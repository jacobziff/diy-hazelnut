// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Incr_map__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incr_map = [0];
   runtime.caml_register_global(0, Incr_map, "Incr_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map__Incr_map_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map_Incr_map_intf = "Incr_map__Incr_map_intf",
    cst_incr_map = "incr_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map_Incr_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[5][1], "src/incr_map_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map_Incr_map_intf);
   var Incr_map_Incr_map_intf = [0];
   runtime.caml_register_global
    (11, Incr_map_Incr_map_intf, cst_Incr_map_Incr_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Core, Core__Bool, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Map, Core__Maybe_bound, Core__Option, Core__Sequence, Core__Set, Core__Tuple, Expect_test_collector, Incr_map__Incr_map_intf, Incremental, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map = "Incr_map",
    cst_incr_map = "incr_map",
    cst_src_incr_map_ml = "src/incr_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Int = global_data.Core__Int,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Incremental = global_data.Incremental,
    Core_Option = global_data.Core__Option,
    Core_Info = global_data.Core__Info,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_List = global_data.Core__List,
    Core_Bool = global_data.Core__Bool,
    Core_Tuple = global_data.Core__Tuple,
    Assert_failure = global_data.Assert_failure,
    Core_Maybe_bound = global_data.Core__Maybe_bound,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Core_Lazy = global_data.Core__Lazy,
    Core_Set = global_data.Core__Set,
    Core_Sequence = global_data.Core__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[5][1], cst_src_incr_map_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map, cst);
   var
    _a_ = [0, cst_src_incr_map_ml, 238, 11],
    _b_ = [0, cst_src_incr_map_ml, 311, 12],
    _c_ = [0, 1],
    _d_ = [0, 1],
    cst_impossible_case_BUG_in_inc =
      "impossible case: BUG in incr_map.ml subrange",
    _e_ = [0, 1],
    cst_BUG_Hit_supposedly_impossi =
      "BUG: Hit supposedly impossible case in Incr_map.index_by",
    _f_ = [0, 1],
    _g_ = [0, "to_"],
    _h_ = [0, "from"],
    cst_Invalid_indices = "Invalid indices",
    _i_ = [0, 0, 0],
    _j_ = [0, cst_src_incr_map_ml, 1195, 10],
    _k_ = [0, cst_src_incr_map_ml, 1194, 10],
    _l_ = [0, cst_src_incr_map_ml, 1210, 6],
    _m_ = [0, [0, 0, 0]],
    _n_ = [0, cst_src_incr_map_ml, 1210, 6],
    _o_ = [0, cst_src_incr_map_ml, 1210, 6],
    _p_ = [0, cst_src_incr_map_ml, 1210, 6],
    _q_ = [0, cst_src_incr_map_ml, 1210, 6],
    _r_ = [0, cst_src_incr_map_ml, 1210, 6],
    _s_ = [0, cst_src_incr_map_ml, 1210, 6],
    _t_ = [0, cst_src_incr_map_ml, 1210, 6],
    _u_ = [0, cst_src_incr_map_ml, 1210, 6],
    _v_ = [0, 1],
    _w_ = [0, 1],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1];
   function with_old(i, f){
    var old = [0, 0];
    return caml_call2
            (Incremental[76][3][5],
             i,
             function(a){
              var b = caml_call2(f, old[1], a);
              old[1] = [0, [0, a, b]];
              return b;
             });
   }
   function unordered_fold
   (opt, update, specialized_initial, _cq_, map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(_cq_)
     var sth$0 = _cq_[1], revert_to_init_when_empty = sth$0;
    else
     var revert_to_init_when_empty = 0;
    function default$0(key, old_data, new_data, acc){
     return caml_call3
             (add, key, new_data, caml_call3(remove, key, old_data, acc));
    }
    var update$0 = caml_call2(Core_Option[34], update, default$0);
    return with_old
            (map,
             function(old, new_in){
              if(! old){
               if(! specialized_initial)
                return caml_call3(Core_Map[55], new_in, init, add);
               var initial = specialized_initial[1];
               return caml_call2(initial, init, new_in);
              }
              var match = old[1], old_out = match[2], old_in = match[1];
              if(revert_to_init_when_empty){
               var _cr_ = caml_call1(Core_Map[29], new_in);
               if(caml_call2(Core[90], _cr_, 0)) return init;
              }
              return caml_call5
                      (Core_Map[81],
                       old_in,
                       new_in,
                       data_equal,
                       old_out,
                       function(acc, param){
                        var change = param[2], key = param[1], _cs_ = change[1];
                        if(847852583 === _cs_){
                         var old = change[2];
                         return caml_call3(remove, key, old, acc);
                        }
                        if(1013247643 <= _cs_){
                         var match = change[2], new$0 = match[2], old$0 = match[1];
                         return caml_call4(update$0, key, old$0, new$0, acc);
                        }
                        var new$1 = change[2];
                        return caml_call3(add, key, new$1, acc);
                       });
             });
   }
   function unordered_fold_nested_maps
   (opt, revert_to_init_when_empty, update, incr_map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(update)
     var update$0 = update[1], update$1 = update$0;
    else
     var
      update$1 =
        function(outer_key, inner_key, old_data, new_data, acc){
         return caml_call4
                 (add,
                  outer_key,
                  inner_key,
                  new_data,
                  caml_call4(remove, outer_key, inner_key, old_data, acc));
        };
    return unordered_fold
            (0,
             [0,
              function(outer_key, old_inner_map, new_inner_map, acc){
               return caml_call2
                       (caml_call3
                         (Core_Map[81], old_inner_map, new_inner_map, data_equal),
                        acc,
                        function(acc, param){
                         var diff = param[2], inner_key = param[1], _cp_ = diff[1];
                         if(847852583 === _cp_){
                          var data_removed = diff[2];
                          return caml_call4
                                  (remove, outer_key, inner_key, data_removed, acc);
                         }
                         if(1013247643 <= _cp_){
                          var
                           match = diff[2],
                           new_data = match[2],
                           old_data = match[1];
                          return caml_call5
                                  (update$1, outer_key, inner_key, old_data, new_data, acc);
                         }
                         var data_added = diff[2];
                         return caml_call4
                                 (add, outer_key, inner_key, data_added, acc);
                        });
              }],
             0,
             revert_to_init_when_empty,
             incr_map,
             init,
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[55],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(add, outer_key, inner_key, data, acc);
                       });
             },
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[55],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(remove, outer_key, inner_key, data, acc);
                       });
             });
   }
   function with_comparator(get_comparator, x, f){
    var
     _cn_ = caml_call2(Incremental[10], x, get_comparator),
     _co_ = caml_call2(Incremental[34], 0, _cn_);
    return caml_call2(Incremental[26], _co_, f);
   }
   function with_comparator$0(map, f){
    return with_comparator(Core_Map[2], map, f);
   }
   function of_set(set){
    return with_comparator
            (Core_Set[5],
             set,
             function(comparator){
              var
               old_input = [0, caml_call1(Core_Set[3][1], comparator)],
               old_output = [0, caml_call1(Core_Map[110][1], comparator)];
              return caml_call2
                      (Incremental[10],
                       set,
                       function(new_input){
                        var
                         _cl_ = old_output[1],
                         _cm_ = caml_call2(Core_Set[17], old_input[1], new_input),
                         new_output =
                           caml_call3
                            (Core_Sequence[18],
                             _cm_,
                             _cl_,
                             function(output, param){
                              if(0 === param[0]){
                               var k = param[1];
                               return caml_call2(Core_Map[41], output, k);
                              }
                              var k$0 = param[1];
                              return caml_call3(Core_Map[31], output, k$0, 0);
                             });
                        old_input[1] = new_input;
                        old_output[1] = new_output;
                        return new_output;
                       });
             });
   }
   function generic_mapi(witness, opt, map){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     return with_old
             (map,
              function(old, input){
               if(0 !== caml_call1(Core_Map[29], input) && old){
                var
                 match = old[1],
                 old_output = match[2],
                 old_input = match[1];
                return caml_call5
                        (Core_Map[81],
                         old_input,
                         input,
                         data_equal,
                         old_output,
                         function(output, param){
                          var change = param[2], key = param[1], _ck_ = change[1];
                          if(847852583 === _ck_)
                           return caml_call2(Core_Map[41], output, key);
                          var
                           new_data = 1013247643 <= _ck_ ? change[2][2] : change[2],
                           res = caml_call2(f, key, new_data);
                          if(! witness)
                           return caml_call3(Core_Map[32], output, key, res);
                          if(! res) return caml_call2(Core_Map[41], output, key);
                          var output_data = res[1];
                          return caml_call3(Core_Map[32], output, key, output_data);
                         });
               }
               return witness
                       ? caml_call2(Core_Map[63], input, f)
                       : caml_call2(Core_Map[52], input, f);
              });};
   }
   function mapi(data_equal, map, f){
    return generic_mapi(0, data_equal, map)(f);
   }
   function filter_mapi(data_equal, map, f){
    return generic_mapi(1, data_equal, map)(f);
   }
   function map(data_equal, map, f){
    return mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map(data_equal, map, f){
    return filter_mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function with_old2(i1, i2, f){
    var old = [0, 0];
    return caml_call3
            (Incremental[12],
             i1,
             i2,
             function(a1, a2){
              var b = caml_call3(f, old[1], a1, a2);
              old[1] = [0, [0, a1, a2, b]];
              return b;
             });
   }
   function mapi_count(opt, input, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     function add(new_key, acc){
      return caml_call3
              (Core_Map[37],
               acc,
               new_key,
               function(param){
                if(! param) return 1;
                var n = param[1];
                return n + 1 | 0;
               });
     }
     function remove(new_key, acc){
      return caml_call3
              (Core_Map[36],
               acc,
               new_key,
               function(param){
                if(! param) return 0;
                var n = param[1];
                return 1 === n ? 0 : [0, n - 1 | 0];
               });
     }
     return unordered_fold
             ([0, data_equal],
              [0,
               function(key, old_data, new_data, acc){
                var
                 prev_key = caml_call2(f, key, old_data),
                 new_key = caml_call2(f, key, new_data),
                 _cj_ = caml_call2(comparator[1][1], prev_key, new_key);
                return caml_call2(Core[90], _cj_, 0)
                        ? acc
                        : add(new_key, remove(prev_key, acc));
               }],
              0,
              0,
              input,
              caml_call1(Core_Map[4], comparator),
              function(key, data, acc){
               return add(caml_call2(f, key, data), acc);
              },
              function(key, data, acc){
               return remove(caml_call2(f, key, data), acc);
              });};
   }
   function map_count(data_equal, input, comparator, f){
    return mapi_count(data_equal, input, comparator)
            (function(param, data){return caml_call1(f, data);});
   }
   function min_helper(map){
    var match = caml_call1(Core_Map[82], map);
    if(! match) return 0;
    var min = match[1][1];
    return [0, min];
   }
   function max_helper(map){
    var match = caml_call1(Core_Map[84], map);
    if(! match) return 0;
    var max = match[1][1];
    return [0, max];
   }
   function bounds_helper(map){
    var
     match = caml_call1(Core_Map[82], map),
     match$0 = caml_call1(Core_Map[84], map);
    if(match){
     if(match$0){
      var max = match$0[1][1], min = match[1][1];
      return [0, [0, min, max]];
     }
    }
    else if(! match$0) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function mapi_min(data_equal, input, comparator, f){
    var _ci_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _ci_, min_helper);
   }
   function mapi_max(data_equal, input, comparator, f){
    var _ch_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _ch_, max_helper);
   }
   function mapi_bounds(data_equal, input, comparator, f){
    var _cg_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _cg_, bounds_helper);
   }
   function mapi_mn(data_equal, input, comparator, f){
    return mapi_min
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function map_max(data_equal, input, comparator, f){
    return mapi_max
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_value(data_equal, input, comparator){
    return mapi_mn
            (data_equal, input, comparator, function(_cf_){return _cf_;});
   }
   function max_value(data_equal, input, comparator){
    return map_max
            (data_equal, input, comparator, function(_ce_){return _ce_;});
   }
   function map_bounds(data_equal, input, comparator, f){
    return mapi_bounds
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function value_bounds(data_equal, input, comparator){
    return map_bounds
            (data_equal, input, comparator, function(_cd_){return _cd_;});
   }
   function merge(opt, _b9_, left_map, right_map, f){
    if(opt)
     var sth = opt[1], data_equal_left = sth;
    else
     var data_equal_left = Core[246];
    if(_b9_)
     var sth$0 = _b9_[1], data_equal_right = sth$0;
    else
     var data_equal_right = Core[246];
    return with_old2
            (left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var comparator = caml_call1(Core_Map[2], new_left_map);
              if(old)
               var
                x = old[1],
                old_output = x[3],
                old_right_map = x[2],
                old_left_map = x[1];
              else
               var
                old_left_map$0 = caml_call1(Core_Map[110][1], comparator),
                old_output = old_left_map$0,
                old_right_map = old_left_map$0,
                old_left_map = old_left_map$0;
              var
               left_diff =
                 caml_call3
                  (Core_Map[80], old_left_map, new_left_map, data_equal_left),
               right_diff =
                 caml_call3
                  (Core_Map[80],
                   old_right_map,
                   new_right_map,
                   data_equal_right),
               _b__ =
                 caml_call3
                  (Core_Sequence[62],
                   left_diff,
                   right_diff,
                   function(param, _cc_){
                    var right_key = _cc_[1], left_key = param[1];
                    return caml_call2(comparator[1], left_key, right_key);
                   });
              return caml_call3
                      (Core_Sequence[18],
                       _b__,
                       old_output,
                       function(output, diff_element){
                        if(2 === diff_element[0]){
                         var
                          right_key = diff_element[2][1],
                          left_key = diff_element[1][1],
                          _ca_ = caml_call2(comparator[1], left_key, right_key);
                         if(! caml_call2(Core[90], _ca_, 0))
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _b_], 1);
                         var key$0 = left_key;
                        }
                        else
                         var key = diff_element[1][1], key$0 = key;
                        function new_data(param){
                         var _cb_ = param[1];
                         if(847852583 === _cb_) return 0;
                         var x = 1013247643 <= _cb_ ? param[2][2] : param[2];
                         return [0, x];
                        }
                        switch(diff_element[0]){
                          case 0:
                           var
                            left_diff = diff_element[1][2],
                            right_data_opt =
                              caml_call2(Core_Map[38], new_right_map, key$0),
                            right_data_opt$0 = right_data_opt,
                            left_data_opt = new_data(left_diff);
                           break;
                          case 1:
                           var
                            right_diff = diff_element[1][2],
                            right_data_opt$1 = new_data(right_diff),
                            right_data_opt$0 = right_data_opt$1,
                            left_data_opt =
                              caml_call2(Core_Map[38], new_left_map, key$0);
                           break;
                          default:
                           var
                            right_diff$0 = diff_element[2][2],
                            left_diff$0 = diff_element[1][2],
                            right_data_opt$2 = new_data(right_diff$0),
                            left_data_opt$0 = new_data(left_diff$0),
                            right_data_opt$0 = right_data_opt$2,
                            left_data_opt = left_data_opt$0;
                        }
                        if(left_data_opt){
                         var x = left_data_opt[1];
                         if(right_data_opt$0)
                          var
                           y = right_data_opt$0[1],
                           _b$_ = caml_call2(f, key$0, [0, 737457313, [0, x, y]]);
                         else
                          var _b$_ = caml_call2(f, key$0, [0, 847852583, x]);
                         var output_data_opt = _b$_;
                        }
                        else if(right_data_opt$0)
                         var
                          y$0 = right_data_opt$0[1],
                          output_data_opt = caml_call2(f, key$0, [0, -57574468, y$0]);
                        else
                         var output_data_opt = 0;
                        if(! output_data_opt)
                         return caml_call2(Core_Map[41], output, key$0);
                        var data = output_data_opt[1];
                        return caml_call3(Core_Map[32], output, key$0, data);
                       });
             });
   }
   function generic_mapi_with_comparator(witness, cutoff, opt, lhs){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(comparator, f){
     var
      incremental_state = caml_call1(Incremental[4], lhs),
      empty_map = caml_call1(Core_Map[110][1], comparator),
      prev_map = [0, empty_map],
      prev_nodes = [0, empty_map],
      acc = [0, empty_map],
      result =
        caml_call3
         (Incremental[79][2][2],
          incremental_state,
          0,
          function(param){return acc[1];}),
      on_inner_change =
        witness
         ? function
          (key, opt){
           var old = acc[1];
           if(opt)
            var
             data = opt[1],
             _b8_ = caml_call3(Core_Map[32], old, key, data);
           else
            var _b8_ = caml_call2(Core_Map[41], old, key);
           acc[1] = _b8_;
           return 0;
          }
         : function
          (key, data){
           acc[1] = caml_call3(Core_Map[32], acc[1], key, data);
           return 0;
          },
      lhs_change = [];
     caml_update_dummy
      (lhs_change,
       [246,
        function(_b1_){
         return caml_call2
                 (Incremental[10],
                  lhs,
                  function(map){
                   var
                    new_nodes =
                      caml_call5
                       (Core_Map[81],
                        prev_map[1],
                        map,
                        data_equal,
                        prev_nodes[1],
                        function(nodes, param){
                         var changed = param[2], key = param[1], _b2_ = changed[1];
                         if(847852583 === _b2_){
                          var
                           match = caml_call2(Core_Map[39], nodes, key),
                           dep = match[2],
                           node = match[1],
                           nodes$0 = caml_call2(Core_Map[41], nodes, key);
                          caml_call2(Incremental[79][2][7], result, dep);
                          acc[1] = caml_call2(Core_Map[41], acc[1], key);
                          caml_call1(Incremental[79][2][5], node);
                          return nodes$0;
                         }
                         if(1013247643 <= _b2_){
                          var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
                          caml_call1(Incremental[79][2][4], node$0);
                          return nodes;
                         }
                         var
                          node$1 =
                            caml_call3
                             (Incremental[79][2][2],
                              incremental_state,
                              0,
                              function(param){
                               return caml_call2(Core_Map[39], prev_map[1], key);
                              });
                         caml_call2
                          (Core_Option[41],
                           cutoff,
                           function(c){
                            var _b7_ = caml_call1(Incremental[79][2][3], node$1);
                            return caml_call2(Incremental[59], _b7_, c);
                           });
                         var
                          _b3_ = caml_call1(Core[237], lhs_change),
                          _b4_ = caml_call2(Incremental[79][1][2], 0, _b3_);
                         caml_call2(Incremental[79][2][6], node$1, _b4_);
                         var
                          _b5_ =
                            caml_call2
                             (f, key, caml_call1(Incremental[79][2][3], node$1)),
                          user_function_dep =
                            caml_call2
                             (Incremental[79][1][2],
                              [0, function(_b6_){return on_inner_change(key, _b6_);}],
                              _b5_);
                         caml_call2(Incremental[79][2][6], result, user_function_dep);
                         return caml_call3
                                 (Core_Map[32], nodes, key, [0, node$1, user_function_dep]);
                        });
                   prev_nodes[1] = new_nodes;
                   prev_map[1] = map;
                   return 0;
                  });
        }]);
     var
      _bZ_ = caml_call1(Core[237], lhs_change),
      _b0_ = caml_call2(Incremental[79][1][2], 0, _bZ_);
     caml_call2(Incremental[79][2][6], result, _b0_);
     return caml_call1(Incremental[79][2][3], result);};
   }
   function filter_mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(1, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(0, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function map$0(cutoff, data_equal, map, f){
    return mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map$0(cutoff, data_equal, map, f){
    return filter_mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function merge$0(cutoff, data_equal_left, data_equal_right, map1, map2, f){
    return filter_mapi$0
            (cutoff,
             0,
             merge
              (data_equal_left,
               data_equal_right,
               map1,
               map2,
               function(param, diff){return [0, diff];}),
             function(key, diff){return caml_call2(f, key, diff);});
   }
   function unzip_mapi
   (data_equal, left_result_equal, right_result_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          if(left_result_equal)
           var sth$0 = left_result_equal[1], left_result_equal$0 = sth$0;
          else
           var left_result_equal$0 = Core[246];
          if(right_result_equal)
           var sth$1 = right_result_equal[1], right_result_equal$0 = sth$1;
          else
           var right_result_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           prev_map = [0, empty_map],
           input_change =
             caml_call2
              (Incremental[10],
               input,
               function(map){
                var
                 match = caml_call1(Core_Map[28], prev_map[1]),
                 match$0 = caml_call1(Core_Map[28], map);
                a:
                {
                 if(match){
                  if(! match$0){
                   var
                    left$0 =
                      caml_call2
                       (Core_Map[52],
                        map,
                        function(key, data){
                         var l = caml_call2(f, key, data)[1];
                         return l;
                        }),
                    right$0 =
                      caml_call2
                       (Core_Map[52],
                        map,
                        function(key, data){
                         var r = caml_call2(f, key, data)[2];
                         return r;
                        }),
                    right = right$0,
                    left = left$0;
                   break a;
                  }
                 }
                 else if(! match$0){
                  var
                   _bU_ =
                     caml_call5
                      (Core_Map[81],
                       prev_map[1],
                       map,
                       data_equal$0,
                       [0, left_acc[1], right_acc[1]],
                       function(param, _bV_){
                        var
                         changed = _bV_[2],
                         key = _bV_[1],
                         right = param[2],
                         left = param[1],
                         _bW_ = changed[1];
                        if(847852583 === _bW_){
                         var _bX_ = caml_call2(Core_Map[41], right, key);
                         return [0, caml_call2(Core_Map[41], left, key), _bX_];
                        }
                        if(1013247643 <= _bW_){
                         var
                          match = changed[2],
                          new$0 = match[2],
                          prev = match[1],
                          match$0 = caml_call2(f, key, prev),
                          prev_b = match$0[2],
                          prev_a = match$0[1],
                          match$1 = caml_call2(f, key, new$0),
                          new_b = match$1[2],
                          new_a = match$1[1],
                          left$0 =
                            caml_call2(left_result_equal$0, prev_a, new_a)
                             ? left
                             : caml_call3(Core_Map[32], left, key, new_a),
                          right$0 =
                            caml_call2(right_result_equal$0, prev_b, new_b)
                             ? right
                             : caml_call3(Core_Map[32], right, key, new_b);
                         return [0, left$0, right$0];
                        }
                        var
                         element = changed[2],
                         match$2 = caml_call2(f, key, element),
                         b = match$2[2],
                         a = match$2[1],
                         _bY_ = caml_call3(Core_Map[32], right, key, b);
                        return [0, caml_call3(Core_Map[32], left, key, a), _bY_];
                       }),
                   right = _bU_[2],
                   left = _bU_[1];
                  break a;
                 }
                 var right = empty_map, left = empty_map;
                }
                if(1 - caml_call2(Core[246], left_acc[1], left))
                 caml_call1(Incremental[79][2][4], left_result);
                if(1 - caml_call2(Core[246], right_acc[1], right))
                 caml_call1(Incremental[79][2][4], right_result);
                left_acc[1] = left;
                right_acc[1] = right;
                prev_map[1] = map;
                return 0;
               }),
           _bQ_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], left_result, _bQ_);
          var _bR_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], right_result, _bR_);
          var
           _bS_ = caml_call1(Incremental[79][2][3], right_result),
           _bT_ = [0, caml_call1(Incremental[79][2][3], left_result), _bS_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _bT_);
         }),
     _bN_ = caml_call2(Incremental[10], pair, function(_bP_){return _bP_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_bO_){return _bO_[1];}),
            _bN_];
   }
   function unzip(left_result_equal, right_result_equal, input){
    var
     data_equal =
       caml_call3
        (Core_Option[23],
         left_result_equal,
         right_result_equal,
         function(l, r){return caml_call2(Core_Tuple[1][10], l, r);});
    return unzip_mapi
            (data_equal,
             left_result_equal,
             right_result_equal,
             input,
             function(param, data){return data;});
   }
   function unzip_mapi$0(cutoff, data_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           prev_map = [0, empty_map],
           prev_nodes = [0, empty_map],
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           input_change = [];
          caml_update_dummy
           (input_change,
            [246,
             function(_bI_){
              return caml_call2
                      (Incremental[10],
                       input,
                       function(map){
                        var
                         new_nodes =
                           caml_call5
                            (Core_Map[81],
                             prev_map[1],
                             map,
                             data_equal$0,
                             prev_nodes[1],
                             function(nodes, param){
                              var changed = param[2], key = param[1], _bJ_ = changed[1];
                              if(847852583 === _bJ_){
                               var
                                match = caml_call2(Core_Map[39], nodes, key),
                                right_dep = match[3],
                                left_dep = match[2],
                                node = match[1],
                                nodes$0 = caml_call2(Core_Map[41], nodes, key);
                               caml_call2(Incremental[79][2][7], left_result, left_dep);
                               caml_call2(Incremental[79][2][7], right_result, right_dep);
                               left_acc[1] = caml_call2(Core_Map[41], left_acc[1], key);
                               right_acc[1] = caml_call2(Core_Map[41], right_acc[1], key);
                               caml_call1(Incremental[79][2][5], node);
                               return nodes$0;
                              }
                              if(1013247643 <= _bJ_){
                               var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
                               caml_call1(Incremental[79][2][4], node$0);
                               return nodes;
                              }
                              var
                               node$1 =
                                 caml_call3
                                  (Incremental[79][2][2],
                                   incremental_state,
                                   0,
                                   function(param){
                                    return caml_call2(Core_Map[39], prev_map[1], key);
                                   });
                              caml_call2
                               (Core_Option[41],
                                cutoff,
                                function(c){
                                 var _bM_ = caml_call1(Incremental[79][2][3], node$1);
                                 return caml_call2(Incremental[59], _bM_, c);
                                });
                              var
                               _bK_ = caml_call1(Core[237], input_change),
                               _bL_ = caml_call2(Incremental[79][1][2], 0, _bK_);
                              caml_call2(Incremental[79][2][6], node$1, _bL_);
                              var
                               match$0 =
                                 caml_call2
                                  (f, key, caml_call1(Incremental[79][2][3], node$1)),
                               right_incr = match$0[2],
                               left_incr = match$0[1],
                               left_user_function_dep =
                                 caml_call2
                                  (Incremental[79][1][2],
                                   [0,
                                    function(data){
                                     left_acc[1] =
                                      caml_call3(Core_Map[32], left_acc[1], key, data);
                                     return 0;
                                    }],
                                   left_incr),
                               right_user_function_dep =
                                 caml_call2
                                  (Incremental[79][1][2],
                                   [0,
                                    function(data){
                                     right_acc[1] =
                                      caml_call3(Core_Map[32], right_acc[1], key, data);
                                     return 0;
                                    }],
                                   right_incr);
                              caml_call2
                               (Incremental[79][2][6], left_result, left_user_function_dep);
                              caml_call2
                               (Incremental[79][2][6],
                                right_result,
                                right_user_function_dep);
                              return caml_call3
                                      (Core_Map[32],
                                       nodes,
                                       key,
                                       [0, node$1, left_user_function_dep, right_user_function_dep]);
                             });
                        prev_nodes[1] = new_nodes;
                        prev_map[1] = map;
                        return 0;
                       });
             }]);
          var
           _bC_ = caml_call1(Core[237], input_change),
           _bD_ = caml_call2(Incremental[79][1][2], 0, _bC_);
          caml_call2(Incremental[79][2][6], left_result, _bD_);
          var
           _bE_ = caml_call1(Core[237], input_change),
           _bF_ = caml_call2(Incremental[79][1][2], 0, _bE_);
          caml_call2(Incremental[79][2][6], right_result, _bF_);
          var
           _bG_ = caml_call1(Incremental[79][2][3], right_result),
           _bH_ = [0, caml_call1(Incremental[79][2][3], left_result), _bG_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _bH_);
         }),
     _bz_ = caml_call2(Incremental[10], pair, function(_bB_){return _bB_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_bA_){return _bA_[1];}),
            _bz_];
   }
   function keys(map){
    return with_comparator$0
            (map,
             function(comparator){
              function add(key, param, acc){
               return caml_call2(Core_Set[11], acc, key);
              }
              function remove(key, param, acc){
               return caml_call2(Core_Set[12], acc, key);
              }
              function data_equal(param, _by_){return 1;}
              return unordered_fold
                      ([0, data_equal],
                       0,
                       0,
                       _c_,
                       map,
                       caml_call1(Core_Set[3][1], comparator),
                       add,
                       remove);
             });
   }
   function partition_mapi(data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              var empty = caml_call1(Core_Map[110][1], comparator);
              return unordered_fold
                      (data_equal,
                       [0,
                        function(key, param, data, _bv_){
                         var
                          second = _bv_[2],
                          first = _bv_[1],
                          match = caml_call2(f, key, data);
                         if(0 === match[0]){
                          var
                           data$0 = match[1],
                           _bw_ = caml_call2(Core_Map[41], second, key);
                          return [0,
                                  caml_call3(Core_Map[32], first, key, data$0),
                                  _bw_];
                         }
                         var
                          data$1 = match[1],
                          _bx_ = caml_call3(Core_Map[32], second, key, data$1);
                         return [0, caml_call2(Core_Map[41], first, key), _bx_];
                        }],
                       0,
                       _d_,
                       map,
                       [0, empty, empty],
                       function(key, data, param){
                        var
                         second = param[2],
                         first = param[1],
                         match = caml_call2(f, key, data);
                        if(0 === match[0]){
                         var data$0 = match[1];
                         return [0,
                                 caml_call3(Core_Map[31], first, key, data$0),
                                 second];
                        }
                        var data$1 = match[1];
                        return [0,
                                first,
                                caml_call3(Core_Map[31], second, key, data$1)];
                       },
                       function(key, param, _bt_){
                        var
                         second = _bt_[2],
                         first = _bt_[1],
                         _bu_ = caml_call2(Core_Map[41], second, key);
                        return [0, caml_call2(Core_Map[41], first, key), _bu_];
                       });
             });
   }
   function flatten(state, map){
    var
     _br_ = caml_call1(Core_Map[2], map),
     result = [0, caml_call1(Core_Map[110][1], _br_)],
     node =
       caml_call3
        (Incremental[79][2][2], state, 0, function(param){return result[1];});
    caml_call2
     (Core_Map[45],
      map,
      function(key, incr){
       var
        _bs_ =
          caml_call2
           (Incremental[79][1][2],
            [0,
             function(a){
              result[1] = caml_call3(Core_Map[32], result[1], key, a);
              return 0;
             }],
            incr);
       return caml_call2(Incremental[79][2][6], node, _bs_);
      });
    return caml_call1(Incremental[79][2][3], node);
   }
   function join(map_incr){
    return with_comparator$0
            (map_incr,
             function(comparator){
              var
               incremental_state = caml_call1(Incremental[4], map_incr),
               empty_map = caml_call1(Core_Map[110][1], comparator),
               result_map = [0, empty_map],
               old_map_of_incrs = [0, empty_map],
               current_dependencies = [0, empty_map],
               result =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return result_map[1];});
              function add_subnode(current_dependencies, key, data_node){
               var
                new_dep =
                  caml_call2
                   (Incremental[79][1][2],
                    [0,
                     function(data){
                      result_map[1] =
                       caml_call3(Core_Map[32], result_map[1], key, data);
                      return 0;
                     }],
                    data_node);
               caml_call2(Incremental[79][2][6], result, new_dep);
               return caml_call3
                       (Core_Map[32], current_dependencies, key, new_dep);
              }
              function remove_subnode(current_dependencies, key){
               var dep = caml_call2(Core_Map[39], current_dependencies, key);
               caml_call2(Incremental[79][2][7], result, dep);
               result_map[1] = caml_call2(Core_Map[41], result_map[1], key);
               return caml_call2(Core_Map[41], current_dependencies, key);
              }
              var
               lhs_change =
                 caml_call2
                  (Incremental[10],
                   map_incr,
                   function(map_of_incrs){
                    var
                     new_dependency_map =
                       caml_call5
                        (Core_Map[81],
                         old_map_of_incrs[1],
                         map_of_incrs,
                         Core[246],
                         current_dependencies[1],
                         function(current_dependencies, param){
                          var diff = param[2], key = param[1], _bq_ = diff[1];
                          if(847852583 === _bq_)
                           return remove_subnode(current_dependencies, key);
                          if(1013247643 <= _bq_){
                           var data_node = diff[2][2];
                           return add_subnode
                                   (remove_subnode(current_dependencies, key), key, data_node);
                          }
                          var data_node$0 = diff[2];
                          return add_subnode(current_dependencies, key, data_node$0);
                         });
                    current_dependencies[1] = new_dependency_map;
                    old_map_of_incrs[1] = map_of_incrs;
                    return 0;
                   }),
               _bp_ = caml_call2(Incremental[79][1][2], 0, lhs_change);
              caml_call2(Incremental[79][2][6], result, _bp_);
              return caml_call1(Incremental[79][2][3], result);
             });
   }
   function separate(input_map, data_equal){
    var incremental_state = caml_call1(Incremental[4], input_map);
    return with_comparator$0
            (input_map,
             function(comparator){
              var
               empty = caml_call1(Core_Map[110][1], comparator),
               state = [0, empty, empty, empty],
               output_map_node =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return state[3];});
              function make_node_depend_on_input_map_(node, input_map_changed){
               var
                _bo_ = caml_call1(Core_Lazy[32], input_map_changed),
                dependency = caml_call2(Incremental[79][1][2], 0, _bo_);
               return caml_call2(Incremental[79][2][6], node, dependency);
              }
              var input_map_changed = [];
              caml_update_dummy
               (input_map_changed,
                [246,
                 function(_bh_){
                  return caml_call2
                          (Incremental[10],
                           input_map,
                           function(input_map){
                            var
                             prev_input_map = state[1],
                             match =
                               caml_call5
                                (Core_Map[81],
                                 prev_input_map,
                                 input_map,
                                 data_equal,
                                 [0, state[2], state[3]],
                                 function(param, _bi_){
                                  var
                                   change = _bi_[2],
                                   key = _bi_[1],
                                   output_map = param[2],
                                   expert_nodes = param[1],
                                   _bj_ = change[1];
                                  if(847852583 === _bj_){
                                   var old_node = caml_call2(Core_Map[39], expert_nodes, key);
                                   caml_call1(Incremental[79][2][5], old_node);
                                   caml_call1(Incremental[79][2][4], output_map_node);
                                   var _bk_ = caml_call2(Core_Map[41], output_map, key);
                                   return [0,
                                           caml_call2(Core_Map[41], expert_nodes, key),
                                           _bk_];
                                  }
                                  if(1013247643 <= _bj_){
                                   var _bl_ = caml_call2(Core_Map[39], expert_nodes, key);
                                   caml_call1(Incremental[79][2][4], _bl_);
                                   return [0, expert_nodes, output_map];
                                  }
                                  var
                                   node =
                                     caml_call3
                                      (Incremental[79][2][2],
                                       incremental_state,
                                       0,
                                       function(param){
                                        return caml_call2(Core_Map[39], state[1], key);
                                       });
                                  make_node_depend_on_input_map_(node, input_map_changed);
                                  caml_call1(Incremental[79][2][4], output_map_node);
                                  var
                                   _bm_ = caml_call1(Incremental[79][2][3], node),
                                   _bn_ = caml_call3(Core_Map[31], output_map, key, _bm_);
                                  return [0,
                                          caml_call3(Core_Map[31], expert_nodes, key, node),
                                          _bn_];
                                 }),
                             output_map = match[2],
                             expert_nodes = match[1];
                            state[1] = input_map;
                            state[2] = expert_nodes;
                            state[3] = output_map;
                            return 0;
                           });
                 }]);
              make_node_depend_on_input_map_
               (output_map_node, input_map_changed);
              return caml_call1(Incremental[79][2][3], output_map_node);
             });
   }
   function subrange(opt, map_incr){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(range){
     return with_old2
             (map_incr,
              range,
              function(old, map, range){
               var compare = caml_call1(Core_Map[2], map)[1];
               function equal(l, r){
                var _bg_ = caml_call2(compare, l, r);
                return caml_call2(Core[90], _bg_, 0);
               }
               function maybe_bound_equal(a_002, b_003){
                if(caml_call2(Ppx_compare_lib[1], a_002, b_003)) return 1;
                if(typeof a_002 === "number"){
                 if(typeof b_003 === "number") return 1;
                 if(1 === b_003[0]) return 0;
                }
                else{
                 if(0 === a_002[0]){
                  var a_004 = a_002[1];
                  if(typeof b_003 !== "number" && 0 === b_003[0]){
                   var b_005 = b_003[1];
                   return equal(a_004, b_005);
                  }
                  return 0;
                 }
                 var a_006 = a_002[1];
                 if(typeof b_003 === "number") return 0;
                 if(0 !== b_003[0]){
                  var b_007 = b_003[1];
                  return equal(a_006, b_007);
                 }
                }
                return 0;
               }
               function range_is_empty(min, max){
                a:
                if(typeof min !== "number"){
                 if(0 === min[0]){
                  var min$0 = min[1];
                  if(typeof max === "number") break a;
                  if(0 === max[0]){
                   var
                    max$0 = max[1],
                    _bd_ = caml_call2(compare, min$0, max$0);
                   return caml_call2(Core[91], _bd_, 0);
                  }
                  var max$1 = max[1], min$1 = min$0;
                 }
                 else{
                  var _bf_ = min[1];
                  if(typeof max === "number") break a;
                  var max$1 = max[1], min$1 = _bf_;
                 }
                 var _be_ = caml_call2(compare, min$1, max$1);
                 return caml_call2(Core[88], _be_, 0);
                }
                return 0;
               }
               function range_includes(min, max, key){
                var
                 _bc_ = caml_call3(Core_Maybe_bound[17], min, key, compare);
                return _bc_
                        ? caml_call3(Core_Maybe_bound[18], max, key, compare)
                        : _bc_;
               }
               if(! range){
                var _a7_ = caml_call1(Core_Map[2], map);
                return caml_call1(Core_Map[110][1], _a7_);
               }
               var range$0 = range[1], max = range$0[2], min = range$0[1];
               function from_scratch(param){
                return caml_call3(Core_Map[94], map, min, max);
               }
               if(old){
                var _a6_ = old[1], match = _a6_[2];
                if(match){
                 var
                  old_range = match[1],
                  old_min = old_range[1],
                  old_map = _a6_[1],
                  old_max = old_range[2];
                 if
                  (!
                   range_is_empty(old_min, old_max)
                   &&
                    !
                    range_is_empty(min, old_max)
                    && ! range_is_empty(old_min, max)){
                  var old_res = _a6_[3], old_max$0 = old_range[2];
                  return caml_call1
                          (Core[260],
                           function(param){
                            function apply_diff_in_intersection(param$0, _a$_){
                             var
                              data = _a$_[2],
                              key = _a$_[1],
                              map = param$0[2],
                              outside = param$0[1],
                              _a__ = range_includes(min, max, key),
                              _ba_ = _a__ ? range_includes(old_min, old_max$0, key) : _a__;
                             if(! _ba_){
                              var outside$0 = outside - 1 | 0;
                              return 0 <= outside$0
                                      ? [0, outside$0, caml_call2(Core_Map[41], map, key)]
                                      : caml_call1(param, from_scratch(0));
                             }
                             var _bb_ = data[1];
                             if(847852583 === _bb_)
                              return [0, outside, caml_call2(Core_Map[41], map, key)];
                             var data$0 = 1013247643 <= _bb_ ? data[2][2] : data[2];
                             return [0,
                                     outside,
                                     caml_call3(Core_Map[32], map, key, data$0)];
                            }
                            var
                             outside_cutoff = caml_call1(Core_Map[29], old_res) / 4 | 0,
                             with_updated_values_in_interse =
                               caml_call5
                                 (Core_Map[81],
                                  old_map,
                                  map,
                                  data_equal,
                                  [0, outside_cutoff, old_res],
                                  apply_diff_in_intersection)
                                [2];
                            if
                             (caml_call4
                               (Core_Tuple[1][10],
                                maybe_bound_equal,
                                maybe_bound_equal,
                                old_range,
                                range$0))
                             return with_updated_values_in_interse;
                            var
                             without_keys_out_of_range =
                               caml_call3
                                (Core_Map[94], with_updated_values_in_interse, min, max);
                            function map_append_exn(lower_part, upper_part){
                             var
                              match = caml_call2(Core_Map[93], lower_part, upper_part);
                             if(typeof match === "number")
                              return caml_call1(Core[6], cst_impossible_case_BUG_in_inc);
                             var map = match[2];
                             return map;
                            }
                            if(typeof old_min === "number")
                             var
                              _a8_ = caml_call1(Core_Map[2], map),
                              lower_part = caml_call1(Core_Map[110][1], _a8_);
                            else if(0 === old_min[0])
                             var
                              old_min$0 = old_min[1],
                              lower_part =
                                caml_call3(Core_Map[94], map, min, [1, old_min$0]);
                            else
                             var
                              old_min$1 = old_min[1],
                              lower_part =
                                caml_call3(Core_Map[94], map, min, [0, old_min$1]);
                            if(typeof old_max$0 === "number")
                             var
                              _a9_ = caml_call1(Core_Map[2], map),
                              upper_part = caml_call1(Core_Map[110][1], _a9_);
                            else if(0 === old_max$0[0])
                             var
                              old_max = old_max$0[1],
                              upper_part =
                                caml_call3(Core_Map[94], map, [1, old_max], max);
                            else
                             var
                              old_max$1 = old_max$0[1],
                              upper_part =
                                caml_call3(Core_Map[94], map, [0, old_max$1], max);
                            var
                             with_new_keys_now_in_range =
                               map_append_exn
                                (lower_part,
                                 map_append_exn(without_keys_out_of_range, upper_part));
                            return with_new_keys_now_in_range;
                           });
                 }
                 return from_scratch(0);
                }
               }
               return from_scratch(0);
              });};
   }
   function rekey(data_equal, map_incr, outer_comparator, f){
    return unordered_fold
            (data_equal,
             [0,
              function(key, old_data, new_data, output){
               var
                prev_key = caml_call2(f, key, old_data),
                new_key = caml_call2(f, key, new_data),
                _a4_ =
                  caml_call2
                   (caml_call1(Core_Map[2], output)[1], prev_key, new_key);
               if(caml_call2(Core[90], _a4_, 0))
                return caml_call3(Core_Map[32], output, new_key, new_data);
               var _a5_ = caml_call2(Core_Map[41], output, prev_key);
               return caml_call3(Core_Map[31], _a5_, new_key, new_data);
              }],
             0,
             _e_,
             map_incr,
             caml_call1(Core_Map[4], outer_comparator),
             function(key, data, output){
              var _a3_ = caml_call2(f, key, data);
              return caml_call3(Core_Map[31], output, _a3_, data);
             },
             function(key, data, output){
              var _a2_ = caml_call2(f, key, data);
              return caml_call2(Core_Map[41], output, _a2_);
             });
   }
   function index_byi(data_equal, map_incr, outer_comparator, index){
    return with_comparator$0
            (map_incr,
             function(inner_comparator){
              return unordered_fold
                      (data_equal,
                       0,
                       0,
                       _f_,
                       map_incr,
                       caml_call1(Core_Map[4], outer_comparator),
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[37],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call3
                                           (Core_Map[110][2], inner_comparator, inner_key, data);
                                  var inner_map = param[1];
                                  return caml_call3(Core_Map[31], inner_map, inner_key, data);
                                 });
                       },
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[36],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call1(Core[6], cst_BUG_Hit_supposedly_impossi);
                                  var
                                   inner_map = param[1],
                                   inner_map$0 = caml_call2(Core_Map[41], inner_map, inner_key);
                                  return caml_call1(Core_Map[28], inner_map$0)
                                          ? 0
                                          : [0, inner_map$0];
                                 });
                       });
             });
   }
   function index_by(data_equal, map_incr, comparator, index){
    return index_byi
            (data_equal,
             map_incr,
             comparator,
             function(param, data){return caml_call1(index, data);});
   }
   function is_known(param){
    if(typeof param === "number" && param) return 0;
    return 1;
   }
   function to_option(param){
    if(typeof param === "number") return 0;
    var k = param[1];
    return [0, k];
   }
   function find_key_range_linear(from, to, map){
    var
     len = caml_call1(Core_Map[29], map),
     begin_key = caml_call2(Core_Int[84], from, len) ? 0 : 1,
     end_key = caml_call2(Core_Int[84], to, len) ? 0 : 1;
    function find_keys(fold, start_pos, advance_pos){
     return caml_call1
             (Core[260],
              function(param){
               return caml_call3
                       (fold,
                        map,
                        [0, begin_key, end_key, start_pos],
                        function(key, param$0, _a1_){
                         var
                          pos = _a1_[3],
                          end_key = _a1_[2],
                          begin_key = _a1_[1],
                          begin_key$0 =
                            caml_call2(Core_Int[86], pos, from) ? [0, key] : begin_key,
                          end_key$0 =
                            caml_call2(Core_Int[86], pos, to) ? [0, key] : end_key;
                         if(is_known(begin_key$0) && is_known(end_key$0))
                          return caml_call1(param, [0, begin_key$0, end_key$0, pos]);
                         return [0,
                                 begin_key$0,
                                 end_key$0,
                                 caml_call1(advance_pos, pos)];
                        });
              });
    }
    var
     match =
       caml_call2(Core[92], to, len - from | 0)
        ? find_keys(Core_Map[55], 0, function(pos){return pos + 1 | 0;})
        : find_keys
          (Core_Map[57], len - 1 | 0, function(pos){return pos - 1 | 0;}),
     end_key$0 = match[2],
     begin_key$0 = match[1],
     _a0_ = to_option(begin_key$0);
    return caml_call2
            (Core_Option[29],
             _a0_,
             function(begin_key){return [0, begin_key, to_option(end_key$0)];});
   }
   function find_offset(compare, key, changed_key, change){
    var _aY_ = caml_call2(compare, changed_key, key);
    if(! caml_call2(Core_Int[88], _aY_, 0)) return 0;
    if(typeof change !== "number"){
     var _aZ_ = change[1];
     if(-57574468 === _aZ_) return -1;
     if(847852583 === _aZ_) return 1;
    }
    return 0;
   }
   function rank(map, key){
    return with_comparator$0
            (map,
             function(comparator){
              var compare_key = comparator[1];
              function same_key(a, b){
               var _aX_ = caml_call2(compare_key, a, b);
               return caml_call2(Core[90], _aX_, 0);
              }
              function process(old, new_map, new_key){
               var old$0 = old;
               for(;;){
                if(! caml_call2(Core_Map[42], new_map, new_key)) return 0;
                if(old$0){
                 var
                  match = old$0[1],
                  old_rank = match[3],
                  old_key = match[2],
                  old_map = match[1];
                 if
                  (caml_call2(Core[246], new_map, old_map)
                   && same_key(old_key, new_key))
                  return old_rank;
                 if(old_rank){
                  var old_rank$0 = old_rank[1];
                  if(! caml_call2(Core[246], new_map, old_map)){
                   if(same_key(new_key, old_key))
                    return [0,
                            caml_call5
                             (Core_Map[81],
                              old_map,
                              new_map,
                              function(param, _aW_){return 1;},
                              old_rank$0,
                              function(acc, param){
                               var diff = param[2], diff_key = param[1];
                               if(typeof diff !== "number"){
                                var _aT_ = diff[1];
                                if(-57574468 === _aT_){
                                 var _aU_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[92], _aU_, 0)) return acc + 1 | 0;
                                }
                                else if(847852583 === _aT_){
                                 var _aV_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[92], _aV_, 0)) return acc - 1 | 0;
                                }
                               }
                               return acc;
                              })];
                   var
                    old_rank$1 =
                      process
                       ([0, [0, old_map, old_key, [0, old_rank$0]]],
                        new_map,
                        old_key),
                    old$1 = [0, [0, new_map, old_key, old_rank$1]];
                   old$0 = old$1;
                   continue;
                  }
                  var _aR_ = caml_call2(compare_key, new_key, old_key);
                  if(caml_call2(Core[92], _aR_, 0))
                   var
                    upper_bound = [1, old_key],
                    lower_bound = [1, new_key],
                    subrange =
                      caml_call3(Core_Map[94], new_map, lower_bound, upper_bound),
                    _aS_ =
                      (old_rank$0 - caml_call1(Core_Map[29], subrange) | 0) - 1
                      | 0;
                  else
                   var
                    upper_bound$0 = [1, new_key],
                    lower_bound$0 = [1, old_key],
                    subrange$0 =
                      caml_call3
                       (Core_Map[94], new_map, lower_bound$0, upper_bound$0),
                    _aS_ =
                      (old_rank$0 + caml_call1(Core_Map[29], subrange$0) | 0) + 1
                      | 0;
                  return [0, _aS_];
                 }
                }
                return caml_call2(Core_Map[100], new_map, new_key);
               }
              }
              return with_old2(map, key, process);
             });
   }
   function subrange_by_rank(data_equal, map, range){
    function find_key_range(range){
     return with_old2
             (map,
              range,
              function(old, map, param){
               var
                to = param[2],
                from = param[1],
                _aB_ = caml_call2(Core_Int[88], to, from),
                _aC_ = _aB_ || caml_call2(Core_Int[88], from, 0);
               if(_aC_){
                var
                 _aD_ =
                   [0, [1, [0, _g_, [0, caml_call1(Core[356], to), 0]]], 0],
                 _aE_ =
                   [0,
                    [1, [0, _h_, [0, caml_call1(Core[356], from), 0]]],
                    _aD_],
                 _aF_ =
                   [1,
                    [0,
                     caml_call1(Sexplib0_Sexp_conv[7], cst_Invalid_indices),
                     _aE_]];
                caml_call1(Core[253], _aF_);
               }
               if(old){
                var _aG_ = old[1], _aH_ = _aG_[3];
                if(_aH_){
                 var
                  _aI_ = _aH_[1],
                  end_key_opt$0 = _aI_[2],
                  begin_key = _aI_[1],
                  match = _aG_[2],
                  old_to = match[2],
                  old_from = match[1],
                  old_map = _aG_[1],
                  _aJ_ = caml_call1(Core_Map[2], map)[1],
                  range_offset_begin = from - old_from | 0,
                  range_offset_end = to - old_to | 0,
                  adjust_and_offset =
                    function(by$1, key$1){
                     a:
                     {
                      if
                       (caml_call2(Core[88], by$1, 0)
                        && ! caml_call2(Core_Map[42], map, key$1)){var _aQ_ = 1; break a;}
                      var _aQ_ = 0;
                     }
                     var by$2 = by$1 + _aQ_ | 0, key = key$1, by = by$2;
                     for(;;){
                      if(caml_call2(Core_Int[86], by, 0)) return [0, key];
                      if(caml_call2(Core_Int[88], by, 0))
                       var add = 1, closest_dir = -640801497;
                      else
                       var add = -1, closest_dir = -779285466;
                      var match = caml_call3(Core_Map[97], map, closest_dir, key);
                      if(! match) return 0;
                      var key$0 = match[1][1], by$0 = by + add | 0;
                      key = key$0;
                      by = by$0;
                     }
                    },
                  diff =
                    function(init, f){
                     return caml_call5
                             (Core_Map[81],
                              old_map,
                              map,
                              function(param, _aP_){return 1;},
                              init,
                              f);
                    };
                 if(end_key_opt$0)
                  var
                   end_key = end_key_opt$0[1],
                   match$0 =
                     diff
                      (_i_,
                       function(param, _aM_){
                        var
                         change = _aM_[2],
                         key = _aM_[1],
                         offset_end = param[2],
                         offset_begin = param[1],
                         _aN_ =
                           offset_end + find_offset(_aJ_, end_key, key, change) | 0;
                        return [0,
                                offset_begin + find_offset(_aJ_, begin_key, key, change) | 0,
                                _aN_];
                       }),
                   map_offset_end = match$0[2],
                   map_offset_begin = match$0[1],
                   end_key_opt$1 =
                     adjust_and_offset
                      (map_offset_end + range_offset_end | 0, end_key),
                   end_key_opt$2 = end_key_opt$1,
                   begin_key_opt =
                     adjust_and_offset
                      (map_offset_begin + range_offset_begin | 0, begin_key);
                 else
                  var
                   map_offset_begin$0 =
                     diff
                      (0,
                       function(offset_begin, param){
                        var change = param[2], key = param[1];
                        return offset_begin
                               + find_offset(_aJ_, begin_key, key, change)
                               | 0;
                       }),
                   _aA_ = find_key_range_linear(to, to, map),
                   end_key_opt =
                     caml_call2
                      (Core_Option[29], _aA_, function(_aO_){return _aO_[1];}),
                   begin_key_opt$0 =
                     adjust_and_offset
                      (map_offset_begin$0 + range_offset_begin | 0, begin_key),
                   end_key_opt$2 = end_key_opt,
                   begin_key_opt = begin_key_opt$0;
                 var _aK_ = caml_call1(Core_Map[42], map);
                 if(! caml_call2(Core_Option[43], begin_key_opt, _aK_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _k_], 1);
                 var _aL_ = caml_call1(Core_Map[42], map);
                 if(caml_call2(Core_Option[43], end_key_opt$2, _aL_))
                  return caml_call2
                          (Core_Option[29],
                           begin_key_opt,
                           function(begin_key){return [0, begin_key, end_key_opt$2];});
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _j_], 1);
                }
               }
               return find_key_range_linear(from, to, map);
              });
    }
    function symbol(new$0, bound){
     return caml_call2
             (Core_Maybe_bound[16], bound, function(param){return new$0;});
    }
    var
     _aq_ = caml_call1(Incremental[4], map),
     return$0 = caml_call1(Incremental[9], _aq_),
     _ar_ =
       caml_call2
        (Incremental[76][3][5],
         range,
         function(param){
          return typeof param[1] === "number"
                  ? typeof param[2] === "number" ? 0 : 3
                  : typeof param[2] === "number" ? 2 : 1;
         }),
     key_range =
       caml_call2
        (Incremental[76][3][1],
         _ar_,
         function(param){
          if(3 < param >>> 0)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
          switch(param){
            case 0:
             return caml_call1(return$0, _m_);
            case 1:
             var
              l =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _az_ = param[1];
                   if(typeof _az_ !== "number"){
                    var pattern_syntax_008 = _az_[1];
                    if(typeof param[2] !== "number") return pattern_syntax_008;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _n_], 1);
                  }),
              lb =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_009 = param[1];
                   if
                    (typeof pattern_syntax_009 !== "number"
                     && typeof param[2] !== "number")
                    return pattern_syntax_009;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _o_], 1);
                  }),
              u =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_010 = match[1];
                     return pattern_syntax_010;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _p_], 1);
                  }),
              ub =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var pattern_syntax_011 = param[2];
                    if(typeof pattern_syntax_011 !== "number")
                     return pattern_syntax_011;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _q_], 1);
                  }),
              let_syntax_016 =
                find_key_range(caml_call2(Incremental[40], l, u)),
              _as_ = caml_call2(Incremental[76][3][20], lb, ub),
              _at_ = caml_call2(Incremental[76][3][20], let_syntax_016, _as_);
             return caml_call2
                     (Incremental[76][3][5],
                      _at_,
                      function(param){
                       var
                        match = param[2],
                        ub = match[2],
                        lb = match[1],
                        key_range = param[1];
                       if(! key_range) return 0;
                       var
                        _ax_ = key_range[1],
                        match$0 = _ax_[2],
                        begin_key = _ax_[1];
                       if(! match$0) return [0, [0, symbol(begin_key, lb), 0]];
                       var end_key = match$0[1], _ay_ = symbol(end_key, ub);
                       return [0, [0, symbol(begin_key, lb), _ay_]];
                      });
            case 2:
             var
              l$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _aw_ = param[1];
                   if(typeof _aw_ !== "number"){
                    var pattern_syntax_012 = _aw_[1];
                    if(typeof param[2] === "number") return pattern_syntax_012;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _r_], 1);
                  }),
              lb$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_013 = param[1];
                   if
                    (typeof pattern_syntax_013 !== "number"
                     && typeof param[2] === "number")
                    return pattern_syntax_013;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _s_], 1);
                  }),
              let_syntax_020 =
                find_key_range(caml_call2(Incremental[40], l$0, l$0)),
              _au_ = caml_call2(Incremental[76][3][20], let_syntax_020, lb$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _au_,
                      function(param){
                       var lb = param[2], key_range = param[1];
                       if(! key_range) return 0;
                       var key = key_range[1][1];
                       return [0, [0, symbol(key, lb), 0]];
                      });
            default:
             var
              u$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_014 = match[1];
                     return pattern_syntax_014;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _t_], 1);
                  }),
              ub$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var pattern_syntax_015 = param[2];
                    if(typeof pattern_syntax_015 !== "number")
                     return pattern_syntax_015;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _u_], 1);
                  }),
              let_syntax_023 =
                find_key_range(caml_call2(Incremental[40], u$0, u$0)),
              _av_ = caml_call2(Incremental[76][3][20], let_syntax_023, ub$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _av_,
                      function(param){
                       var ub = param[2], key_range = param[1];
                       if(! key_range) return 0;
                       var key = key_range[1][1];
                       return [0, [0, 0, symbol(key, ub)]];
                      });
          }
         });
    return subrange(data_equal, map)(key_range);
   }
   function transpose(opt, k2_comparator, m){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return with_comparator$0
            (m,
             function(k1_comparator){
              function update(k1, old_data, new_data, acc){
               return caml_call5
                       (Core_Map[81],
                        old_data,
                        new_data,
                        data_equal,
                        acc,
                        function(acc, param){
                         var diff = param[2], k2 = param[1], _an_ = diff[1];
                         if(847852583 === _an_)
                          var value = 0;
                         else
                          var
                           x = 1013247643 <= _an_ ? diff[2][2] : diff[2],
                           value = [0, x];
                         return caml_call3
                                 (Core_Map[36],
                                  acc,
                                  k2,
                                  function(acc_inner){
                                   var
                                    _ao_ = caml_call1(Core_Map[110][1], k1_comparator),
                                    _ap_ = caml_call2(Core_Option[34], acc_inner, _ao_),
                                    acc_inner$0 =
                                      caml_call3
                                       (Core_Map[36], _ap_, k1, function(param){return value;});
                                   return caml_call1(Core_Map[28], acc_inner$0)
                                           ? 0
                                           : [0, acc_inner$0];
                                  });
                        });
              }
              function add(key, data){
               var _al_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_am_){return update(key, _al_, data, _am_);};
              }
              function remove(key, data){
               var _aj_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_ak_){return update(key, data, _aj_, _ak_);};
              }
              return unordered_fold
                      (0,
                       [0, update],
                       0,
                       _v_,
                       m,
                       caml_call1(Core_Map[4], k2_comparator),
                       add,
                       remove);
             });
   }
   function collapse_by(data_equal, map_incr, merge_keys, comparator){
    return unordered_fold_nested_maps
            (data_equal,
             _w_,
             [0,
              function(outer_key, inner_key, param, new_data, acc){
               var _ai_ = caml_call2(merge_keys, outer_key, inner_key);
               return caml_call3(Core_Map[32], acc, _ai_, new_data);
              }],
             map_incr,
             caml_call1(Core_Map[4], comparator),
             function(outer_key, inner_key, data, acc){
              var _ah_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call3(Core_Map[31], acc, _ah_, data);
             },
             function(outer_key, inner_key, param, acc){
              var _ag_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call2(Core_Map[41], acc, _ag_);
             });
   }
   function collapse(data_equal, map_incr, inner_comparator){
    return with_comparator$0
            (map_incr,
             function(outer_comparator){
              var
               inner_comparator$0 = inner_comparator[1],
               comparator =
                 caml_call2
                  (Core_Tuple[1][5], outer_comparator, inner_comparator$0);
              return collapse_by
                      (data_equal, map_incr, Core_Tuple[1][6], [0, comparator]);
             });
   }
   function expand(data_equal, map_incr, outer_comparator, inner_comparator){
    return unordered_fold
            (data_equal,
             [0,
              function(param, _af_, new_data, acc){
               var inner_key = param[2], outer_key = param[1];
               return caml_call3
                       (Core_Map[37],
                        acc,
                        outer_key,
                        function(param){
                         if(! param)
                          return caml_call3
                                  (Core_Map[5], inner_comparator, inner_key, new_data);
                         var map = param[1];
                         return caml_call3(Core_Map[32], map, inner_key, new_data);
                        });
              }],
             0,
             _x_,
             map_incr,
             caml_call1(Core_Map[4], outer_comparator),
             function(param, data, acc){
              var inner_key = param[2], outer_key = param[1];
              return caml_call3
                      (Core_Map[37],
                       acc,
                       outer_key,
                       function(param){
                        if(! param)
                         return caml_call3
                                 (Core_Map[5], inner_comparator, inner_key, data);
                        var map = param[1];
                        return caml_call3(Core_Map[31], map, inner_key, data);
                       });
             },
             function(param, _ad_, acc){
              var inner_key = param[2], outer_key = param[1];
              return caml_call3
                      (Core_Map[36],
                       acc,
                       outer_key,
                       function(param){
                        if(! param) return 0;
                        var
                         map = param[1],
                         map$0 = caml_call2(Core_Map[41], map, inner_key),
                         _ae_ = 1 - caml_call1(Core_Map[28], map$0);
                        return caml_call2(Core_Option[55], _ae_, map$0);
                       });
             });
   }
   function counti(data_equal, map_incr, f){
    return unordered_fold
            (data_equal,
             0,
             0,
             _y_,
             map_incr,
             0,
             function(key, data, count){
              return caml_call2(f, key, data) ? count + 1 | 0 : count;
             },
             function(key, data, count){
              return caml_call2(f, key, data) ? count - 1 | 0 : count;
             });
   }
   function count(data_equal, map_incr, f){
    return counti
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function existsi(data_equal, map_incr, f){
    var _ac_ = counti(data_equal, map_incr, f);
    return caml_call2
            (Incremental[10],
             _ac_,
             function(count){return caml_call2(Core[93], count, 0);});
   }
   function exists(data_equal, map_incr, f){
    return existsi
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function sum(data_equal, map_incr, Group){
    return function(f){
     return unordered_fold
             (data_equal,
              0,
              0,
              _z_,
              map_incr,
              Group[1],
              function(param, v, acc){
               var _ab_ = caml_call1(f, v);
               return caml_call2(Group[2], acc, _ab_);
              },
              function(param, v, acc){
               var _aa_ = caml_call1(f, v);
               return caml_call2(Group[3], acc, _aa_);
              });};
   }
   function for_alli(data_equal, map_incr, f){
    var
     _$_ =
       counti
        (data_equal,
         map_incr,
         function(key, data){return 1 - caml_call2(f, key, data);});
    return caml_call2
            (Incremental[10],
             _$_,
             function(count){return caml_call2(Core[90], count, 0);});
   }
   function for_all(data_equal, map_incr, f){
    return for_alli
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   var
    For_testing = [0, find_key_range_linear],
    _A_ = [0, "node_is_unnecessary"],
    _B_ = [0, "node_is_invalid"],
    _C_ = [0, "node_is_const"],
    _D_ = [0, "node_info"],
    _E_ = [0, "saved_value"],
    _F_ = [0, "entries"],
    _G_ = [0, "actual_value"],
    _H_ = [0, "key"];
   function M(K){return [0];}
   function create(opt, input_map, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    var self = [];
    caml_update_dummy
     (self,
      [246,
       function(param){
        var
         updater_node =
           caml_call2
            (Incremental[10],
             input_map,
             function(input_map){
              var
               _X_ = caml_obj_tag(self),
               self$0 =
                 250 === _X_
                  ? self[1]
                  : 246 === _X_ ? caml_call1(CamlinternalLazy[2], self) : self;
              caml_call5
               (Core_Map[81],
                self$0[1],
                input_map,
                data_equal,
                0,
                function(param, _Y_){
                 var
                  changed_value = _Y_[2],
                  key = _Y_[1],
                  entries = caml_call2(Core_Map[35], self$0[2], key);
                 return caml_call2
                         (Core_List[9],
                          entries,
                          function(entry){
                           var _Z_ = changed_value[1];
                           if(847852583 === _Z_)
                            var ___ = 0;
                           else
                            var
                             new_value =
                               1013247643 <= _Z_ ? changed_value[2][2] : changed_value[2],
                             ___ = [0, new_value];
                           entry[1] = ___;
                           return caml_call1(Incremental[79][2][4], entry[2]);
                          });
                });
              self$0[1] = input_map;
              return 0;
             }),
         empty_map = caml_call1(Core_Map[110][1], comparator),
         _W_ = caml_call1(Incremental[4], input_map);
        return [0,
                empty_map,
                empty_map,
                updater_node,
                caml_call2(Incremental[50][2], _W_, 0)];
       }]);
    var _V_ = caml_obj_tag(self);
    return 250 === _V_
            ? self[1]
            : 246 === _V_ ? caml_call1(CamlinternalLazy[2], self) : self;
   }
   function find(t, key){
    var match = caml_call2(Core_Map[35], t[2], key);
    if(match){
     var entry = match[1];
     return caml_call1(Incremental[79][2][3], entry[2]);
    }
    var incremental_state = caml_call1(Incremental[4], t[3]);
    return caml_call3
            (Incremental[50][3],
             incremental_state,
             t[4],
             function(param){
              var entry = [];
              caml_update_dummy
               (entry,
                [246,
                 function(param){
                  var
                   _R_ =
                     caml_call3
                      (Incremental[79][2][2],
                       incremental_state,
                       [0,
                        function(is_now_observable){
                         var
                          _S_ = caml_obj_tag(entry),
                          entry$0 =
                            250 === _S_
                             ? entry[1]
                             : 246
                               === _S_
                               ? caml_call1(CamlinternalLazy[2], entry)
                               : entry,
                          current_entries = caml_call2(Core_Map[35], t[2], key),
                          _T_ = caml_call1(Core[246], entry$0),
                          is_linked = caml_call2(Core_List[13], current_entries, _T_);
                         if(caml_call2(Core_Bool[27], is_linked, is_now_observable))
                          return 0;
                         if(is_now_observable){
                          t[2] =
                           caml_call3
                            (Core_Map[37],
                             t[2],
                             key,
                             function(param){
                              if(param){
                               var other_entries = param[1];
                               if(other_entries){
                                var other_entry = other_entries[1];
                                entry$0[1] = other_entry[1];
                                return [0, entry$0, other_entries];
                               }
                              }
                              entry$0[1] = caml_call2(Core_Map[38], t[1], key);
                              return [0, entry$0, 0];
                             });
                          return 0;
                         }
                         var
                          new_entries =
                            caml_call2
                             (Core_List[50],
                              current_entries,
                              function(x){return 1 - caml_call2(Core[246], entry$0, x);}),
                          _U_ =
                            caml_call1(Core_List[8], new_entries)
                             ? caml_call2(Core_Map[41], t[2], key)
                             : caml_call3(Core_Map[32], t[2], key, new_entries);
                         t[2] = _U_;
                         return 0;
                        }],
                       function(param){return caml_call1(Core[237], entry)[1];});
                  return [0, caml_call2(Core_Map[38], t[1], key), _R_];
                 }]);
              var
               _P_ = caml_obj_tag(entry),
               entry$0 =
                 250 === _P_
                  ? entry[1]
                  : 246
                    === _P_
                    ? caml_call1(CamlinternalLazy[2], entry)
                    : entry,
               _Q_ = caml_call2(Incremental[79][1][2], 0, t[3]);
              caml_call2(Incremental[79][2][6], entry$0[2], _Q_);
              return caml_call1(Incremental[79][2][3], entry$0[2]);
             });
   }
   function sexp_of_t(sexp_of_key, sexp_of_value, t){
    var
     info_per_key =
       caml_call3
        (Core_Map[77],
         t[1],
         t[2],
         function(key, data){
          var _I_ = data[1];
          if(737457313 === _I_)
           var
            match = data[2],
            entries = match[2],
            x = match[1],
            actual_value = [0, x],
            entries$0 = entries,
            actual_value$0 = actual_value;
          else if(847852583 <= _I_)
           var x$0 = data[2], entries$0 = 0, actual_value$0 = [0, x$0];
          else
           var y = data[2], entries$0 = y, actual_value$0 = 0;
          var
           match$0 =
             [0,
              [1,
               [0,
                _F_,
                [0,
                 caml_call2
                  (Core[421],
                   function(entry){
                    var
                     saved_value = entry[1],
                     node = entry[2],
                     node$0 = caml_call1(Incremental[79][2][3], node),
                     match = caml_call1(Incremental[67], node$0),
                     _K_ = caml_call1(Incremental[5], node$0),
                     match$0 = caml_call2(Core_Option[55], _K_, 0),
                     _L_ = 1 - caml_call1(Incremental[6], node$0),
                     match$1 = caml_call2(Core_Option[55], _L_, 0),
                     _M_ = 1 - caml_call1(Incremental[7], node$0),
                     _N_ = caml_call2(Core_Option[55], _M_, 0),
                     match$2 = 0;
                    if(_N_)
                     var
                      v = _N_[1],
                      match$3 =
                        [0,
                         [1, [0, _A_, [0, caml_call1(Core[518], v), 0]]],
                         match$2];
                    else
                     var match$3 = match$2;
                    if(match$1)
                     var
                      v$0 = match$1[1],
                      match$4 =
                        [0,
                         [1, [0, _B_, [0, caml_call1(Core[518], v$0), 0]]],
                         match$3];
                    else
                     var match$4 = match$3;
                    if(match$0)
                     var
                      v$1 = match$0[1],
                      match$5 =
                        [0,
                         [1, [0, _C_, [0, caml_call1(Core[518], v$1), 0]]],
                         match$4];
                    else
                     var match$5 = match$4;
                    if(match)
                     var
                      v$2 = match[1],
                      _O_ =
                        [0,
                         [1, [0, _D_, [0, caml_call1(Core_Info[6], v$2), 0]]],
                         match$5];
                    else
                     var _O_ = match$5;
                    return [1,
                            [0,
                             [1,
                              [0,
                               _E_,
                               [0, caml_call2(Core[454], sexp_of_value, saved_value), 0]]],
                             _O_]];
                   },
                   entries$0),
                 0]]],
              0];
          if(actual_value$0)
           var
            v = actual_value$0[1],
            _J_ =
              [0,
               [1, [0, _G_, [0, caml_call1(sexp_of_value, v), 0]]],
               match$0];
          else
           var _J_ = match$0;
          return [0,
                  [1,
                   [0,
                    [1, [0, _H_, [0, caml_call1(sexp_of_key, key), 0]]],
                    _J_]]];
         });
    return [1, caml_call1(Core_Map[73], info_per_key)];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map);
   var
    Incr_map =
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       unordered_fold,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       mapi_mn,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       [0, create, find, M, [0, sexp_of_t]],
       For_testing,
       function(Incr){
        function flatten$0(x){return flatten(Incr[2][3], x);}
        function M(K){return [0];}
        return [0,
                of_set,
                filter_mapi,
                mapi,
                filter_map,
                map,
                filter_mapi$0,
                mapi$0,
                filter_map$0,
                map$0,
                partition_mapi,
                unordered_fold,
                mapi_count,
                map_count,
                mapi_min,
                mapi_max,
                mapi_mn,
                map_max,
                min_value,
                max_value,
                mapi_bounds,
                map_bounds,
                value_bounds,
                merge,
                unzip,
                unzip_mapi,
                unzip_mapi$0,
                merge$0,
                flatten$0,
                join,
                separate,
                keys,
                rank,
                subrange,
                subrange_by_rank,
                rekey,
                index_byi,
                index_by,
                unordered_fold_nested_maps,
                transpose,
                collapse,
                collapse_by,
                expand,
                counti,
                count,
                for_alli,
                for_all,
                existsi,
                exists,
                sum,
                [0, create, find, M, [0, sexp_of_t]],
                For_testing];
       }];
   runtime.caml_register_global(65, Incr_map, cst_Incr_map);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsid2l0aF9vbGQiLCJpIiwiZiIsIm9sZCIsImEiLCJiIiwidW5vcmRlcmVkX2ZvbGQiLCJvcHQiLCJ1cGRhdGUiLCJzcGVjaWFsaXplZF9pbml0aWFsIiwibWFwIiwiaW5pdCIsImFkZCIsInJlbW92ZSIsInN0aCIsImRhdGFfZXF1YWwiLCJzdGgkMCIsInJldmVydF90b19pbml0X3doZW5fZW1wdHkiLCJkZWZhdWx0JDAiLCJrZXkiLCJvbGRfZGF0YSIsIm5ld19kYXRhIiwiYWNjIiwidXBkYXRlJDAiLCJuZXdfaW4iLCJpbml0aWFsIiwib2xkX291dCIsIm9sZF9pbiIsImNoYW5nZSIsIm5ldyQwIiwib2xkJDAiLCJuZXckMSIsInVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzIiwiaW5jcl9tYXAiLCJ1cGRhdGUkMSIsIm91dGVyX2tleSIsImlubmVyX2tleSIsIm9sZF9pbm5lcl9tYXAiLCJuZXdfaW5uZXJfbWFwIiwiZGlmZiIsImRhdGFfcmVtb3ZlZCIsImRhdGFfYWRkZWQiLCJpbm5lcl9tYXAiLCJkYXRhIiwid2l0aF9jb21wYXJhdG9yIiwiZ2V0X2NvbXBhcmF0b3IiLCJ4Iiwid2l0aF9jb21wYXJhdG9yJDAiLCJvZl9zZXQiLCJzZXQiLCJjb21wYXJhdG9yIiwib2xkX2lucHV0Iiwib2xkX291dHB1dCIsIm5ld19pbnB1dCIsIm5ld19vdXRwdXQiLCJvdXRwdXQiLCJrIiwiayQwIiwiZ2VuZXJpY19tYXBpIiwid2l0bmVzcyIsImlucHV0IiwicmVzIiwib3V0cHV0X2RhdGEiLCJtYXBpIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwIiwid2l0aF9vbGQyIiwiaTEiLCJpMiIsImExIiwiYTIiLCJtYXBpX2NvdW50IiwibmV3X2tleSIsIm4iLCJwcmV2X2tleSIsIm1hcF9jb3VudCIsIm1pbl9oZWxwZXIiLCJtaW4iLCJtYXhfaGVscGVyIiwibWF4IiwiYm91bmRzX2hlbHBlciIsIm1hcGlfbWluIiwibWFwaV9tYXgiLCJtYXBpX2JvdW5kcyIsIm1hcGlfbW4iLCJtYXBfbWF4IiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwibWFwX2JvdW5kcyIsInZhbHVlX2JvdW5kcyIsIm1lcmdlIiwibGVmdF9tYXAiLCJyaWdodF9tYXAiLCJkYXRhX2VxdWFsX2xlZnQiLCJkYXRhX2VxdWFsX3JpZ2h0IiwibmV3X2xlZnRfbWFwIiwibmV3X3JpZ2h0X21hcCIsIm9sZF9yaWdodF9tYXAiLCJvbGRfbGVmdF9tYXAiLCJvbGRfbGVmdF9tYXAkMCIsImxlZnRfZGlmZiIsInJpZ2h0X2RpZmYiLCJyaWdodF9rZXkiLCJsZWZ0X2tleSIsImRpZmZfZWxlbWVudCIsImtleSQwIiwicmlnaHRfZGF0YV9vcHQkMCIsImxlZnRfZGF0YV9vcHQiLCJyaWdodF9kaWZmJDAiLCJsZWZ0X2RpZmYkMCIsInJpZ2h0X2RhdGFfb3B0JDIiLCJsZWZ0X2RhdGFfb3B0JDAiLCJ5Iiwib3V0cHV0X2RhdGFfb3B0IiwieSQwIiwiZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvciIsImN1dG9mZiIsImluY3JlbWVudGFsX3N0YXRlIiwiZW1wdHlfbWFwIiwicHJldl9tYXAiLCJwcmV2X25vZGVzIiwicmVzdWx0Iiwib25faW5uZXJfY2hhbmdlIiwibGhzX2NoYW5nZSIsIm5ld19ub2RlcyIsIm5vZGVzIiwiY2hhbmdlZCIsImRlcCIsIm5vZGUiLCJub2RlcyQwIiwibm9kZSQwIiwibm9kZSQxIiwiYyIsInVzZXJfZnVuY3Rpb25fZGVwIiwiZmlsdGVyX21hcGkkMCIsIm1hcGkkMCIsIm1hcCQwIiwiZmlsdGVyX21hcCQwIiwibWVyZ2UkMCIsIm1hcDEiLCJtYXAyIiwidW56aXBfbWFwaSIsImxlZnRfcmVzdWx0X2VxdWFsIiwicmlnaHRfcmVzdWx0X2VxdWFsIiwicGFpciIsImRhdGFfZXF1YWwkMCIsImxlZnRfcmVzdWx0X2VxdWFsJDAiLCJzdGgkMSIsInJpZ2h0X3Jlc3VsdF9lcXVhbCQwIiwibGVmdF9hY2MiLCJsZWZ0X3Jlc3VsdCIsInJpZ2h0X2FjYyIsInJpZ2h0X3Jlc3VsdCIsImlucHV0X2NoYW5nZSIsImxlZnQkMCIsImwiLCJyaWdodCQwIiwiciIsInJpZ2h0IiwibGVmdCIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsInVuemlwIiwidW56aXBfbWFwaSQwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwiZW1wdHkiLCJzZWNvbmQiLCJmaXJzdCIsImRhdGEkMCIsImRhdGEkMSIsImZsYXR0ZW4iLCJzdGF0ZSIsImluY3IiLCJqb2luIiwibWFwX2luY3IiLCJyZXN1bHRfbWFwIiwib2xkX21hcF9vZl9pbmNycyIsImN1cnJlbnRfZGVwZW5kZW5jaWVzIiwiYWRkX3N1Ym5vZGUiLCJkYXRhX25vZGUiLCJuZXdfZGVwIiwicmVtb3ZlX3N1Ym5vZGUiLCJtYXBfb2ZfaW5jcnMiLCJuZXdfZGVwZW5kZW5jeV9tYXAiLCJkYXRhX25vZGUkMCIsInNlcGFyYXRlIiwiaW5wdXRfbWFwIiwib3V0cHV0X21hcF9ub2RlIiwibWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfIiwiaW5wdXRfbWFwX2NoYW5nZWQiLCJkZXBlbmRlbmN5IiwicHJldl9pbnB1dF9tYXAiLCJvdXRwdXRfbWFwIiwiZXhwZXJ0X25vZGVzIiwib2xkX25vZGUiLCJzdWJyYW5nZSIsInJhbmdlIiwiY29tcGFyZSIsImVxdWFsIiwibWF5YmVfYm91bmRfZXF1YWwiLCJhXzAwMiIsImJfMDAzIiwiYV8wMDQiLCJiXzAwNSIsImFfMDA2IiwiYl8wMDciLCJyYW5nZV9pc19lbXB0eSIsIm1pbiQwIiwibWF4JDAiLCJtYXgkMSIsIm1pbiQxIiwicmFuZ2VfaW5jbHVkZXMiLCJyYW5nZSQwIiwiZnJvbV9zY3JhdGNoIiwib2xkX3JhbmdlIiwib2xkX21pbiIsIm9sZF9tYXAiLCJvbGRfbWF4Iiwib2xkX3JlcyIsIm9sZF9tYXgkMCIsInBhcmFtIiwiYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24iLCJvdXRzaWRlIiwib3V0c2lkZSQwIiwib3V0c2lkZV9jdXRvZmYiLCJ3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2UiLCJ3aXRob3V0X2tleXNfb3V0X29mX3JhbmdlIiwibWFwX2FwcGVuZF9leG4iLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm9sZF9taW4kMCIsIm9sZF9taW4kMSIsIm9sZF9tYXgkMSIsIndpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlIiwicmVrZXkiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5kZXhfYnlpIiwiaW5kZXgiLCJpbm5lcl9jb21wYXJhdG9yIiwib3V0ZXJfbWFwIiwiaW5uZXJfbWFwJDAiLCJpbmRleF9ieSIsImlzX2tub3duIiwidG9fb3B0aW9uIiwiZmluZF9rZXlfcmFuZ2VfbGluZWFyIiwiZnJvbSIsInRvIiwibGVuIiwiYmVnaW5fa2V5IiwiZW5kX2tleSIsImZpbmRfa2V5cyIsImZvbGQiLCJzdGFydF9wb3MiLCJhZHZhbmNlX3BvcyIsInBvcyIsImJlZ2luX2tleSQwIiwiZW5kX2tleSQwIiwiZmluZF9vZmZzZXQiLCJjaGFuZ2VkX2tleSIsInJhbmsiLCJjb21wYXJlX2tleSIsInNhbWVfa2V5IiwicHJvY2VzcyIsIm5ld19tYXAiLCJvbGRfcmFuayIsIm9sZF9rZXkiLCJvbGRfcmFuayQwIiwiZGlmZl9rZXkiLCJvbGRfcmFuayQxIiwib2xkJDEiLCJ1cHBlcl9ib3VuZCIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQkMCIsImxvd2VyX2JvdW5kJDAiLCJzdWJyYW5nZSQwIiwic3VicmFuZ2VfYnlfcmFuayIsImZpbmRfa2V5X3JhbmdlIiwiZW5kX2tleV9vcHQkMCIsIm9sZF90byIsIm9sZF9mcm9tIiwicmFuZ2Vfb2Zmc2V0X2JlZ2luIiwicmFuZ2Vfb2Zmc2V0X2VuZCIsImFkanVzdF9hbmRfb2Zmc2V0IiwiYnkkMSIsImtleSQxIiwiYnkkMiIsImJ5IiwiY2xvc2VzdF9kaXIiLCJieSQwIiwib2Zmc2V0X2VuZCIsIm9mZnNldF9iZWdpbiIsIm1hcF9vZmZzZXRfZW5kIiwibWFwX29mZnNldF9iZWdpbiIsImVuZF9rZXlfb3B0JDIiLCJiZWdpbl9rZXlfb3B0IiwibWFwX29mZnNldF9iZWdpbiQwIiwiZW5kX2tleV9vcHQiLCJiZWdpbl9rZXlfb3B0JDAiLCJzeW1ib2wiLCJib3VuZCIsInJldHVybiQwIiwia2V5X3JhbmdlIiwicGF0dGVybl9zeW50YXhfMDA4IiwibGIiLCJwYXR0ZXJuX3N5bnRheF8wMDkiLCJ1IiwicGF0dGVybl9zeW50YXhfMDEwIiwidWIiLCJwYXR0ZXJuX3N5bnRheF8wMTEiLCJsZXRfc3ludGF4XzAxNiIsImwkMCIsInBhdHRlcm5fc3ludGF4XzAxMiIsImxiJDAiLCJwYXR0ZXJuX3N5bnRheF8wMTMiLCJsZXRfc3ludGF4XzAyMCIsInUkMCIsInBhdHRlcm5fc3ludGF4XzAxNCIsInViJDAiLCJwYXR0ZXJuX3N5bnRheF8wMTUiLCJsZXRfc3ludGF4XzAyMyIsInRyYW5zcG9zZSIsImsyX2NvbXBhcmF0b3IiLCJtIiwiazFfY29tcGFyYXRvciIsImsxIiwiazIiLCJ2YWx1ZSIsImFjY19pbm5lciIsImFjY19pbm5lciQwIiwiY29sbGFwc2VfYnkiLCJtZXJnZV9rZXlzIiwiY29sbGFwc2UiLCJpbm5lcl9jb21wYXJhdG9yJDAiLCJleHBhbmQiLCJjb3VudGkiLCJjb3VudCIsImV4aXN0c2kiLCJleGlzdHMiLCJzdW0iLCJHcm91cCIsInYiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJjcmVhdGUiLCJzZWxmIiwidXBkYXRlcl9ub2RlIiwic2VsZiQwIiwiY2hhbmdlZF92YWx1ZSIsImVudHJpZXMiLCJlbnRyeSIsIm5ld192YWx1ZSIsImZpbmQiLCJ0IiwiaXNfbm93X29ic2VydmFibGUiLCJlbnRyeSQwIiwiY3VycmVudF9lbnRyaWVzIiwiaXNfbGlua2VkIiwib3RoZXJfZW50cmllcyIsIm90aGVyX2VudHJ5IiwibmV3X2VudHJpZXMiLCJzZXhwX29mX3QiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsdWUiLCJpbmZvX3Blcl9rZXkiLCJhY3R1YWxfdmFsdWUiLCJlbnRyaWVzJDAiLCJhY3R1YWxfdmFsdWUkMCIsIngkMCIsIm1hdGNoJDAiLCJzYXZlZF92YWx1ZSIsIm1hdGNoJDIiLCJtYXRjaCQzIiwidiQwIiwibWF0Y2gkNCIsInYkMSIsIm1hdGNoJDUiLCJ2JDIiLCJmbGF0dGVuJDAiXSwic291cmNlcyI6WyIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvaW5jcl9tYXAvaW5jcl9tYXAubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFtQk1BLFNBQVNDLEdBQUdDO0lBRUosSUFBTkM7OzthQUZPRjtzQkFHSEc7Y0FDQSxJQUFKQyxJQUFJLFdBSk1ILEdBRVZDLFFBQ0lDO2NBREpELGlCQUNJQyxHQUNKQztjQUVKLE9BRklBO2FBRUg7R0FBQTtZQUdDQztJQUNJQyxLQUNEQyxRQUNBQywyQkFFREMsS0FDQ0MsTUFDQUMsS0FDQUM7SUFFTCxHQVRNTjtTQUFhTyxNQUFiUCxRQUFBUSxhQUFhRDs7U0FBYkM7SUFTTjtTQU5rQ0MsaUJBQTVCQyw0QkFBNEJEOztTQUE1QkM7YUFPQUMsVUFBU0MsS0FBS0MsVUFBVUMsVUFBU0M7S0FDbkMsT0FBd0I7Y0FMdkJWLEtBSVVPLEtBQWVFLFVBQ0YsV0FKdkJSLFFBR1VNLEtBQUtDLFVBQW1CRTtJQUNxQjtJQUUxRCxJQUpFQyxXQUlGLDRCQVpHZixRQVNDVTtJQUtVLE9BekJkbEI7YUFj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Z0JBeUVBVztnQkFyQkFGO2dCQWlEQUk7Z0JBc0JBQztnQkFVQUM7Z0JBNEJBTTtnQkFNQUM7Z0JBOUJBTjtnQkFJQUM7Z0JBSUFDO29CQXFERUssUUErRUFRLGFBd0JTUzs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbmluY2x1ZGUgSW5jcl9tYXBfaW50ZlxuXG4oKiogVGhpcyB0eXBlIGxldHMgdXMgY2FwdHVyZSB0aGUga2luZCBvZiBtYXAgZnVuY3Rpb24gYmVpbmcgcGVyZm9ybWVkLCBzbyB3ZSBjYW4gd2l0aFxuICAgIG9uZSBpbXBsZW1lbnRhdGlvbiBwZXJmb3JtIG1hcCBhbmQgZmlsdGVyLW1hcCBvcGVyYXRpb25zLlxuXG4gICAgSGVyZSwgWydpbnB1dF9kYXRhXSBpcyB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBpbnB1dCBtYXAsIFsnb3V0cHV0X2RhdGFdIGlzIHRoZSB0eXBlXG4gICAgb2YgZGF0YSBpbiB0aGUgb3V0cHV0IG1hcCwgYW5kIFsnZl9vdXRwdXRdIGlzIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgW35mXSBmdW5jdGlvblxuICAgIHBhc3NlZCB0byB0aGUgbWFwcGluZyBmdW5jdGlvbi4gKilcbm1vZHVsZSBNYXBfdHlwZSA9IHN0cnVjdFxuICB0eXBlICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnZl9vdXRwdXQpIHQgPVxuICAgIHwgTWFwIDogKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSkgdFxuICAgIHwgRmlsdGVyX21hcCA6ICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnb3V0cHV0X2RhdGEgb3B0aW9uKSB0XG5cbiAgKCogVGhlIGV4dHJhIHR5cGUgdmFyaWFibGUgJ2EgaXMgdG8gYWxsb3cgaW4gZnV0dXJlOlxuICAgICB8IEZpbHRlciA6ICgnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgYm9vbCkgdCAqKVxuZW5kXG5cbm1vZHVsZSBHZW5lcmljID0gc3RydWN0XG4gIGxldCB3aXRoX29sZCBpIH5mID1cbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgbGV0JW1hcCBhID0gaSBpblxuICAgIGxldCBiID0gZiB+b2xkOiFvbGQgYSBpblxuICAgIG9sZCA6PSBTb21lIChhLCBiKTtcbiAgICBiXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID91cGRhdGVcbiAgICAgICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICAgICAgPyhyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5ID0gZmFsc2UpXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBsZXQgZGVmYXVsdCB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjID1cbiAgICAgICAgYWRkIH5rZXkgfmRhdGE6bmV3X2RhdGEgKHJlbW92ZSB+a2V5IH5kYXRhOm9sZF9kYXRhIGFjYylcbiAgICAgIGluXG4gICAgICBPcHRpb24udmFsdWUgdXBkYXRlIH5kZWZhdWx0XG4gICAgaW5cbiAgICB3aXRoX29sZCBtYXAgfmY6KGZ1biB+b2xkIG5ld19pbiAtPlxuICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAobWF0Y2ggc3BlY2lhbGl6ZWRfaW5pdGlhbCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gTWFwLmZvbGQgfmluaXQgfmY6YWRkIG5ld19pblxuICAgICAgICAgfCBTb21lIGluaXRpYWwgLT4gaW5pdGlhbCB+aW5pdCBuZXdfaW4pXG4gICAgICB8IFNvbWUgKG9sZF9pbiwgb2xkX291dCkgLT5cbiAgICAgICAgaWYgcmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSAmJiBNYXAubGVuZ3RoIG5ld19pbiA9IDBcbiAgICAgICAgdGhlbiBpbml0XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgfmluaXQ6b2xkX291dFxuICAgICAgICAgICAgb2xkX2luXG4gICAgICAgICAgICBuZXdfaW5cbiAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICB+ZjooZnVuIGFjYyAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgb2xkIC0+IHJlbW92ZSB+a2V5IH5kYXRhOm9sZCBhY2NcbiAgICAgICAgICAgICAgfCBgUmlnaHQgbmV3XyAtPiBhZGQgfmtleSB+ZGF0YTpuZXdfIGFjY1xuICAgICAgICAgICAgICB8IGBVbmVxdWFsIChvbGQsIG5ld18pIC0+IHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTpvbGQgfm5ld19kYXRhOm5ld18gYWNjKSlcbiAgOztcblxuICBsZXQgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgICAgP3VwZGF0ZVxuICAgICAgICBpbmNyX21hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBtYXRjaCB1cGRhdGUgd2l0aFxuICAgICAgfCBTb21lIHVwZGF0ZSAtPiB1cGRhdGVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgICAgYWRkXG4gICAgICAgICAgICB+b3V0ZXJfa2V5XG4gICAgICAgICAgICB+aW5uZXJfa2V5XG4gICAgICAgICAgICB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICAgICAgKHJlbW92ZSB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6b2xkX2RhdGEgYWNjKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIGluY3JfbWFwXG4gICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgfmluaXRcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5Om91dGVyX2tleSB+b2xkX2RhdGE6b2xkX2lubmVyX21hcCB+bmV3X2RhdGE6bmV3X2lubmVyX21hcCBhY2MgLT5cbiAgICAgICAgKE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmIG9sZF9pbm5lcl9tYXAgbmV3X2lubmVyX21hcCB+ZGF0YV9lcXVhbClcbiAgICAgICAgICB+aW5pdDphY2NcbiAgICAgICAgICB+ZjooZnVuIGFjYyAoaW5uZXJfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IGRhdGFfcmVtb3ZlZCAtPiByZW1vdmUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOmRhdGFfcmVtb3ZlZCBhY2NcbiAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfYWRkZWQgLT4gYWRkIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX2FkZGVkIGFjY1xuICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkX2RhdGEsIG5ld19kYXRhKSAtPlxuICAgICAgICAgICAgICB1cGRhdGUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjKSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIE1hcC5mb2xkIGlubmVyX21hcCB+aW5pdDphY2MgfmY6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYykpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICA7O1xuXG4gIGxldCB3aXRoX2NvbXBhcmF0b3InIGdldF9jb21wYXJhdG9yIHggZiA9XG4gICAgSW5jcmVtZW50YWwuYmluZCAoSW5jcmVtZW50YWwuZnJlZXplIChJbmNyZW1lbnRhbC5tYXAgeCB+ZjpnZXRfY29tcGFyYXRvcikpIH5mXG4gIDs7XG5cbiAgKCoqIENhcHR1cmVzIHRoZSBjb21wYXJhdG9yICh3aGljaCBjYW4ndCBjaGFuZ2UgYW55d2F5LCBzaW5jZSB0aGUgdHlwZSBkZXRlcm1pbmVzIHRoZVxuICAgICAgY29tcGFyYXRvcikgYnkgZnJlZXppbmcgdGhlIGNvcnJlc3BvbmRpbmcgbWFwLiAgTm90ZSB0aGF0IGJ5IGZpcnN0IHVzaW5nIEluY3JlbWVudGFsLm1hcCB0b1xuICAgICAgZ2V0IHRoZSBjb21wYXJhdG9yIG91dCBvZiB0aGUgbWFwLCB3ZSBhbGxvdyB0aGUgaW5pdGlhbCBtYXAgaXRzZWxmIHRvIGJlIGdhcmJhZ2VcbiAgICAgIGNvbGxlY3RlZCAqKVxuICBsZXQgd2l0aF9jb21wYXJhdG9yIG1hcCBmID0gd2l0aF9jb21wYXJhdG9yJyBNYXAuY29tcGFyYXRvciBtYXAgZlxuXG4gIGxldCBvZl9zZXQgc2V0ID1cbiAgICB3aXRoX2NvbXBhcmF0b3InIFNldC5jb21wYXJhdG9yIHNldCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBvbGRfaW5wdXQgPSByZWYgKFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgbGV0IG9sZF9vdXRwdXQgPSByZWYgKE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgSW5jcmVtZW50YWwubWFwIHNldCB+ZjooZnVuIG5ld19pbnB1dCAtPlxuICAgICAgICBsZXQgbmV3X291dHB1dCA9XG4gICAgICAgICAgU2VxdWVuY2UuZm9sZFxuICAgICAgICAgICAgKFNldC5zeW1tZXRyaWNfZGlmZiAhb2xkX2lucHV0IG5ld19pbnB1dClcbiAgICAgICAgICAgIH5pbml0OiFvbGRfb3V0cHV0XG4gICAgICAgICAgICB+ZjooZnVuIG91dHB1dCAtPiBmdW5jdGlvblxuICAgICAgICAgICAgICB8IEZpcnN0IGsgLT4gTWFwLnJlbW92ZSBvdXRwdXQga1xuICAgICAgICAgICAgICB8IFNlY29uZCBrIC0+IE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5OmsgfmRhdGE6KCkpXG4gICAgICAgIGluXG4gICAgICAgIG9sZF9pbnB1dCA6PSBuZXdfaW5wdXQ7XG4gICAgICAgIG9sZF9vdXRwdXQgOj0gbmV3X291dHB1dDtcbiAgICAgICAgbmV3X291dHB1dCkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaVxuICAgICAgICAodHlwZSBpbnB1dF9kYXRhIG91dHB1dF9kYXRhIGZfb3V0cHV0IHN0YXRlX3dpdG5lc3MpXG4gICAgICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKG1hcCA6ICgoJ2tleSwgaW5wdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oZiA6IGtleTona2V5IC0+IGRhdGE6aW5wdXRfZGF0YSAtPiBmX291dHB1dClcbiAgICA9XG4gICAgd2l0aF9vbGQgbWFwIH5mOihmdW4gfm9sZCBpbnB1dCAtPlxuICAgICAgbWF0Y2ggb2xkLCBNYXAubGVuZ3RoIGlucHV0IHdpdGhcbiAgICAgIHwgXywgMCB8IE5vbmUsIF8gLT5cbiAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gKE1hcC5tYXBpIGlucHV0IH5mIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudClcbiAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPiBNYXAuZmlsdGVyX21hcGkgaW5wdXQgfmYpXG4gICAgICB8IFNvbWUgKG9sZF9pbnB1dCwgb2xkX291dHB1dCksIF8gLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICBvbGRfaW5wdXRcbiAgICAgICAgICBpbnB1dFxuICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgfmluaXQ6b2xkX291dHB1dFxuICAgICAgICAgIH5mOihmdW4gb3V0cHV0IChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5XG4gICAgICAgICAgICB8IGBSaWdodCBuZXdfZGF0YSB8IGBVbmVxdWFsIChfLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgICAgbGV0IHJlcyA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICAgICAgICAobWF0Y2ggd2l0bmVzcyB3aXRoXG4gICAgICAgICAgICAgICB8IE1hcF90eXBlLk1hcCAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOnJlc1xuICAgICAgICAgICAgICAgfCBNYXBfdHlwZS5GaWx0ZXJfbWFwIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCByZXMgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgICAgICAgfCBTb21lIG91dHB1dF9kYXRhIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGE6b3V0cHV0X2RhdGEpKSkpXG4gIDs7XG5cbiAgbGV0IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID0gZ2VuZXJpY19tYXBpIE1hcCA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgbGV0IGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZiA9IGdlbmVyaWNfbWFwaSBGaWx0ZXJfbWFwID9kYXRhX2VxdWFsIG1hcCB+ZlxuICBsZXQgbWFwID9kYXRhX2VxdWFsIG1hcCB+ZiA9IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxuICBsZXQgZmlsdGVyX21hcCA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHdpdGhfb2xkMiBpMSBpMiB+ZiA9XG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgSW5jcmVtZW50YWwubWFwMiBpMSBpMiB+ZjooZnVuIGExIGEyIC0+XG4gICAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGExIGEyIGluXG4gICAgICBvbGQgOj0gU29tZSAoYTEsIGEyLCBiKTtcbiAgICAgIGIpXG4gIDs7XG5cbiAgbGV0IG1hcGlfY291bnRcbiAgICAgICAgKHR5cGUgYSBjbXApXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGlucHV0XG4gICAgICAgIH4oY29tcGFyYXRvciA6XG4gICAgICAgICAgICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGEgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKSlcbiAgICAgICAgfmZcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBNID0gKHZhbCBjb21wYXJhdG9yKSBpblxuICAgIGxldCBhZGQgbmV3X2tleSBhY2MgPVxuICAgICAgTWFwLnVwZGF0ZSBhY2MgbmV3X2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgfCBTb21lIG4gLT4gbiArIDEpXG4gICAgaW5cbiAgICBsZXQgcmVtb3ZlIG5ld19rZXkgYWNjID1cbiAgICAgIE1hcC5jaGFuZ2UgYWNjIG5ld19rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSAxIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIG4gLT4gU29tZSAobiAtIDEpKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIE0pKVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCAoZiB+a2V5IH5kYXRhKSBhY2MpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIChmIH5rZXkgfmRhdGEpIGFjYylcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIGxldCBwcmV2X2tleSA9IGYgfmtleSB+ZGF0YTpvbGRfZGF0YSBpblxuICAgICAgICBsZXQgbmV3X2tleSA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICBpZiBNLmNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIGFjY1xuICAgICAgICBlbHNlIGFjYyB8PiByZW1vdmUgcHJldl9rZXkgfD4gYWRkIG5ld19rZXkpXG4gIDs7XG5cbiAgbGV0IG1hcF9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1pbl9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtaW4sIF8pIC0+IFNvbWUgbWluXG4gIDs7XG5cbiAgbGV0IG1heF9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWF4X2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtYXgsIF8pIC0+IFNvbWUgbWF4XG4gIDs7XG5cbiAgbGV0IGJvdW5kc19oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAsIE1hcC5tYXhfZWx0IG1hcCB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKG1pbiwgXyksIFNvbWUgKG1heCwgXykgLT4gU29tZSAobWluLCBtYXgpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwIH5mOm1pbl9oZWxwZXIgKG1hcGlfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6bWF4X2hlbHBlciAobWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwaV9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpib3VuZHNfaGVscGVyIChtYXBpX2NvdW50ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1hcF9tYXggP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgbWluX3ZhbHVlID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yID1cbiAgICBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1heF92YWx1ZSA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX21heCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtYXBfYm91bmRzID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtZXJnZVxuICAgICAgICA/KGRhdGFfZXF1YWxfbGVmdCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8oZGF0YV9lcXVhbF9yaWdodCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGxlZnRfbWFwXG4gICAgICAgIHJpZ2h0X21hcFxuICAgICAgICB+ZlxuICAgID1cbiAgICB3aXRoX29sZDIgbGVmdF9tYXAgcmlnaHRfbWFwIH5mOihmdW4gfm9sZCBuZXdfbGVmdF9tYXAgbmV3X3JpZ2h0X21hcCAtPlxuICAgICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBuZXdfbGVmdF9tYXAgaW5cbiAgICAgIGxldCBvbGRfbGVmdF9tYXAsIG9sZF9yaWdodF9tYXAsIG9sZF9vdXRwdXQgPVxuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICAgICAgfCBTb21lIHggLT4geFxuICAgICAgaW5cbiAgICAgIGxldCBsZWZ0X2RpZmYgPVxuICAgICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX2xlZnRfbWFwIG5ld19sZWZ0X21hcCB+ZGF0YV9lcXVhbDpkYXRhX2VxdWFsX2xlZnRcbiAgICAgIGluXG4gICAgICBsZXQgcmlnaHRfZGlmZiA9XG4gICAgICAgIE1hcC5zeW1tZXRyaWNfZGlmZiBvbGRfcmlnaHRfbWFwIG5ld19yaWdodF9tYXAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgaW5cbiAgICAgICgqIFdlIG1lcmdlIHRoZSB0d28gc2lkZXMgb2YgdGhlIGRpZmZzIHRvZ2V0aGVyIHNvIHdlIGNhbiBtYWtlIHN1cmUgdG8gaGFuZGxlIGVhY2hcbiAgICAgICAgIGtleSBleGFjdGx5IG9uY2UuIFRoaXMgcmVsaWVzIG9uIHN5bW1ldHJpYyBkaWZmIGdpdmluZyBzb3J0ZWQgb3V0cHV0LiAqKVxuICAgICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAgIGxlZnRfZGlmZlxuICAgICAgICByaWdodF9kaWZmXG4gICAgICAgIH5jb21wYXJlOihmdW4gKGxlZnRfa2V5LCBfKSAocmlnaHRfa2V5LCBfKSAtPlxuICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZSBsZWZ0X2tleSByaWdodF9rZXkpXG4gICAgICB8PiBTZXF1ZW5jZS5mb2xkIH5pbml0Om9sZF9vdXRwdXQgfmY6KGZ1biBvdXRwdXQgZGlmZl9lbGVtZW50IC0+XG4gICAgICAgIGxldCBrZXkgPVxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBMZWZ0IChrZXksIF8pIHwgUmlnaHQgKGtleSwgXykgLT4ga2V5XG4gICAgICAgICAgfCBCb3RoICgobGVmdF9rZXksIF8pLCAocmlnaHRfa2V5LCBfKSkgLT5cbiAgICAgICAgICAgIGFzc2VydCAoY29tcGFyYXRvci5jb21wYXJlIGxlZnRfa2V5IHJpZ2h0X2tleSA9IDApO1xuICAgICAgICAgICAgbGVmdF9rZXlcbiAgICAgICAgaW5cbiAgICAgICAgKCogVGhlc2UgdmFsdWVzIHJlcHJlc2VudCB3aGV0aGVyIHRoZXJlIGlzIGRhdGEgZm9yIHRoZSBnaXZlbiBrZXkgaW4gdGhlIG5ld1xuICAgICAgICAgICBpbnB1dCBpbiB0aGUgbGVmdCBhbmQgcmlnaHQgbWFwLiAqKVxuICAgICAgICBsZXQgbGVmdF9kYXRhX29wdCwgcmlnaHRfZGF0YV9vcHQgPVxuICAgICAgICAgIGxldCBuZXdfZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBCb3RoICgoXywgbGVmdF9kaWZmKSwgKF8sIHJpZ2h0X2RpZmYpKSAtPlxuICAgICAgICAgICAgbmV3X2RhdGEgbGVmdF9kaWZmLCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgICAgfCBMZWZ0IChfLCBsZWZ0X2RpZmYpIC0+IG5ld19kYXRhIGxlZnRfZGlmZiwgTWFwLmZpbmQgbmV3X3JpZ2h0X21hcCBrZXlcbiAgICAgICAgICB8IFJpZ2h0IChfLCByaWdodF9kaWZmKSAtPiBNYXAuZmluZCBuZXdfbGVmdF9tYXAga2V5LCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvdXRwdXRfZGF0YV9vcHQgPVxuICAgICAgICAgIG1hdGNoIGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0IHdpdGhcbiAgICAgICAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSB4LCBOb25lIC0+IGYgfmtleSAoYExlZnQgeClcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgeSAtPiBmIH5rZXkgKGBSaWdodCB5KVxuICAgICAgICAgIHwgU29tZSB4LCBTb21lIHkgLT4gZiB+a2V5IChgQm90aCAoeCwgeSkpXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIG91dHB1dF9kYXRhX29wdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIGlucHV0X2RhdGEgb3V0cHV0X2RhdGEgZl9vdXRwdXQgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgKHdpdG5lc3MgOiAoaW5wdXRfZGF0YSwgb3V0cHV0X2RhdGEsIGZfb3V0cHV0KSBNYXBfdHlwZS50KVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChsaHMgOiAoKCdrZXksIGlucHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KGNvbXBhcmF0b3IgOiAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50KVxuICAgICAgICB+KGYgOlxuICAgICAgICAgICAga2V5OidrZXlcbiAgICAgICAgICAtPiBkYXRhOihpbnB1dF9kYXRhLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgICAgLT4gKGZfb3V0cHV0LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgIDogKCgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgbGhzIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBwcmV2X25vZGVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBhY2MgOiAoJ2tleSwgb3V0cHV0X2RhdGEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFhY2MpIGluXG4gICAgbGV0IChvbl9pbm5lcl9jaGFuZ2UgOiBrZXk6J2tleSAtPiBmX291dHB1dCAtPiB1bml0KSA9XG4gICAgICBtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgIHwgTWFwX3R5cGUuTWFwIC0+IGZ1biB+a2V5IGRhdGEgLT4gYWNjIDo9IE1hcC5zZXQgIWFjYyB+a2V5IH5kYXRhXG4gICAgICB8IE1hcF90eXBlLkZpbHRlcl9tYXAgLT5cbiAgICAgICAgZnVuIH5rZXkgb3B0IC0+XG4gICAgICAgICAgbGV0IG9sZCA9ICFhY2MgaW5cbiAgICAgICAgICBhY2NcbiAgICAgICAgICA6PSAobWF0Y2ggb3B0IHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG9sZCBrZXlcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE1hcC5zZXQgb2xkIH5rZXkgfmRhdGEpXG4gICAgaW5cbiAgICBsZXQgcmVjIGxoc19jaGFuZ2UgPVxuICAgICAgbGF6eVxuICAgICAgICAoSW5jcmVtZW50YWwubWFwIGxocyB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9kZXAgPSBNYXAuZmluZF9leG4gbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IHJlc3VsdCBkZXA7XG4gICAgICAgICAgICAgICAgICAgYWNjIDo9IE1hcC5yZW1vdmUgIWFjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgT3B0aW9uLml0ZXIgY3V0b2ZmIH5mOihmdW4gYyAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBsaHNfY2hhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgbGV0IHVzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgKGYgfmtleSB+ZGF0YTooRS5Ob2RlLndhdGNoIG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihvbl9pbm5lcl9jaGFuZ2UgfmtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgTWFwLnNldCBub2RlcyB+a2V5IH5kYXRhOihub2RlLCB1c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByZXZfbm9kZXMgOj0gbmV3X25vZGVzO1xuICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgbGhzX2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCByZXN1bHRcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgTWFwX3R5cGUuRmlsdGVyX21hcFxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwaScgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJyBNYXBfdHlwZS5NYXAgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIG1hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1lcmdlJyA/Y3V0b2ZmID9kYXRhX2VxdWFsX2xlZnQgP2RhdGFfZXF1YWxfcmlnaHQgbWFwMSBtYXAyIH5mID1cbiAgICBtZXJnZSA/ZGF0YV9lcXVhbF9sZWZ0ID9kYXRhX2VxdWFsX3JpZ2h0IG1hcDEgbWFwMiB+ZjooZnVuIH5rZXk6XyBkaWZmIC0+IFNvbWUgZGlmZilcbiAgICB8PiBmaWx0ZXJfbWFwaScgP2N1dG9mZiB+ZjooZnVuIH5rZXkgfmRhdGE6ZGlmZiAtPiBmIH5rZXkgZGlmZilcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaV93aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgOiB2IC0+IHYgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8obGVmdF9yZXN1bHRfZXF1YWwgOiB2MSAtPiB2MSAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgPyhyaWdodF9yZXN1bHRfZXF1YWwgOiB2MiAtPiB2MiAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgKGlucHV0IDogKCgna2V5LCB2LCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICAgICAgfihmIDoga2V5OidrZXkgLT4gZGF0YTp2IC0+IHYxICogdjIpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBsZWZ0X2FjYyA6ICgna2V5LCB2MSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhbGVmdF9hY2MpIGluXG4gICAgbGV0IHJpZ2h0X2FjYyA6ICgna2V5LCB2MiwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByaWdodF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJpZ2h0X2FjYykgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGlucHV0X2NoYW5nZSA9XG4gICAgICBJbmNyZW1lbnRhbC5tYXAgaW5wdXQgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgbGV0IGxlZnQsIHJpZ2h0ID1cbiAgICAgICAgICBtYXRjaCBNYXAuaXNfZW1wdHkgIXByZXZfbWFwLCBNYXAuaXNfZW1wdHkgbWFwIHdpdGhcbiAgICAgICAgICB8IHRydWUsIHRydWUgfCBmYWxzZSwgdHJ1ZSAtPiBlbXB0eV9tYXAsIGVtcHR5X21hcFxuICAgICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgICAgICgqIE1hcHBpbmcgb24gYSBtYXAgaXMgd2F5IGZhc3RlciB0aGFuIHN5bW1ldHJpYyBkaWZmaW5nIGFuZCB0aGVuXG4gICAgICAgICAgICAgICBidWlsZGluZyB0aGUgbWFwcyB1cCBwaWVjZSBieSBwaWVjZSwgc28gd2UgZG8gdGhpcyB3aGVuZXZlciB3ZVxuICAgICAgICAgICAgICAgdHJhbnNpdGlvbiBmcm9tIFwiZW1wdHlcIiB0byBcInNvbWV0aGluZ1wiLCB3aGljaCB3aWxsIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgIGhhcHBlbiBvbiB0aGUgZmlyc3Qgc3RhYmlsaXphdGlvbi4gKilcbiAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgIGxldCBsLCBfID0gZiB+a2V5IH5kYXRhIGluXG4gICAgICAgICAgICAgICAgbClcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgcmlnaHQgPVxuICAgICAgICAgICAgICBNYXAubWFwaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICAgICAgbGV0IF8sIHIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICAgICAgICByKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgfCBmYWxzZSwgZmFsc2UgLT5cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgfmluaXQ6KCFsZWZ0X2FjYywgIXJpZ2h0X2FjYylcbiAgICAgICAgICAgICAgfmY6KGZ1biAobGVmdCwgcmlnaHQpIChrZXksIGNoYW5nZWQpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAocHJldiwgbmV3XykgLT5cbiAgICAgICAgICAgICAgICAgIGxldCBwcmV2X2EsIHByZXZfYiA9IGYgfmtleSB+ZGF0YTpwcmV2IGluXG4gICAgICAgICAgICAgICAgICBsZXQgbmV3X2EsIG5ld19iID0gZiB+a2V5IH5kYXRhOm5ld18gaW5cbiAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgbGVmdF9yZXN1bHRfZXF1YWwgcHJldl9hIG5ld19hXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gbGVmdFxuICAgICAgICAgICAgICAgICAgICBlbHNlIE1hcC5zZXQgbGVmdCB+a2V5IH5kYXRhOm5ld19hXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgcmlnaHRfcmVzdWx0X2VxdWFsIHByZXZfYiBuZXdfYlxuICAgICAgICAgICAgICAgICAgICB0aGVuIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCByaWdodCB+a2V5IH5kYXRhOm5ld19iXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHRcbiAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBsZWZ0IGtleSwgTWFwLnJlbW92ZSByaWdodCBrZXlcbiAgICAgICAgICAgICAgICB8IGBSaWdodCBlbGVtZW50IC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYSwgYiA9IGYgfmtleSB+ZGF0YTplbGVtZW50IGluXG4gICAgICAgICAgICAgICAgICBNYXAuc2V0IGxlZnQgfmtleSB+ZGF0YTphLCBNYXAuc2V0IHJpZ2h0IH5rZXkgfmRhdGE6YilcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsICFsZWZ0X2FjYyBsZWZ0KSB0aGVuIEUuTm9kZS5tYWtlX3N0YWxlIGxlZnRfcmVzdWx0O1xuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgIXJpZ2h0X2FjYyByaWdodCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSByaWdodF9yZXN1bHQ7XG4gICAgICAgIGxlZnRfYWNjIDo9IGxlZnQ7XG4gICAgICAgIHJpZ2h0X2FjYyA6PSByaWdodDtcbiAgICAgICAgcHJldl9tYXAgOj0gbWFwKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIGlucHV0X2NoYW5nZSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpID9kYXRhX2VxdWFsID9sZWZ0X3Jlc3VsdF9lcXVhbCA/cmlnaHRfcmVzdWx0X2VxdWFsIGlucHV0IH5mID1cbiAgICBsZXQgcGFpciA9XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICAgIGlucHV0XG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgICAgICAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgICAgICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICAgICAgICB+ZlxuICAgICAgICB8PiBUdXBsZTIudW5jdXJyeSBJbmNyZW1lbnRhbC5ib3RoKVxuICAgIGluXG4gICAgSW5jcmVtZW50YWwubWFwIH5mOmZzdCBwYWlyLCBJbmNyZW1lbnRhbC5tYXAgfmY6c25kIHBhaXJcbiAgOztcblxuICBsZXQgdW56aXAgP2xlZnRfcmVzdWx0X2VxdWFsID9yaWdodF9yZXN1bHRfZXF1YWwgaW5wdXQgPVxuICAgIGxldCBkYXRhX2VxdWFsID1cbiAgICAgIE9wdGlvbi5tYXAyIGxlZnRfcmVzdWx0X2VxdWFsIHJpZ2h0X3Jlc3VsdF9lcXVhbCB+ZjooZnVuIGwgciAtPlxuICAgICAgICBUdXBsZTIuZXF1YWwgfmVxMTpsIH5lcTI6cilcbiAgICBpblxuICAgIHVuemlwX21hcGlcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgIGlucHV0XG4gICAgICB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBkYXRhKVxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6XG4gICAgICAgICAgICBrZXk6J2tleVxuICAgICAgICAgIC0+IGRhdGE6KHYsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAodjEsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQgKiAodjIsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IGxlZnRfYWNjIDo9IE1hcC5zZXQgIWxlZnRfYWNjIH5rZXkgfmRhdGEgaW5cbiAgICBsZXQgcmlnaHRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IHJpZ2h0X2FjYyA6PSBNYXAuc2V0ICFyaWdodF9hY2MgfmtleSB+ZGF0YSBpblxuICAgIGxldCByZWMgaW5wdXRfY2hhbmdlID1cbiAgICAgIGxhenlcbiAgICAgICAgKEluY3JlbWVudGFsLm1hcCBpbnB1dCB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9sZWZ0X2RlcCwgX3JpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBFLk5vZGUubWFrZV9zdGFsZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBsZWZ0X2RlcCwgcmlnaHRfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfZGVwO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgcmlnaHRfZGVwO1xuICAgICAgICAgICAgICAgICAgIGxlZnRfYWNjIDo9IE1hcC5yZW1vdmUgIWxlZnRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICByaWdodF9hY2MgOj0gTWFwLnJlbW92ZSAhcmlnaHRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuaW52YWxpZGF0ZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgTWFwLmZpbmRfZXhuICFwcmV2X21hcCBrZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBPcHRpb24uaXRlciBjdXRvZmYgfmY6KGZ1biBjIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5zZXRfY3V0b2ZmIChFLk5vZGUud2F0Y2ggbm9kZSkgYyk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X2luY3IsIHJpZ2h0X2luY3IgPSBmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRfdXNlcl9mdW5jdGlvbl9kZXAgPVxuICAgICAgICAgICAgICAgICAgICAgRS5EZXBlbmRlbmN5LmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICByaWdodF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KHJpZ2h0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcDtcbiAgICAgICAgICAgICAgICAgICBNYXAuc2V0XG4gICAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgICAgICAgfmRhdGE6KG5vZGUsIGxlZnRfdXNlcl9mdW5jdGlvbl9kZXAsIHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwKSlcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgcHJldl9ub2RlcyA6PSBuZXdfbm9kZXM7XG4gICAgICAgICAgIHByZXZfbWFwIDo9IG1hcCkpXG4gICAgaW5cbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgbGVmdF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgICAgbWFwXG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIH5jb21wYXJhdG9yIH5mXG4gICAgICAgIHw+IFR1cGxlMi51bmN1cnJ5IEluY3JlbWVudGFsLmJvdGgpXG4gICAgaW5cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6ZnN0IHBhaXIsIEluY3JlbWVudGFsLm1hcCB+ZjpzbmQgcGFpclxuICA7O1xuXG4gIGxldCBrZXlzIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBhZGQgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5hZGQgYWNjIGtleSBpblxuICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhOl8gYWNjID0gU2V0LnJlbW92ZSBhY2Mga2V5IGluXG4gICAgICBsZXQgZGF0YV9lcXVhbCBfIF8gPSB0cnVlIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICBtYXBcbiAgICAgICAgfmluaXQ6KFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdDooZW1wdHksIGVtcHR5KVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YTpfIH5uZXdfZGF0YTpkYXRhIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBGaXJzdCBkYXRhIC0+IE1hcC5zZXQgZmlyc3QgfmtleSB+ZGF0YSwgTWFwLnJlbW92ZSBzZWNvbmQga2V5XG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBNYXAucmVtb3ZlIGZpcnN0IGtleSwgTWFwLnNldCBzZWNvbmQgfmtleSB+ZGF0YSlcbiAgICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IGRhdGEgLT4gTWFwLmFkZF9leG4gZmlyc3QgfmtleSB+ZGF0YSwgc2Vjb25kXG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBmaXJzdCwgTWFwLmFkZF9leG4gc2Vjb25kIH5rZXkgfmRhdGEpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhOl8gKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgTWFwLnJlbW92ZSBmaXJzdCBrZXksIE1hcC5yZW1vdmUgc2Vjb25kIGtleSkpXG4gIDs7XG5cbiAgbGV0IGZsYXR0ZW4gc3RhdGUgbWFwID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgcmVzdWx0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKSkgaW5cbiAgICBsZXQgbm9kZSA9IEUuTm9kZS5jcmVhdGUgc3RhdGUgKGZ1biAoKSAtPiAhcmVzdWx0KSBpblxuICAgIE1hcC5pdGVyaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhOmluY3IgLT5cbiAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeVxuICAgICAgICBub2RlXG4gICAgICAgIChFLkRlcGVuZGVuY3kuY3JlYXRlIGluY3Igfm9uX2NoYW5nZTooZnVuIGEgLT5cbiAgICAgICAgICAgcmVzdWx0IDo9IE1hcC5zZXQgIXJlc3VsdCB+a2V5IH5kYXRhOmEpKSk7XG4gICAgRS5Ob2RlLndhdGNoIG5vZGVcbiAgOztcblxuICBsZXQgam9pbl93aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgfmNvbXBhcmF0b3IgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIG1hcF9pbmNyIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHJlc3VsdF9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IG9sZF9tYXBfb2ZfaW5jcnMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGN1cnJlbnRfZGVwZW5kZW5jaWVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJlc3VsdF9tYXApIGluXG4gICAgbGV0IGFkZF9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGFfbm9kZSA9XG4gICAgICBsZXQgbmV3X2RlcCA9XG4gICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGUgZGF0YV9ub2RlIH5vbl9jaGFuZ2U6KGZ1biBkYXRhIC0+XG4gICAgICAgICAgcmVzdWx0X21hcCA6PSBNYXAuc2V0ICFyZXN1bHRfbWFwIH5rZXkgfmRhdGEpXG4gICAgICBpblxuICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCBuZXdfZGVwO1xuICAgICAgTWFwLnNldCBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhOm5ld19kZXBcbiAgICBpblxuICAgIGxldCByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5ID1cbiAgICAgIGxldCBkZXAgPSBNYXAuZmluZF9leG4gY3VycmVudF9kZXBlbmRlbmNpZXMga2V5IGluXG4gICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmVzdWx0IGRlcDtcbiAgICAgIHJlc3VsdF9tYXAgOj0gTWFwLnJlbW92ZSAhcmVzdWx0X21hcCBrZXk7XG4gICAgICBNYXAucmVtb3ZlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIGtleVxuICAgIGluXG4gICAgbGV0IGxoc19jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIG1hcF9pbmNyIH5mOihmdW4gbWFwX29mX2luY3JzIC0+XG4gICAgICAgIGxldCBuZXdfZGVwZW5kZW5jeV9tYXAgPVxuICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICB+ZGF0YV9lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAhb2xkX21hcF9vZl9pbmNyc1xuICAgICAgICAgICAgbWFwX29mX2luY3JzXG4gICAgICAgICAgICB+aW5pdDohY3VycmVudF9kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIH5mOihmdW4gY3VycmVudF9kZXBlbmRlbmNpZXMgKGtleSwgZGlmZikgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgXyAtPiByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5XG4gICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfbm9kZSAtPiBhZGRfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhX25vZGVcbiAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoXywgZGF0YV9ub2RlKSAtPlxuICAgICAgICAgICAgICAgIHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfD4gYWRkX3N1Ym5vZGUgfmtleSB+ZGF0YV9ub2RlKVxuICAgICAgICBpblxuICAgICAgICBjdXJyZW50X2RlcGVuZGVuY2llcyA6PSBuZXdfZGVwZW5kZW5jeV9tYXA7XG4gICAgICAgIG9sZF9tYXBfb2ZfaW5jcnMgOj0gbWFwX29mX2luY3JzKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBsaHNfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGpvaW4gbWFwID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPiBqb2luX3dpdGhfY29tcGFyYXRvciBtYXAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbW9kdWxlIFNlcGFyYXRlX3N0YXRlID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdCA9XG4gICAgICB7IG11dGFibGUgaW5wdXRfbWFwIDogKCdrLCAndiwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgbXV0YWJsZSBleHBlcnRfbm9kZXMgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnQsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgb3V0cHV0X21hcCA6ICgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnRcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgY29tcGFyYXRvciA9XG4gICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgeyBpbnB1dF9tYXAgPSBlbXB0eTsgZXhwZXJ0X25vZGVzID0gZW1wdHk7IG91dHB1dF9tYXAgPSBlbXB0eSB9XG4gICAgOztcblxuICAgIGxldCBjcmVhdGVfbG9va3VwX25vZGUgc3RhdGUgdCBrZXkgPVxuICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT4gTWFwLmZpbmRfZXhuIHQuaW5wdXRfbWFwIGtleSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2VwYXJhdGUgaW5wdXRfbWFwIH5kYXRhX2VxdWFsID1cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXAgaW5cbiAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXRfbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IHN0YXRlID0gU2VwYXJhdGVfc3RhdGUuY3JlYXRlIGNvbXBhcmF0b3IgaW5cbiAgICAgIGxldCBvdXRwdXRfbWFwX25vZGUgPVxuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiBzdGF0ZS5vdXRwdXRfbWFwKVxuICAgICAgaW5cbiAgICAgIGxldCBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG5vZGUgfmlucHV0X21hcF9jaGFuZ2VkID1cbiAgICAgICAgbGV0IGRlcGVuZGVuY3kgPVxuICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSAoTGF6eS5mb3JjZV92YWwgaW5wdXRfbWFwX2NoYW5nZWQpXG4gICAgICAgIGluXG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgZGVwZW5kZW5jeVxuICAgICAgaW5cbiAgICAgICgqIFdlIHdhbnQgdG8gbWFrZSBub2RlcyBkZXBlbmQgb24gW2lucHV0X21hcF9jaGFuZ2VkXSBzbyB0aGF0IFtpbnB1dF9tYXBfY2hhbmdlZF1cbiAgICAgICAgIGlzIGFsbG93ZWQgdG8gbWFrZSB0aGVtIHN0YWxlLCBidXQgd2UgZG8gbm90IHdhbnQgdGhlbSB0byBiZSByZWNvbXB1dGVkIGZvciBhbnlcbiAgICAgICAgIG90aGVyIHJlYXNvbi4gU28gd2UgbWFrZSBbaW5wdXRfbWFwX2NoYW5nZWRdIGEgdW5pdCBpbmNyZW1lbnRhbCAodGhhdCB0aGVyZWZvcmVcbiAgICAgICAgIG5ldmVyIGNoYW5nZXMpIGFuZCB0aGlzIHdheSBbb3V0cHV0X21hcF9ub2RlXSBhbmQgdGhlIGxvb2t1cCBub2RlcyB3aWxsIG9ubHkgYmVcbiAgICAgICAgIHJlY29tcHV0ZWQgd2hlbiB0aGV5IGFyZSBleHBsaWNpdGx5IG1hZGUgc3RhbGUuXG4gICAgICAqKVxuICAgICAgbGV0IHJlYyBpbnB1dF9tYXBfY2hhbmdlZCA9XG4gICAgICAgIGxhenlcbiAgICAgICAgICAoSW5jcmVtZW50YWwubWFwIGlucHV0X21hcCB+ZjooZnVuIGlucHV0X21hcCAtPlxuICAgICAgICAgICAgIGxldCBwcmV2X2lucHV0X21hcCA9IHN0YXRlLmlucHV0X21hcCBpblxuICAgICAgICAgICAgIGxldCBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXAgPVxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgcHJldl9pbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgaW5wdXRfbWFwXG4gICAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAgIH5pbml0OihzdGF0ZS5leHBlcnRfbm9kZXMsIHN0YXRlLm91dHB1dF9tYXApXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gKGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfb2xkX3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgb2xkX25vZGUgPSBNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuaW52YWxpZGF0ZSBvbGRfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgTWFwLnJlbW92ZSBleHBlcnRfbm9kZXMga2V5LCBNYXAucmVtb3ZlIG91dHB1dF9tYXAga2V5XG4gICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgX25ld192YWx1ZSAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICBTZXBhcmF0ZV9zdGF0ZS5jcmVhdGVfbG9va3VwX25vZGUgaW5jcmVtZW50YWxfc3RhdGUgc3RhdGUga2V5XG4gICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBub2RlIH5pbnB1dF9tYXBfY2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgKCBNYXAuYWRkX2V4biBleHBlcnRfbm9kZXMgfmtleSB+ZGF0YTpub2RlXG4gICAgICAgICAgICAgICAgICAgICAsIE1hcC5hZGRfZXhuXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X21hcFxuICAgICAgICAgICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGF0YTooSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggbm9kZSkgKVxuICAgICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgKF9vbGRfdmFsdWUsIF9uZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5tYWtlX3N0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgIChNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXApXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBzdGF0ZS5pbnB1dF9tYXAgPC0gaW5wdXRfbWFwO1xuICAgICAgICAgICAgIHN0YXRlLmV4cGVydF9ub2RlcyA8LSBleHBlcnRfbm9kZXM7XG4gICAgICAgICAgICAgc3RhdGUub3V0cHV0X21hcCA8LSBvdXRwdXRfbWFwKSlcbiAgICAgIGluXG4gICAgICBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG91dHB1dF9tYXBfbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQ7XG4gICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBvdXRwdXRfbWFwX25vZGUpXG4gIDs7XG5cbiAgKCogSnVzdCBmb3IgZGVyaXZpbmcgc3RydWN0dXJhbCBlcXVhbGl0eS4gKilcbiAgdHlwZSAnYSBtYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgPSAnYSBNYXliZV9ib3VuZC50ID1cbiAgICB8IEluY2wgb2YgJ2FcbiAgICB8IEV4Y2wgb2YgJ2FcbiAgICB8IFVuYm91bmRlZFxuICBbQEBkZXJpdmluZyBlcXVhbF1cblxuICBsZXQgc3VicmFuZ2VcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAobWFwX2luY3IgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIHJhbmdlXG4gICAgPVxuICAgIHdpdGhfb2xkMiBtYXBfaW5jciByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIHJhbmdlIC0+XG4gICAgICBsZXQgY29tcGFyZSA9IChNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgIGxldCBlcXVhbCBsIHIgPSBjb21wYXJlIGwgciA9IDAgaW5cbiAgICAgIGxldCAoID4gKSBhIGIgPSBjb21wYXJlIGEgYiA+IDBcbiAgICAgIGFuZCAoID49ICkgYSBiID0gY29tcGFyZSBhIGIgPj0gMCBpblxuICAgICAgbGV0IG1heWJlX2JvdW5kX2VxdWFsIGEgYiA6IGJvb2wgPSBlcXVhbF9tYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgZXF1YWwgYSBiIGluXG4gICAgICBsZXQgcmFuZ2VfaXNfZW1wdHkgfm1pbiB+bWF4IDogYm9vbCA9XG4gICAgICAgIG1hdGNoIG1pbiwgbWF4IHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQsIChVbmJvdW5kZWQgfCBFeGNsIF8gfCBJbmNsIF8pIHwgKEV4Y2wgXyB8IEluY2wgXyksIFVuYm91bmRlZCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIHwgSW5jbCBtaW4sIEluY2wgbWF4IC0+IG1pbiA+IG1heFxuICAgICAgICB8IEV4Y2wgbWluLCBFeGNsIG1heCB8IEluY2wgbWluLCBFeGNsIG1heCB8IEV4Y2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPj0gbWF4XG4gICAgICBpblxuICAgICAgbGV0IHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXkgOiBib29sID1cbiAgICAgICAgTWF5YmVfYm91bmQuaXNfbG93ZXJfYm91bmQgbWluIH5vZl86a2V5IH5jb21wYXJlXG4gICAgICAgICYmIE1heWJlX2JvdW5kLmlzX3VwcGVyX2JvdW5kIG1heCB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHJhbmdlIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAoKiBFbXB0eSBuZXcgcmFuZ2UgbWVhbnMgZW1wdHkgbWFwICopXG4gICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICB8IFNvbWUgKChtaW4sIG1heCkgYXMgcmFuZ2UpIC0+XG4gICAgICAgIGxldCBmcm9tX3NjcmF0Y2ggKCkgPSBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZDptaW4gfnVwcGVyX2JvdW5kOm1heCBpblxuICAgICAgICAobWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIE5vbmUsIF8pIC0+XG4gICAgICAgICAgICgqIG5vIG9sZCByYW5nZSAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAoXywgU29tZSAob2xkX21pbiwgb2xkX21heCksIF8pXG4gICAgICAgICAgIHdoZW4gcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW4gfm1heDpvbGRfbWF4XG4gICAgICAgICAgICAgfHwgcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXggLT5cbiAgICAgICAgICAgKCogZW1wdHkgb2xkIHJhbmdlIG9yIG9sZCByYW5nZSBkaXNqb2ludCB3aXRoIG5ldyAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAob2xkX21hcCwgU29tZSAoKG9sZF9taW4sIG9sZF9tYXgpIGFzIG9sZF9yYW5nZSksIG9sZF9yZXMpIC0+XG4gICAgICAgICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgICAgICAgICgqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGtleSBpcyBpbiBib3RoIG5ldyBhbmQgb2xkIHJhbmdlcyAqKVxuICAgICAgICAgICAgIGxldCBpbl9yYW5nZV9pbnRlcnNlY3Rpb24ga2V5ID1cbiAgICAgICAgICAgICAgIHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXlcbiAgICAgICAgICAgICAgICYmIHJhbmdlX2luY2x1ZGVzIH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXgga2V5XG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBBcHBseSBjaGFuZ2VzIHRvIGtleXMgd2hpY2ggYXJlIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgYm90aCByYW5nZXMuXG5cbiAgICAgICAgICAgICAgICBbb3V0c2lkZV0gaXMgdGhlIG51bWJlciBvZiB1cGRhdGVzIG91dHNpZGUgdGhlIHJhbmdlIGludGVyc2VjdGlvbiB0aGF0IHdlXG4gICAgICAgICAgICAgICAgdG9sZXJhdGUgYmVmb3JlIGdpdmluZyB1cCBhbmQgcmVjb25zdHJ1Y3RpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZS4gVGhpc1xuICAgICAgICAgICAgICAgIGlzIGFuIG9wdGltaXNhdGlvbiBpbiB0aGUgY2FzZSB0aGF0IHRoZSBtYXAgY2hhbmdlcyBpbiBhIHZlcnkgYmlnIHdheSwgYXRcbiAgICAgICAgICAgICAgICB3aGljaCBwb2ludCBjb21wdXRpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZSBpcyBjaGVhcGVyLiAgKilcbiAgICAgICAgICAgICBsZXQgYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24gKG91dHNpZGUsIG1hcCkgKGtleSwgZGF0YSkgPVxuICAgICAgICAgICAgICAgaWYgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleVxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5XG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGEgfCBgVW5lcXVhbCAoXywgZGF0YSkgLT4gb3V0c2lkZSwgTWFwLnNldCBtYXAgfmtleSB+ZGF0YSlcbiAgICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgICBsZXQgb3V0c2lkZSA9IG91dHNpZGUgLSAxIGluXG4gICAgICAgICAgICAgICAgIGlmIEludC5PLihvdXRzaWRlIDwgMClcbiAgICAgICAgICAgICAgICAgdGhlbiByZXR1cm4gKGZyb21fc2NyYXRjaCAoKSlcbiAgICAgICAgICAgICAgICAgZWxzZSBvdXRzaWRlLCBNYXAucmVtb3ZlIG1hcCBrZXkpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBGaXJzdCB1cGRhdGUgdGhlIGtleXMgaW4gL2JvdGgvIHRoZSBvbGQgYW5kIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgbGV0IHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uID1cbiAgICAgICAgICAgICAgICgqIEN1dG9mZiB0aGUgYmlnIGRpZmYgY29tcHV0YXRpb24gaWYgd2UgcmVhY2ggTyh8c3VibWFwfCkgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHJhbmdlICopXG4gICAgICAgICAgICAgICBsZXQgb3V0c2lkZV9jdXRvZmYgPSBNYXAubGVuZ3RoIG9sZF9yZXMgLyA0IGluXG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgICB+aW5pdDoob3V0c2lkZV9jdXRvZmYsIG9sZF9yZXMpXG4gICAgICAgICAgICAgICAgIH5mOmFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICB8PiBzbmRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIFR1cGxlMi5lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMTptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMjptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgb2xkX3JhbmdlXG4gICAgICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIFRoZXJlIGFyZSBubyBrZXlzIHRvIHJlbW92ZSBhbmQgZXZlcnl0aGluZyBpbiByYW5nZSBpcyB1cGRhdGVkLiAqKVxuICAgICAgICAgICAgICAgd2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICgqIFJlbW92ZSBhbnkga2V5cyB3aGljaCBhcmUgbm90IGluIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgICBsZXQgd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZVxuICAgICAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgfmxvd2VyX2JvdW5kOm1pblxuICAgICAgICAgICAgICAgICAgIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoKiBBZGQgaW4gYW55IGtleXMgd2hpY2ggYXJlIGluIHRoZSBuZXcgcmFuZ2UgYnV0IG5vdCB0aGUgb2xkIHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlID1cbiAgICAgICAgICAgICAgICAgbGV0IG1hcF9hcHBlbmRfZXhuIGxvd2VyX3BhcnQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICAgICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiaW1wb3NzaWJsZSBjYXNlOiBCVUcgaW4gaW5jcl9tYXAubWwgc3VicmFuZ2VcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21pbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEluY2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21pbiAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDooRXhjbCBvbGRfbWluKVxuICAgICAgICAgICAgICAgICBhbmQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21heCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihJbmNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21heCAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6KEV4Y2wgb2xkX21heCkgfnVwcGVyX2JvdW5kOm1heFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBtYXBfYXBwZW5kX2V4blxuICAgICAgICAgICAgICAgICAgIGxvd2VyX3BhcnRcbiAgICAgICAgICAgICAgICAgICAobWFwX2FwcGVuZF9leG4gd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSB1cHBlcl9wYXJ0KVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlKSkpKVxuICA7O1xuXG4gIGxldCByZWtleSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5mID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgbWFwX2luY3JcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLmFkZF9leG4gb3V0cHV0IH5rZXk6KGYgfmtleSB+ZGF0YSkgfmRhdGEpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLnJlbW92ZSBvdXRwdXQgKGYgfmtleSB+ZGF0YSkpXG4gICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIG91dHB1dCAtPlxuICAgICAgICBsZXQgcHJldl9rZXkgPSBmIH5rZXkgfmRhdGE6b2xkX2RhdGEgaW5cbiAgICAgICAgbGV0IG5ld19rZXkgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgaWYgKE1hcC5jb21wYXJhdG9yIG91dHB1dCkuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIE1hcC5zZXQgb3V0cHV0IH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICBlbHNlIE1hcC5yZW1vdmUgb3V0cHV0IHByZXZfa2V5IHw+IE1hcC5hZGRfZXhuIH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YSlcbiAgOztcblxuICBsZXQgaW5kZXhfYnlpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3IgfmluZGV4ID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgKGZ1biBpbm5lcl9jb21wYXJhdG9yIC0+XG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfmFkZDooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIG91dGVyX21hcCAtPlxuICAgICAgICAgIG1hdGNoIGluZGV4IH5rZXk6aW5uZXJfa2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gb3V0ZXJfbWFwXG4gICAgICAgICAgfCBTb21lIG91dGVyX2tleSAtPlxuICAgICAgICAgICAgTWFwLnVwZGF0ZSBvdXRlcl9tYXAgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b25cbiAgICAgICAgICAgICAgICAgIGlubmVyX2tleVxuICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+IE1hcC5hZGRfZXhuIGlubmVyX21hcCB+a2V5OmlubmVyX2tleSB+ZGF0YSkpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC5jaGFuZ2Ugb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZmFpbHdpdGggXCJCVUc6IEhpdCBzdXBwb3NlZGx5IGltcG9zc2libGUgY2FzZSBpbiBJbmNyX21hcC5pbmRleF9ieVwiXG4gICAgICAgICAgICAgIHwgU29tZSBpbm5lcl9tYXAgLT5cbiAgICAgICAgICAgICAgICBsZXQgaW5uZXJfbWFwID0gTWFwLnJlbW92ZSBpbm5lcl9tYXAgaW5uZXJfa2V5IGluXG4gICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGlubmVyX21hcCB0aGVuIE5vbmUgZWxzZSBTb21lIGlubmVyX21hcCkpKVxuICA7O1xuXG4gIGxldCBpbmRleF9ieSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgIGluZGV4X2J5aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXg6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gaW5kZXggZGF0YSlcbiAgOztcblxuXG4gICgqKiBGaW5kIHR3byBrZXlzIGluIG1hcCBieSBpbmRleCwgTyhuKS4gV2UgdXNlIGp1c3Qgb25lIGZvbGQgKHR3byBNYXAubnRoIHdvdWxkIHVzZSB0d28pXG4gICAgICBhbmQgb3B0aW1pemUgZm9yIGtleXMgY2xvc2UgdG8gZWl0aGVyIGJlZ2lubmluZyBvciBlbmQgYnkgdXNpbmcgZWl0aGVyIGZvbGQgb3JcbiAgICAgIGZvbGRfcmlnaHQuXG4gICopXG4gIG1vZHVsZSBLZXlfc3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAnayB0ID1cbiAgICAgIHwgS25vd24gb2YgJ2tcbiAgICAgIHwgS25vd25fbm9uZVxuICAgICAgfCBVbmtub3duXG5cbiAgICBsZXQgaXNfa25vd24gPSBmdW5jdGlvblxuICAgICAgfCBVbmtub3duIC0+IGZhbHNlXG4gICAgICB8IF8gLT4gdHJ1ZVxuICAgIDs7XG5cbiAgICBsZXQgdG9fb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biB8IEtub3duX25vbmUgLT4gTm9uZVxuICAgICAgfCBLbm93biBrIC0+IFNvbWUga1xuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBmaW5kX2tleV9yYW5nZV9saW5lYXIgKHR5cGUgaykgfmZyb20gfnRvXyAobWFwIDogKGssIF8sIF8pIE1hcC50KVxuICAgIDogKGsgKiBrIG9wdGlvbikgb3B0aW9uXG4gICAgPVxuICAgIGxldCBvcGVuIEtleV9zdGF0dXMgaW5cbiAgICBsZXQgbGVuID0gTWFwLmxlbmd0aCBtYXAgaW5cbiAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPj0gKSBmcm9tIGxlbiB0aGVuIEtub3duX25vbmUgZWxzZSBVbmtub3duIGluXG4gICAgbGV0IGVuZF9rZXkgPSBpZiBJbnQuKCA+PSApIHRvXyBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBmaW5kX2tleXMgZm9sZCB+c3RhcnRfcG9zIH5hZHZhbmNlX3BvcyA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgZm9sZFxuICAgICAgICAgIG1hcFxuICAgICAgICAgIH5pbml0OihiZWdpbl9rZXksIGVuZF9rZXksIHN0YXJ0X3BvcylcbiAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6XyAoYmVnaW5fa2V5LCBlbmRfa2V5LCBwb3MpIC0+XG4gICAgICAgICAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPSApIHBvcyBmcm9tIHRoZW4gS25vd24ga2V5IGVsc2UgYmVnaW5fa2V5IGluXG4gICAgICAgICAgICBsZXQgZW5kX2tleSA9IGlmIEludC4oID0gKSBwb3MgdG9fIHRoZW4gS25vd24ga2V5IGVsc2UgZW5kX2tleSBpblxuICAgICAgICAgICAgaWYgaXNfa25vd24gYmVnaW5fa2V5ICYmIGlzX2tub3duIGVuZF9rZXlcbiAgICAgICAgICAgIHRoZW4gcmV0dXJuIChiZWdpbl9rZXksIGVuZF9rZXksIHBvcylcbiAgICAgICAgICAgIGVsc2UgYmVnaW5fa2V5LCBlbmRfa2V5LCBhZHZhbmNlX3BvcyBwb3MpKVxuICAgIGluXG4gICAgbGV0IGJlZ2luX2tleSwgZW5kX2tleSwgXyA9XG4gICAgICAoKiBTZWFyY2hpbmcgZnJvbSBsZWZ0IHRha2VzIE8odG9fKSwgZnJvbSByaWdodCAtIE8obGVuIC0gZnJvbSksIHNvIHNlbGVjdCB0aGVcbiAgICAgICAgIHNtYWxsZXIgb25lLiAqKVxuICAgICAgaWYgdG9fIDwgbGVuIC0gZnJvbVxuICAgICAgdGhlbiBmaW5kX2tleXMgTWFwLmZvbGQgfnN0YXJ0X3BvczowIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgKyAxKVxuICAgICAgZWxzZSBmaW5kX2tleXMgTWFwLmZvbGRfcmlnaHQgfnN0YXJ0X3BvczoobGVuIC0gMSkgfmFkdmFuY2VfcG9zOihmdW4gcG9zIC0+IHBvcyAtIDEpXG4gICAgaW5cbiAgICBPcHRpb24ubWFwIChLZXlfc3RhdHVzLnRvX29wdGlvbiBiZWdpbl9rZXkpIH5mOihmdW4gYmVnaW5fa2V5IC0+XG4gICAgICBiZWdpbl9rZXksIEtleV9zdGF0dXMudG9fb3B0aW9uIGVuZF9rZXkpXG4gIDs7XG5cbiAgbGV0IG50aF9mcm9tX2VpdGhlcl9zaWRlICh0eXBlIGspIG4gKG1hcCA6IChrLCBfLCBfKSBNYXAudCkgOiBrIG9wdGlvbiA9XG4gICAgT3B0aW9uLm1hcCB+Zjpmc3QgKGZpbmRfa2V5X3JhbmdlX2xpbmVhciB+ZnJvbTpuIH50b186biBtYXApXG4gIDs7XG5cbiAgKCoqIEZpbmQga2V5IFtieV0gcG9zaXRpb25zIGVhcmxpZXIvbGF0ZXIgaW4gYSBtYXAuIFJldHVybnMgbm9uZSBpZiBvdXQgb2YgYm91bmRzLiAqKVxuICBsZXQgcmVjIG9mZnNldCAoa2V5IDogJ2spIChtYXAgOiAoJ2ssIF8sIF8pIE1hcC50KSB+YnkgOiAnayBvcHRpb24gPVxuICAgIGlmIEludC4oID0gKSBieSAwXG4gICAgdGhlbiBTb21lIGtleVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNsb3Nlc3RfZGlyLCBhZGQgPVxuICAgICAgICBpZiBJbnQuKCA8ICkgYnkgMCB0aGVuIGBMZXNzX3RoYW4sIDEgZWxzZSBgR3JlYXRlcl90aGFuLCAtMVxuICAgICAgaW5cbiAgICAgIG1hdGNoIE1hcC5jbG9zZXN0X2tleSBtYXAgY2xvc2VzdF9kaXIga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKGtleSwgXykgLT4gb2Zmc2V0IGtleSBtYXAgfmJ5OihieSArIGFkZCkpXG4gIDs7XG5cbiAgKCoqIEZpbmQgaG93IHdlIG5lZWQgdG8gbW92ZSBba2V5XSBpZiBbY2hhbmdlZF9rZXldIGNoYW5nZWQgaW4gdGhlIGdpdmVuXG4gICAgICB3YXkgKilcbiAgbGV0IGZpbmRfb2Zmc2V0IH5jb21wYXJlIH5rZXkgfmNoYW5nZWRfa2V5IGNoYW5nZSA9XG4gICAgaWYgSW50LiggPCApIChjb21wYXJlIGNoYW5nZWRfa2V5IGtleSkgMFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgIHwgYExlZnQgXyAtPiAxXG4gICAgICB8IGBSaWdodCBfIC0+IC0xXG4gICAgICB8IF8gLT4gMClcbiAgICBlbHNlIDBcbiAgOztcblxuICBsZXQgcmFua1xuICAgICAgICAodHlwZSBrIHYgY21wIHN0YXRlX3dpdG5lc3MpXG4gICAgICAgIChtYXAgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChrZXkgOiAoaywgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IHNhbWVfa2V5IGEgYiA9IGNvbXBhcmVfa2V5IGEgYiA9IDAgaW5cbiAgICAgIGxldCB3aGVuX2tleV9jaGFuZ2VkIH5tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rID1cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgbmV3X2tleSBvbGRfa2V5IDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBJZiB0aGUgbmV3IGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG9sZCBrZXksIGZpbmQgdGhlIHNpemUgb2YgdGhlIG1hcCBzdWJyYW5nZVxuICAgICAgICAgICAgIGJldHdlZW4gdGhlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcHJldmlvdXMgcmFuayAqKVxuICAgICAgICAgIGxldCBsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQgPSBFeGNsIG5ld19rZXksIEV4Y2wgb2xkX2tleSBpblxuICAgICAgICAgIGxldCBzdWJyYW5nZSA9IE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCBpblxuICAgICAgICAgIG9sZF9yYW5rIC0gTWFwLmxlbmd0aCBzdWJyYW5nZSAtIDEpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIE90aGVyd2lzZSwgdGhlIG5ldyBrZXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG9sZCBrZXksIHNvIGZpbmQgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgICAgICAgbWFwIHN1YnJhbmdlIGJldHdlZW4gdGhlbSBhbmQgYWRkIGl0IHRvIHRoZSBwcmV2aW91cyByYW5rICopXG4gICAgICAgICAgbGV0IGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IEV4Y2wgb2xkX2tleSwgRXhjbCBuZXdfa2V5IGluXG4gICAgICAgICAgbGV0IHN1YnJhbmdlID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIGluXG4gICAgICAgICAgb2xkX3JhbmsgKyBNYXAubGVuZ3RoIHN1YnJhbmdlICsgMSlcbiAgICAgIGluXG4gICAgICBsZXQgd2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5IH5vbGRfcmFuayA9XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgKCogV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZGF0YSwgc28gb3B0aW1pemUgdGhlc2UgY2hlY2tzICopXG4gICAgICAgICAgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSlcbiAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgbmV3X21hcFxuICAgICAgICAgIH5pbml0Om9sZF9yYW5rXG4gICAgICAgICAgfmY6KGZ1biBhY2MgKGRpZmZfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyAtIDFcbiAgICAgICAgICAgIHwgYFJpZ2h0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyArIDFcbiAgICAgICAgICAgIHwgXyAtPiBhY2MpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBwcm9jZXNzIH4ob2xkIDogKChrLCB2LCBfKSBNYXAudCAqIF8gKiBfKSBvcHRpb24pIG5ld19tYXAgKG5ld19rZXkgOiBrKSA9XG4gICAgICAgIGlmIG5vdCAoTWFwLm1lbSBuZXdfbWFwIG5ld19rZXkpXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICAgICgqIElmIHRoZSBtYXAgYW5kIGtleSBhcmUgdGhlIHNhbWUsIGp1c3QgcmV1c2UgdGhlIG9sZCByYW5rICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBvbGRfcmFuaylcbiAgICAgICAgICAgIHdoZW4gcGh5c19lcXVhbCBuZXdfbWFwIG9sZF9tYXAgJiYgc2FtZV9rZXkgb2xkX2tleSBuZXdfa2V5IC0+IG9sZF9yYW5rXG4gICAgICAgICAgKCogSWYgdGhlIG1hcCBpcyB0aGUgc2FtZSBidXQgdGhlIGtleSBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHBoeXNfZXF1YWwgbmV3X21hcCBvbGRfbWFwIC0+XG4gICAgICAgICAgICBTb21lICh3aGVuX2tleV9jaGFuZ2VkIH5tYXA6bmV3X21hcCB+b2xkX2tleSB+bmV3X2tleSB+b2xkX3JhbmspXG4gICAgICAgICAgKCogSWYgdGhlIGtleSBpcyB0aGUgc2FtZSBidXQgdGhlIG1hcCBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHNhbWVfa2V5IG5ld19rZXkgb2xkX2tleSAtPlxuICAgICAgICAgICAgU29tZSAod2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5Om5ld19rZXkgfm9sZF9yYW5rKVxuICAgICAgICAgICgqIElmIGJvdGggdGhlIG1hcCBhbmQgdGhlIGtleSBjaGFuZ2VkLCB0aGlzIGNhbiBiZSBzaW11bGF0ZWQgYXMgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5naW5nIGZvbGxvd2VkIGJ5IHRoZSBrZXkgY2hhbmdpbmcgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspIC0+XG4gICAgICAgICAgICAoKiBXZSBjYWxsIFtwcm9jZXNzXSByZWN1cnNpdmVseSBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmdcbiAgICAgICAgICAgICAgIFt3aGVuX21hcF9jaGFuZ2VkXSBmb2xsb3dlZCBieSBbd2hlbl9rZXlfY2hhbmdlZF0gc2luY2UgaXQgbWlnaHQgYmUgdGhlXG4gICAgICAgICAgICAgICBjYXNlIHRoYXQgW29sZF9rZXldIGlzIGluIFtvbGRfbWFwXSBhbmQgW25ld19rZXldIGlzIGluIFtuZXdfbWFwXSwgYnV0XG4gICAgICAgICAgICAgICBbb2xkX2tleV0gaXMgbm90IGluIFtuZXdfbWFwXS4gKilcbiAgICAgICAgICAgIGxldCBvbGRfcmFuayA9XG4gICAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykpIG5ld19tYXAgb2xkX2tleVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAobmV3X21hcCwgb2xkX2tleSwgb2xkX3JhbmspKSBuZXdfbWFwIG5ld19rZXlcbiAgICAgICAgICAoKiBJZiB0aGUgcHJldmlvdXMga2V5IHdhcyBub3QgaW4gdGhlIG1hcCBvciB0aGlzIGlzIHRoZSBmaXJzdCBzdGFiaWxpemF0aW9uLFxuICAgICAgICAgICAgIGNvbXB1dGUgdGhlIHJhbmsgZnJvbSBzY3JhdGNoICopXG4gICAgICAgICAgfCBTb21lIChfLCBfLCBOb25lKSB8IE5vbmUgLT4gTWFwLnJhbmsgbmV3X21hcCBuZXdfa2V5KVxuICAgICAgaW5cbiAgICAgIHdpdGhfb2xkMiBtYXAga2V5IH5mOnByb2Nlc3MpXG4gIDs7XG5cbiAgKCoqIFJhbmdlIG1hcCBieSBpbmRpY2VzICopXG4gIGxldCBzdWJyYW5nZV9ieV9yYW5rXG4gICAgICAgICh0eXBlIGsgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcCA6ICgoaywgXywgXykgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChyYW5nZSA6IChpbnQgTWF5YmVfYm91bmQudCAqIGludCBNYXliZV9ib3VuZC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgID1cbiAgICBsZXQgZmluZF9rZXlfcmFuZ2UgKHJhbmdlIDogKGludCAqIGludCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgIDogKChrICogayBvcHRpb24pIG9wdGlvbiwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgPVxuICAgICAgd2l0aF9vbGQyIG1hcCByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIChmcm9tLCB0b18pIC0+XG4gICAgICAgICgqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBubyBrZXlzLCBvbmx5IGJlZ2luIGtleSwgb3IgYmVnaW4gYW5kIGVuZCBrZXlzLlxuICAgICAgICAgICBUaGVzZSBhcmUgdGhlIGtleXMgYXQgW2Zyb21dIGFuZCBbdG9fXSBwb3NpdGlvbnMgaW4gdGhlIG1hcCwgb3IgTm9uZSBpZiB0aGVcbiAgICAgICAgICAgaW5kaWNlcyBhcmUgdG9vIGJpZy4gQXMgYWx3YXlzIFswIDw9IGZyb20gJiYgZnJvbSA8PSB0b19dLCB0aGVyZSBpcyBub1xuICAgICAgICAgICBwb3NzaWJpbGl0eSBvZiBvbmx5IFt0b19dIGJlaW5nIGEgdmFsaWQgcG9zaXRpb24uXG4gICAgICAgICopXG4gICAgICAgIGlmIEludC4oIDwgKSB0b18gZnJvbSB8fCBJbnQuKCA8ICkgZnJvbSAwXG4gICAgICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJJbnZhbGlkIGluZGljZXNcIiAoZnJvbSA6IGludCkgKHRvXyA6IGludCldO1xuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIChvbGRfZnJvbSwgb2xkX3RvKSwgU29tZSAoYmVnaW5fa2V5LCBlbmRfa2V5X29wdCkpIC0+XG4gICAgICAgICAgbGV0IGZpbmRfb2Zmc2V0ID0gZmluZF9vZmZzZXQgfmNvbXBhcmU6KE1hcC5jb21wYXJhdG9yIG1hcCkuY29tcGFyZSBpblxuICAgICAgICAgIGxldCByYW5nZV9vZmZzZXRfYmVnaW4gPSBmcm9tIC0gb2xkX2Zyb20gaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2VuZCA9IHRvXyAtIG9sZF90byBpblxuICAgICAgICAgIGxldCBhZGp1c3RfYW5kX29mZnNldCB+Ynkga2V5ID1cbiAgICAgICAgICAgIGxldCBieSA9IGJ5ICsgaWYgYnkgPj0gMCAmJiBub3QgKE1hcC5tZW0gbWFwIGtleSkgdGhlbiAxIGVsc2UgMCBpblxuICAgICAgICAgICAgb2Zmc2V0IGtleSBtYXAgfmJ5XG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGtleXMgY2hhbmdpbmcgYW5kIG5vdCB0aGUgZGF0YSwgc28gW2RhdGFfZXF1YWxdIGhlcmVcbiAgICAgICAgICAgICBjYW4gYmUgYWx3YXlzIHRydWUgKilcbiAgICAgICAgICBsZXQgZGlmZiB+aW5pdCB+ZiA9XG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZiB+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiB0cnVlKSBvbGRfbWFwIG1hcCB+aW5pdCB+ZlxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IGJlZ2luX2tleV9vcHQsIGVuZF9rZXlfb3B0ID1cbiAgICAgICAgICAgIG1hdGNoIGVuZF9rZXlfb3B0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBlbmRfa2V5IC0+XG4gICAgICAgICAgICAgIGxldCBtYXBfb2Zmc2V0X2JlZ2luLCBtYXBfb2Zmc2V0X2VuZCA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDooMCwgMCkgfmY6KGZ1biAob2Zmc2V0X2JlZ2luLCBvZmZzZXRfZW5kKSAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICAoIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAsIG9mZnNldF9lbmQgKyBmaW5kX29mZnNldCB+a2V5OmVuZF9rZXkgfmNoYW5nZWRfa2V5OmtleSBjaGFuZ2UgKSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIGFkanVzdF9hbmRfb2Zmc2V0IGVuZF9rZXkgfmJ5OihtYXBfb2Zmc2V0X2VuZCArIHJhbmdlX29mZnNldF9lbmQpIClcbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDowIH5mOihmdW4gb2Zmc2V0X2JlZ2luIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgICAgIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAoIGFkanVzdF9hbmRfb2Zmc2V0IGJlZ2luX2tleSB+Ynk6KG1hcF9vZmZzZXRfYmVnaW4gKyByYW5nZV9vZmZzZXRfYmVnaW4pXG4gICAgICAgICAgICAgICwgbnRoX2Zyb21fZWl0aGVyX3NpZGUgdG9fIG1hcCApXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhc3NlcnQgKE9wdGlvbi5mb3JfYWxsIH5mOihNYXAubWVtIG1hcCkgYmVnaW5fa2V5X29wdCk7XG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGVuZF9rZXlfb3B0KTtcbiAgICAgICAgICBPcHRpb24ubWFwIGJlZ2luX2tleV9vcHQgfmY6KGZ1biBiZWdpbl9rZXkgLT4gYmVnaW5fa2V5LCBlbmRfa2V5X29wdClcbiAgICAgICAgfCBOb25lIHwgU29tZSAoXywgXywgTm9uZSkgLT5cbiAgICAgICAgICAoKiBPbiBmaXJzdCBydW4gKHdoZW4gd2UgaGF2ZSB0bykgb3Igd2hlbiBib3RoIHRoZSBrZXlzIGFyZSBub25lLCBydW4gTyhuKVxuICAgICAgICAgICAgIHNjYW4uIFRoaXMgaXMgZmluZSBmb3Iga2V5cy1hcmUtbm9uZSBjYXNlIGFzIGl0IGhhcHBlbnMgd2hlbiB0aGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgYXJlIHBhc3QgZW5kIG9mIHRoZSBtYXAsIHNvIHRoZXkgc2hvdWxkbid0IGJlIHRvbyBmYXIgZnJvbSBlbmQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5nZXMsIGFuZCBbZmluZF9rZXlfcmFuZ2VfbGluZWFyXSBpcyBmYXN0IGluIHN1Y2ggY2FzZS4gKilcbiAgICAgICAgICBmaW5kX2tleV9yYW5nZV9saW5lYXIgbWFwIH5mcm9tIH50b18pXG4gICAgaW5cbiAgICAoKiBIYW5kbGUgZGlmZmVyZW50IE1heWJlX2JvdW5kIGNhc2VzIGFuZCBjYWxsIGZpbmRfa2V5X3JhbmdlIGlmIG5lY2Vzc2FyeS4gSXQnc1xuICAgICAgIG5pY2VyIHRvIGRvIHRoaXMgaGVyZSBhcyBvcHBvc2VkIHRvIG1ha2luZyBmaW5kX2tleV9yYW5nZSBldmVuIG1vcmUgY29tcGxpY2F0ZWQgKilcbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0ICggPj4+ICkgbmV3XyBib3VuZCA9IE1heWJlX2JvdW5kLm1hcCB+ZjooZnVuIF8gLT4gbmV3XykgYm91bmQgaW5cbiAgICBsZXQgcmV0dXJuID0gSW5jcmVtZW50YWwucmV0dXJuIChJbmNyZW1lbnRhbC5zdGF0ZSBtYXApIGluXG4gICAgbGV0IGtleV9yYW5nZSA9XG4gICAgICBtYXRjaCVwYXR0ZXJuX2JpbmQgcmFuZ2Ugd2l0aFxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCAtPlxuICAgICAgICByZXR1cm4gKFNvbWUgKE1heWJlX2JvdW5kLlVuYm91bmRlZCwgTWF5YmVfYm91bmQuVW5ib3VuZGVkKSlcbiAgICAgIHwgKCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpXG4gICAgICAgICwgKChNYXliZV9ib3VuZC5JbmNsIHUgfCBNYXliZV9ib3VuZC5FeGNsIHUpIGFzIHViKSApIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCB1KVxuICAgICAgICBhbmQgbGIgPSBsYlxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBTb21lIGVuZF9rZXkpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIGVuZF9rZXkgPj4+IHViKVxuICAgICAgICAgfCBTb21lIChiZWdpbl9rZXksIE5vbmUpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCBsIGwpXG4gICAgICAgIGFuZCBsYiA9IGxiIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKGtleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCB1IHUpXG4gICAgICAgIGFuZCB1YiA9IHViIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKFVuYm91bmRlZCwga2V5ID4+PiB1YilcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIGluXG4gICAgc3VicmFuZ2UgP2RhdGFfZXF1YWwgbWFwIGtleV9yYW5nZVxuICA7O1xuXG4gIGxldCB0cmFuc3Bvc2VcbiAgICA6IHR5cGUgazEgazIgdiBrMV9jbXAgazJfY21wIHN0YXRlX3dpdG5lc3MuXG4gICAgICA/ZGF0YV9lcXVhbDoodiAtPiB2IC0+IGJvb2wpXG4gICAgICAtPiAoazIsIGsyX2NtcCkgTWFwLmNvbXBhcmF0b3JcbiAgICAgIC0+ICgoazEsIChrMiwgdiwgazJfY21wKSBNYXAudCwgazFfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgLT4gKChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGZ1biA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKSBrMl9jb21wYXJhdG9yIG0gLT5cbiAgICAgIHdpdGhfY29tcGFyYXRvciBtIChmdW4gazFfY29tcGFyYXRvciAtPlxuICAgICAgICBsZXQgdXBkYXRlXG4gICAgICAgICAgOiAga2V5OmsxIC0+IG9sZF9kYXRhOihrMiwgdiwgazJfY21wKSBNYXAudCAtPiBuZXdfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnRcbiAgICAgICAgICAgIC0+IChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50XG4gICAgICAgICAgICAtPiAoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudFxuICAgICAgICAgID1cbiAgICAgICAgICBmdW4gfmtleTprMSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgb2xkX2RhdGFcbiAgICAgICAgICAgICAgbmV3X2RhdGFcbiAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIChrMiwgZGlmZikgLT5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIE1hcC5jaGFuZ2UgYWNjIGsyIH5mOihmdW4gYWNjX2lubmVyIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYWNjX2lubmVyID1cbiAgICAgICAgICAgICAgICAgICAgTWFwLmNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgIChPcHRpb24udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGVmYXVsdDooTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6azFfY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgICAgICAgazFcbiAgICAgICAgICAgICAgICAgICAgICB+ZjooZnVuIF8gLT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGFjY19pbm5lciB0aGVuIE5vbmUgZWxzZSBTb21lIGFjY19pbm5lcikpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBhZGQgfmtleSB+ZGF0YSA9XG4gICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcikgfm5ld19kYXRhOmRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhID1cbiAgICAgICAgICB1cGRhdGUgfmtleSB+b2xkX2RhdGE6ZGF0YSB+bmV3X2RhdGE6KE1hcC5lbXB0eSBrMl9jb21wYXJhdG9yKVxuICAgICAgICBpblxuICAgICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICAgIG1cbiAgICAgICAgICB+aW5pdDooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpXG4gICAgICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgICAgIH51cGRhdGVcbiAgICAgICAgICB+YWRkXG4gICAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgY29sbGFwc2VfYnlcbiAgICAgICAgKHR5cGUgb3V0ZXJfa2V5IG91dGVyX2NtcCBpbm5lcl9rZXkgaW5uZXJfY21wIGNvbWJpbmVkX2tleSBjb21iaW5lZF9jbXApXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KG1lcmdlX2tleXMgOiBvdXRlcl9rZXkgLT4gaW5uZXJfa2V5IC0+IGNvbWJpbmVkX2tleSlcbiAgICAgICAgfihjb21wYXJhdG9yIDogKGNvbWJpbmVkX2tleSwgY29tYmluZWRfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBjb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfnVwZGF0ZTooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGE6XyB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIE1hcC5zZXQgYWNjIH5rZXk6KG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkgfmRhdGE6bmV3X2RhdGEpXG4gICAgICB+YWRkOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAuYWRkX2V4biBhY2MgfmtleToobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSB+ZGF0YSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLnJlbW92ZSBhY2MgKG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkpXG4gIDs7XG5cbiAgbGV0IGNvbGxhcHNlXG4gICAgICAgICh0eXBlIG91dGVyX2tleSBvdXRlcl9jbXAgaW5uZXJfa2V5IGlubmVyX2NtcClcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcF9pbmNyIDpcbiAgICAgICAgICAgKChvdXRlcl9rZXksIChpbm5lcl9rZXksIF8sIGlubmVyX2NtcCkgTWFwLnQsIG91dGVyX2NtcCkgTWFwLnQsIF8pIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH5jb21wYXJhdG9yOihpbm5lcl9jb21wYXJhdG9yIDogKGlubmVyX2tleSwgaW5uZXJfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gb3V0ZXJfY29tcGFyYXRvciAtPlxuICAgICAgbGV0IG1vZHVsZSBDbXAgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gb3V0ZXJfa2V5ICogaW5uZXJfa2V5XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gKG91dGVyX2NtcCwgaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPVxuICAgICAgICAgIGxldCBpbm5lcl9jb21wYXJhdG9yID1cbiAgICAgICAgICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgaW5uZXJfY29tcGFyYXRvcikgaW5cbiAgICAgICAgICAgIE0uY29tcGFyYXRvclxuICAgICAgICAgIGluXG4gICAgICAgICAgVHVwbGUyLmNvbXBhcmF0b3Igb3V0ZXJfY29tcGFyYXRvciBpbm5lcl9jb21wYXJhdG9yXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICBjb2xsYXBzZV9ieVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+bWVyZ2Vfa2V5czpUdXBsZTIuY3JlYXRlXG4gICAgICAgIH5jb21wYXJhdG9yOihtb2R1bGUgQ21wKSlcbiAgOztcblxuICBsZXQgZXhwYW5kID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+dXBkYXRlOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5vbGRfZGF0YTpfIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBNYXAuc2luZ2xldG9uIGlubmVyX2NvbXBhcmF0b3IgaW5uZXJfa2V5IG5ld19kYXRhXG4gICAgICAgICAgfCBTb21lIG1hcCAtPiBNYXAuc2V0IG1hcCB+a2V5OmlubmVyX2tleSB+ZGF0YTpuZXdfZGF0YSkpXG4gICAgICB+YWRkOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAudXBkYXRlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE1hcC5zaW5nbGV0b24gaW5uZXJfY29tcGFyYXRvciBpbm5lcl9rZXkgZGF0YVxuICAgICAgICAgIHwgU29tZSBtYXAgLT4gTWFwLmFkZF9leG4gbWFwIH5rZXk6aW5uZXJfa2V5IH5kYXRhKSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLmNoYW5nZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIG1hcCAtPlxuICAgICAgICAgICAgbGV0IG1hcCA9IE1hcC5yZW1vdmUgbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgT3B0aW9uLnNvbWVfaWYgKG5vdCAoTWFwLmlzX2VtcHR5IG1hcCkpIG1hcCkpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6MFxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBjb3VudCAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBjb3VudCAtIDEgZWxzZSBjb3VudClcbiAgOztcblxuICBsZXQgY291bnQgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mKSB+ZjooZnVuIGNvdW50IC0+IGNvdW50IDw+IDApXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgZXhpc3RzaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHN1bVxuICAgICAgICAodHlwZSB1KVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAobWFwX2luY3IgOiAoKF8sIF8sIF8pIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICAobW9kdWxlIEdyb3VwIDogQWJzdHJhY3RfYWxnZWJyYS5Db21tdXRhdGl2ZV9ncm91cC5XaXRob3V0X3NleHAgd2l0aCB0eXBlIHQgPSB1KVxuICAgICAgICB+ZlxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDpHcm91cC56ZXJvXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleTpfIH5kYXRhOnYgYWNjIC0+IEdyb3VwLiggKyApIGFjYyAoZiB2KSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5Ol8gfmRhdGE6diBhY2MgLT4gR3JvdXAuKCAtICkgYWNjIChmIHYpKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxuICAgICAgfmY6KGZ1biBjb3VudCAtPiBjb3VudCA9IDApXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGZvcl9hbGxpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyID0gZmluZF9rZXlfcmFuZ2VfbGluZWFyXG4gIGVuZFxuXG4gIG1vZHVsZSBMb29rdXAgPSBzdHJ1Y3RcbiAgICB0eXBlICgndiwgJ3cpIGVudHJ5ID1cbiAgICAgIHsgbXV0YWJsZSBzYXZlZF92YWx1ZSA6ICd2IG9wdGlvblxuICAgICAgOyBub2RlIDogKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnRcbiAgICAgIH1cblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIHNhdmVkX21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICAoKiBXZSBtYXkgaGF2ZSBtdWx0aXBsZSBlbnRyaWVzIHBlciBrZXkgaWYgbm9kZXMgYmVjb21lIG5lY2Vzc2FyeSBhZ2FpbiBhZnRlciBiZWluZ1xuICAgICAgICAgcmVtb3ZlZC4gKilcbiAgICAgIDsgbXV0YWJsZSBsb29rdXBfZW50cmllcyA6ICgnaywgKCd2LCAndykgZW50cnkgbGlzdCwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgdXBkYXRlcl9ub2RlIDogKHVuaXQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICA7IHNjb3BlIDogJ3cgSW5jcmVtZW50YWwuU2NvcGUudFxuICAgICAgfVxuXG4gICAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgICAgdHlwZSB0XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICBlbmQpID1cbiAgICBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgndiwgJ3cpIHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MsICd3KSB0XG4gICAgZW5kXG5cbiAgICBsZXQgY3JlYXRlID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpIGlucHV0X21hcCB+Y29tcGFyYXRvciA9XG4gICAgICBsZXQgcmVjIHNlbGYgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKGxldCB1cGRhdGVyX25vZGUgPVxuICAgICAgICAgICAgIEluY3JlbWVudGFsLm1hcCBpbnB1dF9tYXAgfmY6KGZ1biBpbnB1dF9tYXAgLT5cbiAgICAgICAgICAgICAgIGxldCAobGF6eSBzZWxmKSA9IHNlbGYgaW5cbiAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgIHNlbGYuc2F2ZWRfbWFwXG4gICAgICAgICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICB+aW5pdDooKVxuICAgICAgICAgICAgICAgICB+ZjooZnVuICgpIChrZXksIGNoYW5nZWRfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBNYXAuZmluZF9tdWx0aSBzZWxmLmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIExpc3QuaXRlciBlbnRyaWVzIH5mOihmdW4gZW50cnkgLT5cbiAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICA8LSAobWF0Y2ggY2hhbmdlZF92YWx1ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld192YWx1ZSB8IGBVbmVxdWFsIChfLCBuZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgU29tZSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBlbnRyeS5ub2RlKSk7XG4gICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcCA8LSBpbnB1dF9tYXApXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgICB7IHNhdmVkX21hcCA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IGxvb2t1cF9lbnRyaWVzID0gZW1wdHlfbWFwXG4gICAgICAgICAgIDsgdXBkYXRlcl9ub2RlXG4gICAgICAgICAgIDsgc2NvcGUgPSBJbmNyZW1lbnRhbC5TY29wZS5jdXJyZW50IChJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXApICgpXG4gICAgICAgICAgIH0pXG4gICAgICBpblxuICAgICAgTGF6eS5mb3JjZSBzZWxmXG4gICAgOztcblxuICAgIGxldFtAY29sZF0gc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5IH5pc19ub3dfb2JzZXJ2YWJsZSA9XG4gICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgIGxldCBjdXJyZW50X2VudHJpZXMgPSBNYXAuZmluZF9tdWx0aSB0Lmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgbGV0IGlzX2xpbmtlZCA9IExpc3QuZXhpc3RzIGN1cnJlbnRfZW50cmllcyB+ZjoocGh5c19lcXVhbCBlbnRyeSkgaW5cbiAgICAgIGlmIEJvb2wuZXF1YWwgaXNfbGlua2VkIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuXG4gICAgICAgIHQubG9va3VwX2VudHJpZXNcbiAgICAgICAgPC0gTWFwLnVwZGF0ZSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgKG90aGVyX2VudHJ5IDo6IF8gYXMgb3RoZXJfZW50cmllcykgLT5cbiAgICAgICAgICAgICgqIFVwZGF0ZSB0aGlzIGVudHJ5J3MgdmFsdWUgdG8gYmUgY3VycmVudC4gKilcbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIG90aGVyX2VudHJ5LnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgZW50cnkgOjogb3RoZXJfZW50cmllc1xuICAgICAgICAgIHwgTm9uZSB8IFNvbWUgW10gLT5cbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleTtcbiAgICAgICAgICAgIFsgZW50cnkgXSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV3X2VudHJpZXMgPVxuICAgICAgICAgIExpc3QuZmlsdGVyIGN1cnJlbnRfZW50cmllcyB+ZjooZnVuIHggLT4gbm90IChwaHlzX2VxdWFsIGVudHJ5IHgpKVxuICAgICAgICBpblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgIDwtIChpZiBMaXN0LmlzX2VtcHR5IG5ld19lbnRyaWVzXG4gICAgICAgICAgICB0aGVuIE1hcC5yZW1vdmUgdC5sb29rdXBfZW50cmllcyBrZXlcbiAgICAgICAgICAgIGVsc2UgTWFwLnNldCB0Lmxvb2t1cF9lbnRyaWVzIH5rZXkgfmRhdGE6bmV3X2VudHJpZXMpKVxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleSA9XG4gICAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSB0LnVwZGF0ZXJfbm9kZSBpblxuICAgICAgSW5jcmVtZW50YWwuU2NvcGUud2l0aGluIGluY3JlbWVudGFsX3N0YXRlIHQuc2NvcGUgfmY6KGZ1biAoKSAtPlxuICAgICAgICBsZXQgcmVjIGVudHJ5ID1cbiAgICAgICAgICBsYXp5XG4gICAgICAgICAgICB7IHNhdmVkX3ZhbHVlID0gTWFwLmZpbmQgdC5zYXZlZF9tYXAga2V5XG4gICAgICAgICAgICA7IG5vZGUgPVxuICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgaW5jcmVtZW50YWxfc3RhdGVcbiAgICAgICAgICAgICAgICAgIChmdW4gKCkgLT4gKGZvcmNlIGVudHJ5KS5zYXZlZF92YWx1ZSlcbiAgICAgICAgICAgICAgICAgIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZTooc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5KVxuICAgICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgICBlbnRyeS5ub2RlXG4gICAgICAgICAgKEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSB0LnVwZGF0ZXJfbm9kZSk7XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIGVudHJ5Lm5vZGUpXG4gICAgOztcblxuICAgIGxldCBmaW5kIHQga2V5ID1cbiAgICAgIG1hdGNoIE1hcC5maW5kX211bHRpIHQubG9va3VwX2VudHJpZXMga2V5IHdpdGhcbiAgICAgIHwgZW50cnkgOjogXyAtPiBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBlbnRyeS5ub2RlXG4gICAgICB8IFtdIC0+IHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnID0gc3RydWN0XG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfZW50cnkgc2V4cF9vZl92YWx1ZSBlbnRyeSA9XG4gICAgICAgIGxldCB7IHNhdmVkX3ZhbHVlOyBub2RlIH0gPSBlbnRyeSBpblxuICAgICAgICBsZXQgbm9kZSA9IEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG5vZGUgaW5cbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgeyBzYXZlZF92YWx1ZSA6IHZhbHVlIG9wdGlvblxuICAgICAgICAgIDsgbm9kZV9pbmZvID0gKEluY3JlbWVudGFsLnVzZXJfaW5mbyBub2RlIDogKEluZm8udCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2NvbnN0ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChJbmNyZW1lbnRhbC5pc19jb25zdCBub2RlKSAoKSA6ICh1bml0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICA7IG5vZGVfaXNfaW52YWxpZCA9XG4gICAgICAgICAgICAgIChPcHRpb24uc29tZV9pZiAobm90IChJbmNyZW1lbnRhbC5pc192YWxpZCBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX3VubmVjZXNzYXJ5ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChub3QgKEluY3JlbWVudGFsLmlzX25lY2Vzc2FyeSBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgIH1dXG4gICAgICA7O1xuXG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgICAgICBsZXQgaW5mb19wZXJfa2V5ID1cbiAgICAgICAgICBNYXAubWVyZ2UgdC5zYXZlZF9tYXAgdC5sb29rdXBfZW50cmllcyB+ZjooZnVuIH5rZXkgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IGFjdHVhbF92YWx1ZSwgZW50cmllcyA9XG4gICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSB4LCBbXVxuICAgICAgICAgICAgICB8IGBSaWdodCB5IC0+IE5vbmUsIHlcbiAgICAgICAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gU29tZSB4LCB5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICBbJXNleHBcbiAgICAgICAgICAgICAgICB7IGtleSA6IGtleVxuICAgICAgICAgICAgICAgIDsgYWN0dWFsX3ZhbHVlIDogKHZhbHVlIG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgICAgICAgICAgICAgIDsgZW50cmllcyA6IHZhbHVlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB9XSlcbiAgICAgICAgaW5cbiAgICAgICAgU2V4cC5MaXN0IChNYXAuZGF0YSBpbmZvX3Blcl9rZXkpXG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgc3RhdGVfd2l0bmVzc1xuXG4gIGluY2x1ZGVcbiAgICBTX2dlblxuICAgIHdpdGggdHlwZSAnYSBJbmNyLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgYW5kIHR5cGUgJ2EgSW5jci5DdXRvZmYudCA9ICdhIEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgIGFuZCB0eXBlICgnaywgJ3YsICdjbXApIExvb2t1cC50ID0gKCdrLCAndiwgJ2NtcCwgc3RhdGVfd2l0bmVzcykgR2VuZXJpYy5Mb29rdXAudFxuZW5kXG5cbm1vZHVsZSBNYWtlIChJbmNyIDogSW5jcmVtZW50YWwuUykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IGZsYXR0ZW4geCA9IGZsYXR0ZW4gSW5jci5TdGF0ZS50IHhcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgaW5jbHVkZSBMb29rdXBcblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXAsIEluY3Iuc3RhdGVfd2l0bmVzcykgTG9va3VwLnRcblxuICAgIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICAgIHR5cGUgdFxuICAgICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgZW5kKSA6IHNpZ1xuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEdlbmVyaWNcbiJdfQ==
