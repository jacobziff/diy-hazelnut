// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Async_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Async_kernel = [0];
   runtime.caml_register_global(0, Async_kernel, "Async_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_ns
//# unitInfo: Requires: Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_ns = "Async_kernel__Time_ns",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_ns);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/time_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    typerep_of_t = Core_Time_ns_alternate_sexp[1],
    typename_of_t = Core_Time_ns_alternate_sexp[2],
    bin_size_t = Core_Time_ns_alternate_sexp[3],
    bin_write_t = Core_Time_ns_alternate_sexp[4],
    bin_read_t = Core_Time_ns_alternate_sexp[5],
    bin_read_t$0 = Core_Time_ns_alternate_sexp[6],
    bin_shape_t = Core_Time_ns_alternate_sexp[7],
    bin_writer_t = Core_Time_ns_alternate_sexp[8],
    bin_reader_t = Core_Time_ns_alternate_sexp[9],
    bin_t = Core_Time_ns_alternate_sexp[10],
    quickcheck_generator = Core_Time_ns_alternate_sexp[11],
    quickcheck_observer = Core_Time_ns_alternate_sexp[12],
    quickcheck_shrinker = Core_Time_ns_alternate_sexp[13],
    gen_incl = Core_Time_ns_alternate_sexp[14],
    gen_uniform_incl = Core_Time_ns_alternate_sexp[15],
    is_earlier = Core_Time_ns_alternate_sexp[16],
    is_later = Core_Time_ns_alternate_sexp[17],
    of_date_ofday = Core_Time_ns_alternate_sexp[18],
    of_date_ofday_precise = Core_Time_ns_alternate_sexp[19],
    to_date_ofday = Core_Time_ns_alternate_sexp[20],
    to_date_ofday_precise = Core_Time_ns_alternate_sexp[21],
    to_date = Core_Time_ns_alternate_sexp[22],
    to_ofday = Core_Time_ns_alternate_sexp[23],
    reset_date_cache = Core_Time_ns_alternate_sexp[24],
    convert = Core_Time_ns_alternate_sexp[25],
    utc_offset = Core_Time_ns_alternate_sexp[26],
    to_filename_string = Core_Time_ns_alternate_sexp[27],
    of_filename_string = Core_Time_ns_alternate_sexp[28],
    to_string_abs = Core_Time_ns_alternate_sexp[29],
    to_string_abs_trimmed = Core_Time_ns_alternate_sexp[30],
    to_string_abs_parts = Core_Time_ns_alternate_sexp[31],
    to_string_trimmed = Core_Time_ns_alternate_sexp[32],
    to_sec_string = Core_Time_ns_alternate_sexp[33],
    to_sec_string_with_zone = Core_Time_ns_alternate_sexp[34],
    of_localized_string = Core_Time_ns_alternate_sexp[35],
    of_string_gen = Core_Time_ns_alternate_sexp[36],
    to_string_iso8601_basic = Core_Time_ns_alternate_sexp[37],
    occurrence = Core_Time_ns_alternate_sexp[38],
    of_string = Core_Time_ns_alternate_sexp[39],
    of_string_with_utc_offset = Core_Time_ns_alternate_sexp[40],
    to_string = Core_Time_ns_alternate_sexp[41],
    to_string_utc = Core_Time_ns_alternate_sexp[42],
    epoch = Core_Time_ns_alternate_sexp[43],
    min_value_representable = Core_Time_ns_alternate_sexp[44],
    max_value_representable = Core_Time_ns_alternate_sexp[45],
    min_value_for_1us_rounding = Core_Time_ns_alternate_sexp[46],
    max_value_for_1us_rounding = Core_Time_ns_alternate_sexp[47],
    min_value = Core_Time_ns_alternate_sexp[48],
    max_value = Core_Time_ns_alternate_sexp[49],
    now = Core_Time_ns_alternate_sexp[50],
    add = Core_Time_ns_alternate_sexp[51],
    add_saturating = Core_Time_ns_alternate_sexp[52],
    sub_saturating = Core_Time_ns_alternate_sexp[53],
    sub = Core_Time_ns_alternate_sexp[54],
    next = Core_Time_ns_alternate_sexp[55],
    prev = Core_Time_ns_alternate_sexp[56],
    diff = Core_Time_ns_alternate_sexp[57],
    abs_diff = Core_Time_ns_alternate_sexp[58],
    to_span_since_epoch = Core_Time_ns_alternate_sexp[59],
    of_span_since_epoch = Core_Time_ns_alternate_sexp[60],
    to_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[61],
    of_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[62],
    to_int_ns_since_epoch = Core_Time_ns_alternate_sexp[63],
    of_int_ns_since_epoch = Core_Time_ns_alternate_sexp[64],
    next_multiple = Core_Time_ns_alternate_sexp[65],
    prev_multiple = Core_Time_ns_alternate_sexp[66],
    random = Core_Time_ns_alternate_sexp[67],
    of_time = Core_Time_ns_alternate_sexp[68],
    to_time = Core_Time_ns_alternate_sexp[69],
    to_time_float_round_nearest = Core_Time_ns_alternate_sexp[70],
    to_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[71],
    of_time_float_round_nearest = Core_Time_ns_alternate_sexp[72],
    of_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[73],
    arg_type = Core_Time_ns_alternate_sexp[74],
    get_sexp_zone = Core_Time_ns_alternate_sexp[75],
    interruptible_pause = Core_Time_ns_alternate_sexp[76],
    of_date_ofday_zoned = Core_Time_ns_alternate_sexp[77],
    of_string_abs = Core_Time_ns_alternate_sexp[78],
    of_string_fix_proto = Core_Time_ns_alternate_sexp[79],
    pause = Core_Time_ns_alternate_sexp[80],
    pause_forever = Core_Time_ns_alternate_sexp[81],
    pp = Core_Time_ns_alternate_sexp[82],
    set_sexp_zone = Core_Time_ns_alternate_sexp[83],
    sexp_of_t_abs = Core_Time_ns_alternate_sexp[84],
    t_of_sexp_abs = Core_Time_ns_alternate_sexp[85],
    to_date_ofday_zoned = Core_Time_ns_alternate_sexp[86],
    to_ofday_zoned = Core_Time_ns_alternate_sexp[87],
    to_string_fix_proto = Core_Time_ns_alternate_sexp[88],
    hash_fold_t = Core_Time_ns_alternate_sexp[89],
    hash = Core_Time_ns_alternate_sexp[90],
    t_of_sexp = Core_Time_ns_alternate_sexp[91],
    sexp_of_t = Core_Time_ns_alternate_sexp[92],
    t_sexp_grammar = Core_Time_ns_alternate_sexp[93],
    symbol = Core_Time_ns_alternate_sexp[94],
    symbol$0 = Core_Time_ns_alternate_sexp[95],
    symbol$1 = Core_Time_ns_alternate_sexp[96],
    symbol$2 = Core_Time_ns_alternate_sexp[97],
    symbol$3 = Core_Time_ns_alternate_sexp[98],
    symbol$4 = Core_Time_ns_alternate_sexp[99],
    equal = Core_Time_ns_alternate_sexp[100],
    compare = Core_Time_ns_alternate_sexp[101],
    min = Core_Time_ns_alternate_sexp[102],
    max = Core_Time_ns_alternate_sexp[103],
    ascending = Core_Time_ns_alternate_sexp[104],
    descending = Core_Time_ns_alternate_sexp[105],
    between = Core_Time_ns_alternate_sexp[106],
    clamp_exn = Core_Time_ns_alternate_sexp[107],
    clamp = Core_Time_ns_alternate_sexp[108],
    comparator = Core_Time_ns_alternate_sexp[109],
    validate_lbound = Core_Time_ns_alternate_sexp[110],
    validate_ubound = Core_Time_ns_alternate_sexp[111],
    validate_bound = Core_Time_ns_alternate_sexp[112];
   function after(t, span){
    var result = caml_call2(add, t, span);
    if
     (caml_call2(Core_Time_ns[1][18], span, Core_Time_ns[1][75])
      && caml_call2(symbol$3, result, t))
     return max_value_for_1us_rounding;
    return result;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_ns);
   var
    Async_kernel_Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after];
   runtime.caml_register_global
    (13, Async_kernel_Time_ns, cst_Async_kernel_Time_ns);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Debug
//# unitInfo: Requires: Async_kernel__Time_ns, Async_kernel_config, Core, Core__Sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Debug = "Async_kernel__Debug",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_config = global_data.Async_kernel_config,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Debug);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/debug.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Async_kernel_config[14],
    clock = include[1],
    fd = include[2],
    file_descr_watcher = include[3],
    finalizers = include[4],
    interruptor = include[5],
    monitor = include[6],
    monitor_send_exn = include[7],
    parallel = include[8],
    reader = include[9],
    scheduler = include[10],
    shutdown = include[11],
    thread_pool = include[12],
    thread_safe = include[13],
    writer = include[14],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"];
   function log(arg2_003, arg3_004, sexp_of_a){
    var
     arg1_002 = caml_call1(Async_kernel_Time_ns[50], 0),
     arg0_001 = caml_call1(Async_kernel_config[31][1], 0),
     res0_005 = caml_call1(Core_Sexp[90], arg0_001),
     res1_006 = caml_call1(Async_kernel_Time_ns[92], arg1_002),
     res2_007 = caml_call1(Core[471], arg2_003),
     res3_008 = caml_call1(sexp_of_a, arg3_004),
     _b_ =
       caml_call2
        (Core_Sexp[81],
         0,
         [1, [0, res0_005, [0, res1_006, [0, res2_007, [0, res3_008, 0]]]]]);
    return caml_call2(Core[231], _a_, _b_);
   }
   function log_string(message){return log(message, 0, Core[518]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Debug);
   var
    Async_kernel_Debug =
      [0,
       clock,
       fd,
       file_descr_watcher,
       finalizers,
       interruptor,
       monitor,
       monitor_send_exn,
       parallel,
       reader,
       scheduler,
       shutdown,
       thread_pool,
       thread_safe,
       writer,
       log,
       log_string];
   runtime.caml_register_global
    (16, Async_kernel_Debug, cst_Async_kernel_Debug);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Import
//# unitInfo: Requires: Core, Core__Debug, Core__Int, Core__Sexp, Core__String, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Import = "Async_kernel__Import",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Debug = global_data.Core__Debug,
    Core_Time_ns = global_data.Core__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Core_Int[99],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    concat = Core_String[32],
    eprint = Core_Debug[1],
    eprint_s = Core_Debug[3],
    eprints = Core_Debug[2],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"];
   function print_s(sexp){
    var _b_ = caml_call2(Core_Sexp[81], 0, sexp);
    return caml_call2(Core[250], _a_, _b_);
   }
   var sec = Core_Time_ns[1][81], Thread = [0], Unix = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Import);
   var
    Async_kernel_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       concat,
       eprint,
       eprint_s,
       eprints,
       print_s,
       sec,
       Thread,
       Unix];
   runtime.caml_register_global
    (18, Async_kernel_Import, cst_Async_kernel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Priority
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Priority = "Async_kernel__Priority",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Priority);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/priority.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "Low"], _b_ = [0, "Normal"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Priority);
   var Async_kernel_Priority = [0, sexp_of_t, 0, 1];
   runtime.caml_register_global
    (13, Async_kernel_Priority, cst_Async_kernel_Priority);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Types
//# unitInfo: Requires: CamlinternalMod, Core__Unique_id, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Types = "Async_kernel__Types",
    cst_async_kernel = "async_kernel",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    CamlinternalMod = global_data.CamlinternalMod,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Types);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    Cell =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 37, 2], [0, [0]]),
    Handler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 42, 2], [0, [0]]),
    Ivar =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 51, 2], [0, [0, [0, [0]]]]),
    Deferred =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 56, 2], [0, [0]]),
    Execution_context =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 66, 2], [0, [0]]),
    Forwarding =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 74, 2], [0, [0]]),
    Monitor =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 88, 2], [0, [0]]),
    Tail =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 93, 2], [0, [0]]),
    Stream =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 102, 2], [0, [0]]);
   caml_call3(CamlinternalMod[2], [0, [0]], Cell, Cell);
   caml_call3(CamlinternalMod[2], [0, [0]], Handler, Handler);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]]]], Ivar, Ivar);
   caml_call3(CamlinternalMod[2], [0, [0]], Deferred, Deferred);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Execution_context, Execution_context);
   caml_call3(CamlinternalMod[2], [0, [0]], Forwarding, Forwarding);
   caml_call3(CamlinternalMod[2], [0, [0]], Monitor, Monitor);
   caml_call3(CamlinternalMod[2], [0, [0]], Tail, Tail);
   caml_call3(CamlinternalMod[2], [0, [0]], Stream, Stream);
   function to_repr(t){return t;}
   function of_repr(t){return t;}
   var
    Bvar = [0, of_repr, to_repr],
    Event =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 155, 2],
        [0, [0, [0, [0]], [0, [0]]]]),
    External_job =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 160, 2], [0, [0]]),
    Job =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 166, 2], [0, [0]]),
    Job_or_event =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 171, 2], [0, [0]]),
    Job_pool =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 176, 2], [0, [0]]),
    Job_queue =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 188, 2], [0, [0]]),
    Jobs =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 198, 2], [0, [0]]),
    Scheduler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 233, 2], [0, [0]]),
    Cycle_hook =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 238, 2], [0, [0]]),
    Time_source =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 256, 2], [0, [0]]),
    Very_low_priority_worker =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 270, 2], [0, [0, [0, [0]]]]),
    Cycle_hook_handle = caml_call1(Core_Unique_id[2], [0]),
    Time_source_id = caml_call1(Core_Unique_id[2], [0]);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]], [0, [0]]]], Event, Event);
   caml_call3(CamlinternalMod[2], [0, [0]], External_job, External_job);
   caml_call3(CamlinternalMod[2], [0, [0]], Job, Job);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_or_event, Job_or_event);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_pool, Job_pool);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_queue, Job_queue);
   caml_call3(CamlinternalMod[2], [0, [0]], Jobs, Jobs);
   caml_call3(CamlinternalMod[2], [0, [0]], Scheduler, Scheduler);
   caml_call3(CamlinternalMod[2], [0, [0]], Cycle_hook, Cycle_hook);
   caml_call3(CamlinternalMod[2], [0, [0]], Time_source, Time_source);
   caml_call3
    (CamlinternalMod[2],
     [0, [0, [0, [0]]]],
     Very_low_priority_worker,
     Very_low_priority_worker);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Types);
   var
    Async_kernel_Types =
      [0,
       Cell,
       Handler,
       Ivar,
       Deferred,
       Execution_context,
       Forwarding,
       Monitor,
       Tail,
       Stream,
       Bvar,
       Event,
       External_job,
       Job,
       Job_or_event,
       Job_pool,
       Job_queue,
       Jobs,
       Scheduler,
       Cycle_hook,
       Cycle_hook_handle,
       Time_source_id,
       Time_source,
       Very_low_priority_worker];
   runtime.caml_register_global
    (73, Async_kernel_Types, cst_Async_kernel_Types);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor0
//# unitInfo: Requires: Async_kernel__Debug, Base__Field, Core, Core__Bag, Core__Info, Core__List, Core__Sexp, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monitor0 = "Async_kernel__Monitor0",
    cst_async_kernel = "async_kernel",
    cst_forwarding = "forwarding",
    cst_handlers_for_all_errors = "handlers_for_all_errors",
    cst_has_seen_error = "has_seen_error",
    cst_here = "here",
    cst_id$0 = "id",
    cst_name = "name",
    cst_next_error = "next_error",
    cst_tails_for_all_errors = "tails_for_all_errors";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_name,
       [0,
        cst_here,
        [0,
         cst_id$0,
         [0,
          cst_next_error,
          [0,
           cst_handlers_for_all_errors,
           [0,
            cst_tails_for_all_errors,
            [0, cst_has_seen_error, [0, cst_forwarding, 0]]]]]]]],
    Core = global_data.Core,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Core_Info = global_data.Core__Info,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/monitor0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var debug = Async_kernel_Debug[6];
   function forwarding(r){return r[8];}
   function set_forwarding(r, v){r[8] = v; return 0;}
   function has_seen_error(r){return r[7];}
   function set_has_seen_error(r, v){r[7] = v; return 0;}
   function tails_for_all_errors(r){return r[6];}
   function set_tails_for_all_errors(r, v){r[6] = v; return 0;}
   function handlers_for_all_errors(r){return r[5];}
   function set_handlers_for_all_errors(r, v){r[5] = v; return 0;}
   function next_error(r){return r[4];}
   function set_next_error(r, v){r[4] = v; return 0;}
   function id(r){return r[3];}
   function here(r){return r[2];}
   function name(r){return r[1];}
   var
    forwarding$0 =
      [0,
       function(param){return 0;},
       cst_forwarding,
       [0, set_forwarding],
       forwarding,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
       }],
    has_seen_error$0 =
      [0,
       function(param){return 0;},
       cst_has_seen_error,
       [0, set_has_seen_error],
       has_seen_error,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
       }],
    tails_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_tails_for_all_errors,
       [0, set_tails_for_all_errors],
       tails_for_all_errors,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
       }],
    handlers_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_handlers_for_all_errors,
       [0, set_handlers_for_all_errors],
       handlers_for_all_errors,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
       }],
    next_error$0 =
      [0,
       function(param){return 0;},
       cst_next_error,
       [0, set_next_error],
       next_error,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
       }],
    id$0 =
      [0,
       function(param){return 0;},
       cst_id$0,
       0,
       id,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
       }],
    here$0 =
      [0,
       function(param){return 0;},
       cst_here,
       0,
       here,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
       }],
    name$0 =
      [0,
       function(param){return 0;},
       cst_name,
       0,
       name,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
       }];
   function make_creator
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun,
    compile_acc){
    var
     match = caml_call2(name_fun, name$0, compile_acc),
     compile_acc$0 = match[2],
     name_gen = match[1],
     match$0 = caml_call2(here_fun, here$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     here_gen = match$0[1],
     match$1 = caml_call2(id_fun, id$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     id_gen = match$1[1],
     match$2 = caml_call2(next_error_fun, next_error$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     next_error_gen = match$2[1],
     match$3 =
       caml_call2
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     handlers_for_all_errors_gen = match$3[1],
     match$4 =
       caml_call2
        (tails_for_all_errors_fun, tails_for_all_errors$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     tails_for_all_errors_gen = match$4[1],
     match$5 = caml_call2(has_seen_error_fun, has_seen_error$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     has_seen_error_gen = match$5[1],
     match$6 = caml_call2(forwarding_fun, forwarding$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     forwarding_gen = match$6[1];
    return [0,
            function(acc){
             var
              name = caml_call1(name_gen, acc),
              here = caml_call1(here_gen, acc),
              id = caml_call1(id_gen, acc),
              next_error = caml_call1(next_error_gen, acc),
              handlers_for_all_errors =
                caml_call1(handlers_for_all_errors_gen, acc),
              tails_for_all_errors = caml_call1(tails_for_all_errors_gen, acc),
              has_seen_error = caml_call1(has_seen_error_gen, acc),
              forwarding = caml_call1(forwarding_gen, acc);
             return [0,
                     name,
                     here,
                     id,
                     next_error,
                     handlers_for_all_errors,
                     tails_for_all_errors,
                     has_seen_error,
                     forwarding];
            },
            compile_acc$7];
   }
   function create
   (name,
    here,
    id,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    return [0,
            name,
            here,
            id,
            next_error,
            handlers_for_all_errors,
            tails_for_all_errors,
            has_seen_error,
            forwarding];
   }
   function map
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _am_ = caml_call1(forwarding_fun, forwarding$0),
     _an_ = caml_call1(has_seen_error_fun, has_seen_error$0),
     _ao_ = caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _ap_ = caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _aq_ = caml_call1(next_error_fun, next_error$0),
     _ar_ = caml_call1(id_fun, id$0),
     _as_ = caml_call1(here_fun, here$0);
    return [0,
            caml_call1(name_fun, name$0),
            _as_,
            _ar_,
            _aq_,
            _ap_,
            _ao_,
            _an_,
            _am_];
   }
   function iter
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call1(name_fun, name$0);
    caml_call1(here_fun, here$0);
    caml_call1(id_fun, id$0);
    caml_call1(next_error_fun, next_error$0);
    caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0);
    caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0);
    caml_call1(has_seen_error_fun, has_seen_error$0);
    return caml_call1(forwarding_fun, forwarding$0);
   }
   function fold
   (init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    return caml_call2
            (forwarding_fun,
             caml_call2
              (has_seen_error_fun,
               caml_call2
                (tails_for_all_errors_fun,
                 caml_call2
                  (handlers_for_all_errors_fun,
                   caml_call2
                    (next_error_fun,
                     caml_call2
                      (id_fun,
                       caml_call2
                        (here_fun, caml_call2(name_fun, init, name$0), here$0),
                       id$0),
                     next_error$0),
                   handlers_for_all_errors$0),
                 tails_for_all_errors$0),
               has_seen_error$0),
             forwarding$0);
   }
   function map_poly(record){
    var
     _af_ = [0, caml_call1(record[1], forwarding$0), 0],
     _ag_ = [0, caml_call1(record[1], has_seen_error$0), _af_],
     _ah_ = [0, caml_call1(record[1], tails_for_all_errors$0), _ag_],
     _ai_ = [0, caml_call1(record[1], handlers_for_all_errors$0), _ah_],
     _aj_ = [0, caml_call1(record[1], next_error$0), _ai_],
     _ak_ = [0, caml_call1(record[1], id$0), _aj_],
     _al_ = [0, caml_call1(record[1], here$0), _ak_];
    return [0, caml_call1(record[1], name$0), _al_];
   }
   function for_all
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     ___ = caml_call1(name_fun, name$0),
     _$_ = ___ ? caml_call1(here_fun, here$0) : ___,
     _aa_ = _$_ ? caml_call1(id_fun, id$0) : _$_,
     _ab_ = _aa_ ? caml_call1(next_error_fun, next_error$0) : _aa_,
     _ac_ =
       _ab_
        ? caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0)
        : _ab_,
     _ad_ =
       _ac_
        ? caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0)
        : _ac_,
     _ae_ = _ad_ ? caml_call1(has_seen_error_fun, has_seen_error$0) : _ad_;
    return _ae_ ? caml_call1(forwarding_fun, forwarding$0) : _ae_;
   }
   function exists
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _Z_ = caml_call1(name_fun, name$0),
     _T_ = _Z_ || caml_call1(here_fun, here$0),
     _U_ = _T_ || caml_call1(id_fun, id$0),
     _V_ = _U_ || caml_call1(next_error_fun, next_error$0),
     _W_ =
       _V_
       || caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _X_ = _W_ || caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _Y_ = _X_ || caml_call1(has_seen_error_fun, has_seen_error$0);
    return _Y_ ? _Y_ : caml_call1(forwarding_fun, forwarding$0);
   }
   function to_list
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _M_ = [0, caml_call1(forwarding_fun, forwarding$0), 0],
     _N_ = [0, caml_call1(has_seen_error_fun, has_seen_error$0), _M_],
     _O_ =
       [0, caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0), _N_],
     _P_ =
       [0,
        caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
        _O_],
     _Q_ = [0, caml_call1(next_error_fun, next_error$0), _P_],
     _R_ = [0, caml_call1(id_fun, id$0), _Q_],
     _S_ = [0, caml_call1(here_fun, here$0), _R_];
    return [0, caml_call1(name_fun, name$0), _S_];
   }
   function iter$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call3(name_fun, name$0, record, record[1]);
    caml_call3(here_fun, here$0, record, record[2]);
    caml_call3(id_fun, id$0, record, record[3]);
    caml_call3(next_error_fun, next_error$0, record, record[4]);
    caml_call3
     (handlers_for_all_errors_fun,
      handlers_for_all_errors$0,
      record,
      record[5]);
    caml_call3
     (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]);
    caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _F_ = record[8],
     _G_ = record[7],
     _H_ = record[6],
     _I_ = record[5],
     _J_ = record[4],
     _K_ = record[3],
     _L_ = record[2];
    return caml_call4
            (forwarding_fun,
             caml_call4
              (has_seen_error_fun,
               caml_call4
                (tails_for_all_errors_fun,
                 caml_call4
                  (handlers_for_all_errors_fun,
                   caml_call4
                    (next_error_fun,
                     caml_call4
                      (id_fun,
                       caml_call4
                        (here_fun,
                         caml_call4(name_fun, init, name$0, record, record[1]),
                         here$0,
                         record,
                         _L_),
                       id$0,
                       record,
                       _K_),
                     next_error$0,
                     record,
                     _J_),
                   handlers_for_all_errors$0,
                   record,
                   _I_),
                 tails_for_all_errors$0,
                 record,
                 _H_),
               has_seen_error$0,
               record,
               _G_),
             forwarding$0,
             record,
             _F_);
   }
   function for_all$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _y_ = caml_call3(name_fun, name$0, record, record[1]),
     _z_ = _y_ ? caml_call3(here_fun, here$0, record, record[2]) : _y_,
     _A_ = _z_ ? caml_call3(id_fun, id$0, record, record[3]) : _z_,
     _B_ =
       _A_ ? caml_call3(next_error_fun, next_error$0, record, record[4]) : _A_,
     _C_ =
       _B_
        ? caml_call3
          (handlers_for_all_errors_fun,
           handlers_for_all_errors$0,
           record,
           record[5])
        : _B_,
     _D_ =
       _C_
        ? caml_call3
          (tails_for_all_errors_fun,
           tails_for_all_errors$0,
           record,
           record[6])
        : _C_,
     _E_ =
       _D_
        ? caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7])
        : _D_;
    return _E_
            ? caml_call3(forwarding_fun, forwarding$0, record, record[8])
            : _E_;
   }
   function exists$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _x_ = caml_call3(name_fun, name$0, record, record[1]),
     _r_ = _x_ || caml_call3(here_fun, here$0, record, record[2]),
     _s_ = _r_ || caml_call3(id_fun, id$0, record, record[3]),
     _t_ = _s_ || caml_call3(next_error_fun, next_error$0, record, record[4]),
     _u_ =
       _t_
       ||
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
     _v_ =
       _u_
       ||
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _w_ =
       _v_
       || caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return _w_
            ? _w_
            : caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function to_list$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _k_ = [0, caml_call3(forwarding_fun, forwarding$0, record, record[8]), 0],
     _l_ =
       [0,
        caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
        _k_],
     _m_ =
       [0,
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
        _l_],
     _n_ =
       [0,
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
        _m_],
     _o_ =
       [0, caml_call3(next_error_fun, next_error$0, record, record[4]), _n_],
     _p_ = [0, caml_call3(id_fun, id$0, record, record[3]), _o_],
     _q_ = [0, caml_call3(here_fun, here$0, record, record[2]), _p_];
    return [0, caml_call3(name_fun, name$0, record, record[1]), _q_];
   }
   function map$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _d_ = caml_call3(forwarding_fun, forwarding$0, record, record[8]),
     _e_ = caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
     _f_ =
       caml_call3
        (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _g_ =
       caml_call3
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         record,
         record[5]),
     _h_ = caml_call3(next_error_fun, next_error$0, record, record[4]),
     _i_ = caml_call3(id_fun, id$0, record, record[3]),
     _j_ = caml_call3(here_fun, here$0, record, record[2]);
    return [0,
            caml_call3(name_fun, name$0, record, record[1]),
            _j_,
            _i_,
            _h_,
            _g_,
            _f_,
            _e_,
            _d_];
   }
   function set_all_mutable_fields
   (record,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[4] = next_error;
    record$0[5] = handlers_for_all_errors;
    record$0[6] = tails_for_all_errors;
    record$0[7] = has_seen_error;
    record$0[8] = forwarding;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       forwarding$0,
       has_seen_error$0,
       tails_for_all_errors$0,
       handlers_for_all_errors$0,
       next_error$0,
       id$0,
       here$0,
       name$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function description(t){
    var match = t[2];
    if(! match) return caml_call1(Core_Info[6], t[1]);
    var
     here = match[1],
     _c_ = [0, caml_call1(Core_Source_code_position[1], here), 0];
    return [1, [0, caml_call1(Core_Info[6], t[1]), _c_]];
   }
   function descriptions(t$1){
    var t = t$1, ac = 0;
    for(;;){
     var ac$0 = [0, description(t), ac], match = t[8];
     if(typeof match === "number") return caml_call1(Core_List[34], ac$0);
     var t$0 = match[1];
     t = t$0;
     ac = ac$0;
    }
   }
   function sexp_of_t(t){
    var x_001 = descriptions(t);
    return caml_call2(Core[421], Core_Sexp[90], x_001);
   }
   var r = [0, 0], cst_created_monitor = "created monitor", cst_id = cst_id$0;
   function next_id(param){r[1]++; return r[1];}
   function create_with_parent(here, info, name, parent){
    var id = next_id(0);
    if(info){
     var i = info[1];
     if(name)
      var s = name[1], _a_ = caml_call2(Core_Info[20], i, s);
     else
      var _a_ = i;
     var name$0 = _a_;
    }
    else if(name)
     var s$0 = name[1], name$0 = caml_call1(Core_Info[12], s$0);
    else
     var
      name$0 =
        caml_call5
         (Core_Info[17],
          0,
          0,
          cst_id,
          id,
          function(x_002){
           return caml_call2(Sexp_hidden_in_test[10], Core[356], x_002);
          });
    if(parent)
     var parent$0 = parent[1], _b_ = [0, parent$0];
    else
     var _b_ = 1;
    var
     t = [0, name$0, here, id, [0, 0], caml_call1(Core_Bag[22], 0), 0, 0, _b_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_created_monitor, t, sexp_of_t);
    return t;
   }
   var main = create_with_parent(0, 0, [0, "main"], 0);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor0);
   var
    Async_kernel_Monitor0 =
      [0,
       debug,
       forwarding,
       set_forwarding,
       has_seen_error,
       set_has_seen_error,
       tails_for_all_errors,
       set_tails_for_all_errors,
       handlers_for_all_errors,
       set_handlers_for_all_errors,
       next_error,
       set_next_error,
       id,
       here,
       name,
       Fields,
       description,
       descriptions,
       sexp_of_t,
       next_id,
       create_with_parent,
       main];
   runtime.caml_register_global
    (32, Async_kernel_Monitor0, cst_Async_kernel_Monitor0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Execution_context
//# unitInfo: Requires: Async_kernel__Monitor0, Async_kernel__Priority, Base__Backtrace, Base__Field, Core, Core__Option, Core__Univ_map, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Execution_con = "Async_kernel__Execution_context",
    cst_async_kernel = "async_kernel",
    cst_backtrace_history = "backtrace_history",
    cst_local_storage = "local_storage",
    cst_monitor = "monitor",
    cst_priority = "priority";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_monitor,
       [0,
        cst_priority,
        [0, cst_local_storage, [0, cst_backtrace_history, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Univ_map = global_data.Core__Univ_map,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Execution_con);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/execution_context.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function backtrace_history(r){return r[4];}
   function local_storage(r){return r[3];}
   function priority(r){return r[2];}
   function monitor(r){return r[1];}
   var
    backtrace_history$0 =
      [0,
       function(param){return 0;},
       cst_backtrace_history,
       0,
       backtrace_history,
       function(r, v){return [0, r[1], r[2], r[3], v];}],
    local_storage$0 =
      [0,
       function(param){return 0;},
       cst_local_storage,
       0,
       local_storage,
       function(r, v){return [0, r[1], r[2], v, r[4]];}],
    priority$0 =
      [0,
       function(param){return 0;},
       cst_priority,
       0,
       priority,
       function(r, v){return [0, r[1], v, r[3], r[4]];}],
    monitor$0 =
      [0,
       function(param){return 0;},
       cst_monitor,
       0,
       monitor,
       function(r, v){return [0, v, r[2], r[3], r[4]];}];
   function make_creator
   (monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun,
    compile_acc){
    var
     match = caml_call2(monitor_fun, monitor$0, compile_acc),
     compile_acc$0 = match[2],
     monitor_gen = match[1],
     match$0 = caml_call2(priority_fun, priority$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     priority_gen = match$0[1],
     match$1 = caml_call2(local_storage_fun, local_storage$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     local_storage_gen = match$1[1],
     match$2 =
       caml_call2(backtrace_history_fun, backtrace_history$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     backtrace_history_gen = match$2[1];
    return [0,
            function(acc){
             var
              monitor = caml_call1(monitor_gen, acc),
              priority = caml_call1(priority_gen, acc),
              local_storage = caml_call1(local_storage_gen, acc),
              backtrace_history = caml_call1(backtrace_history_gen, acc);
             return [0, monitor, priority, local_storage, backtrace_history];
            },
            compile_acc$3];
   }
   function create(monitor, priority, local_storage, backtrace_history){return [0, monitor, priority, local_storage, backtrace_history];
   }
   function map
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _L_ = caml_call1(backtrace_history_fun, backtrace_history$0),
     _M_ = caml_call1(local_storage_fun, local_storage$0),
     _N_ = caml_call1(priority_fun, priority$0);
    return [0, caml_call1(monitor_fun, monitor$0), _N_, _M_, _L_];
   }
   function iter
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    caml_call1(monitor_fun, monitor$0);
    caml_call1(priority_fun, priority$0);
    caml_call1(local_storage_fun, local_storage$0);
    return caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function fold
   (init, monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    return caml_call2
            (backtrace_history_fun,
             caml_call2
              (local_storage_fun,
               caml_call2
                (priority_fun,
                 caml_call2(monitor_fun, init, monitor$0),
                 priority$0),
               local_storage$0),
             backtrace_history$0);
   }
   function map_poly(record){
    var
     _I_ = [0, caml_call1(record[1], backtrace_history$0), 0],
     _J_ = [0, caml_call1(record[1], local_storage$0), _I_],
     _K_ = [0, caml_call1(record[1], priority$0), _J_];
    return [0, caml_call1(record[1], monitor$0), _K_];
   }
   function for_all
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _F_ = caml_call1(monitor_fun, monitor$0),
     _G_ = _F_ ? caml_call1(priority_fun, priority$0) : _F_,
     _H_ = _G_ ? caml_call1(local_storage_fun, local_storage$0) : _G_;
    return _H_ ? caml_call1(backtrace_history_fun, backtrace_history$0) : _H_;
   }
   function exists
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _E_ = caml_call1(monitor_fun, monitor$0),
     _C_ = _E_ || caml_call1(priority_fun, priority$0),
     _D_ = _C_ || caml_call1(local_storage_fun, local_storage$0);
    return _D_ ? _D_ : caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function to_list
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _z_ = [0, caml_call1(backtrace_history_fun, backtrace_history$0), 0],
     _A_ = [0, caml_call1(local_storage_fun, local_storage$0), _z_],
     _B_ = [0, caml_call1(priority_fun, priority$0), _A_];
    return [0, caml_call1(monitor_fun, monitor$0), _B_];
   }
   function iter$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    caml_call3(monitor_fun, monitor$0, record, record[1]);
    caml_call3(priority_fun, priority$0, record, record[2]);
    caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return caml_call3
            (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function fold$0
   (record,
    init,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var _w_ = record[4], _x_ = record[3], _y_ = record[2];
    return caml_call4
            (backtrace_history_fun,
             caml_call4
              (local_storage_fun,
               caml_call4
                (priority_fun,
                 caml_call4(monitor_fun, init, monitor$0, record, record[1]),
                 priority$0,
                 record,
                 _y_),
               local_storage$0,
               record,
               _x_),
             backtrace_history$0,
             record,
             _w_);
   }
   function for_all$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _t_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _u_ = _t_ ? caml_call3(priority_fun, priority$0, record, record[2]) : _t_,
     _v_ =
       _u_
        ? caml_call3(local_storage_fun, local_storage$0, record, record[3])
        : _u_;
    return _v_
            ? caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4])
            : _v_;
   }
   function exists$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _s_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _q_ = _s_ || caml_call3(priority_fun, priority$0, record, record[2]),
     _r_ =
       _q_
       || caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return _r_
            ? _r_
            : caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function to_list$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _n_ =
       [0,
        caml_call3
         (backtrace_history_fun, backtrace_history$0, record, record[4]),
        0],
     _o_ =
       [0,
        caml_call3(local_storage_fun, local_storage$0, record, record[3]),
        _n_],
     _p_ = [0, caml_call3(priority_fun, priority$0, record, record[2]), _o_];
    return [0, caml_call3(monitor_fun, monitor$0, record, record[1]), _p_];
   }
   function map$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _k_ =
       caml_call3
        (backtrace_history_fun, backtrace_history$0, record, record[4]),
     _l_ = caml_call3(local_storage_fun, local_storage$0, record, record[3]),
     _m_ = caml_call3(priority_fun, priority$0, record, record[2]);
    return [0,
            caml_call3(monitor_fun, monitor$0, record, record[1]),
            _m_,
            _l_,
            _k_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    _a_ = [0, cst_backtrace_history],
    _b_ = [0, cst_local_storage],
    _c_ = [0, cst_priority],
    _d_ = [0, cst_monitor];
   function sexp_of_t(param){
    var
     backtrace_history_008 = param[4],
     local_storage_006 = param[3],
     priority_004 = param[2],
     monitor_002 = param[1],
     arg_009 = caml_call2(Core[421], Base_Backtrace[1], backtrace_history_008),
     bnds_001 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Core_Univ_map[2], local_storage_006),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Async_kernel_Priority[1], priority_004),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 = caml_call1(Async_kernel_Monitor0[18], monitor_002),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   var
    main =
      [0,
       Async_kernel_Monitor0[21],
       Async_kernel_Priority[2],
       Core_Univ_map[4],
       0];
   function create_like(monitor, priority, local_storage, t){
    var
     monitor$0 = caml_call2(Core_Option[34], monitor, t[1]),
     _i_ = t[4],
     _j_ = caml_call2(Core_Option[34], local_storage, t[3]);
    return [0,
            monitor$0,
            caml_call2(Core_Option[34], priority, t[2]),
            _j_,
            _i_];
   }
   function find_local(t, key){
    return caml_call2(Core_Univ_map[10], t[3], key);
   }
   function with_local(t, key, data){
    var
     _g_ = t[4],
     _h_ =
       caml_call3(Core_Univ_map[14], t[3], key, function(param){return data;});
    return [0, t[1], t[2], _h_, _g_];
   }
   function record_backtrace(t){
    var _e_ = t[4], _f_ = [0, caml_call2(Base_Backtrace[2], 0, 0), _e_];
    return [0, t[1], t[2], t[3], _f_];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Execution_con);
   var
    Async_kernel_Execution_context =
      [0,
       backtrace_history,
       local_storage,
       priority,
       monitor,
       [0,
        names,
        backtrace_history$0,
        local_storage$0,
        priority$0,
        monitor$0,
        fold,
        make_creator,
        create,
        map,
        iter,
        for_all,
        exists,
        to_list,
        map_poly,
        Direct],
       sexp_of_t,
       invariant,
       main,
       create_like,
       find_local,
       with_local,
       record_backtrace];
   runtime.caml_register_global
    (27, Async_kernel_Execution_context, cst_Async_kernel_Execution_con);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__External_job
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_External_job = "Async_kernel__External_job",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_External_job);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/external_job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "<job>"];
   function sexp_of_t(param){return _a_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_External_job);
   var Async_kernel_External_job = [0, sexp_of_t];
   runtime.caml_register_global
    (12, Async_kernel_External_job, cst_Async_kernel_External_job);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_pool
//# unitInfo: Requires: Async_kernel__Execution_context, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_pool = "Async_kernel__Job_pool",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_pool);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_pool.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var dummy_e = Async_kernel_Execution_context[8];
   function dummy_f(_c_){return 0;}
   var dummy_a = 0;
   function sexp_of_slots(x_001){
    return caml_call4
            (Tuple_pool[1][5],
             Async_kernel_Execution_context[6],
             function(param){
              return caml_call1
                      (Sexplib0_Sexp_conv[24], function(_b_){return 0;});
             },
             Sexplib0_Sexp_conv[23],
             x_001);
   }
   function sexp_of_t(x_002){
    return caml_call2(Tuple_pool[4], sexp_of_slots, x_002);
   }
   function invariant(t){
    return caml_call2(Tuple_pool[5], function(_a_){return 0;}, t);
   }
   function create(param){
    return caml_call3
            (Tuple_pool[9],
             Tuple_pool[1][19],
             1,
             [0, dummy_e, dummy_f, dummy_a]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_pool);
   var
    Async_kernel_Job_pool = [0, sexp_of_slots, sexp_of_t, invariant, create];
   runtime.caml_register_global
    (14, Async_kernel_Job_pool, cst_Async_kernel_Job_pool);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job
//# unitInfo: Requires: Async_kernel__Job_pool, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job = "Async_kernel__Job",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function sexp_of_t(x_001){
    return caml_call2(Tuple_pool[3][1], Async_kernel_Job_pool[1], x_001);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job);
   var Async_kernel_Job = [0, sexp_of_t];
   runtime.caml_register_global(13, Async_kernel_Job, cst_Async_kernel_Job);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event = "Async_kernel__Job_or_event",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function of_event(event){return event;}
   function of_job(job){return job;}
   function is_event(t){return caml_call1(Stdlib_Obj[1], t);}
   function is_job(t){return typeof t === "number" ? 1 : 0;}
   function kind(t){return is_event(t) ? 0 : 1;}
   function project(param, job_or_event){return job_or_event;}
   var Match = [0, kind, project];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event);
   var
    Async_kernel_Job_or_event = [0, of_event, of_job, is_event, is_job, Match];
   runtime.caml_register_global
    (13, Async_kernel_Job_or_event, cst_Async_kernel_Job_or_event);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event_ = "Async_kernel__Job_or_event_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event_);
   var Async_kernel_Job_or_event_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Job_or_event_intf, cst_Async_kernel_Job_or_event_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler0
//# unitInfo: Requires: Async_kernel__Types, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler0 = "Async_kernel__Scheduler0",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/scheduler0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function events(t){return t[19][4];}
   function set_execution_context(t, execution_context){
    var
     _a_ = 1 - caml_call2(Core[246], t[7], execution_context),
     _b_ = _a_ ? (t[7] = execution_context, 0) : _a_;
    return _b_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler0);
   var Async_kernel_Scheduler0 = [0, events, set_execution_context];
   runtime.caml_register_global
    (12, Async_kernel_Scheduler0, cst_Async_kernel_Scheduler0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_queue
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Scheduler0, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Int, Core__Uniform_array, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_queue = "Async_kernel__Job_queue",
    cst_async_kernel = "async_kernel",
    cst_front = "front",
    cst_jobs = "jobs",
    cst_jobs_left_this_cycle = "jobs_left_this_cycle",
    cst_length = "length",
    cst_mask = "mask",
    cst_num_jobs_run = "num_jobs_run",
    cst_src_job_queue_ml = "src/job_queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Uniform_array = global_data.Core__Uniform_array,
    Base_Backtrace = global_data.Base__Backtrace,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_queue);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_job_queue_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var dummy_e = Async_kernel_Execution_context[8];
   function dummy_f(_G_){return 0;}
   function length(r){return r[6];}
   function set_length(r, v){r[6] = v; return 0;}
   function front(r){return r[5];}
   function set_front(r, v){r[5] = v; return 0;}
   function mask(r){return r[4];}
   function set_mask(r, v){r[4] = v; return 0;}
   function jobs(r){return r[3];}
   function set_jobs(r, v){r[3] = v; return 0;}
   function jobs_left_this_cycle(r){return r[2];}
   function set_jobs_left_this_cycle(r, v){r[2] = v; return 0;}
   function num_jobs_run(r){return r[1];}
   function set_num_jobs_run(r, v){r[1] = v; return 0;}
   var
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v];}],
    front$0 =
      [0,
       function(param){return 0;},
       cst_front,
       [0, set_front],
       front,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}],
    mask$0 =
      [0,
       function(param){return 0;},
       cst_mask,
       [0, set_mask],
       mask,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}],
    jobs$0 =
      [0,
       function(param){return 0;},
       cst_jobs,
       [0, set_jobs],
       jobs,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}],
    jobs_left_this_cycle$0 =
      [0,
       function(param){return 0;},
       cst_jobs_left_this_cycle,
       [0, set_jobs_left_this_cycle],
       jobs_left_this_cycle,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6]];}],
    num_jobs_run$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_run,
       [0, set_num_jobs_run],
       num_jobs_run,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}],
    dummy_a = 0,
    _a_ = [0, cst_length],
    _b_ = [0, cst_front],
    _c_ = [0, cst_mask],
    _d_ = [0, cst_jobs],
    _e_ = [0, cst_jobs_left_this_cycle],
    _f_ = [0, cst_num_jobs_run],
    _g_ = [0, cst_src_job_queue_ml, 60, 11],
    _h_ = [0, cst_src_job_queue_ml, 59, 11],
    _i_ = [0, cst_src_job_queue_ml, 56, 11],
    _j_ = [0, cst_src_job_queue_ml, 55, 11],
    _k_ = [0, cst_src_job_queue_ml, 52, 11],
    _l_ = [0, cst_src_job_queue_ml, 51, 11],
    _m_ = [0, cst_src_job_queue_ml, 41, 44],
    _n_ = [0, cst_src_job_queue_ml, 39, 48],
    _o_ = [0, cst_src_job_queue_ml, 36, 1334, 1356],
    _p_ = [0, "t"],
    _q_ = [0, "n"],
    cst_Jobs_set_jobs_left_this_cy =
      "Jobs.set_jobs_left_this_cycle got negative number",
    _r_ = [0, 0];
   function sexp_of_t(param){
    var
     num_jobs_run_002 = param[1],
     jobs_left_this_cycle_004 = param[2],
     jobs_006 = param[3],
     mask_008 = param[4],
     front_010 = param[5],
     length_012 = param[6],
     arg_013 = caml_call1(Core[356], length_012),
     bnds_001 = [0, [1, [0, _a_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Core[356], front_010),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_011, 0]]], bnds_001],
     arg_009 = caml_call1(Core[356], mask_008),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_009, 0]]], bnds_001$0],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], jobs_006),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_007, 0]]], bnds_001$1],
     arg_005 = caml_call1(Core[356], jobs_left_this_cycle_004),
     bnds_001$3 = [0, [1, [0, _e_, [0, arg_005, 0]]], bnds_001$2],
     arg_003 = caml_call1(Core[356], num_jobs_run_002),
     bnds_001$4 = [0, [1, [0, _f_, [0, arg_003, 0]]], bnds_001$3];
    return [1, bnds_001$4];
   }
   function offset(t, i){return ((t[5] + i | 0) & t[4]) * 3 | 0;}
   function capacity(t){return t[4] + 1 | 0;}
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _o_,
             t,
             sexp_of_t,
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               length_fun =
                 check
                  (function(length){
                    if(! caml_call2(Async_kernel_Import[1], length, 0))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _h_], 1);
                    var _F_ = capacity(t);
                    if(caml_call2(Async_kernel_Import[2], length, _F_))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _g_], 1);
                   }),
               front_fun =
                 check
                  (function(front){
                    if(! caml_call2(Async_kernel_Import[1], front, 0))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _j_], 1);
                    var _E_ = capacity(t);
                    if(caml_call2(Async_kernel_Import[5], front, _E_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _i_], 1);
                   }),
               mask_fun =
                 check
                  (function(mask){
                    var capacity = mask + 1 | 0;
                    if(! caml_call1(Core_Int[48], capacity))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _l_], 1);
                    var _D_ = caml_call1(Core_Uniform_array[18], t[3]);
                    if
                     (caml_call2(Async_kernel_Import[3], capacity * 3 | 0, _D_))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _k_], 1);
                   }),
               jobs_fun =
                 check
                  (function(jobs){
                    var _z_ = t[6] - 1 | 0, _y_ = 0;
                    if(_z_ >= 0){
                     var i = _y_;
                     for(;;){
                      var
                       _A_ = offset(t, i),
                       _B_ = caml_call2(Core_Uniform_array[19], jobs, _A_);
                      caml_call1(Async_kernel_Execution_context[7], _B_);
                      var _C_ = i + 1 | 0;
                      if(_z_ === i) break;
                      i = _C_;
                     }
                    }
                    return 0;
                   }),
               jobs_left_this_cycle_fun =
                 check
                  (function(jobs_left_this_cycle){
                    if
                     (caml_call2(Async_kernel_Import[1], jobs_left_this_cycle, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _m_], 1);
                   }),
               num_jobs_run_fun =
                 check
                  (function(num_jobs_run){
                    if(caml_call2(Async_kernel_Import[1], num_jobs_run, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _n_], 1);
                   });
              caml_call1(num_jobs_run_fun, num_jobs_run$0);
              caml_call1(jobs_left_this_cycle_fun, jobs_left_this_cycle$0);
              caml_call1(jobs_fun, jobs$0);
              caml_call1(mask_fun, mask$0);
              caml_call1(front_fun, front$0);
              return caml_call1(length_fun, length$0);
             });
   }
   function create_array(capacity){
    return caml_call1(Core_Uniform_array[43], capacity * 3 | 0);
   }
   function create(param){return [0, 0, 0, create_array(1), 0, 0, 0];}
   function clear(t){t[5] = 0; t[6] = 0; t[2] = 0; return 0;}
   function set(t, i, execution_context, f, a){
    var offset$0 = offset(t, i);
    caml_call3(Core_Uniform_array[22], t[3], offset$0, execution_context);
    caml_call3(Core_Uniform_array[22], t[3], offset$0 + 1 | 0, f);
    return caml_call3(Core_Uniform_array[22], t[3], offset$0 + 2 | 0, a);
   }
   function enqueue(t, execution_context, f, a){
    var _x_ = capacity(t);
    if(caml_call2(Async_kernel_Import[3], t[6], _x_)){
     var
      old_capacity = capacity(t),
      new_capacity = old_capacity * 2 | 0,
      old_jobs = t[3],
      old_front = t[5],
      len1 =
        caml_call2(Core_Int[92], t[6], old_capacity - old_front | 0) * 3 | 0,
      len2 = (t[6] * 3 | 0) - len1 | 0,
      new_jobs = create_array(new_capacity);
     caml_call5
      (Core_Uniform_array[36], old_jobs, old_front * 3 | 0, new_jobs, 0, len1);
     caml_call5(Core_Uniform_array[36], old_jobs, 0, new_jobs, len1, len2);
     t[4] = new_capacity - 1 | 0;
     t[3] = new_jobs;
     t[5] = 0;
    }
    set(t, t[6], execution_context, f, a);
    t[6] = t[6] + 1 | 0;
    return 0;
   }
   function set_jobs_left_this_cycle$0(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _u_ = [0, [1, [0, _p_, [0, sexp_of_t(t), 0]]], 0],
      _v_ = [0, [1, [0, _q_, [0, caml_call1(Core[356], n), 0]]], _u_],
      _w_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Jobs_set_jobs_left_this_cy),
          _v_]];
     caml_call1(Core[253], _w_);
    }
    t[2] = n;
    return 0;
   }
   function can_run_a_job(t){
    var _t_ = caml_call2(Async_kernel_Import[4], t[6], 0);
    return _t_ ? caml_call2(Async_kernel_Import[4], t[2], 0) : _t_;
   }
   function run_job(t, scheduler, execution_context, f, a){
    t[1] = t[1] + 1 | 0;
    caml_call2(Async_kernel_Scheduler0[2], scheduler, execution_context);
    return caml_call1(f, a);
   }
   function run_external_jobs(t, scheduler){
    var external_jobs = scheduler[20];
    for(;;){
     var _s_ = caml_call1(Thread_safe_queue[4], external_jobs);
     if(! caml_call2(Async_kernel_Import[4], _s_, 0)) return;
     var
      match = caml_call1(Thread_safe_queue[6], external_jobs),
      a = match[3],
      f = match[2],
      execution_context = match[1];
     run_job(t, scheduler, execution_context, f, a);
    }
   }
   function run_jobs(t, scheduler){
    try{
     run_external_jobs(t, scheduler);
     for(;;){
      if(! can_run_a_job(t)) return _r_;
      var
       this_job = offset(t, 0),
       execution_context = caml_call2(Core_Uniform_array[20], t[3], this_job),
       f = caml_call2(Core_Uniform_array[20], t[3], this_job + 1 | 0),
       a = caml_call2(Core_Uniform_array[20], t[3], this_job + 2 | 0);
      set(t, 0, dummy_e, dummy_f, dummy_a);
      t[5] = (t[5] + 1 | 0) & t[4];
      t[6] = t[6] - 1 | 0;
      t[2] = t[2] - 1 | 0;
      run_job(t, scheduler, execution_context, f, a);
      run_external_jobs(t, scheduler);
     }
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0);
     return [1, [0, exn, backtrace]];
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_queue);
   var
    Async_kernel_Job_queue =
      [0,
       sexp_of_t,
       invariant,
       create,
       enqueue,
       clear,
       set_jobs_left_this_cycle$0,
       can_run_a_job,
       length,
       run_jobs,
       num_jobs_run];
   runtime.caml_register_global
    (49, Async_kernel_Job_queue, cst_Async_kernel_Job_queue);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source0
//# unitInfo: Requires: Assert_failure, Async_kernel__Job_or_event, Async_kernel__Scheduler0, Async_kernel__Time_ns, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Error, Core__List, Core__Or_error, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source0",
    cst_advance_errors = "advance_errors",
    cst_alarm = "alarm",
    cst_am_advancing = "am_advancing",
    cst_async_kernel = "async_kernel",
    cst_at = "at",
    cst_callback = "callback",
    cst_events = "events",
    cst_execution_context = "execution_context",
    cst_fired_events = "fired_events",
    cst_handle_fired = "handle_fired",
    cst_id = "id",
    cst_interval = "interval",
    cst_is_wall_clock = "is_wall_clock",
    cst_most_recently_fired = "most_recently_fired",
    cst_next_fired = "next_fired",
    cst_now = "now",
    cst_prev_fired = "prev_fired",
    cst_scheduler = "scheduler",
    cst_src_synchronous_time_sourc$0 = "src/synchronous_time_source0.ml",
    cst_status = "status",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$3 = "src/synchronous_time_source0.ml:341:32",
    pos$2 = "src/synchronous_time_source0.ml:340:32",
    pos$1 = "src/synchronous_time_source0.ml:187:30",
    pos$0 = "src/synchronous_time_source0.ml:205:32",
    pos = "src/synchronous_time_source0.ml:215:32",
    cst = "",
    names =
      [0,
       cst_alarm,
       [0,
        cst_at,
        [0,
         cst_callback,
         [0,
          cst_execution_context,
          [0,
           cst_interval,
           [0, cst_next_fired, [0, cst_prev_fired, [0, cst_status, 0]]]]]]]],
    names$0 =
      [0,
       cst_id,
       [0,
        cst_advance_errors,
        [0,
         cst_am_advancing,
         [0,
          cst_events,
          [0,
           cst_fired_events,
           [0,
            cst_most_recently_fired,
            [0,
             cst_handle_fired,
             [0, cst_is_wall_clock, [0, cst_scheduler, 0]]]]]]]]],
    Timing_wheel = global_data.Timing_wheel,
    Core_Error = global_data.Core__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Or_error = global_data.Core__Or_error,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Async_kernel_Job_or_event = global_data.Async_kernel__Job_or_event,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_synchronous_time_sourc$0);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    typerep_of_t = Async_kernel_Time_ns[1],
    typename_of_t = Async_kernel_Time_ns[2],
    bin_size_t = Async_kernel_Time_ns[3],
    bin_write_t = Async_kernel_Time_ns[4],
    bin_read_t = Async_kernel_Time_ns[5],
    bin_read_t$0 = Async_kernel_Time_ns[6],
    bin_shape_t = Async_kernel_Time_ns[7],
    bin_writer_t = Async_kernel_Time_ns[8],
    bin_reader_t = Async_kernel_Time_ns[9],
    bin_t = Async_kernel_Time_ns[10],
    quickcheck_generator = Async_kernel_Time_ns[11],
    quickcheck_observer = Async_kernel_Time_ns[12],
    quickcheck_shrinker = Async_kernel_Time_ns[13],
    gen_incl = Async_kernel_Time_ns[14],
    gen_uniform_incl = Async_kernel_Time_ns[15],
    is_earlier = Async_kernel_Time_ns[16],
    is_later = Async_kernel_Time_ns[17],
    of_date_ofday = Async_kernel_Time_ns[18],
    of_date_ofday_precise = Async_kernel_Time_ns[19],
    to_date_ofday = Async_kernel_Time_ns[20],
    to_date_ofday_precise = Async_kernel_Time_ns[21],
    to_date = Async_kernel_Time_ns[22],
    to_ofday = Async_kernel_Time_ns[23],
    reset_date_cache = Async_kernel_Time_ns[24],
    convert = Async_kernel_Time_ns[25],
    utc_offset = Async_kernel_Time_ns[26],
    to_filename_string = Async_kernel_Time_ns[27],
    of_filename_string = Async_kernel_Time_ns[28],
    to_string_abs = Async_kernel_Time_ns[29],
    to_string_abs_trimmed = Async_kernel_Time_ns[30],
    to_string_abs_parts = Async_kernel_Time_ns[31],
    to_string_trimmed = Async_kernel_Time_ns[32],
    to_sec_string = Async_kernel_Time_ns[33],
    to_sec_string_with_zone = Async_kernel_Time_ns[34],
    of_localized_string = Async_kernel_Time_ns[35],
    of_string_gen = Async_kernel_Time_ns[36],
    to_string_iso8601_basic = Async_kernel_Time_ns[37],
    occurrence = Async_kernel_Time_ns[38],
    of_string = Async_kernel_Time_ns[39],
    of_string_with_utc_offset = Async_kernel_Time_ns[40],
    to_string = Async_kernel_Time_ns[41],
    to_string_utc = Async_kernel_Time_ns[42],
    epoch = Async_kernel_Time_ns[43],
    min_value_representable = Async_kernel_Time_ns[44],
    max_value_representable = Async_kernel_Time_ns[45],
    min_value_for_1us_rounding = Async_kernel_Time_ns[46],
    max_value_for_1us_rounding = Async_kernel_Time_ns[47],
    min_value = Async_kernel_Time_ns[48],
    max_value = Async_kernel_Time_ns[49],
    now = Async_kernel_Time_ns[50],
    add = Async_kernel_Time_ns[51],
    add_saturating = Async_kernel_Time_ns[52],
    sub_saturating = Async_kernel_Time_ns[53],
    sub = Async_kernel_Time_ns[54],
    next = Async_kernel_Time_ns[55],
    prev = Async_kernel_Time_ns[56],
    diff = Async_kernel_Time_ns[57],
    abs_diff = Async_kernel_Time_ns[58],
    to_span_since_epoch = Async_kernel_Time_ns[59],
    of_span_since_epoch = Async_kernel_Time_ns[60],
    to_int63_ns_since_epoch = Async_kernel_Time_ns[61],
    of_int63_ns_since_epoch = Async_kernel_Time_ns[62],
    to_int_ns_since_epoch = Async_kernel_Time_ns[63],
    of_int_ns_since_epoch = Async_kernel_Time_ns[64],
    next_multiple = Async_kernel_Time_ns[65],
    prev_multiple = Async_kernel_Time_ns[66],
    random = Async_kernel_Time_ns[67],
    of_time = Async_kernel_Time_ns[68],
    to_time = Async_kernel_Time_ns[69],
    to_time_float_round_nearest = Async_kernel_Time_ns[70],
    to_time_float_round_nearest_mi = Async_kernel_Time_ns[71],
    of_time_float_round_nearest = Async_kernel_Time_ns[72],
    of_time_float_round_nearest_mi = Async_kernel_Time_ns[73],
    arg_type = Async_kernel_Time_ns[74],
    get_sexp_zone = Async_kernel_Time_ns[75],
    interruptible_pause = Async_kernel_Time_ns[76],
    of_date_ofday_zoned = Async_kernel_Time_ns[77],
    of_string_abs = Async_kernel_Time_ns[78],
    of_string_fix_proto = Async_kernel_Time_ns[79],
    pause = Async_kernel_Time_ns[80],
    pause_forever = Async_kernel_Time_ns[81],
    pp = Async_kernel_Time_ns[82],
    set_sexp_zone = Async_kernel_Time_ns[83],
    sexp_of_t_abs = Async_kernel_Time_ns[84],
    t_of_sexp_abs = Async_kernel_Time_ns[85],
    to_date_ofday_zoned = Async_kernel_Time_ns[86],
    to_ofday_zoned = Async_kernel_Time_ns[87],
    to_string_fix_proto = Async_kernel_Time_ns[88],
    hash_fold_t = Async_kernel_Time_ns[89],
    hash = Async_kernel_Time_ns[90],
    t_of_sexp = Async_kernel_Time_ns[91],
    t_sexp_grammar = Async_kernel_Time_ns[93],
    symbol = Async_kernel_Time_ns[94],
    symbol$0 = Async_kernel_Time_ns[95],
    symbol$1 = Async_kernel_Time_ns[96],
    symbol$2 = Async_kernel_Time_ns[97],
    symbol$3 = Async_kernel_Time_ns[98],
    symbol$4 = Async_kernel_Time_ns[99],
    equal = Async_kernel_Time_ns[100],
    compare = Async_kernel_Time_ns[101],
    min = Async_kernel_Time_ns[102],
    max = Async_kernel_Time_ns[103],
    ascending = Async_kernel_Time_ns[104],
    descending = Async_kernel_Time_ns[105],
    between = Async_kernel_Time_ns[106],
    clamp_exn = Async_kernel_Time_ns[107],
    clamp = Async_kernel_Time_ns[108],
    comparator = Async_kernel_Time_ns[109],
    validate_lbound = Async_kernel_Time_ns[110],
    validate_ubound = Async_kernel_Time_ns[111],
    validate_bound = Async_kernel_Time_ns[112],
    after = Async_kernel_Time_ns[113];
   function sexp_of_t(t){
    var
     _dg_ = caml_call1(to_span_since_epoch, t),
     _dh_ =
       runtime.core_time_ns_format
        (caml_call1(Core_Time_ns[1][91], _dg_), "%Y-%m-%dT%H:%M:%S%z");
    return caml_call1(Core[471], _dh_);
   }
   var
    Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after,
       sexp_of_t],
    include = Timing_wheel[5],
    sexp_of_t$0 = include[1],
    null$0 = include[2],
    at = include[3],
    interval_num = include[4],
    value = include[5];
   function is_null(t){
    var _df_ = caml_call1(null$0, 0);
    return caml_call2(Core[246], t, _df_);
   }
   var
    Alarm = [0, sexp_of_t$0, null$0, at, interval_num, value, is_null],
    _a_ = caml_call2(Timing_wheel[1][13], Timing_wheel[1][10], 3),
    _b_ =
      [0,
       caml_call2(Timing_wheel[7][5], 0, [0, 13, [0, 6, [0, 6, [0, 5, 0]]]])],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _b_, _a_, 0),
    compare$0 = runtime.caml_int_compare,
    _c_ = [0, "Fired"],
    _d_ = [0, "Happening"],
    _e_ = [0, "Scheduled"],
    _f_ = [0, "Unscheduled"];
   function equal$0(_de_, _dd_){return _de_ === _dd_ ? 1 : 0;}
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _c_;
      case 1:
       return _d_;
      case 2:
       return _e_;
      default: return _f_;
    }
   }
   function transition_is_allowed(from, to){
    a:
    {
     switch(from){
       case 0:
        if(1 !== to && 3 > to) break a; break;
       case 1:
        if(2 > to) break a; break;
       case 2:
        if(1 >= to - 1 >>> 0) break a; break;
       default: if(1 === to || 3 <= to) break a;
     }
     return 1;
    }
    return 0;
   }
   var
    Status = [0, compare$0, equal$0, sexp_of_t$1, transition_is_allowed],
    _g_ = [0, cst_interval],
    _h_ = [0, cst_at],
    _i_ = [0, cst_status];
   function sexp_of_event(param){
    var at = param[2], interval = param[5], status = param[8], match = 0;
    if(interval)
     var
      v = interval[1],
      _db_ =
        [0, [1, [0, _g_, [0, caml_call1(Core_Time_ns[1][10], v), 0]]], match];
    else
     var _db_ = match;
    var _dc_ = [0, [1, [0, _h_, [0, caml_call1(Time_ns[113], at), 0]]], _db_];
    return [1,
            [0, [1, [0, _i_, [0, caml_call1(Status[3], status), 0]]], _dc_]];
   }
   var Event_is_block = [0], none = 0;
   function some(_da_){return _da_;}
   function is_none(t){return caml_call2(Core[246], t, none);}
   function is_some(t){return 1 - is_none(t);}
   function first_some(t1, t2){return is_some(t1) ? t1 : t2;}
   function unsafe_value(_c$_){return _c$_;}
   var
    Optional_syntax = [0, is_none, unsafe_value],
    Optional_syntax$0 = [0, Optional_syntax],
    _j_ = [1, 0],
    cst_Synchronous_time_source_Ev =
      "[Synchronous_time_source.Event.Option.value_exn None]";
   function sexp_of_t$2(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return _j_;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return sexp_of_event(event);
   }
   function value$0(ppx_optional_e_0, default$0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0))
     return default$0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function value_exn(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)){
     var
      _c__ = caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_Ev);
     return caml_call1(Core[253], _c__);
    }
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function to_option(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return 0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return [0, event];
   }
   function of_option(param){
    if(! param) return none;
    var event = param[1];
    return event;
   }
   var
    Option =
      [0,
       Event_is_block,
       none,
       some,
       is_none,
       is_some,
       first_some,
       Optional_syntax$0,
       sexp_of_t$2,
       value$0,
       value_exn,
       to_option,
       of_option];
   function status(r){return r[8];}
   function set_status(r, v){r[8] = v; return 0;}
   function prev_fired(r){return r[7];}
   function set_prev_fired(r, v){r[7] = v; return 0;}
   function next_fired(r){return r[6];}
   function set_next_fired(r, v){r[6] = v; return 0;}
   function interval(r){return r[5];}
   function set_interval(r, v){r[5] = v; return 0;}
   function execution_context(r){return r[4];}
   function callback(r){return r[3];}
   function at$0(r){return r[2];}
   function set_at(r, v){r[2] = v; return 0;}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   var
    status$0 =
      [0,
       function(param){return 0;},
       cst_status,
       [0, set_status],
       status,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
       }],
    prev_fired$0 =
      [0,
       function(param){return 0;},
       cst_prev_fired,
       [0, set_prev_fired],
       prev_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
       }],
    next_fired$0 =
      [0,
       function(param){return 0;},
       cst_next_fired,
       [0, set_next_fired],
       next_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
       }],
    interval$0 =
      [0,
       function(param){return 0;},
       cst_interval,
       [0, set_interval],
       interval,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
       }],
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       0,
       execution_context,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
       }],
    callback$0 =
      [0,
       function(param){return 0;},
       cst_callback,
       0,
       callback,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
       }],
    at$1 =
      [0,
       function(param){return 0;},
       cst_at,
       [0, set_at],
       at$0,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
       }],
    alarm$0 =
      [0,
       function(param){return 0;},
       cst_alarm,
       [0, set_alarm],
       alarm,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
       }];
   function make_creator
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun,
    compile_acc){
    var
     match = caml_call2(alarm_fun, alarm$0, compile_acc),
     compile_acc$0 = match[2],
     alarm_gen = match[1],
     match$0 = caml_call2(at_fun, at$1, compile_acc$0),
     compile_acc$1 = match$0[2],
     at_gen = match$0[1],
     match$1 = caml_call2(callback_fun, callback$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     callback_gen = match$1[1],
     match$2 =
       caml_call2(execution_context_fun, execution_context$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     execution_context_gen = match$2[1],
     match$3 = caml_call2(interval_fun, interval$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     interval_gen = match$3[1],
     match$4 = caml_call2(next_fired_fun, next_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     next_fired_gen = match$4[1],
     match$5 = caml_call2(prev_fired_fun, prev_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     prev_fired_gen = match$5[1],
     match$6 = caml_call2(status_fun, status$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     status_gen = match$6[1];
    return [0,
            function(acc){
             var
              alarm = caml_call1(alarm_gen, acc),
              at = caml_call1(at_gen, acc),
              callback = caml_call1(callback_gen, acc),
              execution_context = caml_call1(execution_context_gen, acc),
              interval = caml_call1(interval_gen, acc),
              next_fired = caml_call1(next_fired_gen, acc),
              prev_fired = caml_call1(prev_fired_gen, acc),
              status = caml_call1(status_gen, acc);
             return [0,
                     alarm,
                     at,
                     callback,
                     execution_context,
                     interval,
                     next_fired,
                     prev_fired,
                     status];
            },
            compile_acc$7];
   }
   function create
   (alarm,
    at,
    callback,
    execution_context,
    interval,
    next_fired,
    prev_fired,
    status){
    return [0,
            alarm,
            at,
            callback,
            execution_context,
            interval,
            next_fired,
            prev_fired,
            status];
   }
   function map
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _c3_ = caml_call1(status_fun, status$0),
     _c4_ = caml_call1(prev_fired_fun, prev_fired$0),
     _c5_ = caml_call1(next_fired_fun, next_fired$0),
     _c6_ = caml_call1(interval_fun, interval$0),
     _c7_ = caml_call1(execution_context_fun, execution_context$0),
     _c8_ = caml_call1(callback_fun, callback$0),
     _c9_ = caml_call1(at_fun, at$1);
    return [0,
            caml_call1(alarm_fun, alarm$0),
            _c9_,
            _c8_,
            _c7_,
            _c6_,
            _c5_,
            _c4_,
            _c3_];
   }
   function iter
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call1(alarm_fun, alarm$0);
    caml_call1(at_fun, at$1);
    caml_call1(callback_fun, callback$0);
    caml_call1(execution_context_fun, execution_context$0);
    caml_call1(interval_fun, interval$0);
    caml_call1(next_fired_fun, next_fired$0);
    caml_call1(prev_fired_fun, prev_fired$0);
    return caml_call1(status_fun, status$0);
   }
   function fold
   (init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    return caml_call2
            (status_fun,
             caml_call2
              (prev_fired_fun,
               caml_call2
                (next_fired_fun,
                 caml_call2
                  (interval_fun,
                   caml_call2
                    (execution_context_fun,
                     caml_call2
                      (callback_fun,
                       caml_call2
                        (at_fun, caml_call2(alarm_fun, init, alarm$0), at$1),
                       callback$0),
                     execution_context$0),
                   interval$0),
                 next_fired$0),
               prev_fired$0),
             status$0);
   }
   function map_poly(record){
    var
     _cW_ = [0, caml_call1(record[1], status$0), 0],
     _cX_ = [0, caml_call1(record[1], prev_fired$0), _cW_],
     _cY_ = [0, caml_call1(record[1], next_fired$0), _cX_],
     _cZ_ = [0, caml_call1(record[1], interval$0), _cY_],
     _c0_ = [0, caml_call1(record[1], execution_context$0), _cZ_],
     _c1_ = [0, caml_call1(record[1], callback$0), _c0_],
     _c2_ = [0, caml_call1(record[1], at$1), _c1_];
    return [0, caml_call1(record[1], alarm$0), _c2_];
   }
   function for_all
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cP_ = caml_call1(alarm_fun, alarm$0),
     _cQ_ = _cP_ ? caml_call1(at_fun, at$1) : _cP_,
     _cR_ = _cQ_ ? caml_call1(callback_fun, callback$0) : _cQ_,
     _cS_ =
       _cR_ ? caml_call1(execution_context_fun, execution_context$0) : _cR_,
     _cT_ = _cS_ ? caml_call1(interval_fun, interval$0) : _cS_,
     _cU_ = _cT_ ? caml_call1(next_fired_fun, next_fired$0) : _cT_,
     _cV_ = _cU_ ? caml_call1(prev_fired_fun, prev_fired$0) : _cU_;
    return _cV_ ? caml_call1(status_fun, status$0) : _cV_;
   }
   function exists
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cO_ = caml_call1(alarm_fun, alarm$0),
     _cI_ = _cO_ || caml_call1(at_fun, at$1),
     _cJ_ = _cI_ || caml_call1(callback_fun, callback$0),
     _cK_ = _cJ_ || caml_call1(execution_context_fun, execution_context$0),
     _cL_ = _cK_ || caml_call1(interval_fun, interval$0),
     _cM_ = _cL_ || caml_call1(next_fired_fun, next_fired$0),
     _cN_ = _cM_ || caml_call1(prev_fired_fun, prev_fired$0);
    return _cN_ ? _cN_ : caml_call1(status_fun, status$0);
   }
   function to_list
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cB_ = [0, caml_call1(status_fun, status$0), 0],
     _cC_ = [0, caml_call1(prev_fired_fun, prev_fired$0), _cB_],
     _cD_ = [0, caml_call1(next_fired_fun, next_fired$0), _cC_],
     _cE_ = [0, caml_call1(interval_fun, interval$0), _cD_],
     _cF_ = [0, caml_call1(execution_context_fun, execution_context$0), _cE_],
     _cG_ = [0, caml_call1(callback_fun, callback$0), _cF_],
     _cH_ = [0, caml_call1(at_fun, at$1), _cG_];
    return [0, caml_call1(alarm_fun, alarm$0), _cH_];
   }
   function iter$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call3(alarm_fun, alarm$0, record, record[1]);
    caml_call3(at_fun, at$1, record, record[2]);
    caml_call3(callback_fun, callback$0, record, record[3]);
    caml_call3(execution_context_fun, execution_context$0, record, record[4]);
    caml_call3(interval_fun, interval$0, record, record[5]);
    caml_call3(next_fired_fun, next_fired$0, record, record[6]);
    caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return caml_call3(status_fun, status$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cu_ = record[8],
     _cv_ = record[7],
     _cw_ = record[6],
     _cx_ = record[5],
     _cy_ = record[4],
     _cz_ = record[3],
     _cA_ = record[2];
    return caml_call4
            (status_fun,
             caml_call4
              (prev_fired_fun,
               caml_call4
                (next_fired_fun,
                 caml_call4
                  (interval_fun,
                   caml_call4
                    (execution_context_fun,
                     caml_call4
                      (callback_fun,
                       caml_call4
                        (at_fun,
                         caml_call4(alarm_fun, init, alarm$0, record, record[1]),
                         at$1,
                         record,
                         _cA_),
                       callback$0,
                       record,
                       _cz_),
                     execution_context$0,
                     record,
                     _cy_),
                   interval$0,
                   record,
                   _cx_),
                 next_fired$0,
                 record,
                 _cw_),
               prev_fired$0,
               record,
               _cv_),
             status$0,
             record,
             _cu_);
   }
   function for_all$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cn_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _co_ = _cn_ ? caml_call3(at_fun, at$1, record, record[2]) : _cn_,
     _cp_ =
       _co_ ? caml_call3(callback_fun, callback$0, record, record[3]) : _co_,
     _cq_ =
       _cp_
        ? caml_call3
          (execution_context_fun, execution_context$0, record, record[4])
        : _cp_,
     _cr_ =
       _cq_ ? caml_call3(interval_fun, interval$0, record, record[5]) : _cq_,
     _cs_ =
       _cr_
        ? caml_call3(next_fired_fun, next_fired$0, record, record[6])
        : _cr_,
     _ct_ =
       _cs_
        ? caml_call3(prev_fired_fun, prev_fired$0, record, record[7])
        : _cs_;
    return _ct_ ? caml_call3(status_fun, status$0, record, record[8]) : _ct_;
   }
   function exists$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cm_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _cg_ = _cm_ || caml_call3(at_fun, at$1, record, record[2]),
     _ch_ = _cg_ || caml_call3(callback_fun, callback$0, record, record[3]),
     _ci_ =
       _ch_
       ||
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
     _cj_ = _ci_ || caml_call3(interval_fun, interval$0, record, record[5]),
     _ck_ =
       _cj_ || caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _cl_ =
       _ck_ || caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return _cl_ ? _cl_ : caml_call3(status_fun, status$0, record, record[8]);
   }
   function to_list$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _b$_ = [0, caml_call3(status_fun, status$0, record, record[8]), 0],
     _ca_ =
       [0, caml_call3(prev_fired_fun, prev_fired$0, record, record[7]), _b$_],
     _cb_ =
       [0, caml_call3(next_fired_fun, next_fired$0, record, record[6]), _ca_],
     _cc_ = [0, caml_call3(interval_fun, interval$0, record, record[5]), _cb_],
     _cd_ =
       [0,
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
        _cc_],
     _ce_ = [0, caml_call3(callback_fun, callback$0, record, record[3]), _cd_],
     _cf_ = [0, caml_call3(at_fun, at$1, record, record[2]), _ce_];
    return [0, caml_call3(alarm_fun, alarm$0, record, record[1]), _cf_];
   }
   function map$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _b4_ = caml_call3(status_fun, status$0, record, record[8]),
     _b5_ = caml_call3(prev_fired_fun, prev_fired$0, record, record[7]),
     _b6_ = caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _b7_ = caml_call3(interval_fun, interval$0, record, record[5]),
     _b8_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[4]),
     _b9_ = caml_call3(callback_fun, callback$0, record, record[3]),
     _b__ = caml_call3(at_fun, at$1, record, record[2]);
    return [0,
            caml_call3(alarm_fun, alarm$0, record, record[1]),
            _b__,
            _b9_,
            _b8_,
            _b7_,
            _b6_,
            _b5_,
            _b4_];
   }
   function set_all_mutable_fields
   (record, alarm, at, interval, next_fired, prev_fired, status){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = alarm;
    record$0[2] = at;
    record$0[5] = interval;
    record$0[6] = next_fired;
    record$0[7] = prev_fired;
    record$0[8] = status;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       status$0,
       prev_fired$0,
       next_fired$0,
       interval$0,
       execution_context$0,
       callback$0,
       at$1,
       alarm$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct],
    _k_ = [0, cst_src_synchronous_time_sourc$0, 216, 17],
    _l_ = [0, cst_src_synchronous_time_sourc$0, 206, 17],
    _m_ = [0, cst_src_synchronous_time_sourc$0, 182, 5945, 5971],
    _n_ = [0, "event"],
    _o_ = [0, "to_"],
    _p_ = [0, "from"],
    cst_bug_set_status_transition_ =
      "bug -- set_status transition not allowed",
    cst_src_synchronous_time_sourc = "src/synchronous_time_source0.ml:226:12";
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _m_,
             t,
             sexp_of_event,
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               _bS_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
                    var
                     prev_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
                     got = t[8],
                     sexpifier = Status[3];
                    function comparator(a_013, b_014){
                     return caml_call2(Status[1], a_013, b_014);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      0,
                      got);
                    var _b2_ = prev_fired[6], _b3_ = caml_call1(Option[3], t);
                    if(caml_call2(Core[246], _b3_, _b2_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _k_], 1);
                   }),
               _bT_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
                    var
                     next_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
                     got = t[8],
                     sexpifier = Status[3];
                    function comparator(a_009, b_010){
                     return caml_call2(Status[1], a_009, b_010);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos$0,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      0,
                      got);
                    var _b0_ = next_fired[7], _b1_ = caml_call1(Option[3], t);
                    if(caml_call2(Core[246], _b1_, _b0_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _l_], 1);
                   }),
               _bU_ =
                 check
                  (function(alarm){
                    var
                     got = caml_call1(Alarm[6], alarm),
                     expect = 2 === t[8] ? 0 : 1,
                     sexpifier = Core[305];
                    function comparator(a_005, b_006){
                     return caml_call2(Core[301], a_005, b_006);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$1,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             got);
                   });
              return caml_call8
                      (Fields[13],
                       _bU_,
                       function(_bZ_){return 0;},
                       function(_bY_){return 0;},
                       function(_bX_){return 0;},
                       function(_bW_){return 0;},
                       _bT_,
                       _bS_,
                       function(_bV_){return 0;});
             });
   }
   function set_status$0(t, to){
    var from = t[8];
    if(1 - caml_call2(Status[4], from, to)){
     var
      _bN_ = [0, [1, [0, _n_, [0, sexp_of_event(t), 0]]], 0],
      _bO_ = [0, [1, [0, _o_, [0, caml_call1(Status[3], to), 0]]], _bN_],
      _bP_ = [0, [1, [0, _p_, [0, caml_call1(Status[3], from), 0]]], _bO_],
      _bQ_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_bug_set_status_transition_),
         _bP_],
      _bR_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_src_synchronous_time_sourc),
          _bQ_]];
     caml_call1(Core[253], _bR_);
    }
    t[8] = to;
    return 0;
   }
   function set_status_if(is, t, to){
    var _bM_ = caml_call2(Status[2], is, t[8]);
    return _bM_ ? set_status$0(t, to) : _bM_;
   }
   var
    Event =
      [0,
       Status,
       sexp_of_event,
       Option,
       status,
       prev_fired,
       set_prev_fired,
       next_fired,
       set_next_fired,
       interval,
       set_interval,
       execution_context,
       callback,
       at$0,
       set_at,
       alarm,
       set_alarm,
       Fields,
       sexp_of_event,
       invariant,
       set_status$0,
       set_status_if,
       at$0],
    of_event = Async_kernel_Job_or_event[1],
    of_job = Async_kernel_Job_or_event[2],
    is_event = Async_kernel_Job_or_event[3],
    is_job = Async_kernel_Job_or_event[4],
    Match = Async_kernel_Job_or_event[5],
    cst_Job_t = "<Job.t>";
   function sexp_of_t$3(t){
    var
     k = caml_call1(Async_kernel_Job_or_event[5][1], t),
     match = caml_call2(Async_kernel_Job_or_event[5][2], k, t);
    return k
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_Job_t)
            : caml_call1(Event[18], match);
   }
   var
    Job_or_event = [0, of_event, of_job, is_event, is_job, Match, sexp_of_t$3];
   function scheduler(r){return r[9];}
   function is_wall_clock(r){return r[8];}
   function handle_fired(r){return r[7];}
   function most_recently_fired(r){return r[6];}
   function set_most_recently_fired(r, v){r[6] = v; return 0;}
   function fired_events(r){return r[5];}
   function set_fired_events(r, v){r[5] = v; return 0;}
   function events(r){return r[4];}
   function am_advancing(r){return r[3];}
   function set_am_advancing(r, v){r[3] = v; return 0;}
   function advance_errors(r){return r[2];}
   function set_advance_errors(r, v){r[2] = v; return 0;}
   function id(r){return r[1];}
   var
    scheduler$0 =
      [0,
       function(param){return 0;},
       cst_scheduler,
       0,
       scheduler,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v];
       }],
    is_wall_clock$0 =
      [0,
       function(param){return 0;},
       cst_is_wall_clock,
       0,
       is_wall_clock,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9]];
       }],
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       0,
       handle_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9]];
       }],
    most_recently_fired$0 =
      [0,
       function(param){return 0;},
       cst_most_recently_fired,
       [0, set_most_recently_fired],
       most_recently_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9]];
       }],
    fired_events$0 =
      [0,
       function(param){return 0;},
       cst_fired_events,
       [0, set_fired_events],
       fired_events,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9]];
       }],
    events$0 =
      [0,
       function(param){return 0;},
       cst_events,
       0,
       events,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9]];
       }],
    am_advancing$0 =
      [0,
       function(param){return 0;},
       cst_am_advancing,
       [0, set_am_advancing],
       am_advancing,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9]];
       }],
    advance_errors$0 =
      [0,
       function(param){return 0;},
       cst_advance_errors,
       [0, set_advance_errors],
       advance_errors,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
       }],
    id$0 =
      [0,
       function(param){return 0;},
       cst_id,
       0,
       id,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
       }];
   function make_creator$0
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun,
    compile_acc){
    var
     match = caml_call2(id_fun, id$0, compile_acc),
     compile_acc$0 = match[2],
     id_gen = match[1],
     match$0 = caml_call2(advance_errors_fun, advance_errors$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     advance_errors_gen = match$0[1],
     match$1 = caml_call2(am_advancing_fun, am_advancing$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     am_advancing_gen = match$1[1],
     match$2 = caml_call2(events_fun, events$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     events_gen = match$2[1],
     match$3 = caml_call2(fired_events_fun, fired_events$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     fired_events_gen = match$3[1],
     match$4 =
       caml_call2
        (most_recently_fired_fun, most_recently_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     most_recently_fired_gen = match$4[1],
     match$5 = caml_call2(handle_fired_fun, handle_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     handle_fired_gen = match$5[1],
     match$6 = caml_call2(is_wall_clock_fun, is_wall_clock$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     is_wall_clock_gen = match$6[1],
     match$7 = caml_call2(scheduler_fun, scheduler$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     scheduler_gen = match$7[1];
    return [0,
            function(acc){
             var
              id = caml_call1(id_gen, acc),
              advance_errors = caml_call1(advance_errors_gen, acc),
              am_advancing = caml_call1(am_advancing_gen, acc),
              events = caml_call1(events_gen, acc),
              fired_events = caml_call1(fired_events_gen, acc),
              most_recently_fired = caml_call1(most_recently_fired_gen, acc),
              handle_fired = caml_call1(handle_fired_gen, acc),
              is_wall_clock = caml_call1(is_wall_clock_gen, acc),
              scheduler = caml_call1(scheduler_gen, acc);
             return [0,
                     id,
                     advance_errors,
                     am_advancing,
                     events,
                     fired_events,
                     most_recently_fired,
                     handle_fired,
                     is_wall_clock,
                     scheduler];
            },
            compile_acc$8];
   }
   function create$0
   (id,
    advance_errors,
    am_advancing,
    events,
    fired_events,
    most_recently_fired,
    handle_fired,
    is_wall_clock,
    scheduler){
    return [0,
            id,
            advance_errors,
            am_advancing,
            events,
            fired_events,
            most_recently_fired,
            handle_fired,
            is_wall_clock,
            scheduler];
   }
   function map$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bE_ = caml_call1(scheduler_fun, scheduler$0),
     _bF_ = caml_call1(is_wall_clock_fun, is_wall_clock$0),
     _bG_ = caml_call1(handle_fired_fun, handle_fired$0),
     _bH_ = caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _bI_ = caml_call1(fired_events_fun, fired_events$0),
     _bJ_ = caml_call1(events_fun, events$0),
     _bK_ = caml_call1(am_advancing_fun, am_advancing$0),
     _bL_ = caml_call1(advance_errors_fun, advance_errors$0);
    return [0,
            caml_call1(id_fun, id$0),
            _bL_,
            _bK_,
            _bJ_,
            _bI_,
            _bH_,
            _bG_,
            _bF_,
            _bE_];
   }
   function iter$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call1(id_fun, id$0);
    caml_call1(advance_errors_fun, advance_errors$0);
    caml_call1(am_advancing_fun, am_advancing$0);
    caml_call1(events_fun, events$0);
    caml_call1(fired_events_fun, fired_events$0);
    caml_call1(most_recently_fired_fun, most_recently_fired$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return caml_call1(scheduler_fun, scheduler$0);
   }
   function fold$1
   (init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    return caml_call2
            (scheduler_fun,
             caml_call2
              (is_wall_clock_fun,
               caml_call2
                (handle_fired_fun,
                 caml_call2
                  (most_recently_fired_fun,
                   caml_call2
                    (fired_events_fun,
                     caml_call2
                      (events_fun,
                       caml_call2
                        (am_advancing_fun,
                         caml_call2
                          (advance_errors_fun,
                           caml_call2(id_fun, init, id$0),
                           advance_errors$0),
                         am_advancing$0),
                       events$0),
                     fired_events$0),
                   most_recently_fired$0),
                 handle_fired$0),
               is_wall_clock$0),
             scheduler$0);
   }
   function map_poly$0(record){
    var
     _bw_ = [0, caml_call1(record[1], scheduler$0), 0],
     _bx_ = [0, caml_call1(record[1], is_wall_clock$0), _bw_],
     _by_ = [0, caml_call1(record[1], handle_fired$0), _bx_],
     _bz_ = [0, caml_call1(record[1], most_recently_fired$0), _by_],
     _bA_ = [0, caml_call1(record[1], fired_events$0), _bz_],
     _bB_ = [0, caml_call1(record[1], events$0), _bA_],
     _bC_ = [0, caml_call1(record[1], am_advancing$0), _bB_],
     _bD_ = [0, caml_call1(record[1], advance_errors$0), _bC_];
    return [0, caml_call1(record[1], id$0), _bD_];
   }
   function for_all$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bo_ = caml_call1(id_fun, id$0),
     _bp_ = _bo_ ? caml_call1(advance_errors_fun, advance_errors$0) : _bo_,
     _bq_ = _bp_ ? caml_call1(am_advancing_fun, am_advancing$0) : _bp_,
     _br_ = _bq_ ? caml_call1(events_fun, events$0) : _bq_,
     _bs_ = _br_ ? caml_call1(fired_events_fun, fired_events$0) : _br_,
     _bt_ =
       _bs_
        ? caml_call1(most_recently_fired_fun, most_recently_fired$0)
        : _bs_,
     _bu_ = _bt_ ? caml_call1(handle_fired_fun, handle_fired$0) : _bt_,
     _bv_ = _bu_ ? caml_call1(is_wall_clock_fun, is_wall_clock$0) : _bu_;
    return _bv_ ? caml_call1(scheduler_fun, scheduler$0) : _bv_;
   }
   function exists$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bn_ = caml_call1(id_fun, id$0),
     _bg_ = _bn_ || caml_call1(advance_errors_fun, advance_errors$0),
     _bh_ = _bg_ || caml_call1(am_advancing_fun, am_advancing$0),
     _bi_ = _bh_ || caml_call1(events_fun, events$0),
     _bj_ = _bi_ || caml_call1(fired_events_fun, fired_events$0),
     _bk_ = _bj_ || caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _bl_ = _bk_ || caml_call1(handle_fired_fun, handle_fired$0),
     _bm_ = _bl_ || caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return _bm_ ? _bm_ : caml_call1(scheduler_fun, scheduler$0);
   }
   function to_list$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _a__ = [0, caml_call1(scheduler_fun, scheduler$0), 0],
     _a$_ = [0, caml_call1(is_wall_clock_fun, is_wall_clock$0), _a__],
     _ba_ = [0, caml_call1(handle_fired_fun, handle_fired$0), _a$_],
     _bb_ =
       [0, caml_call1(most_recently_fired_fun, most_recently_fired$0), _ba_],
     _bc_ = [0, caml_call1(fired_events_fun, fired_events$0), _bb_],
     _bd_ = [0, caml_call1(events_fun, events$0), _bc_],
     _be_ = [0, caml_call1(am_advancing_fun, am_advancing$0), _bd_],
     _bf_ = [0, caml_call1(advance_errors_fun, advance_errors$0), _be_];
    return [0, caml_call1(id_fun, id$0), _bf_];
   }
   function iter$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call3(id_fun, id$0, record, record[1]);
    caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    caml_call3(am_advancing_fun, am_advancing$0, record, record[3]);
    caml_call3(events_fun, events$0, record, record[4]);
    caml_call3(fired_events_fun, fired_events$0, record, record[5]);
    caml_call3
     (most_recently_fired_fun, most_recently_fired$0, record, record[6]);
    caml_call3(handle_fired_fun, handle_fired$0, record, record[7]);
    caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function fold$2
   (record,
    init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _a2_ = record[9],
     _a3_ = record[8],
     _a4_ = record[7],
     _a5_ = record[6],
     _a6_ = record[5],
     _a7_ = record[4],
     _a8_ = record[3],
     _a9_ = record[2];
    return caml_call4
            (scheduler_fun,
             caml_call4
              (is_wall_clock_fun,
               caml_call4
                (handle_fired_fun,
                 caml_call4
                  (most_recently_fired_fun,
                   caml_call4
                    (fired_events_fun,
                     caml_call4
                      (events_fun,
                       caml_call4
                        (am_advancing_fun,
                         caml_call4
                          (advance_errors_fun,
                           caml_call4(id_fun, init, id$0, record, record[1]),
                           advance_errors$0,
                           record,
                           _a9_),
                         am_advancing$0,
                         record,
                         _a8_),
                       events$0,
                       record,
                       _a7_),
                     fired_events$0,
                     record,
                     _a6_),
                   most_recently_fired$0,
                   record,
                   _a5_),
                 handle_fired$0,
                 record,
                 _a4_),
               is_wall_clock$0,
               record,
               _a3_),
             scheduler$0,
             record,
             _a2_);
   }
   function for_all$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aU_ = caml_call3(id_fun, id$0, record, record[1]),
     _aV_ =
       _aU_
        ? caml_call3(advance_errors_fun, advance_errors$0, record, record[2])
        : _aU_,
     _aW_ =
       _aV_
        ? caml_call3(am_advancing_fun, am_advancing$0, record, record[3])
        : _aV_,
     _aX_ = _aW_ ? caml_call3(events_fun, events$0, record, record[4]) : _aW_,
     _aY_ =
       _aX_
        ? caml_call3(fired_events_fun, fired_events$0, record, record[5])
        : _aX_,
     _aZ_ =
       _aY_
        ? caml_call3
          (most_recently_fired_fun, most_recently_fired$0, record, record[6])
        : _aY_,
     _a0_ =
       _aZ_
        ? caml_call3(handle_fired_fun, handle_fired$0, record, record[7])
        : _aZ_,
     _a1_ =
       _a0_
        ? caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8])
        : _a0_;
    return _a1_
            ? caml_call3(scheduler_fun, scheduler$0, record, record[9])
            : _a1_;
   }
   function exists$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aT_ = caml_call3(id_fun, id$0, record, record[1]),
     _aM_ =
       _aT_
       || caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
     _aN_ =
       _aM_ || caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _aO_ = _aN_ || caml_call3(events_fun, events$0, record, record[4]),
     _aP_ =
       _aO_ || caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _aQ_ =
       _aP_
       ||
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _aR_ =
       _aQ_ || caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _aS_ =
       _aR_
       || caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return _aS_
            ? _aS_
            : caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function to_list$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aE_ = [0, caml_call3(scheduler_fun, scheduler$0, record, record[9]), 0],
     _aF_ =
       [0,
        caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
        _aE_],
     _aG_ =
       [0,
        caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
        _aF_],
     _aH_ =
       [0,
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
        _aG_],
     _aI_ =
       [0,
        caml_call3(fired_events_fun, fired_events$0, record, record[5]),
        _aH_],
     _aJ_ = [0, caml_call3(events_fun, events$0, record, record[4]), _aI_],
     _aK_ =
       [0,
        caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
        _aJ_],
     _aL_ =
       [0,
        caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
        _aK_];
    return [0, caml_call3(id_fun, id$0, record, record[1]), _aL_];
   }
   function map$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aw_ = caml_call3(scheduler_fun, scheduler$0, record, record[9]),
     _ax_ = caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
     _ay_ = caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _az_ =
       caml_call3
        (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _aA_ = caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _aB_ = caml_call3(events_fun, events$0, record, record[4]),
     _aC_ = caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _aD_ =
       caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    return [0,
            caml_call3(id_fun, id$0, record, record[1]),
            _aD_,
            _aC_,
            _aB_,
            _aA_,
            _az_,
            _ay_,
            _ax_,
            _aw_];
   }
   function set_all_mutable_fields$0
   (record, advance_errors, am_advancing, fired_events, most_recently_fired){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[2] = advance_errors;
    record$0[3] = am_advancing;
    record$0[5] = fired_events;
    record$0[6] = most_recently_fired;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       scheduler$0,
       is_wall_clock$0,
       handle_fired$0,
       most_recently_fired$0,
       fired_events$0,
       events$0,
       am_advancing$0,
       advance_errors$0,
       id$0,
       make_creator$0,
       create$0,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0],
    _q_ = [0, cst_now],
    cst_wall_clock = "wall_clock",
    _r_ = [0, cst_events],
    _s_ = [0, cst_now],
    _t_ = [0, cst_src_synchronous_time_sourc$0, 362, 29],
    _u_ = [0, cst_src_synchronous_time_sourc$0, 350, 17],
    _v_ = [0, cst_src_synchronous_time_sourc$0, 346, 15],
    _w_ = [0, cst_src_synchronous_time_sourc$0, 339, 17],
    _x_ = [0, "_"],
    _y_ = [0, cst_src_synchronous_time_sourc$0, 323, 11243, 11267];
   function sexp_of_t$4(param, _ao_){
    var
     events = _ao_[4],
     is_wall_clock = _ao_[8],
     now = caml_call1(Timing_wheel[11], events);
    if(is_wall_clock){
     var _ap_ = [0, [1, [0, _q_, [0, caml_call1(Time_ns[113], now), 0]]], 0];
     return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock), _ap_]];
    }
    var all_events = [0, 0];
    caml_call2
     (Timing_wheel[15],
      events,
      function(alarm){
       var _au_ = all_events[1], _av_ = caml_call2(Alarm[5], events, alarm);
       all_events[1] =
        [0, [0, caml_call2(Alarm[3], events, alarm), _av_], _au_];
       return 0;
      });
    var
     _aq_ =
       caml_call2
        (Core_List[58],
         all_events[1],
         function(param, _at_){
          var at2 = _at_[1], at1 = param[1];
          return caml_call2(Time_ns[100], at1, at2);
         }),
     events$0 =
       caml_call2(Core_List[72], _aq_, function(_as_){return _as_[2];}),
     _ar_ =
       [0,
        [1,
         [0, _r_, [0, caml_call2(Core[421], Job_or_event[6], events$0), 0]]],
        0];
    return [1,
            [0, [1, [0, _s_, [0, caml_call1(Time_ns[113], now), 0]]], _ar_]];
   }
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function is_in_fired_events(t, target_event){
    var current$1 = t[5], ppx_optional_e_0 = current$1;
    for(;;){
     if(caml_call1(Event[3][7][1][1], ppx_optional_e_0)) return 0;
     var
      current = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
      _an_ = caml_call2(Core[246], current, target_event);
     if(_an_) return _an_;
     var current$0 = current[6];
     ppx_optional_e_0 = current$0;
    }
   }
   function invariant_with_jobs(job_invariant, t){
    return caml_call4
            (Base_Invariant[1],
             _y_,
             t,
             function(x_016){
              return sexp_of_t$4(function(param){return _x_;}, x_016);
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               _ac_ =
                 check
                  (function(most_recently_fired){
                    if(caml_call1(Event[3][7][1][1], most_recently_fired))
                     return 0;
                    var
                     event = caml_call1(Event[3][7][1][2], most_recently_fired);
                    if(is_in_fired_events(t, event)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _t_], 1);
                   }),
               _ad_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Event[3][7][1][1], ppx_optional_e_0))
                     return 0;
                    var
                     current$1 = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
                     current = current$1;
                    for(;;){
                     var _am_ = timing_wheel_now(t);
                     if(! caml_call2(Time_ns[94], current[2], _am_))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _v_], 1);
                     var ppx_optional_e_0$0 = current[6];
                     if(caml_call1(Event[3][7][1][1], ppx_optional_e_0$0))
                      return 0;
                     var
                      current$0 =
                        caml_call1(Event[3][7][1][2], ppx_optional_e_0$0);
                     if(! caml_call2(Time_ns[94], current[2], current$0[2]))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _u_], 1);
                     current = current$0;
                    }
                   }),
               _ae_ =
                 check
                  (function(events){
                    caml_call2
                     (Timing_wheel[6], function(_al_){return 0;}, events);
                    return caml_call2
                            (Timing_wheel[15],
                             events,
                             function(alarm){
                              var
                               job_or_event = caml_call2(Alarm[5], events, alarm),
                               k = caml_call1(Job_or_event[5][1], job_or_event),
                               event = caml_call2(Job_or_event[5][2], k, job_or_event);
                              if(k) return caml_call1(job_invariant, event);
                              if(! caml_call2(Core[246], alarm, event[1]))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _w_], 1);
                              var
                               got = event[2],
                               expect = caml_call2(Alarm[3], events, alarm),
                               sexpifier = Time_ns[113];
                              function comparator(a_017, b_018){
                               return caml_call2(Time_ns[100], a_017, b_018);
                              }
                              caml_call8
                               (Ppx_assert_lib_Runtime[3],
                                pos$2,
                                sexpifier,
                                comparator,
                                0,
                                0,
                                0,
                                expect,
                                got);
                              var got$0 = event[8], sexpifier$0 = Event[1][3];
                              function comparator$0(a_019, b_020){
                               return caml_call2(Event[1][1], a_019, b_020);
                              }
                              caml_call8
                               (Ppx_assert_lib_Runtime[3],
                                pos$3,
                                sexpifier$0,
                                comparator$0,
                                0,
                                0,
                                0,
                                2,
                                got$0);
                              return caml_call1(Event[19], event);
                             });
                   });
              return caml_call9
                      (Fields$0[14],
                       function(_ak_){return 0;},
                       function(_aj_){return 0;},
                       function(_ai_){return 0;},
                       _ae_,
                       _ad_,
                       _ac_,
                       function(_ah_){return 0;},
                       function(_ag_){return 0;},
                       function(_af_){return 0;});
             });
   }
   function invariant$0(t){
    return invariant_with_jobs(function(param){return 0;}, t);
   }
   var
    T1 =
      [0,
       Event,
       Job_or_event,
       scheduler,
       is_wall_clock,
       handle_fired,
       most_recently_fired,
       set_most_recently_fired,
       fired_events,
       set_fired_events,
       events,
       am_advancing,
       set_am_advancing,
       advance_errors,
       set_advance_errors,
       id,
       Fields$0,
       sexp_of_t$4,
       timing_wheel_now,
       is_in_fired_events,
       invariant_with_jobs,
       invariant$0];
   function sexp_of_t$5(x_021){return caml_call2(T1[17], Core[171], x_021);}
   var invariant$1 = T1[21], invariant_with_jobs$0 = T1[20];
   function sexp_of_t$6(x_022){return caml_call2(T1[17], Core[202], x_022);}
   var Read_write = [0, sexp_of_t$6, invariant$1, invariant_with_jobs$0];
   function id$1(t){return t[1];}
   function is_wall_clock$1(t){return t[8];}
   function length(t){return caml_call1(Timing_wheel[14], t[4]);}
   function max_allowed_alarm_time(t){
    return caml_call1(Timing_wheel[22], t[4]);
   }
   function read_only(t){return t;}
   function fire(t, event){
    caml_call2(T1[1][20], event, 0);
    event[1] = caml_call1(Alarm[2], 0);
    var ppx_optional_e_0 = t[6];
    a:
    {
     if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
      var
       most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
      if(caml_call2(Time_ns[94], most_recently_fired[2], event[2])){
       var
        most_recently_fired$0 =
          caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
       event[7] = caml_call1(T1[1][3][3], most_recently_fired$0);
       event[6] = most_recently_fired$0[6];
       break a;
      }
     }
     event[7] = T1[1][3][2];
     event[6] = t[5];
    }
    t[6] = caml_call1(T1[1][3][3], event);
    for(;;){
     var ppx_optional_e_0$0 = event[6];
     if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
      var continue$0 = 0;
     else{
      var
       next$0 = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0),
       continue$1 = caml_call2(Time_ns[94], next$0[2], event[2]);
      if(continue$1){event[7] = event[6]; event[6] = next$0[6];}
      var continue$0 = continue$1;
     }
     if(! continue$0) break;
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = caml_call1(T1[1][3][3], event);
    }
    var ppx_optional_e_0$2 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$2)){t[5] = caml_call1(T1[1][3][3], event); return 0;}
    var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$2);
    prev[6] = caml_call1(T1[1][3][3], event);
    return 0;
   }
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function next_alarm_runs_at(t){
    return caml_call1(T1[1][3][5], t[5])
            ? [0, caml_call1(T1[18], t)]
            : caml_call1(Timing_wheel[38], t[4]);
   }
   function now$0(t){
    return t[8] ? caml_call1(Time_ns[50], 0) : caml_call1(T1[18], t);
   }
   var timing_wheel_now$0 = T1[18];
   function schedule(t, event){
    caml_call2(T1[1][20], event, 2);
    var _ab_ = caml_call1(T1[2][1], event);
    event[1] = caml_call3(Timing_wheel[25], t[4], event[2], _ab_);
    return 0;
   }
   function remove_from_fired(t, event, new_status){
    var ppx_optional_e_0 = t[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
     var
      most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
     if(caml_call2(Core[246], event, most_recently_fired))
      t[6] = caml_call2(T1[1][3][6], event[6], event[7]);
    }
    var ppx_optional_e_0$0 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
     t[5] = event[6];
    else{
     var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0);
     prev[6] = event[6];
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = event[7];
    }
    event[6] = T1[1][3][2];
    event[7] = T1[1][3][2];
    return caml_call2(T1[1][20], event, new_status);
   }
   var
    include$0 = T1[1],
    Status$0 = include$0[1],
    sexp_of_event$0 = include$0[2],
    Option$0 = include$0[3],
    status$1 = include$0[4],
    prev_fired$1 = include$0[5],
    set_prev_fired$0 = include$0[6],
    next_fired$1 = include$0[7],
    set_next_fired$0 = include$0[8],
    interval$1 = include$0[9],
    set_interval$0 = include$0[10],
    execution_context$1 = include$0[11],
    callback$1 = include$0[12],
    set_at$0 = include$0[14],
    alarm$1 = include$0[15],
    set_alarm$0 = include$0[16],
    Fields$1 = include$0[17],
    sexp_of_t$7 = include$0[18],
    invariant$2 = include$0[19],
    set_status$1 = include$0[20],
    set_status_if$0 = include$0[21],
    scheduled_at = include$0[22],
    _z_ = [0, "alarm_precision"],
    _A_ = [0, "span"],
    cst_interval_span_smaller_than =
      "interval span smaller than alarm precision",
    _B_ = [0, "Ok"],
    _C_ = [0, "Currently_happening"],
    _D_ = [0, "Previously_unscheduled"];
   function create_internal(t, at, interval, callback){
    var ___ = T1[1][3][2], _$_ = T1[1][3][2], _aa_ = t[9][7];
    return [0,
            caml_call1(Alarm[2], 0),
            at,
            callback,
            _aa_,
            interval,
            _$_,
            ___,
            3];
   }
   function add$0(t, event){
    var _Z_ = caml_call1(timing_wheel_now$0, t);
    return caml_call2(Time_ns[94], event[2], _Z_)
            ? fire(t, event)
            : schedule(t, event);
   }
   function create_and_add(t, at, interval, callback){
    var event = create_internal(t, at, interval, callback);
    add$0(t, event);
    return event;
   }
   function at$2(t, at, callback){return create_and_add(t, at, 0, callback);}
   function after$0(t, span, callback){
    var _Y_ = now$0(t);
    return create_and_add(t, caml_call2(Time_ns[112], _Y_, span), 0, callback);
   }
   function require_span_at_least_alarm_pr(t, span){
    var
     alarm_precision$0 = alarm_precision(t),
     _U_ = caml_call2(Core_Time_ns[1][19], span, alarm_precision$0);
    if(! _U_) return _U_;
    var
     _V_ =
       [0,
        [1,
         [0, _z_, [0, caml_call1(Core_Time_ns[1][10], alarm_precision$0), 0]]],
        0],
     _W_ =
       [0, [1, [0, _A_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], _V_],
     _X_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_interval_span_smaller_than),
         _W_]];
    return caml_call1(Core[253], _X_);
   }
   function at_intervals(t, span, callback){
    require_span_at_least_alarm_pr(t, span);
    return create_and_add(t, now$0(t), [0, span], callback);
   }
   function sexp_of_t$8(param){
    switch(param){case 0: return _B_;case 1: return _C_;default: return _D_;
    }
   }
   var
    Abort_result = [0, sexp_of_t$8],
    _E_ = [0, "reason"],
    cst_Synchronous_time_source_ab =
      "[Synchronous_time_source.abort_exn] cannot abort event",
    _F_ = [0, 0],
    cst_cannot_schedule_an_event_w = "cannot schedule an event with status";
   function abort(t, event){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); return 0;
      case 1:
       return event[5] ? (event[5] = 0, 0) : 1;
      case 2:
       caml_call2(T1[1][20], event, 3);
       caml_call2(Timing_wheel[28], t[4], event[1]);
       event[1] = caml_call1(Alarm[2], 0);
       return 0;
      default: return 2;
    }
   }
   function abort_if_possible(t, event){abort(t, event); return 0;}
   function abort_exn(t, event){
    var reason = abort(t, event);
    if(! reason) return 0;
    var
     _S_ = [0, [1, [0, _E_, [0, caml_call1(Abort_result[1], reason), 0]]], 0],
     _T_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_ab),
         _S_]];
    return caml_call1(Core[253], _T_);
   }
   function create$1(t, callback){
    return create_internal(t, Time_ns[43], 0, callback);
   }
   function schedule_at_internal(t, event, at, interval){
    var status = event[8];
    if(3 <= status){
     event[2] = at;
     event[5] = interval;
     add$0(t, event);
     return _F_;
    }
    var
     _Q_ = [0, caml_call1(T1[1][1][3], status), 0],
     _R_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_schedule_an_event_w),
         _Q_]];
    return caml_call1(Core_Or_error[40], _R_);
   }
   function schedule_at(t, event, at){
    return schedule_at_internal(t, event, at, 0);
   }
   function schedule_after(t, event, span){
    var _P_ = now$0(t);
    return schedule_at(t, event, caml_call2(Time_ns[112], _P_, span));
   }
   function schedule_at_intervals(t, event, span){
    require_span_at_least_alarm_pr(t, span);
    return schedule_at_internal(t, event, now$0(t), [0, span]);
   }
   function reschedule_at(t, event, at){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); event[2] = at; return add$0(t, event);
      case 1:
       event[2] = at; return add$0(t, event);
      case 2:
       event[2] = at;
       var _O_ = caml_call1(timing_wheel_now$0, t);
       return caml_call2(Time_ns[96], at, _O_)
               ? caml_call3(Timing_wheel[29], t[4], event[1], at)
               : (caml_call2
                  (Timing_wheel[28], t[4], event[1]),
                 fire(t, event));
      default: event[2] = at; event[5] = 0; return add$0(t, event);
    }
   }
   function reschedule_after(t, event, span){
    var _N_ = now$0(t);
    return reschedule_at(t, event, caml_call2(Time_ns[112], _N_, span));
   }
   var
    Event$0 =
      [0,
       Status$0,
       sexp_of_event$0,
       Option$0,
       status$1,
       prev_fired$1,
       set_prev_fired$0,
       next_fired$1,
       set_next_fired$0,
       interval$1,
       set_interval$0,
       execution_context$1,
       callback$1,
       set_at$0,
       alarm$1,
       set_alarm$0,
       Fields$1,
       sexp_of_t$7,
       invariant$2,
       set_status$1,
       set_status_if$0,
       scheduled_at,
       create_internal,
       add$0,
       create_and_add,
       at$2,
       after$0,
       require_span_at_least_alarm_pr,
       at_intervals,
       Abort_result,
       abort,
       abort_if_possible,
       abort_exn,
       create$1,
       schedule_at_internal,
       schedule_at,
       schedule_after,
       schedule_at_intervals,
       reschedule_at,
       reschedule_after],
    _G_ = [0, cst_src_synchronous_time_sourc$0, 633, 48],
    cst_cannot_call_advance_by_ala =
      "cannot call [advance_by_alarms] or [advance_directly] from callback",
    _H_ = [0, 0];
   function run_after(t, span, callback){
    caml_call3(Event$0[26], t, span, callback);
    return 0;
   }
   function run_at(t, at, callback){
    caml_call3(Event$0[25], t, at, callback);
    return 0;
   }
   function run_at_intervals(t, span, callback){
    caml_call3(Event$0[28], t, span, callback);
    return 0;
   }
   function run_fired_events(t, send_exn){
    var current_execution_context = t[9][7];
    for(;;){
     var ppx_optional_e_0 = t[5];
     if(caml_call1(Event$0[3][7][1][1], ppx_optional_e_0))
      var _K_ = 0;
     else{
      var event = caml_call1(Event$0[3][7][1][2], ppx_optional_e_0);
      if(event[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
      remove_from_fired(t, event, 1);
      caml_call2(Async_kernel_Scheduler0[2], t[9], event[4]);
      a:
      {
       try{caml_call1(event[3], 0);}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(send_exn){
         var
          send_exn$0 = send_exn[1],
          backtrace = caml_call1(Base_Backtrace[6][4], 0);
         caml_call3
          (send_exn$0, event[4][1], [0, [0, 936718974, backtrace]], exn);
        }
        else{
         var _L_ = t[2];
         t[2] = [0, caml_call2(Core_Error[25], 0, exn), _L_];
        }
        caml_call3(Event$0[20], 1, event, 3);
        break a;
       }
       var match = event[5];
       if(match){
        var interval = match[1];
        if(caml_call2(Event$0[1][2], 1, event[8])){
         var _M_ = caml_call1(timing_wheel_now$0, t);
         event[2] = caml_call5(Time_ns[65], 0, event[2], _M_, interval, 0);
         schedule(t, event);
        }
       }
       else
        caml_call3(Event$0[20], 1, event, 3);
      }
      var _K_ = 1;
     }
     if(! _K_)
      return caml_call2
              (Async_kernel_Scheduler0[2], t[9], current_execution_context);
    }
   }
   function advance_clock(t, to, send_exn){
    caml_call3(Timing_wheel[20], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function fire_past_alarms(t, send_exn){
    caml_call2(Timing_wheel[21], t[4], t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_internal(t, to, send_exn){
    advance_clock(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function prepare_to_advance(t, send_exn){
    if(t[3]){
     var
      _J_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_advance_by_ala);
     caml_call1(Core[253], _J_);
    }
    t[3] = 1;
    if(t[2]) t[2] = 0;
    return run_fired_events(t, send_exn);
   }
   function finish_advancing(t){
    t[3] = 0;
    var errors = t[2];
    return errors
            ? (t[2] = 0, [1, caml_call2(Core_Error[24], 0, errors)])
            : _H_;
   }
   function advance_by_alarms(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    var continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var min_alarm_time = caml_call1(Timing_wheel[37], t[4]);
      if(caml_call2(Time_ns[93], min_alarm_time, to))
       continue$0[1] = 0;
      else
       advance_internal(t, min_alarm_time, send_exn);
     }
    }
   }
   function advance_by_max_alarms_in_each_(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    var continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var next_alarm_fires_at = caml_call1(Timing_wheel[39], t[4]);
      if(caml_call2(Time_ns[93], next_alarm_fires_at, to))
       continue$0[1] = 0;
      else
       advance_internal(t, caml_call1(Timing_wheel[36], t[4]), send_exn);
     }
    }
   }
   function advance_directly(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    advance_internal(t, to, send_exn);
    return finish_advancing(t);
   }
   function duration_of(t, f){
    var
     start = now$0(t),
     result = caml_call1(f, 0),
     _I_ = now$0(t),
     duration = caml_call2(Time_ns[57], _I_, start);
    return [0, result, duration];
   }
   function max_alarm_time_in_min_timing_w(t){
    return caml_call1(Timing_wheel[34], t[4]);
   }
   function has_events_to_run(t){return caml_call1(Event$0[3][5], t[5]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    Async_kernel_Synchronous_time_ =
      [0,
       Time_ns,
       Alarm,
       default_timing_wheel_config,
       T1,
       sexp_of_t$5,
       invariant$1,
       invariant_with_jobs$0,
       Read_write,
       id$1,
       is_wall_clock$1,
       length,
       max_allowed_alarm_time,
       read_only,
       fire,
       alarm_precision,
       next_alarm_fires_at,
       next_alarm_runs_at,
       now$0,
       timing_wheel_now$0,
       schedule,
       remove_from_fired,
       Event$0,
       run_after,
       run_at,
       run_at_intervals,
       run_fired_events,
       advance_clock,
       fire_past_alarms,
       advance_internal,
       prepare_to_advance,
       finish_advancing,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       duration_of,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (102, Async_kernel_Synchronous_time_, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler1
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__External_job, Async_kernel__Import, Async_kernel__Job_pool, Async_kernel__Job_queue, Async_kernel__Scheduler0, Async_kernel__Synchronous_time_source0, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Exn, Base__Field, Base__Invariant, Core, Core__Deque, Core__Error, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Result, Core__Sexp, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue, Timing_wheel, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler1$0 = "Async_kernel__Scheduler1",
    cst_async_kernel$0 = "async_kernel",
    cst_check_access = "check_access",
    cst_check_invariants = "check_invariants",
    cst_current_execution_context = "current_execution_context",
    cst_cycle_count = "cycle_count",
    cst_cycle_start = "cycle_start",
    cst_event_added_hook = "event_added_hook",
    cst_exec = "exec",
    cst_execution_context = "execution_context",
    cst_external_jobs = "external_jobs",
    cst_in_cycle = "in_cycle",
    cst_job_pool = "job_pool",
    cst_job_queued_hook = "job_queued_hook",
    cst_last_cycle_num_jobs = "last_cycle_num_jobs",
    cst_last_cycle_time = "last_cycle_time",
    cst_low_priority_jobs = "low_priority_jobs",
    cst_main_execution_context = "main_execution_context",
    cst_max_num_jobs_per_priority_ = "max_num_jobs_per_priority_per_cycle",
    cst_normal_priority_jobs = "normal_priority_jobs",
    cst_record_backtraces = "record_backtraces",
    cst_run_every_cycle_end = "run_every_cycle_end",
    cst_run_every_cycle_end_state = "run_every_cycle_end_state",
    cst_run_every_cycle_start = "run_every_cycle_start",
    cst_run_every_cycle_start_stat = "run_every_cycle_start_state",
    cst_src_scheduler1_ml = "src/scheduler1.ml",
    cst_thread_safe_external_job_h = "thread_safe_external_job_hook",
    cst_time_source = "time_source",
    cst_total_cycle_time = "total_cycle_time",
    cst_uncaught_exn = "uncaught_exn",
    cst_very_low_priority_workers = "very_low_priority_workers",
    cst_yield = "yield",
    cst_yield_until_no_jobs_remain = "yield_until_no_jobs_remain",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call28
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27){
    return (f.l >= 0 ? f.l : f.l = f.length) == 28
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26,
                a27]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names = [0, cst_execution_context, [0, cst_exec, 0]],
    names$0 =
      caml_list_of_js_array
       ([cst_check_access,
         cst_job_pool,
         cst_normal_priority_jobs,
         cst_low_priority_jobs,
         cst_very_low_priority_workers,
         cst_main_execution_context,
         cst_current_execution_context,
         cst_uncaught_exn,
         cst_cycle_count,
         cst_cycle_start,
         cst_in_cycle,
         cst_run_every_cycle_start,
         cst_run_every_cycle_start_stat,
         cst_run_every_cycle_end,
         cst_run_every_cycle_end_state,
         cst_last_cycle_time,
         cst_last_cycle_num_jobs,
         cst_total_cycle_time,
         cst_time_source,
         cst_external_jobs,
         cst_thread_safe_external_job_h,
         cst_job_queued_hook,
         cst_event_added_hook,
         cst_yield,
         cst_yield_until_no_jobs_remain,
         cst_check_invariants,
         cst_max_num_jobs_per_priority_,
         cst_record_backtraces]),
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Core_Int = global_data.Core__Int,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_List = global_data.Core__List,
    Tuple_pool = global_data.Tuple_pool,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_External_job = global_data.Async_kernel__External_job,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core_Result = global_data.Core__Result;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    events = Async_kernel_Scheduler0[1],
    set_execution_context = Async_kernel_Scheduler0[2],
    debug = Async_kernel_Debug[10];
   function create_with_cell(cell){return [0, cell];}
   function create(param){return [0, 0];}
   function create_full(a){return [0, [2, a]];}
   var Ivar = [0, create_with_cell, create, create_full];
   function create$0(param){
    var _fw_ = [0, 0, caml_call1(Ivar[2], 0)];
    return caml_call1(Async_kernel_Types[10][1], _fw_);
   }
   var Bvar = [0, create$0], _a_ = [0, "Not_finished"], _b_ = [0, "Finished"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   var Exec_result = [0, sexp_of_t];
   function exec(r){return r[2];}
   function execution_context(r){return r[1];}
   var
    exec$0 =
      [0,
       function(param){return 0;},
       cst_exec,
       0,
       exec,
       function(r, v){return [0, r[1], v];}],
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       0,
       execution_context,
       function(r, v){return [0, v, r[2]];}];
   function make_creator(execution_context_fun, exec_fun, compile_acc){
    var
     match =
       caml_call2(execution_context_fun, execution_context$0, compile_acc),
     compile_acc$0 = match[2],
     execution_context_gen = match[1],
     match$0 = caml_call2(exec_fun, exec$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     exec_gen = match$0[1];
    return [0,
            function(acc){
             var
              execution_context = caml_call1(execution_context_gen, acc),
              exec = caml_call1(exec_gen, acc);
             return [0, execution_context, exec];
            },
            compile_acc$1];
   }
   function create$1(execution_context, exec){return [0, execution_context, exec];
   }
   function map(execution_context_fun, exec_fun){
    var _fv_ = caml_call1(exec_fun, exec$0);
    return [0, caml_call1(execution_context_fun, execution_context$0), _fv_];
   }
   function iter(execution_context_fun, exec_fun){
    caml_call1(execution_context_fun, execution_context$0);
    return caml_call1(exec_fun, exec$0);
   }
   function fold(init, execution_context_fun, exec_fun){
    return caml_call2
            (exec_fun,
             caml_call2(execution_context_fun, init, execution_context$0),
             exec$0);
   }
   function map_poly(record){
    var _fu_ = [0, caml_call1(record[1], exec$0), 0];
    return [0, caml_call1(record[1], execution_context$0), _fu_];
   }
   function for_all(execution_context_fun, exec_fun){
    var _ft_ = caml_call1(execution_context_fun, execution_context$0);
    return _ft_ ? caml_call1(exec_fun, exec$0) : _ft_;
   }
   function exists(execution_context_fun, exec_fun){
    var _fs_ = caml_call1(execution_context_fun, execution_context$0);
    return _fs_ ? _fs_ : caml_call1(exec_fun, exec$0);
   }
   function to_list(execution_context_fun, exec_fun){
    var _fr_ = [0, caml_call1(exec_fun, exec$0), 0];
    return [0, caml_call1(execution_context_fun, execution_context$0), _fr_];
   }
   function iter$0(record, execution_context_fun, exec_fun){
    caml_call3(execution_context_fun, execution_context$0, record, record[1]);
    return caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function fold$0(record, init, execution_context_fun, exec_fun){
    var _fq_ = record[2];
    return caml_call4
            (exec_fun,
             caml_call4
              (execution_context_fun,
               init,
               execution_context$0,
               record,
               record[1]),
             exec$0,
             record,
             _fq_);
   }
   function for_all$0(record, execution_context_fun, exec_fun){
    var
     _fp_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _fp_ ? caml_call3(exec_fun, exec$0, record, record[2]) : _fp_;
   }
   function exists$0(record, execution_context_fun, exec_fun){
    var
     _fo_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _fo_ ? _fo_ : caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function to_list$0(record, execution_context_fun, exec_fun){
    var _fn_ = [0, caml_call3(exec_fun, exec$0, record, record[2]), 0];
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _fn_];
   }
   function map$0(record, execution_context_fun, exec_fun){
    var _fm_ = caml_call3(exec_fun, exec$0, record, record[2]);
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _fm_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       exec$0,
       execution_context$0,
       make_creator,
       create$1,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct],
    _c_ = [0, cst_exec],
    _d_ = [0, cst_execution_context],
    _e_ = [0, cst_src_scheduler1_ml, 51, 1645, 1669];
   function sexp_of_t$0(param){
    var
     execution_context_002 = param[1],
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], function(_fl_){return 0;}),
     bnds_001 = [0, [1, [0, _c_, [0, arg_005, 0]]], 0],
     arg_003 =
       caml_call1(Async_kernel_Execution_context[6], execution_context_002),
     bnds_001$0 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001];
    return [1, bnds_001$0];
   }
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             sexp_of_t$0,
             function(param){
              var
               f = Async_kernel_Execution_context[7],
               _fj_ = caml_call2(Base_Invariant[2], t, f);
              return caml_call2(Fields[7], _fj_, function(_fk_){return 0;});
             });
   }
   var
    Very_low_priority_worker =
      [0,
       Exec_result,
       exec,
       execution_context,
       Fields,
       sexp_of_t$0,
       invariant];
   function record_backtraces(r){return r[28];}
   function set_record_backtraces(r, v){r[28] = v; return 0;}
   function max_num_jobs_per_priority_per_(r){return r[27];}
   function set_max_num_jobs_per_priority_(r, v){r[27] = v; return 0;}
   function check_invariants(r){return r[26];}
   function set_check_invariants(r, v){r[26] = v; return 0;}
   function yield_until_no_jobs_remain(r){return r[25];}
   function set_yield_until_no_jobs_remain(r, v){r[25] = v; return 0;}
   function yield$0(r){return r[24];}
   function set_yield(r, v){r[24] = v; return 0;}
   function event_added_hook(r){return r[23];}
   function set_event_added_hook(r, v){r[23] = v; return 0;}
   function job_queued_hook(r){return r[22];}
   function set_job_queued_hook(r, v){r[22] = v; return 0;}
   function thread_safe_external_job_hook(r){return r[21];}
   function set_thread_safe_external_job_h(r, v){r[21] = v; return 0;}
   function external_jobs(r){return r[20];}
   function time_source(r){return r[19];}
   function set_time_source(r, v){r[19] = v; return 0;}
   function total_cycle_time(r){return r[18];}
   function set_total_cycle_time(r, v){r[18] = v; return 0;}
   function last_cycle_num_jobs(r){return r[17];}
   function set_last_cycle_num_jobs(r, v){r[17] = v; return 0;}
   function last_cycle_time(r){return r[16];}
   function set_last_cycle_time(r, v){r[16] = v; return 0;}
   function run_every_cycle_end_state(r){return r[15];}
   function run_every_cycle_end(r){return r[14];}
   function set_run_every_cycle_end(r, v){r[14] = v; return 0;}
   function run_every_cycle_start_state(r){return r[13];}
   function run_every_cycle_start(r){return r[12];}
   function set_run_every_cycle_start(r, v){r[12] = v; return 0;}
   function in_cycle(r){return r[11];}
   function set_in_cycle(r, v){r[11] = v; return 0;}
   function cycle_start(r){return r[10];}
   function set_cycle_start(r, v){r[10] = v; return 0;}
   function cycle_count(r){return r[9];}
   function set_cycle_count(r, v){r[9] = v; return 0;}
   function uncaught_exn_unwrapped(r){return r[8];}
   function set_uncaught_exn(r, v){r[8] = v; return 0;}
   function current_execution_context(r){return r[7];}
   function set_current_execution_context(r, v){r[7] = v; return 0;}
   function main_execution_context(r){return r[6];}
   function set_main_execution_context(r, v){r[6] = v; return 0;}
   function very_low_priority_workers(r){return r[5];}
   function low_priority_jobs(r){return r[4];}
   function normal_priority_jobs(r){return r[3];}
   function job_pool(r){return r[2];}
   function set_job_pool(r, v){r[2] = v; return 0;}
   function check_access(r){return r[1];}
   function set_check_access(r, v){r[1] = v; return 0;}
   var
    record_backtraces$0 =
      [0,
       function(param){return 0;},
       cst_record_backtraces,
       [0, set_record_backtraces],
       record_backtraces,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                v];
       }],
    max_num_jobs_per_priority_per_$0 =
      [0,
       function(param){return 0;},
       cst_max_num_jobs_per_priority_,
       [0, set_max_num_jobs_per_priority_],
       max_num_jobs_per_priority_per_,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                v,
                r[28]];
       }],
    check_invariants$0 =
      [0,
       function(param){return 0;},
       cst_check_invariants,
       [0, set_check_invariants],
       check_invariants,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                v,
                r[27],
                r[28]];
       }],
    yield_until_no_jobs_remain$0 =
      [0,
       function(param){return 0;},
       cst_yield_until_no_jobs_remain,
       [0, set_yield_until_no_jobs_remain],
       yield_until_no_jobs_remain,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                v,
                r[26],
                r[27],
                r[28]];
       }],
    yield$1 =
      [0,
       function(param){return 0;},
       cst_yield,
       [0, set_yield],
       yield$0,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                v,
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    event_added_hook$0 =
      [0,
       function(param){return 0;},
       cst_event_added_hook,
       [0, set_event_added_hook],
       event_added_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                v,
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    job_queued_hook$0 =
      [0,
       function(param){return 0;},
       cst_job_queued_hook,
       [0, set_job_queued_hook],
       job_queued_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                v,
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    thread_safe_external_job_hook$0 =
      [0,
       function(param){return 0;},
       cst_thread_safe_external_job_h,
       [0, set_thread_safe_external_job_h],
       thread_safe_external_job_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                v,
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    external_jobs$0 =
      [0,
       function(param){return 0;},
       cst_external_jobs,
       0,
       external_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                v,
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    time_source$0 =
      [0,
       function(param){return 0;},
       cst_time_source,
       [0, set_time_source],
       time_source,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                v,
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    total_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_total_cycle_time,
       [0, set_total_cycle_time],
       total_cycle_time,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                v,
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    last_cycle_num_jobs$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_num_jobs,
       [0, set_last_cycle_num_jobs],
       last_cycle_num_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                v,
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    last_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_time,
       [0, set_last_cycle_time],
       last_cycle_time,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                v,
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_end_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end_state,
       0,
       run_every_cycle_end_state,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                v,
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_end$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end,
       [0, set_run_every_cycle_end],
       run_every_cycle_end,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                v,
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_start_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start_stat,
       0,
       run_every_cycle_start_state,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                v,
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start,
       [0, set_run_every_cycle_start],
       run_every_cycle_start,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                v,
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    in_cycle$0 =
      [0,
       function(param){return 0;},
       cst_in_cycle,
       [0, set_in_cycle],
       in_cycle,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v,
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_cycle_start,
       [0, set_cycle_start],
       cycle_start,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                v,
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    cycle_count$0 =
      [0,
       function(param){return 0;},
       cst_cycle_count,
       [0, set_cycle_count],
       cycle_count,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                v,
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    uncaught_exn =
      [0,
       function(param){return 0;},
       cst_uncaught_exn,
       [0, set_uncaught_exn],
       uncaught_exn_unwrapped,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    current_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_current_execution_context,
       [0, set_current_execution_context],
       current_execution_context,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    main_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_main_execution_context,
       [0, set_main_execution_context],
       main_execution_context,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                v,
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    very_low_priority_workers$0 =
      [0,
       function(param){return 0;},
       cst_very_low_priority_workers,
       0,
       very_low_priority_workers,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    low_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_low_priority_jobs,
       0,
       low_priority_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    normal_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_normal_priority_jobs,
       0,
       normal_priority_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                v,
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    job_pool$0 =
      [0,
       function(param){return 0;},
       cst_job_pool,
       [0, set_job_pool],
       job_pool,
       function(r, v){
        return [0,
                r[1],
                v,
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    check_access$0 =
      [0,
       function(param){return 0;},
       cst_check_access,
       [0, set_check_access],
       check_access,
       function(r, v){
        return [0,
                v,
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }];
   function make_creator$0
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun,
    compile_acc){
    var
     match = caml_call2(check_access_fun, check_access$0, compile_acc),
     compile_acc$0 = match[2],
     check_access_gen = match[1],
     match$0 = caml_call2(job_pool_fun, job_pool$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     job_pool_gen = match$0[1],
     match$1 =
       caml_call2
        (normal_priority_jobs_fun, normal_priority_jobs$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     normal_priority_jobs_gen = match$1[1],
     match$2 =
       caml_call2(low_priority_jobs_fun, low_priority_jobs$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     low_priority_jobs_gen = match$2[1],
     match$3 =
       caml_call2
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     very_low_priority_workers_gen = match$3[1],
     match$4 =
       caml_call2
        (main_execution_context_fun, main_execution_context$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     main_execution_context_gen = match$4[1],
     match$5 =
       caml_call2
        (current_execution_context_fun,
         current_execution_context$0,
         compile_acc$5),
     compile_acc$6 = match$5[2],
     current_execution_context_gen = match$5[1],
     match$6 = caml_call2(uncaught_exn_fun, uncaught_exn, compile_acc$6),
     compile_acc$7 = match$6[2],
     uncaught_exn_gen = match$6[1],
     match$7 = caml_call2(cycle_count_fun, cycle_count$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     cycle_count_gen = match$7[1],
     match$8 = caml_call2(cycle_start_fun, cycle_start$0, compile_acc$8),
     compile_acc$9 = match$8[2],
     cycle_start_gen = match$8[1],
     match$9 = caml_call2(in_cycle_fun, in_cycle$0, compile_acc$9),
     compile_acc$10 = match$9[2],
     in_cycle_gen = match$9[1],
     match$10 =
       caml_call2
        (run_every_cycle_start_fun, run_every_cycle_start$0, compile_acc$10),
     compile_acc$11 = match$10[2],
     run_every_cycle_start_gen = match$10[1],
     match$11 =
       caml_call2
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         compile_acc$11),
     compile_acc$12 = match$11[2],
     run_every_cycle_start_state_ge = match$11[1],
     match$12 =
       caml_call2
        (run_every_cycle_end_fun, run_every_cycle_end$0, compile_acc$12),
     compile_acc$13 = match$12[2],
     run_every_cycle_end_gen = match$12[1],
     match$13 =
       caml_call2
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         compile_acc$13),
     compile_acc$14 = match$13[2],
     run_every_cycle_end_state_gen = match$13[1],
     match$14 =
       caml_call2(last_cycle_time_fun, last_cycle_time$0, compile_acc$14),
     compile_acc$15 = match$14[2],
     last_cycle_time_gen = match$14[1],
     match$15 =
       caml_call2
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, compile_acc$15),
     compile_acc$16 = match$15[2],
     last_cycle_num_jobs_gen = match$15[1],
     match$16 =
       caml_call2(total_cycle_time_fun, total_cycle_time$0, compile_acc$16),
     compile_acc$17 = match$16[2],
     total_cycle_time_gen = match$16[1],
     match$17 = caml_call2(time_source_fun, time_source$0, compile_acc$17),
     compile_acc$18 = match$17[2],
     time_source_gen = match$17[1],
     match$18 = caml_call2(external_jobs_fun, external_jobs$0, compile_acc$18),
     compile_acc$19 = match$18[2],
     external_jobs_gen = match$18[1],
     match$19 =
       caml_call2
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         compile_acc$19),
     compile_acc$20 = match$19[2],
     thread_safe_external_job_hook_$0 = match$19[1],
     match$20 =
       caml_call2(job_queued_hook_fun, job_queued_hook$0, compile_acc$20),
     compile_acc$21 = match$20[2],
     job_queued_hook_gen = match$20[1],
     match$21 =
       caml_call2(event_added_hook_fun, event_added_hook$0, compile_acc$21),
     compile_acc$22 = match$21[2],
     event_added_hook_gen = match$21[1],
     match$22 = caml_call2(yield_fun, yield$1, compile_acc$22),
     compile_acc$23 = match$22[2],
     yield_gen = match$22[1],
     match$23 =
       caml_call2
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         compile_acc$23),
     compile_acc$24 = match$23[2],
     yield_until_no_jobs_remain_gen = match$23[1],
     match$24 =
       caml_call2(check_invariants_fun, check_invariants$0, compile_acc$24),
     compile_acc$25 = match$24[2],
     check_invariants_gen = match$24[1],
     match$25 =
       caml_call2
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         compile_acc$25),
     compile_acc$26 = match$25[2],
     max_num_jobs_per_priority_per_$1 = match$25[1],
     match$26 =
       caml_call2(record_backtraces_fun, record_backtraces$0, compile_acc$26),
     compile_acc$27 = match$26[2],
     record_backtraces_gen = match$26[1];
    return [0,
            function(acc){
             var
              check_access = caml_call1(check_access_gen, acc),
              job_pool = caml_call1(job_pool_gen, acc),
              normal_priority_jobs = caml_call1(normal_priority_jobs_gen, acc),
              low_priority_jobs = caml_call1(low_priority_jobs_gen, acc),
              very_low_priority_workers =
                caml_call1(very_low_priority_workers_gen, acc),
              main_execution_context =
                caml_call1(main_execution_context_gen, acc),
              current_execution_context =
                caml_call1(current_execution_context_gen, acc),
              uncaught_exn = caml_call1(uncaught_exn_gen, acc),
              cycle_count = caml_call1(cycle_count_gen, acc),
              cycle_start = caml_call1(cycle_start_gen, acc),
              in_cycle = caml_call1(in_cycle_gen, acc),
              run_every_cycle_start =
                caml_call1(run_every_cycle_start_gen, acc),
              run_every_cycle_start_state =
                caml_call1(run_every_cycle_start_state_ge, acc),
              run_every_cycle_end = caml_call1(run_every_cycle_end_gen, acc),
              run_every_cycle_end_state =
                caml_call1(run_every_cycle_end_state_gen, acc),
              last_cycle_time = caml_call1(last_cycle_time_gen, acc),
              last_cycle_num_jobs = caml_call1(last_cycle_num_jobs_gen, acc),
              total_cycle_time = caml_call1(total_cycle_time_gen, acc),
              time_source = caml_call1(time_source_gen, acc),
              external_jobs = caml_call1(external_jobs_gen, acc),
              thread_safe_external_job_hook =
                caml_call1(thread_safe_external_job_hook_$0, acc),
              job_queued_hook = caml_call1(job_queued_hook_gen, acc),
              event_added_hook = caml_call1(event_added_hook_gen, acc),
              yield$0 = caml_call1(yield_gen, acc),
              yield_until_no_jobs_remain =
                caml_call1(yield_until_no_jobs_remain_gen, acc),
              check_invariants = caml_call1(check_invariants_gen, acc),
              max_num_jobs_per_priority_per_ =
                caml_call1(max_num_jobs_per_priority_per_$1, acc),
              record_backtraces = caml_call1(record_backtraces_gen, acc);
             return [0,
                     check_access,
                     job_pool,
                     normal_priority_jobs,
                     low_priority_jobs,
                     very_low_priority_workers,
                     main_execution_context,
                     current_execution_context,
                     uncaught_exn,
                     cycle_count,
                     cycle_start,
                     in_cycle,
                     run_every_cycle_start,
                     run_every_cycle_start_state,
                     run_every_cycle_end,
                     run_every_cycle_end_state,
                     last_cycle_time,
                     last_cycle_num_jobs,
                     total_cycle_time,
                     time_source,
                     external_jobs,
                     thread_safe_external_job_hook,
                     job_queued_hook,
                     event_added_hook,
                     yield$0,
                     yield_until_no_jobs_remain,
                     check_invariants,
                     max_num_jobs_per_priority_per_,
                     record_backtraces];
            },
            compile_acc$27];
   }
   function create$2
   (check_access,
    job_pool,
    normal_priority_jobs,
    low_priority_jobs,
    very_low_priority_workers,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_start_state,
    run_every_cycle_end,
    run_every_cycle_end_state,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    external_jobs,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    return [0,
            check_access,
            job_pool,
            normal_priority_jobs,
            low_priority_jobs,
            very_low_priority_workers,
            main_execution_context,
            current_execution_context,
            uncaught_exn,
            cycle_count,
            cycle_start,
            in_cycle,
            run_every_cycle_start,
            run_every_cycle_start_state,
            run_every_cycle_end,
            run_every_cycle_end_state,
            last_cycle_time,
            last_cycle_num_jobs,
            total_cycle_time,
            time_source,
            external_jobs,
            thread_safe_external_job_hook,
            job_queued_hook,
            event_added_hook,
            yield$0,
            yield_until_no_jobs_remain,
            check_invariants,
            max_num_jobs_per_priority_per_,
            record_backtraces];
   }
   function map$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _eU_ = caml_call1(record_backtraces_fun, record_backtraces$0),
     _eV_ =
       caml_call1
        (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
     _eW_ = caml_call1(check_invariants_fun, check_invariants$0),
     _eX_ =
       caml_call1
        (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _eY_ = caml_call1(yield_fun, yield$1),
     _eZ_ = caml_call1(event_added_hook_fun, event_added_hook$0),
     _e0_ = caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _e1_ =
       caml_call1
        (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _e2_ = caml_call1(external_jobs_fun, external_jobs$0),
     _e3_ = caml_call1(time_source_fun, time_source$0),
     _e4_ = caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _e5_ = caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _e6_ = caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _e7_ =
       caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _e8_ = caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _e9_ =
       caml_call1
        (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _e__ = caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _e$_ = caml_call1(in_cycle_fun, in_cycle$0),
     _fa_ = caml_call1(cycle_start_fun, cycle_start$0),
     _fb_ = caml_call1(cycle_count_fun, cycle_count$0),
     _fc_ = caml_call1(uncaught_exn_fun, uncaught_exn),
     _fd_ =
       caml_call1(current_execution_context_fun, current_execution_context$0),
     _fe_ = caml_call1(main_execution_context_fun, main_execution_context$0),
     _ff_ =
       caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _fg_ = caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _fh_ = caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _fi_ = caml_call1(job_pool_fun, job_pool$0);
    return [0,
            caml_call1(check_access_fun, check_access$0),
            _fi_,
            _fh_,
            _fg_,
            _ff_,
            _fe_,
            _fd_,
            _fc_,
            _fb_,
            _fa_,
            _e$_,
            _e__,
            _e9_,
            _e8_,
            _e7_,
            _e6_,
            _e5_,
            _e4_,
            _e3_,
            _e2_,
            _e1_,
            _e0_,
            _eZ_,
            _eY_,
            _eX_,
            _eW_,
            _eV_,
            _eU_];
   }
   function iter$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call1(check_access_fun, check_access$0);
    caml_call1(job_pool_fun, job_pool$0);
    caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0);
    caml_call1(low_priority_jobs_fun, low_priority_jobs$0);
    caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0);
    caml_call1(main_execution_context_fun, main_execution_context$0);
    caml_call1(current_execution_context_fun, current_execution_context$0);
    caml_call1(uncaught_exn_fun, uncaught_exn);
    caml_call1(cycle_count_fun, cycle_count$0);
    caml_call1(cycle_start_fun, cycle_start$0);
    caml_call1(in_cycle_fun, in_cycle$0);
    caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0);
    caml_call1(run_every_cycle_start_state_fu, run_every_cycle_start_state$0);
    caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0);
    caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0);
    caml_call1(last_cycle_time_fun, last_cycle_time$0);
    caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0);
    caml_call1(total_cycle_time_fun, total_cycle_time$0);
    caml_call1(time_source_fun, time_source$0);
    caml_call1(external_jobs_fun, external_jobs$0);
    caml_call1
     (thread_safe_external_job_hook_, thread_safe_external_job_hook$0);
    caml_call1(job_queued_hook_fun, job_queued_hook$0);
    caml_call1(event_added_hook_fun, event_added_hook$0);
    caml_call1(yield_fun, yield$1);
    caml_call1(yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0);
    caml_call1(check_invariants_fun, check_invariants$0);
    caml_call1
     (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function fold$1
   (init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    return caml_call2
            (record_backtraces_fun,
             caml_call2
              (max_num_jobs_per_priority_per_,
               caml_call2
                (check_invariants_fun,
                 caml_call2
                  (yield_until_no_jobs_remain_fun,
                   caml_call2
                    (yield_fun,
                     caml_call2
                      (event_added_hook_fun,
                       caml_call2
                        (job_queued_hook_fun,
                         caml_call2
                          (thread_safe_external_job_hook_,
                           caml_call2
                            (external_jobs_fun,
                             caml_call2
                              (time_source_fun,
                               caml_call2
                                (total_cycle_time_fun,
                                 caml_call2
                                  (last_cycle_num_jobs_fun,
                                   caml_call2
                                    (last_cycle_time_fun,
                                     caml_call2
                                      (run_every_cycle_end_state_fun,
                                       caml_call2
                                        (run_every_cycle_end_fun,
                                         caml_call2
                                          (run_every_cycle_start_state_fu,
                                           caml_call2
                                            (run_every_cycle_start_fun,
                                             caml_call2
                                              (in_cycle_fun,
                                               caml_call2
                                                (cycle_start_fun,
                                                 caml_call2
                                                  (cycle_count_fun,
                                                   caml_call2
                                                    (uncaught_exn_fun,
                                                     caml_call2
                                                      (current_execution_context_fun,
                                                       caml_call2
                                                        (main_execution_context_fun,
                                                         caml_call2
                                                          (very_low_priority_workers_fun,
                                                           caml_call2
                                                            (low_priority_jobs_fun,
                                                             caml_call2
                                                              (normal_priority_jobs_fun,
                                                               caml_call2
                                                                (job_pool_fun,
                                                                 caml_call2(check_access_fun, init, check_access$0),
                                                                 job_pool$0),
                                                               normal_priority_jobs$0),
                                                             low_priority_jobs$0),
                                                           very_low_priority_workers$0),
                                                         main_execution_context$0),
                                                       current_execution_context$0),
                                                     uncaught_exn),
                                                   cycle_count$0),
                                                 cycle_start$0),
                                               in_cycle$0),
                                             run_every_cycle_start$0),
                                           run_every_cycle_start_state$0),
                                         run_every_cycle_end$0),
                                       run_every_cycle_end_state$0),
                                     last_cycle_time$0),
                                   last_cycle_num_jobs$0),
                                 total_cycle_time$0),
                               time_source$0),
                             external_jobs$0),
                           thread_safe_external_job_hook$0),
                         job_queued_hook$0),
                       event_added_hook$0),
                     yield$1),
                   yield_until_no_jobs_remain$0),
                 check_invariants$0),
               max_num_jobs_per_priority_per_$0),
             record_backtraces$0);
   }
   function map_poly$0(record){
    var
     _et_ = [0, caml_call1(record[1], record_backtraces$0), 0],
     _eu_ = [0, caml_call1(record[1], max_num_jobs_per_priority_per_$0), _et_],
     _ev_ = [0, caml_call1(record[1], check_invariants$0), _eu_],
     _ew_ = [0, caml_call1(record[1], yield_until_no_jobs_remain$0), _ev_],
     _ex_ = [0, caml_call1(record[1], yield$1), _ew_],
     _ey_ = [0, caml_call1(record[1], event_added_hook$0), _ex_],
     _ez_ = [0, caml_call1(record[1], job_queued_hook$0), _ey_],
     _eA_ = [0, caml_call1(record[1], thread_safe_external_job_hook$0), _ez_],
     _eB_ = [0, caml_call1(record[1], external_jobs$0), _eA_],
     _eC_ = [0, caml_call1(record[1], time_source$0), _eB_],
     _eD_ = [0, caml_call1(record[1], total_cycle_time$0), _eC_],
     _eE_ = [0, caml_call1(record[1], last_cycle_num_jobs$0), _eD_],
     _eF_ = [0, caml_call1(record[1], last_cycle_time$0), _eE_],
     _eG_ = [0, caml_call1(record[1], run_every_cycle_end_state$0), _eF_],
     _eH_ = [0, caml_call1(record[1], run_every_cycle_end$0), _eG_],
     _eI_ = [0, caml_call1(record[1], run_every_cycle_start_state$0), _eH_],
     _eJ_ = [0, caml_call1(record[1], run_every_cycle_start$0), _eI_],
     _eK_ = [0, caml_call1(record[1], in_cycle$0), _eJ_],
     _eL_ = [0, caml_call1(record[1], cycle_start$0), _eK_],
     _eM_ = [0, caml_call1(record[1], cycle_count$0), _eL_],
     _eN_ = [0, caml_call1(record[1], uncaught_exn), _eM_],
     _eO_ = [0, caml_call1(record[1], current_execution_context$0), _eN_],
     _eP_ = [0, caml_call1(record[1], main_execution_context$0), _eO_],
     _eQ_ = [0, caml_call1(record[1], very_low_priority_workers$0), _eP_],
     _eR_ = [0, caml_call1(record[1], low_priority_jobs$0), _eQ_],
     _eS_ = [0, caml_call1(record[1], normal_priority_jobs$0), _eR_],
     _eT_ = [0, caml_call1(record[1], job_pool$0), _eS_];
    return [0, caml_call1(record[1], check_access$0), _eT_];
   }
   function for_all$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _d4_ = caml_call1(check_access_fun, check_access$0),
     _d5_ = _d4_ ? caml_call1(job_pool_fun, job_pool$0) : _d4_,
     _d6_ =
       _d5_
        ? caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0)
        : _d5_,
     _d7_ =
       _d6_ ? caml_call1(low_priority_jobs_fun, low_priority_jobs$0) : _d6_,
     _d8_ =
       _d7_
        ? caml_call1
          (very_low_priority_workers_fun, very_low_priority_workers$0)
        : _d7_,
     _d9_ =
       _d8_
        ? caml_call1(main_execution_context_fun, main_execution_context$0)
        : _d8_,
     _d__ =
       _d9_
        ? caml_call1
          (current_execution_context_fun, current_execution_context$0)
        : _d9_,
     _d$_ = _d__ ? caml_call1(uncaught_exn_fun, uncaught_exn) : _d__,
     _ea_ = _d$_ ? caml_call1(cycle_count_fun, cycle_count$0) : _d$_,
     _eb_ = _ea_ ? caml_call1(cycle_start_fun, cycle_start$0) : _ea_,
     _ec_ = _eb_ ? caml_call1(in_cycle_fun, in_cycle$0) : _eb_,
     _ed_ =
       _ec_
        ? caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0)
        : _ec_,
     _ee_ =
       _ed_
        ? caml_call1
          (run_every_cycle_start_state_fu, run_every_cycle_start_state$0)
        : _ed_,
     _ef_ =
       _ee_
        ? caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0)
        : _ee_,
     _eg_ =
       _ef_
        ? caml_call1
          (run_every_cycle_end_state_fun, run_every_cycle_end_state$0)
        : _ef_,
     _eh_ = _eg_ ? caml_call1(last_cycle_time_fun, last_cycle_time$0) : _eg_,
     _ei_ =
       _eh_
        ? caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0)
        : _eh_,
     _ej_ = _ei_ ? caml_call1(total_cycle_time_fun, total_cycle_time$0) : _ei_,
     _ek_ = _ej_ ? caml_call1(time_source_fun, time_source$0) : _ej_,
     _el_ = _ek_ ? caml_call1(external_jobs_fun, external_jobs$0) : _ek_,
     _em_ =
       _el_
        ? caml_call1
          (thread_safe_external_job_hook_, thread_safe_external_job_hook$0)
        : _el_,
     _en_ = _em_ ? caml_call1(job_queued_hook_fun, job_queued_hook$0) : _em_,
     _eo_ = _en_ ? caml_call1(event_added_hook_fun, event_added_hook$0) : _en_,
     _ep_ = _eo_ ? caml_call1(yield_fun, yield$1) : _eo_,
     _eq_ =
       _ep_
        ? caml_call1
          (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0)
        : _ep_,
     _er_ = _eq_ ? caml_call1(check_invariants_fun, check_invariants$0) : _eq_,
     _es_ =
       _er_
        ? caml_call1
          (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0)
        : _er_;
    return _es_
            ? caml_call1(record_backtraces_fun, record_backtraces$0)
            : _es_;
   }
   function exists$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _d3_ = caml_call1(check_access_fun, check_access$0),
     _dD_ = _d3_ || caml_call1(job_pool_fun, job_pool$0),
     _dE_ =
       _dD_ || caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _dF_ = _dE_ || caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _dG_ =
       _dF_
       ||
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _dH_ =
       _dG_
       || caml_call1(main_execution_context_fun, main_execution_context$0),
     _dI_ =
       _dH_
       ||
        caml_call1(current_execution_context_fun, current_execution_context$0),
     _dJ_ = _dI_ || caml_call1(uncaught_exn_fun, uncaught_exn),
     _dK_ = _dJ_ || caml_call1(cycle_count_fun, cycle_count$0),
     _dL_ = _dK_ || caml_call1(cycle_start_fun, cycle_start$0),
     _dM_ = _dL_ || caml_call1(in_cycle_fun, in_cycle$0),
     _dN_ =
       _dM_ || caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _dO_ =
       _dN_
       ||
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _dP_ = _dO_ || caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _dQ_ =
       _dP_
       ||
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _dR_ = _dQ_ || caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _dS_ = _dR_ || caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _dT_ = _dS_ || caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _dU_ = _dT_ || caml_call1(time_source_fun, time_source$0),
     _dV_ = _dU_ || caml_call1(external_jobs_fun, external_jobs$0),
     _dW_ =
       _dV_
       ||
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _dX_ = _dW_ || caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _dY_ = _dX_ || caml_call1(event_added_hook_fun, event_added_hook$0),
     _dZ_ = _dY_ || caml_call1(yield_fun, yield$1),
     _d0_ =
       _dZ_
       ||
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _d1_ = _d0_ || caml_call1(check_invariants_fun, check_invariants$0),
     _d2_ =
       _d1_
       ||
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return _d2_
            ? _d2_
            : caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function to_list$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _dc_ = [0, caml_call1(record_backtraces_fun, record_backtraces$0), 0],
     _dd_ =
       [0,
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
        _dc_],
     _de_ = [0, caml_call1(check_invariants_fun, check_invariants$0), _dd_],
     _df_ =
       [0,
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
        _de_],
     _dg_ = [0, caml_call1(yield_fun, yield$1), _df_],
     _dh_ = [0, caml_call1(event_added_hook_fun, event_added_hook$0), _dg_],
     _di_ = [0, caml_call1(job_queued_hook_fun, job_queued_hook$0), _dh_],
     _dj_ =
       [0,
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
        _di_],
     _dk_ = [0, caml_call1(external_jobs_fun, external_jobs$0), _dj_],
     _dl_ = [0, caml_call1(time_source_fun, time_source$0), _dk_],
     _dm_ = [0, caml_call1(total_cycle_time_fun, total_cycle_time$0), _dl_],
     _dn_ =
       [0, caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0), _dm_],
     _do_ = [0, caml_call1(last_cycle_time_fun, last_cycle_time$0), _dn_],
     _dp_ =
       [0,
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
        _do_],
     _dq_ =
       [0, caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0), _dp_],
     _dr_ =
       [0,
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
        _dq_],
     _ds_ =
       [0,
        caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
        _dr_],
     _dt_ = [0, caml_call1(in_cycle_fun, in_cycle$0), _ds_],
     _du_ = [0, caml_call1(cycle_start_fun, cycle_start$0), _dt_],
     _dv_ = [0, caml_call1(cycle_count_fun, cycle_count$0), _du_],
     _dw_ = [0, caml_call1(uncaught_exn_fun, uncaught_exn), _dv_],
     _dx_ =
       [0,
        caml_call1(current_execution_context_fun, current_execution_context$0),
        _dw_],
     _dy_ =
       [0,
        caml_call1(main_execution_context_fun, main_execution_context$0),
        _dx_],
     _dz_ =
       [0,
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
        _dy_],
     _dA_ = [0, caml_call1(low_priority_jobs_fun, low_priority_jobs$0), _dz_],
     _dB_ =
       [0, caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0), _dA_],
     _dC_ = [0, caml_call1(job_pool_fun, job_pool$0), _dB_];
    return [0, caml_call1(check_access_fun, check_access$0), _dC_];
   }
   function iter$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call3(check_access_fun, check_access$0, record, record[1]);
    caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    caml_call3
     (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]);
    caml_call3(low_priority_jobs_fun, low_priority_jobs$0, record, record[4]);
    caml_call3
     (very_low_priority_workers_fun,
      very_low_priority_workers$0,
      record,
      record[5]);
    caml_call3
     (main_execution_context_fun, main_execution_context$0, record, record[6]);
    caml_call3
     (current_execution_context_fun,
      current_execution_context$0,
      record,
      record[7]);
    caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]);
    caml_call3(cycle_count_fun, cycle_count$0, record, record[9]);
    caml_call3(cycle_start_fun, cycle_start$0, record, record[10]);
    caml_call3(in_cycle_fun, in_cycle$0, record, record[11]);
    caml_call3
     (run_every_cycle_start_fun, run_every_cycle_start$0, record, record[12]);
    caml_call3
     (run_every_cycle_start_state_fu,
      run_every_cycle_start_state$0,
      record,
      record[13]);
    caml_call3
     (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]);
    caml_call3
     (run_every_cycle_end_state_fun,
      run_every_cycle_end_state$0,
      record,
      record[15]);
    caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]);
    caml_call3
     (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]);
    caml_call3(total_cycle_time_fun, total_cycle_time$0, record, record[18]);
    caml_call3(time_source_fun, time_source$0, record, record[19]);
    caml_call3(external_jobs_fun, external_jobs$0, record, record[20]);
    caml_call3
     (thread_safe_external_job_hook_,
      thread_safe_external_job_hook$0,
      record,
      record[21]);
    caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]);
    caml_call3(event_added_hook_fun, event_added_hook$0, record, record[23]);
    caml_call3(yield_fun, yield$1, record, record[24]);
    caml_call3
     (yield_until_no_jobs_remain_fun,
      yield_until_no_jobs_remain$0,
      record,
      record[25]);
    caml_call3(check_invariants_fun, check_invariants$0, record, record[26]);
    caml_call3
     (max_num_jobs_per_priority_per_,
      max_num_jobs_per_priority_per_$0,
      record,
      record[27]);
    return caml_call3
            (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function fold$2
   (record,
    init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cN_ = record[28],
     _cO_ = record[27],
     _cP_ = record[26],
     _cQ_ = record[25],
     _cR_ = record[24],
     _cS_ = record[23],
     _cT_ = record[22],
     _cU_ = record[21],
     _cV_ = record[20],
     _cW_ = record[19],
     _cX_ = record[18],
     _cY_ = record[17],
     _cZ_ = record[16],
     _c0_ = record[15],
     _c1_ = record[14],
     _c2_ = record[13],
     _c3_ = record[12],
     _c4_ = record[11],
     _c5_ = record[10],
     _c6_ = record[9],
     _c7_ = record[8],
     _c8_ = record[7],
     _c9_ = record[6],
     _c__ = record[5],
     _c$_ = record[4],
     _da_ = record[3],
     _db_ = record[2];
    return caml_call4
            (record_backtraces_fun,
             caml_call4
              (max_num_jobs_per_priority_per_,
               caml_call4
                (check_invariants_fun,
                 caml_call4
                  (yield_until_no_jobs_remain_fun,
                   caml_call4
                    (yield_fun,
                     caml_call4
                      (event_added_hook_fun,
                       caml_call4
                        (job_queued_hook_fun,
                         caml_call4
                          (thread_safe_external_job_hook_,
                           caml_call4
                            (external_jobs_fun,
                             caml_call4
                              (time_source_fun,
                               caml_call4
                                (total_cycle_time_fun,
                                 caml_call4
                                  (last_cycle_num_jobs_fun,
                                   caml_call4
                                    (last_cycle_time_fun,
                                     caml_call4
                                      (run_every_cycle_end_state_fun,
                                       caml_call4
                                        (run_every_cycle_end_fun,
                                         caml_call4
                                          (run_every_cycle_start_state_fu,
                                           caml_call4
                                            (run_every_cycle_start_fun,
                                             caml_call4
                                              (in_cycle_fun,
                                               caml_call4
                                                (cycle_start_fun,
                                                 caml_call4
                                                  (cycle_count_fun,
                                                   caml_call4
                                                    (uncaught_exn_fun,
                                                     caml_call4
                                                      (current_execution_context_fun,
                                                       caml_call4
                                                        (main_execution_context_fun,
                                                         caml_call4
                                                          (very_low_priority_workers_fun,
                                                           caml_call4
                                                            (low_priority_jobs_fun,
                                                             caml_call4
                                                              (normal_priority_jobs_fun,
                                                               caml_call4
                                                                (job_pool_fun,
                                                                 caml_call4
                                                                  (check_access_fun, init, check_access$0, record, record[1]),
                                                                 job_pool$0,
                                                                 record,
                                                                 _db_),
                                                               normal_priority_jobs$0,
                                                               record,
                                                               _da_),
                                                             low_priority_jobs$0,
                                                             record,
                                                             _c$_),
                                                           very_low_priority_workers$0,
                                                           record,
                                                           _c__),
                                                         main_execution_context$0,
                                                         record,
                                                         _c9_),
                                                       current_execution_context$0,
                                                       record,
                                                       _c8_),
                                                     uncaught_exn,
                                                     record,
                                                     _c7_),
                                                   cycle_count$0,
                                                   record,
                                                   _c6_),
                                                 cycle_start$0,
                                                 record,
                                                 _c5_),
                                               in_cycle$0,
                                               record,
                                               _c4_),
                                             run_every_cycle_start$0,
                                             record,
                                             _c3_),
                                           run_every_cycle_start_state$0,
                                           record,
                                           _c2_),
                                         run_every_cycle_end$0,
                                         record,
                                         _c1_),
                                       run_every_cycle_end_state$0,
                                       record,
                                       _c0_),
                                     last_cycle_time$0,
                                     record,
                                     _cZ_),
                                   last_cycle_num_jobs$0,
                                   record,
                                   _cY_),
                                 total_cycle_time$0,
                                 record,
                                 _cX_),
                               time_source$0,
                               record,
                               _cW_),
                             external_jobs$0,
                             record,
                             _cV_),
                           thread_safe_external_job_hook$0,
                           record,
                           _cU_),
                         job_queued_hook$0,
                         record,
                         _cT_),
                       event_added_hook$0,
                       record,
                       _cS_),
                     yield$1,
                     record,
                     _cR_),
                   yield_until_no_jobs_remain$0,
                   record,
                   _cQ_),
                 check_invariants$0,
                 record,
                 _cP_),
               max_num_jobs_per_priority_per_$0,
               record,
               _cO_),
             record_backtraces$0,
             record,
             _cN_);
   }
   function for_all$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cm_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _cn_ =
       _cm_ ? caml_call3(job_pool_fun, job_pool$0, record, record[2]) : _cm_,
     _co_ =
       _cn_
        ? caml_call3
          (normal_priority_jobs_fun,
           normal_priority_jobs$0,
           record,
           record[3])
        : _cn_,
     _cp_ =
       _co_
        ? caml_call3
          (low_priority_jobs_fun, low_priority_jobs$0, record, record[4])
        : _co_,
     _cq_ =
       _cp_
        ? caml_call3
          (very_low_priority_workers_fun,
           very_low_priority_workers$0,
           record,
           record[5])
        : _cp_,
     _cr_ =
       _cq_
        ? caml_call3
          (main_execution_context_fun,
           main_execution_context$0,
           record,
           record[6])
        : _cq_,
     _cs_ =
       _cr_
        ? caml_call3
          (current_execution_context_fun,
           current_execution_context$0,
           record,
           record[7])
        : _cr_,
     _ct_ =
       _cs_
        ? caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8])
        : _cs_,
     _cu_ =
       _ct_
        ? caml_call3(cycle_count_fun, cycle_count$0, record, record[9])
        : _ct_,
     _cv_ =
       _cu_
        ? caml_call3(cycle_start_fun, cycle_start$0, record, record[10])
        : _cu_,
     _cw_ =
       _cv_ ? caml_call3(in_cycle_fun, in_cycle$0, record, record[11]) : _cv_,
     _cx_ =
       _cw_
        ? caml_call3
          (run_every_cycle_start_fun,
           run_every_cycle_start$0,
           record,
           record[12])
        : _cw_,
     _cy_ =
       _cx_
        ? caml_call3
          (run_every_cycle_start_state_fu,
           run_every_cycle_start_state$0,
           record,
           record[13])
        : _cx_,
     _cz_ =
       _cy_
        ? caml_call3
          (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14])
        : _cy_,
     _cA_ =
       _cz_
        ? caml_call3
          (run_every_cycle_end_state_fun,
           run_every_cycle_end_state$0,
           record,
           record[15])
        : _cz_,
     _cB_ =
       _cA_
        ? caml_call3
          (last_cycle_time_fun, last_cycle_time$0, record, record[16])
        : _cA_,
     _cC_ =
       _cB_
        ? caml_call3
          (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17])
        : _cB_,
     _cD_ =
       _cC_
        ? caml_call3
          (total_cycle_time_fun, total_cycle_time$0, record, record[18])
        : _cC_,
     _cE_ =
       _cD_
        ? caml_call3(time_source_fun, time_source$0, record, record[19])
        : _cD_,
     _cF_ =
       _cE_
        ? caml_call3(external_jobs_fun, external_jobs$0, record, record[20])
        : _cE_,
     _cG_ =
       _cF_
        ? caml_call3
          (thread_safe_external_job_hook_,
           thread_safe_external_job_hook$0,
           record,
           record[21])
        : _cF_,
     _cH_ =
       _cG_
        ? caml_call3
          (job_queued_hook_fun, job_queued_hook$0, record, record[22])
        : _cG_,
     _cI_ =
       _cH_
        ? caml_call3
          (event_added_hook_fun, event_added_hook$0, record, record[23])
        : _cH_,
     _cJ_ = _cI_ ? caml_call3(yield_fun, yield$1, record, record[24]) : _cI_,
     _cK_ =
       _cJ_
        ? caml_call3
          (yield_until_no_jobs_remain_fun,
           yield_until_no_jobs_remain$0,
           record,
           record[25])
        : _cJ_,
     _cL_ =
       _cK_
        ? caml_call3
          (check_invariants_fun, check_invariants$0, record, record[26])
        : _cK_,
     _cM_ =
       _cL_
        ? caml_call3
          (max_num_jobs_per_priority_per_,
           max_num_jobs_per_priority_per_$0,
           record,
           record[27])
        : _cL_;
    return _cM_
            ? caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28])
            : _cM_;
   }
   function exists$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cl_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _bX_ = _cl_ || caml_call3(job_pool_fun, job_pool$0, record, record[2]),
     _bY_ =
       _bX_
       ||
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _bZ_ =
       _bY_
       ||
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _b0_ =
       _bZ_
       ||
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
     _b1_ =
       _b0_
       ||
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
     _b2_ =
       _b1_
       ||
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
     _b3_ =
       _b2_ || caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _b4_ =
       _b3_ || caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _b5_ =
       _b4_ || caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _b6_ = _b5_ || caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _b7_ =
       _b6_
       ||
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
     _b8_ =
       _b7_
       ||
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
     _b9_ =
       _b8_
       ||
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _b__ =
       _b9_
       ||
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
     _b$_ =
       _b__
       ||
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _ca_ =
       _b$_
       ||
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _cb_ =
       _ca_
       ||
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _cc_ =
       _cb_ || caml_call3(time_source_fun, time_source$0, record, record[19]),
     _cd_ =
       _cc_
       || caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _ce_ =
       _cd_
       ||
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
     _cf_ =
       _ce_
       ||
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _cg_ =
       _cf_
       ||
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _ch_ = _cg_ || caml_call3(yield_fun, yield$1, record, record[24]),
     _ci_ =
       _ch_
       ||
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
     _cj_ =
       _ci_
       ||
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
     _ck_ =
       _cj_
       ||
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]);
    return _ck_
            ? _ck_
            : caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function to_list$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _bw_ =
       [0,
        caml_call3
         (record_backtraces_fun, record_backtraces$0, record, record[28]),
        0],
     _bx_ =
       [0,
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]),
        _bw_],
     _by_ =
       [0,
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
        _bx_],
     _bz_ =
       [0,
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
        _by_],
     _bA_ = [0, caml_call3(yield_fun, yield$1, record, record[24]), _bz_],
     _bB_ =
       [0,
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
        _bA_],
     _bC_ =
       [0,
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
        _bB_],
     _bD_ =
       [0,
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
        _bC_],
     _bE_ =
       [0,
        caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
        _bD_],
     _bF_ =
       [0,
        caml_call3(time_source_fun, time_source$0, record, record[19]),
        _bE_],
     _bG_ =
       [0,
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
        _bF_],
     _bH_ =
       [0,
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
        _bG_],
     _bI_ =
       [0,
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
        _bH_],
     _bJ_ =
       [0,
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
        _bI_],
     _bK_ =
       [0,
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
        _bJ_],
     _bL_ =
       [0,
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
        _bK_],
     _bM_ =
       [0,
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
        _bL_],
     _bN_ =
       [0, caml_call3(in_cycle_fun, in_cycle$0, record, record[11]), _bM_],
     _bO_ =
       [0,
        caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
        _bN_],
     _bP_ =
       [0,
        caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
        _bO_],
     _bQ_ =
       [0,
        caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
        _bP_],
     _bR_ =
       [0,
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
        _bQ_],
     _bS_ =
       [0,
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
        _bR_],
     _bT_ =
       [0,
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
        _bS_],
     _bU_ =
       [0,
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
        _bT_],
     _bV_ =
       [0,
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
        _bU_],
     _bW_ = [0, caml_call3(job_pool_fun, job_pool$0, record, record[2]), _bV_];
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _bW_];
   }
   function map$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _a7_ =
       caml_call3
        (record_backtraces_fun, record_backtraces$0, record, record[28]),
     _a8_ =
       caml_call3
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         record,
         record[27]),
     _a9_ =
       caml_call3
        (check_invariants_fun, check_invariants$0, record, record[26]),
     _a__ =
       caml_call3
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         record,
         record[25]),
     _a$_ = caml_call3(yield_fun, yield$1, record, record[24]),
     _ba_ =
       caml_call3
        (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _bb_ =
       caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _bc_ =
       caml_call3
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         record,
         record[21]),
     _bd_ = caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _be_ = caml_call3(time_source_fun, time_source$0, record, record[19]),
     _bf_ =
       caml_call3
        (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _bg_ =
       caml_call3
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _bh_ =
       caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _bi_ =
       caml_call3
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         record,
         record[15]),
     _bj_ =
       caml_call3
        (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _bk_ =
       caml_call3
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         record,
         record[13]),
     _bl_ =
       caml_call3
        (run_every_cycle_start_fun,
         run_every_cycle_start$0,
         record,
         record[12]),
     _bm_ = caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _bn_ = caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _bo_ = caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _bp_ = caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _bq_ =
       caml_call3
        (current_execution_context_fun,
         current_execution_context$0,
         record,
         record[7]),
     _br_ =
       caml_call3
        (main_execution_context_fun,
         main_execution_context$0,
         record,
         record[6]),
     _bs_ =
       caml_call3
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         record,
         record[5]),
     _bt_ =
       caml_call3
        (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _bu_ =
       caml_call3
        (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _bv_ = caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _bv_,
            _bu_,
            _bt_,
            _bs_,
            _br_,
            _bq_,
            _bp_,
            _bo_,
            _bn_,
            _bm_,
            _bl_,
            _bk_,
            _bj_,
            _bi_,
            _bh_,
            _bg_,
            _bf_,
            _be_,
            _bd_,
            _bc_,
            _bb_,
            _ba_,
            _a$_,
            _a__,
            _a9_,
            _a8_,
            _a7_];
   }
   function set_all_mutable_fields$0
   (record,
    check_access,
    job_pool,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_end,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = check_access;
    record$0[2] = job_pool;
    record$0[6] = main_execution_context;
    record$0[7] = current_execution_context;
    record$0[8] = uncaught_exn;
    record$0[9] = cycle_count;
    record$0[10] = cycle_start;
    record$0[11] = in_cycle;
    record$0[12] = run_every_cycle_start;
    record$0[14] = run_every_cycle_end;
    record$0[16] = last_cycle_time;
    record$0[17] = last_cycle_num_jobs;
    record$0[18] = total_cycle_time;
    record$0[19] = time_source;
    record$0[21] = thread_safe_external_job_hook;
    record$0[22] = job_queued_hook;
    record$0[23] = event_added_hook;
    record$0[24] = yield$0;
    record$0[25] = yield_until_no_jobs_remain;
    record$0[26] = check_invariants;
    record$0[27] = max_num_jobs_per_priority_per_;
    record$0[28] = record_backtraces;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       record_backtraces$0,
       max_num_jobs_per_priority_per_$0,
       check_invariants$0,
       yield_until_no_jobs_remain$0,
       yield$1,
       event_added_hook$0,
       job_queued_hook$0,
       thread_safe_external_job_hook$0,
       external_jobs$0,
       time_source$0,
       total_cycle_time$0,
       last_cycle_num_jobs$0,
       last_cycle_time$0,
       run_every_cycle_end_state$0,
       run_every_cycle_end$0,
       run_every_cycle_start_state$0,
       run_every_cycle_start$0,
       in_cycle$0,
       cycle_start$0,
       cycle_count$0,
       uncaught_exn,
       current_execution_context$0,
       main_execution_context$0,
       very_low_priority_workers$0,
       low_priority_jobs$0,
       normal_priority_jobs$0,
       job_pool$0,
       check_access$0,
       make_creator$0,
       create$2,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0],
    _f_ = [0, cst_record_backtraces],
    _g_ = [0, cst_max_num_jobs_per_priority_],
    _h_ = [0, cst_check_invariants],
    _i_ = [0, cst_yield_until_no_jobs_remain],
    _j_ = [0, cst_yield],
    _k_ = [0, cst_event_added_hook],
    _l_ = [0, cst_job_queued_hook],
    _m_ = [0, cst_thread_safe_external_job_h],
    _n_ = [0, cst_external_jobs],
    _o_ = [0, cst_time_source],
    _p_ = [0, cst_total_cycle_time],
    _q_ = [0, cst_last_cycle_num_jobs],
    _r_ = [0, cst_last_cycle_time],
    _s_ = [0, cst_run_every_cycle_end_state],
    _t_ = [0, cst_run_every_cycle_end],
    _u_ = [0, cst_run_every_cycle_start_stat],
    _v_ = [0, cst_run_every_cycle_start],
    _w_ = [0, cst_in_cycle],
    _x_ = [0, cst_cycle_start],
    _y_ = [0, cst_cycle_count],
    _z_ = [0, cst_uncaught_exn],
    _A_ = [0, cst_current_execution_context],
    _B_ = [0, cst_main_execution_context],
    _C_ = [0, cst_very_low_priority_workers],
    _D_ = [0, cst_low_priority_jobs],
    _E_ = [0, cst_normal_priority_jobs],
    _F_ = [0, cst_job_pool],
    _G_ = [0, cst_check_access],
    cst_unhandled_exception = "unhandled exception",
    _H_ = [0, cst_src_scheduler1_ml, 153, 2],
    _I_ = [0, "t"],
    _J_ = [0, "exn"],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _K_ = [0, cst_src_scheduler1_ml, 191, 14],
    _L_ = [0, cst_src_scheduler1_ml, 187, 43],
    _M_ = [0, cst_src_scheduler1_ml, 171, 46],
    _N_ = [0, cst_src_scheduler1_ml, 170, 40];
   function sexp_of_t$1(param){
    var
     check_access_007 = param[1],
     job_pool_009 = param[2],
     very_low_priority_workers_015 = param[5],
     low_priority_jobs_013 = param[4],
     normal_priority_jobs_011 = param[3],
     main_execution_context_017 = param[6],
     current_execution_context_019 = param[7],
     uncaught_exn_021 = param[8],
     cycle_count_027 = param[9],
     cycle_start_029 = param[10],
     in_cycle_031 = param[11],
     run_every_cycle_start_033 = param[12],
     run_every_cycle_start_state_03 = param[13],
     run_every_cycle_end_037 = param[14],
     run_every_cycle_end_state_039 = param[15],
     last_cycle_time_041 = param[16],
     last_cycle_num_jobs_043 = param[17],
     total_cycle_time_045 = param[18],
     time_source_047 = param[19],
     external_jobs_049 = param[20],
     job_queued_hook_053 = param[22],
     event_added_hook_055 = param[23],
     yield_057 = param[24],
     yield_until_no_jobs_remain_059 = param[25],
     check_invariants_061 = param[26],
     max_num_jobs_per_priority_per_ = param[27],
     record_backtraces_065 = param[28],
     arg_066 = caml_call1(Core[305], record_backtraces_065),
     bnds_006 = [0, [1, [0, _f_, [0, arg_066, 0]]], 0],
     arg_064 =
       caml_call1(Async_kernel_config[5][2], max_num_jobs_per_priority_per_),
     bnds_006$0 = [0, [1, [0, _g_, [0, arg_064, 0]]], bnds_006],
     arg_062 = caml_call1(Core[305], check_invariants_061),
     bnds_006$1 = [0, [1, [0, _h_, [0, arg_062, 0]]], bnds_006$0],
     arg_060 =
       caml_call1(Sexplib0_Sexp_conv[23], yield_until_no_jobs_remain_059),
     bnds_006$2 = [0, [1, [0, _i_, [0, arg_060, 0]]], bnds_006$1],
     arg_058 = caml_call1(Sexplib0_Sexp_conv[23], yield_057),
     bnds_006$3 = [0, [1, [0, _j_, [0, arg_058, 0]]], bnds_006$2],
     arg_056 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a6_){return 0;});
         },
         event_added_hook_055),
     bnds_006$4 = [0, [1, [0, _k_, [0, arg_056, 0]]], bnds_006$3],
     arg_054 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a5_){return 0;});
         },
         job_queued_hook_053),
     bnds_006$5 = [0, [1, [0, _l_, [0, arg_054, 0]]], bnds_006$4],
     arg_052 = caml_call1(Sexplib0_Sexp_conv[24], function(_a4_){return 0;}),
     bnds_006$6 = [0, [1, [0, _m_, [0, arg_052, 0]]], bnds_006$5],
     arg_050 =
       caml_call2
        (Thread_safe_queue[1],
         Async_kernel_External_job[1],
         external_jobs_049),
     bnds_006$7 = [0, [1, [0, _n_, [0, arg_050, 0]]], bnds_006$6],
     arg_048 =
       caml_call2
        (Async_kernel_Synchronous_time_[4][17], Core[202], time_source_047),
     bnds_006$8 = [0, [1, [0, _o_, [0, arg_048, 0]]], bnds_006$7],
     arg_046 = caml_call1(Core_Time_ns[1][10], total_cycle_time_045),
     bnds_006$9 = [0, [1, [0, _p_, [0, arg_046, 0]]], bnds_006$8],
     arg_044 = caml_call1(Core[356], last_cycle_num_jobs_043),
     bnds_006$10 = [0, [1, [0, _q_, [0, arg_044, 0]]], bnds_006$9],
     arg_042 = caml_call1(Core_Time_ns[1][10], last_cycle_time_041),
     bnds_006$11 = [0, [1, [0, _r_, [0, arg_042, 0]]], bnds_006$10],
     arg_040 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_end_state_039),
     bnds_006$12 = [0, [1, [0, _s_, [0, arg_040, 0]]], bnds_006$11],
     arg_038 =
       caml_call2(Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_end_037),
     bnds_006$13 = [0, [1, [0, _t_, [0, arg_038, 0]]], bnds_006$12],
     arg_036 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_start_state_03),
     bnds_006$14 = [0, [1, [0, _u_, [0, arg_036, 0]]], bnds_006$13],
     arg_034 =
       caml_call2
        (Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_start_033),
     bnds_006$15 = [0, [1, [0, _v_, [0, arg_034, 0]]], bnds_006$14],
     arg_032 = caml_call1(Core[305], in_cycle_031),
     bnds_006$16 = [0, [1, [0, _w_, [0, arg_032, 0]]], bnds_006$15],
     arg_030 = caml_call1(Async_kernel_Time_ns[92], cycle_start_029),
     bnds_006$17 = [0, [1, [0, _x_, [0, arg_030, 0]]], bnds_006$16],
     arg_028 = caml_call1(Core[356], cycle_count_027),
     bnds_006$18 = [0, [1, [0, _y_, [0, arg_028, 0]]], bnds_006$17],
     arg_022 =
       caml_call2
        (Core[454],
         function(param){
          var
           arg1_024 = param[2],
           arg0_023 = param[1],
           res0_025 = caml_call1(Base_Exn[1], arg0_023),
           res1_026 = caml_call1(Core_Sexp[90], arg1_024);
          return [1, [0, res0_025, [0, res1_026, 0]]];
         },
         uncaught_exn_021),
     bnds_006$19 = [0, [1, [0, _z_, [0, arg_022, 0]]], bnds_006$18],
     arg_020 =
       caml_call1
        (Async_kernel_Execution_context[6], current_execution_context_019),
     bnds_006$20 = [0, [1, [0, _A_, [0, arg_020, 0]]], bnds_006$19],
     arg_018 =
       caml_call1
        (Async_kernel_Execution_context[6], main_execution_context_017),
     bnds_006$21 = [0, [1, [0, _B_, [0, arg_018, 0]]], bnds_006$20],
     arg_016 =
       caml_call2
        (Core_Deque[10],
         Very_low_priority_worker[5],
         very_low_priority_workers_015),
     bnds_006$22 = [0, [1, [0, _C_, [0, arg_016, 0]]], bnds_006$21],
     arg_014 = caml_call1(Async_kernel_Job_queue[1], low_priority_jobs_013),
     bnds_006$23 = [0, [1, [0, _D_, [0, arg_014, 0]]], bnds_006$22],
     arg_012 = caml_call1(Async_kernel_Job_queue[1], normal_priority_jobs_011),
     bnds_006$24 = [0, [1, [0, _E_, [0, arg_012, 0]]], bnds_006$23],
     arg_010 = caml_call1(Async_kernel_Job_pool[2], job_pool_009),
     bnds_006$25 = [0, [1, [0, _F_, [0, arg_010, 0]]], bnds_006$24],
     arg_008 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a3_){return 0;});
         },
         check_access_007),
     bnds_006$26 = [0, [1, [0, _G_, [0, arg_008, 0]]], bnds_006$25];
    return [1, bnds_006$26];
   }
   function uncaught_exn$0(t){
    var _a2_ = t[8];
    if(! _a2_) return 0;
    var match = _a2_[1], sexp = match[2], exn = match[1];
    return [0,
            caml_call5
             (Core_Error[17],
              0,
              0,
              cst_unhandled_exception,
              [0, exn, sexp],
              function(param){
               var
                arg1_068 = param[2],
                arg0_067 = param[1],
                res0_069 = caml_call1(Base_Exn[1], arg0_067),
                res1_070 = caml_call1(Core_Sexp[90], arg1_068);
               return [1, [0, res0_069, [0, res1_070, 0]]];
              })];
   }
   function num_pending_jobs(t){
    var _a1_ = caml_call1(Async_kernel_Job_queue[8], t[4]);
    return caml_call1(Async_kernel_Job_queue[8], t[3]) + _a1_ | 0;
   }
   function num_jobs_run(t){
    var _a0_ = caml_call1(Async_kernel_Job_queue[10], t[4]);
    return caml_call1(Async_kernel_Job_queue[10], t[3]) + _a0_ | 0;
   }
   function last_cycle_num_jobs$1(t){return t[17];}
   function unordered_is_sublist(equal, small, large){
    var
     _aY_ =
       caml_call3
        (Core_List[10],
         small,
         [0, large],
         function(acc, x){
          return caml_call2
                  (Core_Option[27],
                   acc,
                   function(l$0){
                    var
                     _aZ_ =
                       caml_call2
                        (Core_List[130],
                         l$0,
                         function(y){return 1 - caml_call2(equal, y, x);}),
                     match = _aZ_[2],
                     l = _aZ_[1];
                    if(! match) return 0;
                    var r = match[2];
                    return [0, caml_call2(Core[157], l, r)];
                   });
         });
    return caml_call1(Core_Option[57], _aY_);
   }
   function check_hook_table_invariant(table, list){
    var _aX_ = caml_call1(Core_Hashtbl[65], table);
    if(unordered_is_sublist(Core[246], _aX_, list)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _as_ =
        caml_call1
         (Async_kernel_Synchronous_time_[8][3],
          function(job){
           if(caml_call2(Tuple_pool[6], t[2], job)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
          }),
      _at_ = Async_kernel_Execution_context[7],
      _au_ = Async_kernel_Execution_context[7],
      _av_ = Async_kernel_Job_queue[2],
      _aw_ = Async_kernel_Job_queue[2],
      _ax_ = Async_kernel_Job_pool[3],
      _ay_ =
        caml_call28
         (Fields$0[33],
          function(_aW_){return 0;},
          function(_aV_){return check(_ax_, _aV_);},
          function(_aU_){return check(_aw_, _aU_);},
          function(_aT_){return check(_av_, _aT_);},
          function(field){
           var q = caml_call2(Base_Field[3], field, t);
           return caml_call2(Core_Deque[17], q, Very_low_priority_worker[6]);
          },
          function(_aS_){return check(_au_, _aS_);},
          function(_aR_){return check(_at_, _aR_);},
          function(field){
           var
            uncaught_exn = caml_call2(Base_Field[3], field, t),
            _aP_ = caml_call1(Core[243], uncaught_exn);
           if(! _aP_) return _aP_;
           var _aQ_ = num_pending_jobs(t);
           if(caml_call2(Async_kernel_Import[3], _aQ_, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
          },
          function(field){
           var cycle_count = caml_call2(Base_Field[3], field, t);
           if(caml_call2(Async_kernel_Import[1], cycle_count, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
          },
          function(_aO_){return 0;},
          function(_aN_){return 0;},
          function(_aM_){return 0;},
          function(field){
           var
            run_every_cycle_start_state = caml_call2(Base_Field[3], field, t);
           return check_hook_table_invariant
                   (run_every_cycle_start_state, t[12]);
          },
          function(_aL_){return 0;},
          function(field){
           var
            run_every_cycle_end_state = caml_call2(Base_Field[3], field, t);
           return check_hook_table_invariant(run_every_cycle_end_state, t[14]);
          },
          function(_aK_){return 0;},
          function(field){
           var last_cycle_num_jobs = caml_call2(Base_Field[3], field, t);
           if(caml_call2(Async_kernel_Import[1], last_cycle_num_jobs, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
          },
          function(_aJ_){return 0;},
          function(_aI_){return check(_as_, _aI_);},
          function(_aH_){return 0;},
          function(_aG_){return 0;},
          function(_aF_){return 0;},
          function(_aE_){return 0;},
          function(_aD_){return 0;},
          function(_aC_){return 0;},
          function(_aB_){return 0;},
          function(_aA_){return 0;},
          function(_az_){return 0;});
     return _ay_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ap_ = [0, [1, [0, _I_, [0, sexp_of_t$1(t), 0]]], 0],
      _aq_ = [0, [1, [0, _J_, [0, caml_call1(Core[537], exn), 0]]], _ap_],
      _ar_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _aq_]];
     return caml_call1(Core[253], _ar_);
    }
   }
   function free_job(t, job){return caml_call2(Tuple_pool[15], t[2], job);}
   function enqueue(t, execution_context, f, a){
    var _an_ = caml_call1(Core[242], t[8]);
    if(_an_){
     var priority = execution_context[2], job_queue = priority ? t[4] : t[3];
     caml_call4(Async_kernel_Job_queue[4], job_queue, execution_context, f, a);
     var match = t[22];
     if(match){var f$0 = match[1]; return caml_call1(f$0, priority);}
     var _ao_ = 0;
    }
    else
     var _ao_ = _an_;
    return _ao_;
   }
   function enqueue_job(t, job, free_job){
    var
     job_pool = t[2],
     _al_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][5]),
     _am_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][4]);
    enqueue
     (t,
      caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][3]),
      _am_,
      _al_);
    return free_job ? caml_call2(Tuple_pool[15], t[2], job) : free_job;
   }
   function handle_fired(time_source, job_or_event){
    var
     k = caml_call1(Async_kernel_Synchronous_time_[4][2][5][1], job_or_event),
     match =
       caml_call2(Async_kernel_Synchronous_time_[4][2][5][2], k, job_or_event);
    return k
            ? enqueue_job(time_source[9], match, 1)
            : caml_call2
              (Async_kernel_Synchronous_time_[14], time_source, match);
   }
   function create$3(param){
    var
     now = caml_call1(Async_kernel_Time_ns[50], 0),
     t = [],
     time_source = [],
     events = caml_call2(Timing_wheel[9], Async_kernel_config[29], now),
     _T_ = Async_kernel_config[27],
     _U_ = Async_kernel_config[23],
     _V_ = Async_kernel_config[16],
     _W_ = caml_call1(Bvar[1], 0),
     _X_ = caml_call1(Bvar[1], 0),
     _Y_ = caml_call1(Thread_safe_queue[3], 0),
     _Z_ = caml_call1(Async_kernel_Import[16], 0.),
     ___ = caml_call1(Async_kernel_Import[16], 0.),
     _$_ = Async_kernel_Types[20],
     _aa_ = caml_call3(Core_Hashtbl[4], 0, 0, [0, _$_[20], _$_[10], _$_[36]]),
     _ab_ = Async_kernel_Types[20],
     _ac_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _ab_[20], _ab_[10], _ab_[36]]),
     _ad_ = Async_kernel_Execution_context[8],
     _ae_ = Async_kernel_Execution_context[8],
     _af_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _ag_ = caml_call1(Async_kernel_Job_queue[3], 0),
     _ah_ = caml_call1(Async_kernel_Job_queue[3], 0);
    caml_update_dummy
     (t,
      [0,
       0,
       caml_call1(Async_kernel_Job_pool[4], 0),
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       0,
       0,
       now,
       0,
       0,
       _ac_,
       0,
       _aa_,
       ___,
       0,
       _Z_,
       time_source,
       _Y_,
       function(_ak_){return 0;},
       0,
       0,
       _X_,
       _W_,
       _V_,
       _U_,
       _T_]);
    var
     _ai_ = Async_kernel_Synchronous_time_[22][3][2],
     _aj_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _aj_,
       _ai_,
       function(alarm){
        return handle_fired
                (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
       },
       1,
       t]);
    return t;
   }
   function is_dead(t){return caml_call1(Core[243], t[8]);}
   function set_check_access$0(t, f){t[1] = f; return 0;}
   var
    match = caml_call1(Core_Result[47], create$3),
    _O_ = [0, 0],
    _P_ = [0, 0],
    cst_got_uncaught_exn = "got_uncaught_exn",
    cst_Async_cannot_create_its_ra = "Async cannot create its raw scheduler",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler1 = cst_Async_kernel_Scheduler1$0;
   if(0 === match[0])
    var t = match[1], t_ref = [0, t];
   else{
    var exn = match[1];
    caml_call3
     (Async_kernel_Debug[15], cst_Async_cannot_create_its_ra, exn, Core[537]);
    var t_ref = caml_call1(Core[83], 1);
   }
   function check_access$1(t){
    var match = t[1];
    if(! match) return 0;
    var f = match[1];
    return caml_call1(f, 0);
   }
   function t$0(param){var t = t_ref[1]; check_access$1(t); return t;}
   function current_execution_context$1(t){
    return t[28] ? caml_call1(Async_kernel_Execution_context[12], t[7]) : t[7];
   }
   function with_execution_context1(t, tmp_context, f, x){
    var old_context = current_execution_context$1(t);
    caml_call2(set_execution_context, t, tmp_context);
    return caml_call3
            (Core[252],
             f,
             x,
             function(param){
              return caml_call2(set_execution_context, t, old_context);
             });
   }
   function with_execution_context(t, tmp_context, f){
    return with_execution_context1(t, tmp_context, f, 0);
   }
   function create_job(t, execution_context, f, a){
    if(caml_call1(Tuple_pool[14], t[2]))
     t[2] = caml_call2(Tuple_pool[13], 0, t[2]);
    return caml_call4(Tuple_pool[19], t[2], execution_context, f, a);
   }
   function got_uncaught_exn(t, exn, sexp){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_got_uncaught_exn,
       [0, exn, sexp],
       function(param){
        var
         arg1_072 = param[2],
         arg0_071 = param[1],
         res0_073 = caml_call1(Base_Exn[1], arg0_071),
         res1_074 = caml_call1(Core_Sexp[90], arg1_072);
        return [1, [0, res0_073, [0, res1_074, 0]]];
       });
    caml_call2
     (Core_List[9], [0, t[3], [0, t[4], 0]], Async_kernel_Job_queue[5]);
    t[8] = [0, [0, exn, sexp]];
    return 0;
   }
   function start_cycle(t, max_num_jobs_per_priority){
    var n = caml_call1(Async_kernel_config[5][5], max_num_jobs_per_priority);
    caml_call2(Async_kernel_Job_queue[6], t[3], n);
    return caml_call2(Async_kernel_Job_queue[6], t[4], n);
   }
   function run_jobs(t){
    for(;;){
     var e = caml_call2(Async_kernel_Job_queue[9], t[3], t);
     if(0 !== e[0]) return e;
     var e$0 = caml_call2(Async_kernel_Job_queue[9], t[4], t);
     if(0 !== e$0[0]) return e$0;
     if
      (!
       caml_call1(Async_kernel_Job_queue[7], t[3])
       && ! caml_call1(Async_kernel_Job_queue[7], t[4]))
      return _O_;
    }
   }
   function stabilize(t){
    start_cycle(t, caml_call1(Async_kernel_config[5][4], Core_Int[41]));
    var match = run_jobs(t);
    if(0 === match[0]) return _P_;
    var exn = match[1][1];
    return [1, exn];
   }
   function create_time_source(opt, now, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = Async_kernel_config[29];
    var
     t = t$0(0),
     events = caml_call2(Timing_wheel[9], timing_wheel_config, now),
     time_source = [],
     _R_ = Async_kernel_Synchronous_time_[22][3][2],
     _S_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _S_,
       _R_,
       function(alarm){
        return handle_fired
                (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
       },
       0,
       t]);
    return time_source;
   }
   function wall_clock(param){
    var _Q_ = t$0(0)[19];
    return caml_call1(Async_kernel_Synchronous_time_[13], _Q_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler1);
   var
    Async_kernel_Scheduler1 =
      [0,
       events,
       set_execution_context,
       debug,
       Ivar,
       Bvar,
       Very_low_priority_worker,
       record_backtraces,
       set_record_backtraces,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       check_invariants,
       set_check_invariants,
       yield_until_no_jobs_remain,
       set_yield_until_no_jobs_remain,
       yield$0,
       set_yield,
       event_added_hook,
       set_event_added_hook,
       job_queued_hook,
       set_job_queued_hook,
       thread_safe_external_job_hook,
       set_thread_safe_external_job_h,
       external_jobs,
       time_source,
       set_time_source,
       total_cycle_time,
       set_total_cycle_time,
       set_last_cycle_num_jobs,
       last_cycle_time,
       set_last_cycle_time,
       run_every_cycle_end_state,
       run_every_cycle_end,
       set_run_every_cycle_end,
       run_every_cycle_start_state,
       run_every_cycle_start,
       set_run_every_cycle_start,
       in_cycle,
       set_in_cycle,
       cycle_start,
       set_cycle_start,
       cycle_count,
       set_cycle_count,
       set_uncaught_exn,
       set_current_execution_context,
       main_execution_context,
       set_main_execution_context,
       very_low_priority_workers,
       low_priority_jobs,
       normal_priority_jobs,
       job_pool,
       set_job_pool,
       Fields$0,
       sexp_of_t$1,
       uncaught_exn_unwrapped,
       uncaught_exn$0,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs$1,
       unordered_is_sublist,
       check_hook_table_invariant,
       invariant$0,
       free_job,
       enqueue,
       enqueue_job,
       handle_fired,
       create$3,
       is_dead,
       set_check_access$0,
       t_ref,
       check_access$1,
       t$0,
       current_execution_context$1,
       with_execution_context1,
       with_execution_context,
       create_job,
       got_uncaught_exn,
       start_cycle,
       run_jobs,
       stabilize,
       create_time_source,
       wall_clock];
   runtime.caml_register_global
    (120, Async_kernel_Scheduler1, cst_Async_kernel_Scheduler1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar0
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Scheduler1, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar0 = "Async_kernel__Ivar0",
    cst_async_kernel = "async_kernel",
    cst_src_ivar0_ml = "src/ivar0.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar0_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _b_ = [0, "execution_context"];
   function set_prev(param, x){param[3] = x; return 0;}
   function set_next(param, x){param[4] = x; return 0;}
   function create(run, execution_context){
    var t = [0, run, execution_context, 0, 0];
    set_prev(t, t);
    set_next(t, t);
    return t;
   }
   function create2(run1, execution_context1, run2, execution_context2){
    var
     t1 = [0, run1, execution_context1, 0, 0],
     t2 = [0, run2, execution_context2, t1, t1];
    set_prev(t1, t2);
    set_next(t1, t2);
    return t1;
   }
   function length(t){
    var n = [0, 1], r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return n[1];
     n[1]++;
     r[1] = r[1][4];
    }
   }
   function enqueue(t, scheduler, v){
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, t[2], t[1], v);
   }
   function schedule_jobs(t, v){
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0);
    enqueue(t, scheduler, v);
    var r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return 0;
     enqueue(r[1], scheduler, v);
     r[1] = r[1][4];
    }
   }
   function add(t, run, execution_context){
    var result = [0, run, execution_context, t[3], t];
    set_next(t[3], result);
    set_prev(t, result);
    return result;
   }
   function of_list(l){
    if(! l) return 0;
    var
     l$0 = l[2],
     match = l[1],
     execution_context = match[2],
     run = match[1],
     first = create(run, execution_context),
     prev = first,
     l$1 = l$0;
    for(;;){
     if(! l$1){set_prev(first, prev); return [0, first];}
     var
      l$2 = l$1[2],
      match$0 = l$1[1],
      execution_context$0 = match$0[2],
      run$0 = match$0[1],
      prev$0 = [0, run$0, execution_context$0, prev, first];
     set_next(prev, prev$0);
     prev = prev$0;
     l$1 = l$2;
    }
   }
   function to_list(first){
    var t = first[3], t$0 = t, acc = 0;
    for(;;){
     var acc$0 = [0, [0, t$0[1], t$0[2]], acc];
     if(caml_call2(Core[246], t$0, first)) return acc$0;
     var t$1 = t$0[3];
     t$0 = t$1;
     acc = acc$0;
    }
   }
   function sexp_of_t(param, t){
    var execution_context = t[2];
    return [1,
            [0,
             _b_,
             [0,
              caml_call1(Async_kernel_Execution_context[6], execution_context),
              0]]];
   }
   function cell_of_handler(x){return x;}
   function equal(t$0, t){return caml_call2(Core[246], t$0, t);}
   function indir(t){return [0, [3, t]];}
   var
    include = Async_kernel_Scheduler1[4],
    create_with_cell = include[1],
    create$0 = include[2],
    create_full = include[3],
    _a_ = [0, cst_src_ivar0_ml, 118, 6],
    _c_ = [0, cst_src_ivar0_ml, 258, 15],
    _d_ = [0, "Empty"],
    _e_ = [0, "Full"],
    _f_ = [0, cst_src_ivar0_ml, 269, 15],
    _g_ = [0, cst_src_ivar0_ml, 277, 15],
    _h_ = [0, cst_src_ivar0_ml, 285, 15],
    cst_Ivar_value_exn_called_on_e = "Ivar.value_exn called on empty ivar",
    _i_ = [0, cst_src_ivar0_ml, 296, 15],
    _j_ = [0, "_"],
    _k_ = [0, "t"],
    cst_Ivar_fill_of_full_ivar = "Ivar.fill of full ivar",
    _l_ = [0, cst_src_ivar0_ml, 306, 15],
    _m_ = [0, cst_src_ivar0_ml, 321, 15],
    _n_ = [0, cst_src_ivar0_ml, 340, 15],
    _o_ = [0, cst_src_ivar0_ml, 362, 15],
    _p_ = [0, cst_src_ivar0_ml, 383, 15],
    _q_ = [0, cst_src_ivar0_ml, 450, 21],
    _r_ = [0, cst_src_ivar0_ml, 446, 35];
   function squash(t$3){
    var match$0 = t$3[1];
    if(typeof match$0 !== "number" && 3 === match$0[0]){
     var t$4 = match$0[1], indir$1 = t$4[1];
     if(typeof indir$1 !== "number" && 3 === indir$1[0]){
      var t$5 = indir$1[1];
      a:
      {
       var indir = indir$1, t = t$5;
       for(;;){
        var indir$0 = t[1];
        if(typeof indir$0 === "number") break;
        if(3 !== indir$0[0]) break a;
        var t$0 = indir$0[1];
        indir = indir$0;
        t = t$0;
       }
      }
      var t$1 = t$3;
      for(;;){
       var match = t$1[1];
       if(typeof match !== "number" && 3 === match[0]){
        var t$2 = match[1];
        t$1[1] = indir;
        t$1 = t$2;
        continue;
       }
       return t$1;
      }
     }
     return t$4;
    }
    return t$3;
   }
   function invariant(a_invariant, t){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler === "number") return 0;
    switch(handler[0]){
      case 0:
       caml_call1(Async_kernel_Execution_context[7], handler[2]);
       var r = [0, handler[4]];
       for(;;){
        if(caml_call2(Core[246], r[1], handler)) return 0;
        var t1 = r[1];
        if(! caml_call2(Core[246], t1[4][3], t1))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        caml_call1(Async_kernel_Execution_context[7], t1[2]);
        r[1] = r[1][4];
       }
       break;
      case 1:
       var execution_context = handler[2];
       return caml_call1(Async_kernel_Execution_context[7], execution_context);
      case 2:
       var a = handler[1]; return caml_call1(a_invariant, a);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1];
        return [1, [0, _e_, [0, caml_call1(sexp_of_a, a), 0]]];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
    return _d_;
   }
   function peek(t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return [0, a];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    return 0;
   }
   function value(t, if_empty_then_failwith){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return a;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
    return caml_call1(Core[6], if_empty_then_failwith);
   }
   function value_exn(t){return value(t, cst_Ivar_value_exn_called_on_e);}
   function is_empty(t){
    var t$0 = squash(t), _B_ = t$0[1];
    if(typeof _B_ !== "number")
     switch(_B_[0]){
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    return 1;
   }
   function is_full(t){return 1 - is_empty(t);}
   function fill(t, v){
    var x_001 = squash(t), handler = x_001[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        x_001[1] = [2, v]; return schedule_jobs(handler, v);
       case 1:
        var execution_context = handler[2], run = handler[1];
        x_001[1] = [2, v];
        var _y_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        return caml_call3
                (caml_call1(Async_kernel_Scheduler1[63], _y_),
                 execution_context,
                 run,
                 v);
       case 2:
        var
         _z_ =
           [0,
            [1,
             [0,
              _k_,
              [0, sexp_of_t$0(function(param){return _j_;}, x_001), 0]]],
            0],
         _A_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Ivar_fill_of_full_ivar),
             _z_]];
        return caml_call1(Core[253], _A_);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
    x_001[1] = [2, v];
    return 0;
   }
   function remove_handler(t, handler){
    function x$0(_x_){return 0;}
    handler[1] = x$0;
    var t$0 = squash(t), cell = t$0[1];
    if(typeof cell !== "number")
     switch(cell[0]){
       case 0:
        if(caml_call2(Core[246], handler, handler[4])){t$0[1] = 0; return 0;}
        if(caml_call2(Core[246], handler, cell)){var x = handler[4]; t$0[1] = x;}
        set_prev(handler[4], handler[3]);
        set_next(handler[3], handler[4]);
        set_prev(handler, handler);
        return set_next(handler, handler);
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     }
    return 0;
   }
   function add_handler(t, run, execution_context){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        return add(handler, run, execution_context);
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         handler$1 =
           create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = handler$1;
        return handler$1;
       case 2:
        var
         v = handler[1],
         handler$2 = create(run, execution_context),
         run$1 = function(v){return caml_call1(handler$2[1], v);},
         _w_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        caml_call3
         (caml_call1(Async_kernel_Scheduler1[63], _w_),
          execution_context,
          run$1,
          v);
        return handler$2;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     }
    var handler$0 = create(run, execution_context);
    t$0[1] = handler$0;
    return handler$0;
   }
   function has_handlers(t){
    var t$0 = squash(t), _v_ = t$0[1];
    if(typeof _v_ !== "number")
     switch(_v_[0]){
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
       case 2: break;
       default: return 1;
     }
    return 0;
   }
   function upon(t, run){
    var _u_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return add_handler(t, run, caml_call1(Async_kernel_Scheduler1[72], _u_));
   }
   function upon$0(t, run){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     t$0 = squash(t),
     handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        add(handler, run, execution_context); return 0;
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         x = create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = x;
        return 0;
       case 2:
        var v = handler[1];
        return caml_call4
                (Async_kernel_Scheduler1[63],
                 scheduler,
                 execution_context,
                 run,
                 v);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     }
    t$0[1] = [1, run, execution_context];
    return 0;
   }
   function connect(bind_result, bind_rhs){
    var _s_ = 1 - caml_call2(Core[246], bind_result, bind_rhs);
    if(! _s_) return _s_;
    var bind_result$0 = squash(bind_result), indir = [3, bind_result$0];
    a:
    {
     b:
     c:
     {
      var ivar = bind_rhs;
      d:
      for(;;){
       var bind_rhs_contents = ivar[1];
       if(typeof bind_rhs_contents === "number") break c;
       switch(bind_rhs_contents[0]){
         case 2:
          break d;
         case 3:
          var ivar$0 = bind_rhs_contents[1];
          ivar[1] = indir;
          ivar = ivar$0;
          break;
         default: break b;
       }
      }
      break a;
     }
     if(1 - caml_call2(Core[246], ivar, bind_result$0)) ivar[1] = indir;
    }
    var t1 = bind_result$0[1];
    a:
    {
     b:
     {
      if(typeof t1 !== "number")
       switch(t1[0]){
         case 0:
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var last1 = t1[3], last2 = bind_rhs_contents[3];
             set_next(last1, bind_rhs_contents);
             set_next(last2, t1);
             set_prev(t1, last2);
             return set_prev(bind_rhs_contents, last1);
            case 1:
             var
              execution_context2 = bind_rhs_contents[2],
              run2 = bind_rhs_contents[1];
             add(t1, run2, execution_context2);
             return 0;
            case 2:
             var v = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             return schedule_jobs(t1, v);
          }
          break;
         case 1:
          var execution_context = t1[2], run = t1[1];
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var handler1 = add(bind_rhs_contents, run, execution_context);
             bind_result$0[1] = handler1;
             return 0;
            case 1:
             var
              execution_context2$0 = bind_rhs_contents[2],
              run2$0 = bind_rhs_contents[1],
              handler1$0 =
                create2(run, execution_context, run2$0, execution_context2$0);
             bind_result$0[1] = handler1$0;
             return 0;
            case 2:
             var v$0 = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             var _t_ = caml_call1(Async_kernel_Scheduler1[71], 0);
             return caml_call3
                     (caml_call1(Async_kernel_Scheduler1[63], _t_),
                      execution_context,
                      run,
                      v$0);
          }
          break;
         case 2: break;
         default: break b;
       }
      if(typeof bind_rhs_contents !== "number" && 3 === bind_rhs_contents[0])
       break b;
      if(typeof t1 === "number") break a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    }
    return typeof bind_rhs_contents === "number"
            ? 0
            : (bind_result$0[1] = bind_rhs_contents, 0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar0);
   var
    Async_kernel_Ivar0 =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       create_full,
       create_with_cell,
       peek,
       value_exn,
       value,
       is_empty,
       is_full,
       equal,
       connect,
       fill,
       [0, sexp_of_t, length, of_list, to_list],
       cell_of_handler,
       add_handler,
       remove_handler,
       has_handlers,
       upon$0,
       upon,
       indir,
       squash];
   runtime.caml_register_global
    (36, Async_kernel_Ivar0, cst_Async_kernel_Ivar0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred0
//# unitInfo: Requires: Async_kernel__Ivar0, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred0 = "Async_kernel__Deferred0",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    cst_Deferred_value_exn_called_ =
      "Deferred.value_exn called on undetermined deferred";
   function of_ivar(ivar){return ivar;}
   function invariant(invariant_a, t){
    return caml_call2(Async_kernel_Ivar0[2], invariant_a, t);
   }
   function sexp_of_t(sexp_of_a, t){
    return caml_call2(Async_kernel_Ivar0[1], sexp_of_a, t);
   }
   function peek(t){return caml_call1(Async_kernel_Ivar0[6], t);}
   function return$0(a){
    var ivar = caml_call1(Async_kernel_Ivar0[4], a);
    return ivar;
   }
   function is_determined(t){return caml_call1(Async_kernel_Ivar0[10], t);}
   function value_exn(t){
    return caml_call2
            (Async_kernel_Ivar0[8], t, cst_Deferred_value_exn_called_);
   }
   function upon(t, f){return caml_call2(Async_kernel_Ivar0[19], t, f);}
   function create(f){
    var result = caml_call1(Async_kernel_Ivar0[3], 0);
    caml_call1(f, result);
    return result;
   }
   function bind(t, f){
    var bind_result = caml_call1(Async_kernel_Ivar0[3], 0);
    upon
     (t,
      function(a){
       var t = caml_call1(f, a);
       return caml_call2(Async_kernel_Ivar0[12], bind_result, t);
      });
    return bind_result;
   }
   function add_handler(t, f, execution_context){
    return caml_call3(Async_kernel_Ivar0[16], t, f, execution_context);
   }
   function remove_handler(t, h){
    return caml_call2(Async_kernel_Ivar0[17], t, h);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred0);
   var
    Async_kernel_Deferred0 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       return$0,
       upon,
       bind,
       [0, Async_kernel_Ivar0[14][1]],
       add_handler,
       remove_handler];
   runtime.caml_register_global
    (13, Async_kernel_Deferred0, cst_Async_kernel_Deferred0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar0, Core__Binable, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar = "Async_kernel__Ivar",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Core_Option = global_data.Core__Option,
    Core_Binable = global_data.Core__Binable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/ivar.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Ivar0[1],
    invariant = Async_kernel_Ivar0[2],
    create = Async_kernel_Ivar0[3],
    create_full = Async_kernel_Ivar0[4],
    peek = Async_kernel_Ivar0[6],
    value_exn = Async_kernel_Ivar0[7],
    is_empty = Async_kernel_Ivar0[9],
    is_full = Async_kernel_Ivar0[10],
    equal = Async_kernel_Ivar0[11],
    fill = Async_kernel_Ivar0[13],
    has_handlers = Async_kernel_Ivar0[18],
    read = Async_kernel_Deferred0[3];
   function fill_if_empty(t, v){
    var _a_ = caml_call1(is_empty, t);
    return _a_ ? caml_call2(fill, t, v) : _a_;
   }
   function to_binable(t){return caml_call1(peek, t);}
   function of_binable(param){
    if(! param) return caml_call1(create, 0);
    var a = param[1];
    return caml_call1(create_full, a);
   }
   var
    include =
      caml_call1
       (caml_call1
         (Core_Binable[7],
          [0,
           Core_Option[1],
           Core_Option[2],
           Core_Option[3],
           Core_Option[4],
           Core_Option[5]]),
        [0, to_binable, of_binable]),
    bin_shape_t = include[1],
    bin_size_t = include[2],
    bin_write_t = include[3],
    bin_read_t = include[4],
    bin_read_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar);
   var
    Async_kernel_Ivar =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       sexp_of_t,
       invariant,
       equal,
       create,
       create_full,
       fill,
       fill_if_empty,
       is_empty,
       is_full,
       read,
       peek,
       value_exn,
       has_handlers];
   runtime.caml_register_global(15, Async_kernel_Ivar, cst_Async_kernel_Ivar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monad_sequence
//# unitInfo: Requires: Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monad_sequenc = "Async_kernel__Monad_sequence",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monad_sequenc);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/monad_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Parallel"],
    _b_ = [0, "Sequential"],
    _c_ = [0, "Max_concurrent_jobs"];
   function sexp_of_how(param){
    if(typeof param === "number") return -676829465 <= param ? _a_ : _b_;
    var v_001 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[356], v_001), 0]]];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monad_sequenc);
   var Async_kernel_Monad_sequence = [0, sexp_of_how];
   runtime.caml_register_global
    (15, Async_kernel_Monad_sequence, cst_Async_kernel_Monad_sequenc);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred1
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred0, Async_kernel__Ivar, Async_kernel__Monad_sequence, Async_kernel__Scheduler1, Base__Monad, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred1 = "Async_kernel__Deferred1",
    cst_async_kernel = "async_kernel",
    cst_src_deferred1_ml = "src/deferred1.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad,
    Async_kernel_Monad_sequence = global_data.Async_kernel__Monad_sequence;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred1);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_deferred1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Deferred0[1],
    invariant = Async_kernel_Deferred0[2],
    of_ivar = Async_kernel_Deferred0[3],
    create = Async_kernel_Deferred0[4],
    peek = Async_kernel_Deferred0[5],
    value_exn = Async_kernel_Deferred0[6],
    is_determined = Async_kernel_Deferred0[7],
    upon = Async_kernel_Deferred0[9],
    Handler = Async_kernel_Deferred0[11],
    add_handler = Async_kernel_Deferred0[12],
    remove_handler = Async_kernel_Deferred0[13];
   function never(param){
    var _u_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call1(Async_kernel_Ivar[18], _u_);
   }
   var
    of_ivar$0 = Async_kernel_Deferred0[3],
    return$0 = Async_kernel_Deferred0[8],
    upon$0 = Async_kernel_Deferred0[9],
    bind = Async_kernel_Deferred0[10],
    map =
      [0,
       -198771759,
       function(t, f){
        var result = caml_call1(Async_kernel_Ivar[12], 0);
        caml_call2
         (upon$0,
          t,
          function(a){
           var _t_ = caml_call1(f, a);
           return caml_call2(Async_kernel_Ivar[14], result, _t_);
          });
        return caml_call1(of_ivar$0, result);
       }],
    M = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = M[1],
    symbol_map = M[2],
    Monad_infix = M[3],
    bind$0 = M[4],
    map$0 = M[6],
    join = M[7],
    ignore_m = M[8],
    return$1 = Async_kernel_Deferred0[8],
    include = M[11],
    symbol_bind$0 = include[2],
    symbol_map$0 = include[3],
    return$2 = Async_kernel_Deferred0[8],
    include$0 = M[11][4],
    bind$1 = include$0[2],
    map$1 = include$0[3],
    both = include$0[4],
    Open_on_rhs = include$0[5],
    return$3 = Async_kernel_Deferred0[8],
    Let_syntax = [0, bind$1, map$1, both, Open_on_rhs, return$3],
    Let_syntax$0 = [0, symbol_bind$0, symbol_map$0, return$2, Let_syntax],
    unit = caml_call1(Let_syntax$0[3], 0);
   function both$0(t1, t2){
    return caml_call1
            (create,
             function(result){
              return caml_call2
                      (upon,
                       t1,
                       function(a1){
                        return caml_call2
                                (upon,
                                 t2,
                                 function(a2){
                                  return caml_call2
                                          (Async_kernel_Ivar[14], result, [0, a1, a2]);
                                 });
                       });
             });
   }
   var
    symbol_bind$1 = Monad_infix[1],
    symbol_map$1 = Monad_infix[2],
    Infix = [0, symbol_bind$1, symbol_map$1, upon, both$0];
   function don_t_wait_for(param){return 0;}
   function map$2(param, f2){
    var f1 = param[2], t = param[1];
    return [0, t, function(x){return caml_call1(f2, caml_call1(f1, x));}];
   }
   var Choice = [0, map$2];
   function process(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var rest = param$0[3], handler = param$0[2], t = param$0[1];
     caml_call2(remove_handler, t, handler);
     param$0 = rest;
    }
   }
   var Unregister = [0, process], _a_ = [0, cst_src_deferred1_ml, 120, 10];
   function choice(t, f){return [0, t, f];}
   function enabled(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _r_ = caml_call1(Async_kernel_Ivar[16], result);
     return _r_
             ? (caml_call1
                (Unregister[1], unregisters[1]),
               caml_call2
                (Async_kernel_Ivar[14],
                 result,
                 function(param){
                  var
                   _s_ =
                     caml_call3
                      (Core_List[10],
                       choices,
                       0,
                       function(ac, param){
                        var f = param[2], t = param[1], match = caml_call1(peek, t);
                        if(! match) return ac;
                        var v = match[1];
                        return [0, caml_call1(f, v), ac];
                       });
                  return caml_call1(Core_List[34], _s_);
                 }))
             : _r_;
    }
    var
     _q_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _q_);
    unregisters[1] =
     caml_call3
      (Core_List[10],
       choices,
       0,
       function(acc, param){
        var t = param[1];
        return [0,
                t,
                caml_call3
                 (Async_kernel_Deferred0[12], t, ready, execution_context),
                acc];
       });
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function choose_result(choices){
    var choices$0 = choices;
    for(;;){
     if(! choices$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      choices$1 = choices$0[2],
      match = choices$0[1],
      f = match[2],
      t = match[1],
      match$0 = caml_call1(peek, t);
     if(match$0){var v = match$0[1]; return caml_call1(f, v);}
     choices$0 = choices$1;
    }
   }
   function choose(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _o_ = caml_call1(Async_kernel_Ivar[16], result);
     if(! _o_) return _o_;
     caml_call1(Unregister[1], unregisters[1]);
     var _p_ = choose_result(choices);
     return caml_call2(Async_kernel_Ivar[14], result, _p_);
    }
    var
     _n_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _n_);
    unregisters[1] =
     caml_call3
      (Core_List[10],
       choices,
       0,
       function(acc, param){
        var t = param[1];
        return [0,
                t,
                caml_call3
                 (Async_kernel_Deferred0[12], t, ready, execution_context),
                acc];
       });
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function any_f(ts, f){
    return choose
            (caml_call2(Core_List[72], ts, function(t){return [0, t, f];}));
   }
   function any(ts){return any_f(ts, function(_m_){return _m_;});}
   function any_unit(ts){return any_f(ts, function(_l_){return 0;});}
   function for$0(start, to, do$0){
    function loop(i){
     if(caml_call2(Core[91], i, to)) return caml_call1(Let_syntax$0[3], 0);
     var _k_ = caml_call1(do$0, i);
     return caml_call2
             (Let_syntax$0[4][1],
              _k_,
              function(param){return loop(i + 1 | 0);});
    }
    return loop(start);
   }
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               var _j_ = caml_call1(f, state);
               return caml_call2
                       (Infix[3],
                        _j_,
                        function(param){
                         if(990972795 <= param[1]){
                          var state = param[2];
                          return loop(state);
                         }
                         var result = param[2];
                         return caml_call2(Async_kernel_Ivar[14], finished, result);
                        });
              }
              return loop(state);
             });
   }
   function forever(state, f){
    var
     _g_ = Core[159],
     _h_ =
       repeat_until_finished
        (state,
         function(state){
          var _i_ = caml_call1(f, state);
          return caml_call2
                  (Let_syntax$0[4][2],
                   _i_,
                   function(state){return [0, 990972795, state];});
         });
    return caml_call2(Infix[3], _h_, _g_);
   }
   var sexp_of_how = Async_kernel_Monad_sequence[1];
   function fold(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1], _f_ = caml_call2(f, b, x);
               return caml_call2
                       (Infix[3], _f_, function(b){return loop(xs, b);});
              }
              return loop(t, init);
             });
   }
   function seqmap(t, f){
    var
     _c_ = Core_List[34],
     _d_ =
       fold
        (t,
         0,
         function(bs, a){
          var _e_ = caml_call1(f, a);
          return caml_call2(Infix[2], _e_, function(b){return [0, b, bs];});
         });
    return caml_call2(Infix[2], _d_, _c_);
   }
   function all(ds){return seqmap(ds, function(_b_){return _b_;});}
   function all_unit(ds){return fold(ds, 0, function(param, d){return d;});}
   function ok(x){
    return caml_call2(Infix[2], x, function(x){return [0, x];});
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred1);
   var
    Async_kernel_Deferred1 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       upon,
       Handler,
       add_handler,
       remove_handler,
       never,
       M,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       map$0,
       join,
       ignore_m,
       return$1,
       Let_syntax$0,
       unit,
       both$0,
       Infix,
       don_t_wait_for,
       Choice,
       Unregister,
       choice,
       enabled,
       choose_result,
       choose,
       any_f,
       any,
       any_unit,
       for$0,
       repeat_until_finished,
       forever,
       sexp_of_how,
       fold,
       seqmap,
       all,
       all_unit,
       ok];
   runtime.caml_register_global
    (20, Async_kernel_Deferred1, cst_Async_kernel_Deferred1);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_std
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_std = "Async_kernel__Deferred_std",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_std);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_std.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = Async_kernel_Deferred1[25],
    symbol = _a_[3],
    ppx_both = _a_[4],
    include = Async_kernel_Deferred1[22],
    symbol_bind = include[1],
    symbol_map = include[2],
    return$0 = include[3],
    Let_syntax = include[4],
    choice = Async_kernel_Deferred1[29],
    choose = Async_kernel_Deferred1[32],
    don_t_wait_for = Async_kernel_Deferred1[26],
    never = Async_kernel_Deferred1[12],
    upon = Async_kernel_Deferred1[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_std);
   var
    Async_kernel_Deferred_std =
      [0,
       symbol,
       ppx_both,
       symbol_bind,
       symbol_map,
       Let_syntax,
       choice,
       choose,
       don_t_wait_for,
       never,
       return$0,
       upon];
   runtime.caml_register_global
    (12, Async_kernel_Deferred_std, cst_Async_kernel_Deferred_std);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar_filler
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar_filler = "Async_kernel__Ivar_filler",
    cst_async_kernel = "async_kernel",
    cst_src_ivar_filler_ml = "src/ivar_filler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar_filler);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar_filler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Empty"],
    _b_ = [0, "Full"],
    _c_ = [0, cst_src_ivar_filler_ml, 15, 20],
    _d_ = [0, "_"],
    _e_ = [0, cst_src_ivar_filler_ml, 12, 154, 176],
    cst_attempt_to_fill_full_ivar = "attempt to fill full ivar";
   function sexp_of_t(of_a_005, x_006){
    return caml_call2
            (Core[501],
             function(param){
              if(! param) return _b_;
              var
               arg0_002 = param[1],
               res0_003 = caml_call2(Async_kernel_Ivar[9], of_a_005, arg0_002);
              return [1, [0, _a_, [0, res0_003, 0]]];
             },
             x_006);
   }
   function invariant(param, t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             function(x_007){
              return sexp_of_t(function(param){return _d_;}, x_007);
             },
             function(param){
              var match = t[1];
              if(! match) return 0;
              var ivar = match[1];
              if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
             });
   }
   function create(param){
    var ivar = caml_call1(Async_kernel_Ivar[12], 0), t = [0, [0, ivar]];
    return [0, t, caml_call1(Async_kernel_Ivar[18], ivar)];
   }
   function is_empty(t){return t[1] ? 1 : 0;}
   function fill(t, a){
    var match = t[1];
    if(match){
     var i = match[1];
     t[1] = 0;
     return caml_call2(Async_kernel_Ivar[14], i, a);
    }
    var
     _f_ = caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_fill_full_ivar);
    return caml_call1(Core[253], _f_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar_filler);
   var
    Async_kernel_Ivar_filler =
      [0, sexp_of_t, invariant, create, is_empty, fill];
   runtime.caml_register_global
    (22, Async_kernel_Ivar_filler, cst_Async_kernel_Ivar_filler);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Tail
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Ivar, Base__Field, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Tail = "Async_kernel__Tail",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core;
   global_data.Base__Field;
   var
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Tail);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/tail.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "..."];
   function sexp_of_t(sexp_of_a, t){
    var d = t, ac = 0;
    for(;;){
     var match = caml_call1(Async_kernel_Deferred1[5], d);
     if(! match) return [1, caml_call1(Core_List[34], [0, _a_, ac])];
     var match$0 = match[1];
     if(! match$0) return [1, caml_call1(Core_List[34], ac)];
     var
      t$0 = match$0[2],
      a = match$0[1],
      ac$0 = [0, caml_call1(sexp_of_a, a), ac];
     d = t$0;
     ac = ac$0;
    }
   }
   function next(t){return t;}
   var
    Stream = [0, sexp_of_t, next],
    cst_open_tail = "<open tail>",
    cst_closed_tail = "<closed tail>",
    cst_stream_is_closed = "stream is closed";
   function sexp_of_t$0(param, t){
    var
     _d_ =
       caml_call1(Async_kernel_Ivar[16], t[1])
        ? cst_open_tail
        : cst_closed_tail;
    return [0, _d_];
   }
   function create(param){return [0, caml_call1(Async_kernel_Ivar[12], 0)];}
   function collect(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function fill_exn(t, v){
    if(! is_closed(t)) return caml_call2(Async_kernel_Ivar[14], t[1], v);
    var _c_ = caml_call1(Sexplib0_Sexp_conv[7], cst_stream_is_closed);
    return caml_call1(Core[253], _c_);
   }
   function close_exn(t){return fill_exn(t, 0);}
   function close_if_open(t){
    var _b_ = 1 - is_closed(t);
    return _b_ ? caml_call2(Async_kernel_Ivar[14], t[1], 0) : _b_;
   }
   function extend(t, v){
    var next = caml_call1(Async_kernel_Ivar[12], 0);
    fill_exn(t, [0, v, caml_call1(Async_kernel_Ivar[18], next)]);
    t[1] = next;
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Tail);
   var
    Async_kernel_Tail =
      [0,
       sexp_of_t$0,
       create,
       extend,
       close_exn,
       close_if_open,
       is_closed,
       Stream,
       collect];
   runtime.caml_register_global(23, Async_kernel_Tail, cst_Async_kernel_Tail);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Ivar_filler, Async_kernel__Monitor0, Async_kernel__Scheduler1, Async_kernel__Tail, Async_kernel_config, Base__Backtrace, Base__Exn, Base__Field, Base__Invariant, Core, Core__Bag, Core__Error, Core__Info, Core__List, Core__Or_error, Core__Result, Core__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Async_kernel_Monitor = "Async_kernel__Monitor",
    cst_Caught_by_monitor = "Caught by monitor ",
    cst_async_kernel = "async_kernel",
    cst_exn = "exn",
    cst_file = "file ",
    cst_src_monitor_ml = "src/monitor.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    job_queue = 'Called from file "job_queue.ml"',
    deferred0 = 'Called from file "deferred0.ml"',
    deferred1 = 'Called from file "deferred1.ml"',
    monitor = 'Called from file "monitor.ml"',
    import0 = 'Raised at file "import0.ml"',
    error = 'Called from file "error.ml"',
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar_filler = global_data.Async_kernel__Ivar_filler,
    Base_Exn = global_data.Base__Exn;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Result = global_data.Core__Result,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Bag = global_data.Core__Bag,
    Core_List = global_data.Core__List,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Info = global_data.Core__Info,
    Core_String = global_data.Core__String,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_monitor_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    has_seen_error = Async_kernel_Monitor0[4],
    name = Async_kernel_Monitor0[14],
    Fields = Async_kernel_Monitor0[15],
    sexp_of_t = Async_kernel_Monitor0[18],
    create_with_parent = Async_kernel_Monitor0[20],
    main = Async_kernel_Monitor0[21],
    _a_ = [0, cst_src_monitor_ml, 20, 44],
    _b_ = [0, cst_src_monitor_ml, 13, 226, 248],
    _c_ = [0, cst_src_monitor_ml, 46, 23];
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _b_,
             t,
             sexp_of_t,
             function(param){
              function f(next_error){
               if(caml_call1(Async_kernel_Ivar[16], next_error)) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              }
              var _ae_ = caml_call2(Base_Invariant[2], t, f);
              return caml_call8
                      (Fields[13],
                       function(_al_){return 0;},
                       function(_ak_){return 0;},
                       function(_aj_){return 0;},
                       _ae_,
                       function(_ai_){return 0;},
                       function(_ah_){return 0;},
                       function(_ag_){return 0;},
                       function(_af_){return 0;});
             });
   }
   function current_execution_context(param){
    var _ad_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call1(Async_kernel_Scheduler1[72], _ad_);
   }
   function current(param){
    var _ac_ = current_execution_context(0);
    return caml_call1(Async_kernel_Execution_context[4], _ac_);
   }
   function detach(t){t[8] = 0; return 0;}
   function detach_and_iter_errors(t, f){
    detach(t);
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     handler_state_ref = [0, 0];
    function run_f(exn){
     var match = handler_state_ref[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var bag_elt = match[1];
     try{var _ab_ = caml_call1(f, exn); return _ab_;}
     catch(inner_exn$0){
      var inner_exn = caml_wrap_exception(inner_exn$0);
      handler_state_ref[1] = 1;
      caml_call2(Core_Bag[26], t[5], bag_elt);
      throw caml_maybe_attach_backtrace(inner_exn, 0);
     }
    }
    handler_state_ref[1] =
     [0, caml_call2(Core_Bag[23], t[5], [0, execution_context, run_f])];
    return 0;
   }
   function detach_and_get_error_stream(t){
    detach(t);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    t[6] = [0, tail, t[6]];
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function get_next_error(t){return caml_call1(Async_kernel_Ivar[18], t[4]);}
   function detach_and_get_next_error(t){detach(t); return get_next_error(t);}
   function create(here, info, name, param){
    var parent = current(0);
    return caml_call4(create_with_parent, here, info, name, [0, parent]);
   }
   function backtrace(t){return t[2];}
   function extract_exn(t){return t[1];}
   var
    Monitor_exn =
      [248, "Async_kernel__Monitor.Monitor_exn", runtime.caml_fresh_oo_id(0)],
    _d_ =
      [0,
       [11, cst_file, [3, 0, [11, ", line LINE, characters C1-C2", 0]]],
       "file %S, line LINE, characters C1-C2"],
    _e_ =
      [0,
       [11, cst_Caught_by_monitor, [2, 0, [11, " at ", [2, 0, 0]]]],
       "Caught by monitor %s at %s"],
    _f_ = [0, "backtrace_history"],
    _g_ =
      [0, [11, "Caught by monitor at ", [2, 0, 0]], "Caught by monitor at %s"],
    _h_ = [0, [11, cst_Caught_by_monitor, [2, 0, 0]], "Caught by monitor %s"],
    _i_ =
      [0,
       [11,
        cst_file,
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11, ", characters ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]]]]]],
       "file %S, line %d, characters %d-%d"],
    cst_monitor_ml_Error = "monitor.ml.Error",
    _j_ = [0, cst_src_monitor_ml, 199, 6];
   caml_call4
    (Sexplib_Conv[70][1],
     0,
     0,
     Monitor_exn,
     function(param){
      if(param[1] !== Monitor_exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
      var
       t = param[2],
       monitor$0 = t[4],
       backtrace_history = t[3],
       backtrace = t[2],
       exn = t[1],
       s = caml_call1(Core_Info[9], monitor$0[1]),
       name = s !== cst$1 ? [0, s] : 0,
       match$0 = monitor$0[2];
      if(match$0)
       var
        here = match$0[1],
        column = here[4] - here[3] | 0,
        _X_ =
          Core[541]
           ? caml_call2(Core[257], _d_, here[1])
           : caml_call5(Core[257], _i_, here[1], here[2], column, column),
        pos = [0, _X_];
      else
       var pos = 0;
      if(pos){
       var pos$0 = pos[1];
       if(name)
        var
         name$0 = name[1],
         _Y_ = [0, caml_call3(Core[257], _e_, name$0, pos$0), 0];
       else
        var _Y_ = [0, caml_call2(Core[257], _g_, pos$0), 0];
       var monitor$1 = _Y_;
      }
      else if(name)
       var
        name$1 = name[1],
        monitor$1 = [0, caml_call2(Core[257], _h_, name$1), 0];
      else
       var monitor$1 = 0;
      if(backtrace)
       var
        backtrace$0 = backtrace[1],
        backtrace$1 = caml_call1(Base_Backtrace[4], backtrace$0);
      else
       var backtrace$1 = 0;
      a:
      {
       if(backtrace$1){
        var rest = backtrace$1[2], t1 = backtrace$1[1];
        if(caml_call2(Core_String[57], t1, import0)){
         b:
         {
          if(rest){
           var rest$0 = rest[2], t2 = rest[1];
           if(caml_call2(Core_String[57], t2, error)){
            c:
            {
             if(rest$0){
              var rest$1 = rest$0[2], t3 = rest$0[1];
              if(caml_call2(Core_String[57], t3, error)){var rest$2 = rest$1; break c;}
             }
             var rest$2 = rest$0;
            }
            var rest$3 = rest$2;
            break b;
           }
          }
          var rest$3 = rest;
         }
         var traces = rest$3;
         break a;
        }
       }
       var traces = backtrace$1;
      }
      var match = caml_call1(Core_List[34], traces);
      a:
      {
       if(match){
        var rest$4 = match[2], t1$0 = match[1];
        if(caml_call2(Core_String[57], t1$0, job_queue)){
         if(rest$4){
          var rest$5 = rest$4[2], t2$0 = rest$4[1];
          if(caml_call2(Core_String[57], t2$0, job_queue)){
           b:
           if(rest$5){
            var rest$6 = rest$5[2], t2$1 = rest$5[1];
            if
             (!
              caml_call2(Core_String[57], t2$1, deferred0)
              &&
               !
               caml_call2(Core_String[57], t2$1, deferred1)
               && ! caml_call2(Core_String[57], t2$1, monitor))
             break b;
            var _Z_ = caml_call1(Core_List[34], rest$6);
            break a;
           }
           var _Z_ = caml_call1(Core_List[34], rest$5);
           break a;
          }
         }
         var _Z_ = caml_call1(Core_List[34], rest$4);
         break a;
        }
       }
       var _Z_ = traces;
      }
      var backtrace$2 = caml_call2(Core[157], _Z_, monitor$1);
      function list_if_not_empty(l){return l ? [0, l] : 0;}
      var
       match$1 = list_if_not_empty(backtrace$2),
       ___ = list_if_not_empty(backtrace_history),
       match$2 = 0;
      if(___)
       var
        x_002 = ___[1],
        match$3 =
          [0,
           [1,
            [0, _f_, [0, caml_call2(Core[421], Base_Backtrace[1], x_002), 0]]],
           match$2];
      else
       var match$3 = match$2;
      if(match$1)
       var
        x_001 = match$1[1],
        _$_ = [0, caml_call2(Core[421], Core[471], x_001), match$3];
      else
       var _$_ = match$3;
      var sexp = [1, [0, caml_call1(Core[537], exn), _$_]];
      if(0 === sexp[0])
       var _aa_ = [0, sexp, 0];
      else
       var l = sexp[1], _aa_ = l;
      return [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_monitor_ml_Error),
               _aa_]];
     });
   var
    cst_Monitor_send_exn = "Monitor.send_exn",
    cst_Monitor_send_exn_found_lis =
      "Monitor.send_exn found listening monitor",
    _k_ = [0, 3553398],
    _l_ = [1, 0],
    _m_ = [0, cst_exn],
    cst_failed_to_set_Monitor_Expe =
      "failed to set [Monitor.Expert.try_with_log_exn]";
   function extract_exn$0(exn){
    if(exn[1] !== Monitor_exn) return exn;
    var error = exn[2];
    return error[1];
   }
   function send_exn(t, opt, exn){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 3553398;
    if(exn[1] === Monitor_exn)
     var exn$0 = exn;
    else{
     if(typeof backtrace === "number")
      var backtrace$0 = caml_call1(Base_Backtrace[6][5], exn);
     else
      var b = backtrace[2], backtrace$0 = [0, b];
     var
      backtrace_history = current_execution_context(0)[4],
      exn$0 = [0, Monitor_exn, [0, exn, backtrace$0, backtrace_history, t]];
    }
    if(Async_kernel_Debug[7])
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn,
       [0, t, exn$0],
       function(param){
        var
         arg1_004 = param[2],
         arg0_003 = param[1],
         res0_005 = caml_call1(sexp_of_t, arg0_003),
         res1_006 = caml_call1(Core[537], arg1_004);
        return [1, [0, res0_005, [0, res1_006, 0]]];
       });
    t[7] = 1;
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0), t$0 = t;
    for(;;){
     caml_call2(Async_kernel_Ivar[14], t$0[4], exn$0);
     t$0[4] = caml_call1(Async_kernel_Ivar[12], 0);
     var match = t$0[8];
     if(typeof match === "number") break;
     var parent = match[1];
     t$0 = parent;
    }
    if(match){
     var
      _V_ = caml_call1(Async_kernel_config[31][1], 0),
      _W_ = caml_call1(Async_kernel_Scheduler1[71], 0);
     return caml_call2
             (caml_call1(Async_kernel_Scheduler1[76], _W_), exn$0, _V_);
    }
    if(Async_kernel_Debug[7])
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn_found_lis,
       [0, t$0, exn$0],
       function(param){
        var
         arg1_008 = param[2],
         arg0_007 = param[1],
         res0_009 = caml_call1(sexp_of_t, arg0_007),
         res1_010 = caml_call1(Core[537], arg1_008);
        return [1, [0, res0_009, [0, res1_010, 0]]];
       });
    caml_call2
     (Core_Bag[7],
      t$0[5],
      function(param){
       var f = param[2], execution_context = param[1];
       return caml_call4
               (Async_kernel_Scheduler1[63],
                scheduler,
                execution_context,
                f,
                exn$0);
      });
    return caml_call2
            (Core_List[9],
             t$0[6],
             function(tail){
              return caml_call2(Async_kernel_Tail[3], tail, exn$0);
             });
   }
   function within_context(context, f){
    var _U_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler1[74], _U_),
             context,
             function(param){
              var match = caml_call1(Core_Result[47], f);
              if(0 === match[0]){var x = match[1]; return [0, x];}
              var exn = match[1];
              send_exn
               (caml_call1(Async_kernel_Execution_context[4], context),
                _k_,
                exn);
              return _l_;
             });
   }
   function within_gen(monitor, priority, f){
    var
     _T_ = current_execution_context(0),
     tmp_context =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _T_);
    return within_context(tmp_context, f);
   }
   function within(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return caml_call1(Async_kernel_Deferred1[12], 0);
    var d = match[1];
    return d;
   }
   function within_v(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   function within$0(monitor, priority, f){
    return 0 === within_gen(monitor, priority, f)[0] ? 0 : 0;
   }
   function schedule_with_data(monitor, priority, work, x){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     _R_ = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     _S_ =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _R_);
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, _S_, work, x);
   }
   function schedule(monitor, priority, work){
    return schedule_with_data(monitor, priority, work, 0);
   }
   function upon_work_fill_i(param){
    var i = param[2], work = param[1], _Q_ = caml_call1(work, 0);
    return caml_call2
            (Async_kernel_Deferred_std[11],
             _Q_,
             function(a){return caml_call2(Async_kernel_Ivar[14], i, a);});
   }
   function schedule$0(monitor, priority, work){
    var i = caml_call1(Async_kernel_Ivar[12], 0);
    schedule_with_data(monitor, priority, upon_work_fill_i, [0, work, i]);
    return caml_call1(Async_kernel_Ivar[18], i);
   }
   function preserve_execution_context(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    return caml_call1
            (Core[258],
             function(a){
              return caml_call4
                      (Async_kernel_Scheduler1[63],
                       scheduler,
                       execution_context,
                       f,
                       a);
             });
   }
   function preserve_execution_context$0(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    function call_and_fill(param){
     var i = param[3], a = param[2], f = param[1], _P_ = caml_call1(f, a);
     return caml_call2
             (Async_kernel_Deferred_std[11],
              _P_,
              function(r){return caml_call2(Async_kernel_Ivar[14], i, r);});
    }
    return caml_call1
            (Core[258],
             function(a){
              return caml_call1
                      (Async_kernel_Deferred1[4],
                       function(i){
                        return caml_call4
                                (Async_kernel_Scheduler1[63],
                                 scheduler,
                                 execution_context,
                                 call_and_fill,
                                 [0, f, a, i]);
                       });
             });
   }
   function stream_iter(stream, f){
    function loop(stream){
     var _O_ = caml_call1(Async_kernel_Tail[7][2], stream);
     return caml_call2
             (Async_kernel_Deferred_std[1],
              _O_,
              function(param){
               if(! param) return 0;
               var stream = param[2], v = param[1];
               loop(stream);
               return caml_call1(f, v);
              });
    }
    return loop(stream);
   }
   function create$0(here, info, name, run, f){
    var
     monitor = caml_call4(create_with_parent, here, info, name, 0),
     exns = detach_and_get_error_stream(monitor),
     ok =
       523273847 <= run
        ? schedule$0([0, monitor], 0, f)
        : within([0, monitor], 0, f);
    return [0, ok, exns];
   }
   function fill_result_and_handle_backgro
   (result_filler, result, exns, handle_exns_after_result){
    var _N_ = caml_call1(Async_kernel_Ivar_filler[4], result_filler);
    return _N_
            ? (caml_call2
               (Async_kernel_Ivar_filler[5], result_filler, result),
              caml_call1(handle_exns_after_result, exns))
            : _N_;
   }
   var
    try_with_log_exn =
      [0,
       function(exn){
        var
         _L_ = [0, [1, [0, _m_, [0, caml_call1(Base_Exn[1], exn), 0]]], 0],
         _M_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_failed_to_set_Monitor_Expe),
             _L_]];
        return caml_call1(Core[253], _M_);
       }],
    Expert = [0, try_with_log_exn],
    _n_ = [0, cst_src_monitor_ml, 422, 17],
    _o_ = [0, 3903734],
    cst_try_with_or_error = "try_with_or_error",
    cst_try_with_join_or_error = "try_with_join_or_error",
    _p_ = [0, "finally_exn"],
    _q_ = [0, cst_exn],
    cst_Async_finally = "Async finally",
    _r_ = [0, 523273847],
    _s_ = [0, 0],
    _t_ = [0, "finally"],
    cst_Monitor_protect = "Monitor.protect",
    cst_Monitor_catch_got_unexpect =
      "Monitor.catch got unexpected empty stream";
   function try_with(here, info, opt, _I_, _H_, _G_, f$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst$0;
    if(_I_)
     var sth$0 = _I_[1], do_extract_exn = sth$0;
    else
     var do_extract_exn = 0;
    if(_H_) var sth$1 = _H_[1], run = sth$1; else var run = 3903734;
    if(_G_) var sth$2 = _G_[1], rest = sth$2; else var rest = -146189108;
    var
     match = create$0(here, info, [0, name], run, f$0),
     exns = match[2],
     ok = match[1];
    if(typeof rest === "number")
     if(3804260 <= rest)
      var handle_exn = Expert[1][1];
     else
      var
       parent = current(0),
       handle_exn = function(exn){return send_exn(parent, 0, exn);};
    else
     var
      f = rest[2],
      parent$0 = current(0),
      handle_exn =
        function(exn){
         return within$0
                 ([0, parent$0],
                  0,
                  function(param){return caml_call1(f, exn);});
        };
    function handle_exns_after_result(exns){return stream_iter(exns, handle_exn);
    }
    return within
            ([0, main],
             0,
             function(param){
              if(caml_call1(Async_kernel_Deferred1[7], ok)){
               stream_iter(exns, handle_exn);
               var _J_ = [0, caml_call1(Async_kernel_Deferred1[6], ok)];
               return caml_call1(Async_kernel_Deferred_std[10], _J_);
              }
              var
               match = caml_call1(Async_kernel_Ivar_filler[3], 0),
               result = match[2],
               result_filler = match[1];
              caml_call2
               (Async_kernel_Deferred_std[11],
                ok,
                function(res){
                 return fill_result_and_handle_backgro
                         (result_filler, [0, res], exns, handle_exns_after_result);
                });
              var _K_ = caml_call1(Async_kernel_Tail[7][2], exns);
              caml_call2
               (Async_kernel_Deferred_std[11],
                _K_,
                function(param){
                 if(! param)
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _n_], 1);
                 var
                  exns = param[2],
                  exn = param[1],
                  exn$0 = do_extract_exn ? extract_exn$0(exn) : exn;
                 return fill_result_and_handle_backgro
                         (result_filler, [1, exn$0], exns, handle_exns_after_result);
                });
              return result;
             });
   }
   function try_with_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_or_error;
    var
     arg = Core_Or_error[38],
     _F_ = try_with(here, info, [0, name], extract_exn, _o_, rest, f);
    return caml_call2
            (Async_kernel_Deferred_std[4],
             _F_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function try_with_join_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_join_or_error;
    var
     _D_ = Core_Or_error[27],
     _E_ = try_with_or_error(here, info, [0, name], extract_exn, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _E_, _D_);
   }
   function protect(here, info, opt, extract_exn, run, rest, f, finally$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Monitor_protect;
    var _y_ = try_with(here, info, [0, name], extract_exn, run, rest, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _y_,
             function(r){
              var _z_ = try_with(here, info, _t_, _s_, _r_, rest, finally$0);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _z_,
                       function(fr){
                        if(0 === r[0]){
                         var r$0 = r[1];
                         if(0 === fr[0]) return r$0;
                         var e = fr[1];
                        }
                        else{
                         var exn = r[1];
                         if(0 !== fr[0]){
                          var
                           finally_exn = fr[1],
                           _A_ =
                             [0,
                              [1, [0, _p_, [0, caml_call1(Core[537], finally_exn), 0]]],
                              0],
                           _B_ =
                             [0, [1, [0, _q_, [0, caml_call1(Core[537], exn), 0]]], _A_],
                           _C_ =
                             [1,
                              [0,
                               caml_call1(Sexplib0_Sexp_conv[7], cst_Async_finally),
                               _B_]];
                          return caml_call1(Core[253], _C_);
                         }
                         var e = exn;
                        }
                        throw caml_maybe_attach_backtrace(e, 0);
                       });
             });
   }
   function handle_errors(here, info, name, f, handler){
    var
     match = create$0(here, info, name, 3903734, f),
     exns = match[2],
     ok = match[1];
    stream_iter(exns, handler);
    return ok;
   }
   function catch_stream(here, info, name, f){
    var
     exns =
       create$0
         (here,
          info,
          name,
          3903734,
          function(param){
           caml_call1(f, 0);
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          })
        [2];
    return exns;
   }
   function catch$0(here, info, name, f){
    var
     _v_ = catch_stream(here, info, name, f),
     _w_ = caml_call1(Async_kernel_Tail[7][2], _v_);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _w_,
             function(param){
              if(param){var x = param[1]; return x;}
              var
               _x_ =
                 caml_call1
                  (Sexplib0_Sexp_conv[7], cst_Monitor_catch_got_unexpect);
              return caml_call1(Core[253], _x_);
             });
   }
   function catch_error(here, info, name, f){
    var arg = Core_Error[25], _u_ = catch$0(here, info, name, f);
    return caml_call2
            (Async_kernel_Deferred_std[4],
             _u_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function parent(t){
    var match = t[8];
    if(typeof match === "number") return match ? 0 : 0;
    var parent = match[1];
    return [0, parent];
   }
   function depth(t){
    var t$0 = t, n = 0;
    for(;;){
     var match = parent(t$0);
     if(! match) return n;
     var t$1 = match[1], n$0 = n + 1 | 0;
     t$0 = t$1;
     n = n$0;
    }
   }
   var For_tests = [0, parent, depth];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor);
   var
    Async_kernel_Monitor =
      [0,
       sexp_of_t,
       invariant,
       create,
       name,
       current,
       detach,
       detach_and_iter_errors,
       detach_and_get_next_error,
       detach_and_get_error_stream,
       get_next_error,
       [0, extract_exn, backtrace],
       Monitor_exn,
       extract_exn$0,
       has_seen_error,
       send_exn,
       try_with,
       try_with_or_error,
       try_with_join_or_error,
       handle_errors,
       catch_stream,
       catch$0,
       catch_error,
       protect,
       main,
       Expert,
       [0,
        within,
        within$0,
        within_v,
        schedule$0,
        schedule,
        within_context,
        preserve_execution_context,
        preserve_execution_context$0],
       For_tests];
   runtime.caml_register_global
    (79, Async_kernel_Monitor, cst_Async_kernel_Monitor);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_stream
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_stream = "Async_kernel__Async_stream",
    cst_async_kernel = "async_kernel",
    cst_src_async_stream_ml = "src/async_stream.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_stream);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_async_stream_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Async_kernel_Tail[7],
    sexp_of_t = include[1],
    next = include[2],
    cst_Stream_first_of_empty_stre = "Stream.first of empty stream",
    _a_ = [0, cst_src_async_stream_ml, 179, 18],
    _b_ = [0, -146189108],
    _c_ = [0, 523273847];
   function first_exn(t){
    var _X_ = caml_call1(next, t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _X_,
             function(param){
              if(param){var x = param[1]; return x;}
              var
               _Y_ =
                 caml_call1
                  (Sexplib0_Sexp_conv[7], cst_Stream_first_of_empty_stre);
              return caml_call1(Core[253], _Y_);
             });
   }
   function fold(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t, b){
               var _U_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _U_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, b);
                         var t = param[2], v = param[1], _V_ = caml_call2(f, b, v);
                         return caml_call2
                                 (Async_kernel_Deferred_std[11],
                                  _V_,
                                  function(_W_){return loop(t, _W_);});
                        });
              }
              return loop(t, init);
             });
   }
   function fold$0(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop$0(counter, t, b){
               var
                _S_ = caml_call1(next, t),
                match = caml_call1(Async_kernel_Deferred1[5], _S_);
               if(! match){
                var _T_ = caml_call1(next, t);
                return caml_call2
                        (Async_kernel_Deferred_std[11],
                         _T_,
                         function(next){return loop_next(next, b);});
               }
               var next$0 = match[1];
               if(counter >= 50)
                return caml_trampoline_return(loop_next$0, [0, next$0, b]);
               var counter$0 = counter + 1 | 0;
               return loop_next$0(counter$0, next$0, b);
              }
              function loop(t, b){return caml_trampoline(loop$0(0, t, b));}
              function loop_next$0(counter, next, b){
               if(! next) return caml_call2(Async_kernel_Ivar[14], result, b);
               var t = next[2], v = next[1], _R_ = caml_call2(f, b, v);
               if(counter >= 50)
                return caml_trampoline_return(loop$0, [0, t, _R_]);
               var counter$0 = counter + 1 | 0;
               return loop$0(counter$0, t, _R_);
              }
              function loop_next(next, b){
               return caml_trampoline(loop_next$0(0, next, b));
              }
              return loop(t, init);
             });
   }
   function length(t){
    return fold$0(t, 0, function(n, param){return n + 1 | 0;});
   }
   function iter(t, f){
    return fold(t, 0, function(param, v){return caml_call1(f, v);});
   }
   function closed(t){
    var
     _Q_ = caml_call1(next, t),
     match = caml_call1(Async_kernel_Deferred1[5], _Q_);
    if(match && ! match[1])
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    return iter
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function iter$0(t, f){
    var
     _P_ =
       iter
        (t,
         function(a){
          caml_call1(f, a);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call1(Async_kernel_Deferred_std[8], _P_);
   }
   function create(f){
    var
     tail = caml_call1(Async_kernel_Tail[2], 0),
     t = caml_call1(Async_kernel_Tail[8], tail);
    caml_call1(f, tail);
    return t;
   }
   function unfold(b, f){
    return create
            (function(tail){
              function loop(b){
               var _O_ = caml_call1(f, b);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _O_,
                        function(param){
                         if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                         var match = param[1], b = match[2], a = match[1];
                         caml_call2(Async_kernel_Tail[3], tail, a);
                         return loop(b);
                        });
              }
              return loop(b);
             });
   }
   function of_list(l){
    return create
            (function(tail){
              caml_call2
               (Core_List[9],
                l,
                function(x){return caml_call2(Async_kernel_Tail[3], tail, x);});
              return caml_call1(Async_kernel_Tail[4], tail);
             });
   }
   function to_list(s){
    var
     _M_ = Core_List[34],
     _N_ =
       fold
        (s,
         0,
         function(b, a){
          return caml_call1(Async_kernel_Deferred_std[10], [0, a, b]);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _N_, _M_);
   }
   function copy_to_tail(t, tail){
    return iter
            (t,
             function(a){
              var _L_ = caml_call2(Async_kernel_Tail[3], tail, a);
              return caml_call1(Async_kernel_Deferred_std[10], _L_);
             });
   }
   function append(t1, t2){
    return create
            (function(tail){
              var _J_ = copy_to_tail(t1, tail);
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _J_,
                       function(param){
                        var _K_ = copy_to_tail(t2, tail);
                        return caml_call2
                                (Async_kernel_Deferred_std[11],
                                 _K_,
                                 function(param){
                                  return caml_call1(Async_kernel_Tail[4], tail);
                                 });
                       });
             });
   }
   function concat(t){
    return create
            (function(tail){
              var _I_ = iter(t, function(t){return copy_to_tail(t, tail);});
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _I_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function filter_deprecated(t, f){
    return create
            (function(tail){
              var
               _F_ =
                 iter
                  (t,
                   function(v){
                    var
                     _G_ = caml_call1(f, v),
                     _H_ = caml_call1(Async_kernel_Deferred_std[10], _G_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2],
                             _H_,
                             function(param){
                              return param ? caml_call2(Async_kernel_Tail[3], tail, v) : 0;
                             });
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _F_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function filter_map_deprecated(t, f){
    return create
            (function(tail){
              var
               _C_ =
                 iter
                  (t,
                   function(v){
                    var
                     _D_ = caml_call1(f, v),
                     _E_ = caml_call1(Async_kernel_Deferred_std[10], _D_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2],
                             _E_,
                             function(param){
                              if(! param) return 0;
                              var v = param[1];
                              return caml_call2(Async_kernel_Tail[3], tail, v);
                             });
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _C_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function map(t, f){
    return create
            (function(tail){
              var
               _z_ =
                 iter
                  (t,
                   function(v){
                    var
                     _A_ = caml_call1(Async_kernel_Tail[3], tail),
                     _B_ = caml_call1(f, v);
                    return caml_call2(Async_kernel_Deferred_std[4], _B_, _A_);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _z_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function map$0(t, f){
    return map
            (t,
             function(a){
              var _y_ = caml_call1(f, a);
              return caml_call1(Async_kernel_Deferred_std[10], _y_);
             });
   }
   function first_n(s, n){
    return create
            (function(tail){
              function loop(s, n){
               if(caml_call2(Core[90], n, 0))
                return caml_call1(Async_kernel_Tail[4], tail);
               var _x_ = caml_call1(next, s);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _x_,
                        function(param){
                         if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                         var t = param[2], x = param[1];
                         caml_call2(Async_kernel_Tail[3], tail, x);
                         return loop(t, n - 1 | 0);
                        });
              }
              return loop(s, n);
             });
   }
   function available_now(t){
    var t$0 = t, ac = 0;
    for(;;){
     var
      _w_ = caml_call1(next, t$0),
      match = caml_call1(Async_kernel_Deferred1[5], _w_);
     if(match){
      var match$0 = match[1];
      if(match$0){
       var t$1 = match$0[2], x = match$0[1], ac$0 = [0, x, ac];
       t$0 = t$1;
       ac = ac$0;
       continue;
      }
     }
     return [0, caml_call1(Core_List[34], ac), t$0];
    }
   }
   function split(opt, _q_, t){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    if(_q_)
     var sth$0 = _q_[1], f = sth$0;
    else
     var f = function(param){return 192584839;};
    var
     reason_for_stopping = caml_call1(Async_kernel_Ivar[12], 0),
     prefix = caml_call1(Async_kernel_Tail[2], 0);
    function finish(v){
     caml_call1(Async_kernel_Tail[4], prefix);
     return caml_call2(Async_kernel_Ivar[14], reason_for_stopping, v);
    }
    function loop(t){
     var
      _s_ = caml_call1(next, t),
      _t_ =
        [0,
         caml_call2
          (Async_kernel_Deferred_std[6],
           _s_,
           function(o){return [0, 870035731, o];}),
         0],
      _u_ =
        [0,
         caml_call2
          (Async_kernel_Deferred_std[6],
           stop,
           function(param){return 280164845;}),
         _t_],
      _v_ = caml_call1(Async_kernel_Deferred_std[7], _u_);
     return caml_call2
             (Async_kernel_Deferred_std[1],
              _v_,
              function(param){
               if(typeof param === "number") return finish([0, 280164845, t]);
               var o = param[2];
               if(! o) return finish(1144100);
               var t$0 = o[2], a = o[1], match = caml_call1(f, a);
               if(typeof match === "number"){
                caml_call2(Async_kernel_Tail[3], prefix, a);
                return loop(t$0);
               }
               var b = match[2];
               return finish([0, 398750242, [0, b, t$0]]);
              });
    }
    loop(t);
    var _r_ = caml_call1(Async_kernel_Ivar[18], reason_for_stopping);
    return [0, caml_call1(Async_kernel_Tail[8], prefix), _r_];
   }
   function find(t, f){
    var
     found =
       split
         (0,
          [0,
           function(a){
            return caml_call1(f, a) ? [0, 398750242, a] : 192584839;
           }],
          t)
        [2];
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             found,
             function(x){
              if(typeof x !== "number" && 398750242 > x[1])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              return x;
             });
   }
   function ungroup(t){
    return create
            (function(tail){
              var
               _p_ =
                 iter
                  (t,
                   function(l){
                    caml_call2
                     (Core_List[9],
                      l,
                      function(x){
                       return caml_call2(Async_kernel_Tail[3], tail, x);
                      });
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _p_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function interleave(ts){
    return create
            (function(tail){
              var num_open = [0, 1];
              function close(param){
               num_open[1] = num_open[1] - 1 | 0;
               var _o_ = caml_call2(Core[90], num_open[1], 0);
               return _o_ ? caml_call1(Async_kernel_Tail[4], tail) : _o_;
              }
              var
               outer_closed =
                 iter
                  (ts,
                   function(t){
                    num_open[1] = num_open[1] + 1 | 0;
                    var _n_ = copy_to_tail(t, tail);
                    caml_call2(Async_kernel_Deferred_std[11], _n_, close);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11], outer_closed, close);
             });
   }
   function take_until(t, d){
    return create
            (function(tail){
              function loop(t){
               var
                _j_ = caml_call1(next, t),
                _k_ =
                  [0,
                   caml_call2
                    (Async_kernel_Deferred_std[6],
                     _j_,
                     function(z){return [0, 870035731, z];}),
                   0],
                _l_ =
                  [0,
                   caml_call2
                    (Async_kernel_Deferred_std[6],
                     d,
                     function(param){return 926227490;}),
                   _k_],
                _m_ = caml_call1(Async_kernel_Deferred_std[7], _l_);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _m_,
                        function(param){
                         if(typeof param !== "number"){
                          var match = param[2];
                          if(match){
                           var t = match[2], x = match[1];
                           caml_call2(Async_kernel_Tail[3], tail, x);
                           return loop(t);
                          }
                         }
                         return caml_call1(Async_kernel_Tail[4], tail);
                        });
              }
              return loop(t);
             });
   }
   function iter_durably(t, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t){
               var _g_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _g_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         var
                          t = param[2],
                          x = param[1],
                          _h_ =
                            caml_call7
                             (Async_kernel_Monitor[16],
                              0,
                              0,
                              0,
                              0,
                              _c_,
                              _b_,
                              function(param){return caml_call1(f, x);});
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _h_,
                                  function(z){
                                   loop(t);
                                   if(0 === z[0]) return 0;
                                   var e = z[1], _i_ = caml_call1(Async_kernel_Monitor[5], 0);
                                   return caml_call3(Async_kernel_Monitor[15], _i_, 0, e);
                                  });
                        });
              }
              return loop(t);
             });
   }
   function iter_durably_report_end(t, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t){
               var _f_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _f_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         var t = param[2], x = param[1];
                         loop(t);
                         return caml_call1(f, x);
                        });
              }
              return loop(t);
             });
   }
   function iter_durably$0(t, f){
    var _e_ = iter_durably_report_end(t, f);
    return caml_call1(Async_kernel_Deferred_std[8], _e_);
   }
   function of_fun(f){
    return unfold
            (0,
             function(param){
              var _d_ = caml_call1(f, 0);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(a){return [0, [0, a, 0]];});
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_stream);
   var
    Async_kernel_Async_stream =
      [0,
       sexp_of_t,
       create,
       next,
       first_exn,
       of_list,
       to_list,
       of_fun,
       copy_to_tail,
       append,
       concat,
       available_now,
       filter_deprecated,
       filter_map_deprecated,
       fold,
       fold$0,
       iter,
       closed,
       iter$0,
       take_until,
       iter_durably,
       iter_durably$0,
       iter_durably_report_end,
       length,
       map,
       map$0,
       first_n,
       unfold,
       split,
       find,
       ungroup,
       interleave];
   runtime.caml_register_global
    (24, Async_kernel_Async_stream, cst_Async_kernel_Async_stream);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_source_i = "Async_kernel__Time_source_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/time_source_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source_i);
   var Async_kernel_Time_source_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Time_source_intf, cst_Async_kernel_Time_source_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Bvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Async_kernel__Scheduler1, Async_kernel__Types, Base__Field, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Bvar = "Async_kernel__Bvar",
    cst_async_kernel = "async_kernel",
    cst_has_any_waiters = "has_any_waiters",
    cst_ivar = "ivar",
    cst_src_bvar_ml = "src/bvar.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Types = global_data.Async_kernel__Types,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Bvar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_bvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function ivar(r){return r[2];}
   function set_ivar(r, v){r[2] = v; return 0;}
   function has_any_waiters(r){return r[1];}
   function set_has_any_waiters(r, v){r[1] = v; return 0;}
   var
    ivar$0 =
      [0,
       function(param){return 0;},
       cst_ivar,
       [0, set_ivar],
       ivar,
       function(r, v){return [0, r[1], v];}],
    has_any_waiters$0 =
      [0,
       function(param){return 0;},
       cst_has_any_waiters,
       [0, set_has_any_waiters],
       has_any_waiters,
       function(r, v){return [0, v, r[2]];}],
    _a_ = [0, cst_ivar],
    _b_ = [0, cst_has_any_waiters],
    _c_ = [0, cst_src_bvar_ml, 23, 11],
    _d_ = [0, cst_src_bvar_ml, 19, 47],
    _e_ = [0, "_"],
    _f_ = [0, cst_src_bvar_ml, 14, 287, 309],
    _g_ = [0, cst_has_any_waiters];
   function invariant(invariant_a, param, t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return caml_call4
            (Base_Invariant[1],
             _f_,
             repr,
             function(x_007){
              function of_a_001(param){return _e_;}
              var
               has_any_waiters_003 = x_007[1],
               ivar_005 = x_007[2],
               arg_006 = caml_call2(Async_kernel_Ivar[9], of_a_001, ivar_005),
               bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
               arg_004 = caml_call1(Core[305], has_any_waiters_003),
               bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002];
              return [1, bnds_002$0];
             },
             function(param){
              function check(f){
               return caml_call2(Base_Invariant[2], repr, f);
              }
              var
               ivar_fun =
                 check
                  (function(ivar){
                    caml_call2(Async_kernel_Ivar[10], invariant_a, ivar);
                    if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _c_], 1);
                   }),
               has_any_waiters_fun =
                 check
                  (function(has_any_waiters){
                    var _k_ = caml_call1(Async_kernel_Ivar[21], repr[2]);
                    if(! _k_) return _k_;
                    if(has_any_waiters) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _d_], 1);
                   });
              caml_call1(has_any_waiters_fun, has_any_waiters$0);
              return caml_call1(ivar_fun, ivar$0);
             });
   }
   function sexp_of_t(param, _j_, t){
    var has_any_waiters = caml_call1(Async_kernel_Types[10][2], t)[1];
    return [1, [0, _g_, [0, caml_call1(Core[305], has_any_waiters), 0]]];
   }
   var include = Async_kernel_Scheduler1[5], create = include[1];
   function broadcast(t, a){
    var
     repr = caml_call1(Async_kernel_Types[10][2], t),
     _h_ = repr[1],
     _i_ =
       _h_
        ? (repr
           [1]
          = 0,
          caml_call2(Async_kernel_Ivar[14], repr[2], a),
          repr[2] = caml_call1(Async_kernel_Ivar[12], 0),
          0)
        : _h_;
    return _i_;
   }
   function wait(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    repr[1] = 1;
    return caml_call1(Async_kernel_Ivar[18], repr[2]);
   }
   function has_any_waiters$1(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return repr[1];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Bvar);
   var
    Async_kernel_Bvar =
      [0, sexp_of_t, invariant, create, wait, broadcast, has_any_waiters$1];
   runtime.caml_register_global(28, Async_kernel_Bvar, cst_Async_kernel_Bvar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Base__Field, Base__Invariant, Core, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Time_source = "Async_kernel__Time_source",
    cst_Happened = "Happened",
    cst_Ok = "Ok",
    cst_Previously_aborted = "Previously_aborted",
    cst_Previously_happened = "Previously_happened",
    cst$0 = "_",
    cst_alarm = "alarm",
    cst_async_kernel = "async_kernel",
    cst_fired = "fired",
    cst_num_fires_to_skip = "num_fires_to_skip",
    cst_scheduled_at = "scheduled_at",
    cst_src_time_source_ml = "src/time_source.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/time_source.ml:294:30",
    cst = "",
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_time_source_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    debug = Async_kernel_Debug[1],
    upon = Async_kernel_Deferred1[8],
    choose = Async_kernel_Deferred1[32],
    choice = Async_kernel_Deferred1[29],
    include = Async_kernel_Synchronous_time_[4],
    Job_or_event = include[2],
    invariant_with_jobs = include[20],
    invariant = include[21],
    cst_wall_clock = "<wall_clock>",
    _a_ = [0, cst$0],
    _b_ = [0, "events"],
    _c_ = [0, "is_wall_clock"];
   function sexp_of_t(param, _aB_){
    var events = _aB_[4], is_wall_clock = _aB_[8];
    if(is_wall_clock)
     return caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock);
    var
     _aC_ =
       [0,
        [1,
         [0,
          _b_,
          [0,
           caml_call2(Timing_wheel[2], function(param){return _a_;}, events),
           0]]],
        0];
    return [1,
            [0,
             [1, [0, _c_, [0, caml_call1(Core[305], is_wall_clock), 0]]],
             _aC_]];
   }
   function sexp_of_t$0(x_002){return sexp_of_t(Core[202], x_002);}
   var Read_write = [0, sexp_of_t$0, invariant, invariant_with_jobs];
   function sexp_of_t$1(x_003){return sexp_of_t(Core[171], x_003);}
   function read_only(t){return t;}
   var
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function is_wall_clock(t){return t[8];}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function id(t){return t[1];}
   function now(t){
    return t[8]
            ? caml_call1(Async_kernel_Time_ns[50], 0)
            : timing_wheel_now(t);
   }
   var
    send_exn = [0, Async_kernel_Monitor[15]],
    _d_ = [0, cst_src_time_source_ml, 228, 5],
    _e_ = [0, cst_Aborted],
    _f_ = [0, cst_Happened];
   function advance_directly(t, to){
    return caml_call3(Async_kernel_Synchronous_time_[27], t, to, send_exn);
   }
   function advance_directly_by(t, by){
    var _aA_ = now(t);
    return advance_directly
            (t, caml_call2(Async_kernel_Time_ns[113], _aA_, by));
   }
   function fire_past_alarms(t){
    return caml_call2(Async_kernel_Synchronous_time_[28], t, send_exn);
   }
   function yield$0(t){
    var _az_ = caml_call1(Async_kernel_Scheduler1[15], t[9]);
    return caml_call1(Async_kernel_Bvar[4], _az_);
   }
   function advance_by_alarms(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = caml_call1(Timing_wheel[35], t[4]);
      if(! match) return finish(0);
      var min_alarm_time_in_min_interval = match[1];
      if
       (caml_call2
         (Async_kernel_Time_ns[94], min_alarm_time_in_min_interval, to))
       return finish(0);
      advance_directly(t, min_alarm_time_in_min_interval);
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran))
       return caml_call2
               (Async_kernel_Deferred_std[5][1],
                queued_alarms_ran,
                function(param){return walk_alarms(0);});
     }
    }
    fire_past_alarms(t);
    var _ay_ = run_queued_alarms(0);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _ay_,
             function(param){return walk_alarms(0);});
   }
   function advance_by_max_alarms_in_each_(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = next_alarm_fires_at(t);
      if(! match) return finish(0);
      var next_alarm_fires_at$0 = match[1];
      if(caml_call2(Async_kernel_Time_ns[94], next_alarm_fires_at$0, to))
       return finish(0);
      advance_directly(t, caml_call1(Timing_wheel[36], t[4]));
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran))
       return caml_call2
               (Async_kernel_Deferred_std[5][1],
                queued_alarms_ran,
                function(param){return walk_alarms(0);});
     }
    }
    fire_past_alarms(t);
    var _ax_ = run_queued_alarms(0);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _ax_,
             function(param){return walk_alarms(0);});
   }
   function advance_by_alarms_by(wait_for, t, by){
    var _aw_ = now(t);
    return advance_by_alarms
            (wait_for, t, caml_call2(Async_kernel_Time_ns[113], _aw_, by));
   }
   function span_to_time(t, span){
    var _av_ = now(t);
    return caml_call2(Async_kernel_Time_ns[113], _av_, span);
   }
   function run_at_internal(t, time, f$0, a){
    var
     execution_context = caml_call1(Async_kernel_Scheduler1[72], t[9]),
     _au_ = caml_call1(Timing_wheel[11], t[4]);
    if(! caml_call2(Async_kernel_Time_ns[97], time, _au_)){
     caml_call4(Async_kernel_Scheduler1[63], t[9], execution_context, f$0, a);
     return caml_call1(Timing_wheel[5][2], 0);
    }
    var
     _as_ =
       caml_call4
        (Async_kernel_Scheduler1[75], t[9], execution_context, f$0, a),
     _at_ = caml_call1(Job_or_event[2], _as_),
     alarm = caml_call3(Timing_wheel[25], t[4], time, _at_),
     match = t[9][23];
    if(match){var f = match[1]; caml_call1(f, time);}
    return alarm;
   }
   function run_at(t, time, f, a){run_at_internal(t, time, f, a); return 0;}
   function run_after(t, span, f, a){
    return run_at(t, span_to_time(t, span), f, a);
   }
   function fill(result){return caml_call2(Async_kernel_Ivar[14], result, 0);}
   function at(t, time){
    var _ar_ = caml_call1(Timing_wheel[11], t[4]);
    if(caml_call2(Async_kernel_Time_ns[95], time, _ar_))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var result = caml_call1(Async_kernel_Ivar[12], 0);
    run_at_internal(t, time, fill, result);
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function after(t, span){return at(t, span_to_time(t, span));}
   function remove_alarm(t, alarm){
    var
     job_or_event = caml_call2(Timing_wheel[5][5], t[4], alarm),
     k = caml_call1(Job_or_event[5][1], job_or_event),
     match = caml_call2(Job_or_event[5][2], k, job_or_event);
    if(! k) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    caml_call2(Async_kernel_Scheduler1[62], t[9], match);
    return caml_call2(Timing_wheel[28], t[4], alarm);
   }
   function sexp_of_t$2(of_a_008, of_h_009, param){
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_008, arg0_010);
     return [1, [0, _e_, [0, res0_011, 0]]];
    }
    var arg0_012 = param[1], res0_013 = caml_call1(of_h_009, arg0_012);
    return [1, [0, _f_, [0, res0_013, 0]]];
   }
   var Fired = [0, sexp_of_t$2];
   function scheduled_at(r){return r[5];}
   function set_scheduled_at(r, v){r[5] = v; return 0;}
   function num_fires_to_skip(r){return r[4];}
   function set_num_fires_to_skip(r, v){r[4] = v; return 0;}
   function fired(r){return r[3];}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   var
    scheduled_at$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_at,
       [0, set_scheduled_at],
       scheduled_at,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}],
    num_fires_to_skip$0 =
      [0,
       function(param){return 0;},
       cst_num_fires_to_skip,
       [0, set_num_fires_to_skip],
       num_fires_to_skip,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}],
    fired$0 =
      [0,
       function(param){return 0;},
       cst_fired,
       0,
       fired,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}],
    alarm$0 =
      [0,
       function(param){return 0;},
       cst_alarm,
       [0, set_alarm],
       alarm,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}],
    _g_ = [0, "time_source"],
    _h_ = [0, cst_scheduled_at],
    _i_ = [0, cst_num_fires_to_skip],
    _j_ = [0, cst_fired],
    _k_ = [0, "fire"],
    _l_ = [0, cst_alarm],
    _m_ = [0, cst_src_time_source_ml, 289, 43],
    _n_ = [0, cst_src_time_source_ml, 278, 18],
    _o_ = [0, cst_src_time_source_ml, 280, 18],
    _p_ = [0, cst$0],
    _q_ = [0, cst$0],
    _r_ = [0, cst_src_time_source_ml, 271, 9504, 9528],
    _s_ = [0, cst_Aborted],
    _t_ = [0, cst_Happened],
    _u_ = [0, "Scheduled_at"];
   function sexp_of_t$3(of_a_016, of_h_017, param){
    var
     alarm_019 = param[1],
     fired_023 = param[3],
     num_fires_to_skip_025 = param[4],
     scheduled_at_027 = param[5],
     time_source_029 = param[6],
     arg_030 = caml_call1(Async_kernel_Synchronous_time_[5], time_source_029),
     bnds_018 = [0, [1, [0, _g_, [0, arg_030, 0]]], 0],
     arg_028 = caml_call1(Async_kernel_Time_ns[92], scheduled_at_027),
     bnds_018$0 = [0, [1, [0, _h_, [0, arg_028, 0]]], bnds_018],
     arg_026 = caml_call1(Core[356], num_fires_to_skip_025),
     bnds_018$1 = [0, [1, [0, _i_, [0, arg_026, 0]]], bnds_018$0],
     _ap_ = caml_call2(Fired[1], of_a_016, of_h_017),
     arg_024 = caml_call2(Async_kernel_Ivar[9], _ap_, fired_023),
     bnds_018$2 = [0, [1, [0, _j_, [0, arg_024, 0]]], bnds_018$1],
     arg_022 = caml_call1(Sexplib0_Sexp_conv[24], function(_aq_){return 0;}),
     bnds_018$3 = [0, [1, [0, _k_, [0, arg_022, 0]]], bnds_018$2],
     arg_020 = caml_call2(Timing_wheel[5][1], Job_or_event[6], alarm_019),
     bnds_018$4 = [0, [1, [0, _l_, [0, arg_020, 0]]], bnds_018$3];
    return [1, bnds_018$4];
   }
   function sexp_of_t_unit(x_031){
    return sexp_of_t$3(Core[518], Core[518], x_031);
   }
   function fired$1(t){return caml_call1(Async_kernel_Ivar[18], t[3]);}
   function invariant$0(invariant_a, invariant_h, t){
    return caml_call4
            (Base_Invariant[1],
             _r_,
             t,
             function(x_032){
              return sexp_of_t$3
                      (function(param){return _q_;},
                       function(param){return _p_;},
                       x_032);
             },
             function(param){
              var events = t[6][4];
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               scheduled_at_fun =
                 check
                  (function(scheduled_at){
                    var _ao_ = caml_call2(Timing_wheel[27], events, t[1]);
                    if(! _ao_) return _ao_;
                    var
                     expect = caml_call2(Timing_wheel[5][3], events, t[1]),
                     sexpifier = Async_kernel_Time_ns[92];
                    function comparator(a_033, b_034){
                     return caml_call2(Async_kernel_Time_ns[101], a_033, b_034);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             scheduled_at);
                   }),
               num_fires_to_skip_fun =
                 check
                  (function(num_fires_to_skip){
                    if(caml_call2(Async_kernel_Import[1], num_fires_to_skip, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _m_], 1);
                   }),
               fired_fun =
                 check
                  (function(fired){
                    var
                     _an_ = caml_call1(Async_kernel_Ivar[18], fired),
                     match = caml_call1(Async_kernel_Deferred1[5], _an_);
                    if(! match) return 0;
                    var match$0 = match[1];
                    if(0 === match$0[0]){
                     var a = match$0[1];
                     return caml_call1(invariant_a, a);
                    }
                    var h = match$0[1];
                    return caml_call1(invariant_h, h);
                   }),
               alarm_fun =
                 check
                  (function(alarm){
                    if(caml_call1(Async_kernel_Ivar[17], t[3])){
                     if(caml_call2(Timing_wheel[27], events, alarm))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _n_], 1);
                     return 0;
                    }
                    var _al_ = caml_call2(Timing_wheel[27], events, alarm);
                    if(! _al_) return _al_;
                    var _am_ = caml_call2(Timing_wheel[5][5], events, alarm);
                    if(caml_call1(Job_or_event[4], _am_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _o_], 1);
                   });
              caml_call1(alarm_fun, alarm$0);
              caml_call1(fired_fun, fired$0);
              caml_call1(num_fires_to_skip_fun, num_fires_to_skip$0);
              caml_call1(scheduled_at_fun, scheduled_at$0);
              return 0;
             });
   }
   function sexp_of_t$4(of_a_035, of_h_036, param){
    switch(param[0]){
      case 0:
       var arg0_037 = param[1], res0_038 = caml_call1(of_a_035, arg0_037);
       return [1, [0, _s_, [0, res0_038, 0]]];
      case 1:
       var arg0_039 = param[1], res0_040 = caml_call1(of_h_036, arg0_039);
       return [1, [0, _t_, [0, res0_040, 0]]];
      default:
       var
        arg0_041 = param[1],
        res0_042 = caml_call1(Async_kernel_Time_ns[92], arg0_041);
       return [1, [0, _u_, [0, res0_042, 0]]];
    }
   }
   var
    Status = [0, sexp_of_t$4],
    _v_ = [0, cst_Ok],
    _w_ = [0, cst_Previously_aborted],
    _x_ = [0, cst_Previously_happened];
   function status(t){
    var
     _ak_ = caml_call1(Async_kernel_Ivar[18], t[3]),
     match = caml_call1(Async_kernel_Deferred1[5], _ak_);
    if(! match) return [2, t[5]];
    var match$0 = match[1];
    if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
    var h = match$0[1];
    return [1, h];
   }
   function sexp_of_t$5(of_a_045, of_h_046, param){
    if(typeof param === "number") return _v_;
    if(0 === param[0]){
     var arg0_047 = param[1], res0_048 = caml_call1(of_a_045, arg0_047);
     return [1, [0, _w_, [0, res0_048, 0]]];
    }
    var arg0_049 = param[1], res0_050 = caml_call1(of_h_046, arg0_049);
    return [1, [0, _x_, [0, res0_050, 0]]];
   }
   var
    Abort_result = [0, sexp_of_t$5],
    _y_ = [0, cst$0],
    _z_ = [0, cst$0],
    cst_Time_source_Event_abort = "Time_source.Event.abort",
    cst_Clock_Event_abort_exn_fail =
      "Clock.Event.abort_exn failed to abort event that previously aborted",
    cst_Clock_Event_abort_exn_fail$0 =
      "Clock.Event.abort_exn failed to abort event that previously happened",
    _A_ = [0, cst_Ok],
    _B_ = [0, cst_Previously_aborted],
    _C_ = [0, cst_Previously_happened];
   function abort(t, a){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_abort,
       t,
       function(x_053){
        return sexp_of_t$3
                (function(param){return _z_;},
                 function(param){return _y_;},
                 x_053);
       });
    var
     _aj_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aj_);
    if(! match){
     caml_call2(Async_kernel_Ivar[14], t[3], [0, a]);
     var alarm = t[1], t$0 = t[6];
     if(caml_call2(Timing_wheel[27], t$0[4], alarm)) remove_alarm(t$0, alarm);
     return 0;
    }
    var match$0 = match[1];
    if(0 === match$0[0]){var a$0 = match$0[1]; return [0, a$0];}
    var h = match$0[1];
    return [1, h];
   }
   function abort_exn(t, a){
    var match = abort(t, a);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var
      _ah_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail);
     return caml_call1(Core[253], _ah_);
    }
    var
     _ai_ =
       caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail$0);
    return caml_call1(Core[253], _ai_);
   }
   function abort_if_possible(t, a){abort(t, a); return 0;}
   function schedule(t){t[1] = run_at_internal(t[6], t[5], t[2], 0); return;}
   function sexp_of_t$6(of_a_054, of_h_055, param){
    if(typeof param === "number") return _A_;
    if(0 === param[0]){
     var arg0_056 = param[1], res0_057 = caml_call1(of_a_054, arg0_056);
     return [1, [0, _B_, [0, res0_057, 0]]];
    }
    var arg0_058 = param[1], res0_059 = caml_call1(of_h_055, arg0_058);
    return [1, [0, _C_, [0, res0_059, 0]]];
   }
   var
    Reschedule_result = [0, sexp_of_t$6],
    _D_ = [0, cst$0],
    _E_ = [0, cst$0],
    cst_Time_source_Event_reschedu = "Time_source.Event.reschedule_at",
    cst_Time_source_Event_run_at = "Time_source.Event.run_at";
   function reschedule_at(t, at){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_reschedu,
       [0, t, at],
       function(param){
        var
         arg1_063 = param[2],
         arg0_062 = param[1],
         res0_064 =
           sexp_of_t$3
            (function(param){return _E_;},
             function(param){return _D_;},
             arg0_062),
         res1_065 = caml_call1(Async_kernel_Time_ns[92], arg1_063);
        return [1, [0, res0_064, [0, res1_065, 0]]];
       });
    var
     _af_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _af_);
    if(match){
     var match$0 = match[1];
     if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
     var h = match$0[1];
     return [1, h];
    }
    var
     events = t[6][4],
     is_in_timing_wheel = caml_call2(Timing_wheel[27], events, t[1]),
     _ag_ = caml_call1(Timing_wheel[11], events),
     am_trying_to_reschedule_in_the =
       caml_call2(Async_kernel_Time_ns[97], at, _ag_);
    t[5] = at;
    if(am_trying_to_reschedule_in_the)
     if(is_in_timing_wheel)
      caml_call3(Timing_wheel[29], events, t[1], at);
     else{t[4] = t[4] + 1 | 0; schedule(t);}
    else if(is_in_timing_wheel){
     caml_call1(t[6][7], t[1]);
     caml_call2(Timing_wheel[28], events, t[1]);
    }
    return 0;
   }
   function reschedule_after(t, span){
    return reschedule_at(t, span_to_time(t[6], span));
   }
   function run_at$0(time_source, scheduled_at, f, z){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_run_at,
       scheduled_at,
       Async_kernel_Time_ns[92]);
    var
     _aa_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        caml_call1(Timing_wheel[5][2], 0),
        function(_ae_){return 0;},
        _aa_,
        0,
        scheduled_at,
        time_source];
    function fire(param){
     var _ab_ = caml_call1(Async_kernel_Ivar[16], t[3]);
     if(_ab_){
      if(caml_call2(Async_kernel_Import[4], t[4], 0)){t[4] = t[4] - 1 | 0; return 0;}
      var
       result = caml_call1(f, z),
       _ac_ = caml_call1(Async_kernel_Ivar[16], t[3]);
      if(_ac_) return caml_call2(Async_kernel_Ivar[14], t[3], [1, result]);
      var _ad_ = _ac_;
     }
     else
      var _ad_ = _ab_;
     return _ad_;
    }
    t[2] = fire;
    schedule(t);
    return t;
   }
   function at$0(time_source, time){
    return run_at$0(time_source, time, function(_$_){return 0;}, 0);
   }
   function run_after$0(time_source, span, f, a){
    return run_at$0(time_source, span_to_time(time_source, span), f, a);
   }
   function after$0(time_source, span){
    return at$0(time_source, span_to_time(time_source, span));
   }
   function at_times(opt, t, next_time){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    function loop(param){
     var
      ___ =
        [0,
         caml_call2
          (choice,
           at(t, caml_call1(next_time, 0)),
           function(param){return 936767357;}),
         0];
     return caml_call2
             (upon,
              caml_call1
               (choose,
                [0,
                 caml_call2(choice, stop, function(param){return 926227490;}),
                 ___]),
              function(param){
               return 936767357 <= param
                       ? (caml_call2(Async_kernel_Tail[3], tail, 0), loop(0))
                       : caml_call1(Async_kernel_Tail[4], tail);
              });
    }
    loop(0);
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function at_varying_intervals(stop, t, compute_span){
    return at_times
            (stop,
             t,
             function(param){
              var _Y_ = caml_call1(compute_span, 0), _Z_ = now(t);
              return caml_call2(Async_kernel_Time_ns[113], _Z_, _Y_);
             });
   }
   function at_intervals(start, stop, t, interval){
    if(start) var x = start[1], start$0 = x; else var start$0 = now(t);
    return at_times
            (stop,
             t,
             function(param){
              var _X_ = now(t);
              return caml_call5
                      (Async_kernel_Time_ns[65], 0, start$0, _X_, interval, 0);
             });
   }
   var
    _F_ = [0, -146189108],
    _G_ = [0, 3903734],
    _H_ = [0, "span"],
    cst_Time_source_every_got_nonp = "Time_source.every got nonpositive span",
    _I_ = [0, 1],
    cst_Time_source_with_timeout_b =
      "Time_source.with_timeout bug: both completed and timed out",
    cst_Time_source_with_timeout_b$0 =
      "Time_source.with_timeout bug: should only abort once";
   function run_repeatedly(opt, stop, _R_, _Q_, time_source, f, continue$0){
    if(opt)
     var sth = opt[1], start = sth;
    else
     var start = caml_call1(Async_kernel_Deferred_std[10], 0);
    if(_R_)
     var sth$0 = _R_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 1;
    if(_Q_)
     var sth$1 = _Q_[1], finished = sth$1;
    else
     var finished = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (upon,
             start,
             function(param){
              var alarm = [0, caml_call1(Timing_wheel[5][2], 0)];
              if(stop){
               var stop$0 = stop[1];
               caml_call2
                (upon,
                 stop$0,
                 function(param){
                  var
                   _W_ = caml_call2(Timing_wheel[27], time_source[4], alarm[1]);
                  return _W_
                          ? (remove_alarm
                             (time_source, alarm[1]),
                            caml_call2(Async_kernel_Ivar[15], finished, 0))
                          : _W_;
                 });
               var stop$1 = stop$0;
              }
              else
               var stop$1 = caml_call1(Async_kernel_Deferred1[12], 0);
              function run_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               if(continue_on_error)
                return caml_call2
                        (upon,
                         caml_call7
                          (Async_kernel_Monitor[16], 0, 0, 0, 0, _G_, _F_, f),
                         continue_try_with);
               var d = caml_call1(f, 0);
               return caml_call1(Async_kernel_Deferred1[7], d)
                       ? continue_f(0)
                       : caml_call2(upon, d, continue_f);
              }
              function continue_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               var _U_ = 0;
               if(typeof continue$0 === "number")
                var _V_ = caml_call1(Timing_wheel[11], time_source[4]);
               else if(0 === continue$0[0])
                var
                 span = continue$0[1],
                 _V_ = span_to_time(time_source, span);
               else
                var
                 interval = continue$0[2],
                 base = continue$0[1],
                 _T_ = now(time_source),
                 _V_ =
                   caml_call5
                    (Async_kernel_Time_ns[65], 0, base, _T_, interval, 0);
               alarm[1] = run_at_internal(time_source, _V_, run_f, _U_);
               return 0;
              }
              function continue_try_with(or_error){
               if(0 !== or_error[0]){
                var
                 error = or_error[1],
                 _S_ = caml_call1(Async_kernel_Monitor[5], 0);
                caml_call3(Async_kernel_Monitor[15], _S_, 0, error);
               }
               return continue_f(0);
              }
              return run_f(0);
             });
   }
   function every(start, stop, continue_on_error, finished, t, span, f){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _O_ =
        [0, [1, [0, _H_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _P_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_every_got_nonp),
          _O_]];
     caml_call1(Core[253], _P_);
    }
    return run_repeatedly
            (start, stop, continue_on_error, finished, t, f, [0, span]);
   }
   function every$0(start, stop, continue_on_error, t, span, f){
    return every
            (start,
             stop,
             continue_on_error,
             0,
             t,
             span,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function run_at_intervals(start, stop, continue_on_error, t, interval, f){
    var now$0 = now(t);
    if(start)
     var
      start$0 = start[1],
      start$1 =
        [0,
         at
          (t,
           caml_call5
            (Async_kernel_Time_ns[65], _I_, start$0, now$0, interval, 0))],
      base = start$0;
    else
     var start$1 = 0, base = now$0;
    return run_repeatedly
            (start$1, stop, continue_on_error, 0, t, f, [1, base, interval]);
   }
   function run_at_intervals$0(start, stop, continue_on_error, t, interval, f){
    return run_at_intervals
            (start,
             stop,
             continue_on_error,
             t,
             interval,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function with_timeout(t, span, d){
    var
     timeout = after$0(t, span),
     _L_ =
       [0,
        caml_call2
         (choice,
          fired$1(timeout),
          function(param){
           if(0 !== param[0]) return 642269825;
           var
            _N_ =
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b);
           return caml_call1(Core[253], _N_);
          }),
        0];
    return caml_call1
            (choose,
             [0,
              caml_call2
               (choice,
                d,
                function(v){
                 var match = abort(timeout, 0);
                 a:
                 if(typeof match !== "number" && 0 === match[0]){
                  var
                   _M_ =
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b$0);
                  caml_call1(Core[253], _M_);
                  break a;
                 }
                 return [0, 1025039613, v];
                }),
              _L_]);
   }
   function duration_of(t, f){
    var start = now(t), _J_ = caml_call1(f, 0);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _J_,
             function(result){
              var
               _K_ = now(t),
               duration = caml_call2(Async_kernel_Time_ns[57], _K_, start);
              return [0, result, duration];
             });
   }
   function of_synchronous(t){return t;}
   function to_synchronous(t){return t;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source);
   var
    Async_kernel_Time_source =
      [0,
       [0, sexp_of_t],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t$1,
       id,
       invariant,
       invariant_with_jobs,
       read_only,
       create,
       wall_clock,
       alarm_precision,
       is_wall_clock,
       next_alarm_fires_at,
       now,
       timing_wheel_now,
       advance_directly,
       advance_directly,
       advance_directly_by,
       advance_directly_by,
       fire_past_alarms,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_by_alarms_by,
       [0, 0],
       run_repeatedly,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       duration_of,
       [0,
        sexp_of_t$3,
        sexp_of_t_unit,
        invariant$0,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        Abort_result,
        abort,
        abort_exn,
        abort_if_possible,
        Fired,
        fired$1,
        Reschedule_result,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       of_synchronous,
       to_synchronous];
   runtime.caml_register_global
    (83, Async_kernel_Time_source, cst_Async_kernel_Time_source);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Stack_or_counter
//# unitInfo: Requires: Base, Base__Stack, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Stack_or_coun = "Async_kernel__Stack_or_counter",
    cst_async_kernel = "async_kernel",
    cst_length = "length";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Stack = global_data.Base__Stack,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Stack_or_coun);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/stack_or_counter.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Stack"],
    _b_ = [0, cst_length],
    _c_ = [0, "Counter"],
    _d_ = [0, cst_length],
    cst_Stack_or_counter_create_co =
      "[Stack_or_counter.create_counter] got negative length",
    cst_Stack_or_counter_pop_exn_o =
      "[Stack_or_counter.pop_exn] of empty stack";
   function sexp_of_t(of_a_002, param){
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_004 = caml_call2(Base_Stack[2], of_a_002, arg0_003);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    var
     length_006 = param[1],
     arg_007 = caml_call1(Base[119], length_006),
     bnds_005 = [0, [1, [0, _b_, [0, arg_007, 0]]], 0];
    return [1, [0, _c_, bnds_005]];
   }
   function of_list(list){return [0, caml_call1(Base_Stack[22], list)];}
   function create_counter(length){
    if(length < 0){
     var
      _i_ = [0, [1, [0, _d_, [0, caml_call1(Base[119], length), 0]]], 0],
      _j_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_create_co),
          _i_]];
     caml_call1(Base[202], _j_);
    }
    return [1, length];
   }
   function length(t){
    if(0 !== t[0]) return t[1];
    var s = t[1];
    return caml_call1(Base_Stack[6], s);
   }
   function clear(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[30], s);}
    t[1] = 0;
    return 0;
   }
   function push(t, a){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[25], s, a);}
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function pop_exn(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[27], s);}
    if(0 === t[1]){
     var
      _h_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_pop_exn_o);
     caml_call1(Base[202], _h_);
    }
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function iter(t, f){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[8], s, f);}
    var _f_ = t[1], _e_ = 1;
    if(_f_ >= 1){
     var for$0 = _e_;
     for(;;){
      caml_call1(f, 0);
      var _g_ = for$0 + 1 | 0;
      if(_f_ === for$0) break;
      for$0 = _g_;
     }
    }
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Stack_or_coun);
   var
    Async_kernel_Stack_or_counter =
      [0,
       sexp_of_t,
       clear,
       create_counter,
       iter,
       length,
       of_list,
       pop_exn,
       push];
   runtime.caml_register_global
    (20, Async_kernel_Stack_or_counter, cst_Async_kernel_Stack_or_coun);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttle
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Stack_or_counter, Base__Field, Core, Core__Int, Core__List, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Throttle = "Async_kernel__Throttle",
    cst_Ok = "Ok",
    cst_Raised = "Raised",
    cst_async_kernel = "async_kernel",
    cst_capacity_available = "capacity_available",
    cst_cleaned = "cleaned",
    cst_job_resources_not_in_use = "job_resources_not_in_use",
    cst_jobs_waiting_to_start = "jobs_waiting_to_start",
    cst_max_concurrent_jobs = "max_concurrent_jobs",
    cst_num_jobs_running = "num_jobs_running",
    cst_num_resources_not_cleaned = "num_resources_not_cleaned",
    cst_src_throttle_ml = "src/throttle.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Stack_or_counter = global_data.Async_kernel__Stack_or_counter,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttle);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_throttle_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, cst_Aborted], _b_ = [0, cst_Ok], _c_ = [0, cst_Raised];
   function sexp_of_outcome(of_a_001, param){
    if(typeof param === "number") return _a_;
    if(17724 <= param[1]){
     var v_002 = param[2];
     return [1, [0, _b_, [0, caml_call1(of_a_001, v_002), 0]]];
    }
    var v_003 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[537], v_003), 0]]];
   }
   function abort(t){
    return caml_call2(Async_kernel_Ivar[14], t[1], 774323088);
   }
   function cleaned(r){return r[10];}
   function num_resources_not_cleaned(r){return r[9];}
   function set_num_resources_not_cleaned(r, v){r[9] = v; return 0;}
   function is_dead(r){return r[7];}
   function capacity_available(r){return r[6];}
   function set_capacity_available(r, v){r[6] = v; return 0;}
   function num_jobs_running(r){return r[5];}
   function set_num_jobs_running(r, v){r[5] = v; return 0;}
   function jobs_waiting_to_start(r){return r[4];}
   function job_resources_not_in_use(r){return r[3];}
   function max_concurrent_jobs(r){return r[2];}
   var
    cleaned$0 =
      [0,
       function(param){return 0;},
       cst_cleaned,
       0,
       cleaned,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v];
       }],
    num_resources_not_cleaned$0 =
      [0,
       function(param){return 0;},
       cst_num_resources_not_cleaned,
       [0, set_num_resources_not_cleaned],
       num_resources_not_cleaned,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v, r[10]];
       }],
    capacity_available$0 =
      [0,
       function(param){return 0;},
       cst_capacity_available,
       [0, set_capacity_available],
       capacity_available,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9], r[10]];
       }],
    num_jobs_running$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_running,
       [0, set_num_jobs_running],
       num_jobs_running,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9], r[10]];
       }],
    jobs_waiting_to_start$0 =
      [0,
       function(param){return 0;},
       cst_jobs_waiting_to_start,
       0,
       jobs_waiting_to_start,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    job_resources_not_in_use$0 =
      [0,
       function(param){return 0;},
       cst_job_resources_not_in_use,
       0,
       job_resources_not_in_use,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    max_concurrent_jobs$0 =
      [0,
       function(param){return 0;},
       cst_max_concurrent_jobs,
       0,
       max_concurrent_jobs,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    _d_ = [0, cst_Aborted],
    _e_ = [0, cst_Ok],
    _f_ = [0, cst_Raised],
    _g_ = [0, "outcome"],
    _h_ = [0, "Abort"],
    _i_ = [0, "Start"],
    _j_ = [0, "start"],
    _n_ = [0, cst_cleaned],
    _o_ = [0, cst_num_resources_not_cleaned],
    _p_ = [0, "cleans"],
    _q_ = [0, "is_dead"],
    _r_ = [0, cst_capacity_available],
    _s_ = [0, cst_num_jobs_running],
    _t_ = [0, cst_jobs_waiting_to_start],
    _u_ = [0, cst_job_resources_not_in_use],
    _v_ = [0, cst_max_concurrent_jobs],
    _w_ = [0, "continue_on_error"],
    _x_ = [0, "_"],
    _y_ = [0, "t"],
    _z_ = [0, "exn"],
    cst_Throttle_invariant_failed = "Throttle.invariant failed",
    _A_ = [0, cst_src_throttle_ml, 133, 40],
    _B_ = [0, cst_src_throttle_ml, 130, 69],
    _C_ = [0, cst_src_throttle_ml, 129, 11],
    _D_ = [0, cst_src_throttle_ml, 128, 11],
    _E_ = [0, cst_src_throttle_ml, 123, 26],
    _F_ = [0, cst_src_throttle_ml, 119, 16],
    _G_ = [0, cst_src_throttle_ml, 117, 11],
    _H_ = [0, cst_src_throttle_ml, 116, 11],
    _I_ = [0, cst_src_throttle_ml, 113, 29],
    _J_ = [0, cst_src_throttle_ml, 108, 11],
    _K_ = [0, cst_src_throttle_ml, 104, 43];
   function sexp_of_t(of_a_011, param){
    var
     jobs_waiting_to_start_019 = param[4],
     job_resources_not_in_use_017 = param[3],
     max_concurrent_jobs_015 = param[2],
     continue_on_error_013 = param[1],
     num_jobs_running_021 = param[5],
     capacity_available_023 = param[6],
     is_dead_025 = param[7],
     cleans_027 = param[8],
     num_resources_not_cleaned_029 = param[9],
     cleaned_031 = param[10],
     arg_032 = caml_call2(Async_kernel_Ivar[9], Core[518], cleaned_031),
     bnds_012 = [0, [1, [0, _n_, [0, arg_032, 0]]], 0],
     arg_030 = caml_call1(Core[356], num_resources_not_cleaned_029),
     bnds_012$0 = [0, [1, [0, _o_, [0, arg_030, 0]]], bnds_012],
     arg_028 =
       caml_call2
        (Core[421],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_at_){return 0;});
         },
         cleans_027),
     bnds_012$1 = [0, [1, [0, _p_, [0, arg_028, 0]]], bnds_012$0],
     arg_026 = caml_call1(Core[305], is_dead_025),
     bnds_012$2 = [0, [1, [0, _q_, [0, arg_026, 0]]], bnds_012$1],
     _as_ = caml_call1(Async_kernel_Ivar[9], Core[518]),
     arg_024 = caml_call2(Core[454], _as_, capacity_available_023),
     bnds_012$3 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_012$2],
     arg_022 = caml_call1(Core[356], num_jobs_running_021),
     bnds_012$4 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_012$3],
     arg_020 =
       caml_call2
        (Core_Queue[11],
         function(param){
          var
           outcome_009 = param[2],
           start_006 = param[1],
           arg_010 =
             caml_call2
              (Async_kernel_Deferred1[1],
               function(param){
                return -216426513 === param ? _d_ : 17724 <= param ? _e_ : _f_;
               },
               outcome_009),
           bnds_005 = [0, [1, [0, _g_, [0, arg_010, 0]]], 0],
           arg_007 =
             caml_call2
              (Async_kernel_Ivar[9],
               function(param){
                if(typeof param === "number") return _h_;
                var v_008 = param[2];
                return [1, [0, _i_, [0, caml_call1(of_a_011, v_008), 0]]];
               },
               start_006),
           bnds_005$0 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_005];
          return [1, bnds_005$0];
         },
         jobs_waiting_to_start_019),
     bnds_012$5 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_012$4],
     arg_018 =
       caml_call2
        (Async_kernel_Stack_or_counter[1],
         of_a_011,
         job_resources_not_in_use_017),
     bnds_012$6 = [0, [1, [0, _u_, [0, arg_018, 0]]], bnds_012$5],
     arg_016 = caml_call1(Core[356], max_concurrent_jobs_015),
     bnds_012$7 = [0, [1, [0, _v_, [0, arg_016, 0]]], bnds_012$6],
     arg_014 = caml_call1(Core[305], continue_on_error_013),
     bnds_012$8 = [0, [1, [0, _w_, [0, arg_014, 0]]], bnds_012$7];
    return [1, bnds_012$8];
   }
   function invariant(invariant_a, x_033){
    try{
     var
      max_concurrent_jobs =
        caml_call2(Base_Field[3], max_concurrent_jobs$0, x_033);
     if(! caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
     var
      job_resources_not_in_use =
        caml_call2(Base_Field[3], job_resources_not_in_use$0, x_033);
     caml_call2
      (Async_kernel_Stack_or_counter[4],
       job_resources_not_in_use,
       invariant_a);
     var
      _ap_ = x_033[7] ? 0 : x_033[2] - x_033[5] | 0,
      _aq_ =
        caml_call1(Async_kernel_Stack_or_counter[5], job_resources_not_in_use);
     if(! caml_call2(Async_kernel_Import[3], _aq_, _ap_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
     var
      jobs_waiting_to_start =
        caml_call2(Base_Field[3], jobs_waiting_to_start$0, x_033);
     if(x_033[7] && ! caml_call1(Core_Queue[15], jobs_waiting_to_start))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
     var
      num_jobs_running = caml_call2(Base_Field[3], num_jobs_running$0, x_033);
     if(! caml_call2(Async_kernel_Import[1], num_jobs_running, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     if(! caml_call2(Async_kernel_Import[2], num_jobs_running, x_033[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
     if
      (caml_call2(Async_kernel_Import[5], num_jobs_running, x_033[2])
       && ! caml_call1(Core_Queue[15], x_033[4]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
     var param = caml_call2(Base_Field[3], capacity_available$0, x_033);
     if(param){
      var ivar = param[1];
      if(! caml_call1(Async_kernel_Ivar[16], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
     }
     var
      num_resources_not_cleaned =
        caml_call2(Base_Field[3], num_resources_not_cleaned$0, x_033);
     if(! caml_call2(Async_kernel_Import[1], num_resources_not_cleaned, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
     if
      (!
       caml_call2(Async_kernel_Import[2], num_resources_not_cleaned, x_033[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
     if
      (caml_call2(Async_kernel_Import[5], num_resources_not_cleaned, x_033[2])
       && ! x_033[7])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     var
      cleaned = caml_call2(Base_Field[3], cleaned$0, x_033),
      _ao_ = caml_call1(Async_kernel_Ivar[17], cleaned);
     if(_ao_){
      if(! caml_call2(Async_kernel_Import[3], x_033[9], 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
      var _ar_ = 0;
     }
     else
      var _ar_ = _ao_;
     return _ar_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _al_ =
        [0,
         [1, [0, _y_, [0, sexp_of_t(function(param){return _x_;}, x_033), 0]]],
         0],
      _am_ = [0, [1, [0, _z_, [0, caml_call1(Core[537], exn), 0]]], _al_],
      _an_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_invariant_failed),
          _am_]];
     return caml_call1(Core[253], _an_);
    }
   }
   function sexp_of_t$0(of_a_034, of_kind_035, x_036){return sexp_of_t(of_a_034, x_036);
   }
   function invariant$0(invariant_a, param, t){return invariant(invariant_a, t);
   }
   var
    T2 = [0, sexp_of_t$0, invariant$0],
    _m_ = [0, cst_src_throttle_ml, 58, 18],
    _L_ = [0, cst_src_throttle_ml, 173, 2],
    _M_ = [0, cst_src_throttle_ml, 175, 2],
    _N_ = [0, cst_src_throttle_ml, 174, 2];
   function num_jobs_waiting_to_start(t){
    return caml_call1(Core_Queue[14], t[4]);
   }
   function clean_resource(t, a){
    var
     _ai_ =
       caml_call2(Core_List[72], t[8], function(f){return caml_call1(f, a);}),
     _aj_ = caml_call1(Async_kernel_Deferred1[43], _ai_);
    return caml_call2
            (Async_kernel_Deferred_std[1],
             _aj_,
             function(param){
              t[9] = t[9] - 1 | 0;
              var _ak_ = caml_call2(Async_kernel_Import[3], t[9], 0);
              return _ak_ ? caml_call2(Async_kernel_Ivar[14], t[10], 0) : _ak_;
             });
   }
   function kill(t){
    var _ah_ = 1 - t[7];
    return _ah_
            ? (t
               [7]
              = 1,
              caml_call2(Core_Queue[16], t[4], abort),
              caml_call1(Core_Queue[47], t[4]),
              caml_call2
               (Async_kernel_Stack_or_counter[4],
                t[3],
                function(a){return clean_resource(t, a);}),
              caml_call1(Async_kernel_Stack_or_counter[2], t[3]))
            : _ah_;
   }
   function at_kill(t, f){
    var
     _ag_ = caml_call1(Async_kernel_Monitor[26][8], f),
     f$0 = caml_call1(Core[259], _ag_);
    t[8] = [0, f$0, t[8]];
    return 0;
   }
   function cleaned$1(t){return caml_call1(Async_kernel_Ivar[18], t[10]);}
   function start_job(t){
    if(t[7]) throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    if(! caml_call2(Async_kernel_Import[5], t[5], t[2]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
    if(caml_call1(Core_Queue[15], t[4]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    var job = caml_call1(Core_Queue[44], t[4]);
    t[5] = t[5] + 1 | 0;
    var job_resource = caml_call1(Async_kernel_Stack_or_counter[7], t[3]);
    caml_call2(Async_kernel_Ivar[14], job[1], [0, 389604418, job_resource]);
    var
     _af_ =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         job[2],
         function(x){
          if(-216426513 === x)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          return x;
         });
    return caml_call2
            (Async_kernel_Deferred_std[1],
             _af_,
             function(res){
              t[5] = t[5] - 1 | 0;
              if(17724 > res && 1 - t[1]) kill(t);
              if(t[7]) return clean_resource(t, job_resource);
              caml_call2(Async_kernel_Stack_or_counter[8], t[3], job_resource);
              if(! caml_call1(Core_Queue[15], t[4])) return start_job(t);
              var match = t[6];
              if(! match) return 0;
              var ivar = match[1];
              caml_call2(Async_kernel_Ivar[14], ivar, 0);
              t[6] = 0;
              return 0;
             });
   }
   function create_internal(continue_on_error, job_resources){
    var
     max_concurrent_jobs =
       caml_call1(Async_kernel_Stack_or_counter[5], job_resources),
     _ae_ = caml_call1(Async_kernel_Ivar[12], 0);
    return [0,
            continue_on_error,
            max_concurrent_jobs,
            job_resources,
            caml_call2(Core_Queue[61], 0, 0),
            0,
            0,
            0,
            0,
            max_concurrent_jobs,
            _ae_];
   }
   function create_with(continue_on_error, job_resources){
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[6], job_resources));
   }
   function create(opt, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    return create_with(continue_on_error, [0, a, 0]);
   }
   var
    Sequencer = [0, sexp_of_t, create],
    _k_ = [0, 3804260],
    _l_ = [0, 523273847],
    _O_ = [0, cst_max_concurrent_jobs],
    cst_Throttle_create_requires_p =
      "Throttle.create requires positive max_concurrent_jobs, but got",
    cst_throttle_aborted_job = "throttle aborted job",
    cst_enqueue_exclusive_was_call =
      "[enqueue_exclusive] was called with a very large value of [max_concurrent_jobs]. This doesn't work.",
    _P_ = [0, cst_src_throttle_ml, 279, 2];
   function create$0(continue_on_error, max_concurrent_jobs){
    if(caml_call2(Async_kernel_Import[2], max_concurrent_jobs, 0)){
     var
      _ac_ =
        [0,
         [1, [0, _O_, [0, caml_call1(Core[356], max_concurrent_jobs), 0]]],
         0],
      _ad_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_create_requires_p),
          _ac_]];
     caml_call1(Core[253], _ad_);
    }
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[3], max_concurrent_jobs));
   }
   function enqueue(t, work){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _aa_ = caml_call1(Async_kernel_Ivar[18], start),
     result =
       caml_call2
        (Async_kernel_Deferred_std[5][1],
         _aa_,
         function(param){
          if(typeof param === "number")
           return caml_call1(Async_kernel_Deferred_std[10], -216426513);
          var
           a = param[2],
           _ab_ =
             caml_call7
              (Async_kernel_Monitor[16],
               0,
               0,
               0,
               0,
               _l_,
               _k_,
               function(param){return caml_call1(work, a);});
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _ab_,
                   function(param){
                    if(0 === param[0]){var a = param[1]; return [0, 17724, a];}
                    var exn = param[1];
                    return [0, -387916264, exn];
                   });
         }),
     outcome =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         result,
         function(param){
          return typeof param === "number"
                  ? -216426513
                  : 17724 <= param[1] ? 17724 : -387916264;
         }),
     internal_job = [0, start, outcome];
    if(t[7])
     abort(internal_job);
    else{
     caml_call2(Core_Queue[41], t[4], internal_job);
     if(caml_call2(Async_kernel_Import[5], t[5], t[2])) start_job(t);
    }
    return result;
   }
   function handle_enqueue_result(result){
    if(typeof result === "number"){
     var _$_ = caml_call1(Sexplib0_Sexp_conv[7], cst_throttle_aborted_job);
     return caml_call1(Core[253], _$_);
    }
    if(17724 <= result[1]){var a = result[2]; return a;}
    var exn = result[2];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function enqueue$0(t, f){
    var ___ = enqueue(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], ___, handle_enqueue_result);
   }
   function enqueue_exclusive(t, f){
    var n = t[2];
    if(caml_call2(Core_Int[84], n, 1000000)){
     var
      _U_ = caml_call1(Sexplib0_Sexp_conv[7], cst_enqueue_exclusive_was_call);
     caml_call1(Core[253], _U_);
    }
    var done = caml_call1(Async_kernel_Ivar[12], 0);
    if(! caml_call2(Async_kernel_Import[4], n, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    function f_placeholder(slot){
     return caml_call1(Async_kernel_Ivar[18], done);
    }
    var _W_ = n - 1 | 0, _V_ = 1;
    if(_W_ >= 1){
     var for$0 = _V_;
     for(;;){
      var _Y_ = enqueue$0(t, f_placeholder);
      caml_call1(Async_kernel_Deferred_std[8], _Y_);
      var _Z_ = for$0 + 1 | 0;
      if(_W_ === for$0) break;
      for$0 = _Z_;
     }
    }
    var _X_ = enqueue(t, function(slot){return caml_call1(f, 0);});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _X_,
             function(result){
              caml_call2(Async_kernel_Ivar[14], done, 0);
              return handle_enqueue_result(result);
             });
   }
   function monad_sequence_how(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a){
         return enqueue$0(t, function(param){return caml_call1(f, a);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function monad_sequence_how2(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a1, a2){
         return enqueue$0(t, function(param){return caml_call2(f, a1, a2);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function prior_jobs_done(t){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(all_dummy_jobs_running){
              var dummy_jobs_running = [0, 0], _R_ = t[2], _Q_ = 1;
              if(_R_ >= 1){
               var for$0 = _Q_;
               for(;;){
                var
                 _S_ =
                   enqueue$0
                    (t,
                     function(param){
                      dummy_jobs_running[1]++;
                      if
                       (caml_call2
                         (Async_kernel_Import[3], dummy_jobs_running[1], t[2]))
                       caml_call2(Async_kernel_Ivar[14], all_dummy_jobs_running, 0);
                      return caml_call1
                              (Async_kernel_Ivar[18], all_dummy_jobs_running);
                     });
                caml_call1(Async_kernel_Deferred_std[8], _S_);
                var _T_ = for$0 + 1 | 0;
                if(_R_ === for$0) break;
                for$0 = _T_;
               }
              }
              return 0;
             });
   }
   function capacity_available$1(t){
    if(caml_call2(Async_kernel_Import[5], t[5], t[2]))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var match = t[6];
    if(! match)
     return caml_call1
             (Async_kernel_Deferred1[4],
              function(ivar){t[6] = [0, ivar]; return 0;});
    var ivar = match[1];
    return caml_call1(Async_kernel_Ivar[18], ivar);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttle);
   var
    Async_kernel_Throttle =
      [0,
       T2,
       sexp_of_t,
       invariant,
       create$0,
       create_with,
       sexp_of_outcome,
       enqueue,
       enqueue$0,
       enqueue_exclusive,
       monad_sequence_how,
       monad_sequence_how2,
       prior_jobs_done,
       max_concurrent_jobs,
       num_jobs_running,
       num_jobs_waiting_to_start,
       capacity_available$1,
       kill,
       is_dead,
       at_kill,
       cleaned$1,
       Sequencer];
   runtime.caml_register_global
    (81, Async_kernel_Throttle, cst_Async_kernel_Throttle);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/synchronous_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    default_timing_wheel_config = Async_kernel_Synchronous_time_[3],
    T1 = Async_kernel_Synchronous_time_[4],
    sexp_of_t = Async_kernel_Synchronous_time_[5],
    invariant = Async_kernel_Synchronous_time_[6],
    invariant_with_jobs = Async_kernel_Synchronous_time_[7],
    Read_write = Async_kernel_Synchronous_time_[8],
    id = Async_kernel_Synchronous_time_[9],
    is_wall_clock = Async_kernel_Synchronous_time_[10],
    length = Async_kernel_Synchronous_time_[11],
    max_allowed_alarm_time = Async_kernel_Synchronous_time_[12],
    read_only = Async_kernel_Synchronous_time_[13],
    alarm_precision = Async_kernel_Synchronous_time_[15],
    next_alarm_fires_at = Async_kernel_Synchronous_time_[16],
    next_alarm_runs_at = Async_kernel_Synchronous_time_[17],
    now = Async_kernel_Synchronous_time_[18],
    timing_wheel_now = Async_kernel_Synchronous_time_[19],
    Event = Async_kernel_Synchronous_time_[22],
    run_after = Async_kernel_Synchronous_time_[23],
    run_at = Async_kernel_Synchronous_time_[24],
    run_at_intervals = Async_kernel_Synchronous_time_[25],
    advance_by_alarms = Async_kernel_Synchronous_time_[32],
    advance_by_max_alarms_in_each_ = Async_kernel_Synchronous_time_[33],
    advance_directly = Async_kernel_Synchronous_time_[34],
    duration_of = Async_kernel_Synchronous_time_[35],
    max_alarm_time_in_min_timing_w = Async_kernel_Synchronous_time_[36],
    has_events_to_run = Async_kernel_Synchronous_time_[37],
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    _a_ = Event[3],
    Async_kernel_Synchronous_time_$0 =
      [0,
       [0, T1[17]],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t,
       invariant_with_jobs,
       invariant,
       id,
       read_only,
       create,
       alarm_precision,
       is_wall_clock,
       now,
       timing_wheel_now,
       run_at,
       run_after,
       run_at_intervals,
       max_allowed_alarm_time,
       duration_of,
       [0,
        Event[17],
        Event[18],
        [0,
         _a_[8],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[9],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[7]],
        Event[25],
        Event[26],
        Event[28],
        Event[29],
        Event[30],
        Event[32],
        Event[31],
        Event[33],
        Event[35],
        Event[36],
        Event[37],
        Event[38],
        Event[39],
        Event[21]],
       default_timing_wheel_config,
       wall_clock,
       length,
       next_alarm_runs_at,
       next_alarm_fires_at,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (14, Async_kernel_Synchronous_time_$0, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Job_queue, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Backtrace, Core, Core__Deque, Core__Error, Core__Gc, Core__Hashtbl, Core__Heap_block, Core__List, Core__Option, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler = "Async_kernel__Scheduler",
    cst_async_kernel = "async_kernel",
    cst_src_scheduler_ml = "src/scheduler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Backtrace = global_data.Base__Backtrace,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Core_Error = global_data.Core__Error,
    Core_Option = global_data.Core__Option,
    Core_List = global_data.Core__List,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Core_Heap_block = global_data.Core__Heap_block,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Core_Gc = global_data.Core__Gc,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    start_cycle = Async_kernel_Scheduler1[77],
    create_job = Async_kernel_Scheduler1[75],
    with_execution_context = Async_kernel_Scheduler1[74],
    with_execution_context1 = Async_kernel_Scheduler1[73],
    current_execution_context = Async_kernel_Scheduler1[72],
    check_access = Async_kernel_Scheduler1[70],
    t_ref = Async_kernel_Scheduler1[69],
    set_check_access = Async_kernel_Scheduler1[68],
    is_dead = Async_kernel_Scheduler1[67],
    enqueue_job = Async_kernel_Scheduler1[64],
    enqueue = Async_kernel_Scheduler1[63],
    free_job = Async_kernel_Scheduler1[62],
    invariant = Async_kernel_Scheduler1[61],
    last_cycle_num_jobs = Async_kernel_Scheduler1[58],
    num_jobs_run = Async_kernel_Scheduler1[57],
    num_pending_jobs = Async_kernel_Scheduler1[56],
    uncaught_exn = Async_kernel_Scheduler1[55],
    uncaught_exn_unwrapped = Async_kernel_Scheduler1[54],
    sexp_of_t = Async_kernel_Scheduler1[53],
    last_cycle_time = Async_kernel_Scheduler1[29],
    Very_low_priority_worker = Async_kernel_Scheduler1[6],
    debug = Async_kernel_Scheduler1[3],
    set_execution_context = Async_kernel_Scheduler1[2],
    events = Async_kernel_Scheduler1[1],
    t = Async_kernel_Scheduler1[71],
    include = Async_kernel_Monitor[26],
    within = include[1],
    within$0 = include[2],
    within_v = include[3],
    schedule = include[4],
    schedule$0 = include[5],
    within_context = include[6],
    preserve_execution_context = include[7],
    preserve_execution_context$0 = include[8];
   function find_local(key){
    var _V_ = caml_call1(current_execution_context, caml_call1(t, 0));
    return caml_call2(Async_kernel_Execution_context[10], _V_, key);
   }
   function with_local(key, value, f){
    var
     t$0 = caml_call1(t, 0),
     _U_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call3(Async_kernel_Execution_context[11], _U_, key, value);
    return caml_call3(with_execution_context, t$0, execution_context, f);
   }
   var
    main_execution_context = caml_call1(t, 0)[6],
    cst_Scheduler_remove_single_cy =
      "Scheduler.remove_single_cycle_hook called with a hook that isn't registered",
    cst_Attempted_to_remove_a_cycl =
      "Attempted to remove a cycle start hook which has already been removed.",
    cst_Attempted_to_remove_a_cycl$0 =
      "Attempted to remove a cycle end hook which has already been removed.",
    cst_enqueueing_finalizer = "enqueueing finalizer",
    cst_adding_finalizer = "adding finalizer",
    cst_enqueueing_finalizer_using =
      "enqueueing finalizer (using 'last' semantic)",
    cst_adding_finalizer_using_las =
      "adding finalizer (using 'last' semantic)";
   function can_run_a_job(t){
    var
     _S_ = caml_call1(num_pending_jobs, t),
     _T_ = caml_call2(Async_kernel_Import[4], _S_, 0);
    return _T_ ? _T_ : caml_call1(Async_kernel_Bvar[6], t[24]);
   }
   function has_upcoming_event(t){
    var _R_ = caml_call1(events, t);
    return 1 - caml_call1(Timing_wheel[13], _R_);
   }
   function next_upcoming_event(t){
    var _Q_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[38], _Q_);
   }
   function next_upcoming_event_exn(t){
    var _P_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[39], _P_);
   }
   function event_precision(t){
    var _O_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[10], _O_);
   }
   function cycle_start(t){return t[10];}
   function run_every_cycle_start(t, f){t[12] = [0, f, t[12]]; return 0;}
   function run_every_cycle_end(t, f){t[14] = [0, f, t[14]]; return 0;}
   function add_every_cycle_start_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[13], handle, f);
    run_every_cycle_start(t, f);
    return handle;
   }
   function add_every_cycle_end_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[15], handle, f);
    run_every_cycle_end(t, f);
    return handle;
   }
   function remove_single_cycle_hook(lst, f){
    var
     f$0 = caml_call1(Core[246], f),
     _M_ =
       caml_call2
        (Core_List[130], lst, function(x){return 1 - caml_call1(f$0, x);}),
     match = _M_[2],
     l = _M_[1];
    if(match)
     var r = match[2], match$0 = [0, caml_call2(Core[157], l, r)];
    else
     var match$0 = 0;
    if(match$0){var lst$0 = match$0[1]; return lst$0;}
    var
     _N_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_remove_single_cy);
    return caml_call1(Core[253], _N_);
   }
   function remove_every_cycle_start_hook_(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[13], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl);
    var f = match[1];
    t[12] = remove_single_cycle_hook(t[12], f);
    return 0;
   }
   function remove_every_cycle_end_hook_ex(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[15], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl$0);
    var f = match[1];
    t[14] = remove_single_cycle_hook(t[14], f);
    return 0;
   }
   function map_cycle_times(t, f){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        var _L_ = caml_call1(f, t[16]);
                        return caml_call2(Async_kernel_Tail[3], tail, _L_);
                       });
             });
   }
   function long_cycles(t, at_least){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        var _K_ = caml_call2(Core_Time_ns[1][15], t[16], at_least);
                        return _K_
                                ? caml_call2(Async_kernel_Tail[3], tail, t[16])
                                : _K_;
                       });
             });
   }
   function cycle_num_jobs(t){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        return caml_call2(Async_kernel_Tail[3], tail, t[17]);
                       });
             });
   }
   function cycle_count(t){return t[9];}
   function set_max_num_jobs_per_priority_(t, int$0){
    t[27] = caml_call1(Async_kernel_config[5][4], int$0);
    return 0;
   }
   function max_num_jobs_per_priority_per_(t){
    return caml_call1(Async_kernel_config[5][5], t[27]);
   }
   function set_thread_safe_external_job_h(t, f){t[21] = f; return 0;}
   function thread_safe_enqueue_external_j(t, execution_context, f, a){
    caml_call2(Thread_safe_queue[5], t[20], [0, execution_context, f, a]);
    return caml_call1(t[21], 0);
   }
   function set_event_added_hook(t, f){t[23] = [0, f]; return 0;}
   function set_job_queued_hook(t, f){t[22] = [0, f]; return 0;}
   function create_alarm(t, f){
    var execution_context = caml_call1(current_execution_context, t);
    return caml_call1
            (Core_Gc[10][6][2],
             function(param){
              return thread_safe_enqueue_external_j
                      (t, execution_context, f, 0);
             });
   }
   function add_finalizer(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(heap_block){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer);
     return thread_safe_enqueue_external_j
             (t, execution_context, f, heap_block);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer);
    try{var _I_ = caml_call2(Stdlib_Gc[3], finalizer, heap_block); return _I_;
    }
    catch(_J_){
     var _H_ = caml_wrap_exception(_J_);
     if(_H_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_H_, 0);
    }
   }
   function add_finalizer_exn(t, x, f){
    return add_finalizer
            (t,
             caml_call1(Core_Heap_block[3], x),
             function(heap_block){
              return caml_call1(f, caml_call1(Core_Heap_block[4], heap_block));
             });
   }
   function add_finalizer_last(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(param){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer_using);
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer_using_las);
    try{var _F_ = caml_call2(Stdlib_Gc[4], finalizer, heap_block); return _F_;
    }
    catch(_G_){
     var _E_ = caml_wrap_exception(_G_);
     if(_E_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_E_, 0);
    }
   }
   function add_finalizer_last_exn(t, x, f){
    return add_finalizer_last(t, caml_call1(Core_Heap_block[3], x), f);
   }
   function force_current_cycle_to_end(t){
    return caml_call2(Async_kernel_Job_queue[6], t[3], 0);
   }
   var
    send_exn = [0, Async_kernel_Monitor[15]],
    cst_run_cycle_starting = "run_cycle starting",
    cst_run_cycle_finished = "run_cycle finished",
    cst_run_cycles_until_no_jobs_r =
      "run_cycles_until_no_jobs_remain starting",
    _a_ = [0, "scheduler"],
    cst_run_cycles_until_no_jobs_r$0 =
      "run_cycles_until_no_jobs_remain cannot proceed -- scheduler is dead",
    cst_run_cycles_until_no_jobs_r$1 =
      "run_cycles_until_no_jobs_remain finished",
    cst_Async_scheduler_is_unusabl =
      "Async scheduler is unusable due to [make_async_unusable]",
    cst_reset_in_forked_process = "reset_in_forked_process",
    _b_ = [0, "n"],
    cst_Scheduler_yield_every_got_ =
      "Scheduler.yield_every got nonpositive count",
    _c_ = [0, cst_src_scheduler_ml, 324, 4],
    _d_ = [0, 1];
   function advance_clock(t, now){
    return caml_call3
            (Async_kernel_Synchronous_time_[29], t[19], now, send_exn);
   }
   function run_cycle(t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_run_cycle_starting, t, sexp_of_t);
    var now = caml_call1(Async_kernel_Time_ns[50], 0);
    t[9] = t[9] + 1 | 0;
    t[10] = now;
    t[11] = 1;
    caml_call2(Async_kernel_Bvar[5], t[24], 0);
    var num_jobs_run_at_start_of_cycle = caml_call1(num_jobs_run, t);
    caml_call2(Core_List[9], t[12], function(f){return caml_call1(f, 0);});
    advance_clock(t, now);
    caml_call2(start_cycle, t, t[27]);
    for(;;){
     var match = caml_call1(Async_kernel_Scheduler1[78], t);
     if(0 === match[0]) break;
     var
      match$0 = match[1],
      backtrace = match$0[2],
      exn = match$0[1],
      _v_ = caml_call1(Async_kernel_Monitor[5], 0);
     caml_call3
      (Async_kernel_Monitor[15], _v_, [0, [0, 936718974, backtrace]], exn);
    }
    var
     _w_ = t[10],
     _x_ = caml_call1(Async_kernel_Time_ns[50], 0),
     cycle_time = caml_call2(Async_kernel_Time_ns[57], _x_, _w_);
    t[16] = cycle_time;
    t[17] = caml_call1(num_jobs_run, t) - num_jobs_run_at_start_of_cycle | 0;
    t[18] = caml_call2(Core_Time_ns[1][97], t[18], cycle_time);
    var _y_ = caml_call1(Async_kernel_Bvar[6], t[25]);
    if(_y_)
     var
      _z_ = caml_call1(num_pending_jobs, t),
      _A_ = caml_call2(Async_kernel_Import[3], _z_, 0);
    else
     var _A_ = _y_;
    if(_A_) caml_call2(Async_kernel_Bvar[5], t[25], 0);
    caml_call2(Core_List[9], t[14], function(f){return caml_call1(f, 0);});
    t[11] = 0;
    if(! debug) return debug;
    var
     _B_ = next_upcoming_event(t),
     _C_ = caml_call1(Core[243], _B_),
     _D_ = [0, caml_call1(uncaught_exn, t), _C_];
    return caml_call3
            (Async_kernel_Debug[15],
             cst_run_cycle_finished,
             _D_,
             function(param){
              var
               arg1_002 = param[2],
               arg0_001 = param[1],
               res0_003 = caml_call2(Core[454], Core_Error[6], arg0_001),
               res1_004 = caml_call1(Core[305], arg1_002);
              return [1, [0, res0_003, [0, res1_004, 0]]];
             });
   }
   function run_cycles_until_no_jobs_remai(param){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r);
    var t$0 = caml_call1(t, 0);
    if(caml_call1(is_dead, t$0)){
     var
      _r_ = [0, [1, [0, _a_, [0, caml_call1(sexp_of_t, t$0), 0]]], 0],
      _s_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_run_cycles_until_no_jobs_r$0),
          _r_]];
     caml_call1(Core[253], _s_);
    }
    for(;;){
     run_cycle(t$0);
     advance_clock(t$0, caml_call1(Async_kernel_Time_ns[50], 0));
     if(! can_run_a_job(t$0)){
      caml_call2(set_execution_context, t$0, t$0[6]);
      if(debug)
       caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r$1);
      var _t_ = Core_Error[28], _u_ = caml_call1(uncaught_exn, t$0);
      return caml_call2(Core_Option[41], _u_, _t_);
     }
    }
   }
   function make_async_unusable(param){
    var t = t_ref[1];
    t[1] =
     [0,
      function(param){
       var
        _q_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_scheduler_is_unusabl);
       return caml_call1(Core[253], _q_);
      }];
    return 0;
   }
   function reset_in_forked_process(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_reset_in_forked_process);
    var _p_ = caml_call1(Async_kernel_Scheduler1[66], 0);
    Async_kernel_Scheduler1[69][1] = _p_;
    return 0;
   }
   function check_invariants(t){return t[26];}
   function set_check_invariants(t, b){t[26] = b; return 0;}
   function set_record_backtraces(t, b){t[28] = b; return 0;}
   function yield$0(t){return caml_call1(Async_kernel_Bvar[4], t[24]);}
   function yield_until_no_jobs_remain(opt, t){
    if(opt)
     var sth = opt[1], may_return_immediately = sth;
    else
     var may_return_immediately = 0;
    if(may_return_immediately){
     var _o_ = caml_call1(num_pending_jobs, t);
     if(caml_call2(Async_kernel_Import[3], _o_, 0))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    return caml_call1(Async_kernel_Bvar[4], t[25]);
   }
   function yield_every(n){
    if(caml_call2(Async_kernel_Import[2], n, 0)){
     var
      _m_ = [0, [1, [0, _b_, [0, caml_call1(Core[356], n), 0]]], 0],
      _n_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_yield_every_got_),
          _m_]];
     return caml_call1(Core[253], _n_);
    }
    if(caml_call2(Async_kernel_Import[3], n, 1))
     return caml_call1(Core[258], function(t){return yield$0(t);});
    var count_until_yield = [0, n];
    return caml_call1
            (Core[258],
             function(t){
              count_until_yield[1]--;
              return caml_call2
                       (Async_kernel_Import[4], count_until_yield[1], 0)
                      ? caml_call1(Async_kernel_Deferred_std[10], 0)
                      : (count_until_yield[1] = n, yield$0(t));
             });
   }
   function total_cycle_time(t){
    if(! t[11]) return t[18];
    var
     _k_ = t[10],
     _l_ = caml_call1(Async_kernel_Time_ns[50], 0),
     this_cycle_time = caml_call2(Async_kernel_Time_ns[57], _l_, _k_);
    return caml_call2(Core_Time_ns[1][97], t[18], this_cycle_time);
   }
   function run(t){
    var num_execs_before_yielding = 1000;
    for(;;){
     if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding, 0))
      return yield_then_run(t);
     var _i_ = 1 - caml_call1(Core_Deque[16], t[5]);
     if(! _i_) return _i_;
     var worker = caml_call1(Core_Deque[61], t[5]);
     caml_call2(set_execution_context, t, worker[1]);
     a:
     {
      var num_execs_before_yielding$0 = num_execs_before_yielding;
      for(;;){
       if(! caml_call2(Core[246], t[7], worker[1]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding$0, 0)){caml_call2(Core_Deque[52], t[5], worker); return yield_then_run(t);}
       var num_execs_before_yielding$1 = num_execs_before_yielding$0 - 1 | 0;
       try{var val = caml_call1(worker[2], 0);}
       catch(exn$0){var exn = caml_wrap_exception(exn$0); break;}
       if(! val) break a;
       num_execs_before_yielding$0 = num_execs_before_yielding$1;
      }
      var
       bt = caml_call1(Base_Backtrace[6][4], 0),
       _j_ = caml_call1(Async_kernel_Monitor[5], 0);
      caml_call3(Async_kernel_Monitor[15], _j_, [0, [0, 936718974, bt]], exn);
      num_execs_before_yielding = num_execs_before_yielding$1;
      continue;
     }
     num_execs_before_yielding = num_execs_before_yielding$1;
    }
   }
   function yield_then_run(t){
    var _g_ = 1 - caml_call1(Core_Deque[16], t[5]);
    if(! _g_) return _g_;
    var _h_ = yield$0(t);
    return caml_call2
            (Async_kernel_Deferred1[8], _h_, function(param){return run(t);});
   }
   function enqueue$0(f){
    var
     t$0 = caml_call1(t, 0),
     queue = t$0[5],
     running = 1 - caml_call1(Core_Deque[16], queue),
     _e_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call4(Async_kernel_Execution_context[9], 0, _d_, 0, _e_);
    caml_call2(Core_Deque[53], queue, [0, execution_context, f]);
    var _f_ = 1 - running;
    return _f_ ? caml_call4(enqueue, t$0, execution_context, run, t$0) : _f_;
   }
   var For_bench = [0, advance_clock];
   function in_cycle(t){return t[11];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler);
   var
    Async_kernel_Scheduler =
      [0,
       sexp_of_t,
       t,
       invariant,
       current_execution_context,
       with_execution_context,
       with_execution_context1,
       set_execution_context,
       enqueue,
       create_job,
       enqueue_job,
       free_job,
       main_execution_context,
       cycle_start,
       run_cycle,
       run_cycles_until_no_jobs_remai,
       has_upcoming_event,
       next_upcoming_event,
       next_upcoming_event_exn,
       event_precision,
       uncaught_exn,
       uncaught_exn_unwrapped,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs,
       map_cycle_times,
       cycle_num_jobs,
       cycle_count,
       total_cycle_time,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       set_check_access,
       check_access,
       check_invariants,
       set_check_invariants,
       set_record_backtraces,
       run_every_cycle_start,
       run_every_cycle_end,
       add_every_cycle_start_hook,
       add_every_cycle_end_hook,
       remove_every_cycle_start_hook_,
       remove_every_cycle_end_hook_ex,
       last_cycle_time,
       long_cycles,
       can_run_a_job,
       create_alarm,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       set_thread_safe_external_job_h,
       set_job_queued_hook,
       set_event_added_hook,
       thread_safe_enqueue_external_j,
       force_current_cycle_to_end,
       within,
       within$0,
       within_v,
       schedule,
       schedule$0,
       preserve_execution_context,
       preserve_execution_context$0,
       within_context,
       find_local,
       with_local,
       make_async_unusable,
       reset_in_forked_process,
       yield$0,
       yield_every,
       yield_until_no_jobs_remain,
       [0, Very_low_priority_worker[1], enqueue$0],
       For_bench,
       in_cycle];
   runtime.caml_register_global
    (61, Async_kernel_Scheduler, cst_Async_kernel_Scheduler);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Cycle_hook
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Cycle_hook = "Async_kernel__Cycle_hook",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Cycle_hook);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/cycle_hook.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Handle = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Cycle_hook);
   var Async_kernel_Cycle_hook = [0, Handle];
   runtime.caml_register_global
    (11, Async_kernel_Cycle_hook, cst_Async_kernel_Cycle_hook);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_kernel_scheduler
//# unitInfo: Requires: Async_kernel__Scheduler, Async_kernel__Time_ns, Base__Staged, Core, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_kernel_ = "Async_kernel__Async_kernel_scheduler",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_kernel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_kernel_scheduler.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    t = Async_kernel_Scheduler[2],
    with_execution_context = Async_kernel_Scheduler[5],
    with_execution_context1 = Async_kernel_Scheduler[6],
    enqueue = Async_kernel_Scheduler[8],
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    last_cycle_num_jobs = Async_kernel_Scheduler[24],
    map_cycle_times = Async_kernel_Scheduler[25],
    run_every_cycle_start = Async_kernel_Scheduler[36],
    run_every_cycle_end = Async_kernel_Scheduler[37],
    add_every_cycle_start_hook = Async_kernel_Scheduler[38],
    add_every_cycle_end_hook = Async_kernel_Scheduler[39],
    remove_every_cycle_start_hook_ = Async_kernel_Scheduler[40],
    remove_every_cycle_end_hook_ex = Async_kernel_Scheduler[41],
    thread_safe_enqueue_external_j = Async_kernel_Scheduler[53],
    within = Async_kernel_Scheduler[55],
    within$0 = Async_kernel_Scheduler[56],
    within_v = Async_kernel_Scheduler[57],
    schedule = Async_kernel_Scheduler[58],
    schedule$0 = Async_kernel_Scheduler[59],
    preserve_execution_context = Async_kernel_Scheduler[60],
    preserve_execution_context$0 = Async_kernel_Scheduler[61],
    within_context = Async_kernel_Scheduler[62],
    find_local = Async_kernel_Scheduler[63],
    with_local = Async_kernel_Scheduler[64],
    _a_ = Async_kernel_Scheduler[4],
    _b_ = Async_kernel_Scheduler[13],
    _c_ = Async_kernel_Scheduler[19],
    _d_ = Async_kernel_Scheduler[22],
    _e_ = Async_kernel_Scheduler[23],
    _f_ = Async_kernel_Scheduler[27],
    _g_ = Async_kernel_Scheduler[28],
    _h_ = Async_kernel_Scheduler[29],
    _i_ = Async_kernel_Scheduler[30],
    _j_ = Async_kernel_Scheduler[35],
    _k_ = Async_kernel_Scheduler[42],
    _l_ = Async_kernel_Scheduler[43],
    _m_ = Async_kernel_Scheduler[54],
    _n_ = Async_kernel_Scheduler[67],
    _o_ = Async_kernel_Scheduler[68],
    _p_ = Async_kernel_Scheduler[69];
   function enqueue_job(execution_context, f, a){
    return caml_call4(enqueue, caml_call1(t, 0), execution_context, f, a);
   }
   function thread_safe_enqueue_job(execution_context, f, a){
    return caml_call4
            (thread_safe_enqueue_external_j,
             caml_call1(t, 0),
             execution_context,
             f,
             a);
   }
   function current_execution_context(param){
    return caml_call1(_a_, caml_call1(t, 0));
   }
   function cycle_count(param){return caml_call1(_f_, caml_call1(t, 0));}
   function cycle_start_ns(param){return caml_call1(_b_, caml_call1(t, 0));}
   function cycle_start(param){
    var _u_ = cycle_start_ns(0);
    return caml_call1(Async_kernel_Time_ns[70], _u_);
   }
   function cycle_times_ns(param){
    return caml_call2
            (map_cycle_times, caml_call1(t, 0), function(_t_){return _t_;});
   }
   function cycle_times(param){
    var _s_ = Core_Time_ns[1][134];
    return caml_call2(map_cycle_times, caml_call1(t, 0), _s_);
   }
   function total_cycle_time(param){return caml_call1(_g_, caml_call1(t, 0));}
   function last_cycle_time(param){return caml_call1(_k_, caml_call1(t, 0));}
   function long_cycles(at_least){
    return caml_call2(_l_, caml_call1(t, 0), at_least);
   }
   function event_precision_ns(param){
    return caml_call1(_c_, caml_call1(t, 0));
   }
   function event_precision(param){
    var _r_ = event_precision_ns(0);
    return caml_call1(Core_Time_ns[1][134], _r_);
   }
   function set_max_num_jobs_per_priority_(i){
    return caml_call2(_i_, caml_call1(t, 0), i);
   }
   function max_num_jobs_per_priority_per_(param){return caml_call1(_h_, caml_call1(t, 0));
   }
   function set_record_backtraces(bool){
    return caml_call2(_j_, caml_call1(t, 0), bool);
   }
   function force_current_cycle_to_end(param){return caml_call1(_m_, caml_call1(t, 0));
   }
   function yield$0(param){return caml_call1(_n_, caml_call1(t, 0));}
   function yield_until_no_jobs_remain(may_return_immediately, param){return caml_call2(_p_, may_return_immediately, caml_call1(t, 0));
   }
   function yield_every(n){
    var
     _q_ = caml_call1(_o_, n),
     yield_every = caml_call1(Base_Staged[2], _q_),
     t$0 = caml_call1(t, 0);
    return caml_call1
            (Core[258], function(param){return caml_call1(yield_every, t$0);});
   }
   function num_jobs_run(param){return caml_call1(_e_, caml_call1(t, 0));}
   function num_pending_jobs(param){return caml_call1(_d_, caml_call1(t, 0));}
   function last_cycle_num_jobs$0(param){
    return caml_call1(last_cycle_num_jobs, caml_call1(t, 0));
   }
   function run_every_cycle_start$0(f){
    return caml_call2(run_every_cycle_start, caml_call1(t, 0), f);
   }
   function run_every_cycle_end$0(f){
    return caml_call2(run_every_cycle_end, caml_call1(t, 0), f);
   }
   function add_every_cycle_start_hook$0(f){
    return caml_call2(add_every_cycle_start_hook, caml_call1(t, 0), f);
   }
   function add_every_cycle_end_hook$0(f){
    return caml_call2(add_every_cycle_end_hook, caml_call1(t, 0), f);
   }
   function remove_every_cycle_start_hook_$0(handle){
    return caml_call2
            (remove_every_cycle_start_hook_, caml_call1(t, 0), handle);
   }
   function remove_every_cycle_end_hook_ex$0(handle){
    return caml_call2
            (remove_every_cycle_end_hook_ex, caml_call1(t, 0), handle);
   }
   function with_execution_context$0(execution_context, f){
    return caml_call3
            (with_execution_context, caml_call1(t, 0), execution_context, f);
   }
   function with_execution_context1$0(execution_context, f, x){
    return caml_call4
            (with_execution_context1,
             caml_call1(t, 0),
             execution_context,
             f,
             x);
   }
   var
    Expert =
      [0,
       run_cycles_until_no_jobs_remai,
       last_cycle_num_jobs$0,
       run_every_cycle_start$0,
       run_every_cycle_end$0,
       add_every_cycle_start_hook$0,
       add_every_cycle_end_hook$0,
       remove_every_cycle_start_hook_$0,
       remove_every_cycle_end_hook_ex$0,
       with_execution_context$0,
       with_execution_context1$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_kernel_);
   var
    Async_kernel_Async_kernel_sche =
      [0,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert];
   runtime.caml_register_global
    (16, Async_kernel_Async_kernel_sche, cst_Async_kernel_Async_kernel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_intf = "Async_kernel__Clock_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/clock_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "Timeout"], _b_ = [0, "Result"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(642269825 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 1025039613 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return runtime.caml_compare(a_001, b_002);
   }
   function sexp_of_t(of_a_005, param){
    if(typeof param === "number") return _a_;
    var v_006 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_005, v_006), 0]]];
   }
   var Or_timeout = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_intf);
   var Async_kernel_Clock_intf = [0, Or_timeout];
   runtime.caml_register_global
    (14, Async_kernel_Clock_intf, cst_Async_kernel_Clock_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_ns
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Time_source, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_ns = "Async_kernel__Clock_ns",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_ns);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/clock_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function time_source(param){
    var _q_ = caml_call1(Async_kernel_Scheduler1[71], 0)[19];
    return caml_call1(Async_kernel_Time_source[39], _q_);
   }
   function after(span){
    var _p_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[29], _p_, span);
   }
   function at(time){
    var _o_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[28], _o_, time);
   }
   function at_varying_intervals(stop, compute_span){
    var _n_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[33], stop, _n_, compute_span);
   }
   function at_intervals(start, stop, interval){
    var _m_ = time_source(0);
    return caml_call4
            (Async_kernel_Time_source[34], start, stop, _m_, interval);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _l_ = time_source(0);
    return caml_call7
            (Async_kernel_Time_source[35],
             start,
             stop,
             continue_on_error,
             finished,
             _l_,
             span,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _k_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[36],
             start,
             stop,
             continue_on_error,
             _k_,
             span,
             f);
   }
   function run_after(span, f, a){
    var _j_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[27], _j_, span, f, a);
   }
   function run_at(time, f, a){
    var _i_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[26], _i_, time, f, a);
   }
   function run_at_intervals(start, stop, continue_on_error, interval, f){
    var _h_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[38],
             start,
             stop,
             continue_on_error,
             _h_,
             interval,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, interval, f){
    var _g_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[37],
             start,
             stop,
             continue_on_error,
             _g_,
             interval,
             f);
   }
   function with_timeout(span, d){
    var _f_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[30], _f_, span, d);
   }
   function duration_of(f){
    var _e_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[31], _e_, f);
   }
   var
    include = Async_kernel_Time_source[32],
    sexp_of_t = include[1],
    sexp_of_t_unit = include[2],
    invariant = include[3],
    scheduled_at = include[4],
    Status = include[5],
    status = include[6],
    abort = include[10],
    abort_exn = include[11],
    abort_if_possible = include[12],
    fired = include[14],
    reschedule_at = include[16],
    reschedule_after = include[17],
    _a_ = include[7],
    _b_ = include[8],
    _c_ = include[18],
    _d_ = include[19];
   function after$0(span){return caml_call2(_d_, time_source(0), span);}
   function run_after$0(span, f, a){
    return caml_call4(_b_, time_source(0), span, f, a);
   }
   function at$0(time){return caml_call2(_c_, time_source(0), time);}
   function run_at$0(time, f, z){
    return caml_call4(_a_, time_source(0), time, f, z);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_ns);
   var
    Async_kernel_Clock_ns =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals$0,
       run_at_intervals,
       duration_of];
   runtime.caml_register_global
    (13, Async_kernel_Clock_ns, cst_Async_kernel_Clock_ns);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_array
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__Array, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_arra = "Async_kernel__Deferred_array",
    cst_async_kernel = "async_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Array = global_data.Core__Array,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_arra);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_array.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function foldi(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(i, b){
               if(caml_call2(Core[90], i, t.length - 1))
                return caml_call2(Async_kernel_Ivar[14], result, b);
               var _y_ = caml_call3(f, i, b, caml_check_bound(t, i)[1 + i]);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _y_,
                        function(b){return loop(i + 1 | 0, b);});
              }
              return loop(0, init);
             });
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _v_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          var _x_ = caml_call2(f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[4],
                   _x_,
                   function(b){return [0, b, bs];});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _v_,
             function(bs){
              var _w_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Array[52], _w_);
             });
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _u_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _u_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _s_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _t_ = caml_call1(Core[259], _s_);
    return all_unit(caml_call2(Core_Array[59], t, _t_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _q_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _r_ = caml_call1(Core[259], _q_);
    return all(caml_call2(Core_Array[59], t, _r_));
   }
   function filteri(how, t, f){
    var _o_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _o_,
             function(bools){
              var
               _p_ =
                 caml_call4
                  (Core_Array[82],
                   t,
                   bools,
                   0,
                   function(ac, x, b){return b ? [0, x, ac] : ac;});
              return caml_call1(Core_Array[90], _p_);
             });
   }
   function filter_mapi(how, t, f){
    var _m_ = Core_Array[74], _n_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
   }
   function concat_mapi(how, t, f){
    var _k_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _k_,
             function(t){
              var _l_ = caml_call1(Core_Array[32], t);
              return caml_call1(Core_Array[44], _l_);
             });
   }
   function find_mapi(t, f){
    function aux(i){
     if(caml_call2(Core[90], i, t.length - 1))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
     var _j_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : aux(i + 1 | 0);
              });
    }
    return aux(0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _i_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _i_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _h_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _h_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          var _g_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _g_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _f_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _d_ =
       find_mapi
        (t,
         function(i, elt){
          var _e_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _e_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _d_,
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_Array[40], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_arra);
   var
    Async_kernel_Deferred_array =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_array, cst_Async_kernel_Deferred_arra);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_list
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_list = "Async_kernel__Deferred_list",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_list);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_list.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function foldi(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t, i, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1], _y_ = caml_call3(f, i, b, x);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _y_,
                        function(b){return loop(xs, i + 1 | 0, b);});
              }
              return loop(t, 0, init);
             });
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _v_ = Core_List[34],
     _w_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          var _x_ = caml_call2(f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _x_,
                   function(b){return [0, b, bs];});
         });
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _u_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _u_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _s_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _t_ = caml_call1(Core[259], _s_);
    return all_unit(caml_call2(Core_List[92], t, _t_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _q_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _r_ = caml_call1(Core[259], _q_);
    return all(caml_call2(Core_List[92], t, _r_));
   }
   function filteri(how, t, f){
    var _o_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _o_,
             function(bools){
              var
               _p_ =
                 caml_call4
                  (Core_List[42],
                   t,
                   bools,
                   0,
                   function(ac, x, b){return b ? [0, x, ac] : ac;});
              return caml_call1(Core_List[34], _p_);
             });
   }
   function filter_mapi(how, t, f){
    var _m_ = Core_List[124], _n_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
   }
   function concat_mapi(how, t, f){
    var _k_ = Core_List[133], _l_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _l_, _k_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var tl = t[2], hd = t[1], _j_ = caml_call2(f, i, hd);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _i_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _i_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _h_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _h_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          var _g_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _g_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _f_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _d_ =
       find_mapi
        (t,
         function(i, elt){
          var _e_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _e_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _d_,
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_List[119], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_list);
   var
    Async_kernel_Deferred_list =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (19, Async_kernel_Deferred_list, cst_Async_kernel_Deferred_list);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_map
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_list, Async_kernel__Deferred_std, Async_kernel__Ivar, Base__Field, Base__List, Base__Map, Core__Map, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_map = "Async_kernel__Deferred_map",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Map = global_data.Core__Map,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Base_List = global_data.Base__List,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Map = global_data.Base__Map,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_map.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, -542431297];
   function change(t, k, f){
    var _q_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _q_,
             function(opt){
              return caml_call3
                      (Core_Map[36], t, k, function(param){return opt;});
             });
   }
   function update(t, k, f){
    var _p_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _p_,
             function(data){return caml_call3(Core_Map[32], t, k, data);});
   }
   function iter_keys(how, t, f){
    var _o_ = caml_call1(Core_Map[72], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _o_, f);
   }
   function iter(how, t, f){
    var _n_ = caml_call1(Core_Map[73], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _n_, f);
   }
   function iteri(how, t, f){
    var _m_ = caml_call2(Core_Map[74], 0, t);
    return caml_call3
            (Async_kernel_Deferred_list[14],
             how,
             _m_,
             function(param){
              var data = param[2], key = param[1];
              return caml_call2(f, key, data);
             });
   }
   function fold(t, init, f){
    var
     alist_in_increasing_key_order =
       caml_call3
        (Core_Map[57],
         t,
         0,
         function(key, data, alist){return [0, [0, key, data], alist];});
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_increasing_key_order,
             init,
             function(ac, param){
              var data = param[2], key = param[1];
              return caml_call3(f, key, data, ac);
             });
   }
   function fold_right(t, init, f){
    var
     alist_in_decreasing_key_order =
       caml_call3
        (Core_Map[55],
         t,
         0,
         function(key, data, alist){return [0, [0, key, data], alist];});
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_decreasing_key_order,
             init,
             function(ac, param){
              var data = param[2], key = param[1];
              return caml_call3(f, key, data, ac);
             });
   }
   function result(r){return r[3];}
   function filter_mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var
      comparator = caml_call1(Core_Map[2], t),
      sequence = caml_call4(Core_Map[101], _a_, 0, 0, t);
     return caml_call1
             (Async_kernel_Deferred1[4],
              function(ivar){
               return caml_call4
                       (Core_Sequence[105],
                        sequence,
                        Base_Map[104][3][96][1],
                        function(s, param, k){
                         var
                          data = param[2],
                          key = param[1],
                          _l_ = caml_call2(f, key, data);
                         return caml_call2
                                 (Async_kernel_Deferred_std[11],
                                  _l_,
                                  function(param){
                                   if(! param) return caml_call1(k, s);
                                   var
                                    data = param[1],
                                    s$0 =
                                      caml_call4
                                       (Base_Map[104][3][96][2], s, comparator, key, data);
                                   return caml_call1(k, s$0);
                                  });
                        },
                        function(x){
                         var
                          _j_ = caml_call1(Base_Map[104][3][96][3], x),
                          _k_ = caml_call2(Core_Map[110][23], comparator, _j_);
                         return caml_call2(Async_kernel_Ivar[14], ivar, _k_);
                        });
              });
    }
    var
     jobs = [0, 0],
     job_map =
       caml_call2
        (Core_Map[52],
         t,
         function(key, data){
          var job = [0, key, data, 0];
          jobs[1] = [0, job, jobs[1]];
          return job;
         }),
     _g_ = caml_call1(Base_List[38], jobs[1]),
     _h_ =
       caml_call3
        (Async_kernel_Deferred_list[14],
         [0, how],
         _g_,
         function(job){
          var data = job[2], key = job[1], _i_ = caml_call2(f, key, data);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _i_,
                   function(x){job[3] = x; return 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _h_,
             function(param){
              return caml_call2(Core_Map[62], job_map, result);
             });
   }
   function filter_map(how, t, f){
    return filter_mapi
            (how, t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _f_ = caml_call1(f, key);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _f_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function filter(how, t, f){
    return filter_mapi
            (how,
             t,
             function(param, data){
              var _e_ = caml_call1(f, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _e_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _d_ = caml_call2(f, key, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function mapi(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _c_ = caml_call2(f, key, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _c_,
                       function(z){return [0, z];});
             });
   }
   function map(how, t, f){
    return mapi(how, t, function(param, data){return caml_call1(f, data);});
   }
   function merge(how, t1, t2, f){
    return filter_map
            (how,
             caml_call3
              (Core_Map[77],
               t1,
               t2,
               function(key, z){
                return [0, function(param){return caml_call2(f, key, z);}];
               }),
             function(thunk){return caml_call1(thunk, 0);});
   }
   function all(t){return map(0, t, function(_b_){return _b_;});}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_map);
   var
    Async_kernel_Deferred_map =
      [0,
       change,
       update,
       iter_keys,
       iter,
       iteri,
       map,
       mapi,
       fold,
       fold_right,
       filter_keys,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       merge,
       all];
   runtime.caml_register_global
    (25, Async_kernel_Deferred_map, cst_Async_kernel_Deferred_map);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Monitor, Base__Exn, Base__Staged, Core__Memo, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo = "Async_kernel__Deferred_memo",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Memo = global_data.Core__Memo,
    Base_Staged = global_data.Base__Staged,
    Base_Exn = global_data.Base__Exn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_memo.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    cst_caught_exception_in_memoiz = "caught exception in memoized function",
    _a_ = [0, 3804260],
    _b_ = [0, 3903734],
    _c_ = [0, 3804260],
    _d_ = [0, 3903734];
   function reraise(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    return caml_call2(Base_Exn[8], exn, cst_caught_exception_in_memoiz);
   }
   function general(hashable, f){
    var
     f$0 =
       caml_call3
        (Core_Memo[1],
         [0, hashable[4]],
         0,
         function(a){
          return caml_call7
                  (Async_kernel_Monitor[16],
                   0,
                   0,
                   0,
                   0,
                   _b_,
                   _a_,
                   function(param){return caml_call1(f, a);});
         });
    return caml_call1
            (Base_Staged[1],
             function(a){
              var _f_ = caml_call1(f$0, a);
              return caml_call2(Async_kernel_Deferred_std[4], _f_, reraise);
             });
   }
   function unit(f){
    var
     f$0 =
       caml_call1
        (Core_Memo[3],
         function(param){
          return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _d_, _c_, f);
         });
    return caml_call1
            (Base_Staged[1],
             function(param){
              var _e_ = caml_call1(f$0, 0);
              return caml_call2(Async_kernel_Deferred_std[4], _e_, reraise);
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo = [0, general, unit];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_memo, cst_Async_kernel_Deferred_memo);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_option
//# unitInfo: Requires: Async_kernel__Deferred1, Base__Monad, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_opti = "Async_kernel__Deferred_option",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_opti);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_option.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    return caml_call2
            (Async_kernel_Deferred1[17],
             t,
             function(param){
              if(! param) return caml_call1(Async_kernel_Deferred1[21], 0);
              var a = param[1];
              return caml_call1(f, a);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call2
                (Async_kernel_Deferred1[18],
                 t,
                 function(r){return caml_call2(Core_Option[29], r, f);});
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_opti);
   var
    Async_kernel_Deferred_option =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_option, cst_Async_kernel_Deferred_opti);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_result
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Base__Monad, Core__Printf, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_resu = "Async_kernel__Deferred_result",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Printf = global_data.Core__Printf,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_resu);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_result.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function combine(t1, t2, ok, err){
    var _a_ = caml_call2(Async_kernel_Deferred_std[5][3], t1, t2);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _a_,
             function(param){
              var t2 = param[2], t1 = param[1];
              return caml_call4(Core_Result[40], t1, t2, ok, err);
             });
   }
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    return caml_call2
            (Async_kernel_Deferred1[17],
             t,
             function(error){
              if(0 !== error[0])
               return caml_call1(Async_kernel_Deferred1[21], error);
              var a = error[1];
              return caml_call1(f, a);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call2
                (Async_kernel_Deferred1[18],
                 t,
                 function(r){return caml_call2(Core_Result[38], r, f);});
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){return caml_call1(Async_kernel_Deferred1[21], [1, x]);}
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(r){return caml_call2(Core_Result[39], r, f);});
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_resu);
   var
    Async_kernel_Deferred_result =
      [0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error,
       combine];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_result, cst_Async_kernel_Deferred_resu);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_or_error
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_or_e = "Async_kernel__Deferred_or_error",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_or_e);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_or_error.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    try_with = Async_kernel_Monitor[16],
    ignore_m = Async_kernel_Deferred_result[9],
    join = Async_kernel_Deferred_result[8],
    return$0 = Async_kernel_Deferred_result[6],
    bind = Async_kernel_Deferred_result[5],
    Monad_infix = Async_kernel_Deferred_result[4],
    symbol_bind = Async_kernel_Deferred_result[1];
   function apply(f, x){
    return caml_call4
            (Async_kernel_Deferred_result[15],
             f,
             x,
             function(f, x){return caml_call1(f, x);},
             function(e1, e2){
              return caml_call2(Core_Error[24], 0, [0, e1, [0, e2, 0]]);
             });
   }
   var
    map = [0, -198771759, Async_kernel_Deferred_result[7]],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _G_ = caml_call1(Core_Result[27], error);
    return caml_call1(Async_kernel_Deferred1[21], _G_);
   }
   function ok_exn(t){
    return caml_call2(Async_kernel_Deferred1[18], t, Core_Or_error[36]);
   }
   function of_exn(exn){
    var _F_ = caml_call2(Core_Or_error[37], 0, exn);
    return caml_call1(Async_kernel_Deferred1[21], _F_);
   }
   function of_exn_result(t){
    var arg = Core_Or_error[38];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function error(msg, v, sexp_of){
    var _E_ = caml_call5(Core_Or_error[39], 0, 0, msg, v, sexp_of);
    return caml_call1(Async_kernel_Deferred1[21], _E_);
   }
   function error_s(sexp){
    var _D_ = caml_call1(Core_Or_error[40], sexp);
    return caml_call1(Async_kernel_Deferred1[21], _D_);
   }
   function error_string(msg){
    var _C_ = caml_call1(Core_Or_error[41], msg);
    return caml_call1(Async_kernel_Deferred1[21], _C_);
   }
   function errorf(format){
    return caml_call2(Core[244], error_string, format);
   }
   function tag(t, tag){
    var _A_ = Core_Or_error[43];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_B_){return caml_call2(_A_, _B_, tag);});
   }
   function tag_s(t, tag){
    var _y_ = Core_Or_error[44];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_z_){return caml_call2(_y_, _z_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _w_ = Core_Or_error[45];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_x_){return caml_call2(_w_, _x_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(t){
              return caml_call4(Core_Or_error[46], t, message, a, sexp_of_a);
             });
   }
   function unimplemented(msg){
    var _v_ = caml_call1(Core_Or_error[47], msg);
    return caml_call1(Async_kernel_Deferred1[21], _v_);
   }
   function combine_errors(l){
    var
     _t_ = Core_Or_error[51],
     _u_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _u_, _t_);
   }
   function combine_errors_unit(l){
    var
     _r_ = Core_Or_error[52],
     _s_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _s_, _r_);
   }
   function filter_ok_at_least_one(l){
    var
     _p_ = Core_Or_error[53],
     _q_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _q_, _p_);
   }
   function find_map_ok(l, f){
    return caml_call2
            (Async_kernel_Deferred1[37],
             [0, l, 0],
             function(param){
              var errors = param[2], l = param[1];
              if(l){
               var tl = l[2], hd = l[1], _n_ = caml_call1(f, hd);
               return caml_call2
                       (Async_kernel_Deferred1[18],
                        _n_,
                        function(param){
                         if(0 === param[0]){
                          var result = param[1];
                          return [0, -289386606, [0, result]];
                         }
                         var current_error = param[1];
                         return [0, 990972795, [0, tl, [0, current_error, errors]]];
                        });
              }
              var
               _o_ = caml_call1(Core_List[34], errors),
               errors$0 = caml_call2(Core_Error[24], 0, _o_);
              return caml_call1
                      (Async_kernel_Deferred1[21], [0, -289386606, [1, errors$0]]);
             });
   }
   var ok_unit = caml_call1(return$1, 0), _a_ = [0, 0], _b_ = [0, 0];
   function try_with$0(extract_exn, run, rest, here, name, f){
    var _m_ = caml_call7(try_with, here, 0, name, extract_exn, run, rest, f);
    return caml_call2
            (Async_kernel_Deferred1[18],
             _m_,
             function(ok){
              if(0 === ok[0]) return ok;
              var exn = ok[1];
              return [1, caml_call2(Core_Error[25], 0, exn)];
             });
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _k_ = Core_Or_error[27],
     _l_ = try_with$0(extract_exn, run, rest, here, name, f);
    return caml_call2(Async_kernel_Deferred1[18], _l_, _k_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     return caml_call2
             (bind,
              caml_call3(f, i, acc, hd),
              function(acc){return loop(i + 1 | 0, acc, tl);});
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _i_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _j_ = caml_call1(Core[259], _i_);
    return caml_call1(all_unit, caml_call2(Core_List[92], t, _j_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var _f_ = Core_List[34];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 return caml_call2
                         (map$0,
                          caml_call2(f, i, a),
                          function(b){return [0, b, bs];});
                }),
              _f_);
    }
    var
     _g_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _h_ = caml_call1(Core[259], _g_);
    return caml_call1(all, caml_call2(Core_List[92], t, _h_));
   }
   function filter_mapi(how, t, f){
    var _e_ = Core_List[124];
    return caml_call2(symbol_map$0, mapi(how, t, f), _e_);
   }
   function concat_mapi(how, t, f){
    var _d_ = Core_List[133];
    return caml_call2(symbol_map$0, mapi(how, t, f), _d_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, x),
                       function(b){return b ? [0, x] : 0;});
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     return caml_call2
             (bind,
              caml_call2(f, i, hd),
              function(some){
               return some
                       ? caml_call1(return$1, some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, elt),
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              return caml_call2
                      (map$0,
                       caml_call1(f, elt),
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? _a_ : 0;});
               }),
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? 0 : _b_;});
               }),
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map$1
            (how,
             caml_call2(Core_List[119], n, function(_c_){return _c_;}),
             f);
   }
   function repeat_until_finished(state, f){
    return caml_call2
            (bind,
             caml_call1(f, state),
             function(param){
              if(990972795 <= param[1]){
               var state = param[2];
               return repeat_until_finished(state, f);
              }
              var state$0 = param[2];
              return caml_call1(return$1, state$0);
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_or_e);
   var
    Async_kernel_Deferred_or_error =
      [0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_map_ok,
       ok_unit,
       try_with$0,
       try_with_join,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Async_kernel_Deferred_or_error, cst_Async_kernel_Deferred_or_e);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_queue
//# unitInfo: Requires: Async_kernel__Deferred_list, Async_kernel__Deferred_std, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_queu = "Async_kernel__Deferred_queue",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_queu);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_queue.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function foldi(t, init, f){
    var _T_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[1], _T_, init, f);
   }
   function fold(t, init, f){
    var _S_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[2], _S_, init, f);
   }
   function all(t){
    var
     _P_ = Core_Queue[38],
     _Q_ = caml_call1(Core_Queue[26], t),
     _R_ = caml_call1(Async_kernel_Deferred_list[11], _Q_);
    return caml_call2(Async_kernel_Deferred_std[4], _R_, _P_);
   }
   function all_unit(t){
    var _O_ = caml_call1(Core_Queue[26], t);
    return caml_call1(Async_kernel_Deferred_list[12], _O_);
   }
   function iter(how, t, f){
    var _N_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _N_, f);
   }
   function iteri(how, t, f){
    var _M_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[15], how, _M_, f);
   }
   function map(how, t, f){
    var
     _J_ = Core_Queue[38],
     _K_ = caml_call1(Core_Queue[26], t),
     _L_ = caml_call3(Async_kernel_Deferred_list[16], how, _K_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _L_, _J_);
   }
   function mapi(how, t, f){
    var
     _G_ = Core_Queue[38],
     _H_ = caml_call1(Core_Queue[26], t),
     _I_ = caml_call3(Async_kernel_Deferred_list[17], how, _H_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _I_, _G_);
   }
   function init(how, n, f){
    var
     _E_ = Core_Queue[38],
     _F_ = caml_call3(Async_kernel_Deferred_list[13], how, n, f);
    return caml_call2(Async_kernel_Deferred_std[4], _F_, _E_);
   }
   function filter(how, t, f){
    var
     _B_ = Core_Queue[38],
     _C_ = caml_call1(Core_Queue[26], t),
     _D_ = caml_call3(Async_kernel_Deferred_list[18], how, _C_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _D_, _B_);
   }
   function filteri(how, t, f){
    var
     _y_ = Core_Queue[38],
     _z_ = caml_call1(Core_Queue[26], t),
     _A_ = caml_call3(Async_kernel_Deferred_list[19], how, _z_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _A_, _y_);
   }
   function filter_map(how, t, f){
    var
     _v_ = Core_Queue[38],
     _w_ = caml_call1(Core_Queue[26], t),
     _x_ = caml_call3(Async_kernel_Deferred_list[20], how, _w_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _x_, _v_);
   }
   function filter_mapi(how, t, f){
    var
     _s_ = Core_Queue[38],
     _t_ = caml_call1(Core_Queue[26], t),
     _u_ = caml_call3(Async_kernel_Deferred_list[21], how, _t_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _u_, _s_);
   }
   function concat_map(how, t, f){
    var
     _n_ = Core_Queue[38],
     _o_ = caml_call1(Core_Queue[26], t),
     _p_ =
       caml_call3
        (Async_kernel_Deferred_list[22],
         how,
         _o_,
         function(x){
          var _q_ = Core_Queue[26], _r_ = caml_call1(f, x);
          return caml_call2(Async_kernel_Deferred_std[4], _r_, _q_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _p_, _n_);
   }
   function concat_mapi(how, t, f){
    var
     _i_ = Core_Queue[38],
     _j_ = caml_call1(Core_Queue[26], t),
     _k_ =
       caml_call3
        (Async_kernel_Deferred_list[23],
         how,
         _j_,
         function(i, x){
          var _l_ = Core_Queue[26], _m_ = caml_call2(f, i, x);
          return caml_call2(Async_kernel_Deferred_std[4], _m_, _l_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _k_, _i_);
   }
   function find_map(t, f){
    var _h_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[5], _h_, f);
   }
   function find_mapi(t, f){
    var _g_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[6], _g_, f);
   }
   function find(t, f){
    var _f_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[3], _f_, f);
   }
   function findi(t, f){
    var _e_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[4], _e_, f);
   }
   function for_all(t, f){
    var _d_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[9], _d_, f);
   }
   function for_alli(t, f){
    var _c_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[10], _c_, f);
   }
   function exists(t, f){
    var _b_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[7], _b_, f);
   }
   function existsi(t, f){
    var _a_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[8], _a_, f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_queu);
   var
    Async_kernel_Deferred_queue =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_queue, cst_Async_kernel_Deferred_queu);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_sequence
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Throttle, Core__List, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_sequ = "Async_kernel__Deferred_sequence",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_sequ);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function fold_mapi(opt, t){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    return function(init, mapi_f, fold_f){
     if(typeof how !== "number"){
      var
       max_concurrent_jobs = how[2],
       throttle = caml_call2(Async_kernel_Throttle[4], 0, max_concurrent_jobs),
       loop$0 =
         function(i, t, c){
          var _y_ = caml_call1(Async_kernel_Throttle[16], throttle);
          return caml_call2
                  (Async_kernel_Deferred_std[5][1],
                   _y_,
                   function(param){
                    var match = caml_call1(Core_Sequence[47], t);
                    if(! match) return c;
                    var
                     match$0 = match[1],
                     t$0 = match$0[2],
                     a = match$0[1],
                     _z_ =
                       caml_call2
                        (Async_kernel_Throttle[8],
                         throttle,
                         function(param){return caml_call2(mapi_f, i, a);});
                    return loop$0
                            (i + 1 | 0,
                             t$0,
                             caml_call2
                              (Async_kernel_Deferred_std[5][1],
                               _z_,
                               function(b){
                                return caml_call2
                                        (Async_kernel_Deferred_std[5][2],
                                         c,
                                         function(c){return caml_call2(fold_f, c, b);});
                               }));
                   });
         };
      return loop$0(0, t, caml_call1(Async_kernel_Deferred_std[10], init));
     }
     if(-676829465 > how){
      var
       loop =
         function(i, t, c){
          var match = caml_call1(Core_Sequence[47], t);
          if(! match) return caml_call1(Async_kernel_Deferred_std[10], c);
          var
           match$0 = match[1],
           t$0 = match$0[2],
           a = match$0[1],
           _x_ = caml_call2(mapi_f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[5][1],
                   _x_,
                   function(b){
                    return loop(i + 1 | 0, t$0, caml_call2(fold_f, c, b));
                   });
         };
      return loop(0, t, init);
     }
     var
      c$1 = caml_call1(Async_kernel_Deferred_std[10], init),
      i = 0,
      t$0 = t,
      c = c$1;
     for(;;){
      var match = caml_call1(Core_Sequence[47], t$0);
      if(! match) return c;
      var match$0 = match[1], t$1 = match$0[2], a = match$0[1];
      let c$1 = c;
      var
       _w_ = caml_call2(mapi_f, i, a),
       c$0 =
         caml_call2
          (Async_kernel_Deferred_std[5][1],
           _w_,
           function(b){
            return caml_call2
                    (Async_kernel_Deferred_std[5][2],
                     c$1,
                     function(c){return caml_call2(fold_f, c, b);});
           }),
       i$0 = i + 1 | 0;
      i = i$0;
      t$0 = t$1;
      c = c$0;
     }};
   }
   function foldi(t, init, f){
    return caml_call4
            (Core_Sequence[105],
             t,
             [0, 0, init],
             function(param, a, k){
              var b = param[2], i = param[1], _v_ = caml_call3(f, i, b, a);
              return caml_call2
                      (Async_kernel_Deferred_std[5][1],
                       _v_,
                       function(b){return caml_call1(k, [0, i + 1 | 0, b]);});
             },
             function(param){
              var b = param[2];
              return caml_call1(Async_kernel_Deferred_std[10], b);
             });
   }
   function fold(t, init, f){
    return caml_call4
            (Core_Sequence[105],
             t,
             init,
             function(b, a, k){
              var _u_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[3], _u_, k);
             },
             Async_kernel_Deferred_std[10]);
   }
   function all(t){
    var
     _s_ =
       fold
        (t,
         0,
         function(accum, d){
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   d,
                   function(a){return [0, a, accum];});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _s_,
             function(res){
              var _t_ = caml_call1(Core_List[34], res);
              return caml_call1(Core_Sequence[109], _t_);
             });
   }
   function all_unit(t){return fold(t, 0, function(param, v){return v;});}
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     var match = caml_call1(Core_Sequence[47], t);
     if(! match) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var
      match$0 = match[1],
      rest = match$0[2],
      v = match$0[1],
      _r_ = caml_call2(f, i, v);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _r_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : find_mapi(rest, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _q_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _q_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _p_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _p_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _n_ =
       find_mapi
        (t,
         function(i, elt){
          var _o_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _o_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _n_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _l_ =
       find_mapi
        (t,
         function(i, elt){
          var _m_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _m_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _l_,
             function(param){return param ? 0 : 1;});
   }
   function iteri(how, t, f){
    return fold_mapi(how, t)(0, f, function(param, _k_){return 0;});
   }
   function mapi(how, t, f){
    var
     _i_ =
       fold_mapi(how, t)
        (0,
         function(i, a){return caml_call2(f, i, a);},
         function(bs, b){return [0, b, bs];});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _i_,
             function(bs){
              var _j_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Sequence[109], _j_);
             });
   }
   function filter_mapi(how, t, f){
    var
     _g_ =
       fold_mapi(how, t)
        (0,
         function(i, a){return caml_call2(f, i, a);},
         function(bs, maybe_v){
          if(! maybe_v) return bs;
          var b = maybe_v[1];
          return [0, b, bs];
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _g_,
             function(bs){
              var _h_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Sequence[109], _h_);
             });
   }
   function concat_mapi(how, t, f){
    var _e_ = Core_Sequence[70], _f_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _f_, _e_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, a){
              var _d_ = caml_call2(f, i, a);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(param){return param ? [0, a] : 0;});
             });
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_Sequence[83], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_sequ);
   var
    Async_kernel_Deferred_sequence =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (17, Async_kernel_Deferred_sequence, cst_Async_kernel_Deferred_sequ);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred = "Async_kernel__Deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Deferred1[1],
    invariant = Async_kernel_Deferred1[2],
    create = Async_kernel_Deferred1[4],
    peek = Async_kernel_Deferred1[5],
    value_exn = Async_kernel_Deferred1[6],
    is_determined = Async_kernel_Deferred1[7],
    upon = Async_kernel_Deferred1[8],
    never = Async_kernel_Deferred1[12],
    symbol_bind = Async_kernel_Deferred1[14],
    symbol_map = Async_kernel_Deferred1[15],
    Monad_infix = Async_kernel_Deferred1[16],
    bind = Async_kernel_Deferred1[17],
    map = Async_kernel_Deferred1[18],
    join = Async_kernel_Deferred1[19],
    ignore_m = Async_kernel_Deferred1[20],
    return$0 = Async_kernel_Deferred1[21],
    Let_syntax = Async_kernel_Deferred1[22],
    unit = Async_kernel_Deferred1[23],
    both = Async_kernel_Deferred1[24],
    Infix = Async_kernel_Deferred1[25],
    don_t_wait_for = Async_kernel_Deferred1[26],
    Choice = Async_kernel_Deferred1[27],
    choice = Async_kernel_Deferred1[29],
    enabled = Async_kernel_Deferred1[30],
    choose = Async_kernel_Deferred1[32],
    any = Async_kernel_Deferred1[34],
    any_unit = Async_kernel_Deferred1[35],
    for$0 = Async_kernel_Deferred1[36],
    repeat_until_finished = Async_kernel_Deferred1[37],
    forever = Async_kernel_Deferred1[38],
    all = Async_kernel_Deferred1[42],
    all_unit = Async_kernel_Deferred1[43],
    ok = Async_kernel_Deferred1[44];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred);
   var
    _a_ = Let_syntax[4],
    Async_kernel_Deferred =
      [0,
       sexp_of_t,
       invariant,
       create,
       upon,
       peek,
       value_exn,
       is_determined,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       [0,
        Let_syntax[3],
        Let_syntax[1],
        Let_syntax[2],
        [0, _a_[5], _a_[1], _a_[2], _a_[3], _a_[4]]],
       [0, Infix[1], Infix[2], Infix[3]],
       unit,
       never,
       both,
       all,
       all_unit,
       any,
       any_unit,
       don_t_wait_for,
       Choice,
       choice,
       enabled,
       choose,
       for$0,
       repeat_until_finished,
       forever,
       ok];
   runtime.caml_register_global
    (12, Async_kernel_Deferred, cst_Async_kernel_Deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Clock_ns, Async_kernel__Time_ns, Core__Date, Core__Time_float, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Require_expli =
      "Async_kernel__Require_explicit_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Core_Date = global_data.Core__Date,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core_Time_float = global_data.Core__Time_float,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Require_expli);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1
    (Expect_test_collector[5][1], "src/require_explicit_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    every = Async_kernel_Clock_ns[10],
    with_timeout = Async_kernel_Clock_ns[5];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Require_expli);
   var
    Async_kernel_Require_explicit_ =
      [0,
       Async_kernel_Clock_ns,
       [0,
        Async_kernel_Time_ns[1],
        Async_kernel_Time_ns[2],
        Async_kernel_Time_ns[3],
        Async_kernel_Time_ns[4],
        Async_kernel_Time_ns[5],
        Async_kernel_Time_ns[6],
        Async_kernel_Time_ns[7],
        Async_kernel_Time_ns[8],
        Async_kernel_Time_ns[9],
        Async_kernel_Time_ns[10],
        Async_kernel_Time_ns[11],
        Async_kernel_Time_ns[12],
        Async_kernel_Time_ns[13],
        Async_kernel_Time_ns[14],
        Async_kernel_Time_ns[15],
        Async_kernel_Time_ns[16],
        Async_kernel_Time_ns[17],
        Async_kernel_Time_ns[18],
        Async_kernel_Time_ns[19],
        Async_kernel_Time_ns[20],
        Async_kernel_Time_ns[21],
        Async_kernel_Time_ns[22],
        Async_kernel_Time_ns[23],
        Async_kernel_Time_ns[24],
        Async_kernel_Time_ns[25],
        Async_kernel_Time_ns[26],
        Async_kernel_Time_ns[27],
        Async_kernel_Time_ns[28],
        Async_kernel_Time_ns[29],
        Async_kernel_Time_ns[30],
        Async_kernel_Time_ns[31],
        Async_kernel_Time_ns[32],
        Async_kernel_Time_ns[33],
        Async_kernel_Time_ns[34],
        Async_kernel_Time_ns[35],
        Async_kernel_Time_ns[36],
        Async_kernel_Time_ns[37],
        Async_kernel_Time_ns[38],
        Async_kernel_Time_ns[39],
        Async_kernel_Time_ns[40],
        Async_kernel_Time_ns[41],
        Async_kernel_Time_ns[42],
        Async_kernel_Time_ns[43],
        Async_kernel_Time_ns[44],
        Async_kernel_Time_ns[45],
        Async_kernel_Time_ns[46],
        Async_kernel_Time_ns[47],
        Async_kernel_Time_ns[48],
        Async_kernel_Time_ns[49],
        Async_kernel_Time_ns[51],
        Async_kernel_Time_ns[52],
        Async_kernel_Time_ns[53],
        Async_kernel_Time_ns[54],
        Async_kernel_Time_ns[55],
        Async_kernel_Time_ns[56],
        Async_kernel_Time_ns[57],
        Async_kernel_Time_ns[58],
        Async_kernel_Time_ns[59],
        Async_kernel_Time_ns[60],
        Async_kernel_Time_ns[61],
        Async_kernel_Time_ns[62],
        Async_kernel_Time_ns[63],
        Async_kernel_Time_ns[64],
        Async_kernel_Time_ns[65],
        Async_kernel_Time_ns[66],
        Async_kernel_Time_ns[67],
        Async_kernel_Time_ns[68],
        Async_kernel_Time_ns[69],
        Async_kernel_Time_ns[70],
        Async_kernel_Time_ns[71],
        Async_kernel_Time_ns[72],
        Async_kernel_Time_ns[73],
        Async_kernel_Time_ns[74],
        Async_kernel_Time_ns[75],
        Async_kernel_Time_ns[76],
        Async_kernel_Time_ns[77],
        Async_kernel_Time_ns[78],
        Async_kernel_Time_ns[79],
        Async_kernel_Time_ns[80],
        Async_kernel_Time_ns[81],
        Async_kernel_Time_ns[82],
        Async_kernel_Time_ns[83],
        Async_kernel_Time_ns[84],
        Async_kernel_Time_ns[85],
        Async_kernel_Time_ns[86],
        Async_kernel_Time_ns[87],
        Async_kernel_Time_ns[88],
        Async_kernel_Time_ns[89],
        Async_kernel_Time_ns[90],
        Async_kernel_Time_ns[91],
        Async_kernel_Time_ns[92],
        Async_kernel_Time_ns[93],
        Async_kernel_Time_ns[94],
        Async_kernel_Time_ns[95],
        Async_kernel_Time_ns[96],
        Async_kernel_Time_ns[97],
        Async_kernel_Time_ns[98],
        Async_kernel_Time_ns[99],
        Async_kernel_Time_ns[100],
        Async_kernel_Time_ns[101],
        Async_kernel_Time_ns[102],
        Async_kernel_Time_ns[103],
        Async_kernel_Time_ns[104],
        Async_kernel_Time_ns[105],
        Async_kernel_Time_ns[106],
        Async_kernel_Time_ns[107],
        Async_kernel_Time_ns[108],
        Async_kernel_Time_ns[109],
        Async_kernel_Time_ns[110],
        Async_kernel_Time_ns[111],
        Async_kernel_Time_ns[112],
        Async_kernel_Time_ns[113],
        Async_kernel_Time_ns[50]],
       [0,
        Core_Time_float[1],
        Core_Time_float[2],
        Core_Time_float[3],
        Core_Time_float[4],
        Core_Time_float[5],
        Core_Time_float[6],
        Core_Time_float[7],
        Core_Time_float[8],
        Core_Time_float[9],
        Core_Time_float[10],
        Core_Time_float[11],
        Core_Time_float[12],
        Core_Time_float[14],
        Core_Time_float[15],
        Core_Time_float[16],
        Core_Time_float[17],
        Core_Time_float[18],
        Core_Time_float[19],
        Core_Time_float[20],
        Core_Time_float[21],
        Core_Time_float[22],
        Core_Time_float[23],
        Core_Time_float[24],
        Core_Time_float[25],
        Core_Time_float[26],
        Core_Time_float[27],
        Core_Time_float[28],
        Core_Time_float[29],
        Core_Time_float[30],
        Core_Time_float[31],
        Core_Time_float[32],
        Core_Time_float[33],
        Core_Time_float[34],
        Core_Time_float[35],
        Core_Time_float[36],
        Core_Time_float[37],
        Core_Time_float[38],
        Core_Time_float[39],
        Core_Time_float[40],
        Core_Time_float[41],
        Core_Time_float[42],
        Core_Time_float[43],
        Core_Time_float[45],
        Core_Time_float[46],
        Core_Time_float[48],
        Core_Time_float[49],
        Core_Time_float[50],
        Core_Time_float[51],
        Core_Time_float[52],
        Core_Time_float[53],
        Core_Time_float[54],
        Core_Time_float[55],
        Core_Time_float[56],
        Core_Time_float[57],
        Core_Time_float[58],
        Core_Time_float[59],
        Core_Time_float[60],
        Core_Time_float[61],
        Core_Time_float[62],
        Core_Time_float[63],
        Core_Time_float[64],
        Core_Time_float[65],
        Core_Time_float[66],
        Core_Time_float[67],
        Core_Time_float[68],
        Core_Time_float[69],
        Core_Time_float[70],
        Core_Time_float[71],
        Core_Time_float[72],
        Core_Time_float[73],
        Core_Time_float[74],
        Core_Time_float[75],
        Core_Time_float[76],
        Core_Time_float[77],
        Core_Time_float[78],
        Core_Time_float[79],
        Core_Time_float[80],
        Core_Time_float[81],
        Core_Time_float[82],
        Core_Time_float[93],
        Core_Time_float[94],
        Core_Time_float[95],
        Core_Time_float[96],
        Core_Time_float[97],
        Core_Time_float[98],
        Core_Time_float[99],
        Core_Time_float[100],
        Core_Time_float[101],
        Core_Time_float[102],
        Core_Time_float[103],
        Core_Time_float[104],
        Core_Time_float[105],
        Core_Time_float[106],
        Core_Time_float[107],
        Core_Time_float[108],
        Core_Time_float[109],
        Core_Time_float[110],
        Core_Time_float[111],
        Core_Time_float[112],
        Core_Time_float[113],
        Core_Time_float[114],
        Core_Time_float[115],
        Core_Time_float[47]],
       [0,
        Async_kernel_Async_kernel_sche[1],
        Async_kernel_Async_kernel_sche[2],
        Async_kernel_Async_kernel_sche[3],
        Async_kernel_Async_kernel_sche[4],
        Async_kernel_Async_kernel_sche[5],
        Async_kernel_Async_kernel_sche[6],
        Async_kernel_Async_kernel_sche[7],
        Async_kernel_Async_kernel_sche[8],
        Async_kernel_Async_kernel_sche[9],
        Async_kernel_Async_kernel_sche[10],
        Async_kernel_Async_kernel_sche[11],
        Async_kernel_Async_kernel_sche[12],
        Async_kernel_Async_kernel_sche[13],
        Async_kernel_Async_kernel_sche[16],
        Async_kernel_Async_kernel_sche[17],
        Async_kernel_Async_kernel_sche[18],
        Async_kernel_Async_kernel_sche[19],
        Async_kernel_Async_kernel_sche[20],
        Async_kernel_Async_kernel_sche[21],
        Async_kernel_Async_kernel_sche[22],
        Async_kernel_Async_kernel_sche[23],
        Async_kernel_Async_kernel_sche[24],
        Async_kernel_Async_kernel_sche[25],
        Async_kernel_Async_kernel_sche[26],
        Async_kernel_Async_kernel_sche[27],
        Async_kernel_Async_kernel_sche[28],
        Async_kernel_Async_kernel_sche[29],
        Async_kernel_Async_kernel_sche[30],
        Async_kernel_Async_kernel_sche[31],
        Async_kernel_Async_kernel_sche[32],
        Async_kernel_Async_kernel_sche[14],
        Async_kernel_Async_kernel_sche[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[20],
        Core_Date[21],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[41],
        Core_Date[44],
        Core_Date[45],
        Core_Date[46],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[92],
        Core_Date[94],
        Core_Date[95],
        Core_Date[96],
        Core_Date[93]],
       at,
       after,
       every,
       with_timeout];
   runtime.caml_register_global
    (16, Async_kernel_Require_explicit_, cst_Async_kernel_Require_expli);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Pipe
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_queue, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Base__Field, Core, Core__Bag, Core__Bool, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Queue, Core__Sequence, Core__Sexp, Core__Source_code_position, Expect_test_collector, Pairing_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Pipe = "Async_kernel__Pipe",
    cst_Eof = "Eof",
    cst_Ok = "Ok",
    cst_Reader_closed = "Reader_closed",
    cst$0 = "_",
    cst_async_kernel = "async_kernel",
    cst_blocked_flushes = "blocked_flushes",
    cst_blocked_reads = "blocked_reads",
    cst_consumer = "consumer",
    cst_consumers = "consumers",
    cst_exn = "exn",
    cst_pipe = "pipe",
    cst_pushback = "pushback",
    cst_size_budget = "size_budget",
    cst_src_pipe_ml = "src/pipe.ml",
    cst_values_read = "values_read",
    cst_wants = "wants",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Pairing_heap = global_data.Pairing_heap,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Sequence = global_data.Core__Sequence,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_queue = global_data.Async_kernel__Deferred_queue,
    Core_Sexp = global_data.Core__Sexp,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Core_Bag = global_data.Core__Bag,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Bool = global_data.Core__Bool,
    Base_Field = global_data.Base__Field,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Pipe);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_pipe_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    show_debug_messages = [0, 0],
    check_invariant = [0, 0],
    _a_ = [0, cst_Ok],
    _b_ = [0, cst_Reader_closed];
   function compare(a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(17724 <= a_001){
     if(17724 === b_002) return 0;
    }
    else if(-402004920 === b_002) return 0;
    return runtime.caml_int_compare(a_001, b_002);
   }
   function sexp_of_t(param){return 17724 <= param ? _a_ : _b_;}
   function equal(x_003, x_004){return 0 === compare(x_003, x_004) ? 1 : 0;}
   function combine(l){
    var _c4_ = caml_call1(Async_kernel_Deferred[21], l);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _c4_,
             function(l){
              return caml_call3(Core_List[6], l, -402004920, equal)
                      ? -402004920
                      : 17724;
             });
   }
   function values_read(r){return r[2];}
   function set_values_read(r, v){r[2] = v; return 0;}
   var
    values_read$0 =
      [0,
       function(param){return 0;},
       cst_values_read,
       [0, set_values_read],
       values_read,
       function(r, v){return [0, r[1], v, r[3]];}],
    _c_ = [0, "downstream_flushed"],
    _d_ = [0, "Have_been_sent_downstream"],
    _e_ = [0, cst_values_read],
    _f_ = [0, "pipe_id"],
    _g_ = [0, "Have_not_been_sent_downstream"],
    _h_ = [0, cst_pipe],
    _i_ = [0, cst_exn],
    cst_Pipe_Consumer_invariant_fa = "Pipe.Consumer.invariant failed",
    _j_ = [0, cst_src_pipe_ml, 79, 54];
   function sexp_of_t$0(param){
    var
     pipe_id_009 = param[1],
     values_read_011 = param[2],
     arg_015 = caml_call1(Sexplib0_Sexp_conv[24], function(_c3_){return 0;}),
     bnds_008 = [0, [1, [0, _c_, [0, arg_015, 0]]], 0];
    if(typeof values_read_011 === "number")
     var arg_012 = _d_;
    else
     var
      v_013 = values_read_011[2],
      arg_012 =
        [1,
         [0, _g_, [0, caml_call2(Async_kernel_Ivar[9], Core[518], v_013), 0]]];
    var
     bnds_008$0 = [0, [1, [0, _e_, [0, arg_012, 0]]], bnds_008],
     arg_010 = caml_call1(Core[356], pipe_id_009),
     bnds_008$1 = [0, [1, [0, _f_, [0, arg_010, 0]]], bnds_008$0];
    return [1, bnds_008$1];
   }
   function invariant(t){
    try{
     var param = caml_call2(Base_Field[3], values_read$0, t);
     if(typeof param !== "number"){
      var ivar = param[2];
      if(! caml_call1(Async_kernel_Ivar[16], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     }
     return;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _c0_ = [0, [1, [0, _h_, [0, sexp_of_t$0(t), 0]]], 0],
      _c1_ = [0, [1, [0, _i_, [0, caml_call1(Core[537], exn), 0]]], _c0_],
      _c2_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_Consumer_invariant_fa),
          _c1_]];
     return caml_call1(Core[253], _c2_);
    }
   }
   function start(t){
    return typeof t[2] === "number"
            ? (t
               [2]
              = [0, -122467239, caml_call1(Async_kernel_Ivar[12], 0)],
              0)
            : 0;
   }
   function values_sent_downstream(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var ivar = match[2];
    caml_call2(Async_kernel_Ivar[14], ivar, 0);
    t[2] = -758792467;
    return 0;
   }
   function values_sent_downstream_and_flu(t){
    var match = t[2];
    if(typeof match === "number") return caml_call1(t[3], 0);
    var
     when_sent_downstream = match[2],
     _cZ_ = caml_call1(Async_kernel_Ivar[18], when_sent_downstream);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _cZ_,
             function(param){return caml_call1(t[3], 0);});
   }
   function consumer(r){return r[2];}
   function wants(r){return r[1];}
   var
    consumer$0 =
      [0,
       function(param){return 0;},
       cst_consumer,
       0,
       consumer,
       function(r, v){return [0, r[1], v];}],
    wants$0 =
      [0,
       function(param){return 0;},
       cst_wants,
       0,
       wants,
       function(r, v){return [0, v, r[2]];}],
    _k_ = [0, cst_Eof],
    _l_ = [0, cst_Ok],
    _m_ = [0, "Zero"],
    _n_ = [0, cst_Eof],
    _o_ = [0, cst_Ok],
    _p_ = [0, "One"],
    _q_ = [0, cst_Eof],
    _r_ = [0, cst_Ok],
    _s_ = [0, "At_most"],
    _t_ = [0, cst_consumer],
    _u_ = [0, cst_wants],
    _z_ = [0, cst_Ok],
    _A_ = [0, cst_Reader_closed],
    _B_ = [0, "ready"],
    _C_ = [0, "fill_when_num_values_read"];
   function sexp_of_t$1(of_a_029, param){
    var
     consumer_033 = param[2],
     wants_031 = param[1],
     arg_034 = caml_call2(Core[454], sexp_of_t$0, consumer_033),
     bnds_030 = [0, [1, [0, _t_, [0, arg_034, 0]]], 0];
    switch(wants_031[0]){
      case 0:
       var
        arg0_018 = wants_031[1],
        res0_019 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){return 3456156 <= param ? _k_ : _l_;},
            arg0_018),
        arg_032 = [1, [0, _m_, [0, res0_019, 0]]];
       break;
      case 1:
       var
        arg0_021 = wants_031[1],
        res0_022 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){
             if(typeof param === "number") return _n_;
             var v_020 = param[2];
             return [1, [0, _o_, [0, caml_call1(of_a_029, v_020), 0]]];
            },
            arg0_021),
        arg_032 = [1, [0, _p_, [0, res0_022, 0]]];
       break;
      default:
       var
        arg1_025 = wants_031[2],
        arg0_024 = wants_031[1],
        res0_026 = caml_call1(Core[356], arg0_024),
        res1_027 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){
             if(typeof param === "number") return _q_;
             var v_023 = param[2];
             return [1,
                     [0,
                      _r_,
                      [0, caml_call2(Core_Queue[11], of_a_029, v_023), 0]]];
            },
            arg1_025),
        arg_032 = [1, [0, _s_, [0, res0_026, [0, res1_027, 0]]]];
    }
    var bnds_030$0 = [0, [1, [0, _u_, [0, arg_032, 0]]], bnds_030];
    return [1, bnds_030$0];
   }
   function fill_with_eof(t){
    var match = t[1];
    switch(match[0]){
      case 0:
       var i = match[1]; return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      case 1:
       var i$0 = match[1];
       return caml_call2(Async_kernel_Ivar[14], i$0, 3456156);
      default:
       var i$1 = match[2];
       return caml_call2(Async_kernel_Ivar[14], i$1, 3456156);
    }
   }
   function fill_when_num_values_read(r){return r[1];}
   function sexp_of_t$2(param){
    var
     ready_039 = param[2],
     fill_when_num_values_read_037 = param[1],
     arg_040 =
       caml_call2
        (Async_kernel_Ivar[9],
         function(param){return 17724 <= param ? _z_ : _A_;},
         ready_039),
     bnds_036 = [0, [1, [0, _B_, [0, arg_040, 0]]], 0],
     arg_038 = caml_call1(Core[356], fill_when_num_values_read_037),
     bnds_036$0 = [0, [1, [0, _C_, [0, arg_038, 0]]], bnds_036];
    return [1, bnds_036$0];
   }
   function fill(t, v){return caml_call2(Async_kernel_Ivar[14], t[2], v);}
   function consumers(r){return r[11];}
   function set_consumers(r, v){r[11] = v; return 0;}
   function blocked_reads(r){return r[8];}
   function blocked_flushes(r){return r[7];}
   function pushback(r){return r[5];}
   function set_pushback(r, v){r[5] = v; return 0;}
   function size_budget(r){return r[4];}
   function set_size_budget(r, v){r[4] = v; return 0;}
   var
    consumers$0 =
      [0,
       function(param){return 0;},
       cst_consumers,
       [0, set_consumers],
       consumers,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v,
                r[12]];
       }],
    blocked_reads$0 =
      [0,
       function(param){return 0;},
       cst_blocked_reads,
       0,
       blocked_reads,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    blocked_flushes$0 =
      [0,
       function(param){return 0;},
       cst_blocked_flushes,
       0,
       blocked_flushes,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    pushback$0 =
      [0,
       function(param){return 0;},
       cst_pushback,
       [0, set_pushback],
       pushback,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    size_budget$0 =
      [0,
       function(param){return 0;},
       cst_size_budget,
       [0, set_size_budget],
       size_budget,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    _v_ = [0, cst$0],
    _w_ = [0, cst_pipe],
    _x_ = [0, cst_exn],
    cst_Pipe_Blocked_read_invarian = "Pipe.Blocked_read.invariant failed",
    _y_ = [0, cst_src_pipe_ml, 140, 33],
    _D_ = [0, "upstream_flusheds"],
    _E_ = [0, cst_consumers],
    _F_ = [0, "read_closed"],
    _G_ = [0, "closed"],
    _H_ = [0, cst_blocked_reads],
    _I_ = [0, cst_blocked_flushes],
    _J_ = [0, "num_values_read"],
    _K_ = [0, cst_pushback],
    _L_ = [0, cst_size_budget],
    _M_ = [0, "buffer"],
    _N_ = [0, "info"],
    _O_ = [0, "id"],
    _P_ = [0, cst$0],
    _Q_ = [0, cst$0],
    _R_ = [0, cst_pipe],
    _S_ = [0, cst_exn],
    cst_Pipe_invariant_failed = "Pipe.invariant failed",
    _T_ = [0, cst_src_pipe_ml, 293, 13],
    _U_ = [0, cst_src_pipe_ml, 284, 13],
    _V_ = [0, cst_src_pipe_ml, 286, 31],
    _W_ = [0, cst_src_pipe_ml, 281, 36],
    _X_ = [0, cst_src_pipe_ml, 269, 13],
    _Y_ = [0, cst_src_pipe_ml, 276, 30],
    _Z_ = [0, cst_src_pipe_ml, 270, 11],
    ___ = [0, cst_src_pipe_ml, 261, 11],
    _$_ = [0, cst_src_pipe_ml, 258, 46],
    _aa_ = [0, cst_src_pipe_ml, 300, 2],
    _ab_ = [0, cst_src_pipe_ml, 307, 2];
   function sexp_of_pipe(of_a_041, of_phantom_042, param){
    var
     id_044 = param[1],
     info_046 = param[2],
     buffer_050 = param[3],
     size_budget_052 = param[4],
     pushback_054 = param[5],
     num_values_read_056 = param[6],
     read_closed_064 = param[10],
     closed_062 = param[9],
     blocked_reads_060 = param[8],
     blocked_flushes_058 = param[7],
     consumers_066 = param[11],
     upstream_flusheds_068 = param[12],
     arg_069 =
       caml_call2
        (Core_Bag[3],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_cY_){return 0;});
         },
         upstream_flusheds_068),
     bnds_043 = [0, [1, [0, _D_, [0, arg_069, 0]]], 0],
     arg_067 = caml_call2(Core[421], sexp_of_t$0, consumers_066),
     bnds_043$0 = [0, [1, [0, _E_, [0, arg_067, 0]]], bnds_043],
     arg_065 = caml_call2(Async_kernel_Ivar[9], Core[518], read_closed_064),
     bnds_043$1 = [0, [1, [0, _F_, [0, arg_065, 0]]], bnds_043$0],
     arg_063 = caml_call2(Async_kernel_Ivar[9], Core[518], closed_062),
     bnds_043$2 = [0, [1, [0, _G_, [0, arg_063, 0]]], bnds_043$1],
     arg_061 =
       caml_call2
        (Core_Queue[11],
         function(_cX_){return sexp_of_t$1(of_a_041, _cX_);},
         blocked_reads_060),
     bnds_043$3 = [0, [1, [0, _H_, [0, arg_061, 0]]], bnds_043$2],
     arg_059 = caml_call2(Core_Queue[11], sexp_of_t$2, blocked_flushes_058),
     bnds_043$4 = [0, [1, [0, _I_, [0, arg_059, 0]]], bnds_043$3],
     arg_057 = caml_call1(Core[356], num_values_read_056),
     bnds_043$5 = [0, [1, [0, _J_, [0, arg_057, 0]]], bnds_043$4],
     arg_055 = caml_call2(Async_kernel_Ivar[9], Core[518], pushback_054),
     bnds_043$6 = [0, [1, [0, _K_, [0, arg_055, 0]]], bnds_043$5],
     arg_053 = caml_call1(Core[356], size_budget_052),
     bnds_043$7 = [0, [1, [0, _L_, [0, arg_053, 0]]], bnds_043$6],
     arg_051 = caml_call2(Core_Queue[11], of_a_041, buffer_050),
     bnds_043$8 = [0, [1, [0, _M_, [0, arg_051, 0]]], bnds_043$7];
    if(info_046)
     var
      v_047 = info_046[1],
      arg_049 = caml_call1(Core_Sexp[90], v_047),
      bnd_048 = [1, [0, _N_, [0, arg_049, 0]]],
      bnds_043$9 = [0, bnd_048, bnds_043$8];
    else
     var bnds_043$9 = bnds_043$8;
    var
     arg_045 = caml_call2(Sexp_hidden_in_test[10], Core[356], id_044),
     bnds_043$10 = [0, [1, [0, _O_, [0, arg_045, 0]]], bnds_043$9];
    return [1, bnds_043$10];
   }
   function hash(t){return caml_call1(Core_Hashtbl[1], t[1]);}
   function equal$0(t1, t2){return caml_call2(Core[246], t1, t2);}
   function compare$0(t1, t2){return caml_call2(Core_Int[91], t1[1], t2[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[9]);}
   function is_read_closed(t){
    return caml_call1(Async_kernel_Ivar[17], t[10]);
   }
   function closed(t){return caml_call1(Async_kernel_Ivar[18], t[9]);}
   function pushback$1(t){return caml_call1(Async_kernel_Ivar[18], t[5]);}
   function length(t){return caml_call1(Core_Queue[14], t[3]);}
   function is_empty(t){
    var _cW_ = length(t);
    return caml_call2(Async_kernel_Import[3], _cW_, 0);
   }
   function invariant$0(x_073){
    try{
     var size_budget = caml_call2(Base_Field[3], size_budget$0, x_073);
     if(! caml_call2(Async_kernel_Import[1], size_budget, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
     var
      pushback = caml_call2(Base_Field[3], pushback$0, x_073),
      _cN_ = x_073[4],
      _cO_ = length(x_073),
      _cP_ = caml_call2(Async_kernel_Import[2], _cO_, _cN_),
      _cQ_ = _cP_ || is_closed(x_073),
      _cR_ = caml_call1(Async_kernel_Ivar[17], pushback);
     if(! caml_call2(Core_Bool[27], _cR_, _cQ_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
     var
      blocked_flushes = caml_call2(Base_Field[3], blocked_flushes$0, x_073);
     caml_call2
      (Core_Queue[16],
       blocked_flushes,
       function(f){
        if(caml_call2(Async_kernel_Import[4], f[1], x_073[6])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
       });
     var
      _cK_ = Core_Int[91],
      _cL_ = caml_call1(Core_Queue[26], blocked_flushes),
      _cM_ = caml_call2(Core_List[72], _cL_, fill_when_num_values_read);
     if(! caml_call2(Core_List[140], _cM_, _cK_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
     if(is_empty(x_073) && ! caml_call1(Core_Queue[15], blocked_flushes))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
     var blocked_reads = caml_call2(Base_Field[3], blocked_reads$0, x_073);
     if(1 - is_empty(x_073) && ! caml_call1(Core_Queue[15], blocked_reads))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
     caml_call2
      (Core_Queue[16],
       blocked_reads,
       function(x_035){
        try{
         var param = caml_call2(Base_Field[3], wants$0, x_035);
         if(2 === param[0]){
          var i = param[1];
          if(! caml_call2(Async_kernel_Import[4], i, 0))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
         }
         var param$0 = caml_call2(Base_Field[3], consumer$0, x_035);
         if(param$0){var consumer = param$0[1]; invariant(consumer);}
        }
        catch(exn$0){
         var
          exn = caml_wrap_exception(exn$0),
          _cS_ =
            [0,
             [1,
              [0,
               _w_,
               [0, sexp_of_t$1(function(param){return _v_;}, x_035), 0]]],
             0],
          _cT_ = [0, [1, [0, _x_, [0, caml_call1(Core[537], exn), 0]]], _cS_],
          _cU_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Pipe_Blocked_read_invarian),
              _cT_]];
         caml_call1(Core[253], _cU_);
        }
        var match = x_035[1];
        switch(match[0]){
          case 0:
           var i$0 = match[1], _cV_ = caml_call1(Async_kernel_Ivar[16], i$0);
           break;
          case 1:
           var i$1 = match[1], _cV_ = caml_call1(Async_kernel_Ivar[16], i$1);
           break;
          default:
           var i$2 = match[2], _cV_ = caml_call1(Async_kernel_Ivar[16], i$2);
        }
        if(_cV_) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
       });
     if(is_closed(x_073) && ! caml_call1(Core_Queue[15], blocked_reads))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
     var l = caml_call2(Base_Field[3], consumers$0, x_073);
     caml_call2
      (Core_List[9],
       l,
       function(consumer){
        invariant(consumer);
        if(caml_call2(Async_kernel_Import[3], consumer[1], x_073[1]))
         return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
       });
     var _cJ_ = 0;
     return _cJ_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _cG_ =
        [0,
         [1,
          [0,
           _R_,
           [0,
            sexp_of_pipe
             (function(param){return _Q_;},
              function(param){return _P_;},
              x_073),
            0]]],
         0],
      _cH_ = [0, [1, [0, _S_, [0, caml_call1(Core[537], exn), 0]]], _cG_],
      _cI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_invariant_failed),
          _cH_]];
     return caml_call1(Core[253], _cI_);
    }
   }
   function sexp_of_phantom(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
   }
   function sexp_of_t$3(of_a_074, x_075){
    return sexp_of_pipe(of_a_074, sexp_of_phantom, x_075);
   }
   function sexp_of_phantom$0(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
   }
   function sexp_of_t$4(of_a_076, x_077){
    return sexp_of_pipe(of_a_076, sexp_of_phantom$0, x_077);
   }
   var
    id_ref = [0, 0],
    _ac_ = [0, cst_size_budget],
    cst_negative_size_budget = "negative size_budget",
    _ad_ = [0, cst$0],
    _ae_ = [0, cst$0],
    cst_close = "close",
    _af_ = [0, cst$0],
    _ag_ = [0, cst$0],
    cst_close_read = "close_read",
    _ah_ = [0, 3804260],
    _ai_ = [0, 523273847],
    _aj_ = [0, 3804260],
    _ak_ = [0, 523273847],
    _al_ = [0, cst_src_pipe_ml, 456, 2],
    _am_ = [0, cst_src_pipe_ml, 465, 2],
    _an_ = [0, cst$0],
    _ao_ = [0, cst$0],
    cst_write = "write",
    _ap_ = [0, cst$0],
    _aq_ = [0, cst$0],
    _ar_ = [0, cst_pipe],
    cst_write_to_closed_pipe = "write to closed pipe",
    _as_ = [0, cst$0],
    _at_ = [0, cst_pipe],
    _au_ = [0, cst_consumer],
    cst_Attempt_to_use_consumer_wi = "Attempt to use consumer with wrong pipe",
    _av_ = [0, cst$0],
    _aw_ = [0, cst$0],
    cst_read_now = "read_now",
    _ax_ = [0, cst_src_pipe_ml, 574, 4],
    _ay_ = [0, "max_queue_length"],
    cst_max_queue_length_0 = "max_queue_length <= 0",
    cst_read = "read'",
    cst_read$0 = "read",
    _az_ = [0, cst_src_pipe_ml, 623, 4],
    cst_Pipe_read_exn_received_EOF = "Pipe.read_exn: received EOF",
    cst_values_available = "values_available",
    _aA_ = [0, "here"],
    cst_Pipe_read_choice_single_co =
      "Pipe.read_choice_single_consumer_exn: choice was enabled but pipe is empty; this is likely due to a race condition with one or more other consumers",
    cst_read_exactly = "read_exactly",
    _aB_ = [0, "num_values"],
    cst_Pipe_read_exactly_got_num_ = "Pipe.read_exactly got num_values <= 0",
    _aC_ = [0, cst_src_pipe_ml, 674, 6],
    _aD_ = [0, "When_value_read"],
    _aE_ = [0, "When_value_processed"],
    _aF_ = [0, "Consumer"];
   function create_internal(size_budget, info, initial_buffer){
    id_ref[1]++;
    var
     _cA_ = caml_call1(Core_Bag[22], 0),
     _cB_ = caml_call1(Async_kernel_Ivar[12], 0),
     _cC_ = caml_call1(Async_kernel_Ivar[12], 0),
     _cD_ = caml_call2(Core_Queue[61], 0, 0),
     _cE_ = caml_call2(Core_Queue[61], 0, 0),
     _cF_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        id_ref[1],
        info,
        initial_buffer,
        size_budget,
        _cF_,
        0,
        _cE_,
        _cD_,
        _cC_,
        _cB_,
        0,
        _cA_];
    return t;
   }
   function validate_size_budget(size_budget){
    if(! caml_call2(Async_kernel_Import[5], size_budget, 0))
     return size_budget;
    var
     _cy_ = [0, [1, [0, _ac_, [0, caml_call1(Core[356], size_budget), 0]]], 0],
     _cz_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_negative_size_budget), _cy_]];
    return caml_call1(Core[253], _cz_);
   }
   function create(size_budget, info, param){
    if(size_budget)
     var v = size_budget[1], size_budget$0 = validate_size_budget(v);
    else
     var size_budget$0 = 0;
    var
     t =
       create_internal(size_budget$0, info, caml_call2(Core_Queue[61], 0, 0));
    caml_call2(Async_kernel_Ivar[14], t[5], 0);
    if(check_invariant[1]) invariant$0(t);
    return [0, t, t];
   }
   function update_pushback(t){
    var _cu_ = t[4], _cv_ = length(t);
    if(! caml_call2(Async_kernel_Import[2], _cv_, _cu_) && ! is_closed(t)){
     var
      _cw_ = caml_call1(Async_kernel_Ivar[17], t[5]),
      _cx_ = _cw_ ? (t[5] = caml_call1(Async_kernel_Ivar[12], 0), 0) : _cw_;
     return _cx_;
    }
    return caml_call2(Async_kernel_Ivar[15], t[5], 0);
   }
   function close(t){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_close,
       t,
       function(x_078){
        return sexp_of_pipe
                (function(param){return _ae_;},
                 function(param){return _ad_;},
                 x_078);
       });
    if(check_invariant[1]) invariant$0(t);
    var _ct_ = 1 - is_closed(t);
    if(! _ct_) return _ct_;
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    if(is_empty(t)){
     caml_call2(Core_Queue[16], t[8], fill_with_eof);
     caml_call1(Core_Queue[47], t[8]);
    }
    return update_pushback(t);
   }
   function close_read(t){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_close_read,
       t,
       function(x_079){
        return sexp_of_pipe
                (function(param){return _ag_;},
                 function(param){return _af_;},
                 x_079);
       });
    if(check_invariant[1]) invariant$0(t);
    var _cs_ = 1 - is_read_closed(t);
    return _cs_
            ? (caml_call2
               (Async_kernel_Ivar[14], t[10], 0),
              caml_call2
               (Core_Queue[16],
                t[7],
                function(flush){return fill(flush, -402004920);}),
              caml_call1(Core_Queue[47], t[7]),
              caml_call1(Core_Queue[47], t[3]),
              update_pushback(t),
              close(t))
            : _cs_;
   }
   function create_reader_not_close_on_exc(size_budget, f){
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cr_ = caml_call1(f, w);
    caml_call2
     (Async_kernel_Deferred_std[11], _cr_, function(param){return close(w);});
    return r;
   }
   function create_reader(size_budget, close_on_exception, f){
    if(! close_on_exception)
     return create_reader_not_close_on_exc(size_budget, f);
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cq_ =
       caml_call8
        (Async_kernel_Monitor[23],
         0,
         0,
         0,
         0,
         _ai_,
         _ah_,
         function(param){return caml_call1(f, w);},
         function(param){
          close(w);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _cq_);
    return r;
   }
   function create_writer(size_budget, f){
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cp_ =
       caml_call8
        (Async_kernel_Monitor[23],
         0,
         0,
         0,
         0,
         _ak_,
         _aj_,
         function(param){return caml_call1(f, r);},
         function(param){
          close_read(r);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _cp_);
    return w;
   }
   function values_were_read(t, consumer){
    caml_call2(Core_Option[41], consumer, start);
    for(;;){
     var match = caml_call1(Core_Queue[45], t[7]);
     if(! match) return;
     var
      flush = match[1],
      _cn_ = caml_call2(Async_kernel_Import[1], t[6], flush[1]);
     if(! _cn_) return _cn_;
     caml_call1(Core_Queue[44], t[7]);
     if(consumer){
      var consumer$0 = consumer[1];
      let flush$0 = flush;
      var _co_ = values_sent_downstream_and_flu(consumer$0);
      caml_call2
       (Async_kernel_Deferred_std[11],
        _co_,
        function(flush_result){return fill(flush$0, flush_result);});
     }
     else
      fill(flush, 17724);
    }
   }
   function consume_one(t, consumer){
    var _cm_ = length(t);
    if(! caml_call2(Async_kernel_Import[1], _cm_, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
    var result = caml_call1(Core_Queue[44], t[3]);
    t[6] = t[6] + 1 | 0;
    values_were_read(t, consumer);
    update_pushback(t);
    return result;
   }
   function consume(t, max_queue_length, consumer){
    if(! caml_call2(Async_kernel_Import[1], max_queue_length, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
    var _cl_ = length(t);
    if(caml_call2(Async_kernel_Import[1], max_queue_length, _cl_)){
     var result = t[3];
     t[3] = caml_call2(Core_Queue[61], 0, 0);
     var _ck_ = caml_call1(Core_Queue[14], result);
     t[6] = t[6] + _ck_ | 0;
     values_were_read(t, consumer);
     update_pushback(t);
     return result;
    }
    t[6] = t[6] + max_queue_length | 0;
    values_were_read(t, consumer);
    var result$0 = caml_call2(Core_Queue[61], [0, max_queue_length], 0);
    caml_call4(Core_Queue[64], t[3], result$0, [0, max_queue_length], 0);
    update_pushback(t);
    return result$0;
   }
   function set_size_budget$0(t, size_budget){
    var size_budget$0 = validate_size_budget(size_budget);
    t[4] = size_budget$0;
    return update_pushback(t);
   }
   function start_write(x_081){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_write,
       x_081,
       function(x_080){
        return sexp_of_pipe
                (function(param){return _ao_;},
                 function(param){return _an_;},
                 x_080);
       });
    if(check_invariant[1]) invariant$0(x_081);
    var _ch_ = is_closed(x_081);
    if(! _ch_) return _ch_;
    var
     _ci_ =
       [0,
        [1,
         [0,
          _ar_,
          [0,
           sexp_of_pipe
            (function(param){return _aq_;},
             function(param){return _ap_;},
             x_081),
           0]]],
        0],
     _cj_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_write_to_closed_pipe), _ci_]];
    return caml_call1(Core[253], _cj_);
   }
   function finish_write(t){
    for(;;){
     if(! caml_call1(Core_Queue[15], t[8]) && ! is_empty(t)){
      var
       blocked_read = caml_call1(Core_Queue[44], t[8]),
       consumer = blocked_read[2],
       match = blocked_read[1];
      switch(match[0]){
        case 0:
         var ivar = match[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 17724);
         break;
        case 1:
         var ivar$0 = match[1], _cf_ = [0, 17724, consume_one(t, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$0, _cf_);
         break;
        default:
         var
          ivar$1 = match[2],
          max_queue_length = match[1],
          _cg_ = [0, 17724, consume(t, max_queue_length, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$1, _cg_);
      }
      continue;
     }
     return update_pushback(t);
    }
   }
   function transfer_in_without_pushback(t, from){
    start_write(t);
    caml_call4(Core_Queue[64], from, t[3], 0, 0);
    return finish_write(t);
   }
   function transfer_in(t, from){
    transfer_in_without_pushback(t, from);
    return pushback$1(t);
   }
   function write(t, q){return transfer_in(t, q);}
   function write_without_pushback(t, value){
    start_write(t);
    caml_call2(Core_Queue[41], t[3], value);
    return finish_write(t);
   }
   function write$0(t, value){
    write_without_pushback(t, value);
    return pushback$1(t);
   }
   function write_when_ready(t, f){
    var _ce_ = pushback$1(t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _ce_,
             function(param){
              return is_closed(t)
                      ? -1025106484
                      : [0,
                        17724,
                        caml_call1
                         (f, function(x){return write_without_pushback(t, x);})];
             });
   }
   function write_if_open(t, x){
    return is_closed(t)
            ? caml_call1(Async_kernel_Deferred_std[10], 0)
            : write$0(t, x);
   }
   function write_without_pushback_if_open(t, x){
    var _cd_ = 1 - is_closed(t);
    return _cd_ ? write_without_pushback(t, x) : _cd_;
   }
   function ensure_consumer_matches(consumer, x_083){
    if(! consumer) return;
    var
     consumer$0 = consumer[1],
     _b$_ = caml_call2(Async_kernel_Import[6], x_083[1], consumer$0[1]);
    if(! _b$_) return _b$_;
    function of_a_074(param){return _as_;}
    var
     _ca_ =
       [0,
        [1, [0, _at_, [0, sexp_of_pipe(of_a_074, sexp_of_phantom, x_083), 0]]],
        0],
     _cb_ = [0, [1, [0, _au_, [0, sexp_of_t$0(consumer$0), 0]]], _ca_],
     _cc_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_use_consumer_wi),
         _cb_]];
    return caml_call1(Core[253], _cc_);
   }
   function start_read(consumer, t, label){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       label,
       t,
       function(x_084){
        return sexp_of_pipe
                (function(param){return _aw_;},
                 function(param){return _av_;},
                 x_084);
       });
    if(check_invariant[1]) invariant$0(t);
    return ensure_consumer_matches(consumer, t);
   }
   function gen_read_now(consumer, t, consume){
    start_read(consumer, t, cst_read_now);
    if(is_empty(t)) return is_closed(t) ? 3456156 : -445537353;
    if(caml_call1(Core_Queue[15], t[8]))
     return [0, 17724, caml_call2(consume, t, consumer)];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ax_], 1);
   }
   function get_max_queue_length(max_queue_length){
    if(! max_queue_length) return Core_Int[41];
    var max_queue_length$0 = max_queue_length[1];
    if(caml_call2(Async_kernel_Import[2], max_queue_length$0, 0)){
     var
      _b9_ =
        [0,
         [1, [0, _ay_, [0, caml_call1(Core[356], max_queue_length$0), 0]]],
         0],
      _b__ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_max_queue_length_0), _b9_]];
     caml_call1(Core[253], _b__);
    }
    return max_queue_length$0;
   }
   function read_now(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    return gen_read_now
            (consumer,
             t,
             function(t, consumer){
              return consume(t, max_queue_length$0, consumer);
             });
   }
   function read_now$0(consumer, t){
    return gen_read_now(consumer, t, consume_one);
   }
   function peek(t){return caml_call1(Core_Queue[45], t[3]);}
   function clear(t){read_now(0, 0, t); return 0;}
   function read(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    start_read(consumer, t, cst_read);
    var r = read_now(consumer, [0, max_queue_length$0], t);
    if(typeof r === "number" && 3456156 > r)
     return caml_call1
             (Async_kernel_Deferred[3],
              function(ivar){
               var wants = [2, max_queue_length$0, ivar];
               return caml_call2(Core_Queue[41], t[8], [0, wants, consumer]);
              });
    return caml_call1(Async_kernel_Deferred_std[10], r);
   }
   function read$0(consumer, t){
    start_read(consumer, t, cst_read$0);
    if(is_empty(t))
     return is_closed(t)
             ? caml_call1(Async_kernel_Deferred_std[10], 3456156)
             : caml_call1
               (Async_kernel_Deferred[3],
                function(ivar){
                 var wants = [1, ivar];
                 return caml_call2(Core_Queue[41], t[8], [0, wants, consumer]);
                });
    if(! caml_call1(Core_Queue[15], t[8]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _az_], 1);
    var _b8_ = [0, 17724, consume_one(t, consumer)];
    return caml_call1(Async_kernel_Deferred_std[10], _b8_);
   }
   function read_exn(consumer, t){
    var _b6_ = read$0(consumer, t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _b6_,
             function(param){
              if(typeof param === "number"){
               var
                _b7_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Pipe_read_exn_received_EOF);
               return caml_call1(Core[253], _b7_);
              }
              var value = param[2];
              return value;
             });
   }
   function values_available(t){
    start_read(0, t, cst_values_available);
    if(! is_empty(t)) return caml_call1(Async_kernel_Deferred_std[10], 17724);
    if(is_closed(t))
     return caml_call1(Async_kernel_Deferred_std[10], 3456156);
    var match = caml_call1(Core_Queue[62], t[8]);
    if(match){
     var _b4_ = match[1], _b5_ = _b4_[1];
     if(0 === _b5_[0] && ! _b4_[2]){
      var ivar = _b5_[1];
      return caml_call1(Async_kernel_Ivar[18], ivar);
     }
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(ivar){
              var wants = [0, ivar];
              return caml_call2(Core_Queue[41], t[8], [0, wants, 0]);
             });
   }
   function read_choice(t){
    var _b3_ = values_available(t);
    return caml_call2
            (Async_kernel_Deferred_std[6],
             _b3_,
             function(param){return gen_read_now(0, t, consume_one);});
   }
   function read_choice_single_consumer_ex(t, here){
    var _b0_ = read_choice(t);
    return caml_call2
            (Async_kernel_Deferred[26][1],
             _b0_,
             function(x){
              if(typeof x === "number" && 3456156 > x){
               var
                _b1_ =
                  [0,
                   [1,
                    [0,
                     _aA_,
                     [0, caml_call1(Core_Source_code_position[1], here), 0]]],
                   0],
                _b2_ =
                  [1,
                   [0,
                    caml_call1
                     (Sexplib0_Sexp_conv[7], cst_Pipe_read_choice_single_co),
                    _b1_]];
               return caml_call1(Core[253], _b2_);
              }
              return x;
             });
   }
   function read_exactly(consumer, t, num_values){
    start_read(consumer, t, cst_read_exactly);
    if(caml_call2(Async_kernel_Import[2], num_values, 0)){
     var
      _bW_ = [0, [1, [0, _aB_, [0, caml_call1(Core[356], num_values), 0]]], 0],
      _bX_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exactly_got_num_),
          _bW_]];
     caml_call1(Core[253], _bX_);
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finish){
              var result = caml_call2(Core_Queue[61], 0, 0);
              function loop(param){
               var already_read = caml_call1(Core_Queue[14], result);
               if
                (!
                 caml_call2(Async_kernel_Import[2], already_read, num_values))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _aC_], 1);
               if
                (caml_call2(Async_kernel_Import[3], already_read, num_values))
                return caml_call2
                        (Async_kernel_Ivar[14], finish, [0, -876407060, result]);
               var
                _bY_ = read(consumer, [0, num_values - already_read | 0], t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _bY_,
                        function(param){
                         if(typeof param === "number"){
                          var
                           _bZ_ =
                             caml_call2(Async_kernel_Import[3], already_read, 0)
                              ? 3456156
                              : [0, 287952037, result];
                          return caml_call2(Async_kernel_Ivar[14], finish, _bZ_);
                         }
                         var q = param[2];
                         caml_call4(Core_Queue[64], q, result, 0, 0);
                         return loop(0);
                        });
              }
              return loop(0);
             });
   }
   function downstream_flushed(t){
    return is_empty(t)
            ? caml_call1
               (Core_List[8], t[11])
              ? caml_call1(Async_kernel_Deferred_std[10], 17724)
              : combine
                (caml_call2
                  (Core_List[72], t[11], values_sent_downstream_and_flu))
            : caml_call1
              (Async_kernel_Deferred[3],
               function(ready){
                var _bV_ = length(t);
                return caml_call2
                        (Core_Queue[41], t[7], [0, t[6] + _bV_ | 0, ready]);
               });
   }
   function upstream_flushed(t){
    if(caml_call1(Core_Bag[6], t[12])) return downstream_flushed(t);
    var _bU_ = caml_call1(Core_Bag[17], t[12]);
    return combine
            (caml_call2
              (Core_List[72], _bU_, function(f){return caml_call1(f, 0);}));
   }
   function add_consumer(t, downstream_flushed){
    var
     pipe_id = t[1],
     consumer = [0, pipe_id, -758792467, downstream_flushed];
    t[11] = [0, consumer, t[11]];
    return consumer;
   }
   function consumer$1(param){var t = param[1]; return t[2];}
   function create$0(upstream, downstream){
    function upstream_flushed$0(param){return upstream_flushed(upstream);}
    var _bT_ = caml_call2(Core_Bag[23], downstream[12], upstream_flushed$0);
    return [0,
            [0,
             downstream,
             add_consumer
              (upstream,
               function(param){return downstream_flushed(downstream);}),
             _bT_]];
   }
   function sexp_of_t$5(param){
    if(typeof param === "number") return param ? _aD_ : _aE_;
    var arg0_085 = param[1], res0_086 = sexp_of_t$0(arg0_085);
    return [1, [0, _aF_, [0, res0_086, 0]]];
   }
   var
    Flushed = [0, sexp_of_t$5],
    _aG_ = [0, 3804260],
    _aH_ = [0, 523273847],
    _aI_ = [0, "max_iterations_per_job"],
    cst_iter_without_pushback_got_ =
      "iter_without_pushback got non-positive max_iterations_per_job",
    _aJ_ = [0, cst_src_pipe_ml, 949, 4],
    _aK_ = [0, "Mapped"],
    cst_Pipe_interleave = "Pipe.interleave";
   function fold_gen(read_now, opt, t, init, f){
    if(opt) var sth = opt[1], flushed = sth; else var flushed = 1;
    if(typeof flushed === "number")
     var
      consumer =
        flushed
         ? 0
         : [0,
           add_consumer
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 17724);
             })];
    else
     var consumer$0 = flushed[1], consumer = [0, consumer$0];
    if(check_invariant[1]) invariant$0(t);
    ensure_consumer_matches(consumer, t);
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finished){
              var _bR_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bR_,
                       function(param){
                        function loop(b){
                         var match = caml_call2(read_now, consumer, t);
                         if(typeof match !== "number"){
                          var v = match[2];
                          return caml_call3(f, b, v, continue$0);
                         }
                         if(3456156 <= match)
                          return caml_call2(Async_kernel_Ivar[14], finished, b);
                         var _bS_ = values_available(t);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bS_,
                                  function(param){return loop(b);});
                        }
                        function continue$0(b){
                         caml_call2
                          (Core_Option[41], consumer, values_sent_downstream);
                         return loop(b);
                        }
                        return loop(init);
                       });
             });
   }
   function fold(flushed, max_queue_length, t, init, f){
    return fold_gen
            (function(_bP_){
              return function(_bQ_){
               return read_now(_bP_, max_queue_length, _bQ_);};
             },
             flushed,
             t,
             init,
             function(b, q, loop){
              var _bO_ = caml_call2(f, b, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bO_, loop);
             });
   }
   function fold$0(flushed, t, init, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             init,
             function(b, a, loop){
              var _bN_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[1], _bN_, loop);
             });
   }
   function fold_without_pushback(consumer, t, init, f){
    function _bL_(b, a, loop){return caml_call1(loop, caml_call2(f, b, a));}
    if(consumer) var c = consumer[1], _bM_ = [0, [0, c]]; else var _bM_ = 0;
    return fold_gen(read_now$0, _bM_, t, init, _bL_);
   }
   function with_error_to_current_monitor(opt, f, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    if(! continue_on_error) return caml_call1(f, a);
    var
     _bI_ =
       caml_call7
        (Async_kernel_Monitor[16],
         0,
         0,
         0,
         0,
         _aH_,
         _aG_,
         function(param){return caml_call1(f, a);});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _bI_,
             function(param){
              if(0 === param[0]) return 0;
              var
               exn = param[1],
               _bJ_ = caml_call1(Async_kernel_Monitor[13], exn),
               _bK_ = caml_call1(Async_kernel_Monitor[5], 0);
              return caml_call3(Async_kernel_Monitor[15], _bK_, 0, _bJ_);
             });
   }
   function iter(continue_on_error, flushed, max_queue_length, t, f){
    return fold
            (flushed,
             max_queue_length,
             t,
             0,
             function(param, q){
              return with_error_to_current_monitor(continue_on_error, f, q);
             });
   }
   function iter$0(continue_on_error, flushed, t, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             0,
             function(param, a, loop){
              var
               _bH_ = with_error_to_current_monitor(continue_on_error, f, a);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bH_,
                       function(param){return caml_call1(loop, 0);});
             });
   }
   function iter_without_pushback(consumer, opt, max_iterations_per_job, t, f){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    ensure_consumer_matches(consumer, t);
    if(max_iterations_per_job){
     var max_iterations_per_job$0 = max_iterations_per_job[1];
     if(caml_call2(Async_kernel_Import[2], max_iterations_per_job$0, 0)){
      var
       _bB_ =
         [0,
          [1,
           [0, _aI_, [0, caml_call1(Core[356], max_iterations_per_job$0), 0]]],
          0],
       _bC_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_iter_without_pushback_got_),
           _bB_]];
      caml_call1(Core[253], _bC_);
     }
     var max_iterations_per_job$1 = max_iterations_per_job$0;
    }
    else
     var max_iterations_per_job$1 = Core_Int[41];
    var
     f$0 =
       continue_on_error
        ? function
         (a){
          try{caml_call1(f, a); return;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _bG_ = caml_call1(Async_kernel_Monitor[5], 0);
           return caml_call3(Async_kernel_Monitor[15], _bG_, 0, exn);
          }
         }
        : f;
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finished){
              var _bD_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bD_,
                       function(param){
                        function start(param){
                         a:
                         {
                          var remaining = max_iterations_per_job$1;
                          for(;;){
                           if(caml_call2(Async_kernel_Import[3], remaining, 0))
                            break a;
                           var match = gen_read_now(consumer, t, consume_one);
                           if(typeof match === "number") break;
                           var a = match[2];
                           caml_call1(f$0, a);
                           var remaining$0 = remaining - 1 | 0;
                           remaining = remaining$0;
                          }
                          if(3456156 <= match)
                           return caml_call2(Async_kernel_Ivar[14], finished, 0);
                          var _bF_ = values_available(t);
                          return caml_call2
                                  (Async_kernel_Deferred_std[1],
                                   _bF_,
                                   function(param){return start(0);});
                         }
                         var _bE_ = caml_call1(Async_kernel_Deferred_std[10], 0);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bE_,
                                  function(param){return start(0);});
                        }
                        return start(0);
                       });
             });
   }
   function drain(t){
    return iter
            (0,
             0,
             0,
             t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function drain_and_count(t){
    return fold
            (0,
             0,
             t,
             0,
             function(sum, q){
              var _bA_ = sum + caml_call1(Core_Queue[14], q) | 0;
              return caml_call1(Async_kernel_Deferred_std[10], _bA_);
             });
   }
   function read_all(input){
    var
     result = caml_call2(Core_Queue[61], 0, 0),
     _bz_ =
       iter
        (0,
         0,
         0,
         input,
         function(q){
          caml_call4(Core_Queue[64], q, result, 0, 0);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _bz_,
             function(param){return result;});
   }
   function to_list(r){
    var _bx_ = Core_Queue[26], _by_ = read_all(r);
    return caml_call2(Async_kernel_Deferred_std[4], _by_, _bx_);
   }
   function to_stream_deprecated(t){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              var
               _bw_ =
                 iter_without_pushback
                  (0,
                   0,
                   0,
                   t,
                   function(x){
                    return caml_call2(Async_kernel_Tail[3], tail, x);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bw_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function of_stream_deprecated(s){
    var
     match = create(0, 0, 0),
     w = match[2],
     r = match[1],
     q = caml_call2(Core_Queue[61], 0, 0);
    function transfer(param){
     var _bu_ = 1 - caml_call1(Core_Queue[15], q);
     if(! _bu_) return _bu_;
     var _bv_ = transfer_in(w, q);
     return caml_call1(Async_kernel_Deferred_std[8], _bv_);
    }
    function loop$0(counter, s){
     if(is_closed(w))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aJ_], 1);
     var
      next_deferred = caml_call1(Async_kernel_Async_stream[3], s),
      match = caml_call1(Async_kernel_Deferred[5], next_deferred);
     if(! match){
      transfer(0);
      return caml_call2
              (Async_kernel_Deferred_std[11],
               next_deferred,
               check_closed_loop_next);
     }
     var next = match[1];
     if(counter >= 50) return caml_trampoline_return(loop_next$0, [0, next]);
     var counter$0 = counter + 1 | 0;
     return loop_next$0(counter$0, next);
    }
    function loop(s){return caml_trampoline(loop$0(0, s));}
    function check_closed_loop_next(next){
     var _bt_ = 1 - is_closed(w);
     return _bt_ ? loop_next(next) : _bt_;
    }
    function loop_next$0(counter, param){
     if(! param){transfer(0); return close(w);}
     var s = param[2], x = param[1];
     caml_call2(Core_Queue[41], q, x);
     if(counter >= 50) return caml_trampoline_return(loop$0, [0, s]);
     var counter$0 = counter + 1 | 0;
     return loop$0(counter$0, s);
    }
    function loop_next(param){return caml_trampoline(loop_next$0(0, param));}
    loop(s);
    return r;
   }
   function transfer_gen(read_now, write, input, output, f){
    if(check_invariant[1]){invariant$0(input); invariant$0(output);}
    var link = create$0(input, output), consumer = consumer$1(link);
    function unlink(param){
     var t = link[1];
     return caml_call2(Core_Bag[26], t[1][12], t[3]);
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(result){
              var _bl_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bl_,
                       function(param){
                        function output_closed(param){
                         close_read(input);
                         unlink(0);
                         return caml_call2(Async_kernel_Ivar[14], result, 0);
                        }
                        function loop(param){
                         if(is_closed(output)) return output_closed(0);
                         var match = caml_call2(read_now, [0, consumer], input);
                         if(typeof match !== "number"){
                          var x = match[2];
                          return caml_call2(f, x, continue$0);
                         }
                         if(3456156 <= match){
                          unlink(0);
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         }
                         var
                          _bm_ = closed(output),
                          _bn_ =
                            [0,
                             caml_call2
                              (Async_kernel_Deferred_std[6],
                               _bm_,
                               function(_bs_){return 0;}),
                             0],
                          _bo_ = values_available(input),
                          _bp_ =
                            [0,
                             caml_call2
                              (Async_kernel_Deferred_std[6],
                               _bo_,
                               function(_br_){return 0;}),
                             _bn_],
                          _bq_ = caml_call1(Async_kernel_Deferred_std[7], _bp_);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bq_,
                                  function(param){return loop(0);});
                        }
                        function continue$0(y){
                         if(is_closed(output)) return output_closed(0);
                         var pushback = caml_call2(write, output, y);
                         values_sent_downstream(consumer);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  pushback,
                                  function(param){return loop(0);});
                        }
                        return loop(0);
                       });
             });
   }
   function transfer(max_queue_length, input, output, f){
    return transfer_gen
            (function(_bj_){
              return function(_bk_){
               return read_now(_bj_, max_queue_length, _bk_);};
             },
             write,
             input,
             output,
             function(q, k){
              var _bi_ = caml_call1(f, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bi_, k);
             });
   }
   function transfer$0(input, output, f){
    return transfer_gen
            (read_now$0,
             write$0,
             input,
             output,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function transfer_id(max_queue_length, input, output){
    return transfer_gen
            (function(_bg_){
              return function(_bh_){
               return read_now(_bg_, max_queue_length, _bh_);};
             },
             write,
             input,
             output,
             function(q, k){return caml_call1(k, q);});
   }
   function map_gen(read, write, input, f){
    var
     info =
       caml_call2
        (Core_Option[29],
         input[2],
         function(info){
          return [1, [0, _aK_, [0, caml_call1(Core_Sexp[90], info), 0]]];
         }),
     match = create(0, info, 0),
     output = match[2],
     result = match[1],
     _bf_ = transfer_gen(read, write, input, output, f);
    caml_call2
     (Async_kernel_Deferred_std[11],
      _bf_,
      function(param){return close(output);});
    return result;
   }
   function map(max_queue_length, input, f){
    return map_gen
            (function(_bd_){
              return function(_be_){
               return read_now(_bd_, max_queue_length, _be_);};
             },
             write,
             input,
             function(q, k){
              var _bc_ = caml_call1(f, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bc_, k);
             });
   }
   function map$0(input, f){
    return map_gen
            (read_now$0,
             write$0,
             input,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function concat_map_list(max_queue_length, input, f){
    return map_gen
            (function(_ba_){
              return function(_bb_){
               return read_now(_ba_, max_queue_length, _bb_);};
             },
             write,
             input,
             function(q, k){
              return caml_call1(k, caml_call2(Core_Queue[51], q, f));
             });
   }
   function filter_map(max_queue_length, input, f){
    return map
            (max_queue_length,
             input,
             function(q){
              return caml_call3(Async_kernel_Deferred_queue[20], 0, q, f);
             });
   }
   function filter_map$0(max_queue_length, input, f){
    return map_gen
            (function(_a__){
              return function(_a$_){
               return read_now(_a__, max_queue_length, _a$_);};
             },
             write,
             input,
             function(q, k){
              return caml_call1
                      (k,
                       caml_call2
                        (Core_Queue[53],
                         q,
                         function(x){
                          return is_read_closed(input) ? 0 : caml_call1(f, x);
                         }));
             });
   }
   function folding_filter_map(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map
            (max_queue_length,
             input,
             function(x){
              var _a9_ = caml_call2(f, accum[1], x);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _a9_,
                       function(param){
                        var x = param[2], a = param[1];
                        accum[1] = a;
                        return x;
                       });
             });
   }
   function folding_filter_map$0(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map$0
            (max_queue_length,
             input,
             function(x){
              var
               match = caml_call2(f, accum[1], x),
               x$0 = match[2],
               a = match[1];
              accum[1] = a;
              return x$0;
             });
   }
   function folding_map(max_queue_length, input, init, f){
    return folding_filter_map$0
            (max_queue_length,
             input,
             init,
             function(accum, a){
              var
               match = caml_call2(f, accum, a),
               b = match[2],
               accum$0 = match[1];
              return [0, accum$0, [0, b]];
             });
   }
   function filter(input, f){
    return filter_map$0
            (0, input, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function of_list(l){
    var t = create_internal(0, 0, caml_call1(Core_Queue[38], l));
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    update_pushback(t);
    return t;
   }
   function empty(param){return of_list(0);}
   function singleton(x){
    var match = create(0, 0, 0), writer = match[2], reader = match[1];
    write_without_pushback(writer, x);
    close(writer);
    return reader;
   }
   function unfold(s, f){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(s){
               function f$0(param){
                if(! param)
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                var match = param[1], s = match[2], a = match[1];
                if(is_closed(writer))
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                function f(param){return loop(s);}
                var d = write$0(writer, a);
                return caml_call1(Async_kernel_Deferred[5], d)
                        ? loop(s)
                        : caml_call2(Async_kernel_Deferred_std[3], d, f);
               }
               var
                d = caml_call1(f, s),
                match = caml_call1(Async_kernel_Deferred[5], d);
               if(! match)
                return caml_call2(Async_kernel_Deferred_std[3], d, f$0);
               var x = match[1];
               return f$0(x);
              }
              return loop(s);
             });
   }
   function of_sequence(sequence){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(sequence$1){
               if
                (!
                 is_closed(writer)
                 && ! caml_call1(Core_Sequence[16], sequence$1)){
                start_write(writer);
                var
                 _a7_ = length(writer),
                 i$1 = (1 + writer[4] | 0) - _a7_ | 0;
                a:
                b:
                {
                 var sequence = sequence$1, i = i$1;
                 for(;;){
                  if(caml_call2(Async_kernel_Import[2], i, 0)) break b;
                  var match = caml_call1(Core_Sequence[47], sequence);
                  if(! match) break;
                  var
                   match$0 = match[1],
                   sequence$0 = match$0[2],
                   a = match$0[1];
                  caml_call2(Core_Queue[41], writer[3], a);
                  var i$0 = i - 1 | 0;
                  sequence = sequence$0;
                  i = i$0;
                 }
                 break a;
                }
                finish_write(writer);
                var _a8_ = pushback$1(writer);
                return caml_call2
                        (Async_kernel_Deferred_std[5][1],
                         _a8_,
                         function(param){return loop(sequence);});
               }
               return caml_call1(Async_kernel_Deferred_std[10], 0);
              }
              return loop(sequence);
             });
   }
   function to_sequence(t){
    return caml_call2
            (Core_Sequence[49],
             0,
             function(param){
              var match = gen_read_now(0, t, consume_one);
              if(typeof match === "number")
               return 3456156 <= match
                       ? 0
                       : [0, [0, [1, values_available(t)], 0]];
              var a = match[2];
              return [0, [0, [0, a], 0]];
             });
   }
   function interleave_pipe(inputs){
    var
     match =
       create
        (0, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_interleave)], 0),
     output_writer = match[2],
     output = match[1],
     num_pipes_remaining = [0, 1];
    function decr_num_pipes_remaining(param){
     num_pipes_remaining[1]--;
     var _a6_ = caml_call2(Async_kernel_Import[3], num_pipes_remaining[1], 0);
     return _a6_ ? close(output_writer) : _a6_;
    }
    var
     _a2_ =
       iter_without_pushback
        (0,
         0,
         0,
         inputs,
         function(input){
          num_pipes_remaining[1]++;
          var
           _a4_ = transfer_id(0, input, output_writer),
           _a5_ =
             caml_call2
              (Async_kernel_Deferred_std[5][2],
               _a4_,
               function(param){return decr_num_pipes_remaining(0);});
          return caml_call1(Async_kernel_Deferred_std[8], _a5_);
         }),
     _a3_ =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         _a2_,
         function(param){return decr_num_pipes_remaining(0);});
    caml_call1(Async_kernel_Deferred_std[8], _a3_);
    return output;
   }
   function interleave(inputs){
    if(check_invariant[1]) caml_call2(Core_List[9], inputs, invariant$0);
    return interleave_pipe(of_list(inputs));
   }
   function merge(inputs, compare){
    if(! inputs) return empty(0);
    if(inputs[2]){
     var
      match = create(0, 0, 0),
      w = match[2],
      r = match[1],
      _aU_ = closed(w);
     caml_call2
      (Async_kernel_Deferred_std[11],
       _aU_,
       function(param){return caml_call2(Core_List[9], inputs, close_read);});
     var
      heap =
        caml_call3
         (Pairing_heap[20],
          0,
          function(param, _a1_){
           var a2 = _a1_[1], a1 = param[1];
           return caml_call2(compare, a1, a2);
          },
          0),
      handle_read =
        function(input, eof_or_ok){
         if(typeof eof_or_ok === "number") return 0;
         var v = eof_or_ok[2];
         return caml_call2(Pairing_heap[25], heap, [0, v, input]);
        },
      pop_heap_and_loop =
        function(param){
         for(;;){
          var match = caml_call1(Pairing_heap[28], heap);
          if(! match) return close(w);
          var
           match$0 = match[1],
           input = match$0[2],
           v = match$0[1],
           _aW_ = 1 - is_closed(w);
          if(! _aW_) return _aW_;
          write_without_pushback(w, v);
          var _aX_ = caml_call1(Pairing_heap[3], heap);
          if(caml_call2(Async_kernel_Import[3], _aX_, 0)){
           var _aY_ = transfer_id(0, input, w);
           return caml_call2
                   (Async_kernel_Deferred_std[11],
                    _aY_,
                    function(param){return close(w);});
          }
          var x = gen_read_now(0, input, consume_one);
          if(typeof x === "number" && 3456156 > x){
           var _aZ_ = pushback$1(w);
           return caml_call2
                   (Async_kernel_Deferred_std[1],
                    _aZ_,
                    function(param){
                     var _a0_ = read$0(0, input);
                     return caml_call2
                             (Async_kernel_Deferred_std[1],
                              _a0_,
                              function(x){
                               handle_read(input, x);
                               return pop_heap_and_loop(0);
                              });
                    });
          }
          handle_read(input, x);
         }
        },
      initial_push =
        caml_call3
         (Async_kernel_Deferred_list[14],
          0,
          inputs,
          function(input){
           var _aV_ = read$0(0, input);
           return caml_call2
                   (Async_kernel_Deferred_std[5][2],
                    _aV_,
                    function(x){return handle_read(input, x);});
          });
     caml_call2
      (Async_kernel_Deferred_std[11], initial_push, pop_heap_and_loop);
     return r;
    }
    var input = inputs[1];
    return input;
   }
   function concat_pipe(inputs){
    var
     r =
       create_reader_not_close_on_exc
        (0,
         function(w){
          var link = create$0(inputs, w), consumer = consumer$1(link);
          return iter$0
                  (0,
                   [0, [0, consumer]],
                   inputs,
                   function(input){return transfer_id(0, input, w);});
         }),
     _aT_ = closed(r);
    caml_call2
     (Async_kernel_Deferred_std[11],
      _aT_,
      function(param){return close(inputs);});
    return r;
   }
   function concat(inputs){
    return create_reader_not_close_on_exc
            (0,
             function(w){
              return caml_call3
                      (Async_kernel_Deferred_list[14],
                       0,
                       inputs,
                       function(input){return transfer_id(0, input, w);});
             });
   }
   function fork(t, pushback_uses){
    var
     match = create(0, 0, 0),
     writer0 = match[2],
     reader0 = match[1],
     match$0 = create(0, 0, 0),
     writer1 = match$0[2],
     reader1 = match$0[1],
     some_reader_was_closed = [0, 0],
     consumer =
       add_consumer
        (t,
         function(param){
          var
           some_reader_was_closed$0 = some_reader_was_closed[1],
           _aR_ = [0, downstream_flushed(writer1), 0],
           _aS_ = combine([0, downstream_flushed(writer0), _aR_]);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _aS_,
                   function(param){
                    return 17724 <= param
                            ? some_reader_was_closed$0 ? -402004920 : 17724
                            : -402004920;
                   });
         }),
     still_open = [0, writer0, [0, writer1, 0]];
    function filter_open(still_open){
     if(! caml_call2(Core_List[13], still_open, is_closed)) return still_open;
     some_reader_was_closed[1] = 1;
     var
      still_open$0 =
        caml_call2
         (Core_List[50], still_open, function(w){return 1 - is_closed(w);});
     if(caml_call1(Core_List[8], still_open$0)) close(t);
     return still_open$0;
    }
    var
     _aL_ =
       fold
        ([0, [0, consumer]],
         0,
         t,
         still_open,
         function(still_open, queue){
          var still_open$0 = filter_open(still_open);
          if(caml_call1(Core_List[8], still_open$0))
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          function _aN_(param){
           var still_open = filter_open(still_open$0);
           caml_call2
            (Core_List[9],
             still_open,
             function(w){
              start_write(w);
              caml_call2
               (Core_Queue[16],
                queue,
                function(x){return caml_call2(Core_Queue[41], w[3], x);});
              return finish_write(w);
             });
           return still_open;
          }
          if(-648027566 <= pushback_uses)
           var
            _aO_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _aP_ = caml_call1(Async_kernel_Deferred[23], _aO_);
          else
           var
            _aQ_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _aP_ = caml_call1(Async_kernel_Deferred[22], _aQ_);
          return caml_call2(Async_kernel_Deferred_std[5][2], _aP_, _aN_);
         }),
     _aM_ =
       caml_call2
        (Async_kernel_Deferred_std[5][1],
         _aL_,
         function(still_open){
          caml_call2(Core_List[9], still_open, close);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _aM_);
    return [0, reader0, reader1];
   }
   function set_info(t, info){var v = [0, info]; t[2] = v; return 0;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Pipe);
   var
    Async_kernel_Pipe =
      [0,
       sexp_of_pipe,
       sexp_of_pipe,
       [0, sexp_of_t$4, invariant$0],
       [0, sexp_of_t$3, invariant$0],
       create_reader,
       create_writer,
       create,
       empty,
       of_list,
       singleton,
       unfold,
       of_sequence,
       to_sequence,
       close,
       close_read,
       is_closed,
       closed,
       [0, compare, sexp_of_t],
       upstream_flushed,
       downstream_flushed,
       [0, values_sent_downstream],
       add_consumer,
       length,
       is_empty,
       pushback$1,
       write$0,
       write_without_pushback,
       transfer_in,
       transfer_in_without_pushback,
       write_when_ready,
       write_if_open,
       write_without_pushback_if_open,
       read,
       read$0,
       read_exn,
       read_exactly,
       read_now,
       read_now$0,
       peek,
       clear,
       read_all,
       values_available,
       read_choice,
       read_choice_single_consumer_ex,
       Flushed,
       fold,
       fold$0,
       fold_without_pushback,
       iter,
       iter$0,
       iter_without_pushback,
       transfer,
       transfer$0,
       transfer_id,
       map,
       map$0,
       concat_map_list,
       folding_map,
       filter_map,
       filter_map$0,
       folding_filter_map,
       folding_filter_map$0,
       filter,
       interleave,
       interleave_pipe,
       merge,
       concat,
       concat_pipe,
       fork,
       to_stream_deprecated,
       of_stream_deprecated,
       drain,
       drain_and_count,
       to_list,
       hash,
       equal$0,
       compare$0,
       size_budget,
       set_size_budget$0,
       show_debug_messages,
       check_invariant,
       set_info];
   runtime.caml_register_global(171, Async_kernel_Pipe, cst_Async_kernel_Pipe);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Mvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Pipe, Base__Field, Base__Invariant, Core, Core__Unit, Expect_test_collector, Moption, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Mvar = "Async_kernel__Mvar",
    cst_async_kernel = "async_kernel",
    cst_current_value = "current_value",
    cst_src_mvar_ml = "src/mvar.ml",
    cst_taken = "taken",
    cst_value_available = "value_available",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/mvar.ml:23:26",
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Moption = global_data.Moption,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Unit = global_data.Core__Unit;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Mvar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_mvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function value_available(r){return r[3];}
   function set_value_available(r, v){r[3] = v; return 0;}
   function taken(r){return r[2];}
   function current_value(r){return r[1];}
   var
    value_available$0 =
      [0,
       function(param){return 0;},
       cst_value_available,
       [0, set_value_available],
       value_available,
       function(r, v){return [0, r[1], r[2], v];}],
    taken$0 =
      [0,
       function(param){return 0;},
       cst_taken,
       0,
       taken,
       function(r, v){return [0, r[1], v, r[3]];}],
    current_value$0 =
      [0,
       function(param){return 0;},
       cst_current_value,
       0,
       current_value,
       function(r, v){return [0, v, r[2], r[3]];}],
    _a_ = [0, cst_value_available],
    _b_ = [0, cst_taken],
    _c_ = [0, cst_current_value],
    _d_ = [0, "_"],
    _e_ = [0, cst_src_mvar_ml, 16, 357, 379],
    cst_Mvar_peek_exn_called_on_em = "Mvar.peek_exn called on empty mvar";
   function value_available$1(t){
    return caml_call1(Async_kernel_Ivar[18], t[3]);
   }
   function is_empty(t){return caml_call1(Moption[5], t[1]);}
   function invariant(invariant_a, param, t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             function(x_010){
              function of_a_001(param){return _d_;}
              var
               taken_006 = x_010[2],
               current_value_004 = x_010[1],
               value_available_008 = x_010[3],
               arg_009 =
                 caml_call2
                  (Async_kernel_Ivar[9], Core[518], value_available_008),
               bnds_003 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
               arg_007 =
                 caml_call3
                  (Async_kernel_Bvar[1], Core[518], Core[202], taken_006),
               bnds_003$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003],
               arg_005 = caml_call2(Moption[1], of_a_001, current_value_004),
               bnds_003$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$0];
              return [1, bnds_003$1];
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               value_available_fun =
                 check
                  (function(value_available){
                    var
                     got = caml_call1(Async_kernel_Ivar[17], value_available),
                     expect = caml_call1(Moption[6], t[1]),
                     sexpifier = Core[305];
                    function comparator(a_011, b_012){
                     return caml_call2(Core[301], a_011, b_012);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             got);
                   }),
               taken_fun =
                 check
                  (caml_call2
                    (Async_kernel_Bvar[2],
                     Core_Unit[5],
                     function(_s_){return 0;})),
               current_value_fun = check(caml_call1(Moption[2], invariant_a));
              caml_call1(current_value_fun, current_value$0);
              caml_call1(taken_fun, taken$0);
              return caml_call1(value_available_fun, value_available$0);
             });
   }
   function peek(t){return caml_call1(Moption[7], t[1]);}
   function peek_exn(t){
    if(is_empty(t)){
     var
      _r_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_peek_exn_called_on_em);
     caml_call1(Core[253], _r_);
    }
    return caml_call1(Moption[8], t[1]);
   }
   function sexp_of_t(sexp_of_a, param, t){
    var x_013 = peek(t);
    return caml_call2(Core[454], sexp_of_a, x_013);
   }
   function sexp_of_t$0(of_a_014, x_015){
    return sexp_of_t(of_a_014, Core[202], x_015);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_q_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$0, invariant$0];
   function sexp_of_t$1(of_a_016, x_017){
    return sexp_of_t(of_a_016, Core[171], x_017);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_p_){return 0;}, t);
   }
   var
    Read_only = [0, sexp_of_t$1, invariant$1],
    _f_ = [0, cst_src_mvar_ml, 60, 2],
    cst_Mvar_take_exn_called_on_em = "Mvar.take_exn called on empty mvar";
   function read_only(t){return t;}
   function write_only(t){return t;}
   function create(param){
    var
     _n_ = caml_call1(Async_kernel_Ivar[12], 0),
     _o_ = caml_call1(Async_kernel_Bvar[3], 0);
    return [0, caml_call1(Moption[4], 0), _o_, _n_];
   }
   function take_nonempty(t){
    if(is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var r = caml_call1(Moption[8], t[1]);
    caml_call1(Moption[11], t[1]);
    caml_call2(Async_kernel_Bvar[5], t[2], 0);
    t[3] = caml_call1(Async_kernel_Ivar[12], 0);
    return r;
   }
   function take_now_exn(t){
    if(is_empty(t)){
     var
      _m_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_take_exn_called_on_em);
     caml_call1(Core[253], _m_);
    }
    return take_nonempty(t);
   }
   function take_now(t){return is_empty(t) ? 0 : [0, take_nonempty(t)];}
   function take(t){
    if(is_empty(t)){
     var _k_ = value_available$1(t);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _k_,
              function(param){return take(t);});
    }
    var _l_ = take_nonempty(t);
    return caml_call1(Async_kernel_Deferred_std[10], _l_);
   }
   function set(t, v){
    caml_call2(Moption[12], t[1], v);
    return caml_call2(Async_kernel_Ivar[15], t[3], 0);
   }
   function update(t, f){return set(t, caml_call1(f, peek(t)));}
   function update_exn(t, f){return set(t, caml_call1(f, peek_exn(t)));}
   function taken$1(t){return caml_call1(Async_kernel_Bvar[4], t[2]);}
   function put(t, v){
    if(is_empty(t)){
     set(t, v);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    var _j_ = taken$1(t);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _j_,
             function(param){return put(t, v);});
   }
   function pipe_when_ready(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function loop(param){
     var _h_ = value_available$1(t);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _h_,
              function(param){
               if(caml_call1(Async_kernel_Pipe[16], w))
                return caml_call1(Async_kernel_Deferred_std[10], 0);
               var match = take_now(t);
               if(! match) return loop(0);
               var
                x = match[1],
                _i_ = caml_call2(Async_kernel_Pipe[26], w, x);
               return caml_call2
                       (Async_kernel_Deferred_std[5][1],
                        _i_,
                        function(param){return loop(0);});
              });
    }
    var _g_ = loop(0);
    caml_call1(Async_kernel_Deferred_std[8], _g_);
    return r;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Mvar);
   var
    Async_kernel_Mvar =
      [0,
       sexp_of_t,
       Read_write,
       Read_only,
       create,
       is_empty,
       put,
       set,
       update,
       update_exn,
       read_only,
       write_only,
       value_available$1,
       take,
       take_now,
       take_now_exn,
       taken$1,
       peek,
       peek_exn,
       pipe_when_ready];
   runtime.caml_register_global(37, Async_kernel_Mvar, cst_Async_kernel_Mvar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Lazy_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Base__Monad, Core, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Lazy_deferred = "Async_kernel__Lazy_deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Lazy_deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/lazy_deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 3804260], _b_ = [0, 3804260];
   function create(f){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _j_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0,
            start,
            caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(param){
               return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, _a_, f);
              })];
   }
   function create_or_error(f){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _i_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0,
            start,
            caml_call2
             (Async_kernel_Deferred_std[5][1],
              _i_,
              function(param){
               return caml_call6(Async_kernel_Monitor[18], 0, 0, 0, 0, _b_, f);
              })];
   }
   function wait(t){return t[2];}
   function wait_exn(t){
    return caml_call2(Async_kernel_Deferred_std[4], t[2], Core[245]);
   }
   function force(t){caml_call2(Async_kernel_Ivar[15], t[1], 0); return t[2];}
   function force_exn(t){
    var _g_ = Core[245], _h_ = force(t);
    return caml_call2(Async_kernel_Deferred_std[4], _h_, _g_);
   }
   function return$0(a){
    return create
            (function(param){
              return caml_call1(Async_kernel_Deferred_std[10], a);
             });
   }
   function bind(t, f){
    return create
            (function(param){
              var _f_ = force_exn(t);
              return caml_call2
                      (Async_kernel_Deferred_std[5][1],
                       _f_,
                       function(a){return force_exn(caml_call1(f, a));});
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return create
                (function(param){
                  var _e_ = force_exn(t);
                  return caml_call2(Async_kernel_Deferred_std[4], _e_, f);
                 });
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function bind$1(t, f){
    return caml_call2
            (bind$0,
             t,
             function(a){
              return create(function(param){return caml_call1(f, a);});
             });
   }
   function is_forced(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function is_determined(t){
    return caml_call1(Async_kernel_Deferred[7], t[2]);
   }
   function peek(t){return caml_call1(Async_kernel_Deferred[5], t[2]);}
   function peek_exn(t){
    var _c_ = Core[245], _d_ = peek(t);
    return caml_call2(Core_Option[29], _d_, _c_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Lazy_deferred);
   var
    Async_kernel_Lazy_deferred =
      [0,
       create,
       create_or_error,
       force,
       force_exn,
       wait,
       wait_exn,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       bind$1,
       peek,
       peek_exn,
       is_determined,
       is_forced];
   runtime.caml_register_global
    (20, Async_kernel_Lazy_deferred, cst_Async_kernel_Lazy_deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_condition
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Core__Option, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_conditi = "Async_kernel__Async_condition",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Queue = global_data.Core__Queue,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_conditi);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_condition.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "waits"];
   function sexp_of_t(of_a_001, param){
    var
     waits_003 = param[1],
     _c_ = caml_call1(Async_kernel_Ivar[9], of_a_001),
     arg_004 = caml_call2(Core_Queue[11], _c_, waits_003),
     bnds_002 = [0, [1, [0, _a_, [0, arg_004, 0]]], 0];
    return [1, bnds_002];
   }
   function create(param){return [0, caml_call2(Core_Queue[61], 0, 0)];}
   function wait(t){
    return caml_call1
            (Async_kernel_Deferred[3],
             function(ivar){return caml_call2(Core_Queue[41], t[1], ivar);});
   }
   function signal(t, a){
    var _b_ = caml_call1(Core_Queue[43], t[1]);
    return caml_call2
            (Core_Option[41],
             _b_,
             function(ivar){
              return caml_call2(Async_kernel_Ivar[14], ivar, a);
             });
   }
   function broadcast(t, a){
    caml_call2
     (Core_Queue[16],
      t[1],
      function(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);});
    return caml_call1(Core_Queue[47], t[1]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_conditi);
   var
    Async_kernel_Async_condition =
      [0, sexp_of_t, create, signal, broadcast, wait];
   runtime.caml_register_global
    (16, Async_kernel_Async_condition, cst_Async_kernel_Async_conditi);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_gc
//# unitInfo: Requires: Async_kernel__Scheduler, Core__Gc, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_gc = "Async_kernel__Async_gc",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Gc = global_data.Core__Gc;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_gc);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_gc.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    Stat = Core_Gc[1],
    Control = Core_Gc[2],
    print_stat = Core_Gc[3],
    allocated_bytes = Core_Gc[4],
    keep_alive = Core_Gc[5],
    Allocation_policy = Core_Gc[6],
    tune = Core_Gc[7],
    disable_compaction = Core_Gc[8],
    For_testing = Core_Gc[9],
    Stable = Core_Gc[11];
   function add_finalizer(heap_block, f){
    var _e_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[46], _e_), heap_block, f);
   }
   function add_finalizer_exn(heap_block, f){
    var _d_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[47], _d_), heap_block, f);
   }
   function add_finalizer_last(heap_block, f){
    var _c_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[48], _c_), heap_block, f);
   }
   function add_finalizer_last_exn(heap_block, f){
    var _b_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[49], _b_), heap_block, f);
   }
   var sexp_of_t = Core_Gc[10][6][1];
   function create(f){
    var _a_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call1(caml_call1(Async_kernel_Scheduler[45], _a_), f);
   }
   var delete$0 = Core_Gc[10][6][3], Alarm = [0, sexp_of_t, create, delete$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_gc);
   var
    Async_kernel_Async_gc =
      [0,
       Stat,
       Control,
       print_stat,
       allocated_bytes,
       keep_alive,
       Allocation_policy,
       tune,
       disable_compaction,
       For_testing,
       Stable,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       Alarm];
   runtime.caml_register_global
    (13, Async_kernel_Async_gc, cst_Async_kernel_Async_gc);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Async = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant_i = [0, Async];
   runtime.caml_register_global
    (11, Async_kernel_Async_invariant_i, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant
//# unitInfo: Requires: Async_kernel__Async_invariant_intf, Async_kernel__Deferred, Async_kernel__Monitor, Base__Field, Base__Invariant, Core, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant",
    cst_async_kernel = "async_kernel",
    cst_exn = "exn";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Field = global_data.Base__Field,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    invariant = Base_Invariant[1],
    check_field = Base_Invariant[2],
    _a_ = [0, cst_exn],
    cst_invariant_failed = "invariant failed",
    _b_ = [0, 3804260],
    _c_ = [0, 523273847],
    _d_ = [0, 1],
    _e_ = [0, cst_exn],
    _f_ = [0, "field"],
    cst_problem_with_field = "problem with field",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, 1];
   function invariant$0(here, t, sexp_of_t, f){
    var _o_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _d_, _c_, _b_, f);
    return caml_call2
            (Async_kernel_Deferred[16][4][3],
             _o_,
             function(param){
              if(0 === param[0]) return 0;
              var
               exn = param[1],
               _p_ = [0, caml_call1(sexp_of_t, t), 0],
               _q_ =
                 [0, [1, [0, _a_, [0, caml_call1(Core[537], exn), 0]]], _p_],
               _r_ = [0, caml_call1(Core_Source_code_position[1], here), _q_],
               _s_ =
                 [1,
                  [0,
                   caml_call1(Sexplib0_Sexp_conv[7], cst_invariant_failed),
                   _r_]];
              return caml_call1(Core[253], _s_);
             });
   }
   function check_field$0(t, f, wait_for_previous, field){
    return caml_call2
            (Async_kernel_Deferred[16][4][2],
             wait_for_previous,
             function(param){
              var
               _j_ =
                 caml_call7
                  (Async_kernel_Monitor[16],
                   0,
                   0,
                   0,
                   _i_,
                   _h_,
                   _g_,
                   function(param){
                    return caml_call1(f, caml_call2(Base_Field[3], field, t));
                   });
              return caml_call2
                      (Async_kernel_Deferred[16][4][3],
                       _j_,
                       function(param){
                        if(0 === param[0]) return 0;
                        var
                         exn = param[1],
                         _k_ =
                           [0, [1, [0, _e_, [0, caml_call1(Core[537], exn), 0]]], 0],
                         _l_ = caml_call1(Base_Field[2], field),
                         _m_ =
                           [0, [1, [0, _f_, [0, caml_call1(Core[471], _l_), 0]]], _k_],
                         _n_ =
                           [1,
                            [0,
                             caml_call1(Sexplib0_Sexp_conv[7], cst_problem_with_field),
                             _m_]];
                        return caml_call1(Core[253], _n_);
                       });
             });
   }
   var Async = [0, invariant$0, check_field$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant = [0, invariant, check_field, Async];
   runtime.caml_register_global
    (29, Async_kernel_Async_invariant, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Scheduler, Core, Expect_test_collector, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel = "Async_kernel",
    cst_async_kernel = "async_kernel",
    cst_src_async_kernel_ml = "src/async_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/async_kernel.ml:94:17",
    cst = "",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_async_kernel_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    catch$0 = Async_kernel_Monitor[21],
    choice = Async_kernel_Deferred[27],
    choose = Async_kernel_Deferred[29],
    don_t_wait_for = Async_kernel_Deferred[25],
    every = Async_kernel_Clock_ns[10],
    never = Async_kernel_Deferred[19],
    schedule = Async_kernel_Scheduler[59],
    schedule$0 = Async_kernel_Scheduler[58],
    try_with = Async_kernel_Monitor[16],
    upon = Async_kernel_Deferred[4],
    with_timeout = Async_kernel_Clock_ns[5],
    within = Async_kernel_Scheduler[56],
    within$0 = Async_kernel_Scheduler[55],
    symbol = Async_kernel_Deferred[17][3],
    symbol$0 = Async_kernel_Deferred_result[1],
    symbol$1 = Async_kernel_Deferred_result[2],
    include = Async_kernel_Deferred[16],
    return$0 = include[1],
    symbol_bind = include[2],
    symbol_map = include[3],
    Let_syntax = include[4],
    Async_kernel_private = [0];
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "[return ()] does not allocate",
     0,
     cst_src_async_kernel_ml,
     87,
     0,
     443,
     function(param){
      var expect = runtime.core_gc_minor_words(0);
      caml_call1(return$0, 0);
      caml_call1(Async_kernel_Deferred[12], 0);
      caml_call1(Async_kernel_Deferred[16][1], 0);
      caml_call1(Async_kernel_Deferred[16][4][1], 0);
      var got = runtime.core_gc_minor_words(0), sexpifier = Core[356];
      function comparator(a_001, b_002){
       return caml_call2(Core[352], a_001, b_002);
      }
      caml_call8
       (Ppx_assert_lib_Runtime[3],
        pos,
        sexpifier,
        comparator,
        0,
        0,
        0,
        expect,
        got);
      return 0;
     });
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel);
   var
    Async_kernel =
      [0,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       within,
       within$0,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private];
   runtime.caml_register_global(22, Async_kernel, cst_Async_kernel);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFmdGVyIiwidCIsInNwYW4iLCJyZXN1bHQiLCJsb2ciLCJhcmcyXzAwMyIsImFyZzNfMDA0Iiwic2V4cF9vZl9hIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDA1IiwicmVzMV8wMDYiLCJyZXMyXzAwNyIsInJlczNfMDA4IiwibG9nX3N0cmluZyIsIm1lc3NhZ2UiLCJjb25jYXQiLCJlcHJpbnQiLCJlcHJpbnRfcyIsImVwcmludHMiLCJwcmludF9zIiwic2V4cCIsInNlYyIsInNleHBfb2ZfdCIsInRvX3JlcHIiLCJvZl9yZXByIiwibmFtZXMiLCJkZWJ1ZyIsImZvcndhcmRpbmciLCJyIiwic2V0X2ZvcndhcmRpbmciLCJ2IiwiaGFzX3NlZW5fZXJyb3IiLCJzZXRfaGFzX3NlZW5fZXJyb3IiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyIsInNldF90YWlsc19mb3JfYWxsX2Vycm9ycyIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwic2V0X2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwibmV4dF9lcnJvciIsInNldF9uZXh0X2Vycm9yIiwiaWQiLCJoZXJlIiwibmFtZSIsImZvcndhcmRpbmckMCIsImhhc19zZWVuX2Vycm9yJDAiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyQwIiwiaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMkMCIsIm5leHRfZXJyb3IkMCIsImlkJDAiLCJoZXJlJDAiLCJuYW1lJDAiLCJtYWtlX2NyZWF0b3IiLCJuYW1lX2Z1biIsImhlcmVfZnVuIiwiaWRfZnVuIiwibmV4dF9lcnJvcl9mdW4iLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19mdW4iLCJ0YWlsc19mb3JfYWxsX2Vycm9yc19mdW4iLCJoYXNfc2Vlbl9lcnJvcl9mdW4iLCJmb3J3YXJkaW5nX2Z1biIsImNvbXBpbGVfYWNjIiwiY29tcGlsZV9hY2MkMCIsIm5hbWVfZ2VuIiwiY29tcGlsZV9hY2MkMSIsImhlcmVfZ2VuIiwiY29tcGlsZV9hY2MkMiIsImlkX2dlbiIsImNvbXBpbGVfYWNjJDMiLCJuZXh0X2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDQiLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19nZW4iLCJjb21waWxlX2FjYyQ1IiwidGFpbHNfZm9yX2FsbF9lcnJvcnNfZ2VuIiwiY29tcGlsZV9hY2MkNiIsImhhc19zZWVuX2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDciLCJmb3J3YXJkaW5nX2dlbiIsImFjYyIsImNyZWF0ZSIsIm1hcCIsIml0ZXIiLCJmb2xkIiwiaW5pdCIsIm1hcF9wb2x5IiwicmVjb3JkIiwiZm9yX2FsbCIsImV4aXN0cyIsInRvX2xpc3QiLCJpdGVyJDAiLCJmb2xkJDAiLCJmb3JfYWxsJDAiLCJleGlzdHMkMCIsInRvX2xpc3QkMCIsIm1hcCQwIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyIsInJlY29yZCQwIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbnMiLCJ0JDEiLCJhYyIsImFjJDAiLCJ0JDAiLCJ4XzAwMSIsIm5leHRfaWQiLCJjcmVhdGVfd2l0aF9wYXJlbnQiLCJpbmZvIiwicGFyZW50IiwiaSIsInMiLCJzJDAiLCJ4XzAwMiIsInBhcmVudCQwIiwibWFpbiIsImJhY2t0cmFjZV9oaXN0b3J5IiwibG9jYWxfc3RvcmFnZSIsInByaW9yaXR5IiwibW9uaXRvciIsImJhY2t0cmFjZV9oaXN0b3J5JDAiLCJsb2NhbF9zdG9yYWdlJDAiLCJwcmlvcml0eSQwIiwibW9uaXRvciQwIiwibW9uaXRvcl9mdW4iLCJwcmlvcml0eV9mdW4iLCJsb2NhbF9zdG9yYWdlX2Z1biIsImJhY2t0cmFjZV9oaXN0b3J5X2Z1biIsIm1vbml0b3JfZ2VuIiwicHJpb3JpdHlfZ2VuIiwibG9jYWxfc3RvcmFnZV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV8wMDgiLCJsb2NhbF9zdG9yYWdlXzAwNiIsInByaW9yaXR5XzAwNCIsIm1vbml0b3JfMDAyIiwiYXJnXzAwOSIsImJuZHNfMDAxIiwiYXJnXzAwNyIsImJuZHNfMDAxJDAiLCJhcmdfMDA1IiwiYm5kc18wMDEkMSIsImFyZ18wMDMiLCJibmRzXzAwMSQyIiwiaW52YXJpYW50IiwiY3JlYXRlX2xpa2UiLCJmaW5kX2xvY2FsIiwia2V5Iiwid2l0aF9sb2NhbCIsImRhdGEiLCJyZWNvcmRfYmFja3RyYWNlIiwiZHVtbXlfZSIsImR1bW15X2YiLCJkdW1teV9hIiwic2V4cF9vZl9zbG90cyIsIm9mX2V2ZW50IiwiZXZlbnQiLCJvZl9qb2IiLCJqb2IiLCJpc19ldmVudCIsImlzX2pvYiIsImtpbmQiLCJwcm9qZWN0Iiwiam9iX29yX2V2ZW50IiwiZXZlbnRzIiwic2V0X2V4ZWN1dGlvbl9jb250ZXh0IiwiZXhlY3V0aW9uX2NvbnRleHQiLCJsZW5ndGgiLCJzZXRfbGVuZ3RoIiwiZnJvbnQiLCJzZXRfZnJvbnQiLCJtYXNrIiwic2V0X21hc2siLCJqb2JzIiwic2V0X2pvYnMiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSIsInNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSIsIm51bV9qb2JzX3J1biIsInNldF9udW1fam9ic19ydW4iLCJsZW5ndGgkMCIsImZyb250JDAiLCJtYXNrJDAiLCJqb2JzJDAiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSQwIiwibnVtX2pvYnNfcnVuJDAiLCJudW1fam9ic19ydW5fMDAyIiwiam9ic19sZWZ0X3RoaXNfY3ljbGVfMDA0Iiwiam9ic18wMDYiLCJtYXNrXzAwOCIsImZyb250XzAxMCIsImxlbmd0aF8wMTIiLCJhcmdfMDEzIiwiYXJnXzAxMSIsImJuZHNfMDAxJDMiLCJibmRzXzAwMSQ0Iiwib2Zmc2V0IiwiY2FwYWNpdHkiLCJjaGVjayIsImYiLCJsZW5ndGhfZnVuIiwiZnJvbnRfZnVuIiwibWFza19mdW4iLCJqb2JzX2Z1biIsImpvYnNfbGVmdF90aGlzX2N5Y2xlX2Z1biIsIm51bV9qb2JzX3J1bl9mdW4iLCJjcmVhdGVfYXJyYXkiLCJjbGVhciIsInNldCIsImEiLCJvZmZzZXQkMCIsImVucXVldWUiLCJvbGRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJvbGRfam9icyIsIm9sZF9mcm9udCIsImxlbjEiLCJsZW4yIiwibmV3X2pvYnMiLCJzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUkMCIsIm4iLCJjYW5fcnVuX2Ffam9iIiwicnVuX2pvYiIsInNjaGVkdWxlciIsInJ1bl9leHRlcm5hbF9qb2JzIiwiZXh0ZXJuYWxfam9icyIsInJ1bl9qb2JzIiwidGhpc19qb2IiLCJleG4kMCIsImV4biIsImJhY2t0cmFjZSIsInBvcyQzIiwicG9zJDIiLCJwb3MkMSIsInBvcyQwIiwicG9zIiwibmFtZXMkMCIsImlzX251bGwiLCJkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWciLCJjb21wYXJlJDAiLCJlcXVhbCQwIiwic2V4cF9vZl90JDEiLCJ0cmFuc2l0aW9uX2lzX2FsbG93ZWQiLCJmcm9tIiwidG8iLCJzZXhwX29mX2V2ZW50IiwiYXQiLCJpbnRlcnZhbCIsInN0YXR1cyIsIm1hdGNoIiwibm9uZSIsInNvbWUiLCJpc19ub25lIiwiaXNfc29tZSIsImZpcnN0X3NvbWUiLCJ0MSIsInQyIiwidW5zYWZlX3ZhbHVlIiwic2V4cF9vZl90JDIiLCJwcHhfb3B0aW9uYWxfZV8wIiwidmFsdWUkMCIsImRlZmF1bHQkMCIsInZhbHVlX2V4biIsInRvX29wdGlvbiIsIm9mX29wdGlvbiIsInNldF9zdGF0dXMiLCJwcmV2X2ZpcmVkIiwic2V0X3ByZXZfZmlyZWQiLCJuZXh0X2ZpcmVkIiwic2V0X25leHRfZmlyZWQiLCJzZXRfaW50ZXJ2YWwiLCJjYWxsYmFjayIsImF0JDAiLCJzZXRfYXQiLCJhbGFybSIsInNldF9hbGFybSIsInN0YXR1cyQwIiwicHJldl9maXJlZCQwIiwibmV4dF9maXJlZCQwIiwiaW50ZXJ2YWwkMCIsImV4ZWN1dGlvbl9jb250ZXh0JDAiLCJjYWxsYmFjayQwIiwiYXQkMSIsImFsYXJtJDAiLCJhbGFybV9mdW4iLCJhdF9mdW4iLCJjYWxsYmFja19mdW4iLCJleGVjdXRpb25fY29udGV4dF9mdW4iLCJpbnRlcnZhbF9mdW4iLCJuZXh0X2ZpcmVkX2Z1biIsInByZXZfZmlyZWRfZnVuIiwic3RhdHVzX2Z1biIsImFsYXJtX2dlbiIsImF0X2dlbiIsImNhbGxiYWNrX2dlbiIsImV4ZWN1dGlvbl9jb250ZXh0X2dlbiIsImludGVydmFsX2dlbiIsIm5leHRfZmlyZWRfZ2VuIiwicHJldl9maXJlZF9nZW4iLCJzdGF0dXNfZ2VuIiwiZ290Iiwic2V4cGlmaWVyIiwiY29tcGFyYXRvciIsImFfMDEzIiwiYl8wMTQiLCJhXzAwOSIsImJfMDEwIiwiZXhwZWN0IiwiYV8wMDUiLCJiXzAwNiIsInNldF9zdGF0dXMkMCIsInNldF9zdGF0dXNfaWYiLCJpcyIsInNleHBfb2ZfdCQzIiwiayIsImlzX3dhbGxfY2xvY2siLCJoYW5kbGVfZmlyZWQiLCJtb3N0X3JlY2VudGx5X2ZpcmVkIiwic2V0X21vc3RfcmVjZW50bHlfZmlyZWQiLCJmaXJlZF9ldmVudHMiLCJzZXRfZmlyZWRfZXZlbnRzIiwiYW1fYWR2YW5jaW5nIiwic2V0X2FtX2FkdmFuY2luZyIsImFkdmFuY2VfZXJyb3JzIiwic2V0X2FkdmFuY2VfZXJyb3JzIiwic2NoZWR1bGVyJDAiLCJpc193YWxsX2Nsb2NrJDAiLCJoYW5kbGVfZmlyZWQkMCIsIm1vc3RfcmVjZW50bHlfZmlyZWQkMCIsImZpcmVkX2V2ZW50cyQwIiwiZXZlbnRzJDAiLCJhbV9hZHZhbmNpbmckMCIsImFkdmFuY2VfZXJyb3JzJDAiLCJtYWtlX2NyZWF0b3IkMCIsImFkdmFuY2VfZXJyb3JzX2Z1biIsImFtX2FkdmFuY2luZ19mdW4iLCJldmVudHNfZnVuIiwiZmlyZWRfZXZlbnRzX2Z1biIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZnVuIiwiaGFuZGxlX2ZpcmVkX2Z1biIsImlzX3dhbGxfY2xvY2tfZnVuIiwic2NoZWR1bGVyX2Z1biIsImFkdmFuY2VfZXJyb3JzX2dlbiIsImFtX2FkdmFuY2luZ19nZW4iLCJldmVudHNfZ2VuIiwiZmlyZWRfZXZlbnRzX2dlbiIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZ2VuIiwiaGFuZGxlX2ZpcmVkX2dlbiIsImlzX3dhbGxfY2xvY2tfZ2VuIiwiY29tcGlsZV9hY2MkOCIsInNjaGVkdWxlcl9nZW4iLCJjcmVhdGUkMCIsIm1hcCQxIiwiaXRlciQxIiwiZm9sZCQxIiwibWFwX3BvbHkkMCIsImZvcl9hbGwkMSIsImV4aXN0cyQxIiwidG9fbGlzdCQxIiwiaXRlciQyIiwiZm9sZCQyIiwiZm9yX2FsbCQyIiwiZXhpc3RzJDIiLCJ0b19saXN0JDIiLCJtYXAkMiIsInNldF9hbGxfbXV0YWJsZV9maWVsZHMkMCIsInNleHBfb2ZfdCQ0Iiwibm93IiwiYWxsX2V2ZW50cyIsImF0MiIsImF0MSIsInRpbWluZ193aGVlbF9ub3ciLCJpc19pbl9maXJlZF9ldmVudHMiLCJ0YXJnZXRfZXZlbnQiLCJjdXJyZW50JDEiLCJjdXJyZW50IiwiY3VycmVudCQwIiwiaW52YXJpYW50X3dpdGhfam9icyIsImpvYl9pbnZhcmlhbnQiLCJ4XzAxNiIsInBweF9vcHRpb25hbF9lXzAkMCIsImFfMDE3IiwiYl8wMTgiLCJnb3QkMCIsInNleHBpZmllciQwIiwiY29tcGFyYXRvciQwIiwiYV8wMTkiLCJiXzAyMCIsImludmFyaWFudCQwIiwic2V4cF9vZl90JDUiLCJ4XzAyMSIsImludmFyaWFudCQxIiwiaW52YXJpYW50X3dpdGhfam9icyQwIiwic2V4cF9vZl90JDYiLCJ4XzAyMiIsImlkJDEiLCJpc193YWxsX2Nsb2NrJDEiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwicmVhZF9vbmx5IiwiZmlyZSIsImNvbnRpbnVlJDAiLCJuZXh0JDAiLCJjb250aW51ZSQxIiwicHB4X29wdGlvbmFsX2VfMCQxIiwibmV4dCIsInBweF9vcHRpb25hbF9lXzAkMiIsInByZXYiLCJhbGFybV9wcmVjaXNpb24iLCJuZXh0X2FsYXJtX2ZpcmVzX2F0IiwibmV4dF9hbGFybV9ydW5zX2F0Iiwibm93JDAiLCJ0aW1pbmdfd2hlZWxfbm93JDAiLCJzY2hlZHVsZSIsInJlbW92ZV9mcm9tX2ZpcmVkIiwibmV3X3N0YXR1cyIsInNleHBfb2ZfZXZlbnQkMCIsInN0YXR1cyQxIiwicHJldl9maXJlZCQxIiwic2V0X3ByZXZfZmlyZWQkMCIsIm5leHRfZmlyZWQkMSIsInNldF9uZXh0X2ZpcmVkJDAiLCJpbnRlcnZhbCQxIiwic2V0X2ludGVydmFsJDAiLCJleGVjdXRpb25fY29udGV4dCQxIiwiY2FsbGJhY2skMSIsInNldF9hdCQwIiwiYWxhcm0kMSIsInNldF9hbGFybSQwIiwic2V4cF9vZl90JDciLCJpbnZhcmlhbnQkMiIsInNldF9zdGF0dXMkMSIsInNldF9zdGF0dXNfaWYkMCIsInNjaGVkdWxlZF9hdCIsImNyZWF0ZV9pbnRlcm5hbCIsImFkZCQwIiwiY3JlYXRlX2FuZF9hZGQiLCJhdCQyIiwiYWZ0ZXIkMCIsInJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wciIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXRfaW50ZXJ2YWxzIiwic2V4cF9vZl90JDgiLCJhYm9ydCIsImFib3J0X2lmX3Bvc3NpYmxlIiwiYWJvcnRfZXhuIiwicmVhc29uIiwiY3JlYXRlJDEiLCJzY2hlZHVsZV9hdF9pbnRlcm5hbCIsInNjaGVkdWxlX2F0Iiwic2NoZWR1bGVfYWZ0ZXIiLCJzY2hlZHVsZV9hdF9pbnRlcnZhbHMiLCJyZXNjaGVkdWxlX2F0IiwicmVzY2hlZHVsZV9hZnRlciIsInJ1bl9hZnRlciIsInJ1bl9hdCIsInJ1bl9hdF9pbnRlcnZhbHMiLCJydW5fZmlyZWRfZXZlbnRzIiwic2VuZF9leG4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0Iiwic2VuZF9leG4kMCIsImFkdmFuY2VfY2xvY2siLCJmaXJlX3Bhc3RfYWxhcm1zIiwiYWR2YW5jZV9pbnRlcm5hbCIsInByZXBhcmVfdG9fYWR2YW5jZSIsImZpbmlzaF9hZHZhbmNpbmciLCJlcnJvcnMiLCJhZHZhbmNlX2J5X2FsYXJtcyIsIm1pbl9hbGFybV90aW1lIiwiYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfIiwiYWR2YW5jZV9kaXJlY3RseSIsImR1cmF0aW9uX29mIiwic3RhcnQiLCJkdXJhdGlvbiIsIm1heF9hbGFybV90aW1lX2luX21pbl90aW1pbmdfdyIsImhhc19ldmVudHNfdG9fcnVuIiwiY3JlYXRlX3dpdGhfY2VsbCIsImNlbGwiLCJjcmVhdGVfZnVsbCIsImV4ZWMiLCJleGVjJDAiLCJleGVjX2Z1biIsImV4ZWNfZ2VuIiwic2V4cF9vZl90JDAiLCJleGVjdXRpb25fY29udGV4dF8wMDIiLCJyZWNvcmRfYmFja3RyYWNlcyIsInNldF9yZWNvcmRfYmFja3RyYWNlcyIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyIsInNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XyIsImNoZWNrX2ludmFyaWFudHMiLCJzZXRfY2hlY2tfaW52YXJpYW50cyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwic2V0X3lpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwieWllbGQkMCIsInNldF95aWVsZCIsImV2ZW50X2FkZGVkX2hvb2siLCJzZXRfZXZlbnRfYWRkZWRfaG9vayIsImpvYl9xdWV1ZWRfaG9vayIsInNldF9qb2JfcXVldWVkX2hvb2siLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayIsInNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaCIsInRpbWVfc291cmNlIiwic2V0X3RpbWVfc291cmNlIiwidG90YWxfY3ljbGVfdGltZSIsInNldF90b3RhbF9jeWNsZV90aW1lIiwibGFzdF9jeWNsZV9udW1fam9icyIsInNldF9sYXN0X2N5Y2xlX251bV9qb2JzIiwibGFzdF9jeWNsZV90aW1lIiwic2V0X2xhc3RfY3ljbGVfdGltZSIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfZW5kIiwic2V0X3J1bl9ldmVyeV9jeWNsZV9lbmQiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnQiLCJzZXRfcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IiwiaW5fY3ljbGUiLCJzZXRfaW5fY3ljbGUiLCJjeWNsZV9zdGFydCIsInNldF9jeWNsZV9zdGFydCIsImN5Y2xlX2NvdW50Iiwic2V0X2N5Y2xlX2NvdW50IiwidW5jYXVnaHRfZXhuX3Vud3JhcHBlZCIsInNldF91bmNhdWdodF9leG4iLCJzZXRfY3VycmVudF9leGVjdXRpb25fY29udGV4dCIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHQiLCJzZXRfbWFpbl9leGVjdXRpb25fY29udGV4dCIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMiLCJsb3dfcHJpb3JpdHlfam9icyIsIm5vcm1hbF9wcmlvcml0eV9qb2JzIiwiam9iX3Bvb2wiLCJzZXRfam9iX3Bvb2wiLCJjaGVja19hY2Nlc3MiLCJzZXRfY2hlY2tfYWNjZXNzIiwicmVjb3JkX2JhY2t0cmFjZXMkMCIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyQwIiwiY2hlY2tfaW52YXJpYW50cyQwIiwieWllbGRfdW50aWxfbm9fam9ic19yZW1haW4kMCIsInlpZWxkJDEiLCJldmVudF9hZGRlZF9ob29rJDAiLCJqb2JfcXVldWVkX2hvb2skMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rJDAiLCJleHRlcm5hbF9qb2JzJDAiLCJ0aW1lX3NvdXJjZSQwIiwidG90YWxfY3ljbGVfdGltZSQwIiwibGFzdF9jeWNsZV9udW1fam9icyQwIiwibGFzdF9jeWNsZV90aW1lJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kJDAiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUkMCIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydCQwIiwiaW5fY3ljbGUkMCIsImN5Y2xlX3N0YXJ0JDAiLCJjeWNsZV9jb3VudCQwIiwidW5jYXVnaHRfZXhuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQwIiwibWFpbl9leGVjdXRpb25fY29udGV4dCQwIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyQwIiwibG93X3ByaW9yaXR5X2pvYnMkMCIsIm5vcm1hbF9wcmlvcml0eV9qb2JzJDAiLCJqb2JfcG9vbCQwIiwiY2hlY2tfYWNjZXNzJDAiLCJjaGVja19hY2Nlc3NfZnVuIiwiam9iX3Bvb2xfZnVuIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfZnVuIiwibG93X3ByaW9yaXR5X2pvYnNfZnVuIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc19mdW4iLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfZnVuIiwidW5jYXVnaHRfZXhuX2Z1biIsImN5Y2xlX2NvdW50X2Z1biIsImN5Y2xlX3N0YXJ0X2Z1biIsImluX2N5Y2xlX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9mdW4iLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfZnUiLCJydW5fZXZlcnlfY3ljbGVfZW5kX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZnVuIiwibGFzdF9jeWNsZV90aW1lX2Z1biIsImxhc3RfY3ljbGVfbnVtX2pvYnNfZnVuIiwidG90YWxfY3ljbGVfdGltZV9mdW4iLCJ0aW1lX3NvdXJjZV9mdW4iLCJleHRlcm5hbF9qb2JzX2Z1biIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyIsImpvYl9xdWV1ZWRfaG9va19mdW4iLCJldmVudF9hZGRlZF9ob29rX2Z1biIsInlpZWxkX2Z1biIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluX2Z1biIsImNoZWNrX2ludmFyaWFudHNfZnVuIiwicmVjb3JkX2JhY2t0cmFjZXNfZnVuIiwiY2hlY2tfYWNjZXNzX2dlbiIsImpvYl9wb29sX2dlbiIsIm5vcm1hbF9wcmlvcml0eV9qb2JzX2dlbiIsImxvd19wcmlvcml0eV9qb2JzX2dlbiIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfZ2VuIiwibWFpbl9leGVjdXRpb25fY29udGV4dF9nZW4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0X2dlbiIsInVuY2F1Z2h0X2V4bl9nZW4iLCJjeWNsZV9jb3VudF9nZW4iLCJjb21waWxlX2FjYyQ5IiwiY3ljbGVfc3RhcnRfZ2VuIiwiY29tcGlsZV9hY2MkMTAiLCJpbl9jeWNsZV9nZW4iLCJjb21waWxlX2FjYyQxMSIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9nZW4iLCJjb21waWxlX2FjYyQxMiIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZV9nZSIsImNvbXBpbGVfYWNjJDEzIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF9nZW4iLCJjb21waWxlX2FjYyQxNCIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZ2VuIiwiY29tcGlsZV9hY2MkMTUiLCJsYXN0X2N5Y2xlX3RpbWVfZ2VuIiwiY29tcGlsZV9hY2MkMTYiLCJsYXN0X2N5Y2xlX251bV9qb2JzX2dlbiIsImNvbXBpbGVfYWNjJDE3IiwidG90YWxfY3ljbGVfdGltZV9nZW4iLCJjb21waWxlX2FjYyQxOCIsInRpbWVfc291cmNlX2dlbiIsImNvbXBpbGVfYWNjJDE5IiwiZXh0ZXJuYWxfam9ic19nZW4iLCJjb21waWxlX2FjYyQyMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyQwIiwiY29tcGlsZV9hY2MkMjEiLCJqb2JfcXVldWVkX2hvb2tfZ2VuIiwiY29tcGlsZV9hY2MkMjIiLCJldmVudF9hZGRlZF9ob29rX2dlbiIsImNvbXBpbGVfYWNjJDIzIiwieWllbGRfZ2VuIiwiY29tcGlsZV9hY2MkMjQiLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl9nZW4iLCJjb21waWxlX2FjYyQyNSIsImNoZWNrX2ludmFyaWFudHNfZ2VuIiwiY29tcGlsZV9hY2MkMjYiLCJtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl8kMSIsImNvbXBpbGVfYWNjJDI3IiwicmVjb3JkX2JhY2t0cmFjZXNfZ2VuIiwiY3JlYXRlJDIiLCJjaGVja19hY2Nlc3NfMDA3Iiwiam9iX3Bvb2xfMDA5IiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc18wMTUiLCJsb3dfcHJpb3JpdHlfam9ic18wMTMiLCJub3JtYWxfcHJpb3JpdHlfam9ic18wMTEiLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0XzAxNyIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfMDE5IiwidW5jYXVnaHRfZXhuXzAyMSIsImN5Y2xlX2NvdW50XzAyNyIsImN5Y2xlX3N0YXJ0XzAyOSIsImluX2N5Y2xlXzAzMSIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF8wMzMiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfMDMiLCJydW5fZXZlcnlfY3ljbGVfZW5kXzAzNyIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfMDM5IiwibGFzdF9jeWNsZV90aW1lXzA0MSIsImxhc3RfY3ljbGVfbnVtX2pvYnNfMDQzIiwidG90YWxfY3ljbGVfdGltZV8wNDUiLCJ0aW1lX3NvdXJjZV8wNDciLCJleHRlcm5hbF9qb2JzXzA0OSIsImpvYl9xdWV1ZWRfaG9va18wNTMiLCJldmVudF9hZGRlZF9ob29rXzA1NSIsInlpZWxkXzA1NyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluXzA1OSIsImNoZWNrX2ludmFyaWFudHNfMDYxIiwicmVjb3JkX2JhY2t0cmFjZXNfMDY1IiwiYXJnXzA2NiIsImJuZHNfMDA2IiwiYXJnXzA2NCIsImJuZHNfMDA2JDAiLCJhcmdfMDYyIiwiYm5kc18wMDYkMSIsImFyZ18wNjAiLCJibmRzXzAwNiQyIiwiYXJnXzA1OCIsImJuZHNfMDA2JDMiLCJhcmdfMDU2IiwiYm5kc18wMDYkNCIsImFyZ18wNTQiLCJibmRzXzAwNiQ1IiwiYXJnXzA1MiIsImJuZHNfMDA2JDYiLCJhcmdfMDUwIiwiYm5kc18wMDYkNyIsImFyZ18wNDgiLCJibmRzXzAwNiQ4IiwiYXJnXzA0NiIsImJuZHNfMDA2JDkiLCJhcmdfMDQ0IiwiYm5kc18wMDYkMTAiLCJhcmdfMDQyIiwiYm5kc18wMDYkMTEiLCJhcmdfMDQwIiwiYm5kc18wMDYkMTIiLCJhcmdfMDM4IiwiYm5kc18wMDYkMTMiLCJhcmdfMDM2IiwiYm5kc18wMDYkMTQiLCJhcmdfMDM0IiwiYm5kc18wMDYkMTUiLCJhcmdfMDMyIiwiYm5kc18wMDYkMTYiLCJhcmdfMDMwIiwiYm5kc18wMDYkMTciLCJhcmdfMDI4IiwiYm5kc18wMDYkMTgiLCJhcmdfMDIyIiwiYXJnMV8wMjQiLCJhcmcwXzAyMyIsInJlczBfMDI1IiwicmVzMV8wMjYiLCJibmRzXzAwNiQxOSIsImFyZ18wMjAiLCJibmRzXzAwNiQyMCIsImFyZ18wMTgiLCJibmRzXzAwNiQyMSIsImFyZ18wMTYiLCJibmRzXzAwNiQyMiIsImFyZ18wMTQiLCJibmRzXzAwNiQyMyIsImFyZ18wMTIiLCJibmRzXzAwNiQyNCIsImFyZ18wMTAiLCJibmRzXzAwNiQyNSIsImFyZ18wMDgiLCJibmRzXzAwNiQyNiIsInVuY2F1Z2h0X2V4biQwIiwiYXJnMV8wNjgiLCJhcmcwXzA2NyIsInJlczBfMDY5IiwicmVzMV8wNzAiLCJudW1fcGVuZGluZ19qb2JzIiwibGFzdF9jeWNsZV9udW1fam9icyQxIiwidW5vcmRlcmVkX2lzX3N1Ymxpc3QiLCJlcXVhbCIsInNtYWxsIiwibGFyZ2UiLCJ4IiwibCQwIiwieSIsImwiLCJjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCIsInRhYmxlIiwibGlzdCIsImZpZWxkIiwicSIsImZyZWVfam9iIiwiam9iX3F1ZXVlIiwiZiQwIiwiZW5xdWV1ZV9qb2IiLCJjcmVhdGUkMyIsImlzX2RlYWQiLCJzZXRfY2hlY2tfYWNjZXNzJDAiLCJ0X3JlZiIsImNoZWNrX2FjY2VzcyQxIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQxIiwid2l0aF9leGVjdXRpb25fY29udGV4dDEiLCJ0bXBfY29udGV4dCIsIm9sZF9jb250ZXh0Iiwid2l0aF9leGVjdXRpb25fY29udGV4dCIsImNyZWF0ZV9qb2IiLCJnb3RfdW5jYXVnaHRfZXhuIiwiYXJnMV8wNzIiLCJhcmcwXzA3MSIsInJlczBfMDczIiwicmVzMV8wNzQiLCJzdGFydF9jeWNsZSIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHkiLCJlIiwiZSQwIiwic3RhYmlsaXplIiwiY3JlYXRlX3RpbWVfc291cmNlIiwib3B0Iiwic3RoIiwidGltaW5nX3doZWVsX2NvbmZpZyIsIndhbGxfY2xvY2siLCJzZXRfcHJldiIsInBhcmFtIiwic2V0X25leHQiLCJydW4iLCJjcmVhdGUyIiwicnVuMSIsImV4ZWN1dGlvbl9jb250ZXh0MSIsInJ1bjIiLCJleGVjdXRpb25fY29udGV4dDIiLCJzY2hlZHVsZV9qb2JzIiwiYWRkIiwib2ZfbGlzdCIsImZpcnN0IiwibCQxIiwibCQyIiwicnVuJDAiLCJwcmV2JDAiLCJhY2MkMCIsImNlbGxfb2ZfaGFuZGxlciIsImluZGlyIiwic3F1YXNoIiwidCQzIiwidCQ0IiwiaW5kaXIkMSIsInQkNSIsImluZGlyJDAiLCJ0JDIiLCJhX2ludmFyaWFudCIsImhhbmRsZXIiLCJwZWVrIiwidmFsdWUiLCJpZl9lbXB0eV90aGVuX2ZhaWx3aXRoIiwiaXNfZW1wdHkiLCJpc19mdWxsIiwiZmlsbCIsInJlbW92ZV9oYW5kbGVyIiwieCQwIiwiYWRkX2hhbmRsZXIiLCJoYW5kbGVyJDEiLCJoYW5kbGVyJDIiLCJydW4kMSIsImhhbmRsZXIkMCIsImhhc19oYW5kbGVycyIsInVwb24iLCJ1cG9uJDAiLCJjb25uZWN0IiwiYmluZF9yZXN1bHQiLCJiaW5kX3JocyIsImJpbmRfcmVzdWx0JDAiLCJpdmFyIiwiYmluZF9yaHNfY29udGVudHMiLCJpdmFyJDAiLCJsYXN0MSIsImxhc3QyIiwiaGFuZGxlcjEiLCJleGVjdXRpb25fY29udGV4dDIkMCIsInJ1bjIkMCIsImhhbmRsZXIxJDAiLCJ2JDAiLCJvZl9pdmFyIiwiaW52YXJpYW50X2EiLCJyZXR1cm4kMCIsImlzX2RldGVybWluZWQiLCJiaW5kIiwiaCIsInJlYWQiLCJmaWxsX2lmX2VtcHR5IiwidG9fYmluYWJsZSIsIm9mX2JpbmFibGUiLCJzZXhwX29mX2hvdyIsInZfMDAxIiwibmV2ZXIiLCJyZXR1cm4kMSIsInJldHVybiQyIiwicmV0dXJuJDMiLCJ1bml0IiwiYm90aCQwIiwiYTEiLCJhMiIsImRvbl90X3dhaXRfZm9yIiwiZjIiLCJmMSIsInByb2Nlc3MiLCJyZXN0IiwiY2hvaWNlIiwiZW5hYmxlZCIsImNob2ljZXMiLCJ1bnJlZ2lzdGVycyIsInJlYWR5IiwiY2hvb3NlX3Jlc3VsdCIsImNob2ljZXMkMCIsImNob2ljZXMkMSIsImNob29zZSIsImFueV9mIiwidHMiLCJhbnkiLCJhbnlfdW5pdCIsImZvciQwIiwiZG8kMCIsImxvb3AiLCJyZXBlYXRfdW50aWxfZmluaXNoZWQiLCJzdGF0ZSIsImZpbmlzaGVkIiwiZm9yZXZlciIsImIiLCJ4cyIsInNlcW1hcCIsImJzIiwiYWxsIiwiZHMiLCJhbGxfdW5pdCIsImQiLCJvayIsIm9mX2FfMDA1IiwieF8wMDYiLCJhcmcwXzAwMiIsInJlczBfMDAzIiwieF8wMDciLCJjb2xsZWN0IiwiaXNfY2xvc2VkIiwiZmlsbF9leG4iLCJjbG9zZV9leG4iLCJjbG9zZV9pZl9vcGVuIiwiZXh0ZW5kIiwiZGVmZXJyZWQwIiwiZGVmZXJyZWQxIiwiaW1wb3J0MCIsImVycm9yIiwiZGV0YWNoIiwiZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyIsImhhbmRsZXJfc3RhdGVfcmVmIiwicnVuX2YiLCJiYWdfZWx0IiwiaW5uZXJfZXhuJDAiLCJpbm5lcl9leG4iLCJkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0iLCJ0YWlsIiwiZ2V0X25leHRfZXJyb3IiLCJkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIiwiZXh0cmFjdF9leG4iLCJjb2x1bW4iLCJtb25pdG9yJDEiLCJuYW1lJDEiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwicmVzdCQwIiwicmVzdCQxIiwidDMiLCJyZXN0JDIiLCJyZXN0JDMiLCJ0cmFjZXMiLCJyZXN0JDQiLCJ0MSQwIiwicmVzdCQ1IiwidDIkMCIsInJlc3QkNiIsInQyJDEiLCJiYWNrdHJhY2UkMiIsImxpc3RfaWZfbm90X2VtcHR5IiwibWF0Y2gkMiIsIm1hdGNoJDMiLCJleHRyYWN0X2V4biQwIiwiYXJnMV8wMDQiLCJhcmcwXzAwMyIsImFyZzFfMDA4IiwiYXJnMF8wMDciLCJyZXMwXzAwOSIsInJlczFfMDEwIiwid2l0aGluX2NvbnRleHQiLCJjb250ZXh0Iiwid2l0aGluX2dlbiIsIndpdGhpbiIsIndpdGhpbl92Iiwid2l0aGluJDAiLCJzY2hlZHVsZV93aXRoX2RhdGEiLCJ3b3JrIiwidXBvbl93b3JrX2ZpbGxfaSIsInNjaGVkdWxlJDAiLCJwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCIsInByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0JDAiLCJjYWxsX2FuZF9maWxsIiwic3RyZWFtX2l0ZXIiLCJzdHJlYW0iLCJleG5zIiwiZmlsbF9yZXN1bHRfYW5kX2hhbmRsZV9iYWNrZ3JvIiwicmVzdWx0X2ZpbGxlciIsImhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCIsInRyeV93aXRoX2xvZ19leG4iLCJ0cnlfd2l0aCIsInN0aCQwIiwiZG9fZXh0cmFjdF9leG4iLCJzdGgkMSIsInN0aCQyIiwiaGFuZGxlX2V4biIsInJlcyIsInRyeV93aXRoX29yX2Vycm9yIiwidHJ5X3dpdGhfam9pbl9vcl9lcnJvciIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJmciIsInIkMCIsImZpbmFsbHlfZXhuIiwiaGFuZGxlX2Vycm9ycyIsImNhdGNoX3N0cmVhbSIsImNhdGNoJDAiLCJjYXRjaF9lcnJvciIsImRlcHRoIiwibiQwIiwiZmlyc3RfZXhuIiwibG9vcCQwIiwibG9vcF9uZXh0IiwibG9vcF9uZXh0JDAiLCJjbG9zZWQiLCJ1bmZvbGQiLCJjb3B5X3RvX3RhaWwiLCJhcHBlbmQiLCJmaWx0ZXJfZGVwcmVjYXRlZCIsImZpbHRlcl9tYXBfZGVwcmVjYXRlZCIsImZpcnN0X24iLCJhdmFpbGFibGVfbm93Iiwic3BsaXQiLCJzdG9wIiwicmVhc29uX2Zvcl9zdG9wcGluZyIsInByZWZpeCIsImZpbmlzaCIsIm8iLCJmaW5kIiwiZm91bmQiLCJ1bmdyb3VwIiwiaW50ZXJsZWF2ZSIsIm51bV9vcGVuIiwiY2xvc2UiLCJvdXRlcl9jbG9zZWQiLCJ0YWtlX3VudGlsIiwieiIsIml0ZXJfZHVyYWJseSIsIml0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIiwiaXRlcl9kdXJhYmx5JDAiLCJvZl9mdW4iLCJzZXRfaXZhciIsImhhc19hbnlfd2FpdGVycyIsInNldF9oYXNfYW55X3dhaXRlcnMiLCJoYXNfYW55X3dhaXRlcnMkMCIsInJlcHIiLCJvZl9hXzAwMSIsImhhc19hbnlfd2FpdGVyc18wMDMiLCJpdmFyXzAwNSIsImFyZ18wMDYiLCJibmRzXzAwMiIsImFyZ18wMDQiLCJibmRzXzAwMiQwIiwiaXZhcl9mdW4iLCJoYXNfYW55X3dhaXRlcnNfZnVuIiwiYnJvYWRjYXN0Iiwid2FpdCIsImhhc19hbnlfd2FpdGVycyQxIiwieF8wMDMiLCJhZHZhbmNlX2RpcmVjdGx5X2J5IiwiYnkiLCJ3YWl0X2ZvciIsInJ1bl9xdWV1ZWRfYWxhcm1zIiwid2Fsa19hbGFybXMiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJxdWV1ZWRfYWxhcm1zX3JhbiIsIm5leHRfYWxhcm1fZmlyZXNfYXQkMCIsImFkdmFuY2VfYnlfYWxhcm1zX2J5Iiwic3Bhbl90b190aW1lIiwicnVuX2F0X2ludGVybmFsIiwidGltZSIsInJlbW92ZV9hbGFybSIsIm9mX2FfMDA4Iiwib2ZfaF8wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwiYXJnMF8wMTIiLCJyZXMwXzAxMyIsInNldF9zY2hlZHVsZWRfYXQiLCJudW1fZmlyZXNfdG9fc2tpcCIsInNldF9udW1fZmlyZXNfdG9fc2tpcCIsImZpcmVkIiwic2NoZWR1bGVkX2F0JDAiLCJudW1fZmlyZXNfdG9fc2tpcCQwIiwiZmlyZWQkMCIsIm9mX2FfMDE2Iiwib2ZfaF8wMTciLCJhbGFybV8wMTkiLCJmaXJlZF8wMjMiLCJudW1fZmlyZXNfdG9fc2tpcF8wMjUiLCJzY2hlZHVsZWRfYXRfMDI3IiwidGltZV9zb3VyY2VfMDI5IiwiYm5kc18wMTgiLCJibmRzXzAxOCQwIiwiYXJnXzAyNiIsImJuZHNfMDE4JDEiLCJhcmdfMDI0IiwiYm5kc18wMTgkMiIsImJuZHNfMDE4JDMiLCJibmRzXzAxOCQ0Iiwic2V4cF9vZl90X3VuaXQiLCJ4XzAzMSIsImZpcmVkJDEiLCJpbnZhcmlhbnRfaCIsInhfMDMyIiwic2NoZWR1bGVkX2F0X2Z1biIsImFfMDMzIiwiYl8wMzQiLCJudW1fZmlyZXNfdG9fc2tpcF9mdW4iLCJmaXJlZF9mdW4iLCJvZl9hXzAzNSIsIm9mX2hfMDM2IiwiYXJnMF8wMzciLCJyZXMwXzAzOCIsImFyZzBfMDM5IiwicmVzMF8wNDAiLCJhcmcwXzA0MSIsInJlczBfMDQyIiwib2ZfYV8wNDUiLCJvZl9oXzA0NiIsImFyZzBfMDQ3IiwicmVzMF8wNDgiLCJhcmcwXzA0OSIsInJlczBfMDUwIiwieF8wNTMiLCJhJDAiLCJvZl9hXzA1NCIsIm9mX2hfMDU1IiwiYXJnMF8wNTYiLCJyZXMwXzA1NyIsImFyZzBfMDU4IiwicmVzMF8wNTkiLCJhcmcxXzA2MyIsImFyZzBfMDYyIiwicmVzMF8wNjQiLCJyZXMxXzA2NSIsImlzX2luX3RpbWluZ193aGVlbCIsImFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZSIsInJ1bl9hdCQwIiwicnVuX2FmdGVyJDAiLCJhdF90aW1lcyIsIm5leHRfdGltZSIsImF0X3ZhcnlpbmdfaW50ZXJ2YWxzIiwiY29tcHV0ZV9zcGFuIiwic3RhcnQkMCIsInJ1bl9yZXBlYXRlZGx5IiwiY29udGludWVfb25fZXJyb3IiLCJzdG9wJDAiLCJzdG9wJDEiLCJjb250aW51ZV90cnlfd2l0aCIsImNvbnRpbnVlX2YiLCJiYXNlIiwib3JfZXJyb3IiLCJldmVyeSIsImV2ZXJ5JDAiLCJzdGFydCQxIiwicnVuX2F0X2ludGVydmFscyQwIiwid2l0aF90aW1lb3V0IiwidGltZW91dCIsIm9mX3N5bmNocm9ub3VzIiwidG9fc3luY2hyb25vdXMiLCJvZl9hXzAwMiIsInJlczBfMDA0IiwibGVuZ3RoXzAwNiIsImJuZHNfMDA1IiwiY3JlYXRlX2NvdW50ZXIiLCJwdXNoIiwicG9wX2V4biIsInNleHBfb2Zfb3V0Y29tZSIsInZfMDAyIiwidl8wMDMiLCJjbGVhbmVkIiwibnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCIsInNldF9udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIiwiY2FwYWNpdHlfYXZhaWxhYmxlIiwic2V0X2NhcGFjaXR5X2F2YWlsYWJsZSIsIm51bV9qb2JzX3J1bm5pbmciLCJzZXRfbnVtX2pvYnNfcnVubmluZyIsImpvYnNfd2FpdGluZ190b19zdGFydCIsImpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSIsIm1heF9jb25jdXJyZW50X2pvYnMiLCJjbGVhbmVkJDAiLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkJDAiLCJjYXBhY2l0eV9hdmFpbGFibGUkMCIsIm51bV9qb2JzX3J1bm5pbmckMCIsImpvYnNfd2FpdGluZ190b19zdGFydCQwIiwiam9iX3Jlc291cmNlc19ub3RfaW5fdXNlJDAiLCJtYXhfY29uY3VycmVudF9qb2JzJDAiLCJvZl9hXzAxMSIsImpvYnNfd2FpdGluZ190b19zdGFydF8wMTkiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VfMDE3IiwibWF4X2NvbmN1cnJlbnRfam9ic18wMTUiLCJjb250aW51ZV9vbl9lcnJvcl8wMTMiLCJudW1fam9ic19ydW5uaW5nXzAyMSIsImNhcGFjaXR5X2F2YWlsYWJsZV8wMjMiLCJpc19kZWFkXzAyNSIsImNsZWFuc18wMjciLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXzAyOSIsImNsZWFuZWRfMDMxIiwiYm5kc18wMTIiLCJibmRzXzAxMiQwIiwiYm5kc18wMTIkMSIsImJuZHNfMDEyJDIiLCJibmRzXzAxMiQzIiwiYm5kc18wMTIkNCIsIm91dGNvbWVfMDA5Iiwic3RhcnRfMDA2Iiwidl8wMDgiLCJibmRzXzAwNSQwIiwiYm5kc18wMTIkNSIsImJuZHNfMDEyJDYiLCJibmRzXzAxMiQ3IiwiYm5kc18wMTIkOCIsInhfMDMzIiwib2ZfYV8wMzQiLCJvZl9raW5kXzAzNSIsInhfMDM2IiwibnVtX2pvYnNfd2FpdGluZ190b19zdGFydCIsImNsZWFuX3Jlc291cmNlIiwia2lsbCIsImF0X2tpbGwiLCJjbGVhbmVkJDEiLCJzdGFydF9qb2IiLCJqb2JfcmVzb3VyY2UiLCJqb2JfcmVzb3VyY2VzIiwiY3JlYXRlX3dpdGgiLCJvdXRjb21lIiwiaW50ZXJuYWxfam9iIiwiaGFuZGxlX2VucXVldWVfcmVzdWx0IiwiZW5xdWV1ZSQwIiwiZW5xdWV1ZV9leGNsdXNpdmUiLCJkb25lIiwiZl9wbGFjZWhvbGRlciIsInNsb3QiLCJtb25hZF9zZXF1ZW5jZV9ob3ciLCJob3ciLCJtb25hZF9zZXF1ZW5jZV9ob3cyIiwicHJpb3Jfam9ic19kb25lIiwiYWxsX2R1bW15X2pvYnNfcnVubmluZyIsImR1bW15X2pvYnNfcnVubmluZyIsImNhcGFjaXR5X2F2YWlsYWJsZSQxIiwiaGFzX3VwY29taW5nX2V2ZW50IiwibmV4dF91cGNvbWluZ19ldmVudCIsIm5leHRfdXBjb21pbmdfZXZlbnRfZXhuIiwiZXZlbnRfcHJlY2lzaW9uIiwiYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2siLCJoYW5kbGUiLCJhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2siLCJyZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2siLCJsc3QiLCJsc3QkMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rXyIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCIsIm1hcF9jeWNsZV90aW1lcyIsImxvbmdfY3ljbGVzIiwiYXRfbGVhc3QiLCJjeWNsZV9udW1fam9icyIsImludCQwIiwidGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qIiwiY3JlYXRlX2FsYXJtIiwiYWRkX2ZpbmFsaXplciIsImhlYXBfYmxvY2siLCJmaW5hbGl6ZXIiLCJhZGRfZmluYWxpemVyX2V4biIsImFkZF9maW5hbGl6ZXJfbGFzdCIsImFkZF9maW5hbGl6ZXJfbGFzdF9leG4iLCJmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCIsInJ1bl9jeWNsZSIsIm51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSIsImN5Y2xlX3RpbWUiLCJyZXMxXzAwNCIsInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haSIsIm1ha2VfYXN5bmNfdW51c2FibGUiLCJyZXNldF9pbl9mb3JrZWRfcHJvY2VzcyIsIm1heV9yZXR1cm5faW1tZWRpYXRlbHkiLCJ5aWVsZF9ldmVyeSIsImNvdW50X3VudGlsX3lpZWxkIiwidGhpc19jeWNsZV90aW1lIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyIsInlpZWxkX3RoZW5fcnVuIiwid29ya2VyIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyQwIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyQxIiwiYnQiLCJxdWV1ZSIsInJ1bm5pbmciLCJ0aHJlYWRfc2FmZV9lbnF1ZXVlX2pvYiIsImN5Y2xlX3N0YXJ0X25zIiwiY3ljbGVfdGltZXNfbnMiLCJjeWNsZV90aW1lcyIsImV2ZW50X3ByZWNpc2lvbl9ucyIsImJvb2wiLCJhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayQwIiwiYWRkX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rJDAiLCJyZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va18kMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCQwIiwid2l0aF9leGVjdXRpb25fY29udGV4dCQwIiwid2l0aF9leGVjdXRpb25fY29udGV4dDEkMCIsImNvbXBhcmUiLCJjbXBfYSIsImFfMDAxIiwiYl8wMDIiLCJyaWdodF8wMDQiLCJsZWZ0XzAwMyIsInZfMDA2IiwiZm9sZGkiLCJzZXFtYXBpIiwiaXRlcmkiLCJtYXBpIiwiZmlsdGVyaSIsImJvb2xzIiwiZmlsdGVyX21hcGkiLCJjb25jYXRfbWFwaSIsImZpbmRfbWFwaSIsImF1eCIsImZpbmRpIiwiZWx0IiwiZXhpc3RzaSIsImZvcl9hbGxpIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImNvbmNhdF9tYXAiLCJmaW5kX21hcCIsInRsIiwiaGQiLCJjaGFuZ2UiLCJ1cGRhdGUiLCJpdGVyX2tleXMiLCJhbGlzdF9pbl9pbmNyZWFzaW5nX2tleV9vcmRlciIsImFsaXN0IiwiZm9sZF9yaWdodCIsImFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyIiwic2VxdWVuY2UiLCJqb2JfbWFwIiwiZmlsdGVyX2tleXMiLCJtZXJnZSIsInRodW5rIiwicmVyYWlzZSIsImdlbmVyYWwiLCJoYXNoYWJsZSIsImNvbWJpbmUiLCJlcnIiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJtYXBfZXJyb3IiLCJpZ25vcmVfbSIsImpvaW4iLCJzeW1ib2xfYmluZCIsImFwcGx5IiwiZTEiLCJlMiIsInN5bWJvbF9iaW5kJDAiLCJzeW1ib2xfbWFwJDAiLCJva19leG4iLCJvZl9leG4iLCJvZl9leG5fcmVzdWx0IiwibXNnIiwic2V4cF9vZiIsImVycm9yX3MiLCJlcnJvcl9zdHJpbmciLCJlcnJvcmYiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfZXJyb3JzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX21hcF9vayIsImN1cnJlbnRfZXJyb3IiLCJlcnJvcnMkMCIsIm9rX3VuaXQiLCJ0cnlfd2l0aCQwIiwidHJ5X3dpdGhfam9pbiIsInN0YXRlJDAiLCJmb2xkX21hcGkiLCJtYXBpX2YiLCJmb2xkX2YiLCJ0aHJvdHRsZSIsImMiLCJjJDEiLCJjJDAiLCJpJDAiLCJhY2N1bSIsIm1heWJlX3YiLCJzaG93X2RlYnVnX21lc3NhZ2VzIiwiY2hlY2tfaW52YXJpYW50IiwieF8wMDQiLCJ2YWx1ZXNfcmVhZCIsInNldF92YWx1ZXNfcmVhZCIsInZhbHVlc19yZWFkJDAiLCJwaXBlX2lkXzAwOSIsInZhbHVlc19yZWFkXzAxMSIsImFyZ18wMTUiLCJibmRzXzAwOCIsInZfMDEzIiwiYm5kc18wMDgkMCIsImJuZHNfMDA4JDEiLCJ2YWx1ZXNfc2VudF9kb3duc3RyZWFtIiwidmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1Iiwid2hlbl9zZW50X2Rvd25zdHJlYW0iLCJjb25zdW1lciIsIndhbnRzIiwiY29uc3VtZXIkMCIsIndhbnRzJDAiLCJvZl9hXzAyOSIsImNvbnN1bWVyXzAzMyIsIndhbnRzXzAzMSIsImJuZHNfMDMwIiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJ2XzAyMCIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInJlczFfMDI3Iiwidl8wMjMiLCJibmRzXzAzMCQwIiwiZmlsbF93aXRoX2VvZiIsImkkMSIsImZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQiLCJyZWFkeV8wMzkiLCJmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXzAzNyIsImJuZHNfMDM2IiwiYm5kc18wMzYkMCIsImNvbnN1bWVycyIsInNldF9jb25zdW1lcnMiLCJibG9ja2VkX3JlYWRzIiwiYmxvY2tlZF9mbHVzaGVzIiwicHVzaGJhY2siLCJzZXRfcHVzaGJhY2siLCJzaXplX2J1ZGdldCIsInNldF9zaXplX2J1ZGdldCIsImNvbnN1bWVycyQwIiwiYmxvY2tlZF9yZWFkcyQwIiwiYmxvY2tlZF9mbHVzaGVzJDAiLCJwdXNoYmFjayQwIiwic2l6ZV9idWRnZXQkMCIsInNleHBfb2ZfcGlwZSIsIm9mX2FfMDQxIiwib2ZfcGhhbnRvbV8wNDIiLCJpZF8wNDQiLCJpbmZvXzA0NiIsImJ1ZmZlcl8wNTAiLCJzaXplX2J1ZGdldF8wNTIiLCJwdXNoYmFja18wNTQiLCJudW1fdmFsdWVzX3JlYWRfMDU2IiwicmVhZF9jbG9zZWRfMDY0IiwiY2xvc2VkXzA2MiIsImJsb2NrZWRfcmVhZHNfMDYwIiwiYmxvY2tlZF9mbHVzaGVzXzA1OCIsImNvbnN1bWVyc18wNjYiLCJ1cHN0cmVhbV9mbHVzaGVkc18wNjgiLCJhcmdfMDY5IiwiYm5kc18wNDMiLCJhcmdfMDY3IiwiYm5kc18wNDMkMCIsImFyZ18wNjUiLCJibmRzXzA0MyQxIiwiYXJnXzA2MyIsImJuZHNfMDQzJDIiLCJhcmdfMDYxIiwiYm5kc18wNDMkMyIsImFyZ18wNTkiLCJibmRzXzA0MyQ0IiwiYXJnXzA1NyIsImJuZHNfMDQzJDUiLCJhcmdfMDU1IiwiYm5kc18wNDMkNiIsImFyZ18wNTMiLCJibmRzXzA0MyQ3IiwiYXJnXzA1MSIsImJuZHNfMDQzJDgiLCJ2XzA0NyIsImFyZ18wNDkiLCJibmRfMDQ4IiwiYm5kc18wNDMkOSIsImFyZ18wNDUiLCJibmRzXzA0MyQxMCIsImhhc2giLCJpc19yZWFkX2Nsb3NlZCIsInB1c2hiYWNrJDEiLCJ4XzA3MyIsInhfMDM1IiwiaSQyIiwic2V4cF9vZl9waGFudG9tIiwib2ZfYV8wNzQiLCJ4XzA3NSIsInNleHBfb2ZfcGhhbnRvbSQwIiwib2ZfYV8wNzYiLCJ4XzA3NyIsImlkX3JlZiIsImluaXRpYWxfYnVmZmVyIiwidmFsaWRhdGVfc2l6ZV9idWRnZXQiLCJ1cGRhdGVfcHVzaGJhY2siLCJ4XzA3OCIsImNsb3NlX3JlYWQiLCJ4XzA3OSIsImZsdXNoIiwiY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjIiwidyIsImNyZWF0ZV9yZWFkZXIiLCJjbG9zZV9vbl9leGNlcHRpb24iLCJjcmVhdGVfd3JpdGVyIiwidmFsdWVzX3dlcmVfcmVhZCIsImZsdXNoJDAiLCJmbHVzaF9yZXN1bHQiLCJjb25zdW1lX29uZSIsImNvbnN1bWUiLCJtYXhfcXVldWVfbGVuZ3RoIiwicmVzdWx0JDAiLCJzZXRfc2l6ZV9idWRnZXQkMCIsInN0YXJ0X3dyaXRlIiwieF8wODEiLCJ4XzA4MCIsImZpbmlzaF93cml0ZSIsImJsb2NrZWRfcmVhZCIsIml2YXIkMSIsInRyYW5zZmVyX2luX3dpdGhvdXRfcHVzaGJhY2siLCJ0cmFuc2Zlcl9pbiIsIndyaXRlIiwid3JpdGVfd2l0aG91dF9wdXNoYmFjayIsIndyaXRlJDAiLCJ3cml0ZV93aGVuX3JlYWR5Iiwid3JpdGVfaWZfb3BlbiIsIndyaXRlX3dpdGhvdXRfcHVzaGJhY2tfaWZfb3BlbiIsImVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIiwieF8wODMiLCJzdGFydF9yZWFkIiwibGFiZWwiLCJ4XzA4NCIsImdlbl9yZWFkX25vdyIsImdldF9tYXhfcXVldWVfbGVuZ3RoIiwibWF4X3F1ZXVlX2xlbmd0aCQwIiwicmVhZF9ub3ciLCJyZWFkX25vdyQwIiwicmVhZCQwIiwicmVhZF9leG4iLCJ2YWx1ZXNfYXZhaWxhYmxlIiwicmVhZF9jaG9pY2UiLCJyZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXgiLCJyZWFkX2V4YWN0bHkiLCJudW1fdmFsdWVzIiwiYWxyZWFkeV9yZWFkIiwiZG93bnN0cmVhbV9mbHVzaGVkIiwidXBzdHJlYW1fZmx1c2hlZCIsImFkZF9jb25zdW1lciIsInBpcGVfaWQiLCJjb25zdW1lciQxIiwidXBzdHJlYW0iLCJkb3duc3RyZWFtIiwidXBzdHJlYW1fZmx1c2hlZCQwIiwiYXJnMF8wODUiLCJyZXMwXzA4NiIsImZvbGRfZ2VuIiwiZmx1c2hlZCIsImZvbGRfd2l0aG91dF9wdXNoYmFjayIsIndpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yIiwiaXRlcl93aXRob3V0X3B1c2hiYWNrIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiIsIm1heF9pdGVyYXRpb25zX3Blcl9qb2IkMCIsIm1heF9pdGVyYXRpb25zX3Blcl9qb2IkMSIsInJlbWFpbmluZyIsInJlbWFpbmluZyQwIiwiZHJhaW4iLCJkcmFpbl9hbmRfY291bnQiLCJzdW0iLCJyZWFkX2FsbCIsImlucHV0IiwidG9fc3RyZWFtX2RlcHJlY2F0ZWQiLCJvZl9zdHJlYW1fZGVwcmVjYXRlZCIsInRyYW5zZmVyIiwibmV4dF9kZWZlcnJlZCIsImNoZWNrX2Nsb3NlZF9sb29wX25leHQiLCJ0cmFuc2Zlcl9nZW4iLCJvdXRwdXQiLCJsaW5rIiwidW5saW5rIiwib3V0cHV0X2Nsb3NlZCIsInRyYW5zZmVyJDAiLCJ0cmFuc2Zlcl9pZCIsIm1hcF9nZW4iLCJjb25jYXRfbWFwX2xpc3QiLCJmaWx0ZXJfbWFwJDAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAkMCIsImZvbGRpbmdfbWFwIiwiYWNjdW0kMCIsImVtcHR5Iiwic2luZ2xldG9uIiwid3JpdGVyIiwicmVhZGVyIiwib2Zfc2VxdWVuY2UiLCJzZXF1ZW5jZSQxIiwic2VxdWVuY2UkMCIsInRvX3NlcXVlbmNlIiwiaW50ZXJsZWF2ZV9waXBlIiwiaW5wdXRzIiwib3V0cHV0X3dyaXRlciIsIm51bV9waXBlc19yZW1haW5pbmciLCJkZWNyX251bV9waXBlc19yZW1haW5pbmciLCJoZWFwIiwiaGFuZGxlX3JlYWQiLCJlb2Zfb3Jfb2siLCJwb3BfaGVhcF9hbmRfbG9vcCIsImluaXRpYWxfcHVzaCIsImNvbmNhdF9waXBlIiwiZm9yayIsInB1c2hiYWNrX3VzZXMiLCJ3cml0ZXIwIiwicmVhZGVyMCIsIndyaXRlcjEiLCJyZWFkZXIxIiwic29tZV9yZWFkZXJfd2FzX2Nsb3NlZCIsInNvbWVfcmVhZGVyX3dhc19jbG9zZWQkMCIsInN0aWxsX29wZW4iLCJmaWx0ZXJfb3BlbiIsInN0aWxsX29wZW4kMCIsInNldF9pbmZvIiwidmFsdWVfYXZhaWxhYmxlIiwic2V0X3ZhbHVlX2F2YWlsYWJsZSIsInRha2VuIiwiY3VycmVudF92YWx1ZSIsInZhbHVlX2F2YWlsYWJsZSQwIiwidGFrZW4kMCIsImN1cnJlbnRfdmFsdWUkMCIsInZhbHVlX2F2YWlsYWJsZSQxIiwieF8wMTAiLCJ0YWtlbl8wMDYiLCJjdXJyZW50X3ZhbHVlXzAwNCIsInZhbHVlX2F2YWlsYWJsZV8wMDgiLCJibmRzXzAwMyIsImJuZHNfMDAzJDAiLCJibmRzXzAwMyQxIiwidmFsdWVfYXZhaWxhYmxlX2Z1biIsImFfMDExIiwiYl8wMTIiLCJ0YWtlbl9mdW4iLCJjdXJyZW50X3ZhbHVlX2Z1biIsInBlZWtfZXhuIiwieF8wMTMiLCJvZl9hXzAxNCIsInhfMDE1IiwieF8wMTciLCJ3cml0ZV9vbmx5IiwidGFrZV9ub25lbXB0eSIsInRha2Vfbm93X2V4biIsInRha2Vfbm93IiwidGFrZSIsInVwZGF0ZV9leG4iLCJ0YWtlbiQxIiwicHV0IiwicGlwZV93aGVuX3JlYWR5IiwiY3JlYXRlX29yX2Vycm9yIiwid2FpdF9leG4iLCJmb3JjZSIsImZvcmNlX2V4biIsImJpbmQkMSIsImlzX2ZvcmNlZCIsIndhaXRzXzAwMyIsInNpZ25hbCIsImRlbGV0ZSQwIiwiY2hlY2tfZmllbGQkMCIsIndhaXRfZm9yX3ByZXZpb3VzIiwic3ltYm9sIiwic3ltYm9sJDAiLCJzeW1ib2wkMSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvdGltZV9ucy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVidWcubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2ltcG9ydC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvcHJpb3JpdHkubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3R5cGVzLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9tb25pdG9yMC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZXhlY3V0aW9uX2NvbnRleHQubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2V4dGVybmFsX2pvYi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvam9iX3Bvb2wubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2pvYi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvam9iX29yX2V2ZW50Lm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9qb2JfcXVldWUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlMC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyMS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvaXZhcjAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvaXZhci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbW9uYWRfc2VxdWVuY2UubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc3RkLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9pdmFyX2ZpbGxlci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvdGFpbC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbW9uaXRvci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfc3RyZWFtLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9idmFyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC90aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvc3RhY2tfb3JfY291bnRlci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvdGhyb3R0bGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2N5Y2xlX2hvb2subWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbF9zY2hlZHVsZXIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2Nsb2NrX2ludGYubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2Nsb2NrX25zLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9hcnJheS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfbGlzdC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfbWFwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9tZW1vLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9vcHRpb24ubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX3Jlc3VsdC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfb3JfZXJyb3IubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX3F1ZXVlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9zZXF1ZW5jZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvcGlwZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbXZhci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbGF6eV9kZWZlcnJlZC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfY29uZGl0aW9uLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9hc3luY19nYy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfaW52YXJpYW50X2ludGYubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2ludmFyaWFudC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfa2VybmVsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFPSUEsTUFBTUMsR0FBRUM7SUFDRyxJQUFUQyxTQUFTLGdCQURMRixHQUFFQztJQUVzQjtNQUE3QixnQ0FGT0E7U0FFc0IscUJBRDVCQyxRQURJRjs7SUFFd0UsT0FENUVFO0dBQ2tGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGcEZIOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUU7Z0JBQUFGO2dCQUFBQTtnQkFBQUE7T0FBMEI7SUFEMUJ1Zjs7dUJBQUEsU0FBSzs7V0FBTDNDO09BQUFEO2dCQUFBM2MsR0FBQUU7UUFBQTtnQkFBQUY7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBRTtnQkFBQUY7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7T0FBSztJQURMd2Y7O3VCQUFBLFNBQWdCOztXQUFoQjFDO09BQUFEO2dCQUFBN2MsR0FBQUU7UUFBQTtnQkFBQUY7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFFO2dCQUFBRjtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7T0FBZ0I7SUFEaEJ5Zjs7dUJBQUEsU0FBZTs7V0FBZnpDO09BQUFEO2dCQUFBL2MsR0FBQUU7UUFBQTtnQkFBQUY7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFBQUE7Z0JBQUFBO2dCQUFBQTtnQkFB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QUNNUCxNQUROLGdDQUNNQztlQUFBQyxXQUFBdThCLE9BQUFDO09BQUEsT0FBQSxzQkFBQUQsT0FBQUM7TUFBRzs7O1FBQUgzZ0M7UUFBQWtFO1FBQUFDOzs7O1FBQUFLO1FBQUFQOzs7Ozs7Ozs7O09BdERieFM7T0FDQWtQO09BQ0F5dEI7T0FDQXhIO09BQ0FRO09BQ0FiO09BQ0FnUjtPQUNBeFI7T0FDQTlhO09BQ0F3aEI7T0FDQVc7T0FDQWpKO09BQ0F3VDtPQUNBeEw7T0FDQUU7T0FPQXFyQjtPQUdBQztPQUdBQzs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbImluY2x1ZGUgQ29yZS5Db3JlX3ByaXZhdGUuVGltZV9uc19hbHRlcm5hdGVfc2V4cFxuXG4oKiBbYWZ0ZXJdIGlzIGxpa2UgW2FkZF0sIGJ1dCBkZWFscyBuaWNlbHkgd2l0aCB0aGUgY2FzZSBvZiBvdmVyZmxvdyBieSBpbnN0ZWFkIHJldHVybmluZ1xuICAgW21heF92YWx1ZV0uICBUaW1lLXNvdXJjZSBmdW5jdGlvbnMgdXNlIFthZnRlcl0gdG8gYXZvaWQgaW1tZWRpYXRlbHkgZmlyaW5nIGV2ZW50cyB0aGF0XG4gICBzaG91bGQgbmV2ZXIgZmlyZSwgZHVlIHRvIHRoZSBvdmVyZmxvdyBsZWFkaW5nIHRvIGEgbmVnYXRpdmUgdGltZSB0aGF0IGFwcGVhcnMgdG8gYmUgaW5cbiAgIHRoZSBwYXN0LiAgV2UgZG9uJ3QgY2hlY2sgdW5kZXJmbG93IGJlY2F1c2UgdGhhdCBpcyB2ZXJ5IHVubGlrZWx5LCByZXF1aXJpbmcgYm90aCBhXG4gICBuZWdhdGl2ZSB0aW1lIGFuZCBhIG5lZ2F0aXZlIHNwYW4uICopXG5sZXQgYWZ0ZXIgdCBzcGFuID1cbiAgbGV0IHJlc3VsdCA9IGFkZCB0IHNwYW4gaW5cbiAgaWYgU3Bhbi4oID4gKSBzcGFuIFNwYW4uemVybyAmJiByZXN1bHQgPCB0IHRoZW4gbWF4X3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgZWxzZSByZXN1bHRcbjs7XG4iLCJtb2R1bGUgVGltZV9uc19pbl90aGlzX2RpcmVjdG9yeSA9IFRpbWVfbnNcbm9wZW4gQ29yZVxubW9kdWxlIFRpbWVfbnMgPSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5XG5pbmNsdWRlIEFzeW5jX2tlcm5lbF9jb25maWcuUHJpbnRfZGVidWdfbWVzc2FnZXNfZm9yXG5cbmxldCBsb2cgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIGVwcmludGZcbiAgICBcIiVzXFxuJSFcIlxuICAgIChTZXhwLnRvX3N0cmluZ19odW1cbiAgICAgICAoWyVzZXhwX29mOiBTZXhwLnQgKiBUaW1lX25zLnQgKiBzdHJpbmcgKiBhXVxuICAgICAgICAgICghQXN5bmNfa2VybmVsX2NvbmZpZy50YXNrX2lkICgpLCBUaW1lX25zLm5vdyAoKSwgbWVzc2FnZSwgYSkpKVxuOztcblxubGV0IGxvZ19zdHJpbmcgbWVzc2FnZSA9IGxvZyBtZXNzYWdlICgpIFslc2V4cF9vZjogdW5pdF1cbiIsIm1vZHVsZSBEZWJ1Z19pbl90aGlzX2RpcmVjdG9yeSA9IERlYnVnXG5tb2R1bGUgVGltZV9uc19pbl90aGlzX2RpcmVjdG9yeSA9IFRpbWVfbnNcbm9wZW4hIENvcmVcbmluY2x1ZGUgSW50LlJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIERlYnVnID0gRGVidWdfaW5fdGhpc19kaXJlY3Rvcnlcbm1vZHVsZSBUaW1lX25zID0gVGltZV9uc19pbl90aGlzX2RpcmVjdG9yeVxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5cbm1vZHVsZSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSA9XG4gIEFzeW5jX2tlcm5lbF9jb25maWcuTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGVcblxubGV0IGNvbmNhdCA9IFN0cmluZy5jb25jYXRcbmxldCBlcHJpbnQgPSBDb3JlLkRlYnVnLmVwcmludFxubGV0IGVwcmludF9zID0gQ29yZS5EZWJ1Zy5lcHJpbnRfc1xubGV0IGVwcmludHMgPSBDb3JlLkRlYnVnLmVwcmludHNcbmxldCBwcmludF9zIHNleHAgPSBwcmludGYgXCIlc1xcbiUhXCIgKHNleHAgfD4gU2V4cC50b19zdHJpbmdfaHVtKVxubGV0IHNlYyA9IFRpbWVfbnMuU3Bhbi5vZl9zZWNcblxuKCogV2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlc2UgbW9kdWxlcyBpbiBBc3luY19rZXJuZWwsIHRvIGF2b2lkIGRpZmZpY3VsdGllcyB3aXRoXG4gICB1c2luZyBpdCBvbiBqc19vZl9vY2FtbC4gKilcbm1vZHVsZSBUaHJlYWQgPSBzdHJ1Y3QgZW5kXG5tb2R1bGUgVW5peCA9IHN0cnVjdCBlbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IE5vcm1hbFxuICB8IExvd1xuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IG5vcm1hbCA9IE5vcm1hbFxubGV0IGxvdyA9IExvd1xuIiwiKCogVGhpcyBmaWxlIGRlZmluZXMgdGhlIG11dHVhbGx5IHJlY3Vyc2l2ZSB0eXBlcyBhdCB0aGUgaGVhcnQgb2YgQXN5bmMuICBUaGUgZnVuY3Rpb25zXG4gICBhc3NvY2lhdGVkIHdpdGggdGhlIHR5cGVzIGFyZSBkZWZpbmVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUocykgZm9yIGVhY2ggbW9kdWxlLlxuICAgVGhpcyBmaWxlIHNob3VsZCBkZWZpbmUgb25seSB0eXBlcywgbm90IGZ1bmN0aW9ucywgc2luY2UgZnVuY3Rpb25zIGRlZmluZWQgaW5zaWRlIHRoZVxuICAgcmVjdXJzaXZlIG1vZHVsZXMgYXJlIG5vdCBpbmxpbmVkLlxuXG4gICBJZiB5b3UgbmVlZCB0byBhZGQgZnVuY3Rpb25hbGl0eSB0byBhIG1vZHVsZSBidXQgZG9pbmcgc28gd291bGQgY3JlYXRlIGEgZGVwZW5kZW5jeVxuICAgY3ljbGUsIHNwbGl0IHRoZSBmaWxlIGludG8gcGllY2VzIGFzIG5lZWRlZCB0byBicmVhayB0aGUgY3ljbGUsIGUuZy4gc2NoZWR1bGVyMC5tbCxcbiAgIHNjaGVkdWxlcjEubWwsIHNjaGVkdWxlci5tbC4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSByZWMgQ2VsbCA6IHNpZ1xuICB0eXBlIGFueSA9XG4gICAgWyBgRW1wdHlcbiAgICB8IGBFbXB0eV9vbmVfaGFuZGxlclxuICAgIHwgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgfCBgRnVsbFxuICAgIHwgYEluZGlyXG4gICAgXVxuXG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyA6XG4gICAgICAgIHsgbXV0YWJsZSBydW4gOiAnYSAtPiB1bml0XG4gICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICAgIDsgbXV0YWJsZSBwcmV2IDogJ2EgSGFuZGxlci50XG4gICAgICAgIDsgbXV0YWJsZSBuZXh0IDogJ2EgSGFuZGxlci50XG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgdFxuICAgIHwgRW1wdHlfb25lX2hhbmRsZXIgOlxuICAgICAgICAoJ2EgLT4gdW5pdCkgKiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9oYW5kbGVyIF0pIHRcbiAgICB8IEVtcHR5IDogKCdhLCBbPiBgRW1wdHkgXSkgdFxuICAgIHwgRnVsbCA6ICdhIC0+ICgnYSwgWz4gYEZ1bGwgXSkgdFxuICAgIHwgSW5kaXIgOiAnYSBJdmFyLnQgLT4gKCdhLCBbPiBgSW5kaXIgXSkgdFxuZW5kID1cbiAgQ2VsbFxuXG5hbmQgSGFuZGxlciA6IHNpZ1xuICB0eXBlICdhIHQgPSAoJ2EsIFsgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIENlbGwudFxuZW5kID1cbiAgSGFuZGxlclxuXG5hbmQgSXZhciA6IHNpZ1xuICB0eXBlICdhIHQgPSB7IG11dGFibGUgY2VsbCA6ICgnYSwgQ2VsbC5hbnkpIENlbGwudCB9XG5cbiAgbW9kdWxlIEltbXV0YWJsZSA6IHNpZ1xuICAgIHR5cGUgJ2EgdCA9IHsgY2VsbCA6ICgnYSwgQ2VsbC5hbnkpIENlbGwudCB9XG4gIGVuZFxuZW5kID1cbiAgSXZhclxuXG5hbmQgRGVmZXJyZWQgOiBzaWdcbiAgdHlwZSArJ2EgdFxuZW5kID1cbiAgRGVmZXJyZWRcblxuYW5kIEV4ZWN1dGlvbl9jb250ZXh0IDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBtb25pdG9yIDogTW9uaXRvci50XG4gICAgOyBwcmlvcml0eSA6IFByaW9yaXR5LnRcbiAgICA7IGxvY2FsX3N0b3JhZ2UgOiBVbml2X21hcC50XG4gICAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgICB9XG5lbmQgPVxuICBFeGVjdXRpb25fY29udGV4dFxuXG5hbmQgRm9yd2FyZGluZyA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHwgRGV0YWNoZWRcbiAgICB8IFBhcmVudCBvZiBNb25pdG9yLnRcbiAgICB8IFJlcG9ydF91bmNhdWdodF9leG5cbmVuZCA9XG4gIEZvcndhcmRpbmdcblxuYW5kIE1vbml0b3IgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBJbmZvLnRcbiAgICA7IGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50IG9wdGlvblxuICAgIDsgaWQgOiBpbnRcbiAgICA7IG11dGFibGUgbmV4dF9lcnJvciA6IGV4biBJdmFyLnRcbiAgICA7IG11dGFibGUgaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgOiAoRXhlY3V0aW9uX2NvbnRleHQudCAqIChleG4gLT4gdW5pdCkpIEJhZy50XG4gICAgOyBtdXRhYmxlIHRhaWxzX2Zvcl9hbGxfZXJyb3JzIDogZXhuIFRhaWwudCBsaXN0XG4gICAgOyBtdXRhYmxlIGhhc19zZWVuX2Vycm9yIDogYm9vbFxuICAgIDsgbXV0YWJsZSBmb3J3YXJkaW5nIDogRm9yd2FyZGluZy50XG4gICAgfVxuZW5kID1cbiAgTW9uaXRvclxuXG5hbmQgVGFpbCA6IHNpZ1xuICB0eXBlICdhIHQgPSB7IG11dGFibGUgbmV4dCA6ICdhIFN0cmVhbS5uZXh0IEl2YXIudCB9XG5lbmQgPVxuICBUYWlsXG5cbmFuZCBTdHJlYW0gOiBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgbmV4dCBEZWZlcnJlZC50XG5cbiAgYW5kICdhIG5leHQgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mICdhICogJ2EgdFxuZW5kID1cbiAgU3RyZWFtXG5cbigqIFdlIGF2b2lkIHVzaW5nIFttb2R1bGUgcmVjXSB0byBkZWZpbmUgW0J2YXJdLCBzbyB0aGF0IFt0b19yZXByXSBhbmQgW29mX3JlcHJdIGFyZVxuICAgaW5saW5lZC4gKilcbm1vZHVsZSBCdmFyIDogc2lnXG4gIHR5cGUgKCdhLCAtJ3Blcm1pc3Npb24pIHRcblxuICAoKiogW3JlcHJdIGV4aXN0cyBzbyB0aGF0IHdlIG1heSBoaWRlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIFtCdmFyLnRdLCBhbmQgdGhlbiBhZGQgYVxuICAgICAgcGhhbnRvbSB0eXBlIHRvIGl0IHVwc3RyZWFtLiAgV2l0aG91dCB0aGlzLCB0aGUgcGhhbnRvbSB0eXBlIHZhcmlhYmxlIHdvdWxkIGFsbG93XG4gICAgICBmb3IgYW55dGhpbmcgdG8gYmUgY29lcmNlZCBpbiBhbmQgb3V0LCBzaW5jZSBpdCBpcyB1bnVzZWQuICopXG4gIHR5cGUgJ2EgcmVwciA9XG4gICAgeyBtdXRhYmxlIGhhc19hbnlfd2FpdGVycyA6IGJvb2xcbiAgICA7IG11dGFibGUgaXZhciA6ICdhIEl2YXIudFxuICAgIH1cblxuICB2YWwgb2ZfcmVwciA6ICdhIHJlcHIgLT4gKCdhLCAncGVybWlzc2lvbikgdFxuICB2YWwgdG9fcmVwciA6ICgnYSwgJ3Blcm1pc3Npb24pIHQgLT4gJ2EgcmVwclxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgcmVwciA9XG4gICAgeyBtdXRhYmxlIGhhc19hbnlfd2FpdGVycyA6IGJvb2xcbiAgICA7IG11dGFibGUgaXZhciA6ICdhIEl2YXIudFxuICAgIH1cblxuICB0eXBlICgnYSwgJ3Blcm1pc3Npb24pIHQgPSAnYSByZXByXG5cbiAgbGV0IHRvX3JlcHIgdCA9IHRcbiAgbGV0IG9mX3JlcHIgdCA9IHRcbmVuZFxuXG5tb2R1bGUgcmVjIEV2ZW50IDogc2lnXG4gIG1vZHVsZSBTdGF0dXMgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBGaXJlZFxuICAgICAgfCBIYXBwZW5pbmdcbiAgICAgIHwgU2NoZWR1bGVkXG4gICAgICB8IFVuc2NoZWR1bGVkXG4gIGVuZFxuXG4gIG1vZHVsZSBPcHRpb24gOiBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwuQWxhcm0udFxuICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgIDsgY2FsbGJhY2sgOiB1bml0IC0+IHVuaXRcbiAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgIDsgbXV0YWJsZSBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50IG9wdGlvblxuICAgIDsgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgcHJldl9maXJlZCA6IE9wdGlvbi50XG4gICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50XG4gICAgfVxuZW5kID1cbiAgRXZlbnRcblxuYW5kIEV4dGVybmFsX2pvYiA6IHNpZ1xuICB0eXBlIHQgPSBUIDogRXhlY3V0aW9uX2NvbnRleHQudCAqICgnYSAtPiB1bml0KSAqICdhIC0+IHRcbmVuZCA9XG4gIEV4dGVybmFsX2pvYlxuXG5hbmQgSm9iIDogc2lnXG4gIHR5cGUgc2xvdHMgPSAoRXhlY3V0aW9uX2NvbnRleHQudCwgT2JqLnQgLT4gdW5pdCwgT2JqLnQpIFBvb2wuU2xvdHMudDNcbiAgdHlwZSB0ID0gc2xvdHMgUG9vbC5Qb2ludGVyLnRcbmVuZCA9XG4gIEpvYlxuXG5hbmQgSm9iX29yX2V2ZW50IDogc2lnXG4gIHR5cGUgdFxuZW5kID1cbiAgSm9iX29yX2V2ZW50XG5cbmFuZCBKb2JfcG9vbCA6IHNpZ1xuICB0eXBlIHQgPSBKb2Iuc2xvdHMgUG9vbC50XG5lbmQgPVxuICBKb2JfcG9vbFxuXG5hbmQgSm9iX3F1ZXVlIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIG51bV9qb2JzX3J1biA6IGludFxuICAgIDsgbXV0YWJsZSBqb2JzX2xlZnRfdGhpc19jeWNsZSA6IGludFxuICAgIDsgbXV0YWJsZSBqb2JzIDogT2JqLnQgVW5pZm9ybV9hcnJheS50XG4gICAgOyBtdXRhYmxlIG1hc2sgOiBpbnRcbiAgICA7IG11dGFibGUgZnJvbnQgOiBpbnRcbiAgICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgfVxuZW5kID1cbiAgSm9iX3F1ZXVlXG5cbmFuZCBKb2JzIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBzY2hlZHVsZXIgOiBTY2hlZHVsZXIudFxuICAgIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgICA7IG5vcm1hbCA6IEpvYl9xdWV1ZS50XG4gICAgOyBsb3cgOiBKb2JfcXVldWUudFxuICAgIH1cbmVuZCA9XG4gIEpvYnNcblxuYW5kIFNjaGVkdWxlciA6IHNpZ1xuXG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIGNoZWNrX2FjY2VzcyA6ICh1bml0IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgICA7IG5vcm1hbF9wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgICA7IGxvd19wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgOiBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCBEZXF1ZS50XG4gICAgOyBtdXRhYmxlIG1haW5fZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIHVuY2F1Z2h0X2V4biA6IChFeG4udCAqIFNleHAudCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGN5Y2xlX2NvdW50IDogaW50XG4gICAgOyBtdXRhYmxlIGN5Y2xlX3N0YXJ0IDogVGltZV9ucy50XG4gICAgOyBtdXRhYmxlIGluX2N5Y2xlIDogYm9vbFxuICAgIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgOiBDeWNsZV9ob29rLnQgbGlzdFxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIDogKEN5Y2xlX2hvb2tfaGFuZGxlLnQsIEN5Y2xlX2hvb2sudCkgSGFzaHRibC50XG4gICAgOyBtdXRhYmxlIHJ1bl9ldmVyeV9jeWNsZV9lbmQgOiBDeWNsZV9ob29rLnQgbGlzdFxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSA6IChDeWNsZV9ob29rX2hhbmRsZS50LCBDeWNsZV9ob29rLnQpIEhhc2h0YmwudFxuICAgIDsgbXV0YWJsZSBsYXN0X2N5Y2xlX3RpbWUgOiBUaW1lX25zLlNwYW4udFxuICAgIDsgbXV0YWJsZSBsYXN0X2N5Y2xlX251bV9qb2JzIDogaW50XG4gICAgOyBtdXRhYmxlIHRvdGFsX2N5Y2xlX3RpbWUgOiBUaW1lX25zLlNwYW4udFxuICAgIDsgbXV0YWJsZSB0aW1lX3NvdXJjZSA6IHJlYWRfd3JpdGUgVGltZV9zb3VyY2UudDFcbiAgICA7IGV4dGVybmFsX2pvYnMgOiBFeHRlcm5hbF9qb2IudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gICAgOyBtdXRhYmxlIHRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDogdW5pdCAtPiB1bml0XG4gICAgOyBtdXRhYmxlIGpvYl9xdWV1ZWRfaG9vayA6IChQcmlvcml0eS50IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSBldmVudF9hZGRlZF9ob29rIDogKFRpbWVfbnMudCAtPiB1bml0KSBvcHRpb25cbiAgICA7IG11dGFibGUgeWllbGQgOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gICAgOyBtdXRhYmxlIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIDogKHVuaXQsIHJlYWRfd3JpdGUpIEJ2YXIudFxuICAgIDsgbXV0YWJsZSBjaGVja19pbnZhcmlhbnRzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSA6IE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLnRcbiAgICA7IG11dGFibGUgcmVjb3JkX2JhY2t0cmFjZXMgOiBib29sXG4gICAgfVxuZW5kID1cbiAgU2NoZWR1bGVyXG5cbmFuZCBDeWNsZV9ob29rIDogc2lnXG4gIHR5cGUgdCA9IHVuaXQgLT4gdW5pdFxuZW5kID1cbiAgQ3ljbGVfaG9va1xuXG5hbmQgQ3ljbGVfaG9va19oYW5kbGUgOiBVbmlxdWVfaWQuSWQgPSBVbmlxdWVfaWQuSW50NjMgKClcbmFuZCBUaW1lX3NvdXJjZV9pZCA6IFVuaXF1ZV9pZC5JZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuXG5hbmQgVGltZV9zb3VyY2UgOiBzaWdcbiAgdHlwZSAtJ3J3IHQxID1cbiAgICB7IGlkIDogVGltZV9zb3VyY2VfaWQudFxuICAgIDsgbXV0YWJsZSBhZHZhbmNlX2Vycm9ycyA6IEVycm9yLnQgbGlzdFxuICAgIDsgbXV0YWJsZSBhbV9hZHZhbmNpbmcgOiBib29sXG4gICAgOyBldmVudHMgOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwudFxuICAgIDsgbXV0YWJsZSBmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udFxuICAgIDsgbXV0YWJsZSBtb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnRcbiAgICA7IGhhbmRsZV9maXJlZCA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50IC0+IHVuaXRcbiAgICA7IGlzX3dhbGxfY2xvY2sgOiBib29sXG4gICAgOyBzY2hlZHVsZXIgOiBTY2hlZHVsZXIudFxuICAgIH1cbmVuZCA9XG4gIFRpbWVfc291cmNlXG5cbmFuZCBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIgOiBzaWdcbiAgbW9kdWxlIEV4ZWNfcmVzdWx0IDogc2lnXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgTm90X2ZpbmlzaGVkXG4gIGVuZFxuXG4gIHR5cGUgdCA9XG4gICAgeyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IGV4ZWMgOiB1bml0IC0+IEV4ZWNfcmVzdWx0LnRcbiAgICB9XG5lbmQgPVxuICBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXJcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcblxubGV0IGRlYnVnID0gRGVidWcubW9uaXRvclxuXG5tb2R1bGUgRm9yd2FyZGluZyA9IFR5cGVzLkZvcndhcmRpbmdcblxudHlwZSB0ID0gVHlwZXMuTW9uaXRvci50ID1cbiAgeyBuYW1lIDogSW5mby50XG4gIDsgaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgb3B0aW9uXG4gIDsgaWQgOiBpbnRcbiAgOyBtdXRhYmxlIG5leHRfZXJyb3IgOiBleG4gVHlwZXMuSXZhci50XG4gIDsgKCogW01vbml0b3Iuc2VuZF9leG5dIHNjaGVkdWxlcyBhIGpvYiBmb3IgZWFjaCBlbGVtZW50IG9mIFtoYW5kbGVyc19mb3JfYWxsX2Vycm9yc10uICopXG4gICAgbXV0YWJsZSBoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyA6IChUeXBlcy5FeGVjdXRpb25fY29udGV4dC50ICogKGV4biAtPiB1bml0KSkgQmFnLnRcbiAgOyAoKiBbTW9uaXRvci5zZW5kX2V4bl0gZXh0ZW5kcyBlYWNoIHRhaWwgaW4gW3RhaWxzX2Zvcl9hbGxfZXJyb3JzXS4gKilcbiAgICBtdXRhYmxlIHRhaWxzX2Zvcl9hbGxfZXJyb3JzIDogZXhuIFR5cGVzLlRhaWwudCBsaXN0XG4gIDsgbXV0YWJsZSBoYXNfc2Vlbl9lcnJvciA6IGJvb2xcbiAgOyBtdXRhYmxlIGZvcndhcmRpbmcgOiBGb3J3YXJkaW5nLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzXVxuXG5sZXQgZGVzY3JpcHRpb24gdCA9XG4gIG1hdGNoIHQuaGVyZSB3aXRoXG4gIHwgTm9uZSAtPiBbJXNleHAgKHQubmFtZSA6IEluZm8udCldXG4gIHwgU29tZSBoZXJlIC0+IFslc2V4cCAodC5uYW1lIDogSW5mby50KSwgKGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV1cbjs7XG5cbmxldCBkZXNjcmlwdGlvbnMgPVxuICBsZXQgcmVjIGxvb3AgdCBhYyA9XG4gICAgbGV0IGFjID0gZGVzY3JpcHRpb24gdCA6OiBhYyBpblxuICAgIG1hdGNoIHQuZm9yd2FyZGluZyB3aXRoXG4gICAgfCBEZXRhY2hlZCB8IFJlcG9ydF91bmNhdWdodF9leG4gLT4gTGlzdC5yZXYgYWNcbiAgICB8IFBhcmVudCB0IC0+IGxvb3AgdCBhY1xuICBpblxuICBmdW4gdCAtPiBsb29wIHQgW11cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9IFslc2V4cCAoZGVzY3JpcHRpb25zIHQgOiBTZXhwLnQgbGlzdCldXG5cbmxldCBuZXh0X2lkID1cbiAgbGV0IHIgPSByZWYgMCBpblxuICBmdW4gKCkgLT5cbiAgICBpbmNyIHI7XG4gICAgIXJcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9wYXJlbnQgP2hlcmUgP2luZm8gP25hbWUgcGFyZW50ID1cbiAgbGV0IGlkID0gbmV4dF9pZCAoKSBpblxuICBsZXQgbmFtZSA9XG4gICAgbWF0Y2ggaW5mbywgbmFtZSB3aXRoXG4gICAgfCBTb21lIGksIE5vbmUgLT4gaVxuICAgIHwgU29tZSBpLCBTb21lIHMgLT4gSW5mby50YWcgaSB+dGFnOnNcbiAgICB8IE5vbmUsIFNvbWUgcyAtPiBJbmZvLm9mX3N0cmluZyBzXG4gICAgfCBOb25lLCBOb25lIC0+IEluZm8uY3JlYXRlIFwiaWRcIiBpZCBbJXNleHBfb2Y6IGludCBTZXhwX2hpZGRlbl9pbl90ZXN0LnRdXG4gIGluXG4gIGxldCB0ID1cbiAgICB7IG5hbWVcbiAgICA7IGhlcmVcbiAgICA7IGZvcndhcmRpbmcgPVxuICAgICAgICAobWF0Y2ggcGFyZW50IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBSZXBvcnRfdW5jYXVnaHRfZXhuXG4gICAgICAgICB8IFNvbWUgcGFyZW50IC0+IFBhcmVudCBwYXJlbnQpXG4gICAgOyBpZFxuICAgIDsgbmV4dF9lcnJvciA9IHsgY2VsbCA9IEVtcHR5IH1cbiAgICA7IGhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzID0gQmFnLmNyZWF0ZSAoKVxuICAgIDsgdGFpbHNfZm9yX2FsbF9lcnJvcnMgPSBbXVxuICAgIDsgaGFzX3NlZW5fZXJyb3IgPSBmYWxzZVxuICAgIH1cbiAgaW5cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJjcmVhdGVkIG1vbml0b3JcIiB0IFslc2V4cF9vZjogdF07XG4gIHRcbjs7XG5cbmxldCBtYWluID0gY3JlYXRlX3dpdGhfcGFyZW50IH5uYW1lOlwibWFpblwiIE5vbmVcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIE1vbml0b3IgPSBNb25pdG9yMFxuXG50eXBlIHQgPSBUeXBlcy5FeGVjdXRpb25fY29udGV4dC50ID1cbiAgeyBtb25pdG9yIDogTW9uaXRvci50XG4gIDsgcHJpb3JpdHkgOiBQcmlvcml0eS50XG4gIDsgbG9jYWxfc3RvcmFnZSA6IFVuaXZfbWFwLnRcbiAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG5sZXQgbWFpbiA9XG4gIHsgbW9uaXRvciA9IE1vbml0b3IubWFpblxuICA7IHByaW9yaXR5ID0gUHJpb3JpdHkubm9ybWFsXG4gIDsgbG9jYWxfc3RvcmFnZSA9IFVuaXZfbWFwLmVtcHR5XG4gIDsgYmFja3RyYWNlX2hpc3RvcnkgPSBbXVxuICB9XG47O1xuXG5sZXQgY3JlYXRlX2xpa2UgP21vbml0b3IgP3ByaW9yaXR5ID9sb2NhbF9zdG9yYWdlIHQgPVxuICBsZXQgbW9uaXRvciA9IE9wdGlvbi52YWx1ZSBtb25pdG9yIH5kZWZhdWx0OnQubW9uaXRvciBpblxuICB7IG1vbml0b3JcbiAgOyBwcmlvcml0eSA9IE9wdGlvbi52YWx1ZSBwcmlvcml0eSB+ZGVmYXVsdDp0LnByaW9yaXR5XG4gIDsgbG9jYWxfc3RvcmFnZSA9IE9wdGlvbi52YWx1ZSBsb2NhbF9zdG9yYWdlIH5kZWZhdWx0OnQubG9jYWxfc3RvcmFnZVxuICA7IGJhY2t0cmFjZV9oaXN0b3J5ID0gdC5iYWNrdHJhY2VfaGlzdG9yeVxuICB9XG47O1xuXG5sZXQgZmluZF9sb2NhbCB0IGtleSA9IFVuaXZfbWFwLmZpbmQgdC5sb2NhbF9zdG9yYWdlIGtleVxuXG5sZXQgd2l0aF9sb2NhbCB0IGtleSBkYXRhID1cbiAgeyB0IHdpdGggbG9jYWxfc3RvcmFnZSA9IFVuaXZfbWFwLmNoYW5nZSB0LmxvY2FsX3N0b3JhZ2Uga2V5IH5mOihmdW4gXyAtPiBkYXRhKSB9XG47O1xuXG5sZXQgcmVjb3JkX2JhY2t0cmFjZSB0ID1cbiAgeyB0IHdpdGggYmFja3RyYWNlX2hpc3RvcnkgPSBCYWNrdHJhY2UuZ2V0ICgpIDo6IHQuYmFja3RyYWNlX2hpc3RvcnkgfVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUeXBlcy5FeHRlcm5hbF9qb2JcblxubGV0IHNleHBfb2ZfdCBfID0gU2V4cC5BdG9tIFwiPGpvYj5cIlxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFBvb2xcblxubGV0IGR1bW15X2UgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG5sZXQgZHVtbXlfZiA6IE9iai50IC0+IHVuaXQgPSBpZ25vcmVcbmxldCBkdW1teV9hIDogT2JqLnQgPSBPYmoucmVwciAoKVxuXG50eXBlIHNsb3RzID0gKEV4ZWN1dGlvbl9jb250ZXh0LnQsIE9iai50IC0+IHVuaXQsIChPYmoudFtAc2V4cC5vcGFxdWVdKSkgU2xvdHMudDNcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgdCA9IHNsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPSBQb29sLmludmFyaWFudCBpZ25vcmUgdFxubGV0IGNyZWF0ZSAoKSA9IGNyZWF0ZSBTbG90cy50MyB+Y2FwYWNpdHk6MSB+ZHVtbXk6KGR1bW15X2UsIGR1bW15X2YsIGR1bW15X2EpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID0gSm9iX3Bvb2wuc2xvdHMgUG9vbC5Qb2ludGVyLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEV2ZW50ID0gVHlwZXMuRXZlbnRcbm1vZHVsZSBKb2IgPSBUeXBlcy5Kb2JcbmluY2x1ZGUgVHlwZXMuSm9iX29yX2V2ZW50XG5cbigqIFRoaXMgcmVkZWZpbml0aW9uIG9mIFtFdmVudF0gaXMgaGVyZSBzbyB0aGUgdHlwZSBjaGVja3MgYXJlIHJpZ2h0IG5leHQgdG9cbiAgIFtPYmoubWFnaWNdcy4gKilcbm1vZHVsZSBfIDogc2lnIGVuZCA9IHN0cnVjdFxuICBvcGVuIFR5cGVzXG4gIG9wZW4gRXZlbnRcblxuICB0eXBlIF90ID0gdCA9XG4gICAgeyAoKiBtdXN0IG5ldmVyIGJlIGltbWVkaWF0ZSAqKVxuICAgICAgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50XG4gICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICB9XG5lbmRcblxubW9kdWxlIF8gOiBzaWcgZW5kID0gc3RydWN0XG4gIG1vZHVsZSBFbnN1cmVfcHJpdmF0ZV9pbnQgKE0gOiBzaWdcbiAgICAgIHR5cGUgdCA9IHByaXZhdGUgaW50XG4gICAgZW5kKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgX3QgPSBNLnRcbiAgZW5kXG5cbiAgaW5jbHVkZSBFbnN1cmVfcHJpdmF0ZV9pbnQgKEpvYilcbmVuZFxuXG5sZXQgb2ZfZXZlbnQgZXZlbnQgOiB0ID0gT2JqLm1hZ2ljIChldmVudCA6IEV2ZW50LnQpXG5sZXQgb2Zfam9iIGpvYiA6IHQgPSBPYmoubWFnaWMgKGpvYiA6IEpvYi50KVxubGV0IGlzX2V2ZW50ICh0IDogdCkgPSBPYmouaXNfYmxvY2sgKE9iai5yZXByIHQpXG5sZXQgaXNfam9iICh0IDogdCkgPSBPYmouaXNfaW50IChPYmoucmVwciB0KVxuXG5tb2R1bGUgTWF0Y2ggPSBzdHJ1Y3RcbiAgdHlwZSBfIGtpbmQgPVxuICAgIHwgRXZlbnQgOiBFdmVudC50IGtpbmRcbiAgICB8IEpvYiA6IEpvYi50IGtpbmRcblxuICB0eXBlIHBhY2tlZCA9IEsgOiBfIGtpbmQgLT4gcGFja2VkIFtAQHVuYm94ZWRdXG5cbiAgbGV0IGtpbmQgdCA9IGlmIGlzX2V2ZW50IHQgdGhlbiBLIEV2ZW50IGVsc2UgSyBKb2JcbiAgbGV0IHByb2plY3QgKHR5cGUgYSkgKF8gOiBhIGtpbmQpIGpvYl9vcl9ldmVudCA9IChPYmoubWFnaWMgOiB0IC0+IGEpIGpvYl9vcl9ldmVudFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgVHlwZXMuU2NoZWR1bGVyXG5cbmxldCBldmVudHMgdCA9IHQudGltZV9zb3VyY2UuZXZlbnRzXG5cbmxldCBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCBleGVjdXRpb25fY29udGV4dCA9XG4gICgqIEF2b2lkIGEgY2FtbF9tb2RpZnkgaW4gbW9zdCBjYXNlcy4gKilcbiAgaWYgbm90IChwaHlzX2VxdWFsIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBleGVjdXRpb25fY29udGV4dClcbiAgdGhlbiB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPC0gZXhlY3V0aW9uX2NvbnRleHRcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIwXG5cbmxldCBkdW1teV9lID0gRXhlY3V0aW9uX2NvbnRleHQubWFpblxubGV0IGR1bW15X2YgOiBPYmoudCAtPiB1bml0ID0gaWdub3JlXG5sZXQgZHVtbXlfYSA6IE9iai50ID0gT2JqLnJlcHIgKClcbmxldCBzbG90c19wZXJfZWx0ID0gM1xuXG5tb2R1bGUgQSA9IFVuaWZvcm1fYXJyYXlcblxuKCogVGhpcyBpcyBlc3NlbnRpYWxseSBhIHNwZWNpYWxpemVkIFtGbGF0X3F1ZXVlXSwgZG9uZSBmb3IgcmVhc29ucyBvZiBzcGVlZC4gKilcbnR5cGUgdCA9IFR5cGVzLkpvYl9xdWV1ZS50ID1cbiAgeyBtdXRhYmxlIG51bV9qb2JzX3J1biA6IGludFxuICA7IG11dGFibGUgam9ic19sZWZ0X3RoaXNfY3ljbGUgOiBpbnRcbiAgOyAoKiBbam9ic10gaXMgYW4gYXJyYXkgb2YgbGVuZ3RoIFtjYXBhY2l0eSB0ICogc2xvdHNfcGVyX2VsdF0sIHdoZXJlIGVhY2ggZWx0IGhhcyB0aGVcbiAgICAgICB0aHJlZSBjb21wb25lbnRzIG9mIGEgam9iIChbZXhlY3V0aW9uX2NvbnRleHRdLCBbZl0sIFthXSkgaW4gY29uc2VjdXRpdmUgc3BvdHMgaW5cbiAgICAgICBbam9ic10uICBbZW5xdWV1ZV0gZG91YmxlcyB0aGUgbGVuZ3RoIG9mIFtqb2JzXSBpZiBbam9ic10gaXMgZnVsbC4gIFtqb2JzXSBuZXZlclxuICAgICAgIHNocmlua3MuICBbam9ic10gaXMgc29tZXdoYXQgbGlrZSBhIFtDb3JlLlBvb2xdIHNwZWNpYWxpemVkIHRvIDMtdHVwbGVzOyB3ZVxuICAgICAgIGRvbid0IHVzZSBbUG9vbF0gYmVjYXVzZSB0aGF0IGltcGxlbWVudHMgYSBzZXQsIHdoZXJlIFtqb2JzXSBpcyBhIHF1ZXVlLiAqKVxuICAgIG11dGFibGUgam9icyA6IChPYmoudCBBLnRbQHNleHAub3BhcXVlXSlcbiAgOyAoKiBbbWFza10gaXMgW2NhcGFjaXR5IHQgLSAxXSwgYW5kIGlzIHVzZWQgZm9yIHF1aWNrbHkgY29tcHV0aW5nIFtpIG1vZCAoY2FwYWNpdHlcbiAgICAgICB0KV0gKilcbiAgICBtdXRhYmxlIG1hc2sgOiBpbnRcbiAgOyAoKiBbZnJvbnRdIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgam9iIGluIHRoZSBxdWV1ZS4gIFRoZSBhcnJheSBpbmRleCBvZiB0aGF0IGpvYidzXG4gICAgICAgZXhlY3V0aW9uIGNvbnRleHQgaXMgW2Zyb250ICogc2xvdHNfcGVyX2VsdF0uICopXG4gICAgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IG9mZnNldCB0IGkgPSAodC5mcm9udCArIGkpIGxhbmQgdC5tYXNrICogc2xvdHNfcGVyX2VsdFxubGV0IGNhcGFjaXR5IHQgPSB0Lm1hc2sgKyAxXG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm51bV9qb2JzX3J1bjooY2hlY2sgKGZ1biBudW1fam9ic19ydW4gLT4gYXNzZXJ0IChudW1fam9ic19ydW4gPj0gMCkpKVxuICAgICAgfmpvYnNfbGVmdF90aGlzX2N5Y2xlOlxuICAgICAgICAoY2hlY2sgKGZ1biBqb2JzX2xlZnRfdGhpc19jeWNsZSAtPiBhc3NlcnQgKGpvYnNfbGVmdF90aGlzX2N5Y2xlID49IDApKSlcbiAgICAgIH5qb2JzOlxuICAgICAgICAoY2hlY2sgKGZ1biBqb2JzIC0+XG4gICAgICAgICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgICAgICAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnRcbiAgICAgICAgICAgICAgIChPYmoub2JqIChBLmdldCBqb2JzIChvZmZzZXQgdCBpKSkgOiBFeGVjdXRpb25fY29udGV4dC50KVxuICAgICAgICAgICBkb25lKSlcbiAgICAgIH5tYXNrOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXNrIC0+XG4gICAgICAgICAgIGxldCBjYXBhY2l0eSA9IG1hc2sgKyAxIGluXG4gICAgICAgICAgIGFzc2VydCAoSW50LmlzX3BvdzIgY2FwYWNpdHkpO1xuICAgICAgICAgICBhc3NlcnQgKGNhcGFjaXR5ICogc2xvdHNfcGVyX2VsdCA9IEEubGVuZ3RoIHQuam9icykpKVxuICAgICAgfmZyb250OlxuICAgICAgICAoY2hlY2sgKGZ1biBmcm9udCAtPlxuICAgICAgICAgICBhc3NlcnQgKGZyb250ID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKGZyb250IDwgY2FwYWNpdHkgdCkpKVxuICAgICAgfmxlbmd0aDpcbiAgICAgICAgKGNoZWNrIChmdW4gbGVuZ3RoIC0+XG4gICAgICAgICAgIGFzc2VydCAobGVuZ3RoID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSB0KSkpKVxuOztcblxubGV0IGNyZWF0ZV9hcnJheSB+Y2FwYWNpdHkgPSBBLmNyZWF0ZV9vYmpfYXJyYXkgfmxlbjooY2FwYWNpdHkgKiBzbG90c19wZXJfZWx0KVxuXG5sZXQgY3JlYXRlICgpID1cbiAgbGV0IGNhcGFjaXR5ID0gMSBpblxuICB7IG51bV9qb2JzX3J1biA9IDBcbiAgOyBqb2JzX2xlZnRfdGhpc19jeWNsZSA9IDBcbiAgOyBqb2JzID0gY3JlYXRlX2FycmF5IH5jYXBhY2l0eVxuICA7IG1hc2sgPSBjYXBhY2l0eSAtIDFcbiAgOyBmcm9udCA9IDBcbiAgOyBsZW5ndGggPSAwXG4gIH1cbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgdC5mcm9udCA8LSAwO1xuICB0Lmxlbmd0aCA8LSAwO1xuICB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIDwtIDBcbjs7XG5cbmxldCBncm93IHQgPVxuICBsZXQgb2xkX2NhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBsZXQgbmV3X2NhcGFjaXR5ID0gb2xkX2NhcGFjaXR5ICogMiBpblxuICBsZXQgb2xkX2pvYnMgPSB0LmpvYnMgaW5cbiAgbGV0IG9sZF9mcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IGxlbjEgPSBJbnQubWluIHQubGVuZ3RoIChvbGRfY2FwYWNpdHkgLSBvbGRfZnJvbnQpICogc2xvdHNfcGVyX2VsdCBpblxuICBsZXQgbGVuMiA9ICh0Lmxlbmd0aCAqIHNsb3RzX3Blcl9lbHQpIC0gbGVuMSBpblxuICBsZXQgbmV3X2pvYnMgPSBjcmVhdGVfYXJyYXkgfmNhcGFjaXR5Om5ld19jYXBhY2l0eSBpblxuICBBLmJsaXRcbiAgICB+bGVuOmxlbjFcbiAgICB+c3JjOm9sZF9qb2JzXG4gICAgfnNyY19wb3M6KG9sZF9mcm9udCAqIHNsb3RzX3Blcl9lbHQpXG4gICAgfmRzdDpuZXdfam9ic1xuICAgIH5kc3RfcG9zOjA7XG4gIEEuYmxpdCB+bGVuOmxlbjIgfnNyYzpvbGRfam9icyB+c3JjX3BvczowIH5kc3Q6bmV3X2pvYnMgfmRzdF9wb3M6bGVuMTtcbiAgdC5tYXNrIDwtIG5ld19jYXBhY2l0eSAtIDE7XG4gIHQuam9icyA8LSBuZXdfam9icztcbiAgdC5mcm9udCA8LSAwXG47O1xuXG5sZXQgc2V0ICh0eXBlIGEpIHQgaSBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBsZXQgb2Zmc2V0ID0gb2Zmc2V0IHQgaSBpblxuICBBLnVuc2FmZV9zZXQgdC5qb2JzIG9mZnNldCAoT2JqLnJlcHIgKGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCkpO1xuICBBLnVuc2FmZV9zZXQgdC5qb2JzIChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgKGYgOiBhIC0+IHVuaXQpKTtcbiAgQS51bnNhZmVfc2V0IHQuam9icyAob2Zmc2V0ICsgMikgKE9iai5yZXByIChhIDogYSkpXG47O1xuXG5sZXQgZW5xdWV1ZSB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIGdyb3cgdDtcbiAgc2V0IHQgdC5sZW5ndGggZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIkpvYnMuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIGdvdCBuZWdhdGl2ZSBudW1iZXJcIiAobiA6IGludCkgKHQgOiB0KV07XG4gIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPC0gblxuOztcblxubGV0IGNhbl9ydW5fYV9qb2IgdCA9IHQubGVuZ3RoID4gMCAmJiB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlID4gMFxuXG5sZXQgcnVuX2pvYiB0IChzY2hlZHVsZXIgOiBTY2hlZHVsZXIudCkgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgdC5udW1fam9ic19ydW4gPC0gdC5udW1fam9ic19ydW4gKyAxO1xuICBTY2hlZHVsZXIuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dDtcbiAgZiBhXG47O1xuXG5sZXQgcnVuX2V4dGVybmFsX2pvYnMgdCAoc2NoZWR1bGVyIDogU2NoZWR1bGVyLnQpID1cbiAgbGV0IGV4dGVybmFsX2pvYnMgPSBzY2hlZHVsZXIuZXh0ZXJuYWxfam9icyBpblxuICB3aGlsZSBUaHJlYWRfc2FmZV9xdWV1ZS5sZW5ndGggZXh0ZXJuYWxfam9icyA+IDAgZG9cbiAgICBsZXQgKEV4dGVybmFsX2pvYi5UIChleGVjdXRpb25fY29udGV4dCwgZiwgYSkpID1cbiAgICAgIFRocmVhZF9zYWZlX3F1ZXVlLmRlcXVldWVfZXhuIGV4dGVybmFsX2pvYnNcbiAgICBpblxuICAgIHJ1bl9qb2IgdCBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG4gIGRvbmVcbjs7XG5cbmxldCBydW5fam9icyAodHlwZSBhKSB0IHNjaGVkdWxlciA9XG4gICgqIFdlIGRvIHRoZSBbdHJ5LXdpdGhdIG91dHNpZGUgb2YgdGhlIFt3aGlsZV0gYmVjYXVzZSBpdCBpcyBjaGVhcGVyIHRoYW4gZG9pbmcgYVxuICAgICBbdHJ5LXdpdGhdIGZvciBlYWNoIGpvYi4gKilcbiAgKCogW3J1bl9leHRlcm5hbF9qb2JzXSBiZWZvcmUgZW50ZXJpbmcgdGhlIGxvb3AsIHNpbmNlIGl0IG1pZ2h0IGVucXVldWUgYSBqb2IsXG4gICAgIGNoYW5naW5nIFt0Lmxlbmd0aF0uICopXG4gIHRyeVxuICAgIHJ1bl9leHRlcm5hbF9qb2JzIHQgc2NoZWR1bGVyO1xuICAgIHdoaWxlIGNhbl9ydW5fYV9qb2IgdCBkb1xuICAgICAgbGV0IHRoaXNfam9iID0gb2Zmc2V0IHQgMCBpblxuICAgICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCA9XG4gICAgICAgIE9iai5vYmogKEEudW5zYWZlX2dldCB0LmpvYnMgdGhpc19qb2IpXG4gICAgICBpblxuICAgICAgbGV0IGYgOiBhIC0+IHVuaXQgPSBPYmoub2JqIChBLnVuc2FmZV9nZXQgdC5qb2JzICh0aGlzX2pvYiArIDEpKSBpblxuICAgICAgbGV0IGEgOiBhID0gT2JqLm9iaiAoQS51bnNhZmVfZ2V0IHQuam9icyAodGhpc19qb2IgKyAyKSkgaW5cbiAgICAgICgqIFdlIGNsZWFyIG91dCB0aGUgam9iIHJpZ2h0IG5vdyBzbyB0aGF0IGl0IGlzbid0IGxpdmUgYXQgdGhlIG5leHQgbWlub3JcbiAgICAgICAgIGNvbGxlY3Rpb24uICBXZSB0cmllZCBub3QgZG9pbmcgdGhpcyBhbmQgc2F3IHNpZ25pZmljYW50ICgxNSUgb3Igc28pIHBlcmZvcm1hbmNlXG4gICAgICAgICBoaXRzIGR1ZSB0byBzcHVyaW91cyBwcm9tb3Rpb24uICopXG4gICAgICBzZXQgdCAwIGR1bW15X2UgZHVtbXlfZiBkdW1teV9hO1xuICAgICAgdC5mcm9udCA8LSAodC5mcm9udCArIDEpIGxhbmQgdC5tYXNrO1xuICAgICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgICAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIC0gMTtcbiAgICAgICgqIEl0IGlzIE9LIGlmIFtydW5fam9iXSBvciBbcnVuX2V4dGVybmFsX2pvYnNdIHJhaXNlcywgaW4gd2hpY2ggY2FzZSB0aGUgZXhuIGlzXG4gICAgICAgICBoYW5kbGVkIGJ5IHRoZSBvdXRlciB0cnktd2l0aC4gIFRoZSBvbmx5IHNpZGUgZWZmZWN0cyB3ZSBoYXZlIGRvbmUgYXJlIHRvIHRha2VcbiAgICAgICAgIHRoZSBqb2Igb3V0IG9mIHRoZSBxdWV1ZSBhbmQgZGVjcmVtZW50IFtqb2JzX2xlZnRfdGhpc19jeWNsZV0uICBbcnVuX2pvYl0gb3JcbiAgICAgICAgIFtydW5fZXh0ZXJuYWxfam9ic10gbWF5IHNpZGUgZWZmZWN0IFt0XSwgZWl0aGVyIGJ5IGVucXVldWVpbmcgam9icywgb3IgYnlcbiAgICAgICAgIGNsZWFyaW5nIFt0XS4gKilcbiAgICAgIHJ1bl9qb2IgdCBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgICAgKCogW3J1bl9leHRlcm5hbF9qb2JzXSBhdCBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgW3doaWxlXSBsb29wLCBmb3IgZmFpcm5lc3MuICopXG4gICAgICBydW5fZXh0ZXJuYWxfam9icyB0IHNjaGVkdWxlclxuICAgIGRvbmU7XG4gICAgT2sgKClcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgICgqIFdlIGNhbGwgW0V4bi5iYWNrdHJhY2VdIGltbWVkaWF0ZWx5IGFmdGVyIGNhdGNoaW5nIGFuIHVuaGFuZGxlZCBleGNlcHRpb24sIHRvXG4gICAgICAgZW5zdXJlIHRoZXJlIGlzIG5vIGludGVydmVuaW5nIGNvZGUgdGhhdCBpbnRlcmZlcmVzIHdpdGggdGhlIGdsb2JhbCBiYWNrdHJhY2VcbiAgICAgICBzdGF0ZS4gKilcbiAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgIEVycm9yIChleG4sIGJhY2t0cmFjZSlcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIFRpbWVfbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1lX25zXG5cbiAgZXh0ZXJuYWwgZm9ybWF0IDogZmxvYXQgLT4gc3RyaW5nIC0+IHN0cmluZyA9IFwiY29yZV90aW1lX25zX2Zvcm1hdFwiXG5cbiAgKCogV2UgdXNlIGEgbW9yZSBwbGVhc2FudCBmb3JtYXQgdGhhbiBbQ29yZS5UaW1lX25zLnNleHBfb2ZfdF0sXG4gICAgIHdoaWNoIGhhcyB0byBiZSBtZXNzaWVyIGZvciByb3VuZCB0cmlwcGFiaWxpdHkuICopXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgWyVzZXhwXG4gICAgICAoZm9ybWF0ICh0IHw+IHRvX3NwYW5fc2luY2VfZXBvY2ggfD4gU3Bhbi50b19zZWMpIFwiJVktJW0tJWRUJUg6JU06JVMlelwiIDogc3RyaW5nKV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1pbmdfd2hlZWwuQWxhcm1cblxuICBsZXQgaXNfbnVsbCB0ID0gcGh5c19lcXVhbCB0IChudWxsICgpKVxuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gPSBUaW1pbmdfd2hlZWwuQWxhcm1fcHJlY2lzaW9uXG5cbmxldCBkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWcgPVxuICAoKiAxLzh0aCBvZiBhIG1pbGxpc2Vjb25kIGFsYXJtX3ByZWNpc2lvbiBzZWVtcyBzdWZmaWNpZW50IHRvIGF2b2lkIGhhdmluZyBtYW55IGFsYXJtc1xuICAgICBpbiB0aGUgc2FtZSBpbnRlcnZhbCwgd2hpY2ggYXZvaWRzIHF1YWRyYXRpYyBpbnNlcnRpb24gc29ydCB3aGVuIGZpcmluZyBhbGFybXMuICBBbmRcbiAgICAgdGhlIGxldmVsIGJpdHMgZ2l2ZSB1cyBsZXZlbHMgb2YgPjFzLCA+MW0sID4xaCwgPjFkLiAgU2VlIHRlc3QgaW5cbiAgICAgWy4uL3Rlc3QvdGVzdF9zeW5jaHJvbm91c190aW1lX3NvdXJjZS5tbF0uICopXG4gIFRpbWluZ193aGVlbC5Db25maWcuY3JlYXRlXG4gICAgfmFsYXJtX3ByZWNpc2lvbjpBbGFybV9wcmVjaXNpb24uKGRpdiBhYm91dF9vbmVfbWlsbGlzZWNvbmQgfnBvdzI6MylcbiAgICB+bGV2ZWxfYml0czooVGltaW5nX3doZWVsLkxldmVsX2JpdHMuY3JlYXRlX2V4biBbIDEzOyA2OyA2OyA1IF0pXG4gICAgKClcbjs7XG5cbnR5cGUgY2FsbGJhY2sgPSB1bml0IC0+IHVuaXRcblxubW9kdWxlIElkID0gVHlwZXMuVGltZV9zb3VyY2VfaWRcblxubW9kdWxlIFQxID0gc3RydWN0XG4gIG1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICAgIG1vZHVsZSBTdGF0dXMgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50LlN0YXR1cy50ID1cbiAgICAgICAgfCBGaXJlZCAoKiBpbiBbZmlyZWRfZXZlbnRzXSwgcmVhZHkgdG8gcnVuICopXG4gICAgICAgIHwgSGFwcGVuaW5nICgqIGN1cnJlbnRseSBydW5uaW5nIHRoZSBjYWxsYmFjayAqKVxuICAgICAgICB8IFNjaGVkdWxlZCAoKiBpbiB0aGUgdGltaW5nIHdoZWVsICopXG4gICAgICAgIHwgVW5zY2hlZHVsZWQgKCogbm90IGluIHRpbWluZyB3aGVlbCBvciBbZmlyZWRfZXZlbnRzXSAqKVxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICAgIGxldCB0cmFuc2l0aW9uX2lzX2FsbG93ZWQgfmZyb20gfnRvXyA9XG4gICAgICAgIG1hdGNoIGZyb20sIHRvXyB3aXRoXG4gICAgICAgIHwgRmlyZWQsIEhhcHBlbmluZyAoKiBzdGFydGVkIHJ1bm5pbmcgY2FsbGJhY2sgKilcbiAgICAgICAgfCBGaXJlZCwgVW5zY2hlZHVsZWQgKCogYWJvcnRlZCAqKVxuICAgICAgICAoKiBbcmVzY2hlZHVsZV8qXSBnb2VzIHRocm91Z2ggYW4gaW50ZXJtZWRpYXRlIFtGaXJlZCwgVW5zY2hlZHVsZWRdIHN0YXRlLFxuICAgICAgICAgICBzbyB3ZSBuZXZlciB0cmFuc2l0aW9uIGZyb20gW0ZpcmVkXSBkaXJlY3RseSB0byBbU2NoZWR1bGVkXS4gKilcbiAgICAgICAgfCBIYXBwZW5pbmcsIFNjaGVkdWxlZCAoKiBmb3IgcmVwZWF0aW5nIGV2ZW50cyAqKVxuICAgICAgICB8IEhhcHBlbmluZywgVW5zY2hlZHVsZWQgKCogZXZlbnQgY2FsbGJhY2sgZmluaXNoZWQgKilcbiAgICAgICAgfCBTY2hlZHVsZWQsIEZpcmVkICgqIG1vdmVkIGZyb20gdGltaW5nIHdoZWVsIHRvIFtmaXJlZF9ldmVudHNdICopXG4gICAgICAgIHwgU2NoZWR1bGVkLCBVbnNjaGVkdWxlZCAoKiBhYm9ydGVkICopXG4gICAgICAgIHwgVW5zY2hlZHVsZWQsIEZpcmVkICgqIGV2ZW50IHNjaGVkdWxlZCBpbiB0aGUgcGFzdCAqKVxuICAgICAgICB8IFVuc2NoZWR1bGVkLCBTY2hlZHVsZWQgKCogZXZlbnQgc2NoZWR1bGVkIGluIHRoZSBmdXR1cmUgKikgLT4gdHJ1ZVxuICAgICAgICB8IChGaXJlZCB8IEhhcHBlbmluZyB8IFNjaGVkdWxlZCB8IFVuc2NoZWR1bGVkKSwgXyAtPiBmYWxzZVxuICAgICAgOztcbiAgICBlbmRcblxuICAgIHR5cGUgZXZlbnQgPSBUeXBlcy5FdmVudC50XG5cbiAgICBsZXQgc2V4cF9vZl9ldmVudFxuICAgICAgICAgICh7IGFsYXJtID0gX1xuICAgICAgICAgICA7IGF0XG4gICAgICAgICAgIDsgY2FsbGJhY2sgPSBfXG4gICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBfXG4gICAgICAgICAgIDsgaW50ZXJ2YWxcbiAgICAgICAgICAgOyBuZXh0X2ZpcmVkID0gX1xuICAgICAgICAgICA7IHByZXZfZmlyZWQgPSBfXG4gICAgICAgICAgIDsgc3RhdHVzXG4gICAgICAgICAgIH0gOlxuICAgICAgICAgICAgIGV2ZW50KVxuICAgICAgPVxuICAgICAgWyVzZXhwXG4gICAgICAgIHsgc3RhdHVzIDogU3RhdHVzLnRcbiAgICAgICAgOyBhdCA6IFRpbWVfbnMudFxuICAgICAgICA7IGludGVydmFsIDogKFRpbWVfbnMuU3Bhbi50IG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgICAgICB9XVxuICAgIDs7XG5cbiAgICBtb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gICAgICAoKiBUaGlzIHJlZGVmaW5pdGlvbiBvZiBbRXZlbnRdIGlzIGhlcmUgc28gdGhlIHR5cGUgY2hlY2tzIGFyZSByaWdodCBuZXh0XG4gICAgICAgICB0byBbT2JqLm1hZ2ljXXMuICopXG4gICAgICBtb2R1bGUgRXZlbnRfaXNfYmxvY2sgOiBzaWcgZW5kID0gc3RydWN0XG4gICAgICAgIG9wZW4gVHlwZXNcbiAgICAgICAgb3BlbiBFdmVudFxuXG4gICAgICAgIHR5cGUgX3QgPSB0ID1cbiAgICAgICAgICB7ICgqIG11c3QgbmV2ZXIgYmUgaW1tZWRpYXRlICopXG4gICAgICAgICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbiAgICAgICAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICAgICAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgICA7IG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICAgICAgICA7IG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgICAgICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgICAgICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICB0eXBlIHQgPSBUeXBlcy5FdmVudC5PcHRpb24udFxuXG4gICAgICAoKiBVc2luZyBhbiBpbW1lZGlhdGUgcmF0aGVyIHRoYW4gYSBzdGF0aWNhbGx5LWFsbG9jYXRlZCByZWNvcmQgaGVyZSBzZWVtcyB0b1xuICAgICAgICAgaW1wcm92ZSBwZXJmb3JtYW5jZSBub3RpY2VhYmx5IChbLi4vYmVuY2gvYmluL2JlbmNoX3RpbWVfc291cmNlLmV4ZV0gYmVuY2htYXJrXG4gICAgICAgICBpcyBmYXN0ZXIgYnkgfjEwbnMgcGVyIGFsYXJtKSwgcHJlc3VtYWJseSBiZWNhdXNlIGl0IGF2b2lkcyB0aGUgZXhwZW5zaXZlXG4gICAgICAgICBwYXJ0cyBvZiBjYW1sX21vZGlmeS4gKilcbiAgICAgIGxldCBub25lID0gKE9iai5tYWdpYyBOb25lIDogdCkgKCogYW4gYXJiaXRyYXJ5IGltbWVkaWF0ZSAqKVxuXG4gICAgICBsZXQgc29tZSA9IChPYmoubWFnaWMgOiBUeXBlcy5FdmVudC50IC0+IHQpXG4gICAgICBsZXQgaXNfbm9uZSB0ID0gcGh5c19lcXVhbCB0IG5vbmVcbiAgICAgIGxldCBpc19zb21lIHQgPSBub3QgKGlzX25vbmUgdClcbiAgICAgIGxldCBmaXJzdF9zb21lIHQxIHQyID0gaWYgaXNfc29tZSB0MSB0aGVuIHQxIGVsc2UgdDJcblxuICAgICAgbW9kdWxlIE9wdGlvbmFsX3N5bnRheCA9IHN0cnVjdFxuICAgICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgICAgbGV0IGlzX25vbmUgPSBpc19ub25lXG4gICAgICAgICAgbGV0IHVuc2FmZV92YWx1ZSA9IChPYmoubWFnaWMgOiB0IC0+IFR5cGVzLkV2ZW50LnQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIG9wZW4gT3B0aW9uYWxfc3ludGF4XG5cbiAgICAgIGxldCBzZXhwX29mX3QgdCA9XG4gICAgICAgIG1hdGNoJW9wdGlvbmFsIHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gWyVzZXhwICgpXVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gWyVzZXhwIChldmVudCA6IGV2ZW50KV1cbiAgICAgIDs7XG5cbiAgICAgIGxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICAgICAgbWF0Y2glb3B0aW9uYWwgdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBkZWZhdWx0XG4gICAgICAgIHwgU29tZSBldmVudCAtPiBldmVudFxuICAgICAgOztcblxuICAgICAgbGV0IHZhbHVlX2V4biB0ID1cbiAgICAgICAgbWF0Y2glb3B0aW9uYWwgdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByYWlzZV9zIFslc2V4cCBcIltTeW5jaHJvbm91c190aW1lX3NvdXJjZS5FdmVudC5PcHRpb24udmFsdWVfZXhuIE5vbmVdXCJdXG4gICAgICAgIHwgU29tZSBldmVudCAtPiBldmVudFxuICAgICAgOztcblxuICAgICAgbGV0IHRvX29wdGlvbiB0ID1cbiAgICAgICAgbWF0Y2glb3B0aW9uYWwgdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBldmVudCAtPiBTb21lIGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgb2Zfb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IG5vbmVcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IHNvbWUgZXZlbnRcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICB0eXBlIHQgPSBUeXBlcy5FdmVudC50ID1cbiAgICAgIHsgKCogW2FsYXJtXSBpcyBub24tbnVsbCBpZmYgdGhlIGV2ZW50IGlzIGluIHRoZSB0aW1pbmcgd2hlZWwuICopXG4gICAgICAgIG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50XG4gICAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICAgIDsgY2FsbGJhY2sgOiB1bml0IC0+IHVuaXRcbiAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICA7ICgqIFtpbnRlcnZhbF0gaXMgdGhlIHBlcmlvZCBmb3IgdGhlIHBlcmlvZGljIGV2ZW50cy4gKilcbiAgICAgICAgbXV0YWJsZSBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50IG9wdGlvblxuICAgICAgOyAoKiBbbmV4dF9maXJlZF0gYW5kIFtwcmV2X2ZpcmVkXSBjcmVhdGUgYSBkb3VibHktbGlua2VkIChub24tY2lyY3VsYXIpIGxpc3Qgb2ZcbiAgICAgICAgICAgZmlyZWQgZXZlbnRzLCBsaW5rZWQgdmlhIHRoZXNlIGZpZWxkcy4gQW4gZXZlbnQgaXMgYWRkZWQgdG8gdGhlIGxpc3Qgd2hlblxuICAgICAgICAgICBpdCBmaXJlcywgZWl0aGVyIGJlY2F1c2UgaXQgaXMgYWRkZWQgd2l0aCBhIHRpbWUgaW4gdGhlIHBhc3QsIG9yXG4gICAgICAgICAgIGJlY2F1c2UgdGltZSBhZHZhbmNlcy4gW2FkdmFuY2VfYnlfYWxhcm1zXSBpdGVyYXRlcyBvdmVyIHRoZSBldmVudHNcbiAgICAgICAgICAgaW4gW25leHRfZmlyZWRdIGFuZCBydW5zIHRoZW0sIGVtcHR5aW5nIHRoZSBsaXN0LiBbbm9uZV0gaXMgdXNlZCB0b1xuICAgICAgICAgICBpbmRpY2F0ZSB0aGUgZW5kIG9mIHRoZSBsaW5rZWQgbGlzdCBvZiBmaXJlZCBldmVudHMuICopXG4gICAgICAgIG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgICA7IG11dGFibGUgcHJldl9maXJlZCA6IE9wdGlvbi50XG4gICAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gWyVzZXhwX29mOiBldmVudF1cblxuICAgIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgICAgfmFsYXJtOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gYWxhcm0gLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAgICAgICAgICAgIChBbGFybS5pc19udWxsIGFsYXJtKVxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgIChtYXRjaCB0LnN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgRmlyZWQgfCBIYXBwZW5pbmcgfCBVbnNjaGVkdWxlZCAtPiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHwgU2NoZWR1bGVkIC0+IGZhbHNlKSkpXG4gICAgICAgICAgfmF0Omlnbm9yZVxuICAgICAgICAgIH5jYWxsYmFjazppZ25vcmVcbiAgICAgICAgICB+ZXhlY3V0aW9uX2NvbnRleHQ6aWdub3JlXG4gICAgICAgICAgfmludGVydmFsOmlnbm9yZVxuICAgICAgICAgIH5uZXh0X2ZpcmVkOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbmV4dF9maXJlZCAtPlxuICAgICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwgKG5leHRfZmlyZWQgOiBPcHRpb24udCkgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICgqIFtuZXh0X2ZpcmVkXSBjYW4gYmUgW05vbmVdIGV2ZW4gaWYgdGhlIGV2ZW50IHN0YXR1cyBpcyBGaXJlZCwgYXNzdW1pbmdcbiAgICAgICAgICAgICAgICAgICAgaXQncyBhdCB0aGUgZW5kIG9mIHRoZSBmaXJlZCBldmVudHMgbGlzdCAqKVxuICAgICAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgICAgfCBTb21lIG5leHRfZmlyZWQgLT5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogU3RhdHVzLnRdIHQuc3RhdHVzIH5leHBlY3Q6RmlyZWQ7XG4gICAgICAgICAgICAgICAgIGFzc2VydCAocGh5c19lcXVhbCAoT3B0aW9uLnNvbWUgdCkgbmV4dF9maXJlZC5wcmV2X2ZpcmVkKSkpXG4gICAgICAgICAgfnByZXZfZmlyZWQ6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbCAocHJldl9maXJlZCA6IE9wdGlvbi50KSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgKCogW3ByZXZfZmlyZWRdIGNhbiBiZSBbTm9uZV0gZXZlbiBpZiB0aGUgZXZlbnQgc3RhdHVzIGlzIEZpcmVkLCBhc3N1bWluZ1xuICAgICAgICAgICAgICAgICAgICBpdCdzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpcmVkIGV2ZW50cyBsaXN0ICopXG4gICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgcHJldl9maXJlZCAtPlxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBTdGF0dXMudF0gdC5zdGF0dXMgfmV4cGVjdDpGaXJlZDtcbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChPcHRpb24uc29tZSB0KSBwcmV2X2ZpcmVkLm5leHRfZmlyZWQpKSlcbiAgICAgICAgICB+c3RhdHVzOmlnbm9yZSlcbiAgICA7O1xuXG4gICAgbGV0IHNldF9zdGF0dXMgdCB0b18gPVxuICAgICAgbGV0IGZyb20gPSB0LnN0YXR1cyBpblxuICAgICAgaWYgbm90IChTdGF0dXMudHJhbnNpdGlvbl9pc19hbGxvd2VkIH5mcm9tIH50b18pXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFslaGVyZV1cbiAgICAgICAgICAgICAgXCJidWcgLS0gc2V0X3N0YXR1cyB0cmFuc2l0aW9uIG5vdCBhbGxvd2VkXCJcbiAgICAgICAgICAgICAgKGZyb20gOiBTdGF0dXMudClcbiAgICAgICAgICAgICAgKHRvXyA6IFN0YXR1cy50KVxuICAgICAgICAgICAgICB+ZXZlbnQ6KHQgOiB0KV07XG4gICAgICB0LnN0YXR1cyA8LSB0b19cbiAgICA7O1xuXG4gICAgbGV0IHNldF9zdGF0dXNfaWYgfmlzIHQgdG9fID0gaWYgU3RhdHVzLmVxdWFsIGlzIHQuc3RhdHVzIHRoZW4gc2V0X3N0YXR1cyB0IHRvX1xuICAgIGxldCBzY2hlZHVsZWRfYXQgPSBhdFxuICBlbmRcblxuICBtb2R1bGUgSm9iX29yX2V2ZW50ID0gc3RydWN0XG4gICAgaW5jbHVkZSBKb2Jfb3JfZXZlbnRcblxuICAgIGxldCBzZXhwX29mX3QgdCA9XG4gICAgICBsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgICAgIGxldCAoSyBrKSA9IGtpbmQgdCBpblxuICAgICAgbWF0Y2ggaywgcHJvamVjdCBrIHQgd2l0aFxuICAgICAgfCBFdmVudCwgZXZlbnQgLT4gWyVzZXhwIChldmVudCA6IEV2ZW50LnQpXVxuICAgICAgfCBKb2IsIF8gLT5cbiAgICAgICAgKCogV2UgZG9uJ3QgZGlzcGxheSB0aGUgW0pvYi50XXMgaW4gW2V2ZW50c10gYmVjYXVzZSB0aG9zZSBhcmVcbiAgICAgICAgICAgcG9vbCBwb2ludGVycywgd2hpY2ggYXJlIHVuaW5mb3JtYXRpdmUuICopXG4gICAgICAgIFslbWVzc2FnZSBcIjxKb2IudD5cIl1cbiAgICA7O1xuICBlbmRcblxuICB0eXBlIC0ncncgdCA9ICdydyBUeXBlcy5UaW1lX3NvdXJjZS50MSA9XG4gICAgeyBpZCA6IElkLnRcbiAgICA7ICgqIFthZHZhbmNlX2Vycm9yc10gYWNjdW11bGF0ZXMgZXJyb3JzIHJhaXNlZCBieSBhbGFybXMgcnVuIGJ5XG4gICAgICAgICBbYWR2YW5jZV9ieV9hbGFybXNdLiAqKVxuICAgICAgbXV0YWJsZSBhZHZhbmNlX2Vycm9ycyA6IEVycm9yLnQgbGlzdFxuICAgIDsgKCogW2FtX2FkdmFuY2luZ10gaXMgdHJ1ZSBvbmx5IGR1cmluZyBbYWR2YW5jZV9ieV9hbGFybXNdLCBhbmQgaXMgdXNlZCB0byBjYXVzZVxuICAgICAgICAgY2FsbGJhY2tzIHRvIHJhaXNlIGlmIHRoZXkgY2FsbCBbYWR2YW5jZV9ieV9hbGFybXNdLiAqKVxuICAgICAgbXV0YWJsZSBhbV9hZHZhbmNpbmcgOiBib29sXG4gICAgOyBldmVudHMgOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwudFxuICAgIDsgKCogW2ZpcmVkX2V2ZW50c10gaXMgdGhlIGZyb250IG9mIHRoZSBkb3VibHktbGlua2VkIGxpc3Qgb2YgZmlyZWQgZXZlbnRzLFxuICAgICAgICAgd2hpY2ggaXMgc3RvcmVkIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW0V2ZW50LmF0XS4gKilcbiAgICAgIG11dGFibGUgZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnRcbiAgICA7ICgqIFttb3N0X3JlY2VudGx5X2ZpcmVkXSBpcyB0aGUgZXZlbnQgdGhhdCB3YXMgbW9zdCByZWNlbnRseSBpbnNlcnRlZCBpbnRvXG4gICAgICAgICBbZmlyZWRfZXZlbnRzXS4gSXQgaXMgdXNlZCBhcyBhbiBvcHRpbWl6YXRpb24gdG8gYWxsb3cgaW5zZXJ0aW9uIG9mXG4gICAgICAgICBzdWJzZXF1ZW50IGV2ZW50cyB0byBzdGFydCBsYXRlciBpbiB0aGUgbGlzdCByYXRoZXIgdGhhbiBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgSXQgc3BlY2lmaWNhbGx5IGF2b2lkcyBxdWFkcmF0aWMgYmVoYXZpb3Igd2hlbiBpbnNlcnRpbmcgbXVsdGlwbGUgZXZlbnRzXG4gICAgICAgICB0aGF0IGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0aW1lIC0tIHRoZSB0aW1lIHNvdXJjZSBmaXJlcyBzdWNoIGV2ZW50cyBpblxuICAgICAgICAgdGhlIG9yZGVyIHRoZXkgd2VyZSBhZGRlZCwgYW5kIHdlIHdhbnQgdGhlbSB0byBiZSBpbiB0aGF0IHNhbWUgb3JkZXIgaW5cbiAgICAgICAgIFtmaXJlZF9ldmVudHNdLiAqKVxuICAgICAgbXV0YWJsZSBtb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnRcbiAgICA7ICgqIFdlIHN0b3JlIFtoYW5kbGVfZmlyZWRdIGluIFt0XSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IGV2ZXJ5IHRpbWUgd2UgY2FsbFxuICAgICAgICAgW2FkdmFuY2VfY2xvY2tdLiAqKVxuICAgICAgaGFuZGxlX2ZpcmVkIDogSm9iX29yX2V2ZW50LnQgQWxhcm0udCAtPiB1bml0XG4gICAgOyBpc193YWxsX2Nsb2NrIDogYm9vbFxuICAgIDsgc2NoZWR1bGVyIDogU2NoZWR1bGVyMC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgKCogV2UgZG9uJ3QgaW5jbHVkZSB0aGUgW2lkXSBpbiB0aGUgc2V4cCBiZWNhdXNlIHRoZSB1c2VyIChyaWdodGx5KSBjYW4ndCBjb250cm9sIGl0LCBzb1xuICAgICBpdCdzIGhhcmQgdG8gbWFrZSBpdCBkZXRlcm1pbmlzdGljIGluIHRlc3RzLiAqKVxuICBsZXQgc2V4cF9vZl90XG4gICAgICAgIF9cbiAgICAgICAgeyBpZCA9IF9cbiAgICAgICAgOyBhZHZhbmNlX2Vycm9ycyA9IF9cbiAgICAgICAgOyBhbV9hZHZhbmNpbmcgPSBfXG4gICAgICAgIDsgZXZlbnRzXG4gICAgICAgIDsgZmlyZWRfZXZlbnRzID0gX1xuICAgICAgICA7IGhhbmRsZV9maXJlZCA9IF9cbiAgICAgICAgOyBpc193YWxsX2Nsb2NrXG4gICAgICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IF9cbiAgICAgICAgOyBzY2hlZHVsZXIgPSBfXG4gICAgICAgIH1cbiAgICA9XG4gICAgbGV0IG5vdyA9IFRpbWluZ193aGVlbC5ub3cgZXZlbnRzIGluXG4gICAgaWYgaXNfd2FsbF9jbG9ja1xuICAgIHRoZW4gWyVtZXNzYWdlIFwid2FsbF9jbG9ja1wiIChub3cgOiBUaW1lX25zLnQpXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGFsbF9ldmVudHMgPSByZWYgW10gaW5cbiAgICAgIFRpbWluZ193aGVlbC5pdGVyIGV2ZW50cyB+ZjooZnVuIGFsYXJtIC0+XG4gICAgICAgIGFsbF9ldmVudHMgOj0gKEFsYXJtLmF0IGV2ZW50cyBhbGFybSwgQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSA6OiAhYWxsX2V2ZW50cyk7XG4gICAgICBsZXQgZXZlbnRzID1cbiAgICAgICAgTGlzdC5zb3J0ICFhbGxfZXZlbnRzIH5jb21wYXJlOihmdW4gKGF0MSwgXykgKGF0MiwgXykgLT4gVGltZV9ucy5jb21wYXJlIGF0MSBhdDIpXG4gICAgICAgIHw+IExpc3QubWFwIH5mOnNuZFxuICAgICAgaW5cbiAgICAgIFslbWVzc2FnZSBcIlwiIChub3cgOiBUaW1lX25zLnQpIChldmVudHMgOiBKb2Jfb3JfZXZlbnQudCBsaXN0KV0pXG4gIDs7XG5cbiAgbGV0IHRpbWluZ193aGVlbF9ub3cgdCA9IFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHNcblxuICBsZXQgaXNfaW5fZmlyZWRfZXZlbnRzID1cbiAgICBsZXQgcmVjIHNlYXJjaCBjdXJyZW50IH50YXJnZXRfZXZlbnQgPVxuICAgICAgbWF0Y2glb3B0aW9uYWwgKGN1cnJlbnQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICB8IFNvbWUgY3VycmVudCAtPlxuICAgICAgICBwaHlzX2VxdWFsIGN1cnJlbnQgdGFyZ2V0X2V2ZW50IHx8IHNlYXJjaCBjdXJyZW50Lm5leHRfZmlyZWQgfnRhcmdldF9ldmVudFxuICAgIGluXG4gICAgZnVuIHQgdGFyZ2V0X2V2ZW50IC0+IHNlYXJjaCB0LmZpcmVkX2V2ZW50cyB+dGFyZ2V0X2V2ZW50XG4gIDs7XG5cbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgKHR5cGUgcncpIH5qb2I6KGpvYl9pbnZhcmlhbnQgOiBKb2IudCAtPiB1bml0KSAodCA6IHJ3IHQpID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+aWQ6aWdub3JlXG4gICAgICAgIH5hZHZhbmNlX2Vycm9yczppZ25vcmVcbiAgICAgICAgfmFtX2FkdmFuY2luZzppZ25vcmVcbiAgICAgICAgfmV2ZW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBldmVudHMgLT5cbiAgICAgICAgICAgICBUaW1pbmdfd2hlZWwuaW52YXJpYW50IGlnbm9yZSBldmVudHM7XG4gICAgICAgICAgICAgVGltaW5nX3doZWVsLml0ZXIgZXZlbnRzIH5mOihmdW4gYWxhcm0gLT5cbiAgICAgICAgICAgICAgIGxldCBqb2Jfb3JfZXZlbnQgPSBBbGFybS52YWx1ZSBldmVudHMgYWxhcm0gaW5cbiAgICAgICAgICAgICAgIGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICAgICAgICAgICAgICAgbGV0IChLIGspID0ga2luZCBqb2Jfb3JfZXZlbnQgaW5cbiAgICAgICAgICAgICAgIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBKb2IsIGpvYiAtPiBqb2JfaW52YXJpYW50IGpvYlxuICAgICAgICAgICAgICAgfCBFdmVudCwgZXZlbnQgLT5cbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIGFsYXJtIGV2ZW50LmFsYXJtKTtcbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XSBldmVudC5hdCB+ZXhwZWN0OihBbGFybS5hdCBldmVudHMgYWxhcm0pO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBFdmVudC5TdGF0dXMudF0gZXZlbnQuc3RhdHVzIH5leHBlY3Q6U2NoZWR1bGVkO1xuICAgICAgICAgICAgICAgICBFdmVudC5pbnZhcmlhbnQgZXZlbnQpKSlcbiAgICAgICAgfmZpcmVkX2V2ZW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1biAoZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnQpIC0+XG4gICAgICAgICAgICAgbGV0IHJlYyBjaGVja19ldmVudCAoY3VycmVudCA6IEV2ZW50LnQpID1cbiAgICAgICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgY3VycmVudC5hdCAodGltaW5nX3doZWVsX25vdyB0KSk7XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbC5FdmVudC5PcHRpb24gY3VycmVudC5uZXh0X2ZpcmVkIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgICAgfCBTb21lIG5leHQgLT5cbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBjdXJyZW50LmF0IG5leHQuYXQpO1xuICAgICAgICAgICAgICAgICBjaGVja19ldmVudCBuZXh0XG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbC5FdmVudC5PcHRpb24gZmlyZWRfZXZlbnRzIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgZXZlbnQgLT4gY2hlY2tfZXZlbnQgZXZlbnQpKVxuICAgICAgICB+aGFuZGxlX2ZpcmVkOmlnbm9yZVxuICAgICAgICB+aXNfd2FsbF9jbG9jazppZ25vcmVcbiAgICAgICAgfm1vc3RfcmVjZW50bHlfZmlyZWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbW9zdF9yZWNlbnRseV9maXJlZCAtPlxuICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsIChtb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgZXZlbnQgLT4gYXNzZXJ0IChpc19pbl9maXJlZF9ldmVudHMgdCBldmVudCkpKVxuICAgICAgICB+c2NoZWR1bGVyOmlnbm9yZSlcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPSBpbnZhcmlhbnRfd2l0aF9qb2JzIH5qb2I6KGZ1biBfIC0+ICgpKSB0XG5lbmRcblxub3BlbiBUMVxuXG50eXBlIHQgPSByZWFkIFQxLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCA9IGludmFyaWFudFxubGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IHJlYWRfd3JpdGUgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5lbmRcblxubGV0IGlkIHQgPSB0LmlkXG5sZXQgaXNfd2FsbF9jbG9jayB0ID0gdC5pc193YWxsX2Nsb2NrXG5sZXQgbGVuZ3RoIHQgPSBUaW1pbmdfd2hlZWwubGVuZ3RoIHQuZXZlbnRzXG5sZXQgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0ID0gVGltaW5nX3doZWVsLm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdC5ldmVudHNcbmxldCByZWFkX29ubHkgKHQgOiBbPiByZWFkIF0gVDEudCkgPSAodCA6PiB0KVxuXG4oKiBbZmlyZSB0IGV2ZW50XSBzZXRzIFtldmVudC5zdGF0dXMgPSBGaXJlZF0gYW5kIGluc2VydHMgW2V2ZW50XSBpbnRvXG4gICBbdC5maXJlZF9ldmVudHNdIGluIHNvcnRlZCB0aW1lIG9yZGVyLiAqKVxubGV0IGZpcmUgdCAoZXZlbnQgOiBFdmVudC50KSA9XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgRmlyZWQ7XG4gIGV2ZW50LmFsYXJtIDwtIEFsYXJtLm51bGwgKCk7XG4gIGxldCAoKSA9XG4gICAgKCogSWYgW2V2ZW50XSBiZWxvbmdzIGFmdGVyIFt0Lm1vc3RfcmVjZW50bHlfZmlyZWRdLCB0aGVuIHdlIHN0YXJ0IHRoZVxuICAgICAgIGluc2VydGlvbiB0aGVyZSByYXRoZXIgdGhhbiBhdCB0aGUgZnJvbnQgb2YgW3QuZmlyZWRfZXZlbnRzXS4gVGhpcyB3b3Jrc1xuICAgICAgIG5pY2VseSBpZiB3ZSdyZSBnZXR0aW5nIHRoZSBhbGFybXMgaW4gbm9uLWRlY3JlYXNpbmcgdGltZSBvcmRlciwgd2hpY2ggaXNcbiAgICAgICBjbG9zZSB0byB3aGF0IFtUaW1pbmdfd2hlZWxdIHByb3ZpZGVzIChhbHRob3VnaCBbVGltaW5nX3doZWVsXSBkb2Vzbid0XG4gICAgICAgZ3VhcmFudGVlIHRpbWUgb3JkZXJpbmcgZm9yIHRpbWVzIGluIHRoZSBzYW1lIGludGVydmFsKS4gKilcbiAgICBtYXRjaCVvcHRpb25hbCAodC5tb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IFNvbWUgbW9zdF9yZWNlbnRseV9maXJlZCB3aGVuIFRpbWVfbnMuKCA8PSApIG1vc3RfcmVjZW50bHlfZmlyZWQuYXQgZXZlbnQuYXQgLT5cbiAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgbW9zdF9yZWNlbnRseV9maXJlZDtcbiAgICAgIGV2ZW50Lm5leHRfZmlyZWQgPC0gbW9zdF9yZWNlbnRseV9maXJlZC5uZXh0X2ZpcmVkXG4gICAgfCBfIC0+XG4gICAgICBldmVudC5wcmV2X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSB0LmZpcmVkX2V2ZW50c1xuICBpblxuICB0Lm1vc3RfcmVjZW50bHlfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnQ7XG4gICgqIFdlIHVzZSBbVGltZV9ucy4oIDw9ICldIHJhdGhlciB0aGFuIFs8XSBzbyB0aGF0IFtldmVudF0gaXMgYWRkZWQgYWZ0ZXIgb3RoZXJcbiAgICAgZXZlbnRzIGF0IHRoZSBzYW1lIHRpbWUuIFNpbmNlIFtUaW1pbmdfd2hlZWxdIGZpcmVzIGFsYXJtcyBpbiBhIGJ1Y2tldCBpblxuICAgICB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkLCB1c2luZyBbPD1dIGtlZXBzIGV2ZW50cyBhdCB0aGUgc2FtZVxuICAgICB0aW1lIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQuICopXG4gIHdoaWxlXG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBuZXh0IC0+XG4gICAgICBsZXQgY29udGludWUgPSBUaW1lX25zLiggPD0gKSBuZXh0LmF0IGV2ZW50LmF0IGluXG4gICAgICBpZiBjb250aW51ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gZXZlbnQubmV4dF9maXJlZDtcbiAgICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSBuZXh0Lm5leHRfZmlyZWQpO1xuICAgICAgY29udGludWVcbiAgZG9cbiAgICAoKVxuICBkb25lO1xuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5uZXh0X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbmV4dCAtPiBuZXh0LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbiAgaW5cbiAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50LnByZXZfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICB8IE5vbmUgLT4gdC5maXJlZF9ldmVudHMgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbiAgfCBTb21lIHByZXYgLT4gcHJldi5uZXh0X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5zb21lIGV2ZW50XG47O1xuXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIHQuZXZlbnRzXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcblxubGV0IG5leHRfYWxhcm1fcnVuc19hdCB0ID1cbiAgaWYgRXZlbnQuT3B0aW9uLmlzX3NvbWUgdC5maXJlZF9ldmVudHNcbiAgdGhlbiBTb21lICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gIGVsc2UgVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcbjs7XG5cbmxldCBub3cgdCA9IGlmIHQuaXNfd2FsbF9jbG9jayB0aGVuIFRpbWVfbnMubm93ICgpIGVsc2UgdGltaW5nX3doZWVsX25vdyB0XG5sZXQgdGltaW5nX3doZWVsX25vdyA9IHRpbWluZ193aGVlbF9ub3dcblxubGV0IHNjaGVkdWxlIHQgKGV2ZW50IDogRXZlbnQudCkgPVxuICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IFNjaGVkdWxlZDtcbiAgZXZlbnQuYWxhcm0gPC0gVGltaW5nX3doZWVsLmFkZCB0LmV2ZW50cyB+YXQ6ZXZlbnQuYXQgKGV2ZW50IHw+IEpvYl9vcl9ldmVudC5vZl9ldmVudClcbjs7XG5cbmxldCByZW1vdmVfZnJvbV9maXJlZCB0IChldmVudCA6IEV2ZW50LnQpIH5uZXdfc3RhdHVzID1cbiAgbGV0ICgpID1cbiAgICBtYXRjaCVvcHRpb25hbCAodC5tb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbW9zdF9yZWNlbnRseV9maXJlZCAtPlxuICAgICAgaWYgcGh5c19lcXVhbCBldmVudCBtb3N0X3JlY2VudGx5X2ZpcmVkXG4gICAgICB0aGVuXG4gICAgICAgIHQubW9zdF9yZWNlbnRseV9maXJlZCA8LSBFdmVudC5PcHRpb24uZmlyc3Rfc29tZSBldmVudC5uZXh0X2ZpcmVkIGV2ZW50LnByZXZfZmlyZWRcbiAgaW5cbiAgbGV0ICgpID1cbiAgICBtYXRjaCVvcHRpb25hbCAoZXZlbnQucHJldl9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IHQuZmlyZWRfZXZlbnRzIDwtIGV2ZW50Lm5leHRfZmlyZWRcbiAgICB8IFNvbWUgcHJldiAtPiBwcmV2Lm5leHRfZmlyZWQgPC0gZXZlbnQubmV4dF9maXJlZFxuICBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5uZXh0X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbmV4dCAtPiBuZXh0LnByZXZfZmlyZWQgPC0gZXZlbnQucHJldl9maXJlZFxuICBpblxuICBldmVudC5uZXh0X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICBldmVudC5wcmV2X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5ub25lO1xuICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IG5ld19zdGF0dXNcbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBpbmNsdWRlIEV2ZW50XG5cbiAgbGV0IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdCB+aW50ZXJ2YWwgfmNhbGxiYWNrID1cbiAgICB7IGFsYXJtID0gQWxhcm0ubnVsbCAoKVxuICAgIDsgYXRcbiAgICA7IGNhbGxiYWNrXG4gICAgOyBleGVjdXRpb25fY29udGV4dCA9IHQuc2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbiAgICA7IGludGVydmFsXG4gICAgOyBuZXh0X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHByZXZfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgc3RhdHVzID0gVW5zY2hlZHVsZWRcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGFkZCB0IGV2ZW50ID1cbiAgICBpZiBUaW1lX25zLiggPD0gKSBldmVudC5hdCAodGltaW5nX3doZWVsX25vdyB0KVxuICAgIHRoZW4gZmlyZSB0IGV2ZW50XG4gICAgZWxzZSBzY2hlZHVsZSB0IGV2ZW50XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9hbmRfYWRkIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgPVxuICAgIGxldCBldmVudCA9IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdCB+aW50ZXJ2YWwgfmNhbGxiYWNrIGluXG4gICAgYWRkIHQgZXZlbnQ7XG4gICAgZXZlbnRcbiAgOztcblxuICBsZXQgYXQgdCBhdCBjYWxsYmFjayA9IGNyZWF0ZV9hbmRfYWRkIHQgfmF0IH5pbnRlcnZhbDpOb25lIH5jYWxsYmFja1xuXG4gIGxldCBhZnRlciB0IHNwYW4gY2FsbGJhY2sgPVxuICAgIGNyZWF0ZV9hbmRfYWRkIHQgfmF0OihUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhbikgfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG4gIDs7XG5cbiAgbGV0IHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuID1cbiAgICBsZXQgYWxhcm1fcHJlY2lzaW9uID0gYWxhcm1fcHJlY2lzaW9uIHQgaW5cbiAgICBpZiBUaW1lX25zLlNwYW4uKCA8ICkgc3BhbiBhbGFybV9wcmVjaXNpb25cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiaW50ZXJ2YWwgc3BhbiBzbWFsbGVyIHRoYW4gYWxhcm0gcHJlY2lzaW9uXCJcbiAgICAgICAgICAgIChzcGFuIDogVGltZV9ucy5TcGFuLnQpXG4gICAgICAgICAgICAoYWxhcm1fcHJlY2lzaW9uIDogVGltZV9ucy5TcGFuLnQpXVxuICA7O1xuXG4gIGxldCBhdF9pbnRlcnZhbHMgdCBzcGFuIGNhbGxiYWNrID1cbiAgICByZXF1aXJlX3NwYW5fYXRfbGVhc3RfYWxhcm1fcHJlY2lzaW9uIHQgc3BhbjtcbiAgICBjcmVhdGVfYW5kX2FkZCB0IH5hdDoobm93IHQpIH5pbnRlcnZhbDooU29tZSBzcGFuKSB+Y2FsbGJhY2tcbiAgOztcblxuICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgT2tcbiAgICAgIHwgQ3VycmVudGx5X2hhcHBlbmluZ1xuICAgICAgfCBQcmV2aW91c2x5X3Vuc2NoZWR1bGVkXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IGFib3J0IHQgKGV2ZW50IDogdCkgOiBBYm9ydF9yZXN1bHQudCA9XG4gICAgbWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICB8IEhhcHBlbmluZyAtPlxuICAgICAgKG1hdGNoIGV2ZW50LmludGVydmFsIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gQ3VycmVudGx5X2hhcHBlbmluZ1xuICAgICAgIHwgU29tZSAoXyA6IFRpbWVfbnMuU3Bhbi50KSAtPlxuICAgICAgICAgZXZlbnQuaW50ZXJ2YWwgPC0gTm9uZTtcbiAgICAgICAgIE9rKVxuICAgIHwgRmlyZWQgLT5cbiAgICAgIHJlbW92ZV9mcm9tX2ZpcmVkIHQgZXZlbnQgfm5ld19zdGF0dXM6VW5zY2hlZHVsZWQ7XG4gICAgICBPa1xuICAgIHwgU2NoZWR1bGVkIC0+XG4gICAgICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IFVuc2NoZWR1bGVkO1xuICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBldmVudC5hbGFybTtcbiAgICAgIGV2ZW50LmFsYXJtIDwtIEFsYXJtLm51bGwgKCk7XG4gICAgICBPa1xuICAgIHwgVW5zY2hlZHVsZWQgLT4gUHJldmlvdXNseV91bnNjaGVkdWxlZFxuICA7O1xuXG4gIGxldCBhYm9ydF9pZl9wb3NzaWJsZSB0IGV2ZW50ID0gaWdub3JlIChhYm9ydCB0IGV2ZW50IDogQWJvcnRfcmVzdWx0LnQpXG5cbiAgbGV0IGFib3J0X2V4biB0IGV2ZW50ID1cbiAgICBtYXRjaCBhYm9ydCB0IGV2ZW50IHdpdGhcbiAgICB8IE9rIC0+ICgpXG4gICAgfCByZWFzb24gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbU3luY2hyb25vdXNfdGltZV9zb3VyY2UuYWJvcnRfZXhuXSBjYW5ub3QgYWJvcnQgZXZlbnRcIlxuICAgICAgICAgICAgKHJlYXNvbiA6IEFib3J0X3Jlc3VsdC50KV1cbiAgOztcblxuICBsZXQgY3JlYXRlIHQgY2FsbGJhY2sgPSBjcmVhdGVfaW50ZXJuYWwgdCB+YXQ6VGltZV9ucy5lcG9jaCB+aW50ZXJ2YWw6Tm9uZSB+Y2FsbGJhY2tcblxuICBsZXQgc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCAoZXZlbnQgOiB0KSBhdCB+aW50ZXJ2YWwgPVxuICAgICgqIFtGaXJlZF0gaXMgZGlzYWxsb3dlZCB0byBwcmV2ZW50IHRoZSB1c2VyIGZyb20gZW50ZXJpbmcgaW50byBhbiBpbmZpbml0ZSBsb29wLiAgVGhlXG4gICAgICAgdXNlciBjb3VsZCBzcGVjaWZ5IFthdF0gaW4gdGhlIHBhc3Qgd2hpY2ggd291bGQgY29uc3RhbnRseSBhZGQgW2NhbGxiYWNrXSB0byB0aGVcbiAgICAgICBiYWNrIG9mIFt0Lm5leHRfZmlyZWRdIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZyb20gW2NhbGxiYWNrXS4gKilcbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgKEhhcHBlbmluZyB8IFNjaGVkdWxlZCB8IEZpcmVkKSBhcyBzdGF0dXMgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgWyVzZXhwIFwiY2Fubm90IHNjaGVkdWxlIGFuIGV2ZW50IHdpdGggc3RhdHVzXCIsIChzdGF0dXMgOiBFdmVudC5TdGF0dXMudCldXG4gICAgfCBVbnNjaGVkdWxlZCAtPlxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBldmVudC5pbnRlcnZhbCA8LSBpbnRlcnZhbDtcbiAgICAgIGFkZCB0IGV2ZW50O1xuICAgICAgT2sgKClcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYXQgdCBldmVudCBhdCA9IHNjaGVkdWxlX2F0X2ludGVybmFsIHQgZXZlbnQgYXQgfmludGVydmFsOk5vbmVcbiAgbGV0IHNjaGVkdWxlX2FmdGVyIHQgZXZlbnQgc3BhbiA9IHNjaGVkdWxlX2F0IHQgZXZlbnQgKFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuKVxuXG4gIGxldCBzY2hlZHVsZV9hdF9pbnRlcnZhbHMgdCBldmVudCBzcGFuID1cbiAgICByZXF1aXJlX3NwYW5fYXRfbGVhc3RfYWxhcm1fcHJlY2lzaW9uIHQgc3BhbjtcbiAgICBzY2hlZHVsZV9hdF9pbnRlcm5hbCB0IGV2ZW50IChub3cgdCkgfmludGVydmFsOihTb21lIHNwYW4pXG4gIDs7XG5cbiAgbGV0IHJlc2NoZWR1bGVfYXQgdCBldmVudCBhdCA6IHVuaXQgPVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCBGaXJlZCAtPlxuICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpVbnNjaGVkdWxlZDtcbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgYWRkIHQgZXZlbnRcbiAgICB8IEhhcHBlbmluZyAtPlxuICAgICAgKCogSGFwcGVuaW5nIGV2ZW50cyBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gW2ZpcmVkXS4gKilcbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgYWRkIHQgZXZlbnRcbiAgICB8IFNjaGVkdWxlZCAtPlxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBpZiBUaW1lX25zLiggPiApIGF0ICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gICAgICB0aGVuIFRpbWluZ193aGVlbC5yZXNjaGVkdWxlIHQuZXZlbnRzIGV2ZW50LmFsYXJtIH5hdFxuICAgICAgZWxzZSAoXG4gICAgICAgIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgZXZlbnQuYWxhcm07XG4gICAgICAgIGZpcmUgdCBldmVudClcbiAgICB8IFVuc2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGV2ZW50LmludGVydmFsIDwtIE5vbmU7XG4gICAgICBhZGQgdCBldmVudFxuICA7O1xuXG4gIGxldCByZXNjaGVkdWxlX2FmdGVyIHQgZXZlbnQgc3BhbiA9IHJlc2NoZWR1bGVfYXQgdCBldmVudCAoVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW4pXG5cbmVuZFxuXG5sZXQgcnVuX2FmdGVyIHQgc3BhbiBjYWxsYmFjayA9IGlnbm9yZSAoRXZlbnQuYWZ0ZXIgdCBzcGFuIGNhbGxiYWNrIDogRXZlbnQudClcbmxldCBydW5fYXQgdCBhdCBjYWxsYmFjayA9IGlnbm9yZSAoRXZlbnQuYXQgdCBhdCBjYWxsYmFjayA6IEV2ZW50LnQpXG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzIHQgc3BhbiBjYWxsYmFjayA9XG4gIGlnbm9yZSAoRXZlbnQuYXRfaW50ZXJ2YWxzIHQgc3BhbiBjYWxsYmFjayA6IEV2ZW50LnQpXG47O1xuXG50eXBlIHNlbmRfZXhuID0gTW9uaXRvcjAudCAtPiA/YmFja3RyYWNlOlsgYEdldCB8IGBUaGlzIG9mIEJhY2t0cmFjZS50IF0gLT4gZXhuIC0+IHVuaXRcblxubGV0IHJ1bl9maXJlZF9ldmVudHMgdCB+KHNlbmRfZXhuIDogc2VuZF9leG4gb3B0aW9uKSA9XG4gIGxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ID0gdC5zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBpblxuICB3aGlsZVxuICAgIG1hdGNoJW9wdGlvbmFsICh0LmZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGV2ZW50IC0+XG4gICAgICAobWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICAgICB8IEhhcHBlbmluZyB8IFNjaGVkdWxlZCB8IFVuc2NoZWR1bGVkIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgRmlyZWQgLT5cbiAgICAgICAgIHJlbW92ZV9mcm9tX2ZpcmVkIHQgZXZlbnQgfm5ld19zdGF0dXM6SGFwcGVuaW5nO1xuICAgICAgICAgKCogV2Ugc2V0IHRoZSBleGVjdXRpb24gY29udGV4dCBzbyB0aGF0IFtldmVudC5jYWxsYmFja10gcnVucyBpbiB0aGUgc2FtZSBjb250ZXh0XG4gICAgICAgICAgICB0aGF0IHdhcyBpbiBwbGFjZSB3aGVuIFtldmVudF0gd2FzIGNyZWF0ZWQuICopXG4gICAgICAgICBTY2hlZHVsZXIwLnNldF9leGVjdXRpb25fY29udGV4dCB0LnNjaGVkdWxlciBldmVudC5leGVjdXRpb25fY29udGV4dDtcbiAgICAgICAgICgqIEFueSBtb2RpZmljYXRpb24gb2YgW3N0YXR1c10gYmVsb3cgbmVlZHMgdG8gZmlyc3QgY2hlY2sgdGhhdCB0aGUgZXZlbnQgaXNcbiAgICAgICAgICAgIHN0aWxsIFtIYXBwZW5pbmddLiBJZiB0aGUgZXZlbnQgc3RhdHVzIGlzIG5vdCBbSGFwcGVuaW5nXSB0aGVuIHRoZSBldmVudCdzXG4gICAgICAgICAgICBjYWxsYmFjayBtdXN0IGhhdmUgcmVzY2hlZHVsZWQgdGhlIGV2ZW50LiBJbiB0aGF0IGNhc2UsIGRvIG5vdCBzZXQgdGhlIHN0YXR1c1xuICAgICAgICAgICAgb3IgYXR0ZW1wdCB0byByZXNjaGVkdWxlIGEgcmVwZWF0aW5nIGV2ZW50LlxuXG4gICAgICAgICAgICBUaGlzIGNvZGUgY291bGQgYmUgbXVjaCBzaW1wbGVyIGlmIHdlIGltbWVkaWF0ZWx5IHJlc2NoZWR1bGVkIHRoZSBldmVudCBiZWZvcmVcbiAgICAgICAgICAgIHJ1bm5pbmcgdGhlIGNhbGxiYWNrIChubyBuZWVkIGZvciB0aGUgSGFwcGVuaW5nIHN0YXRlIHRoZW4pLiBPbmUgcmVhc29uIHdlXG4gICAgICAgICAgICBkb24ndCBkbyB0aGF0IGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlc2NoZWR1bGUgYSBwZXJpb2RpY1xuICAgICAgICAgICAgZXZlbnQgaWYgaXRzIGNhbGxiYWNrIHJhaXNlcy4gKilcbiAgICAgICAgIChtYXRjaCBldmVudC5jYWxsYmFjayAoKSB3aXRoXG4gICAgICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgICAgICAobWF0Y2ggc2VuZF9leG4gd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiB0LmFkdmFuY2VfZXJyb3JzIDwtIEVycm9yLm9mX2V4biBleG4gOjogdC5hZHZhbmNlX2Vycm9yc1xuICAgICAgICAgICAgIHwgU29tZSBzZW5kX2V4biAtPlxuICAgICAgICAgICAgICAgbGV0IGJhY2t0cmFjZSA9IEJhY2t0cmFjZS5FeG4ubW9zdF9yZWNlbnQgKCkgaW5cbiAgICAgICAgICAgICAgIHNlbmRfZXhuIGV2ZW50LmV4ZWN1dGlvbl9jb250ZXh0Lm1vbml0b3IgZXhuIH5iYWNrdHJhY2U6KGBUaGlzIGJhY2t0cmFjZSkpO1xuICAgICAgICAgICAgRXZlbnQuc2V0X3N0YXR1c19pZiB+aXM6SGFwcGVuaW5nIGV2ZW50IFVuc2NoZWR1bGVkXG4gICAgICAgICAgfCAoKSAtPlxuICAgICAgICAgICAgKG1hdGNoIGV2ZW50LmludGVydmFsIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gRXZlbnQuc2V0X3N0YXR1c19pZiB+aXM6SGFwcGVuaW5nIGV2ZW50IFVuc2NoZWR1bGVkXG4gICAgICAgICAgICAgfCBTb21lIGludGVydmFsIC0+XG4gICAgICAgICAgICAgICBpZiBFdmVudC5TdGF0dXMuZXF1YWwgSGFwcGVuaW5nIGV2ZW50LnN0YXR1c1xuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICgqIFRoZSBldmVudCdzIGNhbGxiYWNrIGRpZCBub3QgcmVzY2hlZHVsZSB0aGUgZXZlbnQuIFNvIHJlc2NoZWR1bGUgdGhlXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdGluZyB0aW1lciBiYXNlZCBvbiB0aGUgbGFzdCBbYXRdIHRpbWUuICopXG4gICAgICAgICAgICAgICAgIGV2ZW50LmF0XG4gICAgICAgICAgICAgICAgIDwtIFRpbWVfbnMubmV4dF9tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICAgICAgICAgfmJhc2U6ZXZlbnQuYXRcbiAgICAgICAgICAgICAgICAgICAgICB+YWZ0ZXI6KHRpbWluZ193aGVlbF9ub3cgdClcbiAgICAgICAgICAgICAgICAgICAgICB+aW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgIHNjaGVkdWxlIHQgZXZlbnQpKSk7XG4gICAgICAgICB0cnVlKVxuICBkb1xuICAgICgpXG4gIGRvbmU7XG4gIFNjaGVkdWxlcjAuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQuc2NoZWR1bGVyIGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbjs7XG5cbmxldCBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+c2VuZF9leG4gPVxuICBUaW1pbmdfd2hlZWwuYWR2YW5jZV9jbG9jayB0LmV2ZW50cyB+dG9fIH5oYW5kbGVfZmlyZWQ6dC5oYW5kbGVfZmlyZWQ7XG4gIHJ1bl9maXJlZF9ldmVudHMgdCB+c2VuZF9leG5cbjs7XG5cbmxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuID1cbiAgVGltaW5nX3doZWVsLmZpcmVfcGFzdF9hbGFybXMgdC5ldmVudHMgfmhhbmRsZV9maXJlZDp0LmhhbmRsZV9maXJlZDtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4biA9XG4gIGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmlyZV9wYXN0X2FsYXJtcyB0IH5zZW5kX2V4blxuOztcblxubGV0IHByZXBhcmVfdG9fYWR2YW5jZSB0IH5zZW5kX2V4biA9XG4gIGlmIHQuYW1fYWR2YW5jaW5nXG4gIHRoZW5cbiAgICByYWlzZV9zIFslc2V4cCBcImNhbm5vdCBjYWxsIFthZHZhbmNlX2J5X2FsYXJtc10gb3IgW2FkdmFuY2VfZGlyZWN0bHldIGZyb20gY2FsbGJhY2tcIl07XG4gIHQuYW1fYWR2YW5jaW5nIDwtIHRydWU7XG4gIChtYXRjaCB0LmFkdmFuY2VfZXJyb3JzIHdpdGhcbiAgIHwgW10gLT4gKClcbiAgIHwgXyAtPiB0LmFkdmFuY2VfZXJyb3JzIDwtIFtdKTtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGZpbmlzaF9hZHZhbmNpbmcgdCA9XG4gIHQuYW1fYWR2YW5jaW5nIDwtIGZhbHNlO1xuICBtYXRjaCB0LmFkdmFuY2VfZXJyb3JzIHdpdGhcbiAgfCBbXSAtPiBPayAoKVxuICB8IGVycm9ycyAtPlxuICAgIHQuYWR2YW5jZV9lcnJvcnMgPC0gW107XG4gICAgRXJyb3IgKEVycm9yLm9mX2xpc3QgZXJyb3JzKVxuOztcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zIHQgfnRvXyA9XG4gIGxldCBzZW5kX2V4biA9IE5vbmUgaW5cbiAgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuO1xuICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhY29udGludWUgZG9cbiAgICBpZiBUaW1pbmdfd2hlZWwuaXNfZW1wdHkgdC5ldmVudHNcbiAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbWluX2FsYXJtX3RpbWUgPSBUaW1pbmdfd2hlZWwubWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0LmV2ZW50cyBpblxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbWluX2FsYXJtX3RpbWUgdG9fXG4gICAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgICBlbHNlXG4gICAgICAgICgqIFdlIHVzZSB0aGUgYWN0dWFsIGFsYXJtIHRpbWUsIHJhdGhlciB0aGFuIFtuZXh0X2FsYXJtX2ZpcmVzX2F0XSwgc28gYXMgbm90IHRvXG4gICAgICAgICAgIGV4cG9zZSAob3IgYWNjdW11bGF0ZSBlcnJvcnMgYXNzb2NpYXRlZCB3aXRoKSB0aGUgcHJlY2lzaW9uIG9mXG4gICAgICAgICAgIFtUaW1pbmdfd2hlZWxdLiAqKVxuICAgICAgICBhZHZhbmNlX2ludGVybmFsIHQgfnRvXzptaW5fYWxhcm1fdGltZSB+c2VuZF9leG4pXG4gIGRvbmU7XG4gIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfdGltaW5nX3doZWVsX2ludGVydmFsIHQgfnRvXyA9XG4gIGxldCBzZW5kX2V4biA9IE5vbmUgaW5cbiAgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuO1xuICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhY29udGludWUgZG9cbiAgICBpZiBUaW1pbmdfd2hlZWwuaXNfZW1wdHkgdC5ldmVudHNcbiAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dF9hbGFybV9maXJlc19hdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB0LmV2ZW50cyBpblxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbmV4dF9hbGFybV9maXJlc19hdCB0b19cbiAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgIGVsc2VcbiAgICAgICAgKCogV2UgdXNlIHRoZSBhY3R1YWwgYWxhcm0gdGltZSwgcmF0aGVyIHRoYW4gW25leHRfYWxhcm1fZmlyZXNfYXRdLCBzbyBhcyBub3QgdG9cbiAgICAgICAgICAgZXhwb3NlIChvciBhY2N1bXVsYXRlIGVycm9ycyBhc3NvY2lhdGVkIHdpdGgpIHRoZSBwcmVjaXNpb24gb2ZcbiAgICAgICAgICAgW1RpbWluZ193aGVlbF0uICopXG4gICAgICAgIGFkdmFuY2VfaW50ZXJuYWxcbiAgICAgICAgICB0XG4gICAgICAgICAgfnRvXzooVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdC5ldmVudHMpXG4gICAgICAgICAgfnNlbmRfZXhuKVxuICBkb25lO1xuICBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyB+c2VuZF9leG47XG4gIGZpbmlzaF9hZHZhbmNpbmcgdFxuOztcblxubGV0IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgZHVyYXRpb25fb2YgdCBmID1cbiAgbGV0IHN0YXJ0ID0gbm93IHQgaW5cbiAgbGV0IHJlc3VsdCA9IGYgKCkgaW5cbiAgbGV0IGR1cmF0aW9uID0gVGltZV9ucy5kaWZmIChub3cgdCkgc3RhcnQgaW5cbiAgcmVzdWx0LCBkdXJhdGlvblxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl90aW1pbmdfd2hlZWxfaW50ZXJ2YWwgdCA9XG4gIFRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgdC5ldmVudHNcbjs7XG5cbmxldCBoYXNfZXZlbnRzX3RvX3J1biB0ID0gRXZlbnQuT3B0aW9uLmlzX3NvbWUgdC5maXJlZF9ldmVudHNcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbmluY2x1ZGUgU2NoZWR1bGVyMFxubW9kdWxlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwXG5tb2R1bGUgRXZlbnQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5FdmVudFxubW9kdWxlIEFsYXJtID0gVGltaW5nX3doZWVsLkFsYXJtXG5tb2R1bGUgSm9iX29yX2V2ZW50ID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEuSm9iX29yX2V2ZW50XG5cbmxldCBkZWJ1ZyA9IERlYnVnLnNjaGVkdWxlclxuXG5tb2R1bGUgSXZhciA9IHN0cnVjdFxuICBvcGVuIFR5cGVzLkl2YXJcblxuICBsZXQgY3JlYXRlX3dpdGhfY2VsbCBjZWxsID0geyBjZWxsIH1cbiAgbGV0IGNyZWF0ZSAoKSA9IGNyZWF0ZV93aXRoX2NlbGwgRW1wdHlcblxuICBsZXQgY3JlYXRlX2Z1bGwgKHR5cGUgYSkgKGEgOiBhKSA9XG4gICAgKCogV2UgYWxsb2NhdGUgYW4gaW1tdXRhYmxlIGl2YXIgYW5kIHRoZW4gY2FzdCBpdCB0byBhIG11dGFibGUgaXZhci4gIFRoZSBpbW11dGFiaWxpdHlcbiAgICAgICBhbGxvd3MgT0NhbWwgdG8gc3RhdGljYWxseSBhbGxvY2F0ZSB0aGUgaXZhciBpZiBbYV0gaXMgY29uc3RhbnQuICBUaGlzIGNhc3QgaXMgc2FmZVxuICAgICAgIGJlY2F1c2UgYSBmdWxsIGl2YXIgaXMgbmV2ZXIgbXV0YXRlZC4gIFdlIGFsc28gYmVsaWV2ZSB0aGF0IHdlIHdpbGwgbm90IHRyaWdnZXJcbiAgICAgICBmbGFtYmRhIHRvIHNwdXJpb3VzbHkgcmVwb3Igd2FybmluZyA1OSwgbXV0YXRpb24gb2Yga25vd24gaW1tdXRhYmxlIGRhdGEuICBBbGxcbiAgICAgICBtdXRhdGlvbnMgb2YgYW4gaXZhciBjZWxsLCBpLmUuIFtmb28uY2VsbCA8LSAuLi5dLCBhcmUgZGlyZWN0bHkgcHJlY2VkZWQgYnkgYVxuICAgICAgIFttYXRjaCBmb28uY2VsbF0gdGhhdCBwcmV2ZW50cyB0aGUgW0Z1bGxdIGNhc2UgZnJvbSByZWFjaGluZyB0aGUgbW9kaWZpY2F0aW9uLiAgU29cbiAgICAgICBmbGFtYmRhIHNob3VsZCBhbHdheXMgZWxpbWluYXRlIHRoZSBbZm9vLmNlbGwgPC0gLi4uXSBvZiBhIGNvbnN0YW50IFtGdWxsXSBpdmFyLFxuICAgICAgIGFuZCBub3Qgd2Fybi4gKilcbiAgICAoT2JqLm1hZ2ljIDogYSBJbW11dGFibGUudCAtPiBhIHQpIHsgY2VsbCA9IEZ1bGwgYSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIEJ2YXIgPSBzdHJ1Y3RcbiAgb3BlbiBUeXBlcy5CdmFyXG5cbiAgbGV0IGNyZWF0ZSAoKSA9IG9mX3JlcHIgeyBoYXNfYW55X3dhaXRlcnMgPSBmYWxzZTsgaXZhciA9IEl2YXIuY3JlYXRlICgpIH1cbmVuZFxuXG5tb2R1bGUgVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyID0gc3RydWN0XG4gIG1vZHVsZSBFeGVjX3Jlc3VsdCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFR5cGVzLlZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci5FeGVjX3Jlc3VsdC50ID1cbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgTm90X2ZpbmlzaGVkXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgdHlwZSB0ID0gVHlwZXMuVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLnQgPVxuICAgIHsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBleGVjIDogdW5pdCAtPiBFeGVjX3Jlc3VsdC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXIgfmV4ZWN1dGlvbl9jb250ZXh0OihjaGVjayBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQpIH5leGVjOmlnbm9yZSlcbiAgOztcbmVuZFxuXG50eXBlIHQgPSBTY2hlZHVsZXIwLnQgPVxuICB7ICgqIFtjaGVja19hY2Nlc3NdIG9wdGlvbmFsbHkgaG9sZHMgYSBmdW5jdGlvbiB0byBydW4gdG8gY2hlY2sgd2hldGhlciBhY2Nlc3MgdG8gW3RdIGlzXG4gICAgICAgY3VycmVudGx5IGFsbG93ZWQuICBJdCBpcyB1c2VkIHRvIGRldGVjdCBpbnZhbGlkIGFjY2VzcyB0byB0aGUgc2NoZWR1bGVyIGZyb20gYVxuICAgICAgIHRocmVhZC4gKilcbiAgICBtdXRhYmxlIGNoZWNrX2FjY2VzcyA6ICh1bml0IC0+IHVuaXQpIG9wdGlvblxuICA7IG11dGFibGUgam9iX3Bvb2wgOiBKb2JfcG9vbC50XG4gIDsgbm9ybWFsX3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICA7IGxvd19wcmlvcml0eV9qb2JzIDogSm9iX3F1ZXVlLnRcbiAgOyB2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIDogVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLnQgRGVxdWUudFxuICA7IG11dGFibGUgbWFpbl9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgOyBtdXRhYmxlIGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICgqIFRoZSBzY2hlZHVsZXIgY2FsbHMgW2dvdF91bmNhdWdodF9leG5dIHdoZW4gYW4gZXhjZXB0aW9uIGJ1YmJsZXMgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICAgbW9uaXRvciB0cmVlIHdpdGhvdXQgYmVpbmcgaGFuZGxlZC4gIFRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0byBuZXZlciBydW4gYW5vdGhlclxuICAgICBqb2IgYWZ0ZXIgdGhpcyBieSBjYWxsaW5nIFtjbGVhcl0gYW5kIGJlY2F1c2UgW2VucXVldWVfam9iXSB3aWxsIG5ldmVyIGFkZCBhbm90aGVyXG4gICAgIGpvYi4gKilcbiAgOyBtdXRhYmxlIHVuY2F1Z2h0X2V4biA6IChFeG4udCAqIFNleHAudCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBjeWNsZV9jb3VudCA6IGludFxuICA7IG11dGFibGUgY3ljbGVfc3RhcnQgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIGluX2N5Y2xlIDogYm9vbFxuICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDogKFR5cGVzLkN5Y2xlX2hvb2sudFtAc2V4cC5vcGFxdWVdKSBsaXN0XG4gIDsgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIDpcbiAgICAgIChUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS50LCAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pKSBIYXNodGJsLnRcbiAgOyBtdXRhYmxlIHJ1bl9ldmVyeV9jeWNsZV9lbmQgOiAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pIGxpc3RcbiAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIDpcbiAgICAgIChUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS50LCAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pKSBIYXNodGJsLnRcbiAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gIDsgbXV0YWJsZSBsYXN0X2N5Y2xlX251bV9qb2JzIDogaW50XG4gIDsgbXV0YWJsZSB0b3RhbF9jeWNsZV90aW1lIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIHRpbWVfc291cmNlIDogcmVhZF93cml0ZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50XG4gICgqIFtleHRlcm5hbF9qb2JzXSBpcyBhIHF1ZXVlIG9mIGFjdGlvbnMgc2VudCBmcm9tIG91dHNpZGUgb2YgYXN5bmMuICBUaGlzIGlzIGZvciB0aGVcbiAgICAgY2FzZSB3aGVyZSB3ZSB3YW50IHRvIHNjaGVkdWxlIGEgam9iIG9yIGZpbGwgYW4gaXZhciBmcm9tIGEgY29udGV4dCB3aGVyZSBpdCBpcyBub3RcbiAgICAgc2FmZSB0byBydW4gYXN5bmMgY29kZSwgYmVjYXVzZSB0aGUgYXN5bmMgbG9jayBpc24ndCBoZWxkLiAgRm9yIGluc3RhbmNlOiAtIGluIGFuXG4gICAgIE9DYW1sIGZpbmFsaXplciwgYXMgdGhleSBjYW4gcnVuIGF0IGFueSB0aW1lIGluIGFueSB0aHJlYWQuXG5cbiAgICAgVGhlIHdheSB0byBkbyBpdCBpcyB0byBxdWV1ZSBhIHRodW5rIGluIFtleHRlcm5hbF9qb2JzXSBhbmQgY2FsbFxuICAgICBbdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2tdLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3Igbm90aWZ5aW5nIHRoZSBzY2hlZHVsZXJcbiAgICAgdGhhdCBuZXcgYWN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuXG4gICAgIFdoZW4gdXNpbmcgQXN5bmMgb24gdW5peCwgW3RocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXSBpcyBzZXQgaW4gW0FzeW5jX3VuaXhdXG4gICAgIHRvIGNhbGwgW0ludGVycnVwdG9yLnRocmVhZF9zYWZlX2ludGVycnVwdF0sIHdoaWNoIHdpbGwgd2FrZSB1cCB0aGVcbiAgICAgW0FzeW5jX3VuaXhdIHNjaGVkdWxlciBhbmQgcnVuIGEgY3ljbGUuXG5cbiAgICAgTm90ZSB0aGF0IHRoaXMgaG9vayBtaWdodCBiZSB1c2VkIGluIG90aGVyIGNvbnRleHQgKGpzX29mX29jYW1sLCBtaXJhZ2UpLlxuXG4gICAgIFdoZW4gcnVubmluZyBhIGN5Y2xlLCB3ZSBwdWxsIGV4dGVybmFsIGFjdGlvbnMgYXQgZXZlcnkgam9iIGFuZCBwZXJmb3JtIHRoZW1cbiAgICAgaW1tZWRpYXRlbHkuICopXG4gIDsgZXh0ZXJuYWxfam9icyA6IEV4dGVybmFsX2pvYi50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgOyBtdXRhYmxlIHRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDogdW5pdCAtPiB1bml0XG4gICgqIFtqb2JfcXVldWVkX2hvb2tdIGFuZCBbZXZlbnRfYWRkZWRfaG9va10gYWltIHRvIGJlIHVzZWQgYnkganNfb2Zfb2NhbWwuICopXG4gICgqIFdlIHVzZSBbXyBvcHRpb25dIGhlcmUgYmVjYXVzZSB0aG9zZSBob29rcyB3aWxsIG5vdCBiZSBzZXQgaW4gdGhlIGNvbW1vbiBjYXNlXG4gICAgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLiAqKVxuICA7IG11dGFibGUgam9iX3F1ZXVlZF9ob29rIDogKFByaW9yaXR5LnQgLT4gdW5pdCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBldmVudF9hZGRlZF9ob29rIDogKFRpbWVfbnMudCAtPiB1bml0KSBvcHRpb25cbiAgOyBtdXRhYmxlIHlpZWxkIDogKCh1bml0LCByZWFkX3dyaXRlKSBUeXBlcy5CdmFyLnRbQHNleHAub3BhcXVlXSlcbiAgOyBtdXRhYmxlIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIDpcbiAgICAgICgodW5pdCwgcmVhZF93cml0ZSkgVHlwZXMuQnZhci50W0BzZXhwLm9wYXF1ZV0gKCogY29uZmlndXJhdGlvbiopKVxuICA7IG11dGFibGUgY2hlY2tfaW52YXJpYW50cyA6IGJvb2xcbiAgOyBtdXRhYmxlIG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIDogTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUudFxuICA7IG11dGFibGUgcmVjb3JkX2JhY2t0cmFjZXMgOiBib29sXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IHVuY2F1Z2h0X2V4bl91bndyYXBwZWQgPSB1bmNhdWdodF9leG5cblxubGV0IHVuY2F1Z2h0X2V4biB0ID1cbiAgbWF0Y2ggdC51bmNhdWdodF9leG4gd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGV4biwgc2V4cCkgLT5cbiAgICBTb21lIChFcnJvci5jcmVhdGUgXCJ1bmhhbmRsZWQgZXhjZXB0aW9uXCIgKGV4biwgc2V4cCkgWyVzZXhwX29mOiBFeG4udCAqIFNleHAudF0pXG47O1xuXG5sZXQgbnVtX3BlbmRpbmdfam9icyB0ID1cbiAgSm9iX3F1ZXVlLmxlbmd0aCB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzICsgSm9iX3F1ZXVlLmxlbmd0aCB0Lmxvd19wcmlvcml0eV9qb2JzXG47O1xuXG5sZXQgbnVtX2pvYnNfcnVuIHQgPVxuICBKb2JfcXVldWUubnVtX2pvYnNfcnVuIHQubm9ybWFsX3ByaW9yaXR5X2pvYnNcbiAgKyBKb2JfcXVldWUubnVtX2pvYnNfcnVuIHQubG93X3ByaW9yaXR5X2pvYnNcbjs7XG5cbmxldCBsYXN0X2N5Y2xlX251bV9qb2JzIHQgPSB0Lmxhc3RfY3ljbGVfbnVtX2pvYnNcblxubGV0IHVub3JkZXJlZF9pc19zdWJsaXN0IH5lcXVhbCB+c3VibGlzdDpzbWFsbCBsYXJnZSA9XG4gIGxldCByZW1vdmUgbCB4ID1cbiAgICBtYXRjaCBMaXN0LnNwbGl0X3doaWxlIGwgfmY6KGZ1biB5IC0+IG5vdCAoZXF1YWwgeSB4KSkgd2l0aFxuICAgIHwgXywgW10gLT4gTm9uZVxuICAgIHwgbCwgXyA6OiByIC0+IFNvbWUgKGwgQCByKVxuICBpblxuICBPcHRpb24uaXNfc29tZVxuICAgIChMaXN0LmZvbGQgc21hbGwgfmluaXQ6KFNvbWUgbGFyZ2UpIH5mOihmdW4gYWNjIHggLT5cbiAgICAgICBPcHRpb24uYmluZCBhY2MgfmY6KGZ1biBsIC0+IHJlbW92ZSBsIHgpKSlcbjs7XG5cbmxldCBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCB0YWJsZSBsaXN0ID1cbiAgKCogWW91IGNhbiBpbiBmYWN0IGhhdmUgaG9va3MgaW4gdGhlIGxpc3QgZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgZW50cnkgaW5cbiAgICAgdGhlIHRhYmxlLiBTdWNoIGhvb2tzIGNhbiBuZXZlciBiZSByZW1vdmVkLiAqKVxuICBhc3NlcnQgKHVub3JkZXJlZF9pc19zdWJsaXN0IH5lcXVhbDpwaHlzX2VxdWFsIH5zdWJsaXN0OihIYXNodGJsLmRhdGEgdGFibGUpIGxpc3QpXG47O1xuXG5sZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgdHJ5XG4gICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmNoZWNrX2FjY2VzczppZ25vcmVcbiAgICAgIH5qb2JfcG9vbDooY2hlY2sgSm9iX3Bvb2wuaW52YXJpYW50KVxuICAgICAgfm5vcm1hbF9wcmlvcml0eV9qb2JzOihjaGVjayBKb2JfcXVldWUuaW52YXJpYW50KVxuICAgICAgfmxvd19wcmlvcml0eV9qb2JzOihjaGVjayBKb2JfcXVldWUuaW52YXJpYW50KVxuICAgICAgfnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnM6XG4gICAgICAgIChjaGVjayAoZnVuIHEgLT4gRGVxdWUuaXRlciBxIH5mOlZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci5pbnZhcmlhbnQpKVxuICAgICAgfm1haW5fZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudClcbiAgICAgIH5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0OihjaGVjayBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQpXG4gICAgICB+dW5jYXVnaHRfZXhuOlxuICAgICAgICAoY2hlY2sgKGZ1biB1bmNhdWdodF9leG4gLT5cbiAgICAgICAgICAgaWYgaXNfc29tZSB1bmNhdWdodF9leG4gdGhlbiBhc3NlcnQgKG51bV9wZW5kaW5nX2pvYnMgdCA9IDApKSlcbiAgICAgIH5jeWNsZV9jb3VudDooY2hlY2sgKGZ1biBjeWNsZV9jb3VudCAtPiBhc3NlcnQgKGN5Y2xlX2NvdW50ID49IDApKSlcbiAgICAgIH5jeWNsZV9zdGFydDppZ25vcmVcbiAgICAgIH5pbl9jeWNsZTppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfc3RhcnQ6aWdub3JlXG4gICAgICB+cnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlOlxuICAgICAgICAoY2hlY2sgKGZ1biBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgLT5cbiAgICAgICAgICAgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnRcbiAgICAgICAgICAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVcbiAgICAgICAgICAgICB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCkpXG4gICAgICB+cnVuX2V2ZXJ5X2N5Y2xlX2VuZDppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlOlxuICAgICAgICAoY2hlY2sgKGZ1biBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIC0+XG4gICAgICAgICAgIGNoZWNrX2hvb2tfdGFibGVfaW52YXJpYW50IHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgdC5ydW5fZXZlcnlfY3ljbGVfZW5kKSlcbiAgICAgIH5sYXN0X2N5Y2xlX3RpbWU6aWdub3JlXG4gICAgICB+dG90YWxfY3ljbGVfdGltZTppZ25vcmVcbiAgICAgIH5sYXN0X2N5Y2xlX251bV9qb2JzOlxuICAgICAgICAoY2hlY2sgKGZ1biBsYXN0X2N5Y2xlX251bV9qb2JzIC0+IGFzc2VydCAobGFzdF9jeWNsZV9udW1fam9icyA+PSAwKSkpXG4gICAgICB+dGltZV9zb3VyY2U6XG4gICAgICAgIChjaGVja1xuICAgICAgICAgICAoU3luY2hyb25vdXNfdGltZV9zb3VyY2UuUmVhZF93cml0ZS5pbnZhcmlhbnRfd2l0aF9qb2JzIH5qb2I6KGZ1biBqb2IgLT5cbiAgICAgICAgICAgICAgYXNzZXJ0IChQb29sLnBvaW50ZXJfaXNfdmFsaWQgdC5qb2JfcG9vbCBqb2IpKSkpXG4gICAgICB+ZXh0ZXJuYWxfam9iczppZ25vcmVcbiAgICAgIH50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vazppZ25vcmVcbiAgICAgIH5qb2JfcXVldWVkX2hvb2s6aWdub3JlXG4gICAgICB+ZXZlbnRfYWRkZWRfaG9vazppZ25vcmVcbiAgICAgIH55aWVsZDppZ25vcmVcbiAgICAgIH55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbjppZ25vcmVcbiAgICAgIH5jaGVja19pbnZhcmlhbnRzOmlnbm9yZVxuICAgICAgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlOmlnbm9yZVxuICAgICAgfnJlY29yZF9iYWNrdHJhY2VzOmlnbm9yZVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiU2NoZWR1bGVyLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSAodCA6IHQpXVxuOztcblxubGV0IGZyZWVfam9iIHQgam9iID0gUG9vbC5mcmVlIHQuam9iX3Bvb2wgam9iXG5cbmxldCBlbnF1ZXVlIHQgKGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudCkgZiBhID1cbiAgKCogSWYgdGhlcmUncyBiZWVuIGFuIHVuY2F1Z2h0IGV4biwgd2UgZG9uJ3QgYWRkIHRoZSBqb2IsIHNpbmNlIHdlIGRvbid0IHdhbnQgYW55IGpvYnNcbiAgICAgdG8gcnVuIG9uY2UgdGhlcmUncyBiZWVuIGFuIHVuY2F1Z2h0IGV4bi4gKilcbiAgaWYgaXNfbm9uZSB0LnVuY2F1Z2h0X2V4blxuICB0aGVuIChcbiAgICBsZXQgcHJpb3JpdHkgPSBleGVjdXRpb25fY29udGV4dC5wcmlvcml0eSBpblxuICAgIGxldCBqb2JfcXVldWUgPVxuICAgICAgbWF0Y2ggcHJpb3JpdHkgd2l0aFxuICAgICAgfCBOb3JtYWwgLT4gdC5ub3JtYWxfcHJpb3JpdHlfam9ic1xuICAgICAgfCBMb3cgLT4gdC5sb3dfcHJpb3JpdHlfam9ic1xuICAgIGluXG4gICAgSm9iX3F1ZXVlLmVucXVldWUgam9iX3F1ZXVlIGV4ZWN1dGlvbl9jb250ZXh0IGYgYTtcbiAgICBtYXRjaCB0LmpvYl9xdWV1ZWRfaG9vayB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGYgLT4gZiBwcmlvcml0eSlcbjs7XG5cbmxldCBlbnF1ZXVlX2pvYiB0IGpvYiB+ZnJlZV9qb2IgPVxuICBsZXQgam9iX3Bvb2wgPSB0LmpvYl9wb29sIGluXG4gIGVucXVldWVcbiAgICB0XG4gICAgKFBvb2wuZ2V0IGpvYl9wb29sIGpvYiBQb29sLlNsb3QudDApXG4gICAgKFBvb2wuZ2V0IGpvYl9wb29sIGpvYiBQb29sLlNsb3QudDEpXG4gICAgKFBvb2wuZ2V0IGpvYl9wb29sIGpvYiBQb29sLlNsb3QudDIpO1xuICBpZiBmcmVlX2pvYiB0aGVuIFBvb2wuZnJlZSB0LmpvYl9wb29sIGpvYlxuOztcblxubGV0IGhhbmRsZV9maXJlZCAodGltZV9zb3VyY2UgOiBfIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnQpIGpvYl9vcl9ldmVudCA9XG4gIGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICBsZXQgKEsgaykgPSBraW5kIGpvYl9vcl9ldmVudCBpblxuICBtYXRjaCBrLCBwcm9qZWN0IGsgam9iX29yX2V2ZW50IHdpdGhcbiAgfCBKb2IsIGpvYiAtPiBlbnF1ZXVlX2pvYiB0aW1lX3NvdXJjZS5zY2hlZHVsZXIgam9iIH5mcmVlX2pvYjp0cnVlXG4gIHwgRXZlbnQsIGV2ZW50IC0+IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLmZpcmUgdGltZV9zb3VyY2UgZXZlbnRcbjs7XG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgbm93ID0gVGltZV9ucy5ub3cgKCkgaW5cbiAgbGV0IHJlYyB0ID1cbiAgICB7IGNoZWNrX2FjY2VzcyA9IE5vbmVcbiAgICA7IGpvYl9wb29sID0gSm9iX3Bvb2wuY3JlYXRlICgpXG4gICAgOyBub3JtYWxfcHJpb3JpdHlfam9icyA9IEpvYl9xdWV1ZS5jcmVhdGUgKClcbiAgICA7IGxvd19wcmlvcml0eV9qb2JzID0gSm9iX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgdmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyA9IERlcXVlLmNyZWF0ZSAoKVxuICAgIDsgbWFpbl9leGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbiAgICA7IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG4gICAgOyB1bmNhdWdodF9leG4gPSBOb25lXG4gICAgOyBjeWNsZV9zdGFydCA9IG5vd1xuICAgIDsgY3ljbGVfY291bnQgPSAwXG4gICAgOyBpbl9jeWNsZSA9IGZhbHNlXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnQgPSBbXVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZSlcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9lbmQgPSBbXVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUpXG4gICAgOyBsYXN0X2N5Y2xlX3RpbWUgPSBzZWMgMC5cbiAgICA7IGxhc3RfY3ljbGVfbnVtX2pvYnMgPSAwXG4gICAgOyB0b3RhbF9jeWNsZV90aW1lID0gc2VjIDAuXG4gICAgOyB0aW1lX3NvdXJjZVxuICAgIDsgZXh0ZXJuYWxfam9icyA9IFRocmVhZF9zYWZlX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgPSBpZ25vcmVcbiAgICA7IGpvYl9xdWV1ZWRfaG9vayA9IE5vbmVcbiAgICA7IGV2ZW50X2FkZGVkX2hvb2sgPSBOb25lXG4gICAgOyB5aWVsZCA9IEJ2YXIuY3JlYXRlICgpXG4gICAgOyB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA9IEJ2YXIuY3JlYXRlICgpICgqIGNvbmZpZ3VyYXRpb24gKilcbiAgICA7IGNoZWNrX2ludmFyaWFudHMgPSBBc3luY19rZXJuZWxfY29uZmlnLmNoZWNrX2ludmFyaWFudHNcbiAgICA7IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlID1cbiAgICAgICAgQXN5bmNfa2VybmVsX2NvbmZpZy5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuICAgIDsgcmVjb3JkX2JhY2t0cmFjZXMgPSBBc3luY19rZXJuZWxfY29uZmlnLnJlY29yZF9iYWNrdHJhY2VzXG4gICAgfVxuICBhbmQgZXZlbnRzID1cbiAgICBUaW1pbmdfd2hlZWwuY3JlYXRlIH5jb25maWc6QXN5bmNfa2VybmVsX2NvbmZpZy50aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydDpub3dcbiAgYW5kIHRpbWVfc291cmNlIDogXyBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50ID1cbiAgICB7IGlkID0gVHlwZXMuVGltZV9zb3VyY2VfaWQuY3JlYXRlICgpXG4gICAgOyBhZHZhbmNlX2Vycm9ycyA9IFtdXG4gICAgOyBhbV9hZHZhbmNpbmcgPSBmYWxzZVxuICAgIDsgZXZlbnRzXG4gICAgOyBoYW5kbGVfZmlyZWQgPSAoZnVuIGFsYXJtIC0+IGhhbmRsZV9maXJlZCB0aW1lX3NvdXJjZSAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSlcbiAgICA7IGZpcmVkX2V2ZW50cyA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBpc193YWxsX2Nsb2NrID0gdHJ1ZVxuICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzY2hlZHVsZXIgPSB0XG4gICAgfVxuICBpblxuICB0XG47O1xuXG5sZXQgaXNfZGVhZCB0ID0gaXNfc29tZSB0LnVuY2F1Z2h0X2V4blxubGV0IHNldF9jaGVja19hY2Nlc3MgdCBmID0gdC5jaGVja19hY2Nlc3MgPC0gZlxuXG5sZXQgdF9yZWYgPVxuICBtYXRjaCBSZXN1bHQudHJ5X3dpdGggY3JlYXRlIHdpdGhcbiAgfCBPayB0IC0+IHJlZiB0XG4gIHwgRXJyb3IgZXhuIC0+XG4gICAgRGVidWcubG9nIFwiQXN5bmMgY2Fubm90IGNyZWF0ZSBpdHMgcmF3IHNjaGVkdWxlclwiIGV4biBbJXNleHBfb2Y6IGV4bl07XG4gICAgZXhpdCAxXG47O1xuXG5sZXQgY2hlY2tfYWNjZXNzIHQgPVxuICBtYXRjaCB0LmNoZWNrX2FjY2VzcyB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmICgpXG47O1xuXG5sZXQgdCAoKSA9XG4gIGxldCB0ID0gIXRfcmVmIGluXG4gIGNoZWNrX2FjY2VzcyB0O1xuICB0XG47O1xuXG5sZXQgY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0ID1cbiAgaWYgdC5yZWNvcmRfYmFja3RyYWNlc1xuICB0aGVuIEV4ZWN1dGlvbl9jb250ZXh0LnJlY29yZF9iYWNrdHJhY2UgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG4gIGVsc2UgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG47O1xuXG5sZXQgd2l0aF9leGVjdXRpb25fY29udGV4dDEgdCB0bXBfY29udGV4dCB+ZiB4ID1cbiAgbGV0IG9sZF9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIHNldF9leGVjdXRpb25fY29udGV4dCB0IHRtcF9jb250ZXh0O1xuICBwcm90ZWN0eCB+ZiB4IH5maW5hbGx5OihmdW4gXyAtPiBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCBvbGRfY29udGV4dClcbjs7XG5cbmxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IHQgdG1wX2NvbnRleHQgfmYgPSB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSB0IHRtcF9jb250ZXh0IH5mICgpXG5cbmxldCBjcmVhdGVfam9iICh0eXBlIGEpIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgaWYgUG9vbC5pc19mdWxsIHQuam9iX3Bvb2wgdGhlbiB0LmpvYl9wb29sIDwtIFBvb2wuZ3JvdyB0LmpvYl9wb29sO1xuICBQb29sLm5ldzNcbiAgICB0LmpvYl9wb29sXG4gICAgZXhlY3V0aW9uX2NvbnRleHRcbiAgICAoT2JqLm1hZ2ljIChmIDogYSAtPiB1bml0KSA6IE9iai50IC0+IHVuaXQpXG4gICAgKE9iai5yZXByIChhIDogYSkpXG47O1xuXG5sZXQgZ290X3VuY2F1Z2h0X2V4biB0IGV4biBzZXhwID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJnb3RfdW5jYXVnaHRfZXhuXCIgKGV4biwgc2V4cCkgWyVzZXhwX29mOiBFeG4udCAqIFNleHAudF07XG4gIExpc3QuaXRlciBbIHQubm9ybWFsX3ByaW9yaXR5X2pvYnM7IHQubG93X3ByaW9yaXR5X2pvYnMgXSB+ZjpKb2JfcXVldWUuY2xlYXI7XG4gIHQudW5jYXVnaHRfZXhuIDwtIFNvbWUgKGV4biwgc2V4cClcbjs7XG5cbigqIFtzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XSBlbmFibGVzIHN1YnNlcXVlbnQgY2FsbHMgb2YgW3J1bl9qb2JzXVxuICAgdG8gcnVuIHVwIHRvIFttYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XSBqb2JzIG9mIGVhY2ggcHJpb3JpdHkgbGV2ZWwuICopXG5sZXQgc3RhcnRfY3ljbGUgdCB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSA9XG4gIGxldCBuID0gTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUucmF3IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHkgaW5cbiAgSm9iX3F1ZXVlLnNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzIG47XG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5sb3dfcHJpb3JpdHlfam9icyBuXG47O1xuXG4oKiBbcnVuX2pvYnMgdF0gcmVtb3ZlcyBqb2JzIGZyb20gW3RdIG9uZSBhdCBhIHRpbWUgYW5kIHJ1bnMgdGhlbSwgc3RvcHBpbmcgYXMgc29vblxuICAgYXMgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpcyByYWlzZWQsIG9yIHdoZW4gbm8gbW9yZSBqb2JzIGNhbiBiZSBydW4gYXQgYW55IHByaW9yaXR5LFxuICAgYXMgcGVyIFt+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV0uICopXG5sZXQgcmVjIHJ1bl9qb2JzIHQgPVxuICBtYXRjaCBKb2JfcXVldWUucnVuX2pvYnMgdC5ub3JtYWxfcHJpb3JpdHlfam9icyB0IHdpdGhcbiAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICB8IE9rICgpIC0+XG4gICAgKG1hdGNoIEpvYl9xdWV1ZS5ydW5fam9icyB0Lmxvd19wcmlvcml0eV9qb2JzIHQgd2l0aFxuICAgICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gICAgIHwgT2sgKCkgLT5cbiAgICAgICBpZiBKb2JfcXVldWUuY2FuX3J1bl9hX2pvYiB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICAgICAgfHwgSm9iX3F1ZXVlLmNhbl9ydW5fYV9qb2IgdC5sb3dfcHJpb3JpdHlfam9ic1xuICAgICAgIHRoZW4gcnVuX2pvYnMgdFxuICAgICAgIGVsc2UgT2sgKCkpXG47O1xuXG5sZXQgc3RhYmlsaXplIHQgPVxuICBzdGFydF9jeWNsZVxuICAgIHRcbiAgICB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eTpcbiAgICAgIChNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5jcmVhdGVfZXhuIEludC5tYXhfdmFsdWUpO1xuICBtYXRjaCBydW5fam9icyB0IHdpdGhcbiAgfCBPayAoKSAtPiBPayAoKVxuICB8IEVycm9yIChleG4sIF9iYWNrdHJhY2UpIC0+IEVycm9yIGV4blxuOztcblxubGV0IGNyZWF0ZV90aW1lX3NvdXJjZVxuICAgICAgPyh0aW1pbmdfd2hlZWxfY29uZmlnID0gQXN5bmNfa2VybmVsX2NvbmZpZy50aW1pbmdfd2hlZWxfY29uZmlnKVxuICAgICAgfm5vd1xuICAgICAgKClcbiAgPVxuICBsZXQgdCA9IHQgKCkgaW5cbiAgbGV0IGV2ZW50cyA9IFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzp0aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydDpub3cgaW5cbiAgbGV0IHJlYyB0aW1lX3NvdXJjZSA6IF8gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEudCA9XG4gICAgeyBpZCA9IFR5cGVzLlRpbWVfc291cmNlX2lkLmNyZWF0ZSAoKVxuICAgIDsgYWR2YW5jZV9lcnJvcnMgPSBbXVxuICAgIDsgYW1fYWR2YW5jaW5nID0gZmFsc2VcbiAgICA7IGV2ZW50c1xuICAgIDsgaGFuZGxlX2ZpcmVkID0gKGZ1biBhbGFybSAtPiBoYW5kbGVfZmlyZWQgdGltZV9zb3VyY2UgKEFsYXJtLnZhbHVlIGV2ZW50cyBhbGFybSkpXG4gICAgOyBmaXJlZF9ldmVudHMgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgaXNfd2FsbF9jbG9jayA9IGZhbHNlXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHNjaGVkdWxlciA9IHRcbiAgICB9XG4gIGluXG4gIHRpbWVfc291cmNlXG47O1xuXG5sZXQgd2FsbF9jbG9jayAoKSA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLnJlYWRfb25seSAodCAoKSkudGltZV9zb3VyY2VcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBDZWxsID0gVHlwZXMuQ2VsbFxuXG50eXBlIGFueSA9XG4gIFsgYEVtcHR5XG4gIHwgYEVtcHR5X29uZV9oYW5kbGVyXG4gIHwgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gIHwgYEZ1bGxcbiAgfCBgSW5kaXJcbiAgXVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5JdmFyLnQgPSB7IG11dGFibGUgY2VsbCA6ICgnYSwgYW55KSBjZWxsIH1cblxuKCogVGhlIFsnYl0gaXMgdXNlZCB0byBlbmNvZGUgdGhlIGNvbnN0cnVjdG9yLiAgVGhpcyBhbGxvd3MgdXMgdG8gd3JpdGUgZnVuY3Rpb25zIHRoYXRcbiAgIHRha2Ugb25seSBvbmUgb2YgdGhlIGNvbnN0cnVjdG9ycywgd2l0aCBubyBydW50aW1lIHRlc3QuXG5cbiAgIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB0aGUgZGlyZWN0ZWQgZ3JhcGggd2l0aCBpdmFycyBhcyBub2RlcyBhbmQgW0luZGlyXXMgYXNcbiAgIGVkZ2VzIGlzIGFjeWNsaWMuICBUaGUgb25seSBmdW5jdGlvbnMgdGhhdCBjcmVhdGUgYW4gW0luZGlyXSBhcmUgW3NxdWFzaF0gYW5kXG4gICBbY29ubmVjdF0sIGFuZCBmb3IgdGhvc2UsIHRoZSB0YXJnZXQgb2YgdGhlIFtJbmRpcl0gaXMgYWx3YXlzIGEgbm9uLVtJbmRpcl0uICBUaHVzLCB0aGVcbiAgIG5ld2x5IGFkZGVkIGVkZ2VzIGFyZSBuZXZlciBwYXJ0IG9mIGEgY3ljbGUuICopXG5hbmQgKCdhLCAnYikgY2VsbCA9ICgnYSwgJ2IpIFR5cGVzLkNlbGwudCA9XG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgOlxuICAgICAgeyAoKiBbcnVuXSBpcyBtdXRhYmxlIHNvIHdlIGNhbiBzZXQgaXQgdG8gW2lnbm9yZV0gd2hlbiB0aGUgaGFuZGxlciBpcyByZW1vdmVkLlxuICAgICAgICAgICBUaGlzIGlzIHVzZWQgd2hlbiB3ZSBpbnN0YWxsIGEgaGFuZGxlciBvbiBhIGZ1bGwgaXZhciBzaW5jZSBpdCBpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICBhZGRlZCB0byB0aGUgc2NoZWR1bGVyLiAqKVxuICAgICAgICBtdXRhYmxlIHJ1biA6ICdhIC0+IHVuaXRcbiAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICA7ICgqIFtwcmV2XSBhbmQgW25leHRdIGNpcmN1bGFybHkgZG91Ymx5IGxpbmsgYWxsIGhhbmRsZXJzIG9mIHRoZSBzYW1lIGl2YXIuICopXG4gICAgICAgIG11dGFibGUgcHJldiA6ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICAgICAgOyBtdXRhYmxlIG5leHQgOiAoJ2EsIFsgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcbiAgICAgIH1cbiAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciA6XG4gICAgICAoJ2EgLT4gdW5pdCkgKiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfaGFuZGxlciBdKSBjZWxsXG4gIHwgRW1wdHkgOiAoJ2EsIFs+IGBFbXB0eSBdKSBjZWxsXG4gIHwgRnVsbCA6ICdhIC0+ICgnYSwgWz4gYEZ1bGwgXSkgY2VsbFxuICB8IEluZGlyIDogJ2EgdCAtPiAoJ2EsIFs+IGBJbmRpciBdKSBjZWxsXG5cbm1vZHVsZSBIYW5kbGVyID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuXG4gIGxldCBydW4gKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5ydW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQuZXhlY3V0aW9uX2NvbnRleHRcbiAgbGV0IHByZXYgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5wcmV2XG4gIGxldCBuZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQubmV4dFxuICBsZXQgc2V0X3J1biAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgeCA9IHQucnVuIDwtIHhcbiAgbGV0IHNldF9wcmV2IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5wcmV2IDwtIHhcbiAgbGV0IHNldF9uZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5uZXh0IDwtIHhcblxuICBsZXQgY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCA9XG4gICAgKCogQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mOlxuXG4gICAgICAge1tcbiAgICAgICAgIGxldCByZWMgdCA9XG4gICAgICAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgICAgICAgeyBydW5cbiAgICAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0XG4gICAgICAgICAgICAgOyBwcmV2ICAgICAgICAgICAgICA9IHRcbiAgICAgICAgICAgICA7IG5leHQgICAgICAgICAgICAgID0gdCB9XG4gICAgICAgICBpblxuICAgICAgICAgaDEgXX1cblxuICAgICAgIEhvd2V2ZXIgdGhlIGNvbXBpbGF0aW9uIG9mIHJlY3Vyc2l2ZSB2YWx1ZSBpbiBPQ2FtbCBpcyBub3Qgb3B0aW1hbDogdGhlIHZhbHVlIGlzXG4gICAgICAgYWxsb2NhdGVkIHR3aWNlIGFuZCBjb3BpZWQgb25jZSAod2l0aCBhIGxvb3AgY2FsbGluZyBjYW1sX21vZGlmeSkuICBUaGlzIGlzIG5vdFxuICAgICAgIG5lY2Vzc2FyeSBmb3Igc2ltcGxlIHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBsaWtlIHRoaXMgb25lLlxuXG4gICAgICAgSW5zdGVhZCB3ZSBhbGxvY2F0ZSB0aGUgdmFsdWUgd2l0aCBkdW1teSBmaWVsZHMgYW5kIHVwZGF0ZSB0aGVtIGFmdGVyLiAqKVxuICAgIGxldCB0ID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldiA9IE9iai5tYWdpYyBOb25lOyBuZXh0ID0gT2JqLm1hZ2ljIE5vbmUgfVxuICAgIGluXG4gICAgc2V0X3ByZXYgdCB0O1xuICAgIHNldF9uZXh0IHQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZTIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgPVxuICAgICgqIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBvZjpcblxuICAgICAgIHtbXG4gICAgICAgICBsZXQgcmVjIHQxID1cbiAgICAgICAgICAgeyBydW4gICAgICAgICAgICAgICA9IHJ1bjFcbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MVxuICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdDJcbiAgICAgICAgICAgOyBuZXh0ICAgICAgICAgICAgICA9IHQyIH1cbiAgICAgICAgIGFuZCB0MiA9XG4gICAgICAgICAgIHsgcnVuICAgICAgICAgICAgICAgPSBydW4yXG4gICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDJcbiAgICAgICAgICAgOyBwcmV2ICAgICAgICAgICAgICA9IHQxXG4gICAgICAgICAgIDsgbmV4dCAgICAgICAgICAgICAgPSB0MSB9XG4gICAgICAgICBpblxuICAgICAgICAgdDEgXX0gKilcbiAgICBsZXQgdDEgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW4gPSBydW4xXG4gICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDFcbiAgICAgICAgOyBwcmV2ID0gT2JqLm1hZ2ljIE5vbmVcbiAgICAgICAgOyBuZXh0ID0gT2JqLm1hZ2ljIE5vbmVcbiAgICAgICAgfVxuICAgIGluXG4gICAgbGV0IHQyID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgIHsgcnVuID0gcnVuMjsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDI7IHByZXYgPSB0MTsgbmV4dCA9IHQxIH1cbiAgICBpblxuICAgIHNldF9wcmV2IHQxIHQyO1xuICAgIHNldF9uZXh0IHQxIHQyO1xuICAgIHQxXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgKGV4ZWN1dGlvbl9jb250ZXh0IHQpO1xuICAgIGxldCByID0gcmVmIChuZXh0IHQpIGluXG4gICAgd2hpbGUgbm90IChwaHlzX2VxdWFsICFyIHQpIGRvXG4gICAgICBsZXQgdDEgPSAhciBpblxuICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChwcmV2IChuZXh0IHQxKSkgdDEpO1xuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50IChleGVjdXRpb25fY29udGV4dCB0MSk7XG4gICAgICByIDo9IG5leHQgIXJcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGlzX3NpbmdsZXRvbiB0ID0gcGh5c19lcXVhbCB0IChuZXh0IHQpXG5cbiAgbGV0IGxlbmd0aCB0ID1cbiAgICBsZXQgbiA9IHJlZiAxIGluXG4gICAgbGV0IHIgPSByZWYgKG5leHQgdCkgaW5cbiAgICB3aGlsZSBub3QgKHBoeXNfZXF1YWwgIXIgdCkgZG9cbiAgICAgIGluY3IgbjtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmU7XG4gICAgIW5cbiAgOztcblxuICBsZXQgZW5xdWV1ZSB0IHNjaGVkdWxlciB2ID0gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIChleGVjdXRpb25fY29udGV4dCB0KSAocnVuIHQpIHZcblxuICBsZXQgc2NoZWR1bGVfam9icyB0IHYgPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIGVucXVldWUgdCBzY2hlZHVsZXIgdjtcbiAgICBsZXQgciA9IHJlZiAobmV4dCB0KSBpblxuICAgIHdoaWxlIG5vdCAocGh5c19lcXVhbCAhciB0KSBkb1xuICAgICAgZW5xdWV1ZSAhciBzY2hlZHVsZXIgdjtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgdW5saW5rIHQgPVxuICAgIHNldF9wcmV2IChuZXh0IHQpIChwcmV2IHQpO1xuICAgIHNldF9uZXh0IChwcmV2IHQpIChuZXh0IHQpO1xuICAgIHNldF9wcmV2IHQgdDtcbiAgICBzZXRfbmV4dCB0IHRcbiAgOztcblxuICBsZXQgYWRkIHQgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldiA9IHByZXYgdDsgbmV4dCA9IHQgfVxuICAgIGluXG4gICAgc2V0X25leHQgKHByZXYgdCkgcmVzdWx0O1xuICAgIHNldF9wcmV2IHQgcmVzdWx0O1xuICAgIHJlc3VsdFxuICA7O1xuXG4gICgqIFtzcGxpY2UgdDEgdDJdIGNyZWF0ZXM6XG5cbiAgICAge3ZcbiAgICAgICAtLT4gdDEgPC0tPiAuLi4gPC0tPiBsYXN0MSA8LS0+IHQyIDwtLT4gLi4uIDwtLT4gbGFzdDIgPC0tXG4gICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgdn0gKilcbiAgbGV0IHNwbGljZSB0MSB0MiA9XG4gICAgbGV0IGxhc3QxID0gcHJldiB0MSBpblxuICAgIGxldCBsYXN0MiA9IHByZXYgdDIgaW5cbiAgICBzZXRfbmV4dCBsYXN0MSB0MjtcbiAgICBzZXRfbmV4dCBsYXN0MiB0MTtcbiAgICBzZXRfcHJldiB0MSBsYXN0MjtcbiAgICBzZXRfcHJldiB0MiBsYXN0MVxuICA7O1xuXG4gIGxldCBvZl9saXN0IGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIDo6IGwgLT5cbiAgICAgIGxldCBmaXJzdCA9IGNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICAgIGxldCByZWMgbG9vcCBwcmV2IGwgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiBzZXRfcHJldiBmaXJzdCBwcmV2XG4gICAgICAgIHwgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIDo6IGwgLT5cbiAgICAgICAgICBsZXQgdCA9XG4gICAgICAgICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB7IHJ1bjsgZXhlY3V0aW9uX2NvbnRleHQ7IHByZXY7IG5leHQgPSBmaXJzdCB9XG4gICAgICAgICAgaW5cbiAgICAgICAgICBzZXRfbmV4dCBwcmV2IHQ7XG4gICAgICAgICAgbG9vcCB0IGxcbiAgICAgIGluXG4gICAgICBsb29wIGZpcnN0IGw7XG4gICAgICBTb21lIGZpcnN0XG4gIDs7XG5cbiAgbGV0IHRvX2xpc3QgZmlyc3QgPVxuICAgIGxldCByZWMgbG9vcCB0IGFjYyA9XG4gICAgICBsZXQgYWNjID0gKHJ1biB0LCBleGVjdXRpb25fY29udGV4dCB0KSA6OiBhY2MgaW5cbiAgICAgIGlmIHBoeXNfZXF1YWwgdCBmaXJzdCB0aGVuIGFjYyBlbHNlIGxvb3AgKHByZXYgdCkgYWNjXG4gICAgaW5cbiAgICBsb29wIChwcmV2IGZpcnN0KSBbXVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgXyAodCA6IF8gdCkgPVxuICAgIGxldCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgeyBydW4gPSBfOyBleGVjdXRpb25fY29udGV4dDsgbmV4dCA9IF87IHByZXYgPSBfIH0pID1cbiAgICAgIHRcbiAgICBpblxuICAgIFslbWVzc2FnZSAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KV1cbiAgOztcbmVuZFxuXG50eXBlICdhIGl2YXIgPSAnYSB0XG5cbigqIENvbXBpbGVkIGFzIHRoZSBpZGVudGl0eS4gKilcbmxldCBjZWxsX29mX2hhbmRsZXIgOiBfIEhhbmRsZXIudCAtPiBfID0gZnVuY3Rpb25cbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIHggLT4gKHggOj4gKF8sIGFueSkgY2VsbClcbjs7XG5cbmxldCBlcXVhbCAodCA6IF8gdCkgdCcgPSBwaHlzX2VxdWFsIHQgdCdcbmxldCBpbmRpciB0ID0geyBjZWxsID0gSW5kaXIgdCB9XG5cbmluY2x1ZGUgU2NoZWR1bGVyLkl2YXJcblxuKCogW3NxdWFzaCB0XSByZXR1cm5zIHRoZSBub24tW0luZGlyXSBpdmFyIGF0IHRoZSBlbmQgb2YgdGhlIChwb3NzaWJseSBlbXB0eSkgY2hhaW4gb2ZcbiAgIFtJbmRpcl1zIHN0YXJ0aW5nIHdpdGggW3RdIGFuZCBlbnN1cmVzIHRoYXQgYWxsIFtJbmRpcl1zIGFsb25nIHRoYXQgY2hhaW4gYXJlIHJlcGxhY2VkXG4gICB3aXRoIGFuIFtJbmRpcl0gcG9pbnRpbmcgdG8gdGhlIGVuZCBvZiB0aGUgY2hhaW4uICopXG5sZXQgc3F1YXNoID1cbiAgbGV0IHJlYyBmb2xsb3cgaW5kaXIgdCA9XG4gICAgKCogW2luZGlyID0gSW5kaXIgdF0gKilcbiAgICBtYXRjaCB0LmNlbGwgd2l0aFxuICAgIHwgSW5kaXIgdCcgYXMgaW5kaXInIC0+IGZvbGxvdyBpbmRpcicgdCdcbiAgICB8IF8gLT4gaW5kaXJcbiAgaW5cbiAgbGV0IHJlYyB1cGRhdGUgdCBpbmRpciA9XG4gICAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgICB8IEluZGlyIHQnIC0+XG4gICAgICB0LmNlbGwgPC0gaW5kaXI7XG4gICAgICB1cGRhdGUgdCcgaW5kaXJcbiAgICB8IF8gLT4gdFxuICBpblxuICBmdW4gdCAtPlxuICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgfCBJbmRpciB0JyAtPlxuICAgICAgKG1hdGNoIHQnLmNlbGwgd2l0aFxuICAgICAgIHwgSW5kaXIgdCcnIGFzIGluZGlyIC0+IHVwZGF0ZSB0IChmb2xsb3cgaW5kaXIgdCcnKVxuICAgICAgIHwgXyAtPiB0JyAoKiBub3RoaW5nIHRvIGRvLCBzaW5jZSBbdF0gaXMgYSBjaGFpbiB3aXRoIGEgc2luZ2xlIFtJbmRpcl0gKikpXG4gICAgfCBfIC0+IHRcbjs7XG5cbigqIG5vdGhpbmcgdG8gZG8sIHNpbmNlIFt0XSBpc24ndCBhbiBbSW5kaXJdLiAqKVxuXG5sZXQgaW52YXJpYW50IGFfaW52YXJpYW50IHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IGFfaW52YXJpYW50IGFcbiAgfCBFbXB0eSAtPiAoKVxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChfLCBleGVjdXRpb25fY29udGV4dCkgLT5cbiAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgZXhlY3V0aW9uX2NvbnRleHRcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT4gSGFuZGxlci5pbnZhcmlhbnQgaGFuZGxlclxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA6IFNleHAudCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gTGlzdCBbIEF0b20gXCJGdWxsXCI7IHNleHBfb2ZfYSBhIF1cbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+IEF0b20gXCJFbXB0eVwiXG47O1xuXG5sZXQgcGVlayB0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBTb21lIGFcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+IE5vbmVcbjs7XG5cbmxldCB2YWx1ZSB0IH5pZl9lbXB0eV90aGVuX2ZhaWx3aXRoID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBhXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPlxuICAgIGZhaWx3aXRoIGlmX2VtcHR5X3RoZW5fZmFpbHdpdGhcbjs7XG5cbmxldCB2YWx1ZV9leG4gdCA9IHZhbHVlIHQgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGg6XCJJdmFyLnZhbHVlX2V4biBjYWxsZWQgb24gZW1wdHkgaXZhclwiXG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgXyAtPiBmYWxzZVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gdHJ1ZVxuOztcblxubGV0IGlzX2Z1bGwgdCA9IG5vdCAoaXNfZW1wdHkgdClcblxubGV0IGZpbGwgdCB2ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgXyAtPiByYWlzZV9zIFslbWVzc2FnZSBcIkl2YXIuZmlsbCBvZiBmdWxsIGl2YXJcIiAodCA6IF8gdCldXG4gIHwgRW1wdHkgLT4gdC5jZWxsIDwtIEZ1bGwgdlxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSAtPlxuICAgIHQuY2VsbCA8LSBGdWxsIHY7XG4gICAgU2NoZWR1bGVyLihlbnF1ZXVlICh0ICgpKSkgZXhlY3V0aW9uX2NvbnRleHQgcnVuIHZcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT5cbiAgICB0LmNlbGwgPC0gRnVsbCB2O1xuICAgIEhhbmRsZXIuc2NoZWR1bGVfam9icyBoYW5kbGVyIHZcbjs7XG5cbmxldCByZW1vdmVfaGFuZGxlciB0IChoYW5kbGVyIDogXyBIYW5kbGVyLnQpID1cbiAgSGFuZGxlci5zZXRfcnVuIGhhbmRsZXIgaWdub3JlO1xuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIC0+XG4gICAgKCogVGhlc2UgYXJlIG9ubHkgcG9zc2libGUgaWYgW2hhbmRsZXJdIHdhcyBhbHJlYWR5IHJlbW92ZWQuICAqKVxuICAgICgpXG4gIHwgRnVsbCBfIC0+XG4gICAgKCogVGhpcyBpcyBwb3NzaWJsZSBpZiBbdF0gd2FzIGZpbGxlZCBiZWZvcmUgd2UgdHJ5IHRvIHJlbW92ZSB0aGUgaGFuZGxlci4gIEUuZy5cbiAgICAgICBbRGVmZXJyZWQuY2hvb3NlXSB3aWxsIGRvIHRoaXMuICopXG4gICAgKClcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGNlbGwgLT5cbiAgICBpZiBIYW5kbGVyLmlzX3NpbmdsZXRvbiBoYW5kbGVyXG4gICAgdGhlbiB0LmNlbGwgPC0gRW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGlmIHBoeXNfZXF1YWwgaGFuZGxlciBjZWxsIHRoZW4gdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciAoSGFuZGxlci5uZXh0IGhhbmRsZXIpO1xuICAgICAgSGFuZGxlci51bmxpbmsgaGFuZGxlcilcbjs7XG5cbmxldCBhZGRfaGFuZGxlciB0IHJ1biBleGVjdXRpb25fY29udGV4dCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eSAtPlxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlci5jcmVhdGUgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IGluXG4gICAgdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyO1xuICAgIGhhbmRsZXJcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuJywgZXhlY3V0aW9uX2NvbnRleHQnKSAtPlxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlci5jcmVhdGUyIHJ1biBleGVjdXRpb25fY29udGV4dCBydW4nIGV4ZWN1dGlvbl9jb250ZXh0JyBpblxuICAgIHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjtcbiAgICBoYW5kbGVyXG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyIC0+IEhhbmRsZXIuYWRkIGhhbmRsZXIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0XG4gIHwgRnVsbCB2IC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICAoKiBbcnVuXSBjYWxscyBbaGFuZGxlci5ydW5dLCB3aGljaCwgaWYgW2hhbmRsZXJdIGhhcyBiZWVuIHJlbW92ZWQsIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgICB0byBbaWdub3JlXS4gKilcbiAgICBsZXQgcnVuIHYgPSBIYW5kbGVyLnJ1biBoYW5kbGVyIHYgaW5cbiAgICBTY2hlZHVsZXIuKGVucXVldWUgKHQgKCkpKSBleGVjdXRpb25fY29udGV4dCBydW4gdjtcbiAgICBoYW5kbGVyXG47O1xuXG5sZXQgaGFzX2hhbmRsZXJzIHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gdHJ1ZVxuICB8IEVtcHR5IHwgRnVsbCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgdXBvbicgdCBydW4gPSBhZGRfaGFuZGxlciB0IHJ1biBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKVxuXG4oKiBbdXBvbl0gaXMgY29uY2VwdHVhbGx5IHRoZSBzYW1lIGFzOlxuXG4gICB7W1xuICAgICBsZXQgdXBvbiB0IGYgPSBpZ25vcmUgKHVwb24nIHQgcnVuKSBdfVxuXG4gICBIb3dldmVyLCBiZWxvdyBpcyBhIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyB3b3J0aCBkb2luZyBiZWNhdXNlIFt1cG9uXVxuICAgaXMgdmVyeSB3aWRlbHkgdXNlZCBhbmQgaXMgc28gbXVjaCBtb3JlIGNvbW1vbiB0aGFuIFt1cG9uJ10uICBUaGUgYmVsb3cgaW1wbGVtZW50YXRpb25cbiAgIGF2b2lkcyB0aGUgdXNlIG9mIHRoZSBiYWcgb2YgaGFuZGxlcnMgaW4gdGhlIGV4dHJlbWVseSBjb21tb24gY2FzZSBvZiBvbmUgaGFuZGxlciBmb3JcbiAgIHRoZSBkZWZlcnJlZC4gKilcbmxldCB1cG9uIHQgcnVuID1cbiAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCB2IC0+IFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBydW4gdlxuICB8IEVtcHR5IC0+IHQuY2VsbCA8LSBFbXB0eV9vbmVfaGFuZGxlciAocnVuLCBleGVjdXRpb25fY29udGV4dClcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuJywgZXhlY3V0aW9uX2NvbnRleHQnKSAtPlxuICAgIHQuY2VsbFxuICAgIDwtIGNlbGxfb2ZfaGFuZGxlciAoSGFuZGxlci5jcmVhdGUyIHJ1biBleGVjdXRpb25fY29udGV4dCBydW4nIGV4ZWN1dGlvbl9jb250ZXh0JylcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT5cbiAgICBpZ25vcmUgKEhhbmRsZXIuYWRkIGhhbmRsZXIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IDogXyBIYW5kbGVyLnQpXG47O1xuXG4oKiBbY29ubmVjdF0gdGFrZXMgaXZhcnMgW2JpbmRfcmVzdWx0XSBhbmQgW2JpbmRfcmhzXSwgYW5kIG1ha2VzIFtiaW5kX3Joc11cbiAgIGJlIGFuIFtJbmRpcl0gcG9pbnRpbmcgdG8gdGhlIG5vbi1pbmRpciBjZWxsIHJlYWNoYWJsZSBmcm9tIFtiaW5kX3Jlc3VsdF0uICBPbiBlbnRyeVxuICAgdG8gW2Nvbm5lY3RdLCBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdIG1heSBiZSBjaGFpbnMsIHNpbmNlIFtiaW5kX3Joc10gaXMgYW5cbiAgIGFyYml0cmFyeSB1c2VyLXN1cHBsaWVkIGRlZmVycmVkLCBhbmQgW2JpbmRfcmVzdWx0XSBpcyByZXR1cm5lZCB0byB0aGUgdXNlciBwcmlvciB0b1xuICAgYmVpbmcgW2Nvbm5lY3RdZWQsIGFuZCBtYXkgaGF2ZSBiZWVuIGNvbnZlcnRlZCB0byBhbiBpbmRpcmVjdGlvbiBpbiB0aGUgY2FzZSBvZlxuICAgcmlnaHQtbmVzdGVkIGJpbmRzLlxuXG4gICBUaGUgcHVycG9zZSBvZiBbY29ubmVjdF0gaXMgdG8gbWFrZSB0YWlsLXJlY3Vyc2l2ZSBiaW5kIGxvb3BzIHVzZSBjb25zdGFudCBzcGFjZS5cbiAgIEUuZy46XG5cbiAgIHtbXG4gICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICBpZiBpID0gMFxuICAgICAgIHRoZW4gcmV0dXJuICgpXG4gICAgICAgZWxzZSAoXG4gICAgICAgICBsZXQlYmluZCAoKSA9IGFmdGVyIChzZWMgMS4pIGluXG4gICAgICAgICBsb29wIChpIC0gMSkpIF19XG5cbiAgIFtjb25uZWN0XSBtYWtlcyBpbnRlcm1lZGlhdGUgYmluZCByZXN1bHRzIGFsbCBiZSBbSW5kaXJdcyBwb2ludGluZyBhdCB0aGUgb3V0ZXJtb3N0XG4gICBiaW5kLCByYXRoZXIgdGhhbiBiZWluZyBhIGxpbmVhci1sZW5ndGggY2hhaW4sIHdpdGggZWFjaCBwb2ludGluZyB0byB0aGUgcHJldmlvdXMgb25lLlxuICAgVGhlbiwgc2luY2UgdGhlIHByb2dyYW0gaXMgb25seSBob2xkaW5nIG9uIHRvIHRoZSBpbm5lcm1vc3QgYW5kIG91dGVybW9zdCBiaW5kcyBhbGwgdGhlXG4gICBpbnRlcm1lZGlhdGUgb25lcyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG5cbiAgIFtjb25uZWN0XSB3b3JrcyBieSBzcXVhc2hpbmcgaXRzIGFyZ3VtZW50cyBzbyB0aGF0IHRoZSBbYmluZF9yaHNdIGFsd2F5cyBwb2ludHMgYXQgdGhlXG4gICB1bHRpbWF0ZSByZXN1bHQuICopXG5sZXQgY29ubmVjdCA9XG4gICgqIFtyZXBvaW50X2luZGlycyB+aXZhciB+aW5kaXIgfmJpbmRfcmVzdWx0XSByZXBvaW50cyB0byBbaW5kaXJdIGFsbCB0aGUgaXZhcnMgaW4gdGhlXG4gICAgIGNoYWluIHJlYWNoYWJsZSBmcm9tIFtpdmFyXSwgYW5kIHJldHVybnMgdGhlIG5vbi1bSW5kaXJdIGNlbGwgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgY2hhaW4uICBBZnRlciByZXBvaW50aW5nLCB3ZSB3aWxsIG1lcmdlIHRoZSBoYW5kbGVycyBpbiB0aGF0IGNlbGwgd2l0aCB0aGUgaGFuZGxlcnNcbiAgICAgaW4gW2JpbmRfcmVzdWx0XSwgYW5kIHB1dCB0aGUgbWVyZ2VkIHNldCBvZiBoYW5kbGVycyBpbiBbYmluZF9yZXN1bHRdLiAqKVxuICBsZXQgcmVjIHJlcG9pbnRfaW5kaXJzIH5pdmFyIH5pbmRpciB+YmluZF9yZXN1bHQgPVxuICAgIGxldCBjZWxsID0gaXZhci5jZWxsIGluXG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBJbmRpciBpdmFyJyAtPlxuICAgICAgaXZhci5jZWxsIDwtIGluZGlyO1xuICAgICAgcmVwb2ludF9pbmRpcnMgfml2YXI6aXZhcicgfmluZGlyIH5iaW5kX3Jlc3VsdFxuICAgIHwgRnVsbCBfIC0+IGNlbGxcbiAgICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT5cbiAgICAgICgqIEl0IGlzIHBvc3NpYmxlIHRoYXQgW2JpbmRfcmVzdWx0XSBhbmQgW2JpbmRfcmhzXSBhcmUgbm90IGVxdWFsLCBidXQgdGhlaXIgY2hhaW5zXG4gICAgICAgICBvZiBpbmRpcnMgbGVhZCB0byB0aGUgc2FtZSBub24tW0luZGlyXSBjZWxsLCBpbiB3aGljaCBjYXNlIHdlIGNhbm5vdCBzZXQgdGhhdFxuICAgICAgICAgY2VsbCB0byBwb2ludCB0byBpdHNlbGYsIGJlY2F1c2UgdGhhdCB3b3VsZCBpbnRyb2R1Y2UgYSBjeWNsZS4gKilcbiAgICAgIGlmIG5vdCAocGh5c19lcXVhbCBpdmFyIGJpbmRfcmVzdWx0KSB0aGVuIGl2YXIuY2VsbCA8LSBpbmRpcjtcbiAgICAgIGNlbGxcbiAgaW5cbiAgZnVuIH5iaW5kX3Jlc3VsdCB+YmluZF9yaHMgLT5cbiAgICBpZiBub3QgKHBoeXNfZXF1YWwgYmluZF9yZXN1bHQgYmluZF9yaHMpXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYmluZF9yZXN1bHQgPSBzcXVhc2ggYmluZF9yZXN1bHQgaW5cbiAgICAgIGxldCBpbmRpciA9IEluZGlyIGJpbmRfcmVzdWx0IGluXG4gICAgICBsZXQgYmluZF9yaHNfY29udGVudHMgPSByZXBvaW50X2luZGlycyB+aXZhcjpiaW5kX3JocyB+aW5kaXIgfmJpbmRfcmVzdWx0IGluXG4gICAgICAoKiB1cGRhdGUgW2JpbmRfcmVzdWx0XSB3aXRoIHRoZSB1bmlvbiBvZiBoYW5kbGVycyBpbiBbYmluZF9yZXN1bHRdIGFuZFxuICAgICAgICAgW2JpbmRfcmhzXSAqKVxuICAgICAgbWF0Y2ggYmluZF9yZXN1bHQuY2VsbCwgYmluZF9yaHNfY29udGVudHMgd2l0aFxuICAgICAgfCBJbmRpciBfLCBfIHwgXywgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSBhbmQgW3JlcG9pbnRfaW5kaXJzXSAqKVxuICAgICAgKCogW2Nvbm5lY3RdIGlzIG9ubHkgdXNlZCBpbiBiaW5kLCB3aG9zZSBpdmFyIGlzIG9ubHkgZXZlciBleHBvcnRlZCBhcyBhIHJlYWQtb25seVxuICAgICAgICAgZGVmZXJyZWQuICBUaHVzLCBbYmluZF9yZXN1bHRdIG11c3QgYmUgZW1wdHkuICopXG4gICAgICB8IEZ1bGwgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgXywgRW1wdHkgLT4gKClcbiAgICAgIHwgRW1wdHksIF8gLT4gYmluZF9yZXN1bHQuY2VsbCA8LSBiaW5kX3Joc19jb250ZW50c1xuICAgICAgfCBFbXB0eV9vbmVfaGFuZGxlciAocnVuLCBleGVjdXRpb25fY29udGV4dCksIEZ1bGwgdiAtPlxuICAgICAgICBiaW5kX3Jlc3VsdC5jZWxsIDwtIGJpbmRfcmhzX2NvbnRlbnRzO1xuICAgICAgICBTY2hlZHVsZXIuKGVucXVldWUgKHQgKCkpKSBleGVjdXRpb25fY29udGV4dCBydW4gdlxuICAgICAgfCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyKSwgRnVsbCB2IC0+XG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gYmluZF9yaHNfY29udGVudHM7XG4gICAgICAgIEhhbmRsZXIuc2NoZWR1bGVfam9icyBoYW5kbGVyIHZcbiAgICAgIHwgKCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMSwgZXhlY3V0aW9uX2NvbnRleHQxKVxuICAgICAgICAsIEVtcHR5X29uZV9oYW5kbGVyIChydW4yLCBleGVjdXRpb25fY29udGV4dDIpICkgLT5cbiAgICAgICAgbGV0IGhhbmRsZXIxID0gSGFuZGxlci5jcmVhdGUyIHJ1bjEgZXhlY3V0aW9uX2NvbnRleHQxIHJ1bjIgZXhlY3V0aW9uX2NvbnRleHQyIGluXG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXIxXG4gICAgICB8ICggKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjEpXG4gICAgICAgICwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjIsIGV4ZWN1dGlvbl9jb250ZXh0MikgKSAtPlxuICAgICAgICBpZ25vcmUgKEhhbmRsZXIuYWRkIGhhbmRsZXIxIHJ1bjIgZXhlY3V0aW9uX2NvbnRleHQyIDogXyBIYW5kbGVyLnQpXG4gICAgICB8ICggRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjEsIGV4ZWN1dGlvbl9jb250ZXh0MSlcbiAgICAgICAgLCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMikgKSAtPlxuICAgICAgICBsZXQgaGFuZGxlcjEgPSBIYW5kbGVyLmFkZCBoYW5kbGVyMiBydW4xIGV4ZWN1dGlvbl9jb250ZXh0MSBpblxuICAgICAgICBiaW5kX3Jlc3VsdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyMVxuICAgICAgfCAoIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIxKVxuICAgICAgICAsIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIyKSApIC0+IEhhbmRsZXIuc3BsaWNlIGhhbmRsZXIxIGhhbmRsZXIyKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEl2YXIgPSBJdmFyMFxubW9kdWxlIEhhbmRsZXIgPSBJdmFyLkhhbmRsZXJcblxuKCogRGVmZXJyZWRzIHByZXNlbnQgYSBjb3ZhcmlhbnQgdmlldyBvZiBpdmFycy4gIFdlIGNvdWxkIGFjdHVhbGx5IGltcGxlbWVudCBkZWZlcnJlZHNcbiAgIHVzaW5nIGEgcmVjb3JkIG9mIGNsb3N1cmVzLCBhcyBpbiB0aGUgW2Vzc2VuY2Vfb2ZfZGVmZXJyZWRdIHJlY29yZCBiZWxvdywgZm9yIHdoaWNoIHRoZVxuICAgT0NhbWwgdHlwZSBjaGVja2VyIGNhbiBpbmZlciBjb3ZhcmlhbmNlLiAgSG93ZXZlciwgZG9pbmcgc28gd291bGQgbWFrZSBbSXZhci5yZWFkXSB2ZXJ5XG4gICBjb3N0bHksIGJlY2F1c2UgaXQgd291bGQgaGF2ZSB0byBhbGxvY2F0ZSBsb3RzIG9mIGNsb3N1cmVzIGFuZCBhIHJlY29yZC4gIEluc3RlYWQgb2ZcbiAgIGRvaW5nIHRoaXMsIHdlIG1ha2UgZGVmZXJyZWRzIGFuIGFic3RyYWN0IGNvdmFyaWFudCB0eXBlLCB3aGljaCBjb25jcmV0ZWx5IGlzIGp1c3QgdGhlXG4gICBpdmFyLCBhbmQgdXNlIFtPYmoubWFnaWNdIHRvIGNvbnZlcnQgYmFjayBhbmQgZm9ydGggYmV0d2VlbiBhIGRlZmVycmVkIGFuZCBpdHMgY29uY3JldGVcbiAgIHJlcHJlc2VudGF0aW9uIGFzIGFuIGl2YXIuICBUaGlzIFtPYmoubWFnaWNdIGlzIHNhZmUgYmVjYXVzZSB0aGUgcmVwcmVzZW50YXRpb24gaXNcbiAgIGFsd2F5cyBqdXN0IGFuIGl2YXIsIGFuZCB0aGUgY292YXJpYW5jZSBmb2xsb3dzIGZyb20gdGhlIGZhY3QgdGhhdCBhbGwgdGhlIGRlZmVycmVkXG4gICBvcGVyYXRpb25zIGFyZSBlcXVpdmFsZW50IHRvIHRob3NlIGltcGxlbWVudGVkIGRpcmVjdGx5IG9uIHRvcCBvZiB0aGVcbiAgIFtlc3NlbmNlX29mX2RlZmVycmVkXS5cblxuICAge1tcbiAgICAgdHlwZSAoKydhLCAnZXhlY3V0aW9uX2NvbnRleHQpIGVzc2VuY2Vfb2ZfZGVmZXJyZWQgPVxuICAgICAgIHsgcGVlayAgICAgICAgICAgICAgICAgICAgICA6IHVuaXQgLT4gJ2Egb3B0aW9uXG4gICAgICAgOyBpc19kZXRlcm1pbmVkICAgICAgICAgICAgIDogdW5pdCAtPiBib29sXG4gICAgICAgOyB1cG9uICAgICAgICAgICAgICAgICAgICAgIDogKCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgICAgICA7IHVwb24nICAgICAgICAgICAgICAgICAgICAgOiAoJ2EgLT4gdW5pdCkgLT4gVW5yZWdpc3Rlci50XG4gICAgICAgOyBpbnN0YWxsX3JlbW92YWJsZV9oYW5kbGVyIDogKCdhLCAnZXhlY3V0aW9uX2NvbnRleHQpIFJhd19oYW5kbGVyLnQgLT4gVW5yZWdpc3Rlci50OyB9IF19ICopXG5cbnR5cGUgKydhIHQgPSAnYSBUeXBlcy5EZWZlcnJlZC50XG5cbigqIHRoZSBhYnN0cmFjdCBjb3ZhcmlhbnQgdHlwZSwgZXF1aXZhbGVudCB0byBpdmFyICopXG5cbmxldCBvZl9pdmFyICh0eXBlIGEpIChpdmFyIDogYSBJdmFyLnQpIDogYSB0ID0gT2JqLm1hZ2ljIGl2YXJcbmxldCB0b19pdmFyICh0eXBlIGEpIHQgOiBhIEl2YXIudCA9IE9iai5tYWdpYyAodCA6IGEgdClcbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IEl2YXIuaW52YXJpYW50IGludmFyaWFudF9hICh0b19pdmFyIHQpXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gSXZhci5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19pdmFyIHQpXG5sZXQgcGVlayB0ID0gSXZhci5wZWVrICh0b19pdmFyIHQpXG5sZXQgcmV0dXJuIGEgPSBvZl9pdmFyIChJdmFyLmNyZWF0ZV9mdWxsIGEpXG5sZXQgaXNfZGV0ZXJtaW5lZCB0ID0gSXZhci5pc19mdWxsICh0b19pdmFyIHQpXG5cbmxldCB2YWx1ZV9leG4gdCA9XG4gIEl2YXIudmFsdWVcbiAgICAodG9faXZhciB0KVxuICAgIH5pZl9lbXB0eV90aGVuX2ZhaWx3aXRoOlwiRGVmZXJyZWQudmFsdWVfZXhuIGNhbGxlZCBvbiB1bmRldGVybWluZWQgZGVmZXJyZWRcIlxuOztcblxubGV0IHVwb24gdCBmID0gSXZhci51cG9uICh0b19pdmFyIHQpIGZcblxubGV0IGNyZWF0ZSBmID1cbiAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGYgcmVzdWx0O1xuICBvZl9pdmFyIHJlc3VsdFxuOztcblxuKCogZG9uJ3QgdXNlIFtjcmVhdGVdIGhlcmUgYXMgaXQgd291bGQgYWxsb2NhdGUgb25lIG1vcmUgY2xvc3VyZSAqKVxubGV0IGJpbmQgdCB+ZiA9XG4gIGxldCBiaW5kX3Jlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIHVwb24gdCAoZnVuIGEgLT4gSXZhci5jb25uZWN0IH5iaW5kX3Jlc3VsdCB+YmluZF9yaHM6KHRvX2l2YXIgKGYgYSkpKTtcbiAgb2ZfaXZhciBiaW5kX3Jlc3VsdFxuOztcblxubGV0IGFkZF9oYW5kbGVyIHQgZiBleGVjdXRpb25fY29udGV4dCA9IEl2YXIuYWRkX2hhbmRsZXIgKHRvX2l2YXIgdCkgZiBleGVjdXRpb25fY29udGV4dFxubGV0IHJlbW92ZV9oYW5kbGVyIHQgaCA9IEl2YXIucmVtb3ZlX2hhbmRsZXIgKHRvX2l2YXIgdCkgaFxuIiwib3BlbiBDb3JlXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDBcbmluY2x1ZGUgSXZhcjBcblxubGV0IHJlYWQgPSBEZWZlcnJlZC5vZl9pdmFyXG5sZXQgZmlsbF9pZl9lbXB0eSB0IHYgPSBpZiBpc19lbXB0eSB0IHRoZW4gZmlsbCB0IHZcblxuaW5jbHVkZVxuICBCaW5hYmxlLk9mX2JpbmFibGUxX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgIChPcHRpb24pXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHRvX2JpbmFibGUgdCA9IHBlZWsgdFxuXG4gICAgICBsZXQgb2ZfYmluYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBjcmVhdGUgKClcbiAgICAgICAgfCBTb21lIGEgLT4gY3JlYXRlX2Z1bGwgYVxuICAgICAgOztcbiAgICBlbmQpXG4iLCIoKiogW01vbmFkX3NlcXVlbmNlLlNdIGlzIGEgZ2VuZXJpYyBpbnRlcmZhY2Ugc3BlY2lmeWluZyBmdW5jdGlvbnMgdGhhdCBkZWFsIHdpdGggYVxuICAgIGNvbnRhaW5lciBhbmQgYSBtb25hZC4gIEl0IGlzIHNwZWNpYWxpemVkIHRvIHRoZSBbRGVmZXJyZWRdIG1vbmFkIGFuZCB1c2VkIHdpdGhcbiAgICB2YXJpb3VzIGNvbnRhaW5lcnMgaW4gbW9kdWxlcyBbRGVmZXJyZWQuQXJyYXldLCBbRGVmZXJyZWQuTGlzdF0sIFtEZWZlcnJlZC5RdWV1ZV0sIGFuZFxuICAgIFtEZWZlcnJlZC5TZXF1ZW5jZV0uICBUaGUgW01vbmFkX3NlcXVlbmNlLmhvd10gdHlwZSBzcGVjaWZpZXMgdGhlIHBhcmFsbGVsaXNtIG9mXG4gICAgY29udGFpbmVyIGl0ZXJhdG9ycy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgaG93ID1cbiAgWyBgUGFyYWxsZWwgKCoqIGxpa2UgW2BNYXhfY29uY3VycmVudF9qb2JzIEludC5tYXhfdmFsdWVdICopXG4gIHwgYFNlcXVlbnRpYWxcbiAgKCoqIFtgU2VxdWVudGlhbF0gaXMgb2Z0ZW4gYnV0IG5vdCBhbHdheXMgdGhlIHNhbWUgYXMgW2BNYXhfY29uY3VycmVudF9qb2JzIDFdXG4gICAgICAoZm9yIGV4YW1wbGUsIHRoZXkgZGlmZmVyIGluIHRoZSBbT3JfZXJyb3JdIG1vbmFkKS4gKilcbiAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBvZiBpbnRcbiAgXVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIG1vbmFkXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBmb2xkaSA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihpbnQgLT4gJ2IgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIG1vbmFkXG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiIG1vbmFkKSAtPiAnYiBtb25hZFxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gJ2Egb3B0aW9uIG1vbmFkXG4gIHZhbCBmaW5kaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+IChpbnQgKiAnYSkgb3B0aW9uIG1vbmFkXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRfbWFwaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+ICdiIG9wdGlvbiBtb25hZCkgLT4gJ2Igb3B0aW9uIG1vbmFkXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGV4aXN0c2kgOiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiBib29sIG1vbmFkKSAtPiBib29sIG1vbmFkXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sIG1vbmFkKSAtPiBib29sIG1vbmFkXG4gIHZhbCBmb3JfYWxsaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGFsbCA6ICdhIG1vbmFkIHQgLT4gJ2EgdCBtb25hZFxuICB2YWwgYWxsX3VuaXQgOiB1bml0IG1vbmFkIHQgLT4gdW5pdCBtb25hZFxuXG4gICgqKiB7MiBEZWZlcnJlZCBpdGVyYXRvcnN9XG5cbiAgICAgIEluIHRoZSBmb2xsb3dpbmcsIHRoZSBkZWZhdWx0IFtob3ddIGlzIFtgU2VxdWVudGlhbF0gKilcblxuICB2YWwgaW5pdCA6ID9ob3c6aG93IC0+IGludCAtPiBmOihpbnQgLT4gJ2EgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGl0ZXIgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQgbW9uYWQpIC0+IHVuaXQgbW9uYWRcbiAgdmFsIGl0ZXJpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gdW5pdCBtb25hZCkgLT4gdW5pdCBtb25hZFxuICB2YWwgbWFwIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOignYSAtPiAnYiBtb25hZCkgLT4gJ2IgdCBtb25hZFxuICB2YWwgbWFwaSA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+ICdiIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBmaWx0ZXIgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGZpbHRlcmkgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiBib29sIG1vbmFkKSAtPiAnYSB0IG1vbmFkXG4gIHZhbCBmaWx0ZXJfbWFwIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGZpbHRlcl9tYXBpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBjb25jYXRfbWFwIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOignYSAtPiAnYiB0IG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBjb25jYXRfbWFwaSA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+ICdiIHQgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbmVuZFxuIiwib3BlbiBDb3JlXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuaW5jbHVkZSBEZWZlcnJlZDBcblxuKCogVG8gYXZvaWQgYSBzcGFjZSBsZWFrLCBpdCBpcyBuZWNlc3NhcnkgdGhhdCBbbmV2ZXJdIGFsbG9jYXRlcyBhIG5ldyBpdmFyIHdoZW5ldmVyIGl0IGlzXG4gICBjYWxsZWQuICBDb2RlIGNhbiBiaW5kIG9uIFtuZXZlciAoKV0sIHNvIGlmIHdlIHJlLXVzZWQgdGhlIGl2YXIsIHdlIGNvdWxkIGVuZGxlc3NseVxuICAgYWNjdW11bGF0ZSBoYW5kbGVycy4gKilcbmxldCBuZXZlciAoKSA9IEl2YXIucmVhZCAoSXZhci5jcmVhdGUgKCkpXG5cbm1vZHVsZSBNID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBEZWZlcnJlZDBcblxuICAgIGxldCBtYXAgdCB+ZiA9XG4gICAgICAoKiBXZSBtYW51YWxseSBpbmxpbmUgW0RlZmVycmVkLmNyZWF0ZV0gaGVyZSwgYmVjYXVzZSB0aGUgbm9uLWZsYW1iZGEgY29tcGlsZXIgaXNuJ3RcbiAgICAgICAgIGFibGUgdG8gb3B0aW1pemUgYXdheSB0aGUgY2xvc3VyZSB0aGF0IHdvdWxkIGJlIGJlIGNyZWF0ZWQuICopXG4gICAgICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICAgIHVwb24gdCAoZnVuIGEgLT4gSXZhci5maWxsIHJlc3VsdCAoZiBhKSk7XG4gICAgICBvZl9pdmFyIHJlc3VsdFxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5pbmNsdWRlIE1cblxuKCogV2UgcmViaW5kIGFsbCB0aGUgdmFyaW91cyBbcmV0dXJuXXMgYmVjYXVzZSB0aGUgdXNlIG9mIHRoZSBbTW9uYWQuTWFrZV0gZnVuY3RvclxuICAgY2F1c2VzIHRoZSBjb21waWxlciB0byBub3QgaW5saW5lIFtyZXR1cm5dLCBhbmQgaGVuY2UgbWFrZXMgaXQgaW1wb3NzaWJsZSB0b1xuICAgc3RhdGljYWxseSBhbGxvY2F0ZSBjb25zdGFudHMgbGlrZSBbcmV0dXJuICgpXS4gIEJ5IHJlYmluZGluZyBbcmV0dXJuXSBhc1xuICAgW0RlZmVycmVkMC5yZXR1cm5dLCB0aGUgY29tcGlsZXIgY2FuIHNlZSB0aGF0OlxuXG4gICB7W1xuICAgICByZXR1cm4gYSA9IHsgSXZhci5JbW11dGFibGUuIGNlbGwgPSBGdWxsIGEgfSBdfVxuXG4gICBBbmQgaGVuY2UsIGlmIFthXSBpcyBjb25zdGFudCwgdGhlbiB0aGUgcmV0dXJuIGlzIGNvbnN0YW50IGFuZCBjYW4gYmUgc3RhdGljYWxseVxuICAgYWxsb2NhdGVkLiAgV2hlbiBjb21waWxpbmcgd2l0aCBmbGFtYmRhLCB0aGUgY29tcGlsZXIgaW5saW5lcyBbcmV0dXJuXSBhbmQgdGhpcyBtYW51YWxcbiAgIHJlYmluZGluZyB3b3VsZCBub3QgaGVscDsgd2UndmUgZGVjaWRlZCB0byBkbyBpdCBhbnl3YXkgc28gdGhhdCBub24tZmxhbWJkYSBidWlsZHNcbiAgIGdldCB0aGUgb3B0aW1pemF0aW9uLiAqKVxubGV0IHJldHVybiA9IERlZmVycmVkMC5yZXR1cm5cblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNLkxldF9zeW50YXhcblxuICBsZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBNLkxldF9zeW50YXguTGV0X3N5bnRheFxuXG4gICAgbGV0IHJldHVybiA9IERlZmVycmVkMC5yZXR1cm5cbiAgZW5kXG5lbmRcblxub3BlbiBMZXRfc3ludGF4XG5cbigqIFdlIHNoYWRvdyBbYWxsXSBvbi1wdXJwb3NlIGhlcmUsIHNpbmNlIHRoZSBkZWZhdWx0IGRlZmluaXRpb24gaW50cm9kdWNlcyBhIGNoYWluIG9mXG4gICBiaW5kcyBhcyBsb25nIGFzIHRoZSBsaXN0LiAqKVxubGV0IGFsbCA9IGBNYWtlX3N1cmVfdG9fZGVmaW5lX2FsbF9lbHNld2hlcmVcbmxldCBfID0gYWxsXG5sZXQgdW5pdCA9IHJldHVybiAoKVxuXG5sZXQgYm90aCB0MSB0MiA9XG4gIGNyZWF0ZSAoZnVuIHJlc3VsdCAtPiB1cG9uIHQxIChmdW4gYTEgLT4gdXBvbiB0MiAoZnVuIGEyIC0+IEl2YXIuZmlsbCByZXN1bHQgKGExLCBhMikpKSlcbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbGV0ICggPj4+ICkgPSB1cG9uXG4gIGxldCBwcHhfYm90aCA9IGJvdGhcbmVuZFxuXG5vcGVuIEluZml4XG5cbmxldCBkb24ndF93YWl0X2ZvciAoXyA6IHVuaXQgdCkgPSAoKVxuXG5tb2R1bGUgQ2hvaWNlID0gc3RydWN0XG4gIHR5cGUgKydhIHQgPSBUIDogJ2IgRGVmZXJyZWQwLnQgKiAoJ2IgLT4gJ2EpIC0+ICdhIHRcblxuICBsZXQgbWFwIChUICh0LCBmMSkpIH5mOmYyID0gVCAodCwgZnVuIHggLT4gZjIgKGYxIHgpKVxuZW5kXG5cbm1vZHVsZSBVbnJlZ2lzdGVyID0gc3RydWN0XG4gICgqIFRoaXMgcmVwcmVzZW50YXRpb24gc2F2ZXMgMm4gd29yZHMgZm9yIGEgbGlzdCBvZiBuIGNob2ljZXMuICopXG4gIHR5cGUgdCA9XG4gICAgfCBOaWwgOiB0XG4gICAgfCBDb25zIDogJ2EgRGVmZXJyZWQwLnQgKiAnYSBEZWZlcnJlZDAuSGFuZGxlci50ICogdCAtPiB0XG5cbiAgbGV0IHJlYyBwcm9jZXNzID0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAodCwgaGFuZGxlciwgcmVzdCkgLT5cbiAgICAgIHJlbW92ZV9oYW5kbGVyIHQgaGFuZGxlcjtcbiAgICAgIHByb2Nlc3MgcmVzdFxuICA7O1xuZW5kXG5cbmxldCBjaG9pY2UgdCBmID0gQ2hvaWNlLlQgKHQsIGYpXG5cbmxldCBlbmFibGVkIGNob2ljZXMgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHVucmVnaXN0ZXJzID0gcmVmIFVucmVnaXN0ZXIuTmlsIGluXG4gIGxldCByZWFkeSBfID1cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgVW5yZWdpc3Rlci5wcm9jZXNzICF1bnJlZ2lzdGVycztcbiAgICAgIEl2YXIuZmlsbCByZXN1bHQgKGZ1biAoKSAtPlxuICAgICAgICBMaXN0LnJldlxuICAgICAgICAgIChMaXN0LmZvbGQgY2hvaWNlcyB+aW5pdDpbXSB+ZjooZnVuIGFjIChDaG9pY2UuVCAodCwgZikpIC0+XG4gICAgICAgICAgICAgbWF0Y2ggcGVlayB0IHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gYWNcbiAgICAgICAgICAgICB8IFNvbWUgdiAtPiBmIHYgOjogYWMpKSkpXG4gIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGluXG4gIHVucmVnaXN0ZXJzXG4gIDo9IExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OlVucmVnaXN0ZXIuTmlsIH5mOihmdW4gYWNjIChDaG9pY2UuVCAodCwgXykpIC0+XG4gICAgQ29ucyAodCwgRGVmZXJyZWQwLmFkZF9oYW5kbGVyIHQgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQsIGFjYykpO1xuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG5sZXQgcmVjIGNob29zZV9yZXN1bHQgY2hvaWNlcyA9XG4gIG1hdGNoIGNob2ljZXMgd2l0aFxuICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICB8IENob2ljZS5UICh0LCBmKSA6OiBjaG9pY2VzIC0+XG4gICAgKG1hdGNoIHBlZWsgdCB3aXRoXG4gICAgIHwgTm9uZSAtPiBjaG9vc2VfcmVzdWx0IGNob2ljZXNcbiAgICAgfCBTb21lIHYgLT4gZiB2KVxuOztcblxubGV0IGNob29zZSBjaG9pY2VzID1cbiAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCB1bnJlZ2lzdGVycyA9IHJlZiBVbnJlZ2lzdGVyLk5pbCBpblxuICBsZXQgcmVhZHkgXyA9XG4gICAgaWYgSXZhci5pc19lbXB0eSByZXN1bHRcbiAgICB0aGVuIChcbiAgICAgIFVucmVnaXN0ZXIucHJvY2VzcyAhdW5yZWdpc3RlcnM7XG4gICAgICBJdmFyLmZpbGwgcmVzdWx0IChjaG9vc2VfcmVzdWx0IGNob2ljZXMpKVxuICBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBpblxuICB1bnJlZ2lzdGVyc1xuICA6PSBMaXN0LmZvbGQgY2hvaWNlcyB+aW5pdDpVbnJlZ2lzdGVyLk5pbCB+ZjooZnVuIGFjYyAoQ2hvaWNlLlQgKHQsIF8pKSAtPlxuICAgIENvbnMgKHQsIERlZmVycmVkMC5hZGRfaGFuZGxlciB0IHJlYWR5IGV4ZWN1dGlvbl9jb250ZXh0LCBhY2MpKTtcbiAgSXZhci5yZWFkIHJlc3VsdFxuOztcblxubGV0IGFueV9mIHRzIGYgPSBjaG9vc2UgKExpc3QubWFwIHRzIH5mOihmdW4gdCAtPiBjaG9pY2UgdCBmKSlcbmxldCBhbnkgdHMgPSBhbnlfZiB0cyBGbi5pZFxubGV0IGFueV91bml0IHRzID0gYW55X2YgdHMgKEZuLmlnbm9yZSA6IHVuaXQgLT4gdW5pdClcblxubGV0IGZvcl8gc3RhcnQgfnRvXyB+ZG9fID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPiB0b19cbiAgICB0aGVuIHJldHVybiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0JWJpbmQgKCkgPSBkb18gaSBpblxuICAgICAgbG9vcCAoaSArIDEpKVxuICBpblxuICBsb29wIHN0YXJ0XG47O1xuXG5sZXQgcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGYgPVxuICBjcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgIGxldCByZWMgbG9vcCBzdGF0ZSA9XG4gICAgICBmIHN0YXRlXG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgYFJlcGVhdCBzdGF0ZSAtPiBsb29wIHN0YXRlXG4gICAgICB8IGBGaW5pc2hlZCByZXN1bHQgLT4gSXZhci5maWxsIGZpbmlzaGVkIHJlc3VsdFxuICAgIGluXG4gICAgbG9vcCBzdGF0ZSlcbjs7XG5cbmxldCBmb3JldmVyIHN0YXRlIGYgPVxuICByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgKGZ1biBzdGF0ZSAtPlxuICAgIGxldCVtYXAgc3RhdGUgPSBmIHN0YXRlIGluXG4gICAgYFJlcGVhdCBzdGF0ZSlcbiAgPj4+IG5ldmVyX3JldHVybnNcbjs7XG5cbnR5cGUgaG93ID0gTW9uYWRfc2VxdWVuY2UuaG93IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSB0eXBlIE1vbmFkX3NlcXVlbmNlID0gTW9uYWRfc2VxdWVuY2UuUyB3aXRoIHR5cGUgJ2EgbW9uYWQgOj0gJ2EgdFxuXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBjcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBiID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBJdmFyLmZpbGwgcmVzdWx0IGJcbiAgICAgIHwgeCA6OiB4cyAtPiBmIGIgeCA+Pj4gZnVuIGIgLT4gbG9vcCB4cyBiXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbmxldCBzZXFtYXAgdCB+ZiA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGJzIGEgLT4gZiBhID4+fCBmdW4gYiAtPiBiIDo6IGJzKSA+PnwgTGlzdC5yZXZcbmxldCBhbGwgZHMgPSBzZXFtYXAgZHMgfmY6Rm4uaWRcbmxldCBhbGxfdW5pdCBkcyA9IGZvbGQgZHMgfmluaXQ6KCkgfmY6KGZ1biAoKSBkIC0+IGQpXG5sZXQgb2sgeCA9IHggPj58IGZ1biB4IC0+IE9rIHhcbiIsIm9wZW4gRGVmZXJyZWQxXG5pbmNsdWRlIEluZml4XG5pbmNsdWRlIExldF9zeW50YXhcblxubGV0IGNob2ljZSA9IGNob2ljZVxubGV0IGNob29zZSA9IGNob29zZVxubGV0IGRvbid0X3dhaXRfZm9yID0gZG9uJ3Rfd2FpdF9mb3JcbmxldCBuZXZlciA9IG5ldmVyXG5sZXQgcmV0dXJuID0gcmV0dXJuXG5sZXQgdXBvbiA9IHVwb25cbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHUgPVxuICB8IEVtcHR5IG9mICdhIEl2YXIudFxuICB8IEZ1bGxcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgJ2EgdCA9ICdhIHUgcmVmIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgXyB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBtYXRjaCAhdCB3aXRoXG4gICAgfCBGdWxsIC0+ICgpXG4gICAgfCBFbXB0eSBpdmFyIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKSlcbjs7XG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgaXZhciA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCB0ID0gcmVmIChFbXB0eSBpdmFyKSBpblxuICB0LCBJdmFyLnJlYWQgaXZhclxuOztcblxubGV0IGlzX2VtcHR5IHQgPVxuICBtYXRjaCAhdCB3aXRoXG4gIHwgRW1wdHkgXyAtPiB0cnVlXG4gIHwgRnVsbCAtPiBmYWxzZVxuOztcblxubGV0IGZpbGwgdCBhID1cbiAgbWF0Y2ggIXQgd2l0aFxuICB8IEVtcHR5IGkgLT5cbiAgICB0IDo9IEZ1bGw7XG4gICAgSXZhci5maWxsIGkgYVxuICB8IEZ1bGwgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJhdHRlbXB0IHRvIGZpbGwgZnVsbCBpdmFyXCJdXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIFN0cmVhbSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBuZXh0IERlZmVycmVkLnRcblxuICBhbmQgJ2EgbmV4dCA9ICdhIFR5cGVzLlN0cmVhbS5uZXh0ID1cbiAgICB8IE5pbFxuICAgIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBsZXQgcmVjIGxvb3AgZCBhYyA6IFNleHAudCA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgICAgfCBOb25lIC0+IExpc3QgKExpc3QucmV2IChTZXhwLkF0b20gXCIuLi5cIiA6OiBhYykpXG4gICAgICB8IFNvbWUgTmlsIC0+IExpc3QgKExpc3QucmV2IGFjKVxuICAgICAgfCBTb21lIChDb25zIChhLCB0KSkgLT4gbG9vcCB0IChzZXhwX29mX2EgYSA6OiBhYylcbiAgICBpblxuICAgIGxvb3AgdCBbXVxuICA7O1xuXG4gIGxldCBuZXh0IHQgPSB0XG5lbmRcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuVGFpbC50ID1cbiAgeyAoKiBbbmV4dF0gcG9pbnRzIGF0IHRoZSB0YWlsIG9mIHRoZSBzdHJlYW0gKikgbXV0YWJsZSBuZXh0IDogJ2EgU3RyZWFtLm5leHQgSXZhci50IH1cbltAQGRlcml2aW5nIGZpZWxkc11cblxubGV0IHNleHBfb2ZfdCBfIHQgOiBTZXhwLnQgPVxuICBBdG9tIChpZiBJdmFyLmlzX2VtcHR5IHQubmV4dCB0aGVuIFwiPG9wZW4gdGFpbD5cIiBlbHNlIFwiPGNsb3NlZCB0YWlsPlwiKVxuOztcblxubGV0IGNyZWF0ZSAoKSA9IHsgbmV4dCA9IEl2YXIuY3JlYXRlICgpIH1cbmxldCBjb2xsZWN0IHQgPSBJdmFyLnJlYWQgKG5leHQgdClcbmxldCBpc19jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCAobmV4dCB0KVxuXG5sZXQgZmlsbF9leG4gdCB2ID1cbiAgaWYgaXNfY2xvc2VkIHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcInN0cmVhbSBpcyBjbG9zZWRcIl0gZWxzZSBJdmFyLmZpbGwgKG5leHQgdCkgdlxuOztcblxubGV0IGNsb3NlX2V4biB0ID0gZmlsbF9leG4gdCBOaWxcbmxldCBjbG9zZV9pZl9vcGVuIHQgPSBpZiBub3QgKGlzX2Nsb3NlZCB0KSB0aGVuIEl2YXIuZmlsbCAobmV4dCB0KSBOaWxcblxubGV0IGV4dGVuZCB0IHYgPVxuICBsZXQgbmV4dCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGZpbGxfZXhuIHQgKENvbnMgKHYsIEl2YXIucmVhZCBuZXh0KSk7XG4gIHQubmV4dCA8LSBuZXh0XG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBTdHJlYW0gPSBUYWlsLlN0cmVhbVxubW9kdWxlIE1vbml0b3IgPSBNb25pdG9yMFxuaW5jbHVkZSBNb25pdG9yXG5cbnR5cGUgbW9uaXRvciA9IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5uYW1lOmlnbm9yZVxuICAgICAgfmhlcmU6aWdub3JlXG4gICAgICB+aWQ6aWdub3JlXG4gICAgICB+Zm9yd2FyZGluZzppZ25vcmVcbiAgICAgIH5uZXh0X2Vycm9yOihjaGVjayAoZnVuIG5leHRfZXJyb3IgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IG5leHRfZXJyb3IpKSlcbiAgICAgIH5oYW5kbGVyc19mb3JfYWxsX2Vycm9yczppZ25vcmVcbiAgICAgIH50YWlsc19mb3JfYWxsX2Vycm9yczppZ25vcmVcbiAgICAgIH5oYXNfc2Vlbl9lcnJvcjppZ25vcmUpXG47O1xuXG5sZXQgY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSA9IFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpXG5sZXQgY3VycmVudCAoKSA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1vbml0b3IgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpXG5cbnR5cGUgJ2Egd2l0aF9vcHRpb25hbF9tb25pdG9yX25hbWUgPVxuICA/aGVyZTpTb3VyY2VfY29kZV9wb3NpdGlvbi50IC0+ID9pbmZvOkluZm8udCAtPiA/bmFtZTpzdHJpbmcgLT4gJ2FcblxubGV0IGRldGFjaCB0ID0gdC5mb3J3YXJkaW5nIDwtIERldGFjaGVkXG5cbnR5cGUgaGFuZGxlcl9zdGF0ZSA9XG4gIHwgVW5pbml0aWFsaXplZFxuICB8IFJ1bm5pbmcgb2YgKEV4ZWN1dGlvbl9jb250ZXh0LnQgKiAoZXhuIC0+IHVuaXQpKSBCYWcuRWx0LnRcbiAgfCBUZXJtaW5hdGVkXG5cbmxldCBkZXRhY2hfYW5kX2l0ZXJfZXJyb3JzIHQgfmYgPVxuICBkZXRhY2ggdDtcbiAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICBsZXQgaGFuZGxlcl9zdGF0ZV9yZWYgPSByZWYgVW5pbml0aWFsaXplZCBpblxuICBsZXQgcnVuX2YgZXhuID1cbiAgICBtYXRjaCAhaGFuZGxlcl9zdGF0ZV9yZWYgd2l0aFxuICAgIHwgVW5pbml0aWFsaXplZCAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFRlcm1pbmF0ZWQgLT4gKClcbiAgICB8IFJ1bm5pbmcgYmFnX2VsdCAtPlxuICAgICAgKHRyeSBmIGV4biB3aXRoXG4gICAgICAgfCBpbm5lcl9leG4gLT5cbiAgICAgICAgIGhhbmRsZXJfc3RhdGVfcmVmIDo9IFRlcm1pbmF0ZWQ7XG4gICAgICAgICBCYWcucmVtb3ZlIHQuaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgYmFnX2VsdDtcbiAgICAgICAgICgqIFtydW5fZl0gYWx3YXlzIHJ1bnMgaW4gW2V4ZWN1dGlvbl9jb250ZXh0XS4gIEhlbmNlLCBbcmFpc2UgaW5uZXJfZXhuXSBzZW5kc1xuICAgICAgICAgICAgW2lubmVyX2V4bl0gdG8gW2V4ZWN1dGlvbl9jb250ZXh0XSdzIG1vbml0b3IsIGkuZS4gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW5cbiAgICAgICAgICAgIFtkZXRhY2hfYW5kX2l0ZXJfZXJyb3JzXSB3YXMgY2FsbGVkLiAqKVxuICAgICAgICAgcmFpc2UgaW5uZXJfZXhuKVxuICBpblxuICBoYW5kbGVyX3N0YXRlX3JlZlxuICA6PSBSdW5uaW5nIChCYWcuYWRkIHQuaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgKGV4ZWN1dGlvbl9jb250ZXh0LCBydW5fZikpXG47O1xuXG5sZXQgZGV0YWNoX2FuZF9nZXRfZXJyb3Jfc3RyZWFtIHQgPVxuICBkZXRhY2ggdDtcbiAgbGV0IHRhaWwgPSBUYWlsLmNyZWF0ZSAoKSBpblxuICB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzIDwtIHRhaWwgOjogdC50YWlsc19mb3JfYWxsX2Vycm9ycztcbiAgVGFpbC5jb2xsZWN0IHRhaWxcbjs7XG5cbmxldCBnZXRfbmV4dF9lcnJvciB0ID0gSXZhci5yZWFkIHQubmV4dF9lcnJvclxuXG5sZXQgZGV0YWNoX2FuZF9nZXRfbmV4dF9lcnJvciB0ID1cbiAgZGV0YWNoIHQ7XG4gIGdldF9uZXh0X2Vycm9yIHRcbjs7XG5cbmxldCBjcmVhdGUgP2hlcmUgP2luZm8gP25hbWUgKCkgPVxuICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICBjcmVhdGVfd2l0aF9wYXJlbnQgP2hlcmUgP2luZm8gP25hbWUgKFNvbWUgcGFyZW50KVxuOztcblxubW9kdWxlIE1vbml0b3JfZXhuID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBleG4gOiBleG5cbiAgICA7IGJhY2t0cmFjZSA6IEJhY2t0cmFjZS50IG9wdGlvblxuICAgIDsgYmFja3RyYWNlX2hpc3RvcnkgOiBCYWNrdHJhY2UudCBsaXN0XG4gICAgOyBtb25pdG9yIDogTW9uaXRvci50XG4gICAgfVxuXG4gIGxldCBiYWNrdHJhY2UgdCA9IHQuYmFja3RyYWNlXG4gIGxldCBleHRyYWN0X2V4biB0ID0gdC5leG5cblxuICBsZXQgYmFja3RyYWNlX3RydW5jYXRpb25faGV1cmlzdGljcyA9XG4gICAgbGV0IGpvYl9xdWV1ZSA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwiam9iX3F1ZXVlLm1sXFxcIlwiIGluXG4gICAgbGV0IGRlZmVycmVkMCA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwiZGVmZXJyZWQwLm1sXFxcIlwiIGluXG4gICAgbGV0IGRlZmVycmVkMSA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwiZGVmZXJyZWQxLm1sXFxcIlwiIGluXG4gICAgbGV0IG1vbml0b3IgPSBcIkNhbGxlZCBmcm9tIGZpbGUgXFxcIm1vbml0b3IubWxcXFwiXCIgaW5cbiAgICBsZXQgaW1wb3J0MCA9IFwiUmFpc2VkIGF0IGZpbGUgXFxcImltcG9ydDAubWxcXFwiXCIgaW5cbiAgICBsZXQgZXJyb3IgPSBcIkNhbGxlZCBmcm9tIGZpbGUgXFxcImVycm9yLm1sXFxcIlwiIGluXG4gICAgZnVuIHRyYWNlcyAtPlxuICAgICAgKCogLi4vdGVzdC90ZXN0X3RyeV93aXRoX2Vycm9yX2Rpc3BsYXkubWwgbWFrZXMgc3VyZSB0aGlzIHN0YXlzIHVwLXRvLWRhdGUuICopXG4gICAgICBsZXQgdHJhY2VzID1cbiAgICAgICAgbWF0Y2ggdHJhY2VzIHdpdGhcbiAgICAgICAgfCB0MSA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MSB+cHJlZml4OmltcG9ydDAgLT5cbiAgICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICAgIHwgdDIgOjogcmVzdCB3aGVuIFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDplcnJvciAtPlxuICAgICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgICAgfCB0MyA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MyB+cHJlZml4OmVycm9yIC0+IHJlc3RcbiAgICAgICAgICAgICAgfCBfIC0+IHJlc3QpXG4gICAgICAgICAgIHwgXyAtPiByZXN0KVxuICAgICAgICB8IF8gLT4gdHJhY2VzXG4gICAgICBpblxuICAgICAgbWF0Y2ggTGlzdC5yZXYgdHJhY2VzIHdpdGhcbiAgICAgIHwgdDEgOjogcmVzdCB3aGVuIFN0cmluZy5pc19wcmVmaXggdDEgfnByZWZpeDpqb2JfcXVldWUgLT5cbiAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgfCB0MiA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MiB+cHJlZml4OmpvYl9xdWV1ZSAtPlxuICAgICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICAgICB8IHQyIDo6IHJlc3RcbiAgICAgICAgICAgICAgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQyIH5wcmVmaXg6ZGVmZXJyZWQwXG4gICAgICAgICAgICAgICAgKCogYmluZCAqKVxuICAgICAgICAgICAgICAgIHx8IFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDpkZWZlcnJlZDFcbiAgICAgICAgICAgICAgICAoKiBtYXAgKilcbiAgICAgICAgICAgICAgICB8fCBTdHJpbmcuaXNfcHJlZml4IHQyIH5wcmVmaXg6bW9uaXRvclxuICAgICAgICAgICAgICAoKiB0cnlfd2l0aCAqKSAtPiBMaXN0LnJldiByZXN0XG4gICAgICAgICAgICB8IF8gLT4gTGlzdC5yZXYgcmVzdClcbiAgICAgICAgIHwgXyAtPiBMaXN0LnJldiByZXN0KVxuICAgICAgfCBfIC0+IHRyYWNlc1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgeyBleG47IGJhY2t0cmFjZTsgYmFja3RyYWNlX2hpc3Rvcnk7IG1vbml0b3IgfSA9XG4gICAgbGV0IG1vbml0b3IgPVxuICAgICAgbGV0IG5hbWUgPVxuICAgICAgICBtYXRjaCBJbmZvLnRvX3N0cmluZ19odW0gbW9uaXRvci5uYW1lIHdpdGhcbiAgICAgICAgfCBcIlwiIC0+IE5vbmVcbiAgICAgICAgfCBzIC0+IFNvbWUgc1xuICAgICAgaW5cbiAgICAgIGxldCBwb3MgPVxuICAgICAgICBtYXRjaCBtb25pdG9yLmhlcmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgaGVyZSAtPlxuICAgICAgICAgICgqIFdlIGRpc3BsYXkgdGhlIGZ1bGwgZmlsZW5hbWUsIHdoZXJlYXMgYmFja3RyYWNlcyBvbmx5IGhhdmUgYmFzZW5hbWVzLCBidXRcbiAgICAgICAgICAgICBwZXJoYXBzIHRoYXQncyB3aGF0IHNob3VsZCBjaGFuZ2UuICopXG4gICAgICAgICAgbGV0IGNvbHVtbiA9IGhlcmUucG9zX2NudW0gLSBoZXJlLnBvc19ib2wgaW5cbiAgICAgICAgICBTb21lXG4gICAgICAgICAgICAoKiBXZSBoaWRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIHdoZW4gW2FtX3J1bm5pbmdfdGVzdF0gdG8gbWFrZSB0ZXN0IG91dHB1dFxuICAgICAgICAgICAgICAgbW9yZSByb2J1c3QuICBUaGlzIHNhdmVzIHBlb3BsZSBtYW51YWxseSBoaWRpbmcgdGhlIG51bWJlcnMgb3IgZXZlbiB3b3JzZSxcbiAgICAgICAgICAgICAgIGxlYXZpbmcgdGhlbSBpbiB0ZXN0IG91dHB1dC4gIEhpZGluZyBpbiB0ZXN0IGlzIGRpZmZlcmVudCBjaG9pY2UgZm9yXG4gICAgICAgICAgICAgICBiZWhhdmlvciB0aGFuIG91ciBjb2RlYmFzZSBtYWtlcyBmb3IgW0JhY2t0cmFjZS5lbGlkZV0sIHdoaWNoIGhhcyBkZWZhdWx0XG4gICAgICAgICAgICAgICBbZmFsc2VdLCBhbmQgdGh1cyBzaG93cyBiYWNrdHJhY2VzIGluIHRlc3QuICBUaGVyZSBhcmUgYSBjb3VwbGUgcmVhc29ucyBmb3JcbiAgICAgICAgICAgICAgIHRoaXMgZGlmZmVyZW50IGNob2ljZS4gIEZpcnN0LCBleHBlY3QtdGVzdCBtYWNoaW5lcnkgaGFzIGNoZWNrIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgIGJhY2t0cmFjZXMgZnJvbSBhcHBlYXJpbmcgaW4gdGVzdCBvdXRwdXQuICBJdCBoYXMgbm8gc3VjaCBjaGVja3MgZm9yIGxpbmVcbiAgICAgICAgICAgICAgIGFuZCBjb2x1bW4gbnVtYmVycy4gIFNlY29uZCwgd2hlbiB0aGVyZSBpcyBhIHJlYWwgZXJyb3IgYW5kIHlvdSB3YW50IHRvIHNlZVxuICAgICAgICAgICAgICAgdGhlIGJhY2t0cmFjZSwgdGhyb3dpbmcgYXdheSB0aGUgd2hvbGUgYmFja3RyYWNlIGxvc2VzIGEgbG90IG9mIHBvdGVudGlhbGx5XG4gICAgICAgICAgICAgICB1c2VmdWwgaW5mb3JtYXRpb24gdGhhdCBtYXkgYmUgaGFyZCB0byByZWNvdmVyLiAgV2hlcmVhcyB3ZSdyZSBqdXN0XG4gICAgICAgICAgICAgICB0aHJvd2luZyBhIHdheSBhIGxpbmUgbnVtYmVyIGFuZCBjb2x1bW4sIHdoaWNoIGFyZSBhIG1pbm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgICAgICBnaXZlbiB0aGF0IHRoZSBmaWxlbmFtZSBoYXMgbW9zdCBvZiB0aGUgaW5mb3JtYXRpb24uICopXG4gICAgICAgICAgICAoaWYgYW1fcnVubmluZ190ZXN0XG4gICAgICAgICAgICAgdGhlbiBzcHJpbnRmIFwiZmlsZSAlUywgbGluZSBMSU5FLCBjaGFyYWN0ZXJzIEMxLUMyXCIgaGVyZS5wb3NfZm5hbWVcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBzcHJpbnRmXG4gICAgICAgICAgICAgICAgIFwiZmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgICAgIGhlcmUucG9zX2ZuYW1lXG4gICAgICAgICAgICAgICAgIGhlcmUucG9zX2xudW1cbiAgICAgICAgICAgICAgICAgY29sdW1uXG4gICAgICAgICAgICAgICAgIGNvbHVtbilcbiAgICAgIGluXG4gICAgICBtYXRjaCBwb3MsIG5hbWUgd2l0aFxuICAgICAgfCBOb25lLCBOb25lIC0+IFtdXG4gICAgICB8IFNvbWUgcG9zLCBOb25lIC0+IFsgc3ByaW50ZiBcIkNhdWdodCBieSBtb25pdG9yIGF0ICVzXCIgcG9zIF1cbiAgICAgIHwgTm9uZSwgU29tZSBuYW1lIC0+IFsgc3ByaW50ZiBcIkNhdWdodCBieSBtb25pdG9yICVzXCIgbmFtZSBdXG4gICAgICB8IFNvbWUgcG9zLCBTb21lIG5hbWUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgJXMgYXQgJXNcIiBuYW1lIHBvcyBdXG4gICAgaW5cbiAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIGJhY2t0cmFjZSAtPiBCYWNrdHJhY2UudG9fc3RyaW5nX2xpc3QgYmFja3RyYWNlXG4gICAgICBpblxuICAgICAgYmFja3RyYWNlX3RydW5jYXRpb25faGV1cmlzdGljcyBiYWNrdHJhY2UgQCBtb25pdG9yXG4gICAgaW5cbiAgICBsZXQgbGlzdF9pZl9ub3RfZW1wdHkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IF8gOjogXyBhcyBsIC0+IFNvbWUgbFxuICAgIGluXG4gICAgWyVzZXhwXG4gICAgICAoZXhuIDogZXhuKVxuICAgICwgKGxpc3RfaWZfbm90X2VtcHR5IGJhY2t0cmFjZSA6IChzdHJpbmcgbGlzdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgLCBgYmFja3RyYWNlX2hpc3RvcnlcbiAgICAgICAgKGxpc3RfaWZfbm90X2VtcHR5IGJhY2t0cmFjZV9oaXN0b3J5IDogKEJhY2t0cmFjZS50IGxpc3Qgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKV1cbiAgOztcbmVuZFxuXG5leGNlcHRpb24gTW9uaXRvcl9leG4gb2YgTW9uaXRvcl9leG4udFxuXG5sZXQgKCkgPVxuICBTZXhwbGliLkNvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTW9uaXRvcl9leG5dIChmdW5jdGlvblxuICAgIHwgTW9uaXRvcl9leG4gdCAtPiBbJXNleHAgXCJtb25pdG9yLm1sLkVycm9yXCIgOjogKHQgOiBNb25pdG9yX2V4bi50KV1cbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGV4dHJhY3RfZXhuIGV4biA9XG4gIG1hdGNoIGV4biB3aXRoXG4gIHwgTW9uaXRvcl9leG4gZXJyb3IgLT4gZXJyb3IuZXhuXG4gIHwgZXhuIC0+IGV4blxuOztcblxubGV0IHNlbmRfZXhuIHQgPyhiYWNrdHJhY2UgPSBgR2V0KSBleG4gPVxuICBsZXQgZXhuID1cbiAgICBtYXRjaCBleG4gd2l0aFxuICAgIHwgTW9uaXRvcl9leG4gXyAtPiBleG5cbiAgICB8IF8gLT5cbiAgICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgICAgICB8IGBHZXQgLT4gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudF9mb3JfZXhuIGV4blxuICAgICAgICB8IGBUaGlzIGIgLT4gU29tZSBiXG4gICAgICBpblxuICAgICAgbGV0IGJhY2t0cmFjZV9oaXN0b3J5ID0gKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpLmJhY2t0cmFjZV9oaXN0b3J5IGluXG4gICAgICBNb25pdG9yX2V4biB7IE1vbml0b3JfZXhuLmV4bjsgYmFja3RyYWNlOyBiYWNrdHJhY2VfaGlzdG9yeTsgbW9uaXRvciA9IHQgfVxuICBpblxuICBpZiBEZWJ1Zy5tb25pdG9yX3NlbmRfZXhuIHRoZW4gRGVidWcubG9nIFwiTW9uaXRvci5zZW5kX2V4blwiICh0LCBleG4pIFslc2V4cF9vZjogdCAqIGV4bl07XG4gIHQuaGFzX3NlZW5fZXJyb3IgPC0gdHJ1ZTtcbiAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gIGxldCByZWMgbG9vcCB0ID1cbiAgICBJdmFyLmZpbGwgdC5uZXh0X2Vycm9yIGV4bjtcbiAgICB0Lm5leHRfZXJyb3IgPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IERldGFjaGVkIC0+XG4gICAgICBpZiBEZWJ1Zy5tb25pdG9yX3NlbmRfZXhuXG4gICAgICB0aGVuXG4gICAgICAgIERlYnVnLmxvZyBcIk1vbml0b3Iuc2VuZF9leG4gZm91bmQgbGlzdGVuaW5nIG1vbml0b3JcIiAodCwgZXhuKSBbJXNleHBfb2Y6IHQgKiBleG5dO1xuICAgICAgQmFnLml0ZXIgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyB+ZjooZnVuIChleGVjdXRpb25fY29udGV4dCwgZikgLT5cbiAgICAgICAgU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgZXhuKTtcbiAgICAgIExpc3QuaXRlciB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzIH5mOihmdW4gdGFpbCAtPiBUYWlsLmV4dGVuZCB0YWlsIGV4bilcbiAgICB8IFBhcmVudCBwYXJlbnQgLT4gbG9vcCBwYXJlbnRcbiAgICB8IFJlcG9ydF91bmNhdWdodF9leG4gLT5cbiAgICAgICgqIERvIG5vdCBjaGFuZ2UgdGhpcyBicmFuY2ggdG8gcHJpbnQgdGhlIGV4Y2VwdGlvbiBvciB0byBleGl0LiAgSGF2aW5nIHRoZVxuICAgICAgICAgc2NoZWR1bGVyIHJhaXNlIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyB0aGUgbmVjZXNzYXJ5IGJlaGF2aW9yIGZvciBwcm9ncmFtc1xuICAgICAgICAgdGhhdCBjYWxsIFtTY2hlZHVsZXIuZ29dIGFuZCB3YW50IHRvIGhhbmRsZSBpdC4gKilcbiAgICAgIFNjaGVkdWxlci4oZ290X3VuY2F1Z2h0X2V4biAodCAoKSkpIGV4biAoIUFzeW5jX2tlcm5lbF9jb25maWcudGFza19pZCAoKSlcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5tb2R1bGUgRXhwb3J0ZWRfZm9yX3NjaGVkdWxlciA9IHN0cnVjdFxuICBsZXQgd2l0aGluX2NvbnRleHQgY29udGV4dCBmID1cbiAgICBTY2hlZHVsZXIuKHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBjb250ZXh0IH5mOihmdW4gKCkgLT5cbiAgICAgIG1hdGNoIFJlc3VsdC50cnlfd2l0aCBmIHdpdGhcbiAgICAgIHwgT2sgeCAtPiBPayB4XG4gICAgICB8IEVycm9yIGV4biAtPlxuICAgICAgICBzZW5kX2V4biAoRXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciBjb250ZXh0KSBleG4gfmJhY2t0cmFjZTpgR2V0O1xuICAgICAgICBFcnJvciAoKSlcbiAgOztcblxuICB0eXBlICdhIHdpdGhfb3B0aW9ucyA9ID9tb25pdG9yOnQgLT4gP3ByaW9yaXR5OlByaW9yaXR5LnQgLT4gJ2FcblxuICBsZXQgd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbGV0IHRtcF9jb250ZXh0ID1cbiAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpKSA/bW9uaXRvciA/cHJpb3JpdHlcbiAgICBpblxuICAgIHdpdGhpbl9jb250ZXh0IHRtcF9jb250ZXh0IGZcbiAgOztcblxuICBsZXQgd2l0aGluJyA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbWF0Y2ggd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiB3aXRoXG4gICAgfCBFcnJvciAoKSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgT2sgZCAtPiBkXG4gIDs7XG5cbiAgbGV0IHdpdGhpbl92ID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+IE5vbmVcbiAgICB8IE9rIHggLT4gU29tZSB4XG4gIDs7XG5cbiAgbGV0IHdpdGhpbiA/bW9uaXRvciA/cHJpb3JpdHkgZiA9XG4gICAgbWF0Y2ggd2l0aGluX2dlbiA/bW9uaXRvciA/cHJpb3JpdHkgZiB3aXRoXG4gICAgfCBFcnJvciAoKSAtPiAoKVxuICAgIHwgT2sgKCkgLT4gKClcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB3b3JrIHggPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIFNjaGVkdWxlci5lbnF1ZXVlXG4gICAgICBzY2hlZHVsZXJcbiAgICAgIChFeGVjdXRpb25fY29udGV4dC5jcmVhdGVfbGlrZVxuICAgICAgICAgKFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlcilcbiAgICAgICAgID9tb25pdG9yXG4gICAgICAgICA/cHJpb3JpdHkpXG4gICAgICB3b3JrXG4gICAgICB4XG4gIDs7XG5cbiAgbGV0IHNjaGVkdWxlID9tb25pdG9yID9wcmlvcml0eSB3b3JrID0gc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB3b3JrICgpXG5cbiAgbGV0IHNjaGVkdWxlJyA9XG4gICAgKCogRm9yIHBlcmZvcm1hbmNlLCB3ZSB1c2UgW3NjaGVkdWxlX3dpdGhfZGF0YV0gd2l0aCBhIGNsb3NlZCBmdW5jdGlvbiwgYW5kIGlubGluZVxuICAgICAgIFtEZWZlcnJlZC5jcmVhdGVdLiAqKVxuICAgIGxldCB1cG9uX3dvcmtfZmlsbF9pICh3b3JrLCBpKSA9IHVwb24gKHdvcmsgKCkpIChmdW4gYSAtPiBJdmFyLmZpbGwgaSBhKSBpblxuICAgIGZ1biA/bW9uaXRvciA/cHJpb3JpdHkgd29yayAtPlxuICAgICAgbGV0IGkgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB1cG9uX3dvcmtfZmlsbF9pICh3b3JrLCBpKTtcbiAgICAgIEl2YXIucmVhZCBpXG4gIDs7XG5cbiAgbGV0IHByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0IGYgPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICAgIHN0YWdlIChmdW4gYSAtPiBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhKVxuICA7O1xuXG4gIGxldCBwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCcgZiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gICAgbGV0IGNhbGxfYW5kX2ZpbGwgKGYsIGEsIGkpID0gdXBvbiAoZiBhKSAoZnVuIHIgLT4gSXZhci5maWxsIGkgcikgaW5cbiAgICBzdGFnZSAoZnVuIGEgLT5cbiAgICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGkgLT5cbiAgICAgICAgU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGNhbGxfYW5kX2ZpbGwgKGYsIGEsIGkpKSlcbiAgOztcbmVuZFxuXG5vcGVuIEV4cG9ydGVkX2Zvcl9zY2hlZHVsZXJcblxubGV0IHN0cmVhbV9pdGVyIHN0cmVhbSB+ZiA9XG4gIGxldCByZWMgbG9vcCBzdHJlYW0gPVxuICAgIFN0cmVhbS5uZXh0IHN0cmVhbVxuICAgID4+PiBmdW5jdGlvblxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh2LCBzdHJlYW0pIC0+XG4gICAgICBsb29wIHN0cmVhbTtcbiAgICAgIGYgdlxuICBpblxuICBsb29wIHN0cmVhbVxuOztcblxuKCogQW4gWydhIE9rX2FuZF9leG5zLnRdIHJlcHJlc2VudHMgdGhlIG91dHB1dCBvZiBhIGNvbXB1dGF0aW9uIHJ1bm5pbmcgaW4gYSBkZXRhY2hlZFxuICAgbW9uaXRvci4gKilcbm1vZHVsZSBPa19hbmRfZXhucyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgb2sgOiAnYSBEZWZlcnJlZC50XG4gICAgOyBleG5zIDogZXhuIFN0cmVhbS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuIGYgPVxuICAgICgqIFdlIGNhbGwgW2NyZWF0ZV93aXRoX3BhcmVudCBOb25lXSBiZWNhdXNlIFttb25pdG9yXSBkb2VzIG5vdCBuZWVkIGEgcGFyZW50LiAgSXRcbiAgICAgICBkb2VzIG5vdCBiZWNhdXNlIHdlIGNhbGwgW2RldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yXSBhbmQgZGVhbCB3aXRoIHRoZVxuICAgICAgIGVycm9ycyBleHBsaWNpdGx5LCB0aHVzIFtzZW5kX2V4bl0gd291bGQgbmV2ZXIgcHJvcGFnYXRlIGFuIGV4biBwYXN0IFttb25pdG9yXS4gKilcbiAgICBsZXQgbW9uaXRvciA9IGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSBOb25lIGluXG4gICAgbGV0IGV4bnMgPSBkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gbW9uaXRvciBpblxuICAgIGxldCBvayA9XG4gICAgICBtYXRjaCBydW4gd2l0aFxuICAgICAgfCBgTm93IC0+IHdpdGhpbicgfm1vbml0b3IgZlxuICAgICAgfCBgU2NoZWR1bGUgLT4gc2NoZWR1bGUnIH5tb25pdG9yIGZcbiAgICBpblxuICAgIHsgb2s7IGV4bnMgfVxuICA7O1xuZW5kXG5cbmxldCBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gICAgICByZXN1bHRfZmlsbGVyXG4gICAgICByZXN1bHRcbiAgICAgIGV4bnNcbiAgICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdFxuICA9XG4gIGlmIEl2YXJfZmlsbGVyLmlzX2VtcHR5IHJlc3VsdF9maWxsZXJcbiAgdGhlbiAoXG4gICAgSXZhcl9maWxsZXIuZmlsbCByZXN1bHRfZmlsbGVyIHJlc3VsdDtcbiAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQgZXhucylcbjs7XG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IHRyeV93aXRoX2xvZ19leG4gOiAoZXhuIC0+IHVuaXQpIHJlZiA9XG4gICAgcmVmIChmdW4gZXhuIC0+XG4gICAgICByYWlzZV9zIFslbWVzc2FnZSBcImZhaWxlZCB0byBzZXQgW01vbml0b3IuRXhwZXJ0LnRyeV93aXRoX2xvZ19leG5dXCIgKGV4biA6IEV4bi50KV0pXG4gIDs7XG5lbmRcblxubGV0IG1ha2VfaGFuZGxlX2V4biByZXN0ID1cbiAgbWF0Y2ggcmVzdCB3aXRoXG4gIHwgYExvZyAtPlxuICAgICgqIFdlIGFyZSBjYXJlZnVsIHRvIG5vdCBjbG9zZSBvdmVyIGN1cnJlbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IG5lZWRlZC4gKilcbiAgICAhRXhwZXJ0LnRyeV93aXRoX2xvZ19leG5cbiAgfCBgUmFpc2UgLT5cbiAgICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICAgIGZ1biBleG4gLT4gc2VuZF9leG4gcGFyZW50IGV4biA/YmFja3RyYWNlOk5vbmVcbiAgfCBgQ2FsbCBmIC0+XG4gICAgbGV0IHBhcmVudCA9IGN1cnJlbnQgKCkgaW5cbiAgICBmdW4gZXhuIC0+IHdpdGhpbiB+bW9uaXRvcjpwYXJlbnQgKGZ1biAoKSAtPiBmIGV4bilcbjs7XG5cbmxldCB0cnlfd2l0aFxuICAgICAgP2hlcmVcbiAgICAgID9pbmZvXG4gICAgICA/KG5hbWUgPSBcIlwiKVxuICAgICAgP2V4dHJhY3RfZXhuOihkb19leHRyYWN0X2V4biA9IGZhbHNlKVxuICAgICAgPyhydW4gPSBgTm93KVxuICAgICAgPyhyZXN0ID0gYFJhaXNlKVxuICAgICAgZlxuICA9XG4gIGxldCB7IE9rX2FuZF9leG5zLm9rOyBleG5zIH0gPSBPa19hbmRfZXhucy5jcmVhdGUgP2hlcmUgP2luZm8gfm5hbWUgfnJ1biBmIGluXG4gIGxldCBoYW5kbGVfZXhuID0gbWFrZV9oYW5kbGVfZXhuIHJlc3QgaW5cbiAgbGV0IGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zID0gc3RyZWFtX2l0ZXIgZXhucyB+ZjpoYW5kbGVfZXhuIGluXG4gICgqIFdlIHJ1biBbd2l0aGluJyB+bW9uaXRvcjptYWluXSB0byBhdm9pZCBob2xkaW5nIG9uIHRvIHJlZmVyZW5jZXMgdG8gdGhlIGV2YWx1YXRpb25cbiAgICAgY29udGV4dCBpbiB3aGljaCBbdHJ5X3dpdGhdIHdhcyBjYWxsZWQuICBUaGlzIGF2b2lkcyBhIHNwYWNlIGxlYWsgd2hlbiBhIGNoYWluIG9mXG4gICAgIFt0cnlfd2l0aF0ncyBhcmUgcnVuIGVhY2ggbmVzdGVkIHdpdGhpbiB0aGUgcHJldmlvdXMgb25lLiAgV2l0aG91dCB0aGUgW3dpdGhpbiddLCB0aGVcbiAgICAgZXJyb3IgaGFuZGxpbmcgZm9yIHRoZSBpbm5lcm1vc3QgW3RyeV93aXRoXSB3b3VsZCBrZWVwIGFsaXZlIHRoZSBlbnRpcmUgY2hhaW4uICopXG4gIHdpdGhpbicgfm1vbml0b3I6bWFpbiAoZnVuICgpIC0+XG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBva1xuICAgIHRoZW4gKFxuICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IGV4bnM7XG4gICAgICByZXR1cm4gKE9rIChEZWZlcnJlZC52YWx1ZV9leG4gb2spKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCByZXN1bHRfZmlsbGVyLCByZXN1bHQgPSBJdmFyX2ZpbGxlci5jcmVhdGUgKCkgaW5cbiAgICAgIHVwb24gb2sgKGZ1biByZXMgLT5cbiAgICAgICAgZmlsbF9yZXN1bHRfYW5kX2hhbmRsZV9iYWNrZ3JvdW5kX2Vycm9yc1xuICAgICAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgICAgICAoT2sgcmVzKVxuICAgICAgICAgIGV4bnNcbiAgICAgICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQpO1xuICAgICAgdXBvbiAoU3RyZWFtLm5leHQgZXhucykgKGZ1bmN0aW9uXG4gICAgICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IENvbnMgKGV4biwgZXhucykgLT5cbiAgICAgICAgICBsZXQgZXhuID0gaWYgZG9fZXh0cmFjdF9leG4gdGhlbiBleHRyYWN0X2V4biBleG4gZWxzZSBleG4gaW5cbiAgICAgICAgICBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gICAgICAgICAgICByZXN1bHRfZmlsbGVyXG4gICAgICAgICAgICAoRXJyb3IgZXhuKVxuICAgICAgICAgICAgZXhuc1xuICAgICAgICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0KTtcbiAgICAgIHJlc3VsdCkpXG47O1xuXG5sZXQgdHJ5X3dpdGhfb3JfZXJyb3IgP2hlcmUgP2luZm8gPyhuYW1lID0gXCJ0cnlfd2l0aF9vcl9lcnJvclwiKSA/ZXh0cmFjdF9leG4gP3Jlc3QgZiA9XG4gIHRyeV93aXRoIGYgP2hlcmUgP2luZm8gfm5hbWUgP2V4dHJhY3RfZXhuIH5ydW46YE5vdyA/cmVzdCA+PnwgT3JfZXJyb3Iub2ZfZXhuX3Jlc3VsdFxuOztcblxubGV0IHRyeV93aXRoX2pvaW5fb3JfZXJyb3JcbiAgICAgID9oZXJlXG4gICAgICA/aW5mb1xuICAgICAgPyhuYW1lID0gXCJ0cnlfd2l0aF9qb2luX29yX2Vycm9yXCIpXG4gICAgICA/ZXh0cmFjdF9leG5cbiAgICAgID9yZXN0XG4gICAgICBmXG4gID1cbiAgdHJ5X3dpdGhfb3JfZXJyb3IgZiA/aGVyZSA/aW5mbyB+bmFtZSA/ZXh0cmFjdF9leG4gP3Jlc3QgPj58IE9yX2Vycm9yLmpvaW5cbjs7XG5cbmxldCBwcm90ZWN0ID9oZXJlID9pbmZvID8obmFtZSA9IFwiTW9uaXRvci5wcm90ZWN0XCIpID9leHRyYWN0X2V4biA/cnVuID9yZXN0IGYgfmZpbmFsbHkgPVxuICBsZXQlYmluZCByID0gdHJ5X3dpdGggP2V4dHJhY3RfZXhuID9oZXJlID9pbmZvID9ydW4gP3Jlc3Qgfm5hbWUgZiBpblxuICBsZXQlbWFwIGZyID1cbiAgICB0cnlfd2l0aFxuICAgICAgfmV4dHJhY3RfZXhuOmZhbHNlXG4gICAgICA/aGVyZVxuICAgICAgP2luZm9cbiAgICAgIH5ydW46YFNjaGVkdWxlICgqIGNvbnNpZGVyIFt+cnVuOmBOb3ddICopXG4gICAgICA/cmVzdFxuICAgICAgfm5hbWU6XCJmaW5hbGx5XCJcbiAgICAgIGZpbmFsbHlcbiAgaW5cbiAgbWF0Y2ggciwgZnIgd2l0aFxuICB8IEVycm9yIGV4biwgRXJyb3IgZmluYWxseV9leG4gLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIkFzeW5jIGZpbmFsbHlcIiAoZXhuIDogZXhuKSAoZmluYWxseV9leG4gOiBleG4pXVxuICB8IEVycm9yIGUsIE9rICgpIHwgT2sgXywgRXJyb3IgZSAtPiByYWlzZSBlXG4gIHwgT2sgciwgT2sgKCkgLT4gclxuOztcblxubGV0IGhhbmRsZV9lcnJvcnMgP2hlcmUgP2luZm8gP25hbWUgZiBoYW5kbGVyID1cbiAgbGV0IHsgT2tfYW5kX2V4bnMub2s7IGV4bnMgfSA9IE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuOmBOb3cgZiBpblxuICBzdHJlYW1faXRlciBleG5zIH5mOmhhbmRsZXI7XG4gIG9rXG47O1xuXG5sZXQgY2F0Y2hfc3RyZWFtID9oZXJlID9pbmZvID9uYW1lIGYgPVxuICBsZXQgeyBPa19hbmRfZXhucy5leG5zOyBfIH0gPVxuICAgIE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuOmBOb3cgKGZ1biAoKSAtPlxuICAgICAgZiAoKTtcbiAgICAgIHJldHVybiAoKSlcbiAgaW5cbiAgZXhuc1xuOztcblxubGV0IGNhdGNoID9oZXJlID9pbmZvID9uYW1lIGYgPVxuICBtYXRjaCVtYXAgU3RyZWFtLm5leHQgKGNhdGNoX3N0cmVhbSA/aGVyZSA/aW5mbyA/bmFtZSBmKSB3aXRoXG4gIHwgQ29ucyAoeCwgXykgLT4geFxuICB8IE5pbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcIk1vbml0b3IuY2F0Y2ggZ290IHVuZXhwZWN0ZWQgZW1wdHkgc3RyZWFtXCJdXG47O1xuXG5sZXQgY2F0Y2hfZXJyb3IgP2hlcmUgP2luZm8gP25hbWUgZiA9IGNhdGNoID9oZXJlID9pbmZvID9uYW1lIGYgPj58IEVycm9yLm9mX2V4blxuXG5tb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gIGxldCBwYXJlbnQgdCA9XG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IFJlcG9ydF91bmNhdWdodF9leG4gLT4gTm9uZVxuICAgIHwgUGFyZW50IHBhcmVudCAtPiBTb21lIHBhcmVudFxuICAgIHwgRGV0YWNoZWQgLT4gTm9uZVxuICA7O1xuXG4gIGxldCBkZXB0aCB0ID1cbiAgICBsZXQgcmVjIGxvb3AgdCBuID1cbiAgICAgIG1hdGNoIHBhcmVudCB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBuXG4gICAgICB8IFNvbWUgdCAtPiBsb29wIHQgKG4gKyAxKVxuICAgIGluXG4gICAgbG9vcCB0IDBcbiAgOztcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5pbmNsdWRlIFRhaWwuU3RyZWFtXG5cbmxldCBmaXJzdF9leG4gdCA9XG4gIG1hdGNoJW1hcCBuZXh0IHQgd2l0aFxuICB8IE5pbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlN0cmVhbS5maXJzdCBvZiBlbXB0eSBzdHJlYW1cIl1cbiAgfCBDb25zICh4LCBfKSAtPiB4XG47O1xuXG5sZXQgZm9sZCcgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgdXBvbiAobmV4dCB0KSAoZnVuY3Rpb25cbiAgICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCBiXG4gICAgICAgIHwgQ29ucyAodiwgdCkgLT4gdXBvbiAoZiBiIHYpIChsb29wIHQpKVxuICAgIGluXG4gICAgbG9vcCB0IGluaXQpXG47O1xuXG4oKiBbZm9sZF0gaXMgaW1wbGVtZW50ZWQgdG8gYXZvaWQgcGVyLXN0cmVhbS1lbGVtZW50IGRlZmVycmVkIG92ZXJoZWFkIGluIHRoZSBjYXNlIHdoZW5cbiAgIG11bHRpcGxlIHN0cmVhbSBlbGVtZW50cyBhcmUgYXZhaWxhYmxlIHNpbXVsdGFuZW91c2x5LiAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayAobmV4dCB0KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdXBvbiAobmV4dCB0KSAoZnVuIG5leHQgLT4gbG9vcF9uZXh0IG5leHQgYilcbiAgICAgIHwgU29tZSBuZXh0IC0+IGxvb3BfbmV4dCBuZXh0IGJcbiAgICBhbmQgbG9vcF9uZXh0IG5leHQgYiA9XG4gICAgICBtYXRjaCBuZXh0IHdpdGhcbiAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgfCBDb25zICh2LCB0KSAtPiBsb29wIHQgKGYgYiB2KVxuICAgIGluXG4gICAgbG9vcCB0IGluaXQpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gXyAtPiBuICsgMSlcbmxldCBpdGVyJyB0IH5mID0gZm9sZCcgdCB+aW5pdDooKSB+ZjooZnVuICgpIHYgLT4gZiB2KVxuXG5sZXQgY2xvc2VkIHQgPVxuICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgfCBTb21lIE5pbCAtPiByZXR1cm4gKClcbiAgfCBfIC0+IGl0ZXInIHQgfmY6KGZ1biBfIC0+IHJldHVybiAoKSlcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBkb24ndF93YWl0X2ZvclxuICAgIChpdGVyJyB0IH5mOihmdW4gYSAtPlxuICAgICAgIGYgYTtcbiAgICAgICByZXR1cm4gKCkpKVxuOztcblxubGV0IGNyZWF0ZSBmID1cbiAgbGV0IHRhaWwgPSBUYWlsLmNyZWF0ZSAoKSBpblxuICAoKiBjb2xsZWN0IGJlZm9yZSBjYWxsaW5nIFtmXSwgaW4gY2FzZSBbZl0gaW1tZWRpYXRlbHkgZXh0ZW5kcy4gKilcbiAgbGV0IHQgPSBUYWlsLmNvbGxlY3QgdGFpbCBpblxuICBmIHRhaWw7XG4gIHRcbjs7XG5cbmxldCB1bmZvbGQgYiB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgYiA9XG4gICAgICB1cG9uIChmIGIpIChmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgICB8IFNvbWUgKGEsIGIpIC0+XG4gICAgICAgICAgVGFpbC5leHRlbmQgdGFpbCBhO1xuICAgICAgICAgIGxvb3AgYilcbiAgICBpblxuICAgIGxvb3AgYilcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeCk7XG4gICAgVGFpbC5jbG9zZV9leG4gdGFpbClcbjs7XG5cbmxldCB0b19saXN0IHMgPSBmb2xkJyBzIH5pbml0OltdIH5mOihmdW4gYiBhIC0+IHJldHVybiAoYSA6OiBiKSkgPj58IExpc3QucmV2XG5sZXQgY29weV90b190YWlsIHQgdGFpbCA9IGl0ZXInIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoVGFpbC5leHRlbmQgdGFpbCBhKSlcblxubGV0IGFwcGVuZCB0MSB0MiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uIChjb3B5X3RvX3RhaWwgdDEgdGFpbCkgKGZ1biAoKSAtPlxuICAgICAgdXBvbiAoY29weV90b190YWlsIHQyIHRhaWwpIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpKVxuOztcblxubGV0IGNvbmNhdCB0ID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb24gKGl0ZXInIHQgfmY6KGZ1biB0IC0+IGNvcHlfdG9fdGFpbCB0IHRhaWwpKSAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IGZpbHRlcicgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT5cbiAgICAgICAgIG1hdGNoJW1hcCBmIHYgd2l0aFxuICAgICAgICAgfCBmYWxzZSAtPiAoKVxuICAgICAgICAgfCB0cnVlIC0+IFRhaWwuZXh0ZW5kIHRhaWwgdikpXG4gICAgICAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IGZpbHRlcl9kZXByZWNhdGVkIHQgfmYgPSBmaWx0ZXInIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IGZpbHRlcl9tYXAnIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvblxuICAgICAgKGl0ZXInIHQgfmY6KGZ1biB2IC0+XG4gICAgICAgICBtYXRjaCVtYXAgZiB2IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgfCBTb21lIHYgLT4gVGFpbC5leHRlbmQgdGFpbCB2KSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9kZXByZWNhdGVkIHQgfmYgPSBmaWx0ZXJfbWFwJyB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXG5cbmxldCBtYXAnIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvblxuICAgICAgKGl0ZXInIHQgfmY6KGZ1biB2IC0+IGYgdiA+PnwgVGFpbC5leHRlbmQgdGFpbCkpXG4gICAgICAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwJyB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXG5cbmxldCBmaXJzdF9uIHMgbiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgcyBuID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgIGVsc2VcbiAgICAgICAgdXBvbiAobmV4dCBzKSAoZnVuY3Rpb25cbiAgICAgICAgICB8IE5pbCAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICAgICAgVGFpbC5leHRlbmQgdGFpbCB4O1xuICAgICAgICAgICAgbG9vcCB0IChuIC0gMSkpXG4gICAgaW5cbiAgICBsb29wIHMgbilcbjs7XG5cbmxldCBhdmFpbGFibGVfbm93IHQgPVxuICBsZXQgcmVjIGxvb3AgdCBhYyA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAobmV4dCB0KSB3aXRoXG4gICAgfCBOb25lIHwgU29tZSBOaWwgLT4gTGlzdC5yZXYgYWMsIHRcbiAgICB8IFNvbWUgKENvbnMgKHgsIHQpKSAtPiBsb29wIHQgKHggOjogYWMpXG4gIGluXG4gIGxvb3AgdCBbXVxuOztcblxubGV0IHNwbGl0ID8oc3RvcCA9IERlZmVycmVkLm5ldmVyICgpKSA/KGYgPSBmdW4gXyAtPiBgQ29udGludWUpIHQgPVxuICBsZXQgcmVhc29uX2Zvcl9zdG9wcGluZyA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCBwcmVmaXggPSBUYWlsLmNyZWF0ZSAoKSBpblxuICBsZXQgZmluaXNoIHYgPVxuICAgIFRhaWwuY2xvc2VfZXhuIHByZWZpeDtcbiAgICBJdmFyLmZpbGwgcmVhc29uX2Zvcl9zdG9wcGluZyB2XG4gIGluXG4gIGxldCByZWMgbG9vcCB0ID1cbiAgICBjaG9vc2UgWyBjaG9pY2Ugc3RvcCAoZnVuICgpIC0+IGBTdG9wcGVkKTsgY2hvaWNlIChuZXh0IHQpIChmdW4gbyAtPiBgTmV4dCBvKSBdXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBgU3RvcHBlZCAtPiBmaW5pc2ggKGBTdG9wcGVkIHQpXG4gICAgfCBgTmV4dCBvIC0+XG4gICAgICAobWF0Y2ggbyB3aXRoXG4gICAgICAgfCBOaWwgLT4gZmluaXNoIGBFbmRfb2Zfc3RyZWFtXG4gICAgICAgfCBDb25zIChhLCB0KSAtPlxuICAgICAgICAgKG1hdGNoIGYgYSB3aXRoXG4gICAgICAgICAgfCBgQ29udGludWUgLT5cbiAgICAgICAgICAgIFRhaWwuZXh0ZW5kIHByZWZpeCBhO1xuICAgICAgICAgICAgbG9vcCB0XG4gICAgICAgICAgfCBgRm91bmQgYiAtPiBmaW5pc2ggKGBGb3VuZCAoYiwgdCkpKSlcbiAgaW5cbiAgbG9vcCB0O1xuICBUYWlsLmNvbGxlY3QgcHJlZml4LCBJdmFyLnJlYWQgcmVhc29uX2Zvcl9zdG9wcGluZ1xuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCBfLCBmb3VuZCA9IHNwbGl0IHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGBGb3VuZCBhIGVsc2UgYENvbnRpbnVlKSBpblxuICBtYXRjaCVtYXAgZm91bmQgd2l0aFxuICB8IGBTdG9wcGVkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgKGBFbmRfb2Zfc3RyZWFtIHwgYEZvdW5kIF8pIGFzIHggLT4geFxuOztcblxubGV0IHVuZ3JvdXAgdCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIGwgLT5cbiAgICAgICAgIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBUYWlsLmV4dGVuZCB0YWlsIHgpO1xuICAgICAgICAgcmV0dXJuICgpKSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZSB0cyA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICAoKiBUaGUgaW50ZXJsZWF2ZWQgc3RyZWFtIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgb3V0ZXIgc3RyZWFtIGFuZCBhbGwgb2ZcbiAgICAgICB0aGUgaW5uZXIgc3RyZWFtcyBoYXZlIGJlZW4gY2xvc2VkLiAgS2VlcCBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygb3BlblxuICAgICAgIHN0cmVhbXMgYW5kIGNsb3NlIHRoZSBpbnRlcmxlYXZlZCBzdHJlYW0gd2hlbiB0aGF0IGNvdW50IGJlY29tZXNcbiAgICAgICB6ZXJvLiAqKVxuICAgIGxldCBudW1fb3BlbiA9IHJlZiAxIGluXG4gICAgKCogMSBmb3IgdGhlIG91dGVyIHN0cmVhbSB0aGF0IGlzIG9wZW4gKilcbiAgICBsZXQgY2xvc2UgKCkgPVxuICAgICAgbnVtX29wZW4gOj0gIW51bV9vcGVuIC0gMTtcbiAgICAgIGlmICFudW1fb3BlbiA9IDAgdGhlbiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgaW5cbiAgICBsZXQgb3V0ZXJfY2xvc2VkID1cbiAgICAgIGl0ZXInIHRzIH5mOihmdW4gdCAtPlxuICAgICAgICBudW1fb3BlbiA6PSAhbnVtX29wZW4gKyAxO1xuICAgICAgICB1cG9uIChjb3B5X3RvX3RhaWwgdCB0YWlsKSBjbG9zZTtcbiAgICAgICAgcmV0dXJuICgpKVxuICAgIGluXG4gICAgdXBvbiBvdXRlcl9jbG9zZWQgY2xvc2UpXG47O1xuXG5sZXQgdGFrZV91bnRpbCB0IGQgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgbGV0IHJlYyBsb29wIHQgPVxuICAgICAgdXBvblxuICAgICAgICAoY2hvb3NlIFsgY2hvaWNlIGQgKGZ1biAoKSAtPiBgU3RvcCk7IGNob2ljZSAobmV4dCB0KSAoZnVuIHogLT4gYE5leHQgeikgXSlcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBgU3RvcCB8IGBOZXh0IE5pbCAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgICAgfCBgTmV4dCAoQ29ucyAoeCwgdCkpIC0+XG4gICAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIHg7XG4gICAgICAgICAgICBsb29wIHQpXG4gICAgaW5cbiAgICBsb29wIHQpXG47O1xuXG5sZXQgaXRlcl9kdXJhYmx5JyB0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgPVxuICAgICAgbmV4dCB0XG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbCByZXN1bHQgKClcbiAgICAgIHwgQ29ucyAoeCwgdCkgLT5cbiAgICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICAgIH5ydW46XG4gICAgICAgICAgICBgU2NoZWR1bGVcbiAgICAgICAgICB+cmVzdDpgUmFpc2VcbiAgICAgICAgICAoZnVuICgpIC0+IGYgeClcbiAgICAgICAgPj4+IGZ1biB6IC0+XG4gICAgICAgIGxvb3AgdDtcbiAgICAgICAgKG1hdGNoIHogd2l0aFxuICAgICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgICAgfCBFcnJvciBlIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZSlcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHlfcmVwb3J0X2VuZCB0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgPVxuICAgICAgbmV4dCB0XG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbCByZXN1bHQgKClcbiAgICAgIHwgQ29ucyAoeCwgdCkgLT5cbiAgICAgICAgKCogV2UgaW1tZWRpYXRlbHkgY2FsbCBbbG9vcF0sIHRodXMgbWFraW5nIHRoZSBpdGVyIGR1cmFibGUuICBBbnkgZXhjZXB0aW9uc1xuICAgICAgICAgICByYWlzZWQgYnkgW2ZdIHdpbGwgbm90IHByZXZlbnQgdGhlIGxvb3AgZnJvbSBjb250aW51aW5nLCBhbmQgd2lsbCBnbyB0byB0aGVcbiAgICAgICAgICAgbW9uaXRvciBvZiB3aG9tZXZlciBjYWxsZWQgW2l0ZXJfZHVyYWJseV9yZXBvcnRfZW5kXS4gKilcbiAgICAgICAgbG9vcCB0O1xuICAgICAgICBmIHhcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHkgdCB+ZiA9IGRvbid0X3dhaXRfZm9yIChpdGVyX2R1cmFibHlfcmVwb3J0X2VuZCB0IH5mKVxuXG5sZXQgb2ZfZnVuIGYgPVxuICB1bmZvbGQgKCkgfmY6KGZ1biAoKSAtPlxuICAgIGxldCVtYXAgYSA9IGYgKCkgaW5cbiAgICBTb21lIChhLCAoKSkpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAncGVybWlzc2lvbikgdCA9ICgnYSwgJ3Blcm1pc3Npb24pIFR5cGVzLkJ2YXIudFxuXG50eXBlICdhIHJlcHIgPSAnYSBUeXBlcy5CdmFyLnJlcHIgPVxuICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICA7IG11dGFibGUgaXZhciA6ICdhIEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgXyB0ID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gcmVwciBbJXNleHBfb2Y6IF8gcmVwcl0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHJlcHIgZiBpblxuICAgIEZpZWxkc19vZl9yZXByLml0ZXJcbiAgICAgIH5oYXNfYW55X3dhaXRlcnM6XG4gICAgICAgIChjaGVjayAoZnVuIGhhc19hbnlfd2FpdGVycyAtPlxuICAgICAgICAgICBpZiBJdmFyLmhhc19oYW5kbGVycyByZXByLml2YXIgdGhlbiBhc3NlcnQgaGFzX2FueV93YWl0ZXJzKSlcbiAgICAgIH5pdmFyOlxuICAgICAgICAoY2hlY2sgKGZ1biBpdmFyIC0+XG4gICAgICAgICAgIEl2YXIuaW52YXJpYW50IGludmFyaWFudF9hIGl2YXI7XG4gICAgICAgICAgIGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKSkpKVxuOztcblxubGV0IHNleHBfb2ZfdCBfIF8gdCA9XG4gIGxldCB7IGhhc19hbnlfd2FpdGVyczsgaXZhciA9IF8gfSA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gICgqIFdlIGRvbid0IHNob3cgW2l2YXJdIGJlY2F1c2UgaXQncyBhbHdheXMgZW1wdHkuICopXG4gIFslbWVzc2FnZSAoaGFzX2FueV93YWl0ZXJzIDogYm9vbCldXG47O1xuXG5pbmNsdWRlIFNjaGVkdWxlcjEuQnZhclxuXG5sZXQgYnJvYWRjYXN0IHQgYSA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgaWYgcmVwci5oYXNfYW55X3dhaXRlcnNcbiAgdGhlbiAoXG4gICAgcmVwci5oYXNfYW55X3dhaXRlcnMgPC0gZmFsc2U7XG4gICAgSXZhci5maWxsIHJlcHIuaXZhciBhO1xuICAgIHJlcHIuaXZhciA8LSBJdmFyLmNyZWF0ZSAoKSlcbjs7XG5cbmxldCB3YWl0IHQgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIHJlcHIuaGFzX2FueV93YWl0ZXJzIDwtIHRydWU7XG4gIEl2YXIucmVhZCByZXByLml2YXJcbjs7XG5cbmxldCBoYXNfYW55X3dhaXRlcnMgdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgcmVwci5oYXNfYW55X3dhaXRlcnNcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5jbG9ja1xuXG5tb2R1bGUgQWxhcm0gPSBUaW1pbmdfd2hlZWwuQWxhcm1cbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcblxubGV0IHVwb24gPSBEZWZlcnJlZC51cG9uXG5sZXQgY2hvb3NlID0gRGVmZXJyZWQuY2hvb3NlXG5sZXQgY2hvaWNlID0gRGVmZXJyZWQuY2hvaWNlXG5sZXQgKCA+Pj4gKSA9IHVwb25cblxubW9kdWxlIFQxID0gc3RydWN0XG4gIGluY2x1ZGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLlQxXG5cbiAgKCogV2UgZG9uJ3QgaW5jbHVkZSB0aGUgW2lkXSBpbiB0aGUgc2V4cCBiZWNhdXNlIHRoZSB1c2VyIChyaWdodGx5KSBjYW4ndCBjb250cm9sIGl0LCBzb1xuICAgICBpdCdzIGhhcmQgdG8gbWFrZSBpdCBkZXRlcm1pbmlzdGljIGluIHRlc3RzLiAqKVxuICBsZXQgc2V4cF9vZl90XG4gICAgICAgIF9cbiAgICAgICAgeyBpZCA9IF9cbiAgICAgICAgOyBhZHZhbmNlX2Vycm9ycyA9IF9cbiAgICAgICAgOyBhbV9hZHZhbmNpbmcgPSBfXG4gICAgICAgIDsgZXZlbnRzXG4gICAgICAgIDsgZmlyZWRfZXZlbnRzID0gX1xuICAgICAgICA7IGhhbmRsZV9maXJlZCA9IF9cbiAgICAgICAgOyBpc193YWxsX2Nsb2NrXG4gICAgICAgIDsgbW9zdF9yZWNlbnRseV9maXJlZCA9IF9cbiAgICAgICAgOyBzY2hlZHVsZXIgPSBfXG4gICAgICAgIH1cbiAgICA9XG4gICAgaWYgaXNfd2FsbF9jbG9ja1xuICAgIHRoZW4gWyVtZXNzYWdlIFwiPHdhbGxfY2xvY2s+XCJdXG4gICAgZWxzZVxuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIChpc193YWxsX2Nsb2NrIDogYm9vbClcbiAgICAgICAgICAoKiBXZSBkb24ndCBkaXNwbGF5IHRoZSBbSm9iLnRdcyBpbiBbZXZlbnRzXSBiZWNhdXNlIHRob3NlIGFyZVxuICAgICAgICAgICAgIHBvb2wgcG9pbnRlcnMsIHdoaWNoIGFyZSB1bmluZm9ybWF0aXZlLiAqKVxuICAgICAgICAgIChldmVudHMgOiBfIFRpbWluZ193aGVlbC50KV1cbiAgOztcbmVuZFxuXG5vcGVuIFQxXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IHJlYWRfd3JpdGUgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5lbmRcblxudHlwZSB0ID0gcmVhZCBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbmxldCBpbnZhcmlhbnRfd2l0aF9qb2JzID0gaW52YXJpYW50X3dpdGhfam9ic1xubGV0IHJlYWRfb25seSAodCA6IFs+IHJlYWQgXSBUMS50KSA9ICh0IDo+IHQpXG5sZXQgY3JlYXRlID0gU2NoZWR1bGVyLmNyZWF0ZV90aW1lX3NvdXJjZVxubGV0IHdhbGxfY2xvY2sgPSBTY2hlZHVsZXIud2FsbF9jbG9ja1xubGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiB0LmV2ZW50c1xubGV0IGlzX3dhbGxfY2xvY2sgdCA9IHQuaXNfd2FsbF9jbG9ja1xubGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0IHQuZXZlbnRzXG5sZXQgdGltaW5nX3doZWVsX25vdyB0ID0gVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c1xubGV0IGlkIHQgPSB0LmlkXG5cbm1vZHVsZSBJZCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5JZFxuXG5sZXQgbm93IHQgPVxuICBpZiB0LmlzX3dhbGxfY2xvY2tcbiAgdGhlblxuICAgICgqIEZvciB0aGUgd2FsbC1jbG9jayB0aW1lLXNvdXJjZSwgd2UgdXNlIFtUaW1lX25zLm5vdyAoKV0gcmF0aGVyIHRoYW5cbiAgICAgICBbVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c10uICBUaGUgbGF0dGVyIGlzIG9ubHkgdXBkYXRlZCBhdCB0aGUgc3RhcnQgb2YgZWFjaFxuICAgICAgIGN5Y2xlLiAgVGhlcmUgY2FuIGJlIHN1YnN0YW50aWFsIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIHdoZW4gcGVvcGxlIGRvIGxvbmdcbiAgICAgICBydW5uaW5nIGNvbXB1dGF0aW9ucyBvciBtaXggYmxvY2tpbmcgY29kZSB3aXRoIGFzeW5jLiAgQW5kIGh1bWFucyBleHBlY3QgdGhhdFxuICAgICAgIHdhbGwtY2xvY2sgdGltZSBpcyBiYXNlZCBvbiBbVGltZS5ub3ddLCBub3Qgc29tZSBhcnRpZmFjdCBvZiBhc3luY1xuICAgICAgIGltcGxlbWVudGF0aW9uLiAqKVxuICAgIFRpbWVfbnMubm93ICgpXG4gIGVsc2UgdGltaW5nX3doZWVsX25vdyB0XG47O1xuXG4oKiBXZSBwcmVhbGxvY2F0ZSBbc2VuZF9leG5dIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgb24gZWFjaCBjYWxsIHRvIFthZHZhbmNlX2Nsb2NrXS4gKilcbmxldCBzZW5kX2V4biA9IFNvbWUgTW9uaXRvci5zZW5kX2V4blxubGV0IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4blxubGV0IGFkdmFuY2VfZGlyZWN0bHlfYnkgdCBieSA9IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fOihUaW1lX25zLmFmdGVyIChub3cgdCkgYnkpXG5sZXQgYWR2YW5jZSA9IGFkdmFuY2VfZGlyZWN0bHlcbmxldCBhZHZhbmNlX2J5ID0gYWR2YW5jZV9kaXJlY3RseV9ieVxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5maXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuXG5sZXQgeWllbGQgdCA9IEJ2YXIud2FpdCAoU2NoZWR1bGVyLnlpZWxkIHQuc2NoZWR1bGVyKVxuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXMgP3dhaXRfZm9yIHQgfnRvXyA9XG4gIGxldCBydW5fcXVldWVkX2FsYXJtcyAoKSA9XG4gICAgKCogRXZlcnkgdGltZSB3ZSB3YW50IHRvIHJ1biBxdWV1ZWQgYWxhcm1zIHdlIG5lZWQgdG8geWllbGQgY29udHJvbCBiYWNrIHRvIHRoZVxuICAgICAgIFtBc3luYy5TY2hlZHVsZXJdIGFuZCBbd2FpdF9mb3JdIGFueSBsb2dpYyB0aGF0IGlzIHN1cHBvc2VkIHRvIGZpbmlzaCBhdCB0aGlzIHRpbWVcbiAgICAgICBiZWZvcmUgYWR2YW5jaW5nLiAgSWYgbm8gW3dhaXRfZm9yXSBsb2dpYyBpcyBzcGVjaWZpZWQgd2UgY2FuIHNpbXBseSB5aWVsZCBjb250cm9sXG4gICAgICAgYnkgaW52b2tpbmcgW3lpZWxkIHRdLCB3aGljaCBlbnF1ZXVlcyBhbm90aGVyIGpvYiBhdCB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgam9iXG4gICAgICAgcXVldWUgc28gYWxhcm0gam9icyBoYXZlIHRoZSBvcHBvcnR1bml0eSB0byBydW4gYmVmb3JlIHdlIGFkdmFuY2UuICopXG4gICAgbWF0Y2ggd2FpdF9mb3Igd2l0aFxuICAgIHwgTm9uZSAtPiB5aWVsZCB0XG4gICAgfCBTb21lIGYgLT4gZiAoKVxuICBpblxuICBsZXQgZmluaXNoICgpID1cbiAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXztcbiAgICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICAgKCogc28gdGhhdCBhbGFybXMgc2NoZWR1bGVkIGF0IG9yIGJlZm9yZSBbdG9fXSBmaXJlICopXG4gICAgcnVuX3F1ZXVlZF9hbGFybXMgKClcbiAgaW5cbiAgbGV0IHJlYyB3YWxrX2FsYXJtcyAoKSA9XG4gICAgbWF0Y2ggVGltaW5nX3doZWVsLm1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0LmV2ZW50cyB3aXRoXG4gICAgfCBOb25lIC0+IGZpbmlzaCAoKVxuICAgIHwgU29tZSBtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgLT5cbiAgICAgIGlmIFRpbWVfbnMuKCA+PSApIG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0b19cbiAgICAgIHRoZW4gZmluaXNoICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b186bWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsO1xuICAgICAgICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICAgICAgIGxldCBxdWV1ZWRfYWxhcm1zX3JhbiA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gICAgICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgcXVldWVkX2FsYXJtc19yYW5cbiAgICAgICAgdGhlbiB3YWxrX2FsYXJtcyAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQlYmluZCAoKSA9IHF1ZXVlZF9hbGFybXNfcmFuIGluXG4gICAgICAgICAgd2Fsa19hbGFybXMgKCkpKVxuICBpblxuICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICgqIFRoaXMgZmlyc3QgW3J1bl9xdWV1ZWRfYWxhcm1zXSBjYWxsIGFsbG93cyBbQ2xvY2tfbnMuZXZlcnldIHRoZSBvcHBvcnR1bml0eSB0byBydW5cbiAgICAgaXRzIGNvbnRpbnVhdGlvbiBkZWZlcnJlZHMgc28gdGhhdCB0aGV5IGNhbiByZXNjaGVkdWxlIGFsYXJtcy4gIFRoaXMgaXMgcGFydGljdWxhcmx5XG4gICAgIHVzZWZ1bCBpbiBvdXIgXCJhZHZhbmNlIGhpdHMgaW50ZXJtZWRpYXRlIGFsYXJtc1wiIHVuaXQgdGVzdCBiZWxvdywgYnV0IGxpa2VseSB1c2VmdWxcbiAgICAgaW4gb3RoZXIgY2FzZXMgd2hlcmUgW2V2ZXJ5XSBpcyBzeW5jaHJvbm91c2x5IGZvbGxvd2VkIGJ5IFthZHZhbmNlXS4gKilcbiAgbGV0JWJpbmQgKCkgPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICB3YWxrX2FsYXJtcyAoKVxuOztcblxubGV0IGFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoX3RpbWluZ193aGVlbF9pbnRlcnZhbCA/d2FpdF9mb3IgdCB+dG9fID1cbiAgbGV0IHJ1bl9xdWV1ZWRfYWxhcm1zICgpID1cbiAgICAoKiBFdmVyeSB0aW1lIHdlIHdhbnQgdG8gcnVuIHF1ZXVlZCBhbGFybXMgd2UgbmVlZCB0byB5aWVsZCBjb250cm9sIGJhY2sgdG8gdGhlXG4gICAgICAgW0FzeW5jLlNjaGVkdWxlcl0gYW5kIFt3YWl0X2Zvcl0gYW55IGxvZ2ljIHRoYXQgaXMgc3VwcG9zZWQgdG8gZmluaXNoIGF0IHRoaXMgdGltZVxuICAgICAgIGJlZm9yZSBhZHZhbmNpbmcuICBJZiBubyBbd2FpdF9mb3JdIGxvZ2ljIGlzIHNwZWNpZmllZCB3ZSBjYW4gc2ltcGx5IHlpZWxkIGNvbnRyb2xcbiAgICAgICBieSBpbnZva2luZyBbeWllbGQgdF0sIHdoaWNoIGVucXVldWVzIGFub3RoZXIgam9iIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBqb2JcbiAgICAgICBxdWV1ZSBzbyBhbGFybSBqb2JzIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJ1biBiZWZvcmUgd2UgYWR2YW5jZS4gKilcbiAgICBtYXRjaCB3YWl0X2ZvciB3aXRoXG4gICAgfCBOb25lIC0+IHlpZWxkIHRcbiAgICB8IFNvbWUgZiAtPiBmICgpXG4gIGluXG4gIGxldCBmaW5pc2ggKCkgPVxuICAgIGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fO1xuICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAoKiBzbyB0aGF0IGFsYXJtcyBzY2hlZHVsZWQgYXQgb3IgYmVmb3JlIFt0b19dIGZpcmUgKilcbiAgICBydW5fcXVldWVkX2FsYXJtcyAoKVxuICBpblxuICBsZXQgcmVjIHdhbGtfYWxhcm1zICgpID1cbiAgICBtYXRjaCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiBmaW5pc2ggKClcbiAgICB8IFNvbWUgbmV4dF9hbGFybV9maXJlc19hdCAtPlxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbmV4dF9hbGFybV9maXJlc19hdCB0b19cbiAgICAgIHRoZW4gZmluaXNoICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQuZXZlbnRzKTtcbiAgICAgICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgICAgICBsZXQgcXVldWVkX2FsYXJtc19yYW4gPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICAgICAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHF1ZXVlZF9hbGFybXNfcmFuXG4gICAgICAgIHRoZW4gd2Fsa19hbGFybXMgKClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0JWJpbmQgKCkgPSBxdWV1ZWRfYWxhcm1zX3JhbiBpblxuICAgICAgICAgIHdhbGtfYWxhcm1zICgpKSlcbiAgaW5cbiAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAoKiBUaGlzIGZpcnN0IFtydW5fcXVldWVkX2FsYXJtc10gY2FsbCBhbGxvd3MgW0Nsb2NrX25zLmV2ZXJ5XSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuXG4gICAgIGl0cyBjb250aW51YXRpb24gZGVmZXJyZWRzIHNvIHRoYXQgdGhleSBjYW4gcmVzY2hlZHVsZSBhbGFybXMuICBUaGlzIGlzIHBhcnRpY3VsYXJseVxuICAgICB1c2VmdWwgaW4gb3VyIFwiYWR2YW5jZSBoaXRzIGludGVybWVkaWF0ZSBhbGFybXNcIiB1bml0IHRlc3QgYmVsb3csIGJ1dCBsaWtlbHkgdXNlZnVsXG4gICAgIGluIG90aGVyIGNhc2VzIHdoZXJlIFtldmVyeV0gaXMgc3luY2hyb25vdXNseSBmb2xsb3dlZCBieSBbYWR2YW5jZV0uICopXG4gIGxldCViaW5kICgpID0gcnVuX3F1ZXVlZF9hbGFybXMgKCkgaW5cbiAgd2Fsa19hbGFybXMgKClcbjs7XG5cbmxldCBhZHZhbmNlX2J5X2FsYXJtc19ieSA/d2FpdF9mb3IgdCBieSA9XG4gIGFkdmFuY2VfYnlfYWxhcm1zID93YWl0X2ZvciB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcbjs7XG5cbmxldCBzcGFuX3RvX3RpbWUgdCBzcGFuID0gVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW5cblxubGV0IHNjaGVkdWxlX2pvYiB0IH5hdCBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBsZXQgYWxhcm0gPVxuICAgIFRpbWluZ193aGVlbC5hZGRcbiAgICAgIHQuZXZlbnRzXG4gICAgICB+YXRcbiAgICAgIChKb2Jfb3JfZXZlbnQub2Zfam9iIChTY2hlZHVsZXIuY3JlYXRlX2pvYiB0LnNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGEpKVxuICBpblxuICAobWF0Y2ggdC5zY2hlZHVsZXIuZXZlbnRfYWRkZWRfaG9vayB3aXRoXG4gICB8IE5vbmUgLT4gKClcbiAgIHwgU29tZSBmIC0+IGYgYXQpO1xuICBhbGFybVxuOztcblxubGV0IHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZiBhID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdC5zY2hlZHVsZXIgaW5cbiAgaWYgVGltZV9ucy4oID4gKSB0aW1lIChUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzKVxuICB0aGVuIHNjaGVkdWxlX2pvYiB0IH5hdDp0aW1lIGV4ZWN1dGlvbl9jb250ZXh0IGYgYVxuICBlbHNlIChcbiAgICBTY2hlZHVsZXIuZW5xdWV1ZSB0LnNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgQWxhcm0ubnVsbCAoKSlcbjs7XG5cbmxldCBydW5fYXQgdCB0aW1lIGYgYSA9IGlnbm9yZSAocnVuX2F0X2ludGVybmFsIHQgdGltZSBmIGEgOiBfIEFsYXJtLnQpXG5sZXQgcnVuX2FmdGVyIHQgc3BhbiBmIGEgPSBydW5fYXQgdCAoc3Bhbl90b190aW1lIHQgc3BhbikgZiBhXG5cbmxldCBhdCA9XG4gIGxldCBmaWxsIHJlc3VsdCA9IEl2YXIuZmlsbCByZXN1bHQgKCkgaW5cbiAgZnVuIHQgdGltZSAtPlxuICAgIGlmIFRpbWVfbnMuKCA8PSApIHRpbWUgKFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHMpXG4gICAgdGhlbiByZXR1cm4gKClcbiAgICBlbHNlIChcbiAgICAgIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgaWdub3JlIChydW5fYXRfaW50ZXJuYWwgdCB0aW1lIGZpbGwgcmVzdWx0IDogXyBBbGFybS50KTtcbiAgICAgIEl2YXIucmVhZCByZXN1bHQpXG47O1xuXG5sZXQgYWZ0ZXIgdCBzcGFuID0gYXQgdCAoc3Bhbl90b190aW1lIHQgc3BhbilcblxubGV0IHJlbW92ZV9hbGFybSB0IGFsYXJtIDogdW5pdCA9XG4gIGxldCBqb2Jfb3JfZXZlbnQgPSBBbGFybS52YWx1ZSB0LmV2ZW50cyBhbGFybSBpblxuICAobGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gICBsZXQgKEsgaykgPSBraW5kIGpvYl9vcl9ldmVudCBpblxuICAgbWF0Y2ggaywgcHJvamVjdCBrIGpvYl9vcl9ldmVudCB3aXRoXG4gICB8IEpvYiwgam9iIC0+IFNjaGVkdWxlci5mcmVlX2pvYiB0LnNjaGVkdWxlciBqb2JcbiAgIHwgRXZlbnQsIF8gLT5cbiAgICAgKCogVGhpcyBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIFthbGFybV0gb25seSBldmVyIGNvbWVzIGZyb20gW0V2ZW50LmFsYXJtXSB3aGljaCBvbmx5XG4gICAgICAgIGV2ZXIgZ2V0cyBwb3B1bGF0ZWQgYnkgYSBjYWxsIHRvIFtzY2hlZHVsZV9qb2JdLiAqKVxuICAgICBhc3NlcnQgZmFsc2UpO1xuICBUaW1pbmdfd2hlZWwucmVtb3ZlIHQuZXZlbnRzIGFsYXJtXG47O1xuXG5sZXQgcmVtb3ZlX2FsYXJtX2lmX3NjaGVkdWxlZCB0IGFsYXJtID1cbiAgaWYgVGltaW5nX3doZWVsLm1lbSB0LmV2ZW50cyBhbGFybSB0aGVuIHJlbW92ZV9hbGFybSB0IGFsYXJtXG47O1xuXG5tb2R1bGUgRXZlbnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEZpcmVkID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgeyBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgQWxhcm0udFxuICAgIDsgbXV0YWJsZSBmaXJlIDogdW5pdCAtPiB1bml0XG4gICAgOyAoKiBBcyBsb25nIGFzIFtJdmFyLmlzX2VtcHR5IGZpcmVkXSwgd2UgaGF2ZSBub3QgeWV0IGNvbW1pdHRlZCB0byB3aGV0aGVyIHRoZSBldmVudFxuICAgICAgICAgd2lsbCBoYXBwZW4gb3IgYmUgYWJvcnRlZC4gIFdoZW4gW0l2YXIuaXNfZW1wdHkgZmlyZWRdLCB0aGUgYWxhcm0gbWF5IG9yIG1heSBub3RcbiAgICAgICAgIGJlIGluIHRoZSB0aW1pbmcgd2hlZWwgLS0gaWYgaXQgaXNuJ3QsIHRoZW4gdGhlcmUncyBhIGpvYiBpbiBBc3luYydzIGpvYiBxdWV1ZVxuICAgICAgICAgdGhhdCB3aWxsIGZpcmUgdGhlIGV2ZW50LCB1bmxlc3MgaXQgaXMgYWJvcnRlZCBiZWZvcmUgdGhhdCBqb2IgY2FuIHJ1bi4gKilcbiAgICAgIGZpcmVkIDogKCdhLCAnaCkgRmlyZWQudCBJdmFyLnRcbiAgICA7ICgqIFtudW1fZmlyZXNfdG9fc2tpcF0gaXMgdXNlZCB0byByZXNjaGVkdWxlIGV2ZW50cyB0aGF0IGhhdmUgZmlyZWQgYW5kIGVudGVyZWQgdGhlXG4gICAgICAgICBBc3luYyBqb2IgcXVldWUsIGJ1dCBoYXZlIG5vdCB5ZXQgcnVuLiAgVGhvc2Ugam9icyBvbmx5IHJ1biBpZiBbbnVtX2ZpcmVzX3RvX3NraXBcbiAgICAgICAgID0gMF0sIGFuZCBvdGhlcndpc2UganVzdCBkZWNyZW1lbnQgaXQuICBTbywgdG8gcmVzY2hlZHVsZSBhbiBldmVudCBpbiBzdWNoIGFcbiAgICAgICAgIHN0YXRlLCB3ZSBpbmNyZW1lbnQgW251bV9maXJlc190b19za2lwXSBhbmQgYWRkIGEgbmV3IGFsYXJtIHRvIHRoZSB0aW1pbmdcbiAgICAgICAgIHdoZWVsLiAqKVxuICAgICAgbXV0YWJsZSBudW1fZmlyZXNfdG9fc2tpcCA6IGludFxuICAgIDsgKCogW3NjaGVkdWxlZF9hdF0gaXMgdGhlIHRpbWUgYXQgd2hpY2ggW3RdIGhhcyBtb3N0IHJlY2VudGx5IGJlZW4gc2NoZWR1bGVkIHRvIGZpcmUuXG4gICAgICAgICBXaGlsZSBbdC5hbGFybV0gaXMgc3RpbGwgaW4gdGhlIHRpbWluZyB3aGVlbCwgdGhpcyBpcyB0aGUgc2FtZSBhcyBbQWxhcm0uYXRcbiAgICAgICAgIHQuYWxhcm1dLiAqKVxuICAgICAgbXV0YWJsZSBzY2hlZHVsZWRfYXQgOiBUaW1lX25zLnRcbiAgICA7IHRpbWVfc291cmNlIDogU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICB0eXBlIHRfdW5pdCA9ICh1bml0LCB1bml0KSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGZpcmVkIHQgPSBJdmFyLnJlYWQgdC5maXJlZFxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgaW52YXJpYW50X2ggdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGV2ZW50cyA9IHQudGltZV9zb3VyY2UuZXZlbnRzIGluXG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5hbGFybTpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmZpcmVkXG4gICAgICAgICAgICAgdGhlbiBhc3NlcnQgKG5vdCAoVGltaW5nX3doZWVsLm1lbSBldmVudHMgYWxhcm0pKVxuICAgICAgICAgICAgIGVsc2UgaWYgVGltaW5nX3doZWVsLm1lbSBldmVudHMgYWxhcm1cbiAgICAgICAgICAgICB0aGVuIGFzc2VydCAoSm9iX29yX2V2ZW50LmlzX2pvYiAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSkpKVxuICAgICAgICB+ZmlyZTppZ25vcmVcbiAgICAgICAgfmZpcmVkOlxuICAgICAgICAgIChjaGVjayAoZnVuIChmaXJlZCA6IF8gRmlyZWQudCBJdmFyLnQpIC0+XG4gICAgICAgICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIGZpcmVkKSB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IGludmFyaWFudF9hIGFcbiAgICAgICAgICAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IGludmFyaWFudF9oIGgpKVxuICAgICAgICB+bnVtX2ZpcmVzX3RvX3NraXA6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbnVtX2ZpcmVzX3RvX3NraXAgLT4gYXNzZXJ0IChudW1fZmlyZXNfdG9fc2tpcCA+PSAwKSkpXG4gICAgICAgIH5zY2hlZHVsZWRfYXQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gc2NoZWR1bGVkX2F0IC0+XG4gICAgICAgICAgICAgaWYgVGltaW5nX3doZWVsLm1lbSBldmVudHMgdC5hbGFybVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICAgICAgc2NoZWR1bGVkX2F0XG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6KEFsYXJtLmF0IGV2ZW50cyB0LmFsYXJtKSkpXG4gICAgICAgIH50aW1lX3NvdXJjZTppZ25vcmUpXG4gIDs7XG5cbiAgbW9kdWxlIFN0YXR1cyA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICB8IEFib3J0ZWQgb2YgJ2FcbiAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICAgIHwgU2NoZWR1bGVkX2F0IG9mIFRpbWVfbnMudFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBzdGF0dXMgdCA6IF8gU3RhdHVzLnQgPVxuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKEl2YXIucmVhZCB0LmZpcmVkKSB3aXRoXG4gICAgfCBOb25lIC0+IFNjaGVkdWxlZF9hdCB0LnNjaGVkdWxlZF9hdFxuICAgIHwgU29tZSAoQWJvcnRlZCBhKSAtPiBBYm9ydGVkIGFcbiAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IEhhcHBlbmVkIGhcbiAgOztcblxuICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgT2tcbiAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIG9mICdhXG4gICAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgb2YgJ2hcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgYWJvcnQgdCBhIDogXyBBYm9ydF9yZXN1bHQudCA9XG4gICAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJUaW1lX3NvdXJjZS5FdmVudC5hYm9ydFwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoZmlyZWQgdCkgd2l0aFxuICAgIHwgU29tZSAoQWJvcnRlZCBhKSAtPiBQcmV2aW91c2x5X2Fib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gUHJldmlvdXNseV9oYXBwZW5lZCBoXG4gICAgfCBOb25lIC0+XG4gICAgICBJdmFyLmZpbGwgdC5maXJlZCAoQWJvcnRlZCBhKTtcbiAgICAgIHJlbW92ZV9hbGFybV9pZl9zY2hlZHVsZWQgdC50aW1lX3NvdXJjZSB0LmFsYXJtO1xuICAgICAgT2tcbiAgOztcblxuICBsZXQgYWJvcnRfZXhuIHQgYSA9XG4gICAgbWF0Y2ggYWJvcnQgdCBhIHdpdGhcbiAgICB8IE9rIC0+ICgpXG4gICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkIF8gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQ2xvY2suRXZlbnQuYWJvcnRfZXhuIGZhaWxlZCB0byBhYm9ydCBldmVudCB0aGF0IHByZXZpb3VzbHkgaGFwcGVuZWRcIl1cbiAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCBfIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkNsb2NrLkV2ZW50LmFib3J0X2V4biBmYWlsZWQgdG8gYWJvcnQgZXZlbnQgdGhhdCBwcmV2aW91c2x5IGFib3J0ZWRcIl1cbiAgOztcblxuICBsZXQgYWJvcnRfaWZfcG9zc2libGUgdCBhID0gaWdub3JlIChhYm9ydCB0IGEgOiBfIEFib3J0X3Jlc3VsdC50KVxuICBsZXQgc2NoZWR1bGUgdCA9IHQuYWxhcm0gPC0gcnVuX2F0X2ludGVybmFsIHQudGltZV9zb3VyY2UgdC5zY2hlZHVsZWRfYXQgdC5maXJlICgpXG5cbiAgbW9kdWxlIFJlc2NoZWR1bGVfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgT2tcbiAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIG9mICdhXG4gICAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgb2YgJ2hcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IGF0IDogXyBSZXNjaGVkdWxlX3Jlc3VsdC50ID1cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LnJlc2NoZWR1bGVfYXRcIiAodCwgYXQpIFslc2V4cF9vZjogKF8sIF8pIHQgKiBUaW1lX25zLnRdO1xuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKGZpcmVkIHQpIHdpdGhcbiAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gUHJldmlvdXNseV9hYm9ydGVkIGFcbiAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IFByZXZpb3VzbHlfaGFwcGVuZWQgaFxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IGV2ZW50cyA9IHQudGltZV9zb3VyY2UuZXZlbnRzIGluXG4gICAgICBsZXQgaXNfaW5fdGltaW5nX3doZWVsID0gVGltaW5nX3doZWVsLm1lbSBldmVudHMgdC5hbGFybSBpblxuICAgICAgbGV0IGFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZV9mdXR1cmUgPVxuICAgICAgICBUaW1lX25zLiggPiApIGF0IChUaW1pbmdfd2hlZWwubm93IGV2ZW50cylcbiAgICAgIGluXG4gICAgICB0LnNjaGVkdWxlZF9hdCA8LSBhdDtcbiAgICAgIChtYXRjaCBhbV90cnlpbmdfdG9fcmVzY2hlZHVsZV9pbl90aGVfZnV0dXJlLCBpc19pbl90aW1pbmdfd2hlZWwgd2l0aFxuICAgICAgIHwgZmFsc2UsIGZhbHNlIC0+ICgpXG4gICAgICAgfCBmYWxzZSwgdHJ1ZSAtPlxuICAgICAgICAgdC50aW1lX3NvdXJjZS5oYW5kbGVfZmlyZWQgdC5hbGFybTtcbiAgICAgICAgIFRpbWluZ193aGVlbC5yZW1vdmUgZXZlbnRzIHQuYWxhcm1cbiAgICAgICB8IHRydWUsIGZhbHNlIC0+XG4gICAgICAgICB0Lm51bV9maXJlc190b19za2lwIDwtIHQubnVtX2ZpcmVzX3RvX3NraXAgKyAxO1xuICAgICAgICAgc2NoZWR1bGUgdFxuICAgICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBUaW1pbmdfd2hlZWwucmVzY2hlZHVsZSBldmVudHMgdC5hbGFybSB+YXQpO1xuICAgICAgT2tcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hZnRlciB0IHNwYW4gPSByZXNjaGVkdWxlX2F0IHQgKHNwYW5fdG9fdGltZSB0LnRpbWVfc291cmNlIHNwYW4pXG5cbiAgbGV0IHJ1bl9hdCB0aW1lX3NvdXJjZSBzY2hlZHVsZWRfYXQgZiB6ID1cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LnJ1bl9hdFwiIHNjaGVkdWxlZF9hdCBbJXNleHBfb2Y6IFRpbWVfbnMudF07XG4gICAgbGV0IHQgPVxuICAgICAgeyBhbGFybSA9IEFsYXJtLm51bGwgKClcbiAgICAgIDsgZmlyZSA9IGlnbm9yZSAoKiBzZXQgYmVsb3cgKilcbiAgICAgIDsgZmlyZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgOyBudW1fZmlyZXNfdG9fc2tpcCA9IDBcbiAgICAgIDsgc2NoZWR1bGVkX2F0XG4gICAgICA7IHRpbWVfc291cmNlID0gcmVhZF9vbmx5IHRpbWVfc291cmNlXG4gICAgICB9XG4gICAgaW5cbiAgICBsZXQgZmlyZSAoKSA9XG4gICAgICAoKiBbZmlyZV0gcnVucyBpbiBhbiBBc3luYyBqb2IuICBUaGUgZXZlbnQgbWF5IGhhdmUgYmVlbiBhYm9ydGVkIGFmdGVyIHRoZSBqb2JcbiAgICAgICAgIHdhcyBlbnF1ZXVlZCwgc28gW2ZpcmVdIG11c3QgY2hlY2sgW2ZpcmVkXS4gKilcbiAgICAgIGlmIEl2YXIuaXNfZW1wdHkgdC5maXJlZFxuICAgICAgdGhlblxuICAgICAgICBpZiB0Lm51bV9maXJlc190b19za2lwID4gMFxuICAgICAgICB0aGVuIHQubnVtX2ZpcmVzX3RvX3NraXAgPC0gdC5udW1fZmlyZXNfdG9fc2tpcCAtIDFcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGYgeiBpblxuICAgICAgICAgICgqIFtmIHpdIG1heSBoYXZlIGFib3J0ZWQgdGhlIGV2ZW50LCBzbyB3ZSBtdXN0IGNoZWNrIFtmaXJlZF0gYWdhaW4uICopXG4gICAgICAgICAgaWYgSXZhci5pc19lbXB0eSB0LmZpcmVkIHRoZW4gSXZhci5maWxsIHQuZmlyZWQgKEhhcHBlbmVkIHJlc3VsdCkpXG4gICAgaW5cbiAgICB0LmZpcmUgPC0gZmlyZTtcbiAgICBzY2hlZHVsZSB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgYXQgdGltZV9zb3VyY2UgdGltZSA9IHJ1bl9hdCB0aW1lX3NvdXJjZSB0aW1lIGlnbm9yZSAoKVxuXG4gIGxldCBydW5fYWZ0ZXIgdGltZV9zb3VyY2Ugc3BhbiBmIGEgPVxuICAgIHJ1bl9hdCB0aW1lX3NvdXJjZSAoc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW4pIGYgYVxuICA7O1xuXG4gIGxldCBhZnRlciB0aW1lX3NvdXJjZSBzcGFuID0gYXQgdGltZV9zb3VyY2UgKHNwYW5fdG9fdGltZSB0aW1lX3NvdXJjZSBzcGFuKVxuZW5kXG5cbmxldCBhdF90aW1lcyA/KHN0b3AgPSBEZWZlcnJlZC5uZXZlciAoKSkgdCBuZXh0X3RpbWUgPVxuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgY2hvb3NlXG4gICAgICBbIGNob2ljZSBzdG9wIChmdW4gKCkgLT4gYFN0b3ApOyBjaG9pY2UgKGF0IHQgKG5leHRfdGltZSAoKSkpIChmdW4gKCkgLT4gYFRpY2spIF1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IGBTdG9wIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICB8IGBUaWNrIC0+XG4gICAgICBUYWlsLmV4dGVuZCB0YWlsICgpO1xuICAgICAgbG9vcCAoKVxuICBpblxuICBsb29wICgpO1xuICBUYWlsLmNvbGxlY3QgdGFpbFxuOztcblxubGV0IGF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wIHQgY29tcHV0ZV9zcGFuID1cbiAgYXRfdGltZXMgdCA/c3RvcCAoZnVuICgpIC0+IFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSAoY29tcHV0ZV9zcGFuICgpKSlcbjs7XG5cbmxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wIHQgaW50ZXJ2YWwgPVxuICBsZXQgc3RhcnQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+IG5vdyB0XG4gIGluXG4gIGF0X3RpbWVzIHQgP3N0b3AgKGZ1biAoKSAtPlxuICAgIFRpbWVfbnMubmV4dF9tdWx0aXBsZSB+YmFzZTpzdGFydCB+YWZ0ZXI6KG5vdyB0KSB+aW50ZXJ2YWwgKCkpXG47O1xuXG5tb2R1bGUgQ29udGludWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEltbWVkaWF0ZWx5XG4gICAgfCBBZnRlciBvZiBUaW1lX25zLlNwYW4udFxuICAgIHwgTmV4dF9tdWx0aXBsZSBvZiBUaW1lX25zLnQgKiBUaW1lX25zLlNwYW4udFxuXG4gIGxldCBpbW1lZGlhdGVseSA9IEltbWVkaWF0ZWx5XG5cbiAgbGV0IGF0IHQgdGltZV9zb3VyY2UgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgSW1tZWRpYXRlbHkgLT4gVGltaW5nX3doZWVsLm5vdyB0aW1lX3NvdXJjZS5ldmVudHNcbiAgICB8IEFmdGVyIHNwYW4gLT4gc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW5cbiAgICB8IE5leHRfbXVsdGlwbGUgKGJhc2UsIGludGVydmFsKSAtPlxuICAgICAgVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlIH5hZnRlcjoobm93IHRpbWVfc291cmNlKSB+aW50ZXJ2YWwgKClcbiAgOztcbmVuZFxuXG5sZXQgcnVuX3JlcGVhdGVkbHlcbiAgICAgID8oc3RhcnQgPSByZXR1cm4gKCkpXG4gICAgICA/c3RvcFxuICAgICAgPyhjb250aW51ZV9vbl9lcnJvciA9IHRydWUpXG4gICAgICA/KGZpbmlzaGVkID0gSXZhci5jcmVhdGUgKCkpXG4gICAgICB0XG4gICAgICB+ZlxuICAgICAgfmNvbnRpbnVlXG4gID1cbiAgc3RhcnRcbiAgPj4+IGZ1biAoKSAtPlxuICBsZXQgYWxhcm0gPSByZWYgKEFsYXJtLm51bGwgKCkpIGluXG4gIGxldCBzdG9wID1cbiAgICBtYXRjaCBzdG9wIHdpdGhcbiAgICB8IE5vbmUgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICB8IFNvbWUgc3RvcCAtPlxuICAgICAgdXBvbiBzdG9wIChmdW4gKCkgLT5cbiAgICAgICAgaWYgVGltaW5nX3doZWVsLm1lbSB0LmV2ZW50cyAhYWxhcm1cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcmVtb3ZlX2FsYXJtIHQgIWFsYXJtO1xuICAgICAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKSkpO1xuICAgICAgc3RvcFxuICBpblxuICAoKiBbcnVuX2ZdLCBbY29udGludWVfZl0sIGFuZCBbY29udGludWVfdHJ5X3dpdGhdIGFyZSBkZWZpbmVkIHNvIHRoYXQgd2UgYWxsb2NhdGUgdGhlaXJcbiAgICAgY2xvc3VyZXMgb25jZSwgbm90IG9uY2UgcGVyIGl0ZXJhdGlvbi4gKilcbiAgbGV0IHJlYyBydW5fZiAoKSA9XG4gICAgKCogQmVmb3JlIGNhbGxpbmcgW2ZdLCB3ZSBzeW5jaHJvbm91c2x5IGNoZWNrIHdoZXRoZXIgW3N0b3BdIGlzIGRldGVybWluZWQuICopXG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBzdG9wXG4gICAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgZmluaXNoZWQgKClcbiAgICBlbHNlIGlmIGNvbnRpbnVlX29uX2Vycm9yXG4gICAgdGhlbiBNb25pdG9yLnRyeV93aXRoIGYgfnJ1bjpgTm93IH5yZXN0OmBSYWlzZSA+Pj4gY29udGludWVfdHJ5X3dpdGhcbiAgICBlbHNlIChcbiAgICAgIGxldCBkID0gZiAoKSBpblxuICAgICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBkIHRoZW4gY29udGludWVfZiAoKSBlbHNlIGQgPj4+IGNvbnRpbnVlX2YpXG4gIGFuZCBjb250aW51ZV9mICgpID1cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICB0aGVuIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKVxuICAgIGVsc2UgYWxhcm0gOj0gcnVuX2F0X2ludGVybmFsIHQgKENvbnRpbnVlLmF0IGNvbnRpbnVlIHQpIHJ1bl9mICgpXG4gIGFuZCBjb250aW51ZV90cnlfd2l0aCBvcl9lcnJvciA9XG4gICAgKG1hdGNoIG9yX2Vycm9yIHdpdGhcbiAgICAgfCBPayAoKSAtPiAoKVxuICAgICB8IEVycm9yIGVycm9yIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXJyb3IpO1xuICAgIGNvbnRpbnVlX2YgKClcbiAgaW5cbiAgcnVuX2YgKClcbjs7XG5cbmxldCBldmVyeScgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgdCBzcGFuIGYgPVxuICBpZiBUaW1lX25zLlNwYW4uKCA8PSApIHNwYW4gVGltZV9ucy5TcGFuLnplcm9cbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWVfc291cmNlLmV2ZXJ5IGdvdCBub25wb3NpdGl2ZSBzcGFuXCIgKHNwYW4gOiBUaW1lX25zLlNwYW4udCldO1xuICBydW5fcmVwZWF0ZWRseSB0ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgP2ZpbmlzaGVkIH5mIH5jb250aW51ZTooQWZ0ZXIgc3Bhbilcbjs7XG5cbmxldCBldmVyeSA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgc3BhbiBmID1cbiAgZXZlcnknIHQgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQ6Tm9uZSBzcGFuIChmdW4gKCkgLT5cbiAgICBmICgpO1xuICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgaW50ZXJ2YWwgZiA9XG4gIGxldCBub3cgPSBub3cgdCBpblxuICBsZXQgYmFzZSwgc3RhcnQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IE5vbmUgLT4gbm93LCBOb25lXG4gICAgfCBTb21lIHN0YXJ0IC0+XG4gICAgICAoIHN0YXJ0XG4gICAgICAsIFNvbWVcbiAgICAgICAgICAoYXRcbiAgICAgICAgICAgICB0XG4gICAgICAgICAgICAgKFRpbWVfbnMubmV4dF9tdWx0aXBsZVxuICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICAgfmJhc2U6c3RhcnRcbiAgICAgICAgICAgICAgICB+YWZ0ZXI6bm93XG4gICAgICAgICAgICAgICAgfmNhbl9lcXVhbF9hZnRlcjp0cnVlXG4gICAgICAgICAgICAgICAgfmludGVydmFsKSkgKVxuICBpblxuICBydW5fcmVwZWF0ZWRseVxuICAgIHRcbiAgICA/c3RhcnRcbiAgICA/c3RvcFxuICAgID9jb250aW51ZV9vbl9lcnJvclxuICAgIH5mXG4gICAgfmNvbnRpbnVlOihOZXh0X211bHRpcGxlIChiYXNlLCBpbnRlcnZhbCkpXG47O1xuXG5sZXQgcnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHQgaW50ZXJ2YWwgZiA9XG4gIHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCAoZnVuICgpIC0+XG4gICAgZiAoKTtcbiAgICByZXR1cm4gKCkpXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0IHQgc3BhbiBkID1cbiAgbGV0IHRpbWVvdXQgPSBFdmVudC5hZnRlciB0IHNwYW4gaW5cbiAgY2hvb3NlXG4gICAgKCogVGhlIGNvZGUgYmVsb3cgZG9lcyBleGhhdXN0aXZlIGNhc2UgYW5hbHlzaXMgaW4gYm90aCBbY2hvaWNlXXMuICBCZWNhdXNlIFt0aW1lb3V0XVxuICAgICAgIGRvZXMgbm90IGVzY2FwZSB0aGUgc2NvcGUgb2YgdGhpcyBmdW5jdGlvbiwgY2VydGFpbiBjYXNlcyBzaG91bGQgYmUgaW1wb3NzaWJsZSwgYW5kXG4gICAgICAgYXJlIG1hcmtlZCBhcyBzdWNoIHdpdGggZXhjZXB0aW9ucy4gIFdlIGRvIG5vdCBleHBlY3QgdGhvc2UgZXhjZXB0aW9ucyB0byBvY2N1cixcbiAgICAgICBidXQgaWYgdGhleSBkbywgaXQgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBbY2hvb3NlXSByYXRoZXIgdGhhblxuICAgICAgIFt3aXRoX3RpbWVvdXRdLiAqKVxuICAgIFsgY2hvaWNlIGQgKGZ1biB2IC0+XG4gICAgICAgIChtYXRjaCBFdmVudC5hYm9ydCB0aW1lb3V0ICgpIHdpdGhcbiAgICAgICAgICgqIFtQcmV2aW91c2x5X2hhcHBlbmVkXSBjYW4gb2NjdXIgaWYgYm90aCBbZF0gYW5kIFt3YWl0XSBiZWNvbWUgZGV0ZXJtaW5lZCBhdFxuICAgICAgICAgICAgdGhlIHNhbWUgdGltZSwgZS5nLiBbd2l0aF90aW1lb3V0IChzZWMgMC4pIChyZXR1cm4gKCkpXS4gKilcbiAgICAgICAgIHwgT2sgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+ICgpXG4gICAgICAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCAoKSAtPlxuICAgICAgICAgICByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWVfc291cmNlLndpdGhfdGltZW91dCBidWc6IHNob3VsZCBvbmx5IGFib3J0IG9uY2VcIl0pO1xuICAgICAgICBgUmVzdWx0IHYpXG4gICAgOyBjaG9pY2UgKEV2ZW50LmZpcmVkIHRpbWVvdXQpIChmdW5jdGlvblxuICAgICAgICB8IEhhcHBlbmVkICgpIC0+IGBUaW1lb3V0XG4gICAgICAgIHwgQWJvcnRlZCAoKSAtPlxuICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZSBcIlRpbWVfc291cmNlLndpdGhfdGltZW91dCBidWc6IGJvdGggY29tcGxldGVkIGFuZCB0aW1lZCBvdXRcIl0pXG4gICAgXVxuOztcblxubGV0IGR1cmF0aW9uX29mIHQgZiA9XG4gIGxldCBzdGFydCA9IG5vdyB0IGluXG4gIGxldCVtYXAgcmVzdWx0ID0gZiAoKSBpblxuICBsZXQgZHVyYXRpb24gPSBUaW1lX25zLmRpZmYgKG5vdyB0KSBzdGFydCBpblxuICByZXN1bHQsIGR1cmF0aW9uXG47O1xuXG5sZXQgb2Zfc3luY2hyb25vdXMgdCA9IHRcbmxldCB0b19zeW5jaHJvbm91cyB0ID0gdFxuIiwib3BlbiEgQmFzZVxuXG50eXBlIF8gdCA9XG4gIHwgU3RhY2sgOiAnYSBTdGFjay50IC0+ICdhIHRcbiAgfCBDb3VudGVyIDogeyBtdXRhYmxlIGxlbmd0aCA6IGludCB9IC0+IHVuaXQgdFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IG9mX2xpc3QgbGlzdCA9IFN0YWNrIChTdGFjay5vZl9saXN0IGxpc3QpXG5cbmxldCBjcmVhdGVfY291bnRlciB+bGVuZ3RoID1cbiAgaWYgbGVuZ3RoIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiW1N0YWNrX29yX2NvdW50ZXIuY3JlYXRlX2NvdW50ZXJdIGdvdCBuZWdhdGl2ZSBsZW5ndGhcIiAobGVuZ3RoIDogaW50KV07XG4gIENvdW50ZXIgeyBsZW5ndGggfVxuOztcblxubGV0IGxlbmd0aCAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLmxlbmd0aCBzXG4gIHwgQ291bnRlciByIC0+IHIubGVuZ3RoXG47O1xuXG5sZXQgY2xlYXIgKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5jbGVhciBzXG4gIHwgQ291bnRlciByIC0+IHIubGVuZ3RoIDwtIDBcbjs7XG5cbmxldCBwdXNoICh0eXBlIGEpICh0IDogYSB0KSBhID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5wdXNoIHMgYVxuICB8IENvdW50ZXIgciAtPiByLmxlbmd0aCA8LSByLmxlbmd0aCArIDFcbjs7XG5cbmxldCBwb3BfZXhuICh0eXBlIGEpICh0IDogYSB0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2sucG9wX2V4biBzXG4gIHwgQ291bnRlciByIC0+XG4gICAgaWYgci5sZW5ndGggPSAwIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJbU3RhY2tfb3JfY291bnRlci5wb3BfZXhuXSBvZiBlbXB0eSBzdGFja1wiXTtcbiAgICByLmxlbmd0aCA8LSByLmxlbmd0aCAtIDFcbjs7XG5cbmxldCBpdGVyICh0eXBlIGEpICh0IDogYSB0KSB+KGYgOiBhIC0+IHVuaXQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5pdGVyIHMgfmZcbiAgfCBDb3VudGVyIHIgLT5cbiAgICBmb3IgXyA9IDEgdG8gci5sZW5ndGggZG9cbiAgICAgIGYgKClcbiAgICBkb25lXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG50eXBlICdhIG91dGNvbWUgPVxuICBbIGBPayBvZiAnYVxuICB8IGBBYm9ydGVkXG4gIHwgYFJhaXNlZCBvZiBleG5cbiAgXVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIEludGVybmFsX2pvYiA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB2YWwgY3JlYXRlIDogKCdhIC0+ICdiIERlZmVycmVkLnQpIC0+ICdhIHQgKiAnYiBvdXRjb21lIERlZmVycmVkLnRcblxuICAoKiBFdmVyeSBpbnRlcm5hbCBqb2Igd2lsbCBldmVudHVhbGx5IGJlIGVpdGhlciBbcnVuXSBvciBbYWJvcnRdZWQsIGJ1dCBub3QgYm90aC4gKilcblxuICB2YWwgcnVuIDogJ2EgdCAtPiAnYSAtPiBbIGBPayB8IGBSYWlzZWQgXSBEZWZlcnJlZC50XG4gIHZhbCBhYm9ydCA6IF8gdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHN0YXJ0IDogWyBgQWJvcnQgfCBgU3RhcnQgb2YgJ2EgXSBJdmFyLnRcbiAgICA7IG91dGNvbWUgOiBbIGBPayB8IGBBYm9ydGVkIHwgYFJhaXNlZCBdIERlZmVycmVkLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSB3b3JrID1cbiAgICBsZXQgc3RhcnQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZXN1bHQgPVxuICAgICAgbWF0Y2glYmluZCBJdmFyLnJlYWQgc3RhcnQgd2l0aFxuICAgICAgfCBgQWJvcnQgLT4gcmV0dXJuIGBBYm9ydGVkXG4gICAgICB8IGBTdGFydCBhIC0+XG4gICAgICAgIChtYXRjaCVtYXBcbiAgICAgICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICAgICAgIH5ydW46XG4gICAgICAgICAgICAgICBgU2NoZWR1bGVcbiAgICAgICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgICAgICAgKGZ1biAoKSAtPiB3b3JrIGEpXG4gICAgICAgICB3aXRoXG4gICAgICAgICB8IE9rIGEgLT4gYE9rIGFcbiAgICAgICAgIHwgRXJyb3IgZXhuIC0+IGBSYWlzZWQgZXhuKVxuICAgIGluXG4gICAgbGV0IG91dGNvbWUgPVxuICAgICAgbWF0Y2glbWFwIHJlc3VsdCB3aXRoXG4gICAgICB8IGBPayBfIC0+IGBPa1xuICAgICAgfCBgQWJvcnRlZCAtPiBgQWJvcnRlZFxuICAgICAgfCBgUmFpc2VkIF8gLT4gYFJhaXNlZFxuICAgIGluXG4gICAgbGV0IHQgPSB7IHN0YXJ0OyBvdXRjb21lIH0gaW5cbiAgICB0LCByZXN1bHRcbiAgOztcblxuICBsZXQgcnVuIHQgYSA9XG4gICAgSXZhci5maWxsIHQuc3RhcnQgKGBTdGFydCBhKTtcbiAgICBtYXRjaCVtYXAgdC5vdXRjb21lIHdpdGhcbiAgICB8IGBBYm9ydGVkIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGBPayB8IGBSYWlzZWQpIGFzIHggLT4geFxuICA7O1xuXG4gIGxldCBhYm9ydCB0ID0gSXZhci5maWxsIHQuc3RhcnQgYEFib3J0XG5lbmRcblxudHlwZSAnYSB0ID1cbiAgeyBjb250aW51ZV9vbl9lcnJvciA6IGJvb2xcbiAgOyBtYXhfY29uY3VycmVudF9qb2JzIDogaW50XG4gIDsgKCogW2pvYl9yZXNvdXJjZXNfbm90X2luX3VzZV0gaG9sZHMgcmVzb3VyY2VzIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgaW4gdXNlIGJ5IGFcbiAgICAgICBydW5uaW5nIGpvYi4gKilcbiAgICBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgOiAnYSBTdGFja19vcl9jb3VudGVyLnRcbiAgO1xuICAgICgqIFtqb2JzX3dhaXRpbmdfdG9fc3RhcnRdIGlzIHRoZSBxdWV1ZSBvZiBqb2JzIHRoYXQgaGF2ZW4ndCB5ZXQgc3RhcnRlZC4gKilcbiAgICBqb2JzX3dhaXRpbmdfdG9fc3RhcnQgOiAnYSBJbnRlcm5hbF9qb2IudCBRdWV1ZS50XG4gIDsgKCogWzAgPD0gbnVtX2pvYnNfcnVubmluZyA8PSBtYXhfY29uY3VycmVudF9qb2JzXS4gKilcbiAgICBtdXRhYmxlIG51bV9qb2JzX3J1bm5pbmcgOiBpbnRcbiAgOyAoKiBbY2FwYWNpdHlfYXZhaWxhYmxlXSBpcyBbU29tZSBpdmFyXSBpZiB1c2VyIGNvZGUgaGFzIGNhbGxlZCBbY2FwYWNpdHlfYXZhaWxhYmxlIHRdXG4gICAgICAgYW5kIGlzIHdhaXRpbmcgdG8gYmUgbm90aWZpZWQgd2hlbiBjYXBhY2l0eSBpcyBhdmFpbGFibGUgaW4gdGhlIHRocm90dGxlLlxuICAgICAgIFttYXliZV9zdGFydF9qb2JdIHdpbGwgZmlsbCBbaXZhcl0gd2hlbiBjYXBhY2l0eSBiZWNvbWVzIGF2YWlsYWJsZSwgaS5lLiB3aGVuXG4gICAgICAgW2pvYnNfd2FpdGluZ190b19zdGFydF0gaXMgZW1wdHkgYW5kIFtudW1fam9ic19ydW5uaW5nIDwgbWF4X2NvbmN1cnJlbnRfam9ic10uICopXG4gICAgbXV0YWJsZSBjYXBhY2l0eV9hdmFpbGFibGUgOiB1bml0IEl2YXIudCBvcHRpb25cbiAgOyAoKiBbaXNfZGVhZF0gaXMgdHJ1ZSBpZiBbdF0gd2FzIGtpbGxlZCBkdWUgdG8gYSBqb2IgcmFpc2luZyBhbiBleGNlcHRpb24gb3IgW2tpbGwgdF1cbiAgICAgICBiZWluZyBjYWxsZWQuICopXG4gICAgbXV0YWJsZSBpc19kZWFkIDogYm9vbFxuICA7ICgqIFtjbGVhbnNdIGhvbGRzIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGNsZWFuIGVhY2ggcmVzb3VyY2Ugd2hlbiBbdF0gaXNcbiAgICAgICBraWxsZWQuICopXG4gICAgbXV0YWJsZSBjbGVhbnMgOiAoJ2EgLT4gdW5pdCBEZWZlcnJlZC50KSBsaXN0XG4gIDsgKCogW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIGlzIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHdob3NlIGNsZWFuIGZ1bmN0aW9ucyBoYXZlXG4gICAgICAgbm90IHlldCBjb21wbGV0ZWQuICBXaGlsZSBbdF0gaXMgYWxpdmUsIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID1cbiAgICAgICBtYXhfY29uY3VycmVudF9qb2JzXS4gIE9uY2UgW3RdIGlzIGtpbGxlZCwgW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIGRlY3JlYXNlcyB0b1xuICAgICAgIHplcm8gb3ZlciB0aW1lIGFzIHRoZSBjbGVhbiBmdW5jdGlvbnMgY29tcGxldGUuICopXG4gICAgbXV0YWJsZSBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDogaW50XG4gIDsgKCogW2NsZWFuZWRdIGJlY29tZXMgZGV0ZXJtaW5lZCB3aGVuIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXSByZWFjaGVzIHplcm8sXG4gICAgICAgaS5lLiBhZnRlciBbdF0gaXMga2lsbGVkIGFuZCBhbGwgaXRzIGNsZWFuIGZ1bmN0aW9ucyBjb21wbGV0ZS4gKilcbiAgICBjbGVhbmVkIDogdW5pdCBJdmFyLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgOiB1bml0ID1cbiAgdHJ5XG4gICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmNvbnRpbnVlX29uX2Vycm9yOmlnbm9yZVxuICAgICAgfm1heF9jb25jdXJyZW50X2pvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9jb25jdXJyZW50X2pvYnMgLT4gYXNzZXJ0IChtYXhfY29uY3VycmVudF9qb2JzID4gMCkpKVxuICAgICAgfmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZTpcbiAgICAgICAgKGNoZWNrIChmdW4gam9iX3Jlc291cmNlc19ub3RfaW5fdXNlIC0+XG4gICAgICAgICAgIFN0YWNrX29yX2NvdW50ZXIuaXRlciBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgfmY6aW52YXJpYW50X2E7XG4gICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgU3RhY2tfb3JfY291bnRlci5sZW5ndGggam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXG4gICAgICAgICAgICAgPSBpZiB0LmlzX2RlYWQgdGhlbiAwIGVsc2UgdC5tYXhfY29uY3VycmVudF9qb2JzIC0gdC5udW1fam9ic19ydW5uaW5nKSkpXG4gICAgICB+am9ic193YWl0aW5nX3RvX3N0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uIGpvYnNfd2FpdGluZ190b19zdGFydCAtPlxuICAgICAgICAgICBpZiB0LmlzX2RlYWQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGpvYnNfd2FpdGluZ190b19zdGFydCkpKVxuICAgICAgfm51bV9qb2JzX3J1bm5pbmc6XG4gICAgICAgIChjaGVjayAoZnVuIG51bV9qb2JzX3J1bm5pbmcgLT5cbiAgICAgICAgICAgYXNzZXJ0IChudW1fam9ic19ydW5uaW5nID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKG51bV9qb2JzX3J1bm5pbmcgPD0gdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgICAgICAgICAgaWYgbnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgICAgICB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQpKSlcbiAgICAgIH5jYXBhY2l0eV9hdmFpbGFibGU6XG4gICAgICAgIChjaGVjayAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgIHwgU29tZSBpdmFyIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKSkpXG4gICAgICB+aXNfZGVhZDppZ25vcmVcbiAgICAgIH5jbGVhbnM6aWdub3JlXG4gICAgICB+bnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZDpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCAtPlxuICAgICAgICAgICBhc3NlcnQgKG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA8PSB0Lm1heF9jb25jdXJyZW50X2pvYnMpO1xuICAgICAgICAgICBpZiBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDwgdC5tYXhfY29uY3VycmVudF9qb2JzIHRoZW4gYXNzZXJ0IHQuaXNfZGVhZCkpXG4gICAgICB+Y2xlYW5lZDpcbiAgICAgICAgKGNoZWNrIChmdW4gY2xlYW5lZCAtPlxuICAgICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgY2xlYW5lZCB0aGVuIGFzc2VydCAodC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gMCkpKVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiVGhyb3R0bGUuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pICh0IDogXyB0KV1cbjs7XG5cbm1vZHVsZSBUMiA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdraW5kKSB0ID0gJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgXyB0ID0gaW52YXJpYW50IGludmFyaWFudF9hIHRcbmVuZFxuXG5sZXQgbnVtX2pvYnNfd2FpdGluZ190b19zdGFydCB0ID0gUXVldWUubGVuZ3RoIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0XG5cbmxldCBjbGVhbl9yZXNvdXJjZSB0IGEgPVxuICBEZWZlcnJlZC5hbGxfdW5pdCAoTGlzdC5tYXAgdC5jbGVhbnMgfmY6KGZ1biBmIC0+IGYgYSkpXG4gID4+PiBmdW4gKCkgLT5cbiAgdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDwtIHQubnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCAtIDE7XG4gIGlmIHQubnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA9IDAgdGhlbiBJdmFyLmZpbGwgdC5jbGVhbmVkICgpXG47O1xuXG5sZXQga2lsbCB0ID1cbiAgaWYgbm90IHQuaXNfZGVhZFxuICB0aGVuIChcbiAgICB0LmlzX2RlYWQgPC0gdHJ1ZTtcbiAgICBRdWV1ZS5pdGVyIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0IH5mOkludGVybmFsX2pvYi5hYm9ydDtcbiAgICBRdWV1ZS5jbGVhciB0LmpvYnNfd2FpdGluZ190b19zdGFydDtcbiAgICBTdGFja19vcl9jb3VudGVyLml0ZXIgdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgfmY6KGZ1biBhIC0+IGNsZWFuX3Jlc291cmNlIHQgYSk7XG4gICAgU3RhY2tfb3JfY291bnRlci5jbGVhciB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSlcbjs7XG5cbmxldCBhdF9raWxsIHQgZiA9XG4gICgqIFdlIHByZXNlcnZlIHRoZSBleGVjdXRpb24gY29udGV4dCBzbyB0aGF0IGV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBnbyB0byB0aGUgbW9uaXRvclxuICAgICBpbiBlZmZlY3Qgd2hlbiBbYXRfa2lsbF0gd2FzIGNhbGxlZC4gKilcbiAgbGV0IGYgPSB1bnN0YWdlIChNb25pdG9yLkV4cG9ydGVkX2Zvcl9zY2hlZHVsZXIucHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQnIGYpIGluXG4gIHQuY2xlYW5zIDwtIGYgOjogdC5jbGVhbnNcbjs7XG5cbmxldCBjbGVhbmVkIHQgPSBJdmFyLnJlYWQgdC5jbGVhbmVkXG5cbmxldCByZWMgc3RhcnRfam9iIHQgPVxuICBhc3NlcnQgKG5vdCB0LmlzX2RlYWQpO1xuICBhc3NlcnQgKHQubnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gIGFzc2VydCAobm90IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydCkpO1xuICBsZXQgam9iID0gUXVldWUuZGVxdWV1ZV9leG4gdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgaW5cbiAgdC5udW1fam9ic19ydW5uaW5nIDwtIHQubnVtX2pvYnNfcnVubmluZyArIDE7XG4gIGxldCBqb2JfcmVzb3VyY2UgPSBTdGFja19vcl9jb3VudGVyLnBvcF9leG4gdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgaW5cbiAgSW50ZXJuYWxfam9iLnJ1biBqb2Igam9iX3Jlc291cmNlXG4gID4+PiBmdW4gcmVzIC0+XG4gIHQubnVtX2pvYnNfcnVubmluZyA8LSB0Lm51bV9qb2JzX3J1bm5pbmcgLSAxO1xuICAobWF0Y2ggcmVzIHdpdGhcbiAgIHwgYE9rIC0+ICgpXG4gICB8IGBSYWlzZWQgLT4gaWYgbm90IHQuY29udGludWVfb25fZXJyb3IgdGhlbiBraWxsIHQpO1xuICBpZiB0LmlzX2RlYWRcbiAgdGhlbiBjbGVhbl9yZXNvdXJjZSB0IGpvYl9yZXNvdXJjZVxuICBlbHNlIChcbiAgICBTdGFja19vcl9jb3VudGVyLnB1c2ggdC5qb2JfcmVzb3VyY2VzX25vdF9pbl91c2Ugam9iX3Jlc291cmNlO1xuICAgIGlmIG5vdCAoUXVldWUuaXNfZW1wdHkgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQpXG4gICAgdGhlbiBzdGFydF9qb2IgdFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggdC5jYXBhY2l0eV9hdmFpbGFibGUgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgaXZhciAtPlxuICAgICAgICBJdmFyLmZpbGwgaXZhciAoKTtcbiAgICAgICAgdC5jYXBhY2l0eV9hdmFpbGFibGUgPC0gTm9uZSkpXG47O1xuXG5sZXQgY3JlYXRlX2ludGVybmFsIH5jb250aW51ZV9vbl9lcnJvciBqb2JfcmVzb3VyY2VzID1cbiAgbGV0IG1heF9jb25jdXJyZW50X2pvYnMgPSBTdGFja19vcl9jb3VudGVyLmxlbmd0aCBqb2JfcmVzb3VyY2VzIGluXG4gIHsgY29udGludWVfb25fZXJyb3JcbiAgOyBtYXhfY29uY3VycmVudF9qb2JzXG4gIDsgam9iX3Jlc291cmNlc19ub3RfaW5fdXNlID0gam9iX3Jlc291cmNlc1xuICA7IGpvYnNfd2FpdGluZ190b19zdGFydCA9IFF1ZXVlLmNyZWF0ZSAoKVxuICA7IG51bV9qb2JzX3J1bm5pbmcgPSAwXG4gIDsgY2FwYWNpdHlfYXZhaWxhYmxlID0gTm9uZVxuICA7IGlzX2RlYWQgPSBmYWxzZVxuICA7IGNsZWFucyA9IFtdXG4gIDsgbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA9IG1heF9jb25jdXJyZW50X2pvYnNcbiAgOyBjbGVhbmVkID0gSXZhci5jcmVhdGUgKClcbiAgfVxuOztcblxubGV0IGNyZWF0ZV93aXRoIH5jb250aW51ZV9vbl9lcnJvciBqb2JfcmVzb3VyY2VzID1cbiAgY3JlYXRlX2ludGVybmFsIH5jb250aW51ZV9vbl9lcnJvciAoU3RhY2tfb3JfY291bnRlci5vZl9saXN0IGpvYl9yZXNvdXJjZXMpXG47O1xuXG5tb2R1bGUgU2VxdWVuY2VyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSA/KGNvbnRpbnVlX29uX2Vycm9yID0gZmFsc2UpIGEgPSBjcmVhdGVfd2l0aCB+Y29udGludWVfb25fZXJyb3IgWyBhIF1cbmVuZFxuXG5sZXQgY3JlYXRlIH5jb250aW51ZV9vbl9lcnJvciB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gIGlmIG1heF9jb25jdXJyZW50X2pvYnMgPD0gMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGhyb3R0bGUuY3JlYXRlIHJlcXVpcmVzIHBvc2l0aXZlIG1heF9jb25jdXJyZW50X2pvYnMsIGJ1dCBnb3RcIlxuICAgICAgICAgIChtYXhfY29uY3VycmVudF9qb2JzIDogaW50KV07XG4gIGNyZWF0ZV9pbnRlcm5hbFxuICAgIH5jb250aW51ZV9vbl9lcnJvclxuICAgIChTdGFja19vcl9jb3VudGVyLmNyZWF0ZV9jb3VudGVyIH5sZW5ndGg6bWF4X2NvbmN1cnJlbnRfam9icylcbjs7XG5cbm1vZHVsZSBKb2IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB7IGludGVybmFsX2pvYiA6ICdhIEludGVybmFsX2pvYi50XG4gICAgOyByZXN1bHQgOiBbIGBPayBvZiAnYiB8IGBBYm9ydGVkIHwgYFJhaXNlZCBvZiBleG4gXSBEZWZlcnJlZC50XG4gICAgfVxuXG4gIGxldCByZXN1bHQgdCA9IHQucmVzdWx0XG4gIGxldCBhYm9ydCB0ID0gSW50ZXJuYWxfam9iLmFib3J0IHQuaW50ZXJuYWxfam9iXG5cbiAgbGV0IGNyZWF0ZSBmID1cbiAgICBsZXQgaW50ZXJuYWxfam9iLCByZXN1bHQgPSBJbnRlcm5hbF9qb2IuY3JlYXRlIGYgaW5cbiAgICB7IGludGVybmFsX2pvYjsgcmVzdWx0IH1cbiAgOztcbmVuZFxuXG5sZXQgZW5xdWV1ZScgdCBmID1cbiAgbGV0IGpvYiA9IEpvYi5jcmVhdGUgZiBpblxuICBpZiB0LmlzX2RlYWRcbiAgdGhlbiBKb2IuYWJvcnQgam9iXG4gIGVsc2UgKFxuICAgIFF1ZXVlLmVucXVldWUgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgam9iLmludGVybmFsX2pvYjtcbiAgICBpZiB0Lm51bV9qb2JzX3J1bm5pbmcgPCB0Lm1heF9jb25jdXJyZW50X2pvYnMgdGhlbiBzdGFydF9qb2IgdCk7XG4gIEpvYi5yZXN1bHQgam9iXG47O1xuXG5sZXQgaGFuZGxlX2VucXVldWVfcmVzdWx0IHJlc3VsdCA9XG4gIG1hdGNoIHJlc3VsdCB3aXRoXG4gIHwgYE9rIGEgLT4gYVxuICB8IGBBYm9ydGVkIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwidGhyb3R0bGUgYWJvcnRlZCBqb2JcIl1cbiAgfCBgUmFpc2VkIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBlbnF1ZXVlIHQgZiA9IGVucXVldWUnIHQgZiA+PnwgaGFuZGxlX2VucXVldWVfcmVzdWx0XG5cbmxldCBlbnF1ZXVlX2V4Y2x1c2l2ZSB0IGYgPVxuICBsZXQgbiA9IHQubWF4X2NvbmN1cnJlbnRfam9icyBpblxuICBpZiBJbnQuKCA+PSApIG4gMV8wMDBfMDAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJXNleHBcbiAgICAgICAgXCJbZW5xdWV1ZV9leGNsdXNpdmVdIHdhcyBjYWxsZWQgd2l0aCBhIHZlcnkgbGFyZ2UgdmFsdWUgb2YgXFxcbiAgICAgICAgIFttYXhfY29uY3VycmVudF9qb2JzXS4gVGhpcyBkb2Vzbid0IHdvcmsuXCJdO1xuICBsZXQgZG9uZV8gPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBhc3NlcnQgKG4gPiAwKTtcbiAgbGV0IGZfcGxhY2Vob2xkZXIgX3Nsb3QgPSBJdmFyLnJlYWQgZG9uZV8gaW5cbiAgZm9yIF8gPSAxIHRvIG4gLSAxIGRvXG4gICAgZG9uJ3Rfd2FpdF9mb3IgKGVucXVldWUgdCBmX3BsYWNlaG9sZGVyKVxuICBkb25lO1xuICBsZXQlbWFwIHJlc3VsdCA9IGVucXVldWUnIHQgKGZ1biBfc2xvdCAtPiBmICgpKSBpblxuICBJdmFyLmZpbGwgZG9uZV8gKCk7XG4gIGhhbmRsZV9lbnF1ZXVlX3Jlc3VsdCByZXN1bHRcbjs7XG5cbmxldCBtb25hZF9zZXF1ZW5jZV9ob3cgfmhvdyB+ZiA9XG4gIHN0YWdlXG4gICAgKG1hdGNoIGhvdyB3aXRoXG4gICAgIHwgYFBhcmFsbGVsIC0+IGZcbiAgICAgfCAoYFNlcXVlbnRpYWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9XG4gICAgICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgICAgfCBgU2VxdWVudGlhbCAtPiAxXG4gICAgICAgICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT4gbWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgIGluXG4gICAgICAgbGV0IHQgPSBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIH5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gICAgICAgZnVuIGEgLT4gZW5xdWV1ZSB0IChmdW4gKCkgLT4gZiBhKSlcbjs7XG5cbmxldCBtb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYgPVxuICBzdGFnZVxuICAgIChtYXRjaCBob3cgd2l0aFxuICAgICB8IGBQYXJhbGxlbCAtPiBmXG4gICAgIHwgKGBTZXF1ZW50aWFsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgICAgbGV0IG1heF9jb25jdXJyZW50X2pvYnMgPVxuICAgICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgICAgIHwgYFNlcXVlbnRpYWwgLT4gMVxuICAgICAgICAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBtYXhfY29uY3VycmVudF9qb2JzIC0+IG1heF9jb25jdXJyZW50X2pvYnNcbiAgICAgICBpblxuICAgICAgIGxldCB0ID0gY3JlYXRlIH5jb250aW51ZV9vbl9lcnJvcjpmYWxzZSB+bWF4X2NvbmN1cnJlbnRfam9icyBpblxuICAgICAgIGZ1biBhMSBhMiAtPiBlbnF1ZXVlIHQgKGZ1biAoKSAtPiBmIGExIGEyKSlcbjs7XG5cbmxldCBwcmlvcl9qb2JzX2RvbmUgdCA9XG4gICgqIFdlIHF1ZXVlIFt0Lm1heF9jb25jdXJyZW50X2pvYnNdIGR1bW15IGpvYnMgYW5kIHdoZW4gdGhleSBhcmUgYWxsIHN0YXJ0ZWQgd2Uga25vd1xuICAgICB0aGF0IGFsbCBwcmlvciBqb2JzIGZpbmlzaGVkLiAgV2UgbWFrZSBzdXJlIHRoYXQgYWxsIGR1bW15IGpvYnMgd2FpdCBmb3IgdGhlIGxhc3Qgb25lXG4gICAgIHRvIGdldCBzdGFydGVkIGJlZm9yZSBmaW5pc2hpbmcuICopXG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGFsbF9kdW1teV9qb2JzX3J1bm5pbmcgLT5cbiAgICBsZXQgZHVtbXlfam9ic19ydW5uaW5nID0gcmVmIDAgaW5cbiAgICBmb3IgXyA9IDEgdG8gdC5tYXhfY29uY3VycmVudF9qb2JzIGRvXG4gICAgICBkb24ndF93YWl0X2ZvclxuICAgICAgICAoZW5xdWV1ZSB0IChmdW4gXyAtPlxuICAgICAgICAgICBpbmNyIGR1bW15X2pvYnNfcnVubmluZztcbiAgICAgICAgICAgaWYgIWR1bW15X2pvYnNfcnVubmluZyA9IHQubWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgICAgICB0aGVuIEl2YXIuZmlsbCBhbGxfZHVtbXlfam9ic19ydW5uaW5nICgpO1xuICAgICAgICAgICBJdmFyLnJlYWQgYWxsX2R1bW15X2pvYnNfcnVubmluZykpXG4gICAgZG9uZSlcbjs7XG5cbmxldCBjYXBhY2l0eV9hdmFpbGFibGUgdCA9XG4gIGlmIG51bV9qb2JzX3J1bm5pbmcgdCA8IG1heF9jb25jdXJyZW50X2pvYnMgdFxuICB0aGVuIHJldHVybiAoKVxuICBlbHNlIChcbiAgICBtYXRjaCB0LmNhcGFjaXR5X2F2YWlsYWJsZSB3aXRoXG4gICAgfCBTb21lIGl2YXIgLT4gSXZhci5yZWFkIGl2YXJcbiAgICB8IE5vbmUgLT4gRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPiB0LmNhcGFjaXR5X2F2YWlsYWJsZSA8LSBTb21lIGl2YXIpKVxuOztcbiIsIm9wZW4hIENvcmVcbmluY2x1ZGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwXG5cbmxldCBjcmVhdGUgPSBTY2hlZHVsZXIxLmNyZWF0ZV90aW1lX3NvdXJjZVxubGV0IHdhbGxfY2xvY2sgPSBTY2hlZHVsZXIxLndhbGxfY2xvY2tcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5tb2R1bGUgU3RyZWFtID0gQXN5bmNfc3RyZWFtXG5pbmNsdWRlIChTY2hlZHVsZXIgOiBtb2R1bGUgdHlwZSBvZiBTY2hlZHVsZXIgd2l0aCBtb2R1bGUgQnZhciA6PSBTY2hlZHVsZXIuQnZhcilcblxubGV0IHQgPSBTY2hlZHVsZXIudFxuXG5pbmNsdWRlIE1vbml0b3IuRXhwb3J0ZWRfZm9yX3NjaGVkdWxlclxuXG5sZXQgZmluZF9sb2NhbCBrZXkgPSBFeGVjdXRpb25fY29udGV4dC5maW5kX2xvY2FsIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkga2V5XG5cbmxldCB3aXRoX2xvY2FsIGtleSB2YWx1ZSB+ZiA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LndpdGhfbG9jYWwgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCkga2V5IHZhbHVlXG4gIGluXG4gIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgdCBleGVjdXRpb25fY29udGV4dCB+ZlxuOztcblxubGV0IG1haW5fZXhlY3V0aW9uX2NvbnRleHQgPSAodCAoKSkubWFpbl9leGVjdXRpb25fY29udGV4dFxubGV0IGNhbl9ydW5fYV9qb2IgdCA9IG51bV9wZW5kaW5nX2pvYnMgdCA+IDAgfHwgQnZhci5oYXNfYW55X3dhaXRlcnMgdC55aWVsZFxubGV0IGhhc191cGNvbWluZ19ldmVudCB0ID0gbm90IChUaW1pbmdfd2hlZWwuaXNfZW1wdHkgKGV2ZW50cyB0KSlcbmxldCBuZXh0X3VwY29taW5nX2V2ZW50IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCAoZXZlbnRzIHQpXG5sZXQgbmV4dF91cGNvbWluZ19ldmVudF9leG4gdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biAoZXZlbnRzIHQpXG5sZXQgZXZlbnRfcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIChldmVudHMgdClcbmxldCBjeWNsZV9zdGFydCB0ID0gdC5jeWNsZV9zdGFydFxubGV0IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mID0gdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQgPC0gZiA6OiB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydFxubGV0IHJ1bl9ldmVyeV9jeWNsZV9lbmQgdCB+ZiA9IHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZCA8LSBmIDo6IHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZFxuXG5sZXQgYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgdCB+ZiA9XG4gIGxldCBoYW5kbGUgPSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS5jcmVhdGUgKCkgaW5cbiAgSGFzaHRibC5hZGRfZXhuIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIH5rZXk6aGFuZGxlIH5kYXRhOmY7XG4gIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mO1xuICBoYW5kbGVcbjs7XG5cbmxldCBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgdCB+ZiA9XG4gIGxldCBoYW5kbGUgPSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS5jcmVhdGUgKCkgaW5cbiAgSGFzaHRibC5hZGRfZXhuIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSB+a2V5OmhhbmRsZSB+ZGF0YTpmO1xuICBydW5fZXZlcnlfY3ljbGVfZW5kIHQgfmY7XG4gIGhhbmRsZVxuOztcblxuKCogVW5iZWxpZXZhYmxlIHRoYXQgW0xpc3QucmVtb3ZlXSBpcyBub3QgYSB0aGluZyAqKVxubGV0IGxpc3RfcmVtb3ZlX2ZpcnN0IGxzdCB+ZiA9XG4gIG1hdGNoIExpc3Quc3BsaXRfd2hpbGUgfmY6KGZ1biB4IC0+IG5vdCAoZiB4KSkgbHN0IHdpdGhcbiAgfCBfLCBbXSAtPiBOb25lXG4gIHwgbCwgXyA6OiByIC0+IFNvbWUgKGwgQCByKVxuOztcblxubGV0IHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayBsc3QgZiA9XG4gICgqIFJlbW92ZSBhIHNpbmdsZSBpbnN0YW5jZSBvZiBbZl0gZnJvbSBbbHN0XS4gTW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBtYXkgYmUgcHJlc2VudCxcbiAgICAgYnV0IHJlbW92YWwgaXMgcmVmZXJlbmNlLWNvdW50ZWQgYnkgW3J1bl9ldmVyeV9jeWNsZV8oc3RhcnR8ZW5kKV9zdGF0ZV0gdGFibGVzLiAqKVxuICBtYXRjaCBsaXN0X3JlbW92ZV9maXJzdCB+ZjoocGh5c19lcXVhbCBmKSBsc3Qgd2l0aFxuICB8IFNvbWUgbHN0IC0+IGxzdFxuICB8IE5vbmUgLT5cbiAgICAoKiBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZSwgc2VlIHRoZSBbaW52YXJpYW50XSBpbiBbc2NoZWR1bGVyMS5tbF0uICopXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiU2NoZWR1bGVyLnJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayBjYWxsZWQgd2l0aCBhIGhvb2sgdGhhdCBpc24ndCByZWdpc3RlcmVkXCJdXG47O1xuXG5sZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuIHQgaGFuZGxlID1cbiAgbWF0Y2ggSGFzaHRibC5maW5kX2FuZF9yZW1vdmUgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgaGFuZGxlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgZmFpbHdpdGggXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgY3ljbGUgc3RhcnQgaG9vayB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXCJcbiAgfCBTb21lIGYgLT5cbiAgICB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCA8LSByZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2sgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQgZlxuOztcblxubGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gdCBoYW5kbGUgPVxuICBtYXRjaCBIYXNodGJsLmZpbmRfYW5kX3JlbW92ZSB0LnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgaGFuZGxlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgZmFpbHdpdGggXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgY3ljbGUgZW5kIGhvb2sgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkLlwiXG4gIHwgU29tZSBmIC0+IHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZCA8LSByZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2sgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIGZcbjs7XG5cbmxldCBtYXBfY3ljbGVfdGltZXMgdCB+ZiA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPiBUYWlsLmV4dGVuZCB0YWlsIChmIHQubGFzdF9jeWNsZV90aW1lKSkpXG47O1xuXG5sZXQgbG9uZ19jeWNsZXMgdCB+YXRfbGVhc3QgPVxuICBTdHJlYW0uY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mOihmdW4gKCkgLT5cbiAgICAgIGlmIFRpbWVfbnMuU3Bhbi4oID49ICkgdC5sYXN0X2N5Y2xlX3RpbWUgYXRfbGVhc3RcbiAgICAgIHRoZW4gVGFpbC5leHRlbmQgdGFpbCB0Lmxhc3RfY3ljbGVfdGltZSkpXG47O1xuXG5sZXQgY3ljbGVfbnVtX2pvYnMgdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPiBUYWlsLmV4dGVuZCB0YWlsIHQubGFzdF9jeWNsZV9udW1fam9icykpXG47O1xuXG5sZXQgY3ljbGVfY291bnQgdCA9IHQuY3ljbGVfY291bnRcblxubGV0IHNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSB0IGludCA9XG4gIHQubWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGVcbiAgPC0gTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUuY3JlYXRlX2V4biBpbnRcbjs7XG5cbmxldCBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSB0ID1cbiAgTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUucmF3IHQubWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGVcbjs7XG5cbmxldCBzZXRfdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgdCBmID0gdC50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayA8LSBmXG5cbmxldCB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIFRocmVhZF9zYWZlX3F1ZXVlLmVucXVldWUgdC5leHRlcm5hbF9qb2JzIChFeHRlcm5hbF9qb2IuVCAoZXhlY3V0aW9uX2NvbnRleHQsIGYsIGEpKTtcbiAgdC50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayAoKVxuOztcblxubGV0IHNldF9ldmVudF9hZGRlZF9ob29rIHQgZiA9IHQuZXZlbnRfYWRkZWRfaG9vayA8LSBTb21lIGZcbmxldCBzZXRfam9iX3F1ZXVlZF9ob29rIHQgZiA9IHQuam9iX3F1ZXVlZF9ob29rIDwtIFNvbWUgZlxuXG5sZXQgY3JlYXRlX2FsYXJtIHQgZiA9XG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCBpblxuICBHYy5FeHBlcnQuQWxhcm0uY3JlYXRlIChmdW4gKCkgLT5cbiAgICB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgKCkpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplciB0IGhlYXBfYmxvY2sgZiA9XG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCBpblxuICBsZXQgZmluYWxpemVyIGhlYXBfYmxvY2sgPVxuICAgICgqIEhlcmUgd2UgY2FuIGJlIGluIGFueSB0aHJlYWQsIGFuZCBtYXkgbm90IGJlIGhvbGRpbmcgdGhlIGFzeW5jIGxvY2suICBTbywgd2UgY2FuXG4gICAgICAgb25seSBkbyB0aHJlYWQtc2FmZSB0aGluZ3MuXG5cbiAgICAgICBCeSBwdXR0aW5nIFtoZWFwX2Jsb2NrXSBpbiBbZXh0ZXJuYWxfam9ic10sIHdlIGFyZSBrZWVwaW5nIGl0IGFsaXZlIHVudGlsIHRoZSBuZXh0XG4gICAgICAgdGltZSB0aGUgYXN5bmMgc2NoZWR1bGVyIGdldHMgYXJvdW5kIHRvIGRlcXVldWVpbmcgaXQuICBDYWxsaW5nXG4gICAgICAgW3QudGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2tdIGVuc3VyZXMgdGhhdCB3aWxsIGhhcHBlbiBpbiBzaG9ydCBvcmRlci4gIFRodXMsXG4gICAgICAgd2UgYXJlIG5vdCBkcmFtYXRpY2FsbHkgaW5jcmVhc2luZyB0aGUgbGlmZXRpbWUgb2YgW2hlYXBfYmxvY2tdLCBzaW5jZSB0aGUgT0NhbWxcbiAgICAgICBydW50aW1lIGFscmVhZHkgcmVzdXJyZWN0ZWQgW2hlYXBfYmxvY2tdIHNvIHRoYXQgd2UgY291bGQgcmVmZXIgdG8gaXQgaGVyZS4gIFRoZVxuICAgICAgIE9DYW1sIHJ1bnRpbWUgYWxyZWFkeSByZW1vdmVkIHRoZSBmaW5hbGl6ZXIgZnVuY3Rpb24gd2hlbiBpdCBub3RpY2VkIFtoZWFwX2Jsb2NrXVxuICAgICAgIGNvdWxkIGJlIGZpbmFsaXplZCwgc28gdGhlcmUgaXMgbm8gaW5maW5pdGUgbG9vcCBpbiB3aGljaCB3ZSBhcmUgY2F1c2luZyB0aGVcbiAgICAgICBmaW5hbGl6ZXIgdG8gcnVuIGFnYWluLiAgQWxzbywgT0NhbWwgZG9lcyBub3QgaW1wb3NlIGFueSByZXF1aXJlbWVudCBvbiBmaW5hbGl6ZXJcbiAgICAgICBmdW5jdGlvbnMgdGhhdCB0aGV5IG5lZWQgdG8gZGlzcG9zZSBvZiB0aGUgYmxvY2ssIHNvIGl0J3MgZmluZSB0aGF0IHdlIGtlZXBcbiAgICAgICBbaGVhcF9ibG9ja10gYXJvdW5kIHVudGlsIGxhdGVyLiAqKVxuICAgIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiZW5xdWV1ZWluZyBmaW5hbGl6ZXJcIjtcbiAgICB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiB0IGV4ZWN1dGlvbl9jb250ZXh0IGYgaGVhcF9ibG9ja1xuICBpblxuICBpZiBEZWJ1Zy5maW5hbGl6ZXJzIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImFkZGluZyBmaW5hbGl6ZXJcIjtcbiAgKCogV2UgdXNlIFtDYW1sLkdjLmZpbmFsaXNlXSBpbnN0ZWFkIG9mIFtDb3JlLkdjLmFkZF9maW5hbGl6ZXJdIGJlY2F1c2UgdGhlIGxhdHRlclxuICAgICBoYXMgaXRzIG93biB3cmFwcGVyIGFyb3VuZCBbQ2FtbC5HYy5maW5hbGlzZV0gdG8gcnVuIGZpbmFsaXplcnMgc3luY2hyb25vdXNseS4gKilcbiAgdHJ5IENhbWwuR2MuZmluYWxpc2UgZmluYWxpemVyIGhlYXBfYmxvY2sgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICgqIFtIZWFwX2Jsb2NrXSBlbnN1cmVzIHRoYXQgdGhpcyB3aWxsIG9ubHkgZmFpbCBmb3Igc3RhdGljIGRhdGEsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAgICBjYW4gZHJvcCB0aGUgZmluYWxpemVyIHNpbmNlIHRoZSBibG9jayB3aWxsIG5ldmVyIGJlIGNvbGxlY3RlZC4qKVxuICAgICgpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gdCB4IGYgPVxuICBhZGRfZmluYWxpemVyIHQgKEhlYXBfYmxvY2suY3JlYXRlX2V4biB4KSAoZnVuIGhlYXBfYmxvY2sgLT5cbiAgICBmIChIZWFwX2Jsb2NrLnZhbHVlIGhlYXBfYmxvY2spKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdCB0IGhlYXBfYmxvY2sgZiA9XG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCBpblxuICBsZXQgZmluYWxpemVyICgpID1cbiAgICAoKiBIZXJlIHdlIGNhbiBiZSBpbiBhbnkgdGhyZWFkLCBhbmQgbWF5IG5vdCBiZSBob2xkaW5nIHRoZSBhc3luYyBsb2NrLiAgU28sIHdlIGNhblxuICAgICAgIG9ubHkgZG8gdGhyZWFkLXNhZmUgdGhpbmdzLiAqKVxuICAgIGlmIERlYnVnLmZpbmFsaXplcnNcbiAgICB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJlbnF1ZXVlaW5nIGZpbmFsaXplciAodXNpbmcgJ2xhc3QnIHNlbWFudGljKVwiO1xuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiAoKVxuICBpblxuICBpZiBEZWJ1Zy5maW5hbGl6ZXJzIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImFkZGluZyBmaW5hbGl6ZXIgKHVzaW5nICdsYXN0JyBzZW1hbnRpYylcIjtcbiAgKCogV2UgdXNlIFtDYW1sLkdjLmZpbmFsaXNlX2xhc3RdIGluc3RlYWQgb2YgW0NvcmUuR2MuYWRkX2ZpbmFsaXplcl9sYXN0XSBiZWNhdXNlXG4gICAgIHRoZSBsYXR0ZXIgaGFzIGl0cyBvd24gd3JhcHBlciBhcm91bmQgW0NhbWwuR2MuZmluYWxpc2VfbGFzdF0gdG8gcnVuIGZpbmFsaXplcnNcbiAgICAgc3luY2hyb25vdXNseS4gKilcbiAgdHJ5IENhbWwuR2MuZmluYWxpc2VfbGFzdCBmaW5hbGl6ZXIgaGVhcF9ibG9jayB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgKCogW0hlYXBfYmxvY2tdIGVuc3VyZXMgdGhhdCB0aGlzIHdpbGwgb25seSBmYWlsIGZvciBzdGF0aWMgZGF0YSwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgICAgIGNhbiBkcm9wIHRoZSBmaW5hbGl6ZXIgc2luY2UgdGhlIGJsb2NrIHdpbGwgbmV2ZXIgYmUgY29sbGVjdGVkLiopXG4gICAgKClcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyX2xhc3RfZXhuIHQgeCBmID0gYWRkX2ZpbmFsaXplcl9sYXN0IHQgKEhlYXBfYmxvY2suY3JlYXRlX2V4biB4KSBmXG5cbigqKiBbZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmRdIHNldHMgdGhlIG51bWJlciBvZiBub3JtYWwgam9icyBhbGxvd2VkIHRvIHJ1biBpbiB0aGlzXG4gICAgY3ljbGUgdG8gemVyby4gIFRodXMsIGFmdGVyIHRoZSBjdXJyZW50bHkgcnVubmluZyBqb2IgY29tcGxldGVzLCB0aGUgc2NoZWR1bGVyIHdpbGxcbiAgICBzd2l0Y2ggdG8gbG93IHByaW9yaXR5IGpvYnMgYW5kIHRoZW4gZW5kIHRoZSBjdXJyZW50IGN5Y2xlLiAqKVxubGV0IGZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kIHQgPVxuICBKb2JfcXVldWUuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgMFxuOztcblxuKCogV2UgcHJlYWxsb2NhdGUgW3NlbmRfZXhuXSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IG9uIGVhY2ggY2FsbCB0byBbYWR2YW5jZV9jbG9ja10uICopXG5sZXQgc2VuZF9leG4gPSBTb21lIE1vbml0b3Iuc2VuZF9leG5cblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+bm93ID1cbiAgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFkdmFuY2VfaW50ZXJuYWwgdC50aW1lX3NvdXJjZSB+dG9fOm5vdyB+c2VuZF9leG5cbjs7XG5cbmxldCBydW5fY3ljbGUgdCA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwicnVuX2N5Y2xlIHN0YXJ0aW5nXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBsZXQgbm93ID0gVGltZV9ucy5ub3cgKCkgaW5cbiAgdC5jeWNsZV9jb3VudCA8LSB0LmN5Y2xlX2NvdW50ICsgMTtcbiAgdC5jeWNsZV9zdGFydCA8LSBub3c7XG4gIHQuaW5fY3ljbGUgPC0gdHJ1ZTtcbiAgQnZhci5icm9hZGNhc3QgdC55aWVsZCAoKTtcbiAgbGV0IG51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSA9IG51bV9qb2JzX3J1biB0IGluXG4gIExpc3QuaXRlciB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCB+ZjooZnVuIGYgLT4gZiAoKSk7XG4gIGFkdmFuY2VfY2xvY2sgdCB+bm93O1xuICBzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5OnQubWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGU7XG4gIGxldCByZWMgcnVuX2pvYnMgdCA9XG4gICAgbWF0Y2ggU2NoZWR1bGVyLnJ1bl9qb2JzIHQgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgIE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXhuIH5iYWNrdHJhY2U6KGBUaGlzIGJhY2t0cmFjZSk7XG4gICAgICAoKiBbcnVuX2pvYnNdIHN0b3BwZWQgZHVlIHRvIGFuIGV4bi4gIFRoZXJlIG1heSBzdGlsbCBiZSBqb2JzIHRoYXQgY291bGQgYmVcbiAgICAgICAgIHJ1biB0aGlzIGN5Y2xlLCBzbyBbcnVuX2pvYnNdIGFnYWluLiAqKVxuICAgICAgcnVuX2pvYnMgdFxuICBpblxuICBydW5fam9icyB0O1xuICBsZXQgY3ljbGVfdGltZSA9IFRpbWVfbnMuZGlmZiAoVGltZV9ucy5ub3cgKCkpIHQuY3ljbGVfc3RhcnQgaW5cbiAgdC5sYXN0X2N5Y2xlX3RpbWUgPC0gY3ljbGVfdGltZTtcbiAgdC5sYXN0X2N5Y2xlX251bV9qb2JzIDwtIG51bV9qb2JzX3J1biB0IC0gbnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlO1xuICB0LnRvdGFsX2N5Y2xlX3RpbWUgPC0gVGltZV9ucy5TcGFuLih0LnRvdGFsX2N5Y2xlX3RpbWUgKyBjeWNsZV90aW1lKTtcbiAgaWYgQnZhci5oYXNfYW55X3dhaXRlcnMgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiAmJiBudW1fcGVuZGluZ19qb2JzIHQgPSAwXG4gIHRoZW4gQnZhci5icm9hZGNhc3QgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiAoKTtcbiAgTGlzdC5pdGVyIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZCB+ZjooZnVuIGYgLT4gZiAoKSk7XG4gIHQuaW5fY3ljbGUgPC0gZmFsc2U7XG4gIGlmIGRlYnVnXG4gIHRoZW5cbiAgICBEZWJ1Zy5sb2dcbiAgICAgIFwicnVuX2N5Y2xlIGZpbmlzaGVkXCJcbiAgICAgICh1bmNhdWdodF9leG4gdCwgaXNfc29tZSAobmV4dF91cGNvbWluZ19ldmVudCB0KSlcbiAgICAgIFslc2V4cF9vZjogRXJyb3IudCBvcHRpb24gKiBib29sXVxuOztcblxubGV0IHJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gKCkgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluIHN0YXJ0aW5nXCI7XG4gIGxldCB0ID0gdCAoKSBpblxuICBpZiBpc19kZWFkIHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gY2Fubm90IHByb2NlZWQgLS0gc2NoZWR1bGVyIGlzIGRlYWRcIlxuICAgICAgICAgIH5zY2hlZHVsZXI6KHQgOiB0KV07XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgcnVuX2N5Y2xlIHQ7XG4gICAgYWR2YW5jZV9jbG9jayB0IH5ub3c6KFRpbWVfbnMubm93ICgpKTtcbiAgICBpZiBjYW5fcnVuX2Ffam9iIHQgdGhlbiBsb29wICgpXG4gIGluXG4gIGxvb3AgKCk7XG4gICgqIFJlc2V0IHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0IHRvIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB3aGVuIHdlJ3JlIG5vdCBpblxuICAgICBhIGpvYiwgW2N1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPSBtYWluX2V4ZWN1dGlvbl9jb250ZXh0XS4gKilcbiAgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgdC5tYWluX2V4ZWN1dGlvbl9jb250ZXh0O1xuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluIGZpbmlzaGVkXCI7XG4gIE9wdGlvbi5pdGVyICh1bmNhdWdodF9leG4gdCkgfmY6RXJyb3IucmFpc2Vcbjs7XG5cbmxldCBtYWtlX2FzeW5jX3VudXNhYmxlICgpID1cbiAgbGV0IHQgPSAhdF9yZWYgaW5cbiAgdC5jaGVja19hY2Nlc3NcbiAgPC0gU29tZVxuICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICByYWlzZV9zIFslc2V4cCBcIkFzeW5jIHNjaGVkdWxlciBpcyB1bnVzYWJsZSBkdWUgdG8gW21ha2VfYXN5bmNfdW51c2FibGVdXCJdKVxuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzICgpID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwicmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3NcIjtcbiAgKCogVGhlcmUgaXMgbm8gbmVlZCB0byBlbXB0eSBbbWFpbl9tb25pdG9yX2hvbGVdLiAqKVxuICBTY2hlZHVsZXIuKHRfcmVmIDo9IGNyZWF0ZSAoKSlcbjs7XG5cbmxldCBjaGVja19pbnZhcmlhbnRzIHQgPSB0LmNoZWNrX2ludmFyaWFudHNcbmxldCBzZXRfY2hlY2tfaW52YXJpYW50cyB0IGIgPSB0LmNoZWNrX2ludmFyaWFudHMgPC0gYlxubGV0IHNldF9yZWNvcmRfYmFja3RyYWNlcyB0IGIgPSB0LnJlY29yZF9iYWNrdHJhY2VzIDwtIGJcbmxldCB5aWVsZCB0ID0gQnZhci53YWl0IHQueWllbGRcblxubGV0IHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID8obWF5X3JldHVybl9pbW1lZGlhdGVseSA9IGZhbHNlKSB0ID1cbiAgaWYgbWF5X3JldHVybl9pbW1lZGlhdGVseSAmJiBudW1fcGVuZGluZ19qb2JzIHQgPSAwXG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgQnZhci53YWl0IHQueWllbGRfdW50aWxfbm9fam9ic19yZW1haW5cbjs7XG5cbmxldCB5aWVsZF9ldmVyeSB+biA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiU2NoZWR1bGVyLnlpZWxkX2V2ZXJ5IGdvdCBub25wb3NpdGl2ZSBjb3VudFwiIChuIDogaW50KV1cbiAgZWxzZSBpZiBuID0gMVxuICB0aGVuIHN0YWdlIChmdW4gdCAtPiB5aWVsZCB0KVxuICBlbHNlIChcbiAgICBsZXQgY291bnRfdW50aWxfeWllbGQgPSByZWYgbiBpblxuICAgIHN0YWdlIChmdW4gdCAtPlxuICAgICAgZGVjciBjb3VudF91bnRpbF95aWVsZDtcbiAgICAgIGlmICFjb3VudF91bnRpbF95aWVsZCA+IDBcbiAgICAgIHRoZW4gcmV0dXJuICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgY291bnRfdW50aWxfeWllbGQgOj0gbjtcbiAgICAgICAgeWllbGQgdCkpKVxuOztcblxubGV0IHRvdGFsX2N5Y2xlX3RpbWUgdCA9XG4gICgqIEFkanVzdCBmb3IgdGhlIGZhY3QgdGhlIGNhbGxlcidzIHByb2JhYmx5IGFuIEFzeW5jIGpvYi4gKilcbiAgaWYgdC5pbl9jeWNsZVxuICB0aGVuIChcbiAgICBsZXQgdGhpc19jeWNsZV90aW1lID0gVGltZV9ucy4oZGlmZiAobm93ICgpKSB0LmN5Y2xlX3N0YXJ0KSBpblxuICAgIFRpbWVfbnMuU3Bhbi4odC50b3RhbF9jeWNsZV90aW1lICsgdGhpc19jeWNsZV90aW1lKSlcbiAgZWxzZSB0LnRvdGFsX2N5Y2xlX3RpbWVcbjs7XG5cbm1vZHVsZSBWZXJ5X2xvd19wcmlvcml0eV93b3JrID0gc3RydWN0XG4gIG1vZHVsZSBXb3JrZXJfcmVzdWx0ID0gVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLkV4ZWNfcmVzdWx0XG5cblxuICBsZXQgcmVjIHJ1biB0ID0gcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZzoxXzAwMFxuXG4gIGFuZCBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID1cbiAgICBpZiBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gMFxuICAgIHRoZW4geWllbGRfdGhlbl9ydW4gdFxuICAgIGVsc2UgaWYgbm90IChEZXF1ZS5pc19lbXB0eSB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMpXG4gICAgdGhlbiAoXG4gICAgICBsZXQgd29ya2VyID0gRGVxdWUuZGVxdWV1ZV9mcm9udF9leG4gdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIGluXG4gICAgICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB3b3JrZXIuZXhlY3V0aW9uX2NvbnRleHQ7XG4gICAgICBydW5fd29ya2VyIHQgd29ya2VyIH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nKVxuXG4gIGFuZCB5aWVsZF90aGVuX3J1biB0ID1cbiAgICBpZiBub3QgKERlcXVlLmlzX2VtcHR5IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycylcbiAgICB0aGVuIERlZmVycmVkLnVwb24gKHlpZWxkIHQpIChmdW4gKCkgLT4gcnVuIHQpXG5cbiAgYW5kIHJ1bl93b3JrZXIgdCB3b3JrZXIgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPVxuICAgIGFzc2VydCAocGh5c19lcXVhbCB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgd29ya2VyLmV4ZWN1dGlvbl9jb250ZXh0KTtcbiAgICBpZiBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gMFxuICAgIHRoZW4gKFxuICAgICAgRGVxdWUuZW5xdWV1ZV9mcm9udCB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgd29ya2VyO1xuICAgICAgeWllbGRfdGhlbl9ydW4gdClcbiAgICBlbHNlIChcbiAgICAgIGxldCBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gbnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyAtIDEgaW5cbiAgICAgIG1hdGNoIHdvcmtlci5leGVjICgpIHdpdGhcbiAgICAgIHwgRmluaXNoZWQgLT4gcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZ1xuICAgICAgfCBOb3RfZmluaXNoZWQgLT4gcnVuX3dvcmtlciB0IHdvcmtlciB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZ1xuICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgIGxldCBidCA9IEJhY2t0cmFjZS5FeG4ubW9zdF9yZWNlbnQgKCkgaW5cbiAgICAgICAgTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBleG4gfmJhY2t0cmFjZTooYFRoaXMgYnQpO1xuICAgICAgICBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nKVxuICA7O1xuXG4gIGxldCBlbnF1ZXVlIH5mID1cbiAgICBsZXQgdCA9IHQgKCkgaW5cbiAgICBsZXQgcXVldWUgPSB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgaW5cbiAgICBsZXQgcnVubmluZyA9IG5vdCAoRGVxdWUuaXNfZW1wdHkgcXVldWUpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQpIH5wcmlvcml0eTpMb3dcbiAgICBpblxuICAgIERlcXVlLmVucXVldWVfYmFjayBxdWV1ZSB7IGV4ZWN1dGlvbl9jb250ZXh0OyBleGVjID0gZiB9O1xuICAgIGlmIG5vdCBydW5uaW5nIHRoZW4gZW5xdWV1ZSB0IGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB0XG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl9iZW5jaCA9IHN0cnVjdFxuICBsZXQgYWR2YW5jZV9jbG9jayA9IGFkdmFuY2VfY2xvY2tcbmVuZFxuXG5sZXQgaW5fY3ljbGUgdCA9IHQuaW5fY3ljbGVcbiIsInR5cGUgdCA9IHVuaXQgLT4gdW5pdFxuXG5tb2R1bGUgSGFuZGxlID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnRcbmVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNjaGVkdWxlclxuXG5sZXQgZW5xdWV1ZV9qb2IgZXhlY3V0aW9uX2NvbnRleHQgZiBhID0gZW5xdWV1ZSAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG5cbmxldCB0aHJlYWRfc2FmZV9lbnF1ZXVlX2pvYiBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG47O1xuXG5sZXQgY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpXG5sZXQgY3ljbGVfY291bnQgKCkgPSBjeWNsZV9jb3VudCAodCAoKSlcbmxldCBjeWNsZV9zdGFydF9ucyAoKSA9IGN5Y2xlX3N0YXJ0ICh0ICgpKVxubGV0IGN5Y2xlX3N0YXJ0ICgpID0gVGltZV9ucy50b190aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgKGN5Y2xlX3N0YXJ0X25zICgpKVxubGV0IGN5Y2xlX3RpbWVzX25zICgpID0gbWFwX2N5Y2xlX3RpbWVzICh0ICgpKSB+ZjpGbi5pZFxubGV0IGN5Y2xlX3RpbWVzICgpID0gbWFwX2N5Y2xlX3RpbWVzICh0ICgpKSB+ZjpUaW1lX25zLlNwYW4udG9fc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0XG5sZXQgdG90YWxfY3ljbGVfdGltZSAoKSA9IHRvdGFsX2N5Y2xlX3RpbWUgKHQgKCkpXG5sZXQgbGFzdF9jeWNsZV90aW1lICgpID0gbGFzdF9jeWNsZV90aW1lICh0ICgpKVxubGV0IGxvbmdfY3ljbGVzIH5hdF9sZWFzdCA9IGxvbmdfY3ljbGVzICh0ICgpKSB+YXRfbGVhc3RcbmxldCBldmVudF9wcmVjaXNpb25fbnMgKCkgPSBldmVudF9wcmVjaXNpb24gKHQgKCkpXG5sZXQgZXZlbnRfcHJlY2lzaW9uICgpID0gVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCAoZXZlbnRfcHJlY2lzaW9uX25zICgpKVxuXG5sZXQgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIGkgPVxuICBzZXRfbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgKHQgKCkpIGlcbjs7XG5cbmxldCBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSAoKSA9IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlICh0ICgpKVxubGV0IHNldF9yZWNvcmRfYmFja3RyYWNlcyBib29sID0gc2V0X3JlY29yZF9iYWNrdHJhY2VzICh0ICgpKSBib29sXG5sZXQgZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmQgKCkgPSBmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCAodCAoKSlcbmxldCB5aWVsZCAoKSA9IHlpZWxkICh0ICgpKVxuXG5sZXQgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gP21heV9yZXR1cm5faW1tZWRpYXRlbHkgKCkgPVxuICB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA/bWF5X3JldHVybl9pbW1lZGlhdGVseSAodCAoKSlcbjs7XG5cbmxldCB5aWVsZF9ldmVyeSB+biA9XG4gIGxldCB5aWVsZF9ldmVyeSA9IFN0YWdlZC51bnN0YWdlICh5aWVsZF9ldmVyeSB+bikgaW5cbiAgbGV0IHQgPSB0ICgpIGluXG4gIHN0YWdlIChmdW4gKCkgLT4geWllbGRfZXZlcnkgdClcbjs7XG5cbmxldCBudW1fam9ic19ydW4gKCkgPSBudW1fam9ic19ydW4gKHQgKCkpXG5sZXQgbnVtX3BlbmRpbmdfam9icyAoKSA9IG51bV9wZW5kaW5nX2pvYnMgKHQgKCkpXG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IHJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gPSBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluXG4gIGxldCBsYXN0X2N5Y2xlX251bV9qb2JzICgpID0gbGFzdF9jeWNsZV9udW1fam9icyAodCAoKSlcbiAgbGV0IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCBmID0gcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0ICh0ICgpKSB+ZlxuICBsZXQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCBmID0gcnVuX2V2ZXJ5X2N5Y2xlX2VuZCAodCAoKSkgfmZcbiAgbGV0IGFkZF9ldmVyeV9jeWNsZV9zdGFydF9ob29rIH5mID0gYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgKHQgKCkpIH5mXG4gIGxldCBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgfmYgPSBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgKHQgKCkpIH5mXG5cbiAgbGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rX2V4biBoYW5kbGUgPVxuICAgIHJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rX2V4biAodCAoKSkgaGFuZGxlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gaGFuZGxlID1cbiAgICByZW1vdmVfZXZlcnlfY3ljbGVfZW5kX2hvb2tfZXhuICh0ICgpKSBoYW5kbGVcbiAgOztcblxuICBsZXQgd2l0aF9leGVjdXRpb25fY29udGV4dCBleGVjdXRpb25fY29udGV4dCBmID1cbiAgICB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSBleGVjdXRpb25fY29udGV4dCB+ZlxuICA7O1xuXG4gIGxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSBleGVjdXRpb25fY29udGV4dCB+ZiB4ID1cbiAgICB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgfmYgeFxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gU2NoZWR1bGVyXG4iLCIoKiogU2NoZWR1bGUgam9icyB0byBydW4gYXQgYSB0aW1lIGluIHRoZSBmdXR1cmUuXG5cbiAgICBUaGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgaGVhcCBvZiBldmVudHMsIG9uZSBmb3IgZWFjaCBqb2IgdGhhdCBuZWVkcyB0b1xuICAgIHJ1biBpbiB0aGUgZnV0dXJlLiAgVGhlIEFzeW5jIHNjaGVkdWxlciBpcyByZXNwb25zaWJsZSBmb3Igd2FraW5nIHVwIGF0IHRoZSByaWdodCB0aW1lXG4gICAgdG8gcnVuIHRoZSBqb2JzLiAqKVxuXG5vcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgT3JfdGltZW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIFsgYFJlc3VsdCBvZiAnYVxuICAgIHwgYFRpbWVvdXRcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgQ2xvY2sgPSBzaWdcbiAgbW9kdWxlIE9yX3RpbWVvdXQgPSBPcl90aW1lb3V0XG5cbiAgbW9kdWxlIFRpbWUgOiBzaWdcbiAgICBtb2R1bGUgU3BhbiA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgZW5kXG5cbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgKCoqIFtydW5fYXQgdGltZSBmIGFdIHJ1bnMgW2YgYV0gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciBbdGltZV0uICBJZiBbdGltZV0gaXMgaW4gdGhlXG4gICAgICBwYXN0LCB0aGVuIFtydW5fYXRdIHdpbGwgaW1tZWRpYXRlbHkgc2NoZWR1bGUgYSBqb2IgW3RdIHRoYXQgd2lsbCBydW4gW2YgYV0uICBJbiBub1xuICAgICAgc2l0dWF0aW9uIHdpbGwgW3J1bl9hdF0gYWN0dWFsbHkgY2FsbCBbZl0gaXRzZWxmLiAgVGhlIGNhbGwgdG8gW2ZdIHdpbGwgYWx3YXlzIGJlIGluXG4gICAgICBhbm90aGVyIGpvYi4gKilcbiAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqKiBbcnVuX2FmdGVyXSBpcyBsaWtlIFtydW5fYXRdLCBleGNlcHQgdGhhdCBvbmUgc3BlY2lmaWVzIGEgdGltZSBzcGFuIHJhdGhlciB0aGFuIGFuXG4gICAgICBhYnNvbHV0ZSB0aW1lLiAqKVxuICB2YWwgcnVuX2FmdGVyIDogVGltZS5TcGFuLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcblxuICAoKiogW2F0IHRpbWVdIHJldHVybnMgYSBkZWZlcnJlZCBbZF0gdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICAgIGFmdGVyIFt0aW1lXS4gKilcbiAgdmFsIGF0IDogVGltZS50IC0+IHVuaXQgRGVmZXJyZWQudFxuXG4gICgqKiBbYWZ0ZXJdIGlzIGxpa2UgW2F0XSwgZXhjZXB0IHRoYXQgb25lIHNwZWNpZmllcyBhIHRpbWUgc3BhbiByYXRoZXIgdGhhbiBhbiBhYnNvbHV0ZVxuICAgICAgdGltZS4gKilcbiAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgKCoqIFt3aXRoX3RpbWVvdXQgc3BhbiBkXSByZXR1cm5zIGEgZGVmZXJyZWQgdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIGFmdGVyIGVpdGhlclxuICAgICAgW3NwYW5dIGVsYXBzZXMgb3IgW2RdIGlzIGRldGVybWluZWQsIHJldHVybmluZyBlaXRoZXIgW2BUaW1lb3V0XSBvciBbYFJlc3VsdF1cbiAgICAgIGRlcGVuZGluZyBvbiB3aGljaCBvbmUgc3VjY2VlZGVkIGZpcnN0LiAgQXQgdGhlIHRpbWUgdGhlIHJldHVybmVkIGRlZmVycmVkIGJlY29tZXNcbiAgICAgIGRldGVybWluZWQsIGJvdGggdGhpbmdzIG1heSBoYXZlIGhhcHBlbmVkLCBpbiB3aGljaCBjYXNlIFtgUmVzdWx0XSBpcyBnaXZlblxuICAgICAgcHJlZmVyZW5jZS4gKilcbiAgdmFsIHdpdGhfdGltZW91dCA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gJ2EgT3JfdGltZW91dC50IERlZmVycmVkLnRcblxuICAoKiogRXZlbnRzIHByb3ZpZGUgdmFyaWFudHMgb2YgW3J1bl9hdF0gYW5kIFtydW5fYWZ0ZXJdIHdpdGggdGhlIGFiaWxpdHkgdG8gYWJvcnQgb3JcbiAgICAgIHJlc2NoZWR1bGUgYW4gZXZlbnQgdGhhdCBoYXNuJ3QgeWV0IGhhcHBlbmVkLiAgT25jZSBhbiBldmVudCBoYXBwZW5zIG9yIGlzIGFib3J0ZWQsXG4gICAgICBBc3luYyBkb2Vzbid0IHVzZSBhbnkgc3BhY2UgZm9yIHRyYWNraW5nIGl0LiAqKVxuICBtb2R1bGUgRXZlbnQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2gpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICB0eXBlIHRfdW5pdCA9ICh1bml0LCB1bml0KSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgc2NoZWR1bGVkX2F0IDogKF8sIF8pIHQgLT4gVGltZS50XG5cbiAgICBtb2R1bGUgU3RhdHVzIDogc2lnXG4gICAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgICB8IEFib3J0ZWQgb2YgJ2FcbiAgICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgICB8IFNjaGVkdWxlZF9hdCBvZiBUaW1lLnRcbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICAoKiogSWYgW3N0YXR1c10gcmV0dXJucyBbU2NoZWR1bGVkX2F0IHRpbWVdLCBpdCBpcyBwb3NzaWJsZSB0aGF0IFt0aW1lIDwgVGltZS5ub3cgKCldXG4gICAgICAgIGlmIEFzeW5jJ3Mgc2NoZWR1bGVyIGhhc24ndCB5ZXQgZ290dGVuIHRoZSBjaGFuY2UgdG8gdXBkYXRlIGl0cyBjbG9jaywgZS5nLiwgZHVlXG4gICAgICAgIHRvIHVzZXIgam9icyBydW5uaW5nLiAqKVxuICAgIHZhbCBzdGF0dXMgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIFN0YXR1cy50XG5cbiAgICAoKiogTGV0IFt0ID0gcnVuX2F0IHRpbWUgZiB6XS4gIEF0IFt0aW1lXSwgdGhpcyBydW5zIFtmIHpdIGFuZCB0cmFuc2l0aW9ucyBbc3RhdHVzIHRdXG4gICAgICAgIHRvIFtIYXBwZW5lZCBoXSwgd2hlcmUgW2hdIGlzIHJlc3VsdCBvZiBbZiB6XS5cblxuICAgICAgICBNb3JlIHByZWNpc2VseSwgYXQgW3RpbWVdLCBwcm92aWRlZCBbYWJvcnQgdCBhXSBoYXMgbm90IHByZXZpb3VzbHkgYmVlbiBjYWxsZWQsXG4gICAgICAgIHRoaXMgd2lsbCBjYWxsIFtmIHpdLCB3aXRoIHRoZSBndWFyYW50ZWUgdGhhdCBbc3RhdHVzIHQgPSBTY2hlZHVsZWRfYXQgdGltZV0uICBJZlxuICAgICAgICBbZiB6XSByZXR1cm5zIFtoXSBhbmQgZGlkIG5vdCBjYWxsIFthYm9ydCB0IGFdLCB0aGVuIFtzdGF0dXMgdF0gYmVjb21lcyBbSGFwcGVuZWRcbiAgICAgICAgaF0uICBJZiBbZiB6XSBjYWxscyBbYWJvcnQgdCBhXSwgdGhlbiB0aGUgcmVzdWx0IG9mIFtmXSBpcyBpZ25vcmVkLCBhbmQgW3N0YXR1cyB0XVxuICAgICAgICBpcyBbQWJvcnRlZCBhXS5cblxuICAgICAgICBJZiBbZiB6XSByYWlzZXMsIHRoZW4gW3N0YXR1cyB0XSBkb2VzIG5vdCB0cmFuc2l0aW9uIGFuZCByZW1haW5zIFtTY2hlZHVsZWRfYXRcbiAgICAgICAgdGltZV0sIGFuZCB0aGUgZXhjZXB0aW9uIGlzIHNlbnQgdG8gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW4gW3J1bl9hdF0gd2FzXG4gICAgICAgIGNhbGxlZC4gKilcbiAgICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG5cbiAgICB2YWwgcnVuX2FmdGVyIDogVGltZS5TcGFuLnQgLT4gKCd6IC0+ICdoKSAtPiAneiAtPiAoXywgJ2gpIHRcblxuICAgIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5BYm9ydF9yZXN1bHRcblxuICAgICgqKiBbYWJvcnQgdF0gY2hhbmdlcyBbc3RhdHVzIHRdIHRvIFtBYm9ydGVkXSBhbmQgcmV0dXJucyBbT2tdLCB1bmxlc3MgW3RdXG4gICAgICAgIHByZXZpb3VzbHkgaGFwcGVuZWQgb3Igd2FzIHByZXZpb3VzbHkgYWJvcnRlZC4gKilcbiAgICB2YWwgYWJvcnQgOiAoJ2EsICdoKSB0IC0+ICdhIC0+ICgnYSwgJ2gpIEFib3J0X3Jlc3VsdC50XG5cbiAgICAoKiogW2Fib3J0X2V4biB0IGFdIHJldHVybnMgW3VuaXRdIGlmIFthYm9ydCB0IGEgPSBgT2tdLCBhbmQgb3RoZXJ3aXNlIHJhaXNlcy4gKilcbiAgICB2YWwgYWJvcnRfZXhuIDogKCdhLCAnaCkgdCAtPiAnYSAtPiB1bml0XG5cbiAgICAoKiogW2Fib3J0X2lmX3Bvc3NpYmxlIHQgYSA9IGlnbm9yZSAoYWJvcnQgdCBhKV0uICopXG4gICAgdmFsIGFib3J0X2lmX3Bvc3NpYmxlIDogKCdhLCBfKSB0IC0+ICdhIC0+IHVuaXRcblxuICAgIG1vZHVsZSBGaXJlZCA9IFRpbWVfc291cmNlLkV2ZW50LkZpcmVkXG5cbiAgICB2YWwgZmlyZWQgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIEZpcmVkLnQgRGVmZXJyZWQudFxuXG4gICAgbW9kdWxlIFJlc2NoZWR1bGVfcmVzdWx0ID0gVGltZV9zb3VyY2UuRXZlbnQuUmVzY2hlZHVsZV9yZXN1bHRcblxuICAgICgqKiBbcmVzY2hlZHVsZV9hdCB0XSBhbmQgW3Jlc2NoZWR1bGVfYWZ0ZXIgdF0gY2hhbmdlIHRoZSB0aW1lIHRoYXQgW3RdIHdpbGwgZmlyZSwgaWZcbiAgICAgICAgcG9zc2libGUsIGFuZCBpZiBub3QsIGdpdmUgYSByZWFzb24gd2h5LiAgTGlrZSBbcnVuX2F0XSwgaWYgdGhlIHJlcXVlc3RlZCB0aW1lIGlzXG4gICAgICAgIGluIHRoZSBwYXN0LCB0aGUgZXZlbnQgd2lsbCBiZSBzY2hlZHVsZWQgdG8gcnVuIGltbWVkaWF0ZWx5LiAgSWYgW3Jlc2NoZWR1bGVfYXQgdFxuICAgICAgICB0aW1lID0gT2tdLCB0aGVuIHN1YnNlcXVlbnRseSBbc2NoZWR1bGVkX2F0IHQgPSB0aW1lXS4gICopXG4gICAgdmFsIHJlc2NoZWR1bGVfYXQgOiAoJ2EsICdoKSB0IC0+IFRpbWUudCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hZnRlciA6ICgnYSwgJ2gpIHQgLT4gVGltZS5TcGFuLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuXG4gICAgKCoqIFthdCB0aW1lXSAgICBpcyBbcnVuX2F0ICAgIHRpbWUgaWdub3JlICgpXS5cbiAgICAgICAgW2FmdGVyIHRpbWVdIGlzIFtydW5fYWZ0ZXIgdGltZSBpZ25vcmUgKCldLlxuXG4gICAgICAgIFlvdSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgdGhlIFtydW5fKl0gZnVuY3Rpb25zLCB3aGljaCBhbGxvdyB5b3UgdG9cbiAgICAgICAgc3luY2hyb25vdXNseSB1cGRhdGUgc3RhdGUgdmlhIGEgdXNlci1zdXBwbGllZCBmdW5jdGlvbiB3aGVuIHRoZSBldmVudFxuICAgICAgICB0cmFuc2l0aW9ucyB0byBbSGFwcGVuZWRdLiAgVGhhdCBpcywgdGhlcmUgaXMgYW4gaW1wb3J0YW50IGRpZmZlcmVuY2UgYmV0d2VlbjpcblxuICAgICAgICB7W1xuICAgICAgICAgIGxldCB0ID0gcnVuX2F0IHRpbWUgZiAoKSBdfVxuXG4gICAgICAgIGFuZDpcblxuICAgICAgICB7W1xuICAgICAgICAgIGxldCB0ID0gYXQgdGltZSBpblxuICAgICAgICAgIGZpcmVkIHRcbiAgICAgICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgICAgICB8IEhhcHBlbmVkICgpIC0+IGYgKClcbiAgICAgICAgICB8IEFib3J0ZWQgKCkgLT4gKCkgXX1cblxuICAgICAgICBXaXRoIFtydW5fYXRdLCBpZiBbc3RhdHVzIHQgPSBIYXBwZW5lZF0sIG9uZSBrbm93cyB0aGF0IFtmXSBoYXMgcnVuLiAgV2l0aCBbYXRdXG4gICAgICAgIGFuZCBbZmlyZWRdLCBvbmUgZG9lcyBub3Qga25vdyB3aGV0aGVyIFtmXSBoYXMgeWV0IHJ1bjsgaXQgbWF5IHN0aWxsIGJlIHNjaGVkdWxlZFxuICAgICAgICB0byBydW4uICBUaHVzLCB3aXRoIFthdF0gYW5kIFtmaXJlZF0sIGl0IGlzIGVhc3kgdG8gaW50cm9kdWNlIGEgcmFjZS4gIEZvclxuICAgICAgICBleGFtcGxlLCBjb25zaWRlciB0aGVzZSB0d28gY29kZSBzbmlwcGV0czpcblxuICAgICAgICB7W1xuICAgICAgICAgIGxldCB0ID0gRXZlbnQuYWZ0ZXIgKHNlYyAyLikgaW5cbiAgICAgICAgICB1cG9uIChFdmVudC5maXJlZCB0KSAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgQWJvcnRlZCAoKSAtPiAoKVxuICAgICAgICAgICAgfCBIYXBwZW5lZCAoKSAtPiBwcmludGYgXCJUaW1lciBmaXJlZFwiKTtcbiAgICAgICAgICB1cG9uIGRlZmVycmVkX2V2ZW50IChmdW4gKCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEV2ZW50LmFib3J0IHQgKCkgd2l0aFxuICAgICAgICAgICAgfCBPayAtPiBwcmludGYgXCJFdmVudCBvY2N1cnJlZFwiXG4gICAgICAgICAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCAoKSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCAoKSAtPiBwcmludGYgXCJFdmVudCBvY2N1cnJlZCBhZnRlciB0aW1lciBmaXJlZFwiKTsgXX1cblxuICAgICAgICB7W1xuICAgICAgICAgIGxldCB0ID0gRXZlbnQucnVuX2FmdGVyIChzZWMgMi4pIHByaW50ZiBcIlRpbWVyIGZpcmVkXCIgaW5cbiAgICAgICAgICB1cG9uIGRlZmVycmVkX2V2ZW50IChmdW4gKCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEV2ZW50LmFib3J0IHQgKCkgd2l0aFxuICAgICAgICAgICAgfCBPayAtPiBwcmludGYgXCJFdmVudCBvY2N1cnJlZFwiXG4gICAgICAgICAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCAoKSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCAoKSAtPiBwcmludGYgXCJFdmVudCBvY2N1cnJlZCBhZnRlciB0aW1lciBmaXJlZFwiKTsgXX1cblxuICAgICAgICBJbiBib3RoIHNuaXBwZXRzLCBpZiBbRXZlbnQuYWJvcnRdIHJldHVybnMgW09rXSwgXCJUaW1lciBmaXJlZFwiIGlzIG5ldmVyIHByaW50ZWQuXG4gICAgICAgIEhvd2V2ZXIsIHRoZSBmaXJzdCBzbmlwcGV0IG1pZ2h0IHByaW50IFwiRXZlbnQgb2NjdXJyZWQgYWZ0ZXIgdGltZXIgZmlyZWRcIiBhbmQgdGhlblxuICAgICAgICBcIlRpbWVyIGZpcmVkXCIuICBUaGlzIGNvbmZ1c2VkIG9yZGVyaW5nIGNhbm5vdCBoYXBwZW4gd2l0aCBbRXZlbnQucnVuX2FmdGVyXS4gKilcbiAgICB2YWwgYXQgOiBUaW1lLnQgLT4gKF8sIHVuaXQpIHRcblxuICAgIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IChfLCB1bml0KSB0XG4gIGVuZFxuXG4gICgqKiBbYXRfdmFyeWluZ19pbnRlcnZhbHMgZiA/c3RvcF0gcmV0dXJucyBhIHN0cmVhbSB3aG9zZSBuZXh0IGVsZW1lbnQgYmVjb21lc1xuICAgICAgZGV0ZXJtaW5lZCBieSBjYWxsaW5nIFtmICgpXSBhbmQgd2FpdGluZyBmb3IgdGhhdCBhbW91bnQgb2YgdGltZSwgYW5kIHRoZW4gbG9vcGluZ1xuICAgICAgdG8gZGV0ZXJtaW5lIHN1YnNlcXVlbnQgZWxlbWVudHMuICBUaGUgc3RyZWFtIHdpbGwgZW5kIGFmdGVyIFtzdG9wXSBiZWNvbWVzXG4gICAgICBkZXRlcm1pbmVkLiAqKVxuICB2YWwgYXRfdmFyeWluZ19pbnRlcnZhbHNcbiAgICA6ICA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiAodW5pdCAtPiBUaW1lLlNwYW4udClcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG5cbiAgKCoqIFthdF9pbnRlcnZhbHMgaW50ZXJ2YWwgP3N0YXJ0ID9zdG9wXSByZXR1cm5zIGEgc3RyZWFtIHdob3NlIGVsZW1lbnRzIHdpbGwgYmVjb21lXG4gICAgICBkZXRlcm1pbmVkIGF0IG5vbm5lZ2F0aXZlIGludGVnZXIgbXVsdGlwbGVzIG9mIFtpbnRlcnZhbF0gYWZ0ZXIgdGhlIFtzdGFydF0gdGltZSxcbiAgICAgIHVudGlsIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQ6XG5cbiAgICAgIHt2XG4gICAgICAgIHN0YXJ0ICsgMCAqIGludGVydmFsXG4gICAgICAgIHN0YXJ0ICsgMSAqIGludGVydmFsXG4gICAgICAgIHN0YXJ0ICsgMiAqIGludGVydmFsXG4gICAgICAgIHN0YXJ0ICsgMyAqIGludGVydmFsXG4gICAgICAgIC4uLlxuICAgICAgdn1cblxuICAgICAgTm90ZSB0aGF0IG9ubHkgZWxlbWVudHMgdGhhdCBhcmUgc3RyaWN0bHkgaW4gdGhlIGZ1dHVyZSBldmVyIGJlY29tZSBkZXRlcm1pbmVkLlxuICAgICAgSW4gcGFydGljdWxhciwgaWYgW3N0YXJ0XSBpcyBub3QgaW4gdGhlIGZ1dHVyZSwgb3IgW3N0YXJ0XSBpcyBub3QgcHJvdmlkZWQsXG4gICAgICB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gZWxlbWVudCBiZWZvcmUgdGhlIFtpbnRlcnZhbF0gaGFzIHBhc3NlZC5cblxuICAgICAgSWYgdGhlIGludGVydmFsIGlzIHRvbyBzbWFsbCBvciB0aGUgQ1BVIGlzIHRvbyBsb2FkZWQsIFthdF9pbnRlcnZhbHNdIHdpbGwgc2tpcFxuICAgICAgdW50aWwgdGhlIG5leHQgdXBjb21pbmcgbXVsdGlwbGUgb2YgW2ludGVydmFsXSBhZnRlciBbc3RhcnRdLiAqKVxuICB2YWwgYXRfaW50ZXJ2YWxzXG4gICAgOiAgP3N0YXJ0OlRpbWUudFxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gdW5pdCBBc3luY19zdHJlYW0udFxuXG4gICgqKiBbZXZlcnknID9zdGFydCA/c3RvcCBzcGFuIGZdIHJ1bnMgW2YgKCldIGV2ZXJ5IFtzcGFuXSBhbW91bnQgb2YgdGltZSBzdGFydGluZyB3aGVuXG4gICAgICBbc3RhcnRdIGJlY29tZXMgZGV0ZXJtaW5lZCBhbmQgc3RvcHBpbmcgd2hlbiBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkLiAgW2V2ZXJ5J11cbiAgICAgIHdhaXRzIHVudGlsIHRoZSBvdXRjb21lIG9mIFtmICgpXSBiZWNvbWVzIGRldGVybWluZWQgYmVmb3JlIHdhaXRpbmcgZm9yIHRoZSBuZXh0XG4gICAgICBbc3Bhbl0uXG5cbiAgICAgIEl0IGlzIGd1YXJhbnRlZWQgdGhhdCBpZiBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkLCBldmVuIGR1cmluZyBldmFsdWF0aW9uIG9mIFtmXSxcbiAgICAgIHRoZW4gW2ZdIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBieSBhIHN1YnNlcXVlbnQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuXG4gICAgICBJdCBpcyBhbiBlcnJvciBmb3IgW3NwYW5dIHRvIGJlIG5vbnBvc2l0aXZlLlxuXG4gICAgICBbY29udGludWVfb25fZXJyb3JdIGNvbnRyb2xzIHdoYXQgc2hvdWxkIGhhcHBlbiBpZiBbZl0gcmFpc2VzIGFuIGV4Y2VwdGlvbi5cbiAgICAgIFdpdGggW35jb250aW51ZV9vbl9lcnJvcjpmYWxzZV0sIGl0ZXJhdGlvbiBvbmx5IGNvbnRpbnVlcyBpZiBbZl0gc3VjY2Vzc2Z1bGx5XG4gICAgICByZXR1cm5zIGEgZGVmZXJyZWQgYW5kIHRoYXQgZGVmZXJyZWQgaXMgZGV0ZXJtaW5lZC5cbiAgICAgIFdpdGggW35jb250aW51ZV9vbl9lcnJvcjp0cnVlXSwgaXRlcmF0aW9uIGFsc28gY29udGludWVzIGlmIFtmXSByYWlzZXMgYW4gZXhjZXB0aW9uLlxuICAgICAgSWYgW2ZdIHJhaXNlcyBhbiBleGNlcHRpb24gYXN5bmNocm9ub3VzbHksIHRoaXMgbWF5IGNhdXNlIHVzIHRvIHByb2NlZWQgd2l0aCB0aGVcbiAgICAgIG5leHQgaXRlcmF0aW9uIHdoaWxlIHRoZSBwcmV2aW91cyBjYWxsIHRvIFtmXSBpcyBzdGlsbCBydW5uaW5nLlxuXG4gICAgICBFeGNlcHRpb25zIHJhaXNlZCBieSBbZl0gYXJlIGFsd2F5cyBzZW50IHRvIHRoZSBtb25pdG9yIGluIGVmZmVjdCB3aGVuIFtldmVyeSddIHdhc1xuICAgICAgY2FsbGVkLCBldmVuIHdpdGggW35jb250aW51ZV9vbl9lcnJvcjp0cnVlXS5cblxuICAgICAgSWYgW2ZpbmlzaGVkXSBpcyBzdXBwbGllZCwgW2V2ZXJ5J10gd2lsbCBmaWxsIGl0IG9uY2UgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYmVjb21lXG4gICAgICBkZXRlcm1pbmVkOiBbc3RhcnRdLCBbc3RvcF0sIGFuZCB0aGUgb3V0Y29tZSBvZiB0aGUgZmluYWwgY2FsbCB0byBbZl0uICopXG4gIHZhbCBldmVyeSdcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiA/ZmluaXNoZWQ6dW5pdCBJdmFyLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtldmVyeSA/c3RhcnQgP3N0b3Agc3BhbiBmXSBpc1xuICAgICAgW2V2ZXJ5JyA/c3RhcnQgP3N0b3Agc3BhbiAoZnVuICgpIC0+IGYgKCk7IHJldHVybiAoKSldLiAqKVxuICB2YWwgZXZlcnlcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBbcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wIHNwYW4gZl0gcnVucyBbZigpXSBhdCBpbmNyZW1lbnRzIG9mIFtzdGFydCArIGkgKlxuICAgICAgc3Bhbl0gZm9yIG5vbm5lZ2F0aXZlIGludGVnZXJzIFtpXSwgdW50aWwgW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZC5cbiAgICAgIElmIHRoZSByZXN1bHQgb2YgW2ZdIGlzIG5vdCBkZXRlcm1pbmVkIGZhc3QgZW5vdWdoIHRoZW4gdGhlIG5leHQgaW50ZXJ2YWwocylcbiAgICAgIGFyZSBza2lwcGVkIHNvIHRoYXQgdGhlcmUgYXJlIG5ldmVyIG11bHRpcGxlIGNvbmN1cnJlbnQgaW52b2NhdGlvbnMgb2YgW2ZdIGluXG4gICAgICBmbGlnaHQuXG5cbiAgICAgIEV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBhcmUgYWx3YXlzIHNlbnQgdG8gbW9uaXRvciBpbiBlZmZlY3Qgd2hlblxuICAgICAgW3J1bl9hdF9pbnRlcnZhbHMnXSB3YXMgY2FsbGVkLCBldmVuIHdpdGggW35jb250aW51ZV9vbl9lcnJvcjp0cnVlXS4gKilcbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmXSBpcyBlcXVpdmFsZW50IHRvOlxuXG4gICAgICB7W1xuICAgICAgICBydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHNwYW5cbiAgICAgICAgICAoZnVuICgpIC0+IGYgKCk7IHJldHVybiAoKSkgXX0gKilcbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50ICgqKiBkZWZhdWx0IGlzIFtUaW1lLm5vdyAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtkdXJhdGlvbl9vZiBmXSBpbnZva2VzIFtmICgpXSBhbmQgbWVhc3VyZXMgaG93IGxvbmcgaXQgdGFrZXMgZnJvbSB0aGUgaW52b2NhdGlvblxuICAgICAgdG8gYWZ0ZXIgdGhlIGRlZmVycmVkIGlzIGRldGVybWluZWQuXG5cbiAgICAgIE5vdGUgdGhhdCB0aGUgbWVhc3VyZW1lbnQgaXMgbm90IGV4YWN0OyBiZWNhdXNlIGl0IGludm9sdmVzIGFuIGFkZGl0aW9uYWwgbWFwIG9uIHRoZVxuICAgICAgZGVmZXJyZWQsIHRoZSB0aW1pbmcgYWxzbyBpbmNsdWRlcyB0aGUgZHVyYXRpb24gb2Ygam9icyBpbiB0aGUgam9iIHF1ZXVlIHdoZW4gW2YgKCldXG4gICAgICBpcyBkZXRlcm1pbmVkLiAqKVxuICB2YWwgZHVyYXRpb25fb2YgOiAodW5pdCAtPiAnYSBEZWZlcnJlZC50KSAtPiAoJ2EgKiBUaW1lLlNwYW4udCkgRGVmZXJyZWQudFxuZW5kXG5cbigqKiBbQ2xvY2tfZGVwcmVjYXRlZF0gaXMgdXNlZCBpbiBbUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZV0gdG8gY3JlYXRlIGEgY2xvY2tcbiAgICBtb2R1bGUgaW4gd2hpY2ggYWxsIGZ1bmN0aW9ucyBhcmUgZGVwcmVjYXRlZC4gKilcbm1vZHVsZSB0eXBlIENsb2NrX2RlcHJlY2F0ZWQgPSBzaWdcbiAgbW9kdWxlIE9yX3RpbWVvdXQgPSBPcl90aW1lb3V0XG5cbiAgbW9kdWxlIFRpbWUgOiBzaWdcbiAgICBtb2R1bGUgU3BhbiA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgZW5kXG5cbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgYXQgOiBUaW1lLnQgLT4gdW5pdCBEZWZlcnJlZC50IFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiB1bml0IERlZmVycmVkLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCB3aXRoX3RpbWVvdXQgOiBUaW1lLlNwYW4udCAtPiAnYSBEZWZlcnJlZC50IC0+ICdhIE9yX3RpbWVvdXQudCBEZWZlcnJlZC50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICBtb2R1bGUgRXZlbnQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2gpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICB0eXBlIHRfdW5pdCA9ICh1bml0LCB1bml0KSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlXG4gICAgICBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHNjaGVkdWxlZF9hdCA6IChfLCBfKSB0IC0+IFRpbWUudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBTdGF0dXMgOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgICAgIHwgU2NoZWR1bGVkX2F0IG9mIFRpbWUudFxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIHZhbCBzdGF0dXMgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIFN0YXR1cy50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5BYm9ydF9yZXN1bHRcblxuICAgIHZhbCBhYm9ydCA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gKCdhLCAnaCkgQWJvcnRfcmVzdWx0LnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWJvcnRfZXhuIDogKCdhLCAnaCkgdCAtPiAnYSAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIGFib3J0X2lmX3Bvc3NpYmxlIDogKCdhLCBfKSB0IC0+ICdhIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICBtb2R1bGUgRmlyZWQgPSBUaW1lX3NvdXJjZS5FdmVudC5GaXJlZFxuXG4gICAgdmFsIGZpcmVkIDogKCdhLCAnaCkgdCAtPiAoJ2EsICdoKSBGaXJlZC50IERlZmVycmVkLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5SZXNjaGVkdWxlX3Jlc3VsdFxuXG4gICAgdmFsIHJlc2NoZWR1bGVfYXQgOiAoJ2EsICdoKSB0IC0+IFRpbWUudCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJlc2NoZWR1bGVfYWZ0ZXIgOiAoJ2EsICdoKSB0IC0+IFRpbWUuU3Bhbi50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYXQgOiBUaW1lLnQgLT4gKF8sIHVuaXQpIHQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gKF8sIHVuaXQpIHRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG4gIGVuZFxuXG4gIHZhbCBhdF92YXJ5aW5nX2ludGVydmFsc1xuICAgIDogID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+ICh1bml0IC0+IFRpbWUuU3Bhbi50KVxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50XG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgZXZlcnknXG4gICAgOiAgP3N0YXJ0OnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbcmV0dXJuICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gP2ZpbmlzaGVkOnVuaXQgSXZhci50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgLT4gdW5pdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGV2ZXJ5XG4gICAgOiAgP3N0YXJ0OnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbcmV0dXJuICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBydW5fYXRfaW50ZXJ2YWxzJ1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgLT4gdW5pdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50ICgqKiBkZWZhdWx0IGlzIFtUaW1lLm5vdyAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgZHVyYXRpb25fb2YgOiAodW5pdCAtPiAnYSBEZWZlcnJlZC50KSAtPiAoJ2EgKiBUaW1lLlNwYW4udCkgRGVmZXJyZWQudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5lbmRcblxuKCoqIEBpbmxpbmUgKilcbmluY2x1ZGUgKFxuc3RydWN0XG4gIFtAQEB3YXJuaW5nIFwiLTNcIl1cblxuICBtb2R1bGUgXyAoQyA6IENsb2NrKSA6IENsb2NrX2RlcHJlY2F0ZWQgPSBDXG5cbiAgbW9kdWxlIF8gKEMgOiBDbG9ja19kZXByZWNhdGVkKSA6IENsb2NrID0gQ1xuZW5kIDpcbnNpZyBlbmQpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIHR5cGUgQ2xvY2sgPSBDbG9ja19pbnRmLkNsb2NrXG5tb2R1bGUgdHlwZSBDbG9ja19kZXByZWNhdGVkID0gQ2xvY2tfaW50Zi5DbG9ja19kZXByZWNhdGVkXG5cbm1vZHVsZSBPcl90aW1lb3V0ID0gQ2xvY2tfaW50Zi5Pcl90aW1lb3V0XG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuXG5sZXQgdGltZV9zb3VyY2UgKCkgPSAoU2NoZWR1bGVyLnQgKCkpLnRpbWVfc291cmNlIHw+IFRpbWVfc291cmNlLm9mX3N5bmNocm9ub3VzXG5sZXQgYWZ0ZXIgc3BhbiA9IFRpbWVfc291cmNlLmFmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhblxubGV0IGF0IHRpbWUgPSBUaW1lX3NvdXJjZS5hdCAodGltZV9zb3VyY2UgKCkpIHRpbWVcblxubGV0IGF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wIGNvbXB1dGVfc3BhbiA9XG4gIFRpbWVfc291cmNlLmF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wICh0aW1lX3NvdXJjZSAoKSkgY29tcHV0ZV9zcGFuXG47O1xuXG5sZXQgYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCBpbnRlcnZhbCA9XG4gIFRpbWVfc291cmNlLmF0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgKHRpbWVfc291cmNlICgpKSBpbnRlcnZhbFxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCBzcGFuIGYgPVxuICBUaW1lX3NvdXJjZS5ldmVyeScgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgKHRpbWVfc291cmNlICgpKSBzcGFuIGZcbjs7XG5cbmxldCBldmVyeSA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHNwYW4gZiA9XG4gIFRpbWVfc291cmNlLmV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgKHRpbWVfc291cmNlICgpKSBzcGFuIGZcbjs7XG5cbmxldCBydW5fYWZ0ZXIgc3BhbiBmIGEgPSBUaW1lX3NvdXJjZS5ydW5fYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuIGYgYVxubGV0IHJ1bl9hdCB0aW1lIGYgYSA9IFRpbWVfc291cmNlLnJ1bl9hdCAodGltZV9zb3VyY2UgKCkpIHRpbWUgZiBhXG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgaW50ZXJ2YWwgZiA9XG4gIFRpbWVfc291cmNlLnJ1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAodGltZV9zb3VyY2UgKCkpIGludGVydmFsIGZcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIGludGVydmFsIGYgPVxuICBUaW1lX3NvdXJjZS5ydW5fYXRfaW50ZXJ2YWxzJ1xuICAgID9zdGFydFxuICAgID9zdG9wXG4gICAgP2NvbnRpbnVlX29uX2Vycm9yXG4gICAgKHRpbWVfc291cmNlICgpKVxuICAgIGludGVydmFsXG4gICAgZlxuOztcblxubGV0IHdpdGhfdGltZW91dCBzcGFuIGQgPSBUaW1lX3NvdXJjZS53aXRoX3RpbWVvdXQgKHRpbWVfc291cmNlICgpKSBzcGFuIGRcbmxldCBkdXJhdGlvbl9vZiBmID0gVGltZV9zb3VyY2UuZHVyYXRpb25fb2YgKHRpbWVfc291cmNlICgpKSBmXG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfc291cmNlLkV2ZW50XG5cbiAgbGV0IGFmdGVyIHNwYW4gPSBhZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW5cbiAgbGV0IHJ1bl9hZnRlciBzcGFuIGYgYSA9IHJ1bl9hZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZiBhXG4gIGxldCBhdCB0aW1lID0gYXQgKHRpbWVfc291cmNlICgpKSB0aW1lXG4gIGxldCBydW5fYXQgdGltZSBmIHogPSBydW5fYXQgKHRpbWVfc291cmNlICgpKSB0aW1lIGYgelxuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgaSBiID1cbiAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdFxuICAgICAgdGhlbiBJdmFyLmZpbGwgcmVzdWx0IGJcbiAgICAgIGVsc2UgZiBpIGIgdC4oaSkgPj4+IGZ1biBiIC0+IGxvb3AgKGkgKyAxKSBiXG4gICAgaW5cbiAgICBsb29wIDAgaW5pdClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbmxldCBzZXFtYXBpIHQgfmYgPVxuICBsZXQlbWFwIGJzID0gZm9sZGkgdCB+aW5pdDpbXSB+ZjooZnVuIGkgYnMgYSAtPiBmIGkgYSA+PnwgZnVuIGIgLT4gYiA6OiBicykgaW5cbiAgQXJyYXkub2ZfbGlzdCAoQ29yZS5MaXN0LnJldiBicylcbjs7XG5cbmxldCBhbGwgZHMgPSBzZXFtYXBpIGRzIH5mOihmdW4gXyB4IC0+IHgpXG5sZXQgYWxsX3VuaXQgZHMgPSBEZWZlcnJlZC5pZ25vcmVfbSAoZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZCkpXG5cbmxldCBpdGVyaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsX3VuaXQgKEFycmF5Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYFNlcXVlbnRpYWwgLT4gZm9sZGkgdCB+aW5pdDooKSB+ZjooZnVuIGkgKCkgeCAtPiBmIGkgeClcbjs7XG5cbmxldCBtYXBpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGwgKEFycmF5Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG47O1xuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBsZXQlbWFwIGJvb2xzID0gbWFwaSB0ID9ob3cgfmYgaW5cbiAgQXJyYXkub2ZfbGlzdF9yZXZcbiAgICAoQXJyYXkuZm9sZDJfZXhuIHQgYm9vbHMgfmluaXQ6W10gfmY6KGZ1biBhYyB4IGIgLT4gaWYgYiB0aGVuIHggOjogYWMgZWxzZSBhYykpXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgP2hvdyB0IH5mID0gbWFwaSB0ID9ob3cgfmYgPj58IEFycmF5LmZpbHRlcl9vcHRcblxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgdCA9IG1hcGkgdCA/aG93IH5mIGluXG4gIEFycmF5LmNvbmNhdCAoQXJyYXkudG9fbGlzdCB0KVxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0XG4gICAgdGhlbiByZXR1cm4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2glYmluZCBmIGkgdC4oaSkgd2l0aFxuICAgICAgfCBOb25lIC0+IGF1eCAoaSArIDEpXG4gICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICBpblxuICBhdXggMFxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIF8gZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBlbHQgZWxzZSBOb25lKVxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgbm90IGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gZmFsc2VcbiAgfCBOb25lIC0+IHRydWVcbjs7XG5cbmxldCBpdGVyID9ob3cgdCB+ZiA9IGl0ZXJpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgbWFwID9ob3cgdCB+ZiA9IG1hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBjb25jYXRfbWFwID9ob3cgdCB+ZiA9IGNvbmNhdF9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgaW5pdCA/aG93IG4gfmYgPSBtYXAgP2hvdyAoQXJyYXkuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgaSBiID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBJdmFyLmZpbGwgcmVzdWx0IGJcbiAgICAgIHwgeCA6OiB4cyAtPiBmIGkgYiB4ID4+PiBmdW4gYiAtPiBsb29wIHhzIChpICsgMSkgYlxuICAgIGluXG4gICAgbG9vcCB0IDAgaW5pdClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbmxldCBzZXFtYXBpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OltdIH5mOihmdW4gaSBicyBhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICBiIDo6IGJzKVxuICA+PnwgTGlzdC5yZXZcbjs7XG5cbmxldCBhbGwgZHMgPSBzZXFtYXBpIGRzIH5mOihmdW4gXyB4IC0+IHgpXG5sZXQgYWxsX3VuaXQgZHMgPSBEZWZlcnJlZC5pZ25vcmVfbSAoZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZCkpXG5cbmxldCBpdGVyaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsX3VuaXQgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuOztcblxubGV0IG1hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgIGFsbCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICB8IGBTZXF1ZW50aWFsIC0+IHNlcW1hcGkgdCB+ZlxuOztcblxubGV0IGZpbHRlcmkgP2hvdyB0IH5mID1cbiAgbGV0JW1hcCBib29scyA9IG1hcGkgdCA/aG93IH5mIGluXG4gIExpc3QucmV2IChMaXN0LmZvbGQyX2V4biB0IGJvb2xzIH5pbml0OltdIH5mOihmdW4gYWMgeCBiIC0+IGlmIGIgdGhlbiB4IDo6IGFjIGVsc2UgYWMpKVxuOztcblxubGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbmxldCBjb25jYXRfbWFwaSA/aG93IHQgfmYgPSBtYXBpIHQgP2hvdyB+ZiA+PnwgTGlzdC5jb25jYXRcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldHVybiBOb25lXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoJWJpbmQgZiBpIGhkIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHRsIH5mIChpICsgMSlcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICBpblxuICBmaW5kX21hcGkgdCB+ZiAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlciA/aG93IHQgfmYgPSBmaWx0ZXJpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID0gY29uY2F0X21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0ID9ob3cgbiB+ZiA9IG1hcCA/aG93IChMaXN0LmluaXQgbiB+ZjpGbi5pZCkgfmZcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIExpc3QgPSBEZWZlcnJlZF9saXN0XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTWFwLnRcblxubGV0IGNoYW5nZSB0IGsgfmYgPVxuICBsZXQlbWFwIG9wdCA9IGYgKE1hcC5maW5kIHQgaykgaW5cbiAgTWFwLmNoYW5nZSB0IGsgfmY6KGZ1biBfIC0+IG9wdClcbjs7XG5cbmxldCB1cGRhdGUgdCBrIH5mID1cbiAgbGV0JW1hcCBkYXRhID0gZiAoTWFwLmZpbmQgdCBrKSBpblxuICBNYXAuc2V0IHQgfmtleTprIH5kYXRhXG47O1xuXG5sZXQgaXRlcl9rZXlzID9ob3cgdCB+ZiA9IExpc3QuaXRlciA/aG93IChNYXAua2V5cyB0KSB+ZlxubGV0IGl0ZXIgP2hvdyB0IH5mID0gTGlzdC5pdGVyID9ob3cgKE1hcC5kYXRhIHQpIH5mXG5sZXQgaXRlcmkgP2hvdyB0IH5mID0gTGlzdC5pdGVyID9ob3cgKE1hcC50b19hbGlzdCB0KSB+ZjooZnVuIChrZXksIGRhdGEpIC0+IGYgfmtleSB+ZGF0YSlcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBhbGlzdF9pbl9pbmNyZWFzaW5nX2tleV9vcmRlciA9XG4gICAgTWFwLmZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWxpc3QgLT4gKGtleSwgZGF0YSkgOjogYWxpc3QpXG4gIGluXG4gIExpc3QuZm9sZCBhbGlzdF9pbl9pbmNyZWFzaW5nX2tleV9vcmRlciB+aW5pdCB+ZjooZnVuIGFjIChrZXksIGRhdGEpIC0+IGYgfmtleSB+ZGF0YSBhYylcbjs7XG5cbmxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPVxuICBsZXQgYWxpc3RfaW5fZGVjcmVhc2luZ19rZXlfb3JkZXIgPVxuICAgIE1hcC5mb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFsaXN0IC0+IChrZXksIGRhdGEpIDo6IGFsaXN0KVxuICBpblxuICBMaXN0LmZvbGQgYWxpc3RfaW5fZGVjcmVhc2luZ19rZXlfb3JkZXIgfmluaXQgfmY6KGZ1biBhYyAoa2V5LCBkYXRhKSAtPiBmIH5rZXkgfmRhdGEgYWMpXG47O1xuXG5tb2R1bGUgSm9iID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPVxuICAgIHsga2V5IDogJ2FcbiAgICA7IGRhdGEgOiAnYlxuICAgIDsgbXV0YWJsZSByZXN1bHQgOiAnYyBvcHRpb25cbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkc11cbmVuZFxuXG5sZXQgZmlsdGVyX21hcGlfc2VxdWVudGlhbCB0IH5mID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciB0IGluXG4gIGxldCBzZXF1ZW5jZSA9IE1hcC50b19zZXF1ZW5jZSB+b3JkZXI6YEluY3JlYXNpbmdfa2V5IHQgaW5cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPlxuICAgIFNlcXVlbmNlLmRlbGF5ZWRfZm9sZFxuICAgICAgc2VxdWVuY2VcbiAgICAgIH5pbml0OkJhc2UuTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5CdWlsZF9pbmNyZWFzaW5nLmVtcHR5XG4gICAgICB+ZjooZnVuIHMgKGtleSwgZGF0YSkgfmsgLT5cbiAgICAgICAgdXBvbiAoZiB+a2V5IH5kYXRhKSAoZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gayBzXG4gICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgIGxldCBzID1cbiAgICAgICAgICAgICAgQmFzZS5NYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLkJ1aWxkX2luY3JlYXNpbmcuYWRkX2V4blxuICAgICAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICB+Y29tcGFyYXRvclxuICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGsgcykpXG4gICAgICB+ZmluaXNoOihmdW4geCAtPlxuICAgICAgICBJdmFyLmZpbGxcbiAgICAgICAgICBpdmFyXG4gICAgICAgICAgKE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWVcbiAgICAgICAgICAgICB+Y29tcGFyYXRvclxuICAgICAgICAgICAgIChCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy50b190cmVlIHgpKSkpXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYFNlcXVlbnRpYWwgLT4gZmlsdGVyX21hcGlfc2VxdWVudGlhbCB0IH5mXG4gIHwgYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXyAtPlxuICAgIGxldCBqb2JzID0gcmVmIFtdIGluXG4gICAgbGV0IGpvYl9tYXAgPVxuICAgICAgTWFwLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgbGV0IGpvYiA9IHsgSm9iLmtleTsgZGF0YTsgcmVzdWx0ID0gTm9uZSB9IGluXG4gICAgICAgIGpvYnMgOj0gam9iIDo6ICFqb2JzO1xuICAgICAgICBqb2IpXG4gICAgaW5cbiAgICBsZXQlbWFwICgpID1cbiAgICAgIExpc3QuaXRlciB+aG93IChCYXNlLkxpc3QucmV2ICFqb2JzKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCB7IEpvYi5rZXk7IGRhdGE7IHJlc3VsdCA9IF8gfSBhcyBqb2IgLT5cbiAgICAgICAgICBsZXQlbWFwIHggPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICBqb2IucmVzdWx0IDwtIHgpXG4gICAgaW5cbiAgICBNYXAuZmlsdGVyX21hcCBqb2JfbWFwIH5mOkpvYi5yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaWx0ZXJfa2V5cyA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBrZXkgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXIgP2hvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBkYXRhIGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiB+a2V5IH5kYXRhIGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgbWFwaSA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0JW1hcCB6ID0gZiB+a2V5IH5kYXRhIGluXG4gICAgU29tZSB6KVxuOztcblxubGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBtZXJnZSA/aG93IHQxIHQyIH5mID1cbiAgZmlsdGVyX21hcFxuICAgID9ob3dcbiAgICAoTWFwLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleSB6IC0+IFNvbWUgKGZ1biAoKSAtPiBmIH5rZXkgeikpKVxuICAgIH5mOihmdW4gdGh1bmsgLT4gdGh1bmsgKCkpXG47O1xuXG5sZXQgYWxsIHQgPSBtYXAgdCB+ZjpGbi5pZFxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbmxldCByZXJhaXNlID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBleG4gLT4gRXhuLnJlcmFpc2UgZXhuIFwiY2F1Z2h0IGV4Y2VwdGlvbiBpbiBtZW1vaXplZCBmdW5jdGlvblwiXG47O1xuXG5sZXQgZ2VuZXJhbCAodHlwZSBhKSAoaGFzaGFibGUgOiAobW9kdWxlIEhhc2hhYmxlLlNfcGxhaW4gd2l0aCB0eXBlIHQgPSBhKSkgZiA9XG4gIGxldCBtb2R1bGUgSGFzaGFibGUgPSAodmFsIGhhc2hhYmxlKSBpblxuICBsZXQgZiA9XG4gICAgTWVtby5nZW5lcmFsIH5oYXNoYWJsZTpIYXNoYWJsZS5oYXNoYWJsZSAoZnVuIGEgLT5cbiAgICAgIE1vbml0b3IudHJ5X3dpdGhcbiAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICB+cnVuOmBOb3dcbiAgICAgICAgKGZ1biAoKSAtPiBmIGEpKVxuICBpblxuICBTdGFnZWQuc3RhZ2UgKGZ1biBhIC0+IGYgYSA+PnwgcmVyYWlzZSlcbjs7XG5cbmxldCB1bml0IGYgPVxuICBsZXQgZiA9XG4gICAgTWVtby51bml0IChmdW4gKCkgLT5cbiAgICAgIE1vbml0b3IudHJ5X3dpdGhcbiAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICB+cnVuOmBOb3dcbiAgICAgICAgZilcbiAgaW5cbiAgU3RhZ2VkLnN0YWdlIChmdW4gKCkgLT4gZiAoKSA+PnwgcmVyYWlzZSlcbjs7XG4iLCJvcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBPcHRpb24udCBEZWZlcnJlZC50XG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgcmV0dXJuIGEgPSBEZWZlcnJlZC5yZXR1cm4gKFNvbWUgYSlcblxuICAgIGxldCBiaW5kIHQgfmYgPVxuICAgICAgRGVmZXJyZWQuYmluZCB0IH5mOihmdW5jdGlvblxuICAgICAgICB8IFNvbWUgYSAtPiBmIGFcbiAgICAgICAgfCBOb25lIC0+IERlZmVycmVkLnJldHVybiBOb25lKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwIHQgfmYgPSBEZWZlcnJlZC5tYXAgdCB+ZjooZnVuIHIgLT4gT3B0aW9uLm1hcCByIH5mKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdlcnJvcikgdCA9ICgnYSwgJ2Vycm9yKSBSZXN1bHQudCBEZWZlcnJlZC50XG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBjb21iaW5lIHQxIHQyIH5vayB+ZXJyID1cbiAgbGV0JW1hcCB0MSA9IHQxXG4gIGFuZCB0MiA9IHQyIGluXG4gIFJlc3VsdC5jb21iaW5lIHQxIHQyIH5vayB+ZXJyXG47O1xuXG5pbmNsdWRlIE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCByZXR1cm4gYSA9IERlZmVycmVkLnJldHVybiAoT2sgYSlcblxuICAgIGxldCBiaW5kIHQgfmYgPVxuICAgICAgRGVmZXJyZWQuYmluZCB0IH5mOihmdW5jdGlvblxuICAgICAgICB8IE9rIGEgLT4gZiBhXG4gICAgICAgIHwgRXJyb3IgXyBhcyBlcnJvciAtPiBEZWZlcnJlZC5yZXR1cm4gZXJyb3IpXG4gICAgOztcblxuICAgIGxldCBtYXAgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBSZXN1bHQubWFwIHIgfmYpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGZhaWwgeCA9IERlZmVycmVkLnJldHVybiAoRXJyb3IgeClcbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcbmxldCBtYXBfZXJyb3IgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBSZXN1bHQubWFwX2Vycm9yIHIgfmYpXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgTW9uaXRvciA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGggPSBNb25pdG9yLnRyeV93aXRoXG5lbmRcblxuKCogQ29waWVkIHRvIFtlYWdlcl9kZWZlcnJlZF9vcl9lcnJvci5tbF0uICBUaGVyZSBzaG91bGQgYmUgbm8gZGlmZnMgYmVsb3cgdGhpcyBsaW5lLiAqKVxuXG5pbmNsdWRlIChEZWZlcnJlZF9yZXN1bHQgOiBNb25hZC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBEZWZlcnJlZF9yZXN1bHQudClcblxudHlwZSAnYSB0ID0gJ2EgT3JfZXJyb3IudCBEZWZlcnJlZC50XG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGxldCBhcHBseSBmIHggPVxuICAgICAgRGVmZXJyZWRfcmVzdWx0LmNvbWJpbmVcbiAgICAgICAgZlxuICAgICAgICB4XG4gICAgICAgIH5vazooZnVuIGYgeCAtPiBmIHgpXG4gICAgICAgIH5lcnI6KGZ1biBlMSBlMiAtPiBFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5vcGVuIExldF9zeW50YXhcblxubGV0IGZhaWwgZXJyb3IgPSBEZWZlcnJlZC5yZXR1cm4gKFJlc3VsdC5mYWlsIGVycm9yKVxubGV0IG9rX2V4biB0ID0gRGVmZXJyZWQubWFwIHQgfmY6T3JfZXJyb3Iub2tfZXhuXG5sZXQgb2ZfZXhuIGV4biA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3Iub2ZfZXhuIGV4bilcbmxldCBvZl9leG5fcmVzdWx0IHQgPSBEZWZlcnJlZC5tYXAgdCB+ZjpPcl9lcnJvci5vZl9leG5fcmVzdWx0XG5sZXQgZXJyb3IgbXNnIHYgc2V4cF9vZiA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3IgbXNnIHYgc2V4cF9vZilcbmxldCBlcnJvcl9zIHNleHAgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3Mgc2V4cClcbmxldCBlcnJvcl9zdHJpbmcgbXNnID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgbXNnKVxubGV0IGVycm9yZiBmb3JtYXQgPSBrc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWcgfnRhZylcbmxldCB0YWdfcyB0IH50YWcgPSBEZWZlcnJlZC5tYXAgdCB+ZjooT3JfZXJyb3IudGFnX3MgfnRhZylcbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIERlZmVycmVkLm1hcCB0IH5mOihmdW4gdCAtPiBPcl9lcnJvci50YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCB1bmltcGxlbWVudGVkIG1zZyA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IudW5pbXBsZW1lbnRlZCBtc2cpXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9IERlZmVycmVkLm1hcCAoRGVmZXJyZWQuYWxsIGwpIH5mOk9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzXG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxuXG5sZXQgZmlsdGVyX29rX2F0X2xlYXN0X29uZSBsID1cbiAgRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuZmlsdGVyX29rX2F0X2xlYXN0X29uZVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBEZWZlcnJlZC5yZXBlYXRfdW50aWxfZmluaXNoZWQgKGwsIFtdKSAoZnVuIChsLCBlcnJvcnMpIC0+XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgbGV0IGVycm9ycyA9IEVycm9yLm9mX2xpc3QgKExpc3QucmV2IGVycm9ycykgaW5cbiAgICAgIERlZmVycmVkLnJldHVybiAoYEZpbmlzaGVkIChFcnJvciBlcnJvcnMpKVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIERlZmVycmVkLm1hcCAoZiBoZCkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgRXJyb3IgY3VycmVudF9lcnJvciAtPiBgUmVwZWF0ICh0bCwgY3VycmVudF9lcnJvciA6OiBlcnJvcnMpXG4gICAgICAgIHwgT2sgcmVzdWx0IC0+IGBGaW5pc2hlZCAoT2sgcmVzdWx0KSkpXG47O1xuXG5sZXQgb2tfdW5pdCA9IHJldHVybiAoKVxuXG5sZXQgdHJ5X3dpdGggP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgP2hlcmUgP25hbWUgZiA9XG4gIERlZmVycmVkLm1hcCAoTW9uaXRvci50cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmKSB+ZjooZnVuY3Rpb25cbiAgICB8IEVycm9yIGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4bilcbiAgICB8IE9rIF8gYXMgb2sgLT4gb2spXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmID1cbiAgRGVmZXJyZWQubWFwICh0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmKSB+ZjpPcl9lcnJvci5qb2luXG47O1xuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBsZXQgZm9sZGkgbGlzdCB+aW5pdDphY2MgfmYgPVxuICAgIGxldCByZWMgbG9vcCBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiBhY2NcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgbGV0JWJpbmQgYWNjID0gZiBpIGFjYyBoZCBpblxuICAgICAgICBsb29wIChpICsgMSkgYWNjIHRsXG4gICAgaW5cbiAgICBsb29wIDAgYWNjIGxpc3RcbiAgOztcblxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gZm9sZGkgdCB+aW5pdCB+ZjooZnVuIF8gYSB4IC0+IGYgYSB4KVxuXG4gIGxldCBzZXFtYXBpIHQgfmYgPVxuICAgIGZvbGRpIHQgfmluaXQ6W10gfmY6KGZ1biBpIGJzIGEgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBhIGluXG4gICAgICBiIDo6IGJzKVxuICAgID4+fCBMaXN0LnJldlxuICA7O1xuXG4gIGxldCBhbGwgPSBhbGxcbiAgbGV0IGFsbF91bml0ID0gYWxsX3VuaXRcblxuICBsZXQgaXRlcmkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbF91bml0IChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gICAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuICA7O1xuXG4gIGxldCBtYXBpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgICBhbGwgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgICB8IGBTZXF1ZW50aWFsIC0+IHNlcW1hcGkgdCB+ZlxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSA/aG93IHQgfmYgPSBtYXBpIHQgP2hvdyB+ZiA+PnwgTGlzdC5maWx0ZXJfb3B0XG4gIGxldCBjb25jYXRfbWFwaSA/aG93IHQgfmYgPSBtYXBpIHQgP2hvdyB+ZiA+PnwgTGlzdC5jb25jYXRcblxuICBsZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICAgIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIHggaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIHggZWxzZSBOb25lKVxuICA7O1xuXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9XG4gICAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiByZXR1cm4gTm9uZVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwaSB0bCB+ZiAoaSArIDEpXG4gICAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICAgIGluXG4gICAgZmluZF9tYXBpIHQgfmYgMFxuICA7O1xuXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuXG4gIGxldCBmaW5kaSB0IH5mID1cbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZiA9XG4gICAgZmluZF9tYXAgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKCkgLT4gdHJ1ZVxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKCkgLT4gZmFsc2VcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCBpdGVyID9ob3cgdCB+ZiA9IGl0ZXJpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBtYXAgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID0gY29uY2F0X21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGluaXQgP2hvdyBuIH5mID0gbWFwID9ob3cgKExpc3QuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuZW5kXG5cbmxldCByZWMgcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGYgPVxuICBtYXRjaCViaW5kIGYgc3RhdGUgd2l0aFxuICB8IGBSZXBlYXQgc3RhdGUgLT4gcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGZcbiAgfCBgRmluaXNoZWQgc3RhdGUgLT4gcmV0dXJuIHN0YXRlXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIExpc3QgPSBEZWZlcnJlZF9saXN0XG5cbigqIFdlIGltcGxlbWVudCBhbGwgb2YgdGhlIFtRdWV1ZV0gb3BlcmF0aW9ucyBieSBjb252ZXJ0aW5nIHRoZSBxdWV1ZSB0byBhIGxpc3QgYW5kIHRoZW5cbiAgIHVzaW5nIHRoZSBjb3JyZXNwb25kaW5nIFtMaXN0XSBvcGVyYXRpb24uICBXZSB1c2UgbGlzdHMgcmF0aGVyIHRoYW4gYXJyYXlzIGJlY2F1c2VcbiAgIGFycmF5cyBsb25nZXIgdGhhbiBhIGNlcnRhaW4gbGVuZ3RoIGFyZSBhbGxvY2F0ZWQgaW4gdGhlIG1ham9yIGhlYXAsIHdoaWNoIGNhbiBjYXVzZVxuICAgdW5uZWNlc3NhcnkgcHJvbW90aW9uIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgcXVldWUuICBBbHNvLCB3aGVuIG9uZSBpcyBmb2xkaW5nIG9yXG4gICBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSwgdGhlIGVudGlyZSBhcnJheSBtdXN0IGJlIGtlcHQgYWxpdmUuICBXaGVuIGZvbGRpbmcgb3JcbiAgIGl0ZXJhdGluZyBvdmVyIGEgbGlzdCwgb25seSB0aGUgcmVtYWluaW5nIHRhaWwgb2YgdGhlIGxpc3QgaXMga2VwdCBhbGl2ZS4gIFNvLCB1c2luZ1xuICAgYXJyYXlzIHJhdGhlciB0aGFuIGxpc3RzIHdvdWxkIGluY3JlYXNlIHRoZSBsaXZlLXNwYWNlIG5lZWRlZCBieSB0aGUgcHJvZ3JhbS4gKilcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPSBMaXN0LmZvbGRpIChRdWV1ZS50b19saXN0IHQpIH5pbml0IH5mXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gTGlzdC5mb2xkIChRdWV1ZS50b19saXN0IHQpIH5pbml0IH5mXG5sZXQgYWxsIHQgPSBMaXN0LmFsbCAoUXVldWUudG9fbGlzdCB0KSA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGFsbF91bml0IHQgPSBMaXN0LmFsbF91bml0IChRdWV1ZS50b19saXN0IHQpXG5sZXQgaXRlciA/aG93IHQgfmYgPSBMaXN0Lml0ZXIgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGl0ZXJpID9ob3cgdCB+ZiA9IExpc3QuaXRlcmkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IG1hcCA/aG93IHQgfmYgPSBMaXN0Lm1hcCA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgbWFwaSA/aG93IHQgfmYgPSBMaXN0Lm1hcGkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGluaXQgP2hvdyBuIH5mID0gTGlzdC5pbml0ID9ob3cgbiB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlciA/aG93IHQgfmYgPSBMaXN0LmZpbHRlciA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPSBMaXN0LmZpbHRlcmkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gTGlzdC5maWx0ZXJfbWFwID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXJfbWFwaSA/aG93IHQgfmYgPSBMaXN0LmZpbHRlcl9tYXBpID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcblxubGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID1cbiAgTGlzdC5jb25jYXRfbWFwID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmY6KGZ1biB4IC0+IGYgeCA+PnwgUXVldWUudG9fbGlzdClcbiAgPj58IFF1ZXVlLm9mX2xpc3Rcbjs7XG5cbmxldCBjb25jYXRfbWFwaSA/aG93IHQgfmYgPVxuICBMaXN0LmNvbmNhdF9tYXBpID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmY6KGZ1biBpIHggLT4gZiBpIHggPj58IFF1ZXVlLnRvX2xpc3QpXG4gID4+fCBRdWV1ZS5vZl9saXN0XG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9IExpc3QuZmluZF9tYXAgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kX21hcGkgdCB+ZiA9IExpc3QuZmluZF9tYXBpIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZmluZCB0IH5mID0gTGlzdC5maW5kIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZmluZGkgdCB+ZiA9IExpc3QuZmluZGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBMaXN0LmZvcl9hbGwgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmb3JfYWxsaSB0IH5mID0gTGlzdC5mb3JfYWxsaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGV4aXN0cyB0IH5mID0gTGlzdC5leGlzdHMgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBleGlzdHNpIHQgfmYgPSBMaXN0LmV4aXN0c2kgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG4oKiBbZm9sZF9tYXBpID9ob3cgdCB+aW5pdCB+bWFwaV9mIH5mb2xkX2ZdIGlzIGEgbW9yZSBlZmZpY2llbnQgdmVyc2lvbiBvZjpcblxuICAge1tcbiAgICAgZm9sZCB+aW5pdCB+ZjooZnVuIGIgYSAtPiByZXR1cm4gKGZvbGRfZiBiIGEpKSAobWFwaSB0ID9ob3cgfmY6bWFwaV9mKSBdfVxuXG4gICBJdCBhdm9pZHMgY3JlYXRpbmcgdGhlIGludGVybWVkaWF0ZSBzZXF1ZW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIFttYXBpXSwgYW5kXG4gICBhbGxvd3MgdGhlIFtmb2xkXSB0byBwcm9jZWVkIGNvbmN1cnJlbnRseSB3aXRoIHRoZSBbbWFwaV0sIHNvIHRoYXQgb25lIGNhbiBhY2N1bXVsYXRlXG4gICB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUsIHBvc3NpYmx5IGF2b2lkaW5nIGNyZWF0aW5nIGFuIGludGVybWVkaWF0ZSBzdHJ1Y3R1cmVcbiAgIChlLmcuIFtpdGVyaV0gYW5kIFtmaWx0ZXJfbWFwXSB1c2VzIFtmb2xkX21hcGldIHRvIGRvIHRoaXMpLiAqKVxubGV0IGZvbGRfbWFwaVxuICAgICAgKHR5cGUgYSBiIGMpXG4gICAgICA/KGhvdyA9IGBTZXF1ZW50aWFsKVxuICAgICAgKHQgOiBhIFNlcXVlbmNlLnQpXG4gICAgICB+KGluaXQgOiBjKVxuICAgICAgfihtYXBpX2YgOiBpbnQgLT4gYSAtPiBiIERlZmVycmVkLnQpXG4gICAgICB+KGZvbGRfZiA6IGMgLT4gYiAtPiBjKVxuICA6IGMgRGVmZXJyZWQudFxuICA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYFNlcXVlbnRpYWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgaSB0IChjIDogYykgPVxuICAgICAgbWF0Y2ggU2VxdWVuY2UubmV4dCB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiByZXR1cm4gY1xuICAgICAgfCBTb21lIChhLCB0KSAtPlxuICAgICAgICBsZXQlYmluZCBiID0gbWFwaV9mIGkgYSBpblxuICAgICAgICBsb29wIChpICsgMSkgdCAoZm9sZF9mIGMgYilcbiAgICBpblxuICAgIGxvb3AgMCB0IGluaXRcbiAgfCBgUGFyYWxsZWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgaSB0IChjIDogYyBEZWZlcnJlZC50KSA9XG4gICAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IGNcbiAgICAgIHwgU29tZSAoYSwgdCkgLT5cbiAgICAgICAgbG9vcFxuICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICB0XG4gICAgICAgICAgKGxldCViaW5kIGIgPSBtYXBpX2YgaSBhIGluXG4gICAgICAgICAgIGxldCVtYXAgYyA9IGMgaW5cbiAgICAgICAgICAgZm9sZF9mIGMgYilcbiAgICBpblxuICAgIGxvb3AgMCB0IChyZXR1cm4gaW5pdClcbiAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBtYXhfY29uY3VycmVudF9qb2JzIC0+XG4gICAgbGV0IHRocm90dGxlID0gVGhyb3R0bGUuY3JlYXRlIH5tYXhfY29uY3VycmVudF9qb2JzIH5jb250aW51ZV9vbl9lcnJvcjpmYWxzZSBpblxuICAgICgqIFtsb29wXSBmb3JjZXMgdGhlIGlucHV0IHNlcXVlbmNlIGFuZCBlbnF1ZXVlcyBhIHRocm90dGxlIGpvYiBvbmx5IGlmIHRoZXJlIGlzXG4gICAgICAgY2FwYWNpdHkgYXZhaWxhYmxlLiAqKVxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjIERlZmVycmVkLnQpID1cbiAgICAgIGxldCViaW5kICgpID0gVGhyb3R0bGUuY2FwYWNpdHlfYXZhaWxhYmxlIHRocm90dGxlIGluXG4gICAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IGNcbiAgICAgIHwgU29tZSAoYSwgdCkgLT5cbiAgICAgICAgbG9vcFxuICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICB0XG4gICAgICAgICAgKGxldCViaW5kIGIgPSBUaHJvdHRsZS5lbnF1ZXVlIHRocm90dGxlIChmdW4gKCkgLT4gbWFwaV9mIGkgYSkgaW5cbiAgICAgICAgICAgbGV0JW1hcCBjID0gYyBpblxuICAgICAgICAgICBmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHQgKHJldHVybiBpbml0KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBTZXF1ZW5jZS5kZWxheWVkX2ZvbGRcbiAgICB0XG4gICAgfmluaXQ6KDAsIGluaXQpXG4gICAgfmY6KGZ1biAoaSwgYikgYSB+ayAtPlxuICAgICAgbGV0JWJpbmQgYiA9IGYgaSBiIGEgaW5cbiAgICAgIGsgKGkgKyAxLCBiKSlcbiAgICB+ZmluaXNoOihmdW4gKF8sIGIpIC0+IHJldHVybiBiKVxuOztcblxuKCogW2ZvbGRdIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBbZm9sZGldIHRvIHNhdmUgdGhlIGludGVybWVkaWF0ZSBjbG9zdXJlXG4gICBhbGxvY2F0aW9uLiAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIFNlcXVlbmNlLmRlbGF5ZWRfZm9sZCB0IH5pbml0IH5mOihmdW4gYiBhIH5rIC0+IGYgYiBhID4+PSBrKSB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGFsbCB0ID1cbiAgbGV0JW1hcCByZXMgPVxuICAgIGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjY3VtIGQgLT5cbiAgICAgIGxldCVtYXAgYSA9IGQgaW5cbiAgICAgIGEgOjogYWNjdW0pXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IHJlcylcbjs7XG5cbmxldCBhbGxfdW5pdCB0ID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgdiAtPiB2KVxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJldHVybiBOb25lXG4gICAgfCBTb21lICh2LCByZXN0KSAtPlxuICAgICAgKG1hdGNoJWJpbmQgZiBpIHYgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgcmVzdCB+ZiAoaSArIDEpXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiByZXR1cm4gc29tZSlcbiAgaW5cbiAgZmluZF9tYXBpIHQgfmYgMFxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIF8gZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBlbHQgZWxzZSBOb25lKVxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgbm90IGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gZmFsc2VcbiAgfCBOb25lIC0+IHRydWVcbjs7XG5cbmxldCBpdGVyaSA/aG93IHQgfmYgOiB1bml0IERlZmVycmVkLnQgPVxuICBmb2xkX21hcGkgP2hvdyB0IH5tYXBpX2Y6ZiB+aW5pdDooKSB+Zm9sZF9mOihmdW4gKCkgKCkgLT4gKCkpXG47O1xuXG5sZXQgbWFwaSA/aG93IHQgfmYgPVxuICBsZXQlbWFwIGJzID1cbiAgICBmb2xkX21hcGkgP2hvdyB0IH5tYXBpX2Y6KGZ1biBpIGEgLT4gZiBpIGEpIH5pbml0OltdIH5mb2xkX2Y6KGZ1biBicyBiIC0+IGIgOjogYnMpXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IGJzKVxuOztcblxuKCogW2ZpbHRlcl9tYXBpXSBpcyBpbXBsZW1lbnRlZCB1c2luZyBbZm9sZF9tYXBpXSByYXRoZXIgdGhhbiBbbWFwXSBzbyB0aGF0IHdlIG5ldmVyIG5lZWRcbiAgIHRvIGtlZXAgYSBsb25nIHN0cmVhbSBvZiBpbnRlcm1lZGlhdGUgW05vbmVdIHJlc3VsdHMgaW4gdGhlIGFjY3VtdWxhdG9yLCBvbmx5IHRvIGxhdGVyXG4gICBmaWx0ZXIgdGhlbSBhbGwgb3V0LiAqKVxubGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPVxuICAgIGZvbGRfbWFwaVxuICAgICAgdFxuICAgICAgP2hvd1xuICAgICAgfm1hcGlfZjooZnVuIGkgYSAtPiBmIGkgYSlcbiAgICAgIH5pbml0OltdXG4gICAgICB+Zm9sZF9mOihmdW4gYnMgbWF5YmVfdiAtPlxuICAgICAgICBtYXRjaCBtYXliZV92IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGJzXG4gICAgICAgIHwgU29tZSBiIC0+IGIgOjogYnMpXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IGJzKVxuOztcblxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgP2hvdyB0IH5mID4+fCBTZXF1ZW5jZS5jb25jYXRcblxubGV0IGZpbHRlcmkgP2hvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2glbWFwIGYgaSBhIHdpdGhcbiAgICB8IHRydWUgLT4gU29tZSBhXG4gICAgfCBmYWxzZSAtPiBOb25lKVxuOztcblxubGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlciA/aG93IHQgfmYgPSBmaWx0ZXJpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID0gY29uY2F0X21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0ID9ob3cgbiB+ZiA9IG1hcCA/aG93IChTZXF1ZW5jZS5pbml0IG4gfmY6Rm4uaWQpIH5mXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBDbG9ja19ucyA9IENsb2NrX25zXG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNcbm1vZHVsZSBUaW1lID0gVGltZVxubW9kdWxlIEFzeW5jX2tlcm5lbF9zY2hlZHVsZXIgPSBBc3luY19rZXJuZWxfc2NoZWR1bGVyXG5tb2R1bGUgRGF0ZSA9IERhdGVcblxubGV0IGFmdGVyID0gQ2xvY2tfbnMuYWZ0ZXJcbmxldCBhdCA9IENsb2NrX25zLmF0XG5sZXQgZXZlcnkgPSBDbG9ja19ucy5ldmVyeVxubGV0IHdpdGhfdGltZW91dCA9IENsb2NrX25zLndpdGhfdGltZW91dFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cblxubGV0IHNob3dfZGVidWdfbWVzc2FnZXMgPSByZWYgZmFsc2VcbmxldCBjaGVja19pbnZhcmlhbnQgPSByZWYgZmFsc2VcblxubW9kdWxlIEZsdXNoZWRfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgT2tcbiAgICB8IGBSZWFkZXJfY2xvc2VkXG4gICAgXVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCBlcXVhbCA9IFslY29tcGFyZS5lcXVhbDogdF1cblxuICBsZXQgY29tYmluZSAobCA6IHQgRGVmZXJyZWQudCBsaXN0KSA9XG4gICAgbGV0JW1hcCBsID0gRGVmZXJyZWQuYWxsIGwgaW5cbiAgICBtYXRjaCBMaXN0Lm1lbSBsIGBSZWFkZXJfY2xvc2VkIH5lcXVhbCB3aXRoXG4gICAgfCB0cnVlIC0+IGBSZWFkZXJfY2xvc2VkXG4gICAgfCBmYWxzZSAtPiBgT2tcbiAgOztcbmVuZFxuXG4oKiBBIFtDb25zdW1lci50XSBhY3RzIGFzIHRoZSBtb25pdG9yIG9mIHNvbWUgcHJvY2VzcyB0aGF0IHJlYWRzIHZhbHVlcyBmcm9tIGEgcGlwZSBhbmRcbiAgIHByb2Nlc3NlcyB0aGVtLCBhbGxvd2luZyB0aGF0IHByb2Nlc3M6XG4gICAtIHRvIGNvbW11bmljYXRlIHRoYXQgaXQgaGFzIHRha2VuIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdmFsdWVzXG4gICAtIHRvIHNpZ25hbCB3aGVuIGl0IGhhcyBmaW5pc2hlZCB3aXRoIHRoZSB2YWx1ZXMgdG8gaW50ZXJlc3RlZCBwYXJ0aWVzICh2aWFcbiAgICAgW2Rvd25zdHJlYW1fZmx1c2hlZF0pXG5cbiAgIEl0IGlzIHVzZWQgaW4gdHdvIHN0ZXBzOlxuXG4gICAxLiBjYWxsaW5nIFtDb25zdW1lci5zdGFydF0gYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBjb25zdW1lciB0YWtlcyB2YWx1ZXMgb3V0IG9mIHRoZVxuICAgUGlwZSB2aWEgW3JlYWRdIG9yIFtyZWFkJ10uXG5cbiAgIDIuIGNhbGxpbmcgW0NvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW1dLlxuXG4gICBCeSBjYWxsaW5nIFt2YWx1ZXNfc2VudF9kb3duc3RyZWFtXSBvbmUgYXNzZXJ0cyB0aGF0IHRoZSBbZG93bnN0cmVhbV9mbHVzaGVkXSBmdW5jdGlvblxuICAgc3VwcGxpZWQgdG8gW2NyZWF0ZV0gd2lsbCBub3cgd2FpdCBmb3IgdGhpcyB2YWx1ZS5cblxuICAgSWYgbm8gW0NvbnN1bWVyLnRdIGlzIHN1cHBsaWVkIHdoZW4gYSB2YWx1ZSBpcyByZWFkIHRoZW4gdGhlIHZhbHVlIGlzIGRlZmluZWQgdG8gYmVcbiAgIGZsdXNoZWQgYXQgdGhhdCB0aW1lLiAqKVxubW9kdWxlIENvbnN1bWVyIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBjcmVhdGVcbiAgICA6ICBwaXBlX2lkOmludFxuICAgIC0+IGRvd25zdHJlYW1fZmx1c2hlZDoodW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnQpXG4gICAgLT4gdFxuXG4gIHZhbCBwaXBlX2lkIDogdCAtPiBpbnRcbiAgdmFsIHN0YXJ0IDogdCAtPiB1bml0XG4gIHZhbCB2YWx1ZXNfc2VudF9kb3duc3RyZWFtIDogdCAtPiB1bml0XG4gIHZhbCB2YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIDogdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcGlwZV9pZCA6IGludFxuICAgIDsgKCogW3ZhbHVlc19yZWFkXSByZWZsZWN0cyB3aGV0aGVyIHZhbHVlcyB0aGUgY29uc3VtZXIgaGFzIHJlYWQgZnJvbSB0aGUgcGlwZSBoYXZlIGJlZW5cbiAgICAgICAgIHNlbnQgZG93bnN0cmVhbSBvciBpZiBub3QsIGhvbGRzIGFuIGl2YXIgdGhhdCBpcyB0byBiZSBmaWxsZWQgd2hlbiB0aGV5IGFyZS4gKilcbiAgICAgIG11dGFibGUgdmFsdWVzX3JlYWQgOlxuICAgICAgICBbIGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIG9mIHVuaXQgSXZhci50IF1cbiAgICA7ICgqIFtkb3duc3RyZWFtX2ZsdXNoZWQgKCldIHJldHVybnMgd2hlbiBhbGwgcHJpb3IgdmFsdWVzIHRoYXQgdGhlIGNvbnN1bWVyIGhhc1xuICAgICAgICAgcGFzc2VkIGRvd25zdHJlYW0gaGF2ZSBiZWVuIGZsdXNoZWQgYWxsIHRoZSB3YXkgZG93biB0aGUgY2hhaW4gb2YgcGlwZXMuICopXG4gICAgICBkb3duc3RyZWFtX2ZsdXNoZWQgOiB1bml0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5waXBlX2lkOmlnbm9yZVxuICAgICAgICB+dmFsdWVzX3JlYWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT4gKClcbiAgICAgICAgICAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBpdmFyIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKSkpXG4gICAgICAgIH5kb3duc3RyZWFtX2ZsdXNoZWQ6aWdub3JlXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5Db25zdW1lci5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiB0KV1cbiAgOztcblxuICBsZXQgY3JlYXRlIH5waXBlX2lkIH5kb3duc3RyZWFtX2ZsdXNoZWQgPVxuICAgIHsgcGlwZV9pZDsgdmFsdWVzX3JlYWQgPSBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbTsgZG93bnN0cmVhbV9mbHVzaGVkIH1cbiAgOztcblxuICBsZXQgc3RhcnQgdCA9XG4gICAgbWF0Y2ggdC52YWx1ZXNfcmVhZCB3aXRoXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gXyAtPiAoKVxuICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT5cbiAgICAgIHQudmFsdWVzX3JlYWQgPC0gYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIChJdmFyLmNyZWF0ZSAoKSlcbiAgOztcblxuICBsZXQgdmFsdWVzX3NlbnRfZG93bnN0cmVhbSB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+ICgpXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gaXZhciAtPlxuICAgICAgSXZhci5maWxsIGl2YXIgKCk7XG4gICAgICB0LnZhbHVlc19yZWFkIDwtIGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtXG4gIDs7XG5cbiAgbGV0IHZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgdCA9XG4gICAgbWF0Y2ggdC52YWx1ZXNfcmVhZCB3aXRoXG4gICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPiB0LmRvd25zdHJlYW1fZmx1c2hlZCAoKVxuICAgIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIHdoZW5fc2VudF9kb3duc3RyZWFtIC0+XG4gICAgICBsZXQlYmluZCAoKSA9IEl2YXIucmVhZCB3aGVuX3NlbnRfZG93bnN0cmVhbSBpblxuICAgICAgdC5kb3duc3RyZWFtX2ZsdXNoZWQgKClcbiAgOztcbmVuZFxuXG5tb2R1bGUgQmxvY2tlZF9yZWFkID0gc3RydWN0XG4gICgqIEEgW0Jsb2NrZWRfcmVhZC50XSByZXByZXNlbnRzIGEgYmxvY2tlZCByZWFkIGF0dGVtcHQuICBJZiBzb21lb25lIHJlYWRzIGZyb20gYW4gZW1wdHlcbiAgICAgcGlwZSwgdGhleSBlbnF1ZXVlIGEgW0Jsb2NrZWRfcmVhZC50XSBpbiB0aGUgcXVldWUgb2YgW2Jsb2NrZWRfcmVhZHNdLiAgTGF0ZXIsIHdoZW5cbiAgICAgdmFsdWVzIGFyZSB3cml0dGVuIHRvIGEgcGlwZSwgdGhhdCB3aWxsIGNhdXNlIHNvbWUgbnVtYmVyIG9mIGJsb2NrZWQgcmVhZHMgdG8gYmVcbiAgICAgZmlsbGVkLCBmaXJzdCBjb21lIGZpcnN0IHNlcnZlLiAgVGhlIGJsb2NrZWQtcmVhZCBjb25zdHJ1Y3RvciBzcGVjaWZpZXMgaG93IG1hbnlcbiAgICAgdmFsdWVzIGEgcmVhZCBzaG91bGQgY29uc3VtZSBmcm9tIHRoZSBwaXBlIHdoZW4gaXQgZ2V0cyBpdHMgdHVybi5cblxuICAgICBJZiBhIHBpcGUgaXMgY2xvc2VkLCB0aGVuIGFsbCBibG9ja2VkIHJlYWRzIHdpbGwgYmUgZmlsbGVkIHdpdGggW2BFb2ZdLiAqKVxuICB0eXBlICdhIHdhbnRzID1cbiAgICB8IFplcm8gb2YgWyBgRW9mIHwgYE9rIF0gSXZhci50XG4gICAgfCBPbmUgb2YgWyBgRW9mIHwgYE9rIG9mICdhIF0gSXZhci50XG4gICAgfCBBdF9tb3N0IG9mIGludCAqIFsgYEVvZiB8IGBPayBvZiAnYSBRdWV1ZS50IF0gSXZhci50XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IHdhbnRzIDogJ2Egd2FudHNcbiAgICA7IGNvbnN1bWVyIDogQ29uc3VtZXIudCBvcHRpb25cbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgICB0cnlcbiAgICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+d2FudHM6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgIHwgWmVybyBfIHwgT25lIF8gLT4gKClcbiAgICAgICAgICAgICB8IEF0X21vc3QgKGksIF8pIC0+IGFzc2VydCAoaSA+IDApKSlcbiAgICAgICAgfmNvbnN1bWVyOlxuICAgICAgICAgIChjaGVjayAoZnVuY3Rpb25cbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgY29uc3VtZXIgLT4gQ29uc3VtZXIuaW52YXJpYW50IGNvbnN1bWVyKSlcbiAgICB3aXRoXG4gICAgfCBleG4gLT5cbiAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5CbG9ja2VkX3JlYWQuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5waXBlOih0IDogXyB0KV1cbiAgOztcblxuICBsZXQgY3JlYXRlIHdhbnRzIGNvbnN1bWVyID0geyB3YW50czsgY29uc3VtZXIgfVxuXG4gIGxldCBpc19lbXB0eSB0ID1cbiAgICBtYXRjaCB0LndhbnRzIHdpdGhcbiAgICB8IFplcm8gaSAtPiBJdmFyLmlzX2VtcHR5IGlcbiAgICB8IE9uZSBpIC0+IEl2YXIuaXNfZW1wdHkgaVxuICAgIHwgQXRfbW9zdCAoXywgaSkgLT4gSXZhci5pc19lbXB0eSBpXG4gIDs7XG5cbiAgbGV0IGZpbGxfd2l0aF9lb2YgdCA9XG4gICAgbWF0Y2ggdC53YW50cyB3aXRoXG4gICAgfCBaZXJvIGkgLT4gSXZhci5maWxsIGkgYEVvZlxuICAgIHwgT25lIGkgLT4gSXZhci5maWxsIGkgYEVvZlxuICAgIHwgQXRfbW9zdCAoXywgaSkgLT4gSXZhci5maWxsIGkgYEVvZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBCbG9ja2VkX2ZsdXNoID0gc3RydWN0XG4gICgqIEEgW0Jsb2NrZWRfZmx1c2gudF0gcmVwcmVzZW50cyBhIGJsb2NrZWQgZmx1c2ggb3BlcmF0aW9uLCB3aGljaCBjYW4gYmUgZW5hYmxlZCBieSBhXG4gICAgIGZ1dHVyZSByZWFkLiAgSWYgc29tZW9uZSBkb2VzIFtmbHVzaGVkIHBdIG9uIGEgcGlwZSwgdGhhdCBibG9ja3MgdW50aWwgZXZlcnl0aGluZ1xuICAgICB0aGF0J3MgY3VycmVudGx5IGluIHRoZSBwaXBlIGF0IHRoYXQgcG9pbnQgaGFzIGRyYWluZWQgb3V0IG9mIHRoZSBwaXBlLiAgV2hlbiB3ZSBjYWxsXG4gICAgIFtmbHVzaGVkXSwgaXQgcmVjb3JkcyB0aGUgdG90YWwgYW1vdW50IG9mIGRhdGEgdGhhdCBoYXMgYmVlbiB3cml0dGVuIHNvIGZhciBpblxuICAgICBbZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZF0uICBXZSBmaWxsIHRoZSBbRmx1c2gudF0gd2l0aCBbYE9rXSB3aGVuIHRoaXMgYW1vdW50IG9mXG4gICAgIGRhdGEgaGFzIGJlZW4gcmVhZCBmcm9tIHRoZSBwaXBlLlxuXG4gICAgIEEgW0Jsb2NrZWRfZmx1c2gudF0gY2FuIGFsc28gYmUgZmlsbGVkIHdpdGggW2BSZWFkZXJfY2xvc2VkXSwgd2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICByZWFkZXIgZW5kIG9mIHRoZSBwaXBlIGlzIGNsb3NlZCwgYW5kIHdlIGFyZSB0aHVzIHN1cmUgdGhhdCB0aGUgdW5yZWFkIGVsZW1lbnRzXG4gICAgIHByZWNlZGluZyB0aGUgZmx1c2ggd2lsbCBuZXZlciBiZSByZWFkLiAqKVxuICB0eXBlIHQgPVxuICAgIHsgZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZCA6IGludFxuICAgIDsgcmVhZHkgOiBbIGBPayB8IGBSZWFkZXJfY2xvc2VkIF0gSXZhci50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgbGV0IGZpbGwgdCB2ID0gSXZhci5maWxsIHQucmVhZHkgdlxuZW5kXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgdCA9XG4gIHsgKCogW2lkXSBpcyBhbiBpbnRlZ2VyIHVzZWQgdG8gZGlzdGluZ3Vpc2ggcGlwZXMgd2hlbiBkZWJ1Z2dpbmcuICopXG4gICAgaWQgOiBpbnQgU2V4cF9oaWRkZW5faW5fdGVzdC50XG4gIDsgKCogW2luZm9dIGlzIHVzZXItcHJvdmlkZWQgYXJiaXRyYXJ5IHNleHAsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuICopXG4gICAgbXV0YWJsZSBpbmZvIDogU2V4cC50IG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICA7ICgqIFtidWZmZXJdIGhvbGRzIHZhbHVlcyB3cml0dGVuIHRvIHRoZSBwaXBlIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gcmVhZC4gKilcbiAgICBtdXRhYmxlIGJ1ZmZlciA6ICdhIFF1ZXVlLnRcbiAgOyAoKiBbc2l6ZV9idWRnZXRdIGdvdmVybnMgcHVzaGJhY2sgb24gd3JpdGVycyB0byB0aGUgcGlwZS5cblxuICAgICAgIFRoZXJlIGlzICpubyogaW52YXJpYW50IHRoYXQgW1F1ZXVlLmxlbmd0aCBidWZmZXIgPD0gc2l6ZV9idWRnZXRdLiAgVGhlcmUgaXMgbm9cbiAgICAgICBoYXJkIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBjYW4gYmUgc3R1ZmZlZCBpbnRvIHRoZSBbYnVmZmVyXS5cbiAgICAgICBUaGlzIGlzIGR1ZSB0byB0aGUgd2F5IHdlIGhhbmRsZSB3cml0ZXMuICBXaGVuIHdlIGRvIGEgd3JpdGUsIGFsbCBvZiB0aGUgdmFsdWVzXG4gICAgICAgd3JpdHRlbiBhcmUgaW1tZWRpYXRlbHkgZW5xdWV1ZWQgaW50byBbYnVmZmVyXS4gIEFmdGVyIHRoZSB3cml0ZSwgaWYgW1F1ZXVlLmxlbmd0aFxuICAgICAgIGJ1ZmZlciA8PSB0LnNpemVfYnVkZ2V0XSwgdGhlbiB0aGUgd3JpdGVyIHdpbGwgYmUgbm90aWZpZWQgdG8gY29udGludWUgd3JpdGluZy5cbiAgICAgICBBZnRlciB0aGUgd3JpdGUsIGlmIFtsZW5ndGggdCA+IHQuc2l6ZV9idWRnZXRdLCB0aGVuIHRoZSB3cml0ZSB3aWxsIGJsb2NrIHVudGlsIHRoZVxuICAgICAgIHBpcGUgaXMgdW5kZXIgYnVkZ2V0LiAqKVxuICAgIG11dGFibGUgc2l6ZV9idWRnZXQgOiBpbnRcbiAgOyAoKiBbcHVzaGJhY2tdIGlzIHVzZWQgdG8gZ2l2ZSBmZWVkYmFjayB0byB3cml0ZXJzIGFib3V0IHdoZXRoZXIgdGhleSBzaG91bGQgd3JpdGUgdG9cbiAgICAgICB0aGUgcGlwZS4gIFtwdXNoYmFja10gaXMgZnVsbCBpZmYgW2xlbmd0aCB0IDw9IHQuc2l6ZV9idWRnZXQgfHwgaXNfY2xvc2VkIHRdLiAqKVxuICAgIG11dGFibGUgcHVzaGJhY2sgOiB1bml0IEl2YXIudFxuICA7ICgqIFtudW1fdmFsdWVzX3JlYWRdIGtlZXBzIHRyYWNrIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIHJlYWRcbiAgICAgICBmcm9tIHRoZSBwaXBlLiAgV2UgZG8gbm90IGhhdmUgdG8gd29ycnkgYWJvdXQgb3ZlcmZsb3cgaW4gW251bV92YWx1ZXNfcmVhZF0uICBZb3UnZFxuICAgICAgIG5lZWQgdG8gd3JpdGUgMl42MiBlbGVtZW50cyB0byB0aGUgcGlwZSwgd2hpY2ggd291bGQgdGFrZSBhYm91dCAxNDYgeWVhcnMsIGF0IGFcbiAgICAgICBmbG93IHJhdGUgb2YgMSBzaXplLXVuaXQvbmFub3NlY29uZC4gKilcbiAgICBtdXRhYmxlIG51bV92YWx1ZXNfcmVhZCA6IGludFxuICA7ICgqIFtibG9ja2VkX2ZsdXNoZXNdIGhvbGRzIGZsdXNoZXMgd2hvc2UgcHJlY2VkaW5nIGVsZW1lbnRzIGhhdmUgbm90IGJlZW4gY29tcGxldGVseVxuICAgICAgIHJlYWQuICBGb3IgZWFjaCBibG9ja2VkIGZsdXNoLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZSByZWFkIGZyb20gdGhlXG4gICAgICAgcGlwZSBpbiBvcmRlciB0byBmaWxsIHRoZSBmbHVzaCBpcyAgICAgICAgICAgICAgICAgICAgICAgIDpcblxuICAgICAgIGZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgLSBudW1fdmFsdWVzX3JlYWRcblxuICAgICAgIEtlZXBpbmcgdGhlIGRhdGEgaW4gdGhpcyBmb3JtIGFsbG93cyB1cyB0byBjaGFuZ2UgYSBzaW5nbGUgZmllbGQobnVtX3ZhbHVlc19yZWFkKVxuICAgICAgIHdoZW4gd2UgY29uc3VtZSB2YWx1ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gaXRlcmF0ZSBvdmVyIHRoZSB3aG9sZSBxdWV1ZSBvZlxuICAgICAgIGZsdXNoZXMuICopXG4gICAgYmxvY2tlZF9mbHVzaGVzIDogQmxvY2tlZF9mbHVzaC50IFF1ZXVlLnRcbiAgOyAoKiBbYmxvY2tlZF9yZWFkc10gaG9sZHMgcmVhZHMgdGhhdCBhcmUgd2FpdGluZyBvbiBkYXRhIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIHBpcGUuICopXG4gICAgYmxvY2tlZF9yZWFkcyA6ICdhIEJsb2NrZWRfcmVhZC50IFF1ZXVlLnRcbiAgOyAoKiBbY2xvc2VkXSBpcyBmaWxsZWQgd2hlbiB3ZSBjbG9zZSB0aGUgd3JpdGUgZW5kIG9mIHRoZSBwaXBlLiAqKVxuICAgIGNsb3NlZCA6IHVuaXQgSXZhci50XG4gIDsgKCogW3JlYWRfY2xvc2VkXSBpcyBmaWxsZWQgd2hlbiB3ZSBjbG9zZSB0aGUgcmVhZCBlbmQgb2YgdGhlIHBpcGUuICopXG4gICAgcmVhZF9jbG9zZWQgOiB1bml0IEl2YXIudFxuICA7ICgqIFtjb25zdW1lcnNdIGlzIGEgbGlzdCBvZiBhbGwgY29uc3VtZXJzIHRoYXQgbWF5IGJlIGhhbmRsaW5nIHZhbHVlcyByZWFkIGZyb20gdGhlXG4gICAgICAgcGlwZS4gKilcbiAgICBtdXRhYmxlIGNvbnN1bWVycyA6IENvbnN1bWVyLnQgbGlzdFxuICA7ICgqIFt1cHN0cmVhbV9mbHVzaGVkc10gaGFzIGEgZnVuY3Rpb24gZm9yIGVhY2ggcGlwZSBpbW1lZGlhdGVseSB1cHN0cmVhbSBvZiB0aGlzIG9uZS5cbiAgICAgICBUaGF0IGZ1bmN0aW9uIHdhbGtzIHRvIHRoZSBoZWFkKHMpIG9mIHRoZSB1cHN0cmVhbSBwaXBlLCBhbmQgY2FsbHNcbiAgICAgICBbZG93bnN0cmVhbV9mbHVzaGVkXSBvbiB0aGUgaGVhZChzKS4gIFNlZSB0aGUgZGVmaW5pdGlvbiBvZiBbdXBzdHJlYW1fZmx1c2hlZF1cbiAgICAgICBiZWxvdy4gKilcbiAgICB1cHN0cmVhbV9mbHVzaGVkcyA6ICh1bml0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudCkgQmFnLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG50eXBlICgnYSwgJ3BoYW50b20pIHBpcGUgPSAoJ2EsICdwaGFudG9tKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBoYXNoIHQgPSBIYXNodGJsLmhhc2ggdC5pZFxubGV0IGVxdWFsICh0MSA6IChfLCBfKSB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBjb21wYXJlIHQxIHQyID0gSW50LmNvbXBhcmUgdDEuaWQgdDIuaWRcbmxldCBpc19jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LmNsb3NlZFxubGV0IGlzX3JlYWRfY2xvc2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5yZWFkX2Nsb3NlZFxubGV0IGNsb3NlZCB0ID0gSXZhci5yZWFkIHQuY2xvc2VkXG5sZXQgcHVzaGJhY2sgdCA9IEl2YXIucmVhZCB0LnB1c2hiYWNrXG5sZXQgbGVuZ3RoIHQgPSBRdWV1ZS5sZW5ndGggdC5idWZmZXJcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aWQ6aWdub3JlXG4gICAgICB+aW5mbzppZ25vcmVcbiAgICAgIH5idWZmZXI6aWdub3JlXG4gICAgICB+c2l6ZV9idWRnZXQ6KGNoZWNrIChmdW4gc2l6ZV9idWRnZXQgLT4gYXNzZXJ0IChzaXplX2J1ZGdldCA+PSAwKSkpXG4gICAgICB+cHVzaGJhY2s6XG4gICAgICAgIChjaGVjayAoZnVuIHB1c2hiYWNrIC0+XG4gICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgQm9vbC5lcXVhbFxuICAgICAgICAgICAgICAgKEl2YXIuaXNfZnVsbCBwdXNoYmFjaylcbiAgICAgICAgICAgICAgIChsZW5ndGggdCA8PSB0LnNpemVfYnVkZ2V0IHx8IGlzX2Nsb3NlZCB0KSkpKVxuICAgICAgfm51bV92YWx1ZXNfcmVhZDppZ25vcmVcbiAgICAgIH5ibG9ja2VkX2ZsdXNoZXM6XG4gICAgICAgIChjaGVjayAoZnVuIGJsb2NrZWRfZmx1c2hlcyAtPlxuICAgICAgICAgICBRdWV1ZS5pdGVyIGJsb2NrZWRfZmx1c2hlcyB+ZjooZnVuIChmIDogQmxvY2tlZF9mbHVzaC50KSAtPlxuICAgICAgICAgICAgIGFzc2VydCAoZi5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkID4gdC5udW1fdmFsdWVzX3JlYWQpKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBMaXN0LmlzX3NvcnRlZFxuICAgICAgICAgICAgICAgfmNvbXBhcmU6SW50LmNvbXBhcmVcbiAgICAgICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAgICAgKFF1ZXVlLnRvX2xpc3QgYmxvY2tlZF9mbHVzaGVzKVxuICAgICAgICAgICAgICAgICAgfmY6QmxvY2tlZF9mbHVzaC5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkKSk7XG4gICAgICAgICAgIGlmIGlzX2VtcHR5IHQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGJsb2NrZWRfZmx1c2hlcykpKVxuICAgICAgfmJsb2NrZWRfcmVhZHM6XG4gICAgICAgIChjaGVjayAoZnVuIGJsb2NrZWRfcmVhZHMgLT5cbiAgICAgICAgICAgKCogSWYgZGF0YSBpcyBhdmFpbGFibGUsIG5vIG9uZSBpcyB3YWl0aW5nIGZvciBpdC4gIFRoaXMgd291bGQgbmVlZCB0byBjaGFuZ2UgaWZcbiAgICAgICAgICAgICAgd2UgZXZlciBpbXBsZW1lbnQgW3JlYWRfZXhhY3RseV0gYXMgYW4gYXRvbWljIG9wZXJhdGlvbi4gKilcbiAgICAgICAgICAgaWYgbm90IChpc19lbXB0eSB0KSB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9yZWFkcyk7XG4gICAgICAgICAgIFF1ZXVlLml0ZXIgYmxvY2tlZF9yZWFkcyB+ZjooZnVuIHJlYWQgLT5cbiAgICAgICAgICAgICBCbG9ja2VkX3JlYWQuaW52YXJpYW50IHJlYWQ7XG4gICAgICAgICAgICAgYXNzZXJ0IChCbG9ja2VkX3JlYWQuaXNfZW1wdHkgcmVhZCkpO1xuICAgICAgICAgICAoKiBZb3UgbmV2ZXIgYmxvY2sgdHJ5aW5nIHRvIHJlYWQgYSBjbG9zZWQgcGlwZS4gKilcbiAgICAgICAgICAgaWYgaXNfY2xvc2VkIHQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGJsb2NrZWRfcmVhZHMpKSlcbiAgICAgIH5jbG9zZWQ6aWdub3JlXG4gICAgICB+cmVhZF9jbG9zZWQ6aWdub3JlXG4gICAgICB+Y29uc3VtZXJzOlxuICAgICAgICAoY2hlY2sgKGZ1biBsIC0+XG4gICAgICAgICAgIExpc3QuaXRlciBsIH5mOihmdW4gY29uc3VtZXIgLT5cbiAgICAgICAgICAgICBDb25zdW1lci5pbnZhcmlhbnQgY29uc3VtZXI7XG4gICAgICAgICAgICAgYXNzZXJ0IChDb25zdW1lci5waXBlX2lkIGNvbnN1bWVyID0gdC5pZCkpKSlcbiAgICAgIH51cHN0cmVhbV9mbHVzaGVkczppZ25vcmVcbiAgd2l0aFxuICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlBpcGUuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pIH5waXBlOih0IDogKF8sIF8pIHQpXVxuOztcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICB0eXBlIHBoYW50b20gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0ID0gKCdhLCBwaGFudG9tKSBwaXBlIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuZW5kXG5cbm1vZHVsZSBXcml0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSBwaGFudG9tIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgJ2EgdCA9ICgnYSwgcGhhbnRvbSkgcGlwZSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbmVuZFxuXG5sZXQgaWRfcmVmID0gcmVmIDBcblxubGV0IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQgfmluZm8gfmluaXRpYWxfYnVmZmVyID1cbiAgaW5jciBpZF9yZWY7XG4gIGxldCB0ID1cbiAgICB7IGlkID0gIWlkX3JlZlxuICAgIDsgaW5mb1xuICAgIDsgY2xvc2VkID0gSXZhci5jcmVhdGUgKClcbiAgICA7IHJlYWRfY2xvc2VkID0gSXZhci5jcmVhdGUgKClcbiAgICA7XG4gICAgICBzaXplX2J1ZGdldFxuICAgIDsgcHVzaGJhY2sgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgYnVmZmVyID0gaW5pdGlhbF9idWZmZXJcbiAgICA7IG51bV92YWx1ZXNfcmVhZCA9IDBcbiAgICA7IGJsb2NrZWRfZmx1c2hlcyA9IFF1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgYmxvY2tlZF9yZWFkcyA9IFF1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgY29uc3VtZXJzID0gW11cbiAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzID0gQmFnLmNyZWF0ZSAoKVxuICAgIH1cbiAgaW5cbiAgdFxuOztcblxubGV0IHZhbGlkYXRlX3NpemVfYnVkZ2V0IHNpemVfYnVkZ2V0ID1cbiAgaWYgc2l6ZV9idWRnZXQgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJuZWdhdGl2ZSBzaXplX2J1ZGdldFwiIChzaXplX2J1ZGdldCA6IGludCldXG4gIGVsc2Ugc2l6ZV9idWRnZXRcbjs7XG5cbmxldCBjcmVhdGUgP3NpemVfYnVkZ2V0ID9pbmZvICgpID1cbiAgbGV0IHNpemVfYnVkZ2V0ID1cbiAgICBtYXRjaCBzaXplX2J1ZGdldCB3aXRoXG4gICAgfCBTb21lIHYgLT4gdmFsaWRhdGVfc2l6ZV9idWRnZXQgdlxuICAgIHwgTm9uZSAtPiAwXG4gIGluXG4gIGxldCB0ID0gY3JlYXRlX2ludGVybmFsIH5zaXplX2J1ZGdldCB+aW5mbyB+aW5pdGlhbF9idWZmZXI6KFF1ZXVlLmNyZWF0ZSAoKSkgaW5cbiAgKCogaW5pdGlhbGx5LCB0aGUgcGlwZSBkb2VzIG5vdCBwdXNoYmFjayAqKVxuICBJdmFyLmZpbGwgdC5wdXNoYmFjayAoKTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICB0LCB0XG47O1xuXG5sZXQgdXBkYXRlX3B1c2hiYWNrIHQgPVxuICBpZiBsZW5ndGggdCA8PSB0LnNpemVfYnVkZ2V0IHx8IGlzX2Nsb3NlZCB0XG4gIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IHQucHVzaGJhY2sgKClcbiAgZWxzZSBpZiBJdmFyLmlzX2Z1bGwgdC5wdXNoYmFja1xuICB0aGVuIHQucHVzaGJhY2sgPC0gSXZhci5jcmVhdGUgKClcbjs7XG5cbmxldCBjbG9zZSB0ID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwiY2xvc2VcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIG5vdCAoaXNfY2xvc2VkIHQpXG4gIHRoZW4gKFxuICAgIEl2YXIuZmlsbCB0LmNsb3NlZCAoKTtcbiAgICBpZiBpc19lbXB0eSB0XG4gICAgdGhlbiAoXG4gICAgICBRdWV1ZS5pdGVyIHQuYmxvY2tlZF9yZWFkcyB+ZjpCbG9ja2VkX3JlYWQuZmlsbF93aXRoX2VvZjtcbiAgICAgIFF1ZXVlLmNsZWFyIHQuYmxvY2tlZF9yZWFkcyk7XG4gICAgdXBkYXRlX3B1c2hiYWNrIHQpXG47O1xuXG5sZXQgY2xvc2VfcmVhZCB0ID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwiY2xvc2VfcmVhZFwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgbm90IChpc19yZWFkX2Nsb3NlZCB0KVxuICB0aGVuIChcbiAgICBJdmFyLmZpbGwgdC5yZWFkX2Nsb3NlZCAoKTtcbiAgICBRdWV1ZS5pdGVyIHQuYmxvY2tlZF9mbHVzaGVzIH5mOihmdW4gZmx1c2ggLT4gQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGBSZWFkZXJfY2xvc2VkKTtcbiAgICBRdWV1ZS5jbGVhciB0LmJsb2NrZWRfZmx1c2hlcztcbiAgICBRdWV1ZS5jbGVhciB0LmJ1ZmZlcjtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgICAoKiB3ZSBqdXN0IGNsZWFyZWQgdGhlIGJ1ZmZlciwgc28gbWF5IG5lZWQgdG8gZmlsbCBbdC5wdXNoYmFja10gKilcbiAgICBjbG9zZSB0KVxuOztcblxubGV0IGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiA/c2l6ZV9idWRnZXQgZiA9XG4gIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICB1cG9uIChmIHcpIChmdW4gKCkgLT4gY2xvc2Ugdyk7XG4gIHJcbjs7XG5cbmxldCBjcmVhdGVfcmVhZGVyID9zaXplX2J1ZGdldCB+Y2xvc2Vfb25fZXhjZXB0aW9uIGYgPVxuICBpZiBub3QgY2xvc2Vfb25fZXhjZXB0aW9uXG4gIHRoZW4gY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uID9zaXplX2J1ZGdldCBmXG4gIGVsc2UgKFxuICAgIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAoTW9uaXRvci5wcm90ZWN0XG4gICAgICAgICB+cnVuOlxuICAgICAgICAgICBgU2NoZWR1bGVcbiAgICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgIChmdW4gKCkgLT4gZiB3KVxuICAgICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgICAgICBjbG9zZSB3O1xuICAgICAgICAgICByZXR1cm4gKCkpKTtcbiAgICByKVxuOztcblxubGV0IGNyZWF0ZV93cml0ZXIgP3NpemVfYnVkZ2V0IGYgPVxuICBsZXQgciwgdyA9IGNyZWF0ZSA/c2l6ZV9idWRnZXQgKCkgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAoTW9uaXRvci5wcm90ZWN0XG4gICAgICAgfnJ1bjpcbiAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAoZnVuICgpIC0+IGYgcilcbiAgICAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICAgICBjbG9zZV9yZWFkIHI7XG4gICAgICAgICByZXR1cm4gKCkpKTtcbiAgd1xuOztcblxubGV0IHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lciA9XG4gIE9wdGlvbi5pdGVyIGNvbnN1bWVyIH5mOkNvbnN1bWVyLnN0YXJ0O1xuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIG1hdGNoIFF1ZXVlLnBlZWsgdC5ibG9ja2VkX2ZsdXNoZXMgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBmbHVzaCAtPlxuICAgICAgaWYgdC5udW1fdmFsdWVzX3JlYWQgPj0gZmx1c2guZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZFxuICAgICAgdGhlbiAoXG4gICAgICAgIGlnbm9yZSAoUXVldWUuZGVxdWV1ZV9leG4gdC5ibG9ja2VkX2ZsdXNoZXMgOiBCbG9ja2VkX2ZsdXNoLnQpO1xuICAgICAgICAobWF0Y2ggY29uc3VtZXIgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IEJsb2NrZWRfZmx1c2guZmlsbCBmbHVzaCBgT2tcbiAgICAgICAgIHwgU29tZSBjb25zdW1lciAtPlxuICAgICAgICAgICB1cG9uIChDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIGNvbnN1bWVyKSAoZnVuIGZsdXNoX3Jlc3VsdCAtPlxuICAgICAgICAgICAgIEJsb2NrZWRfZmx1c2guZmlsbCBmbHVzaCBmbHVzaF9yZXN1bHQpKTtcbiAgICAgICAgbG9vcCAoKSlcbiAgaW5cbiAgbG9vcCAoKVxuOztcblxuKCogW2NvbnN1bWVfYWxsIHRdIHJlYWRzIGFsbCB0aGUgZWxlbWVudHMgaW4gW3RdLiAqKVxubGV0IGNvbnN1bWVfYWxsIHQgY29uc3VtZXIgPVxuICBsZXQgcmVzdWx0ID0gdC5idWZmZXIgaW5cbiAgdC5idWZmZXIgPC0gUXVldWUuY3JlYXRlICgpO1xuICB0Lm51bV92YWx1ZXNfcmVhZCA8LSB0Lm51bV92YWx1ZXNfcmVhZCArIFF1ZXVlLmxlbmd0aCByZXN1bHQ7XG4gIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gIHJlc3VsdFxuOztcblxubGV0IGNvbnN1bWVfb25lIHQgY29uc3VtZXIgPVxuICBhc3NlcnQgKGxlbmd0aCB0ID49IDEpO1xuICBsZXQgcmVzdWx0ID0gUXVldWUuZGVxdWV1ZV9leG4gdC5idWZmZXIgaW5cbiAgdC5udW1fdmFsdWVzX3JlYWQgPC0gdC5udW1fdmFsdWVzX3JlYWQgKyAxO1xuICB2YWx1ZXNfd2VyZV9yZWFkIHQgY29uc3VtZXI7XG4gIHVwZGF0ZV9wdXNoYmFjayB0O1xuICByZXN1bHRcbjs7XG5cbmxldCBjb25zdW1lIHQgfm1heF9xdWV1ZV9sZW5ndGggY29uc3VtZXIgPVxuICBhc3NlcnQgKG1heF9xdWV1ZV9sZW5ndGggPj0gMCk7XG4gIGlmIG1heF9xdWV1ZV9sZW5ndGggPj0gbGVuZ3RoIHRcbiAgdGhlbiBjb25zdW1lX2FsbCB0IGNvbnN1bWVyXG4gIGVsc2UgKFxuICAgIHQubnVtX3ZhbHVlc19yZWFkIDwtIHQubnVtX3ZhbHVlc19yZWFkICsgbWF4X3F1ZXVlX2xlbmd0aDtcbiAgICB2YWx1ZXNfd2VyZV9yZWFkIHQgY29uc3VtZXI7XG4gICAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSB+Y2FwYWNpdHk6bWF4X3F1ZXVlX2xlbmd0aCAoKSBpblxuICAgIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzp0LmJ1ZmZlciB+ZHN0OnJlc3VsdCB+bGVuOm1heF9xdWV1ZV9sZW5ndGggKCk7XG4gICAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gICAgcmVzdWx0KVxuOztcblxubGV0IHNldF9zaXplX2J1ZGdldCB0IHNpemVfYnVkZ2V0ID1cbiAgbGV0IHNpemVfYnVkZ2V0ID0gdmFsaWRhdGVfc2l6ZV9idWRnZXQgc2l6ZV9idWRnZXQgaW5cbiAgdC5zaXplX2J1ZGdldCA8LSBzaXplX2J1ZGdldDtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCBmaWxsX2Jsb2NrZWRfcmVhZHMgdCA9XG4gIHdoaWxlIChub3QgKFF1ZXVlLmlzX2VtcHR5IHQuYmxvY2tlZF9yZWFkcykpICYmIG5vdCAoaXNfZW1wdHkgdCkgZG9cbiAgICBsZXQgYmxvY2tlZF9yZWFkID0gUXVldWUuZGVxdWV1ZV9leG4gdC5ibG9ja2VkX3JlYWRzIGluXG4gICAgbGV0IGNvbnN1bWVyID0gYmxvY2tlZF9yZWFkLmNvbnN1bWVyIGluXG4gICAgbWF0Y2ggYmxvY2tlZF9yZWFkLndhbnRzIHdpdGhcbiAgICB8IFplcm8gaXZhciAtPiBJdmFyLmZpbGwgaXZhciBgT2tcbiAgICB8IE9uZSBpdmFyIC0+IEl2YXIuZmlsbCBpdmFyIChgT2sgKGNvbnN1bWVfb25lIHQgY29uc3VtZXIpKVxuICAgIHwgQXRfbW9zdCAobWF4X3F1ZXVlX2xlbmd0aCwgaXZhcikgLT5cbiAgICAgIEl2YXIuZmlsbCBpdmFyIChgT2sgKGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lcikpXG4gIGRvbmVcbjs7XG5cbigqIGNoZWNrcyBhbGwgaW52YXJpYW50cywgY2FsbHMgYSBwYXNzZWQgaW4gZiB0byBoYW5kbGUgYSB3cml0ZSwgdGhlbiB1cGRhdGVzIHJlYWRzIGFuZFxuICAgcHVzaGJhY2sgKilcbmxldCBzdGFydF93cml0ZSB0ID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwid3JpdGVcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIGlzX2Nsb3NlZCB0IHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJ3cml0ZSB0byBjbG9zZWQgcGlwZVwiIH5waXBlOih0IDogKF8sIF8pIHQpXVxuOztcblxubGV0IGZpbmlzaF93cml0ZSB0ID1cbiAgZmlsbF9ibG9ja2VkX3JlYWRzIHQ7XG4gIHVwZGF0ZV9wdXNoYmFjayB0XG47O1xuXG5sZXQgdHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayB0IH5mcm9tID1cbiAgc3RhcnRfd3JpdGUgdDtcbiAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOmZyb20gfmRzdDp0LmJ1ZmZlciAoKTtcbiAgZmluaXNoX3dyaXRlIHRcbjs7XG5cbmxldCB0cmFuc2Zlcl9pbiB0IH5mcm9tID1cbiAgdHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayB0IH5mcm9tO1xuICBwdXNoYmFjayB0XG47O1xuXG5sZXQgY29weV9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb20gPVxuICBzdGFydF93cml0ZSB0O1xuICBRdWV1ZS5pdGVyIGZyb20gfmY6KGZ1biB4IC0+IFF1ZXVlLmVucXVldWUgdC5idWZmZXIgeCk7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG4oKiBbd3JpdGUnXSBpcyB1c2VkIGludGVybmFsbHkgKilcbmxldCB3cml0ZScgdCBxID0gdHJhbnNmZXJfaW4gdCB+ZnJvbTpxXG5cbmxldCB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgdmFsdWUgPVxuICBzdGFydF93cml0ZSB0O1xuICBRdWV1ZS5lbnF1ZXVlIHQuYnVmZmVyIHZhbHVlO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHdyaXRlIHQgdmFsdWUgPVxuICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgdmFsdWU7XG4gIHB1c2hiYWNrIHRcbjs7XG5cbmxldCB3cml0ZV93aGVuX3JlYWR5IHQgfmYgPVxuICBsZXQlbWFwICgpID0gcHVzaGJhY2sgdCBpblxuICBpZiBpc19jbG9zZWQgdCB0aGVuIGBDbG9zZWQgZWxzZSBgT2sgKGYgKGZ1biB4IC0+IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB4KSlcbjs7XG5cbmxldCB3cml0ZV9pZl9vcGVuIHQgeCA9IGlmIG5vdCAoaXNfY2xvc2VkIHQpIHRoZW4gd3JpdGUgdCB4IGVsc2UgcmV0dXJuICgpXG5cbmxldCB3cml0ZV93aXRob3V0X3B1c2hiYWNrX2lmX29wZW4gdCB4ID1cbiAgaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgeFxuOztcblxubGV0IGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzID9jb25zdW1lciB0ID1cbiAgbWF0Y2ggY29uc3VtZXIgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGNvbnN1bWVyIC0+XG4gICAgaWYgdC5pZCA8PiBDb25zdW1lci5waXBlX2lkIGNvbnN1bWVyXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkF0dGVtcHQgdG8gdXNlIGNvbnN1bWVyIHdpdGggd3JvbmcgcGlwZVwiXG4gICAgICAgICAgICAoY29uc3VtZXIgOiBDb25zdW1lci50KVxuICAgICAgICAgICAgfnBpcGU6KHQgOiBfIFJlYWRlci50KV1cbjs7XG5cbmxldCBzdGFydF9yZWFkID9jb25zdW1lciB0IGxhYmVsID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIGxhYmVsIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXJcbjs7XG5cbmxldCBnZW5fcmVhZF9ub3cgP2NvbnN1bWVyIHQgY29uc3VtZSA9XG4gIHN0YXJ0X3JlYWQgdCBcInJlYWRfbm93XCIgP2NvbnN1bWVyO1xuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gaWYgaXNfY2xvc2VkIHQgdGhlbiBgRW9mIGVsc2UgYE5vdGhpbmdfYXZhaWxhYmxlXG4gIGVsc2UgKFxuICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICAoKiBmcm9tIFtpbnZhcmlhbnRdIGFuZCBbbm90IChpc19lbXB0eSB0KV0gKilcbiAgICBgT2sgKGNvbnN1bWUgdCBjb25zdW1lcikpXG47O1xuXG5sZXQgZ2V0X21heF9xdWV1ZV9sZW5ndGggfm1heF9xdWV1ZV9sZW5ndGggPVxuICBtYXRjaCBtYXhfcXVldWVfbGVuZ3RoIHdpdGhcbiAgfCBOb25lIC0+IEludC5tYXhfdmFsdWVcbiAgfCBTb21lIG1heF9xdWV1ZV9sZW5ndGggLT5cbiAgICBpZiBtYXhfcXVldWVfbGVuZ3RoIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwibWF4X3F1ZXVlX2xlbmd0aCA8PSAwXCIgKG1heF9xdWV1ZV9sZW5ndGggOiBpbnQpXTtcbiAgICBtYXhfcXVldWVfbGVuZ3RoXG47O1xuXG5sZXQgcmVhZF9ub3cnID9jb25zdW1lciA/bWF4X3F1ZXVlX2xlbmd0aCB0ID1cbiAgbGV0IG1heF9xdWV1ZV9sZW5ndGggPSBnZXRfbWF4X3F1ZXVlX2xlbmd0aCB+bWF4X3F1ZXVlX2xlbmd0aCBpblxuICBnZW5fcmVhZF9ub3cgdCA/Y29uc3VtZXIgKGZ1biB0IGNvbnN1bWVyIC0+IGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lcilcbjs7XG5cbmxldCByZWFkX25vdyA/Y29uc3VtZXIgdCA9IGdlbl9yZWFkX25vdyB0ID9jb25zdW1lciBjb25zdW1lX29uZVxubGV0IHBlZWsgdCA9IFF1ZXVlLnBlZWsgdC5idWZmZXJcblxubGV0IGNsZWFyIHQgPVxuICBtYXRjaCByZWFkX25vdycgdCB3aXRoXG4gIHwgYEVvZiB8IGBOb3RoaW5nX2F2YWlsYWJsZSB8IGBPayBfIC0+ICgpXG47O1xuXG5sZXQgcmVhZCcgP2NvbnN1bWVyID9tYXhfcXVldWVfbGVuZ3RoIHQgPVxuICBsZXQgbWF4X3F1ZXVlX2xlbmd0aCA9IGdldF9tYXhfcXVldWVfbGVuZ3RoIH5tYXhfcXVldWVfbGVuZ3RoIGluXG4gIHN0YXJ0X3JlYWQgdCBcInJlYWQnXCIgP2NvbnN1bWVyO1xuICBtYXRjaCByZWFkX25vdycgdCA/Y29uc3VtZXIgfm1heF9xdWV1ZV9sZW5ndGggd2l0aFxuICB8IChgT2sgXyB8IGBFb2YpIGFzIHIgLT4gcmV0dXJuIHJcbiAgfCBgTm90aGluZ19hdmFpbGFibGUgLT5cbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICBRdWV1ZS5lbnF1ZXVlXG4gICAgICAgIHQuYmxvY2tlZF9yZWFkc1xuICAgICAgICAoQmxvY2tlZF9yZWFkLmNyZWF0ZSAoQXRfbW9zdCAobWF4X3F1ZXVlX2xlbmd0aCwgaXZhcikpIGNvbnN1bWVyKSlcbjs7XG5cbmxldCByZWFkID9jb25zdW1lciB0ID1cbiAgc3RhcnRfcmVhZCB0IFwicmVhZFwiID9jb25zdW1lcjtcbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuXG4gICAgaWYgaXNfY2xvc2VkIHRcbiAgICB0aGVuIHJldHVybiBgRW9mXG4gICAgZWxzZVxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPlxuICAgICAgICBRdWV1ZS5lbnF1ZXVlIHQuYmxvY2tlZF9yZWFkcyAoQmxvY2tlZF9yZWFkLihjcmVhdGUgKE9uZSBpdmFyKSkgY29uc3VtZXIpKVxuICBlbHNlIChcbiAgICBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IHQuYmxvY2tlZF9yZWFkcyk7XG4gICAgcmV0dXJuIChgT2sgKGNvbnN1bWVfb25lIHQgY29uc3VtZXIpKSlcbjs7XG5cbmxldCByZWFkX2V4biA/Y29uc3VtZXIgdCA9XG4gIG1hdGNoJW1hcCByZWFkID9jb25zdW1lciB0IHdpdGhcbiAgfCBgT2sgdmFsdWUgLT4gdmFsdWVcbiAgfCBgRW9mIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX2V4bjogcmVjZWl2ZWQgRU9GXCJdXG47O1xuXG5sZXQgdmFsdWVzX2F2YWlsYWJsZSB0ID1cbiAgc3RhcnRfcmVhZCB0IFwidmFsdWVzX2F2YWlsYWJsZVwiO1xuICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gIHRoZW4gcmV0dXJuIGBPa1xuICBlbHNlIGlmIGlzX2Nsb3NlZCB0XG4gIHRoZW4gcmV0dXJuIGBFb2ZcbiAgZWxzZSAoXG4gICAgbWF0Y2ggUXVldWUubGFzdCB0LmJsb2NrZWRfcmVhZHMgd2l0aFxuICAgIHwgU29tZSB7IGNvbnN1bWVyID0gTm9uZTsgd2FudHMgPSBaZXJvIGl2YXIgfSAtPlxuICAgICAgKCogVGhpcyBjYXNlIGlzIGFuIG9wdGltaXphdGlvbiBmb3IgbXVsdGlwbGUgY2FsbHMgdG8gW3ZhbHVlc19hdmFpbGFibGVdIGluXG4gICAgICAgICBzZXF1ZW5jZS4gIEl0IGNhdXNlcyB0aGVtIHRvIGFsbCBzaGFyZSB0aGUgc2FtZSBpdmFyLCByYXRoZXIgdGhhbiBhbGxvY2F0ZVxuICAgICAgICAgYW4gaXZhciBwZXIgY2FsbC4gKilcbiAgICAgIEl2YXIucmVhZCBpdmFyXG4gICAgfCBfIC0+XG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdC5ibG9ja2VkX3JlYWRzIChCbG9ja2VkX3JlYWQuKGNyZWF0ZSAoWmVybyBpdmFyKSkgTm9uZSkpKVxuOztcblxubGV0IHJlYWRfY2hvaWNlIHQgPSBjaG9pY2UgKHZhbHVlc19hdmFpbGFibGUgdCkgKGZ1biAoXyA6IFsgYE9rIHwgYEVvZiBdKSAtPiByZWFkX25vdyB0KVxuXG5sZXQgcmVhZF9jaG9pY2Vfc2luZ2xlX2NvbnN1bWVyX2V4biB0IGhlcmUgPVxuICBEZWZlcnJlZC5DaG9pY2UubWFwIChyZWFkX2Nob2ljZSB0KSB+ZjooZnVuY3Rpb25cbiAgICB8IChgT2sgXyB8IGBFb2YpIGFzIHggLT4geFxuICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiUGlwZS5yZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXhuOiBjaG9pY2Ugd2FzIGVuYWJsZWQgYnV0IHBpcGUgaXMgZW1wdHk7IFxcXG4gICAgICAgICAgIHRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIHJhY2UgY29uZGl0aW9uIHdpdGggb25lIG9yIG1vcmUgb3RoZXIgY29uc3VtZXJzXCJcbiAgICAgICAgICAgIChoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCldKVxuOztcblxuKCogW3JlYWRfZXhhY3RseSB0IH5udW1fdmFsdWVzXSBsb29wcywgZ2V0dGluZyB5b3UgYWxsIFtudW1fdmFsdWVzXSBpdGVtcywgdXBcbiAgIHRvIEVPRi4gKilcbmxldCByZWFkX2V4YWN0bHkgP2NvbnN1bWVyIHQgfm51bV92YWx1ZXMgPVxuICBzdGFydF9yZWFkIHQgXCJyZWFkX2V4YWN0bHlcIiA/Y29uc3VtZXI7XG4gIGlmIG51bV92YWx1ZXMgPD0gMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX2V4YWN0bHkgZ290IG51bV92YWx1ZXMgPD0gMFwiIChudW1fdmFsdWVzIDogaW50KV07XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGZpbmlzaCAtPlxuICAgIGxldCByZXN1bHQgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IFF1ZXVlLmxlbmd0aCByZXN1bHQgaW5cbiAgICAgIGFzc2VydCAoYWxyZWFkeV9yZWFkIDw9IG51bV92YWx1ZXMpO1xuICAgICAgaWYgYWxyZWFkeV9yZWFkID0gbnVtX3ZhbHVlc1xuICAgICAgdGhlbiBJdmFyLmZpbGwgZmluaXNoIChgRXhhY3RseSByZXN1bHQpXG4gICAgICBlbHNlXG4gICAgICAgIHJlYWQnID9jb25zdW1lciB0IH5tYXhfcXVldWVfbGVuZ3RoOihudW1fdmFsdWVzIC0gYWxyZWFkeV9yZWFkKVxuICAgICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbCBmaW5pc2ggKGlmIGFscmVhZHlfcmVhZCA9IDAgdGhlbiBgRW9mIGVsc2UgYEZld2VyIHJlc3VsdClcbiAgICAgICAgfCBgT2sgcSAtPlxuICAgICAgICAgIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzpxIH5kc3Q6cmVzdWx0ICgpO1xuICAgICAgICAgIGxvb3AgKClcbiAgICBpblxuICAgIGxvb3AgKCkpXG47O1xuXG5sZXQgZG93bnN0cmVhbV9mbHVzaGVkIHQgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBpZiBMaXN0LmlzX2VtcHR5IHQuY29uc3VtZXJzXG4gICAgdGhlbiByZXR1cm4gYE9rXG4gICAgZWxzZVxuICAgICAgRmx1c2hlZF9yZXN1bHQuY29tYmluZVxuICAgICAgICAoTGlzdC5tYXAgdC5jb25zdW1lcnMgfmY6Q29uc3VtZXIudmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZClcbiAgZWxzZVxuICAgICgqIFt0XSBtaWdodCBiZSBjbG9zZWQuICBCdXQgdGhlIHJlYWQgZW5kIGNhbid0IGJlIGNsb3NlZCwgYmVjYXVzZSBpZiBpdCB3ZXJlLCB0aGVuXG4gICAgICAgW3RdIHdvdWxkIGJlIGVtcHR5LiAgSWYgdGhlIHdyaXRlIGVuZCBpcyBjbG9zZWQgYnV0IG5vdCB0aGUgcmVhZCBlbmQsIHRoZW4gd2Ugd2FudFxuICAgICAgIHRvIGVucXVldWUgYSBibG9ja2VkIGZsdXNoIGJlY2F1c2UgdGhlIGVucXVldWVkIHZhbHVlcyBtYXkgZ2V0IHJlYWQuICopXG4gICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVhZHkgLT5cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgdC5ibG9ja2VkX2ZsdXNoZXNcbiAgICAgICAgeyBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkID0gdC5udW1fdmFsdWVzX3JlYWQgKyBsZW5ndGggdDsgcmVhZHkgfSlcbjs7XG5cbigqIEluIHByYWN0aWNlLCBhbG9uZyB3aXRoIFtMaW5rLmNyZWF0ZV0gYW5kIFthZGRfdXBzdHJlYW1fZmx1c2hlZF0sIFt1cHN0cmVhbV9mbHVzaGVkXVxuICAgdHJhdmVyc2VzIHRoZSBncmFwaCBvZiBsaW5rZWQgcGlwZXMgdXAgdG8gdGhlIGhlYWRzIGFuZCB0aGVuIGNhbGxzIFtkb3duc3RyZWFtX2ZsdXNoZWRdXG4gICBvbiB0aGVtLiAqKVxubGV0IHVwc3RyZWFtX2ZsdXNoZWQgdCA9XG4gIGlmIEJhZy5pc19lbXB0eSB0LnVwc3RyZWFtX2ZsdXNoZWRzXG4gIHRoZW4gZG93bnN0cmVhbV9mbHVzaGVkIHRcbiAgZWxzZVxuICAgIEJhZy50b19saXN0IHQudXBzdHJlYW1fZmx1c2hlZHNcbiAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGYgLT4gZiAoKSlcbiAgICB8PiBGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXG47O1xuXG5sZXQgYWRkX3Vwc3RyZWFtX2ZsdXNoZWQgdCB1cHN0cmVhbV9mbHVzaGVkID0gQmFnLmFkZCB0LnVwc3RyZWFtX2ZsdXNoZWRzIHVwc3RyZWFtX2ZsdXNoZWRcblxubGV0IGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQgPVxuICBsZXQgY29uc3VtZXIgPSBDb25zdW1lci5jcmVhdGUgfnBpcGVfaWQ6dC5pZCB+ZG93bnN0cmVhbV9mbHVzaGVkIGluXG4gIHQuY29uc3VtZXJzIDwtIGNvbnN1bWVyIDo6IHQuY29uc3VtZXJzO1xuICBjb25zdW1lclxuOztcblxuKCogQSBbTGluay50XSBsaW5rcyBmbHVzaGluZyBvZiB0d28gcGlwZXMgdG9nZXRoZXIuICopXG5tb2R1bGUgTGluayA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlIDogdXBzdHJlYW06KF8sIF8pIHBpcGUgLT4gZG93bnN0cmVhbTooXywgXykgcGlwZSAtPiB0XG4gIHZhbCBjb25zdW1lciA6IHQgLT4gQ29uc3VtZXIudFxuXG4gICgqIFt1bmxpbmtfdXBzdHJlYW1dIHJlbW92ZXMgZG93bnN0cmVhbSdzIHJlZmVyZW5jZSB0byB1cHN0cmVhbS4gKilcblxuICB2YWwgdW5saW5rX3Vwc3RyZWFtIDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB1bnBhY2tlZCA9XG4gICAgeyBkb3duc3RyZWFtIDogKCdhLCAnYikgdFxuICAgIDsgY29uc3VtZXIgOiBDb25zdW1lci50XG4gICAgOyB1cHN0cmVhbV9mbHVzaGVkc19iYWdfZWx0IDogKHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KSBCYWcuRWx0LnRcbiAgICB9XG5cbiAgdHlwZSB0ID0gVCA6IChfLCBfKSB1bnBhY2tlZCAtPiB0XG5cbiAgbGV0IGNvbnN1bWVyIChUIHQpID0gdC5jb25zdW1lclxuXG4gIGxldCBjcmVhdGUgfnVwc3RyZWFtIH5kb3duc3RyZWFtID1cbiAgICBUXG4gICAgICB7IGRvd25zdHJlYW1cbiAgICAgIDsgY29uc3VtZXIgPVxuICAgICAgICAgIGFkZF9jb25zdW1lciB1cHN0cmVhbSB+ZG93bnN0cmVhbV9mbHVzaGVkOihmdW4gKCkgLT5cbiAgICAgICAgICAgIGRvd25zdHJlYW1fZmx1c2hlZCBkb3duc3RyZWFtKVxuICAgICAgOyB1cHN0cmVhbV9mbHVzaGVkc19iYWdfZWx0ID1cbiAgICAgICAgICBhZGRfdXBzdHJlYW1fZmx1c2hlZCBkb3duc3RyZWFtIChmdW4gKCkgLT4gdXBzdHJlYW1fZmx1c2hlZCB1cHN0cmVhbSlcbiAgICAgIH1cbiAgOztcblxuICBsZXQgdW5saW5rX3Vwc3RyZWFtIChUIHQpID1cbiAgICBCYWcucmVtb3ZlIHQuZG93bnN0cmVhbS51cHN0cmVhbV9mbHVzaGVkcyB0LnVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmx1c2hlZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ29uc3VtZXIgb2YgQ29uc3VtZXIudFxuICAgIHwgV2hlbl92YWx1ZV9wcm9jZXNzZWRcbiAgICB8IFdoZW5fdmFsdWVfcmVhZFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBmb2xkX2dlblxuICAgICAgKHJlYWRfbm93IDogP2NvbnN1bWVyOkNvbnN1bWVyLnQgLT4gXyBSZWFkZXIudCAtPiBfKVxuICAgICAgPyhmbHVzaGVkID0gRmx1c2hlZC5XaGVuX3ZhbHVlX3JlYWQpXG4gICAgICB0XG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgPVxuICBsZXQgY29uc3VtZXIgPVxuICAgIG1hdGNoIGZsdXNoZWQgd2l0aFxuICAgIHwgV2hlbl92YWx1ZV9yZWFkIC0+IE5vbmVcbiAgICB8IENvbnN1bWVyIGNvbnN1bWVyIC0+IFNvbWUgY29uc3VtZXJcbiAgICB8IFdoZW5fdmFsdWVfcHJvY2Vzc2VkIC0+XG4gICAgICAoKiBUaGUgZmFjdCB0aGF0IFwibm8gY29uc3VtZXJcIiBiZWhhdmVzIGRpZmZlcmVudCBmcm9tIFwidHJpdmlhbCBjb25zdW1lclwiIGlzIHdlaXJkLFxuICAgICAgICAgYnV0IHRoYXQncyBob3cgdGhlIGNvbnN1bWVyIG1hY2hpbmVyeSB3b3Jrcy4gKilcbiAgICAgIFNvbWUgKGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPiByZXR1cm4gYE9rKSlcbiAgaW5cbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBlbnN1cmVfY29uc3VtZXJfbWF0Y2hlcyB0ID9jb25zdW1lcjtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoZWQgLT5cbiAgICAoKiBXZSBkbyBbcmV0dXJuICgpID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqKVxuICAgIHJldHVybiAoKVxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBsZXQgcmVjIGxvb3AgYiA9XG4gICAgICBtYXRjaCByZWFkX25vdyB0ID9jb25zdW1lciB3aXRoXG4gICAgICB8IGBFb2YgLT4gSXZhci5maWxsIGZpbmlzaGVkIGJcbiAgICAgIHwgYE9rIHYgLT4gZiBiIHYgY29udGludWVcbiAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IHZhbHVlc19hdmFpbGFibGUgdCA+Pj4gZnVuIF8gLT4gbG9vcCBiXG4gICAgYW5kIGNvbnRpbnVlIGIgPVxuICAgICAgT3B0aW9uLml0ZXIgY29uc3VtZXIgfmY6Q29uc3VtZXIudmFsdWVzX3NlbnRfZG93bnN0cmVhbTtcbiAgICAgIGxvb3AgYlxuICAgIGluXG4gICAgbG9vcCBpbml0KVxuOztcblxubGV0IGZvbGQnID9mbHVzaGVkID9tYXhfcXVldWVfbGVuZ3RoIHQgfmluaXQgfmYgPVxuICBmb2xkX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSA/Zmx1c2hlZCB0IH5pbml0IH5mOihmdW4gYiBxIGxvb3AgLT5cbiAgICBmIGIgcSA+Pj4gbG9vcClcbjs7XG5cbmxldCBmb2xkID9mbHVzaGVkIHQgfmluaXQgfmYgPVxuICBmb2xkX2dlbiByZWFkX25vdyA/Zmx1c2hlZCB0IH5pbml0IH5mOihmdW4gYiBhIGxvb3AgLT4gZiBiIGEgPj4+IGxvb3ApXG47O1xuXG5sZXQgZm9sZF93aXRob3V0X3B1c2hiYWNrID9jb25zdW1lciB0IH5pbml0IH5mID1cbiAgZm9sZF9nZW5cbiAgICByZWFkX25vd1xuICAgIHRcbiAgICB+aW5pdFxuICAgIH5mOihmdW4gYiBhIGxvb3AgLT4gbG9vcCAoZiBiIGEpKVxuICAgID9mbHVzaGVkOlxuICAgICAgKG1hdGNoIGNvbnN1bWVyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgIHwgU29tZSBjIC0+IFNvbWUgKENvbnN1bWVyIGMpKVxuOztcblxubGV0IHdpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yID8oY29udGludWVfb25fZXJyb3IgPSBmYWxzZSkgZiBhID1cbiAgaWYgbm90IGNvbnRpbnVlX29uX2Vycm9yXG4gIHRoZW4gZiBhXG4gIGVsc2UgKFxuICAgIG1hdGNoJW1hcFxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cnVuOlxuICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIChmdW4gKCkgLT4gZiBhKVxuICAgIHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciBleG4gLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSAoTW9uaXRvci5leHRyYWN0X2V4biBleG4pKVxuOztcblxubGV0IGl0ZXInID9jb250aW51ZV9vbl9lcnJvciA/Zmx1c2hlZCA/bWF4X3F1ZXVlX2xlbmd0aCB0IH5mID1cbiAgZm9sZCcgP21heF9xdWV1ZV9sZW5ndGggP2ZsdXNoZWQgdCB+aW5pdDooKSB+ZjooZnVuICgpIHEgLT5cbiAgICB3aXRoX2Vycm9yX3RvX2N1cnJlbnRfbW9uaXRvciA/Y29udGludWVfb25fZXJyb3IgZiBxKVxuOztcblxubGV0IGl0ZXIgP2NvbnRpbnVlX29uX2Vycm9yID9mbHVzaGVkIHQgfmYgPVxuICBmb2xkX2dlbiByZWFkX25vdyA/Zmx1c2hlZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSBsb29wIC0+XG4gICAgd2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IgP2NvbnRpbnVlX29uX2Vycm9yIGYgYSA+Pj4gZnVuICgpIC0+IGxvb3AgKCkpXG47O1xuXG4oKiBbaXRlcl93aXRob3V0X3B1c2hiYWNrXSBpcyBhIGNvbW1vbiBjYXNlLCBzbyB3ZSBpbXBsZW1lbnQgaXQgaW4gYW4gb3B0aW1pemVkIG1hbm5lcixcbiAgIHJhdGhlciB0aGFuIHZpYSBbaXRlcl0uICBUaGUgaW1wbGVtZW50YXRpb24gcmVhZHMgb25seSBvbmUgZWxlbWVudCBhdCBhIHRpbWUsIHNvIHRoYXRcbiAgIGlmIFtmXSBjbG9zZXMgW3RdIG9yIHJhaXNlcywgbm8gbW9yZSBlbGVtZW50cyB3aWxsIGJlIHJlYWQuICopXG5sZXQgaXRlcl93aXRob3V0X3B1c2hiYWNrXG4gICAgICA/Y29uc3VtZXJcbiAgICAgID8oY29udGludWVfb25fZXJyb3IgPSBmYWxzZSlcbiAgICAgID9tYXhfaXRlcmF0aW9uc19wZXJfam9iXG4gICAgICB0XG4gICAgICB+ZlxuICA9XG4gIGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIHQgP2NvbnN1bWVyO1xuICBsZXQgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiA9XG4gICAgbWF0Y2ggbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiB3aXRoXG4gICAgfCBOb25lIC0+IEludC5tYXhfdmFsdWVcbiAgICB8IFNvbWUgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiAtPlxuICAgICAgaWYgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiA8PSAwXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiaXRlcl93aXRob3V0X3B1c2hiYWNrIGdvdCBub24tcG9zaXRpdmUgbWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlwiXG4gICAgICAgICAgICAgIChtYXhfaXRlcmF0aW9uc19wZXJfam9iIDogaW50KV07XG4gICAgICBtYXhfaXRlcmF0aW9uc19wZXJfam9iXG4gIGluXG4gIGxldCBmID1cbiAgICBpZiBub3QgY29udGludWVfb25fZXJyb3JcbiAgICB0aGVuIGZcbiAgICBlbHNlXG4gICAgICBmdW4gYSAtPlxuICAgICAgICB0cnkgZiBhIHdpdGhcbiAgICAgICAgfCBleG4gLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBleG5cbiAgaW5cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoZWQgLT5cbiAgICAoKiBXZSBkbyBbcmV0dXJuICgpID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqKVxuICAgIHJldHVybiAoKVxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBsZXQgcmVjIHN0YXJ0ICgpID0gbG9vcCB+cmVtYWluaW5nOm1heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgICBhbmQgbG9vcCB+cmVtYWluaW5nID1cbiAgICAgIGlmIHJlbWFpbmluZyA9IDBcbiAgICAgIHRoZW4gcmV0dXJuICgpID4+PiBmdW4gKCkgLT4gc3RhcnQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCByZWFkX25vdyB0ID9jb25zdW1lciB3aXRoXG4gICAgICAgIHwgYEVvZiAtPiBJdmFyLmZpbGwgZmluaXNoZWQgKClcbiAgICAgICAgfCBgT2sgYSAtPlxuICAgICAgICAgIGYgYTtcbiAgICAgICAgICBsb29wIH5yZW1haW5pbmc6KHJlbWFpbmluZyAtIDEpXG4gICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IHZhbHVlc19hdmFpbGFibGUgdCA+Pj4gZnVuIF8gLT4gc3RhcnQgKCkpXG4gICAgaW5cbiAgICBzdGFydCAoKSlcbjs7XG5cbmxldCBkcmFpbiB0ID0gaXRlcicgdCB+ZjooZnVuIF8gLT4gcmV0dXJuICgpKVxubGV0IGRyYWluX2FuZF9jb3VudCB0ID0gZm9sZCcgdCB+aW5pdDowIH5mOihmdW4gc3VtIHEgLT4gcmV0dXJuIChzdW0gKyBRdWV1ZS5sZW5ndGggcSkpXG5cbmxldCByZWFkX2FsbCBpbnB1dCA9XG4gIGxldCByZXN1bHQgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0JW1hcCAoKSA9XG4gICAgaXRlcicgaW5wdXQgfmY6KGZ1biBxIC0+XG4gICAgICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6cSB+ZHN0OnJlc3VsdCAoKTtcbiAgICAgIHJldHVybiAoKSlcbiAgaW5cbiAgcmVzdWx0XG47O1xuXG5sZXQgdG9fbGlzdCByID0gcmVhZF9hbGwgciA+PnwgUXVldWUudG9fbGlzdFxuXG5sZXQgdG9fc3RyZWFtX2RlcHJlY2F0ZWQgdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgaXRlcl93aXRob3V0X3B1c2hiYWNrIHQgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeClcbiAgICA+Pj4gZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpXG47O1xuXG4oKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgW29mX3N0cmVhbV9kZXByZWNhdGVkXSBkb2VzIGFzIG11Y2ggYmF0Y2hpbmcgYXMgcG9zc2libGUuICBJdFxuICAgZ3JhYnMgYXMgbWFueSBpdGVtcyBhcyBhcmUgYXZhaWxhYmxlIGludG8gYW4gaW50ZXJuYWwgcXVldWUuICBPbmNlIGl0IGhhcyBncmFiYmVkXG4gICBldmVyeXRoaW5nLCBpdCB3cml0ZXMgaXQgdG8gdGhlIHBpcGUgYW5kIHRoZW4gYmxvY2tzIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGVsZW1lbnQgZnJvbVxuICAgdGhlIHN0cmVhbS5cblxuICAgVGhlcmUncyBubyBwb3NzaWJpbGl0eSB0aGF0IHdlJ2xsIHN0YXJ2ZSB0aGUgcGlwZSByZWFkaW5nIGFuIGVuZGxlc3Mgc3RyZWFtLCBqdXN0XG4gICBhY2N1bXVsYXRpbmcgdGhlIGVsZW1lbnRzIGludG8gb3VyIHByaXZhdGUgcXVldWUgZm9yZXZlciB3aXRob3V0IGV2ZXIgd3JpdGluZyB0aGVtXG4gICBkb3duc3RyZWFtIHRvIHRoZSBwaXBlLiAgV2h5PyBiZWNhdXNlIHdoaWxlIHdlJ3JlIHJ1bm5pbmcsIHRoZSBzdHJlYW0tcHJvZHVjZXIgKmlzbid0KlxuICAgcnVubmluZyAtLSB0aGVyZSBhcmUgbm8gQXN5bmMgYmxvY2sgcG9pbnRzIGluIHRoZSBxdWV1ZS1hY2N1bXVsYXRvciBsb29wLiAgU28gdGhlXG4gICBxdWV1ZS1hY2N1bXVsYXRvciBsb29wIHdpbGwgZXZlbnR1YWxseSBjYXRjaCB1cCB0byB0aGUgY3VycmVudCBzdHJlYW0gdGFpbCwgYXQgd2hpY2hcbiAgIHBvaW50IHdlJ2xsIGRvIHRoZSBwaXBlLXdyaXRlIGFuZCB0aGVuIGJsb2NrIG9uIHRoZSBzdHJlYW0uLi4gdGh1cyBnaXZpbmcgdGhlXG4gICBzdHJlYW0tcHJvZHVjZXIgYSBjaGFuY2UgdG8gbWFrZSBtb3JlIGVsZW1lbnRzLlxuXG4gICBPbmUgY2FuJ3QgaW1wbGVtZW50IFtvZl9zdHJlYW1dIHVzaW5nIFtTdHJlYW0uaXRlcl0gb3IgW1N0cmVhbS5pdGVyJ10gYmVjYXVzZSB5b3VcbiAgIG5lZWQgdG8gYmUgYWJsZSB0byBzdG9wIGVhcmx5IHdoZW4gdGhlIGNvbnN1bWVyIGNsb3NlcyB0aGUgcGlwZS4gIEFsc28sIHVzaW5nIGVpdGhlclxuICAgb2YgdGhvc2Ugd291bGQgZW50YWlsIHNpZ25pZmljYW50bHkgbW9yZSBkZWZlcnJlZCBvdmVyaGVhZCwgd2hlcmVhcyB0aGUgYmVsb3dcbiAgIGltcGxlbWVudGF0aW9uIHVzZXMgYSBkZWZlcnJlZCBvbmx5IHdoZW4gaXQgbmVlZHMgdG8gd2FpdCBmb3IgZGF0YSBmcm9tIHRoZSBzdHJlYW0uICopXG5sZXQgb2Zfc3RyZWFtX2RlcHJlY2F0ZWQgcyA9XG4gIGxldCByLCB3ID0gY3JlYXRlICgpIGluXG4gIGxldCBxID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCB0cmFuc2ZlciAoKSA9XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSBxKVxuICAgIHRoZW5cbiAgICAgICgqIENhbiBub3QgcHVzaGJhY2sgb24gdGhlIHN0cmVhbSwgc28gaWdub3JlIHRoZSBwdXNoYmFjayBvbiB0aGUgcGlwZS4gKilcbiAgICAgIGRvbid0X3dhaXRfZm9yICh3cml0ZScgdyBxKVxuICBpblxuICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgYXNzZXJ0IChub3QgKGlzX2Nsb3NlZCB3KSk7XG4gICAgbGV0IG5leHRfZGVmZXJyZWQgPSBTdHJlYW0ubmV4dCBzIGluXG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayBuZXh0X2RlZmVycmVkIHdpdGhcbiAgICB8IFNvbWUgbmV4dCAtPiBsb29wX25leHQgbmV4dFxuICAgIHwgTm9uZSAtPlxuICAgICAgdHJhbnNmZXIgKCk7XG4gICAgICB1cG9uIG5leHRfZGVmZXJyZWQgY2hlY2tfY2xvc2VkX2xvb3BfbmV4dFxuICBhbmQgY2hlY2tfY2xvc2VkX2xvb3BfbmV4dCBuZXh0ID0gaWYgbm90IChpc19jbG9zZWQgdykgdGhlbiBsb29wX25leHQgbmV4dFxuICBhbmQgbG9vcF9uZXh0ID0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPlxuICAgICAgdHJhbnNmZXIgKCk7XG4gICAgICBjbG9zZSB3XG4gICAgfCBDb25zICh4LCBzKSAtPlxuICAgICAgUXVldWUuZW5xdWV1ZSBxIHg7XG4gICAgICBsb29wIHNcbiAgaW5cbiAgbG9vcCBzO1xuICByXG47O1xuXG5sZXQgdHJhbnNmZXJfZ2VuXG4gICAgICAocmVhZF9ub3cgOiA/Y29uc3VtZXI6Q29uc3VtZXIudCAtPiBfIFJlYWRlci50IC0+IF8pXG4gICAgICB3cml0ZVxuICAgICAgaW5wdXRcbiAgICAgIG91dHB1dFxuICAgICAgfmZcbiAgPVxuICBpZiAhY2hlY2tfaW52YXJpYW50XG4gIHRoZW4gKFxuICAgIGludmFyaWFudCBpbnB1dDtcbiAgICBpbnZhcmlhbnQgb3V0cHV0KTtcbiAgbGV0IGxpbmsgPSBMaW5rLmNyZWF0ZSB+dXBzdHJlYW06aW5wdXQgfmRvd25zdHJlYW06b3V0cHV0IGluXG4gIGxldCBjb25zdW1lciA9IExpbmsuY29uc3VtZXIgbGluayBpblxuICAoKiBXaGVuIHdlJ3JlIGRvbmUgd2l0aCBbaW5wdXRdLCB3ZSB1bmxpbmsgdG8gcmVtb3ZlIHBvaW50ZXJzIGZyb21cbiAgICAgW291dHB1dF0gdG8gW2lucHV0XSwgd2hpY2ggd291bGQgY2F1c2UgYSBzcGFjZSBsZWFrIGlmIHdlIGhhZCBzaW5nbGUgbG9uZy1saXZlZFxuICAgICBvdXRwdXQgaW50byB3aGljaCB3ZSB0cmFuc2ZlciBsb3RzIG9mIHNob3J0LWxpdmVkIGlucHV0cy4gKilcbiAgbGV0IHVubGluayAoKSA9IExpbmsudW5saW5rX3Vwc3RyZWFtIGxpbmsgaW5cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgKCogV2UgZG8gW3JldHVybiAoKSA+Pj5dIHRvIGVuc3VyZSB0aGF0IFtmXSBpcyBvbmx5IGNhbGxlZCBhc3luY2hyb25vdXNseS4gKilcbiAgICByZXR1cm4gKClcbiAgICA+Pj4gZnVuICgpIC0+XG4gICAgbGV0IG91dHB1dF9jbG9zZWQgKCkgPVxuICAgICAgY2xvc2VfcmVhZCBpbnB1dDtcbiAgICAgIHVubGluayAoKTtcbiAgICAgIEl2YXIuZmlsbCByZXN1bHQgKClcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBpZiBpc19jbG9zZWQgb3V0cHV0XG4gICAgICB0aGVuIG91dHB1dF9jbG9zZWQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCByZWFkX25vdyBpbnB1dCB+Y29uc3VtZXIgd2l0aFxuICAgICAgICB8IGBFb2YgLT5cbiAgICAgICAgICB1bmxpbmsgKCk7XG4gICAgICAgICAgSXZhci5maWxsIHJlc3VsdCAoKVxuICAgICAgICB8IGBPayB4IC0+IGYgeCBjb250aW51ZVxuICAgICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgICAgICAgIGNob29zZVxuICAgICAgICAgICAgWyBjaG9pY2UgKHZhbHVlc19hdmFpbGFibGUgaW5wdXQpIGlnbm9yZTsgY2hvaWNlIChjbG9zZWQgb3V0cHV0KSBpZ25vcmUgXVxuICAgICAgICAgID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICBhbmQgY29udGludWUgeSA9XG4gICAgICBpZiBpc19jbG9zZWQgb3V0cHV0XG4gICAgICB0aGVuIG91dHB1dF9jbG9zZWQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcHVzaGJhY2sgPSB3cml0ZSBvdXRwdXQgeSBpblxuICAgICAgICBDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtIGNvbnN1bWVyO1xuICAgICAgICBwdXNoYmFjayA+Pj4gZnVuICgpIC0+IGxvb3AgKCkpXG4gICAgaW5cbiAgICBsb29wICgpKVxuOztcblxubGV0IHRyYW5zZmVyJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCBvdXRwdXQgfmYgPVxuICB0cmFuc2Zlcl9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IG91dHB1dCB+ZjooZnVuIHEgayAtPiBmIHEgPj4+IGspXG47O1xuXG5sZXQgdHJhbnNmZXIgaW5wdXQgb3V0cHV0IH5mID1cbiAgdHJhbnNmZXJfZ2VuIHJlYWRfbm93IHdyaXRlIGlucHV0IG91dHB1dCB+ZjooZnVuIGEgayAtPiBrIChmIGEpKVxuOztcblxubGV0IHRyYW5zZmVyX2lkID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IG91dHB1dCA9XG4gIHRyYW5zZmVyX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgb3V0cHV0IH5mOihmdW4gcSBrIC0+IGsgcSlcbjs7XG5cbmxldCBtYXBfZ2VuIHJlYWQgd3JpdGUgaW5wdXQgfmYgPVxuICBsZXQgaW5mbyA9IE9wdGlvbi5tYXAgaW5wdXQuaW5mbyB+ZjooZnVuIGluZm8gLT4gWyVzZXhwIE1hcHBlZCAoaW5mbyA6IFNleHAudCldKSBpblxuICBsZXQgcmVzdWx0LCBvdXRwdXQgPSBjcmVhdGUgP2luZm8gKCkgaW5cbiAgdXBvbiAodHJhbnNmZXJfZ2VuIHJlYWQgd3JpdGUgaW5wdXQgb3V0cHV0IH5mKSAoZnVuICgpIC0+IGNsb3NlIG91dHB1dCk7XG4gIHJlc3VsdFxuOztcblxubGV0IG1hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPiBmIHEgPj4+IGspXG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwX2dlbiByZWFkX25vdyB3cml0ZSBpbnB1dCB+ZjooZnVuIGEgayAtPiBrIChmIGEpKVxuXG5sZXQgY29uY2F0X21hcF9saXN0ID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mID1cbiAgbWFwX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgfmY6KGZ1biBxIGsgLT5cbiAgICBrIChRdWV1ZS5jb25jYXRfbWFwIHEgfmYpKVxuOztcblxubGV0IGZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mID1cbiAgbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZjooZnVuIHEgLT4gRGVmZXJyZWQuUXVldWUuZmlsdGVyX21hcCBxIH5mKVxuOztcblxubGV0IGZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPlxuICAgIGsgKFF1ZXVlLmZpbHRlcl9tYXAgcSB+ZjooZnVuIHggLT4gaWYgaXNfcmVhZF9jbG9zZWQgaW5wdXQgdGhlbiBOb25lIGVsc2UgZiB4KSkpXG47O1xuXG5sZXQgZm9sZGluZ19maWx0ZXJfbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2N1bSA9IHJlZiBpbml0IGluXG4gIGZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4geCAtPlxuICAgIGxldCVtYXAgYSwgeCA9IGYgIWFjY3VtIHggaW5cbiAgICBhY2N1bSA6PSBhO1xuICAgIHgpXG47O1xuXG5sZXQgZm9sZGluZ19maWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjY3VtID0gcmVmIGluaXQgaW5cbiAgZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZjooZnVuIHggLT5cbiAgICBsZXQgYSwgeCA9IGYgIWFjY3VtIHggaW5cbiAgICBhY2N1bSA6PSBhO1xuICAgIHgpXG47O1xuXG5sZXQgZm9sZGluZ19tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmYgPVxuICBmb2xkaW5nX2ZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmY6KGZ1biBhY2N1bSBhIC0+XG4gICAgbGV0IGFjY3VtLCBiID0gZiBhY2N1bSBhIGluXG4gICAgYWNjdW0sIFNvbWUgYilcbjs7XG5cbmxldCBmaWx0ZXIgaW5wdXQgfmYgPSBmaWx0ZXJfbWFwIGlucHV0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgbGV0IHQgPSBjcmVhdGVfaW50ZXJuYWwgfnNpemVfYnVkZ2V0OjAgfmluZm86Tm9uZSB+aW5pdGlhbF9idWZmZXI6KFF1ZXVlLm9mX2xpc3QgbCkgaW5cbiAgSXZhci5maWxsIHQuY2xvc2VkICgpO1xuICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgdFxuOztcblxubGV0IGVtcHR5ICgpID0gb2ZfbGlzdCBbXVxuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgcmVhZGVyLCB3cml0ZXIgPSBjcmVhdGUgKCkgaW5cbiAgd3JpdGVfd2l0aG91dF9wdXNoYmFjayB3cml0ZXIgeDtcbiAgY2xvc2Ugd3JpdGVyO1xuICByZWFkZXJcbjs7XG5cbmxldCB1bmZvbGQgfmluaXQ6cyB+ZiA9XG4gICgqIFRvIGdldCBzb21lIGJhdGNoaW5nLCB3ZSBydW4gdGhlIGNvbnRpbnVhdGlvbiBpbW1lZGlhdGVseSBpZiB0aGUgZGVmZXJyZWQgaXNcbiAgICAgZGV0ZXJtaW5lZC4gIEhvd2V2ZXIsIHdlIGFsd2F5cyBjaGVjayBmb3IgcHVzaGJhY2suICBCZWNhdXNlIHNpemUgYnVkZ2V0IGNhbid0IGJlXG4gICAgIGluZmluaXRlLCB0aGUgYmVsb3cgbG9vcCBpcyBndWFyYW50ZWVkIHRvIGV2ZW50dWFsbHkgeWllbGQgdG8gdGhlIHNjaGVkdWxlci4gKilcbiAgbGV0ICggPj49fiApIGQgZiA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayBkIHdpdGhcbiAgICB8IE5vbmUgLT4gZCA+Pj0gZlxuICAgIHwgU29tZSB4IC0+IGYgeFxuICBpblxuICBjcmVhdGVfcmVhZGVyIH5jbG9zZV9vbl9leGNlcHRpb246ZmFsc2UgKGZ1biB3cml0ZXIgLT5cbiAgICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgICBmIHNcbiAgICAgID4+PX4gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiByZXR1cm4gKClcbiAgICAgIHwgU29tZSAoYSwgcykgLT5cbiAgICAgICAgaWYgaXNfY2xvc2VkIHdyaXRlciB0aGVuIHJldHVybiAoKSBlbHNlIHdyaXRlIHdyaXRlciBhID4+PX4gZnVuICgpIC0+IGxvb3Agc1xuICAgIGluXG4gICAgbG9vcCBzKVxuOztcblxubGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgY3JlYXRlX3JlYWRlciB+Y2xvc2Vfb25fZXhjZXB0aW9uOmZhbHNlIChmdW4gd3JpdGVyIC0+XG4gICAgbGV0IHJlYyBlbnF1ZXVlX24gc2VxdWVuY2UgaSA9XG4gICAgICBpZiBpIDw9IDBcbiAgICAgIHRoZW4gc2VxdWVuY2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHNlcXVlbmNlIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHNlcXVlbmNlXG4gICAgICAgIHwgU29tZSAoYSwgc2VxdWVuY2UpIC0+XG4gICAgICAgICAgUXVldWUuZW5xdWV1ZSB3cml0ZXIuYnVmZmVyIGE7XG4gICAgICAgICAgZW5xdWV1ZV9uIHNlcXVlbmNlIChpIC0gMSkpXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3Agc2VxdWVuY2UgPVxuICAgICAgaWYgaXNfY2xvc2VkIHdyaXRlciB8fCBTZXF1ZW5jZS5pc19lbXB0eSBzZXF1ZW5jZVxuICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBzdGFydF93cml0ZSB3cml0ZXI7XG4gICAgICAgIGxldCBzZXF1ZW5jZSA9IGVucXVldWVfbiBzZXF1ZW5jZSAoMSArIHdyaXRlci5zaXplX2J1ZGdldCAtIGxlbmd0aCB3cml0ZXIpIGluXG4gICAgICAgIGZpbmlzaF93cml0ZSB3cml0ZXI7XG4gICAgICAgIGxldCViaW5kICgpID0gcHVzaGJhY2sgd3JpdGVyIGluXG4gICAgICAgIGxvb3Agc2VxdWVuY2UpXG4gICAgaW5cbiAgICBsb29wIHNlcXVlbmNlKVxuOztcblxudHlwZSAnYSB0b19zZXF1ZW5jZV9lbHQgPVxuICB8IFZhbHVlIG9mICdhXG4gIHwgV2FpdF9mb3IgOiBfIERlZmVycmVkLnQgLT4gXyB0b19zZXF1ZW5jZV9lbHRcblxubGV0IHRvX3NlcXVlbmNlIHQgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KCkgfmY6KGZ1biAoKSAtPlxuICAgIG1hdGNoIHJlYWRfbm93IHQgd2l0aFxuICAgIHwgYEVvZiAtPiBOb25lXG4gICAgfCBgT2sgYSAtPiBTb21lIChWYWx1ZSBhLCAoKSlcbiAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiBTb21lIChXYWl0X2ZvciAodmFsdWVzX2F2YWlsYWJsZSB0KSwgKCkpKVxuOztcblxubGV0IGludGVybGVhdmVfcGlwZSBpbnB1dHMgPVxuICBsZXQgb3V0cHV0LCBvdXRwdXRfd3JpdGVyID0gY3JlYXRlIH5pbmZvOlslc2V4cCBcIlBpcGUuaW50ZXJsZWF2ZVwiXSAoKSBpblxuICAoKiBXZSBrZWVwIGEgcmVmZXJlbmNlIGNvdW50IG9mIGFsbCB0aGUgcGlwZXMgdGhhdCBbaW50ZXJsZWF2ZV9waXBlXSBpcyBtYW5hZ2luZztcbiAgICAgW2lucHV0c10gY291bnRzIGFzIG9uZS4gIFdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBkcm9wcyB0byB6ZXJvLCB3ZSBrbm93IHRoYXQgYWxsXG4gICAgIHBpcGVzIGFyZSBjbG9zZWQgYW5kIHdlIGNhbiBjbG9zZSBbb3V0cHV0X3dyaXRlcl0uICopXG4gIGxldCBudW1fcGlwZXNfcmVtYWluaW5nID0gcmVmIDEgaW5cbiAgbGV0IGRlY3JfbnVtX3BpcGVzX3JlbWFpbmluZyAoKSA9XG4gICAgZGVjciBudW1fcGlwZXNfcmVtYWluaW5nO1xuICAgIGlmICFudW1fcGlwZXNfcmVtYWluaW5nID0gMCB0aGVuIGNsb3NlIG91dHB1dF93cml0ZXJcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0JW1hcCAoKSA9XG4gICAgICAgaXRlcl93aXRob3V0X3B1c2hiYWNrIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+XG4gICAgICAgICBpbmNyIG51bV9waXBlc19yZW1haW5pbmc7XG4gICAgICAgICBkb24ndF93YWl0X2ZvclxuICAgICAgICAgICAobGV0JW1hcCAoKSA9IHRyYW5zZmVyX2lkIGlucHV0IG91dHB1dF93cml0ZXIgaW5cbiAgICAgICAgICAgIGRlY3JfbnVtX3BpcGVzX3JlbWFpbmluZyAoKSkpXG4gICAgIGluXG4gICAgIGRlY3JfbnVtX3BpcGVzX3JlbWFpbmluZyAoKSk7XG4gICgqIGZvciBbaW5wdXRzXSAqKVxuICBvdXRwdXRcbjs7XG5cbmxldCBpbnRlcmxlYXZlIGlucHV0cyA9XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBMaXN0Lml0ZXIgaW5wdXRzIH5mOmludmFyaWFudDtcbiAgaW50ZXJsZWF2ZV9waXBlIChvZl9saXN0IGlucHV0cylcbjs7XG5cbmxldCBtZXJnZSBpbnB1dHMgfmNvbXBhcmUgPVxuICBtYXRjaCBpbnB1dHMgd2l0aFxuICB8IFtdIC0+IGVtcHR5ICgpXG4gIHwgWyBpbnB1dCBdIC0+IGlucHV0XG4gIHwgaW5wdXRzIC0+XG4gICAgbGV0IG1vZHVsZSBIZWFwID0gUGFpcmluZ19oZWFwIGluXG4gICAgbGV0IHIsIHcgPSBjcmVhdGUgKCkgaW5cbiAgICB1cG9uIChjbG9zZWQgdykgKGZ1biAoKSAtPiBMaXN0Lml0ZXIgaW5wdXRzIH5mOmNsb3NlX3JlYWQpO1xuICAgIGxldCBoZWFwID0gSGVhcC5jcmVhdGUgfmNtcDooZnVuIChhMSwgXykgKGEyLCBfKSAtPiBjb21wYXJlIGExIGEyKSAoKSBpblxuICAgIGxldCBoYW5kbGVfcmVhZCBpbnB1dCBlb2Zfb3Jfb2sgPVxuICAgICAgbWF0Y2ggZW9mX29yX29rIHdpdGhcbiAgICAgIHwgYEVvZiAtPiAoKVxuICAgICAgfCBgT2sgdiAtPiBIZWFwLmFkZCBoZWFwICh2LCBpbnB1dClcbiAgICBpblxuICAgIGxldCByZWMgcG9wX2hlYXBfYW5kX2xvb3AgKCkgPVxuICAgICAgKCogQXQgdGhpcyBwb2ludCwgYWxsIGlucHV0cyBub3QgYXQgRW9mIG9jY3VyIGluIFtoZWFwXSBleGFjdGx5IG9uY2UsIHNvIHdlIGtub3dcbiAgICAgICAgIHdoYXQgdGhlIG5leHQgb3V0cHV0IGVsZW1lbnQgaXMuICBbcG9wX2hlYXBfYW5kX2xvb3BdIHJlcGVhdGVkbHkgdGFrZXMgZWxlbWVudHNcbiAgICAgICAgIGZyb20gdGhlIGlucHV0cyBhcyBsb25nIGFzIGl0IGhhcyBvbmUgZnJvbSBlYWNoIGlucHV0LiAgVGhpcyBpcyBkb25lXG4gICAgICAgICBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGEgZGVmZXJyZWQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgb3V0cHV0IC0tXG4gICAgICAgICB0aGVyZSdzIG5vIG5lZWQgdG8gcHVzaGJhY2sgc2luY2UgdGhhdCBpcyBvbmx5IG1vdmluZyBlbGVtZW50cyBmcm9tIG9uZSBwaXBlIHRvXG4gICAgICAgICBhbm90aGVyLiAgQXMgc29vbiBhcyBbcG9wX2hlYXBfYW5kX2xvb3BdIGNhbid0IGdldCBhbiBlbGVtZW50IGZyb20gc29tZSBpbnB1dCwgaXRcbiAgICAgICAgIHdhaXRzIG9uIHB1c2hiYWNrIGZyb20gdGhlIG91dHB1dCwgc2luY2UgaXQgaGFzIHRvIHdhaXQgb24gdGhlIGlucHV0IGFueXdheS5cbiAgICAgICAgIFRoaXMgYWxzbyBwcmV2ZW50cyBbbWVyZ2VdIGZyb20gY29uc3VtaW5nIGlucHV0cyBhdCBhIHJhdGUgZmFzdGVyIHRoYW4gaXRzIG91dHB1dFxuICAgICAgICAgaXMgY29uc3VtZWQuICopXG4gICAgICBtYXRjaCBIZWFwLnBvcCBoZWFwIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBjbG9zZSB3XG4gICAgICB8IFNvbWUgKHYsIGlucHV0KSAtPlxuICAgICAgICBpZiBub3QgKGlzX2Nsb3NlZCB3KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHcgdjtcbiAgICAgICAgICBpZiBIZWFwLmxlbmd0aCBoZWFwID0gMFxuICAgICAgICAgIHRoZW4gdXBvbiAodHJhbnNmZXJfaWQgaW5wdXQgdykgKGZ1biAoKSAtPiBjbG9zZSB3KVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbWF0Y2ggcmVhZF9ub3cgaW5wdXQgd2l0aFxuICAgICAgICAgICAgfCAoYEVvZiB8IGBPayBfKSBhcyB4IC0+XG4gICAgICAgICAgICAgIGhhbmRsZV9yZWFkIGlucHV0IHg7XG4gICAgICAgICAgICAgIHBvcF9oZWFwX2FuZF9sb29wICgpXG4gICAgICAgICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgICAgICAgICAgICBwdXNoYmFjayB3XG4gICAgICAgICAgICAgID4+PiBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgcmVhZCBpbnB1dFxuICAgICAgICAgICAgICA+Pj4gZnVuIHggLT5cbiAgICAgICAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeDtcbiAgICAgICAgICAgICAgcG9wX2hlYXBfYW5kX2xvb3AgKCkpKVxuICAgIGluXG4gICAgbGV0IGluaXRpYWxfcHVzaCA9XG4gICAgICBEZWZlcnJlZC5MaXN0Lml0ZXIgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT5cbiAgICAgICAgbGV0JW1hcCB4ID0gcmVhZCBpbnB1dCBpblxuICAgICAgICBoYW5kbGVfcmVhZCBpbnB1dCB4KVxuICAgIGluXG4gICAgdXBvbiBpbml0aWFsX3B1c2ggcG9wX2hlYXBfYW5kX2xvb3A7XG4gICAgclxuOztcblxubGV0IGNvbmNhdF9waXBlIGlucHV0cyA9XG4gIGxldCByID1cbiAgICBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gKGZ1biB3IC0+XG4gICAgICBsZXQgbGluayA9IExpbmsuY3JlYXRlIH51cHN0cmVhbTppbnB1dHMgfmRvd25zdHJlYW06dyBpblxuICAgICAgbGV0IGNvbnN1bWVyID0gTGluay5jb25zdW1lciBsaW5rIGluXG4gICAgICBpdGVyIH5mbHVzaGVkOihDb25zdW1lciBjb25zdW1lcikgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT4gdHJhbnNmZXJfaWQgaW5wdXQgdykpXG4gIGluXG4gIHVwb24gKGNsb3NlZCByKSAoZnVuICgpIC0+IGNsb3NlIGlucHV0cyk7XG4gIHJcbjs7XG5cbmxldCBjb25jYXQgaW5wdXRzID1cbiAgY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uIChmdW4gdyAtPlxuICAgIERlZmVycmVkLkxpc3QuaXRlciBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPiB0cmFuc2Zlcl9pZCBpbnB1dCB3KSlcbjs7XG5cbmxldCBmb3JrIHQgfnB1c2hiYWNrX3VzZXMgPVxuICBsZXQgcmVhZGVyMCwgd3JpdGVyMCA9IGNyZWF0ZSAoKSBpblxuICBsZXQgcmVhZGVyMSwgd3JpdGVyMSA9IGNyZWF0ZSAoKSBpblxuICBsZXQgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCA9IHJlZiBmYWxzZSBpblxuICBsZXQgY29uc3VtZXIgPVxuICAgIGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgbGV0IHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgPSAhc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCBpblxuICAgICAgbWF0Y2glbWFwXG4gICAgICAgIEZsdXNoZWRfcmVzdWx0LmNvbWJpbmVcbiAgICAgICAgICBbIGRvd25zdHJlYW1fZmx1c2hlZCB3cml0ZXIwOyBkb3duc3RyZWFtX2ZsdXNoZWQgd3JpdGVyMSBdXG4gICAgICB3aXRoXG4gICAgICB8IGBSZWFkZXJfY2xvc2VkIC0+IGBSZWFkZXJfY2xvc2VkXG4gICAgICB8IGBPayAtPlxuICAgICAgICAoKiBJbiB0aGlzIGNhc2UsIHRoZXJlIGNvdWxkIGhhdmUgYmVlbiBubyBwZW5kaW5nIGl0ZW1zIGluIFt3cml0ZXIwXSBub3IgaW5cbiAgICAgICAgICAgW3dyaXRlcjFdLCBpbiB3aGljaCBjYXNlIHdlIGNvdWxkIGhhdmUgaGFkIGEgY2xvc2VkIHBpcGUgdGhhdCBtaXNzZWQgc29tZVxuICAgICAgICAgICB3cml0ZXMsIGJ1dCBbRmx1c2hlZF9yZXN1bHQuY29tYmluZV0gd291bGQgc3RpbGwgaGF2ZSByZXR1cm5lZCBbYE9rXSAqKVxuICAgICAgICBpZiBzb21lX3JlYWRlcl93YXNfY2xvc2VkIHRoZW4gYFJlYWRlcl9jbG9zZWQgZWxzZSBgT2spXG4gIGluXG4gIGRvbid0X3dhaXRfZm9yXG4gICAgKGxldCBzdGlsbF9vcGVuID0gWyB3cml0ZXIwOyB3cml0ZXIxIF0gaW5cbiAgICAgbGV0IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gPVxuICAgICAgICgqIE9ubHkgY2FsbCBbZmlsdGVyXSBhbmQgcmVhbGxvY2F0ZSBsaXN0IGlmIHNvbWV0aGluZyB3aWxsIGdldCBmaWx0ZXJlZCAqKVxuICAgICAgIGlmIG5vdCAoTGlzdC5leGlzdHMgc3RpbGxfb3BlbiB+Zjppc19jbG9zZWQpXG4gICAgICAgdGhlbiBzdGlsbF9vcGVuXG4gICAgICAgZWxzZSAoXG4gICAgICAgICBzb21lX3JlYWRlcl93YXNfY2xvc2VkIDo9IHRydWU7XG4gICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IExpc3QuZmlsdGVyIHN0aWxsX29wZW4gfmY6KGZ1biB3IC0+IG5vdCAoaXNfY2xvc2VkIHcpKSBpblxuICAgICAgICAgaWYgTGlzdC5pc19lbXB0eSBzdGlsbF9vcGVuIHRoZW4gY2xvc2UgdDtcbiAgICAgICAgIHN0aWxsX29wZW4pXG4gICAgIGluXG4gICAgIGxldCViaW5kIHN0aWxsX29wZW4gPVxuICAgICAgIGZvbGQnIHQgfmZsdXNoZWQ6KENvbnN1bWVyIGNvbnN1bWVyKSB+aW5pdDpzdGlsbF9vcGVuIH5mOihmdW4gc3RpbGxfb3BlbiBxdWV1ZSAtPlxuICAgICAgICAgbGV0IHN0aWxsX29wZW4gPSBmaWx0ZXJfb3BlbiBzdGlsbF9vcGVuIGluXG4gICAgICAgICBpZiBMaXN0LmlzX2VtcHR5IHN0aWxsX29wZW5cbiAgICAgICAgIHRoZW4gcmV0dXJuIFtdXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgbGV0JW1hcCAoKSA9XG4gICAgICAgICAgICAgbWF0Y2ggcHVzaGJhY2tfdXNlcyB3aXRoXG4gICAgICAgICAgICAgfCBgRmFzdF9jb25zdW1lcl9vbmx5IC0+IERlZmVycmVkLmFueSAoTGlzdC5tYXAgc3RpbGxfb3BlbiB+ZjpwdXNoYmFjaylcbiAgICAgICAgICAgICB8IGBCb3RoX2NvbnN1bWVycyAtPiBEZWZlcnJlZC5hbGxfdW5pdCAoTGlzdC5tYXAgc3RpbGxfb3BlbiB+ZjpwdXNoYmFjaylcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbGV0IHN0aWxsX29wZW4gPSBmaWx0ZXJfb3BlbiBzdGlsbF9vcGVuIGluXG4gICAgICAgICAgIExpc3QuaXRlciBzdGlsbF9vcGVuIH5mOihmdW4gdyAtPiBjb3B5X2luX3dpdGhvdXRfcHVzaGJhY2sgdyB+ZnJvbTpxdWV1ZSk7XG4gICAgICAgICAgIHN0aWxsX29wZW4pKVxuICAgICBpblxuICAgICBMaXN0Lml0ZXIgc3RpbGxfb3BlbiB+ZjpjbG9zZTtcbiAgICAgcmV0dXJuICgpKTtcbiAgcmVhZGVyMCwgcmVhZGVyMVxuOztcblxubGV0IHNldF9pbmZvIHQgaW5mbyA9IHNldF9pbmZvIHQgKFNvbWUgaW5mbylcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgdCA9XG4gIHsgY3VycmVudF92YWx1ZSA6ICdhIE1vcHRpb24udFxuICA7IHRha2VuIDogKHVuaXQsIHJlYWRfd3JpdGUpIEJ2YXIudFxuICA7IG11dGFibGUgdmFsdWVfYXZhaWxhYmxlIDogdW5pdCBJdmFyLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgdmFsdWVfYXZhaWxhYmxlIHQgPSBJdmFyLnJlYWQgdC52YWx1ZV9hdmFpbGFibGVcbmxldCBpc19lbXB0eSB0ID0gTW9wdGlvbi5pc19ub25lIHQuY3VycmVudF92YWx1ZVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gKHQgOiBfIHQpID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y3VycmVudF92YWx1ZTooY2hlY2sgKE1vcHRpb24uaW52YXJpYW50IGludmFyaWFudF9hKSlcbiAgICAgIH50YWtlbjooY2hlY2sgKEJ2YXIuaW52YXJpYW50IFVuaXQuaW52YXJpYW50IGlnbm9yZSkpXG4gICAgICB+dmFsdWVfYXZhaWxhYmxlOlxuICAgICAgICAoY2hlY2sgKGZ1biB2YWx1ZV9hdmFpbGFibGUgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAoSXZhci5pc19mdWxsIHZhbHVlX2F2YWlsYWJsZSlcbiAgICAgICAgICAgICB+ZXhwZWN0OihNb3B0aW9uLmlzX3NvbWUgdC5jdXJyZW50X3ZhbHVlKSkpKVxuOztcblxubGV0IHBlZWsgdCA9IE1vcHRpb24uZ2V0IHQuY3VycmVudF92YWx1ZVxuXG5sZXQgcGVla19leG4gdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIk12YXIucGVla19leG4gY2FsbGVkIG9uIGVtcHR5IG12YXJcIl07XG4gIE1vcHRpb24uZ2V0X3NvbWVfZXhuIHQuY3VycmVudF92YWx1ZVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gWyVzZXhwIChwZWVrIHQgOiBhIG9wdGlvbildXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAoJ2EsIHJlYWRfd3JpdGUpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5tb2R1bGUgUmVhZF9vbmx5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAoJ2EsIHJlYWQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5sZXQgcmVhZF9vbmx5ICh0IDogKCdhLCBbPiByZWFkIF0pIHQpID0gKHQgOj4gKCdhLCByZWFkKSB0KVxubGV0IHdyaXRlX29ubHkgKHQgOiAoJ2EsIFs+IHdyaXRlIF0pIHQpID0gKHQgOj4gKCdhLCB3cml0ZSkgdClcblxubGV0IGNyZWF0ZSAoKSA9XG4gIHsgY3VycmVudF92YWx1ZSA9IE1vcHRpb24uY3JlYXRlICgpXG4gIDsgdGFrZW4gPSBCdmFyLmNyZWF0ZSAoKVxuICA7IHZhbHVlX2F2YWlsYWJsZSA9IEl2YXIuY3JlYXRlICgpXG4gIH1cbjs7XG5cbmxldCB0YWtlX25vbmVtcHR5IHQgPVxuICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICBsZXQgciA9IE1vcHRpb24uZ2V0X3NvbWVfZXhuIHQuY3VycmVudF92YWx1ZSBpblxuICBNb3B0aW9uLnNldF9ub25lIHQuY3VycmVudF92YWx1ZTtcbiAgQnZhci5icm9hZGNhc3QgdC50YWtlbiAoKTtcbiAgdC52YWx1ZV9hdmFpbGFibGUgPC0gSXZhci5jcmVhdGUgKCk7XG4gIHJcbjs7XG5cbmxldCB0YWtlX25vd19leG4gdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIk12YXIudGFrZV9leG4gY2FsbGVkIG9uIGVtcHR5IG12YXJcIl07XG4gIHRha2Vfbm9uZW1wdHkgdFxuOztcblxubGV0IHRha2Vfbm93IHQgPSBpZiBub3QgKGlzX2VtcHR5IHQpIHRoZW4gU29tZSAodGFrZV9ub25lbXB0eSB0KSBlbHNlIE5vbmVcblxubGV0IHJlYyB0YWtlIHQgPVxuICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gIHRoZW4gcmV0dXJuICh0YWtlX25vbmVtcHR5IHQpXG4gIGVsc2UgKFxuICAgIGxldCViaW5kICgpID0gdmFsdWVfYXZhaWxhYmxlIHQgaW5cbiAgICB0YWtlIHQpXG47O1xuXG5sZXQgc2V0IHQgdiA9XG4gIE1vcHRpb24uc2V0X3NvbWUgdC5jdXJyZW50X3ZhbHVlIHY7XG4gIEl2YXIuZmlsbF9pZl9lbXB0eSB0LnZhbHVlX2F2YWlsYWJsZSAoKVxuOztcblxubGV0IHVwZGF0ZSB0IH5mID0gc2V0IHQgKGYgKHBlZWsgdCkpXG5sZXQgdXBkYXRlX2V4biB0IH5mID0gc2V0IHQgKGYgKHBlZWtfZXhuIHQpKVxubGV0IHRha2VuIHQgPSBCdmFyLndhaXQgdC50YWtlblxuXG5sZXQgcmVjIHB1dCB0IHYgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gKFxuICAgIHNldCB0IHY7XG4gICAgcmV0dXJuICgpKVxuICBlbHNlIChcbiAgICBsZXQlYmluZCAoKSA9IHRha2VuIHQgaW5cbiAgICBwdXQgdCB2KVxuOztcblxubGV0IHBpcGVfd2hlbl9yZWFkeSB0ID1cbiAgbGV0IHIsIHcgPSBQaXBlLmNyZWF0ZSAoKSBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIGxldCViaW5kICgpID0gdmFsdWVfYXZhaWxhYmxlIHQgaW5cbiAgICBpZiBub3QgKFBpcGUuaXNfY2xvc2VkIHcpXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCB0YWtlX25vdyB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wICgpXG4gICAgICB8IFNvbWUgeCAtPlxuICAgICAgICBsZXQlYmluZCAoKSA9IFBpcGUud3JpdGUgdyB4IGluXG4gICAgICAgIGxvb3AgKCkpXG4gICAgZWxzZSByZXR1cm4gKClcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3IgKGxvb3AgKCkpO1xuICByXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgc3RhcnQgOiB1bml0IEl2YXIudFxuICAgIDsgcmVzdWx0IDogJ2EgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgfVxuXG4gIGxldCBjcmVhdGUgZiA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICB7IHN0YXJ0XG4gICAgOyByZXN1bHQgPVxuICAgICAgICAobGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgc3RhcnQgaW5cbiAgICAgICAgIE1vbml0b3IudHJ5X3dpdGhfb3JfZXJyb3JcbiAgICAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICAgICBmKVxuICAgIH1cbiAgOztcblxuICBsZXQgY3JlYXRlX29yX2Vycm9yIGYgPVxuICAgIGxldCBzdGFydCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgeyBzdGFydFxuICAgIDsgcmVzdWx0ID1cbiAgICAgICAgKGxldCViaW5kICgpID0gSXZhci5yZWFkIHN0YXJ0IGluXG4gICAgICAgICBNb25pdG9yLnRyeV93aXRoX2pvaW5fb3JfZXJyb3JcbiAgICAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICAgICBmKVxuICAgIH1cbiAgOztcblxuICBsZXQgd2FpdCB0ID0gdC5yZXN1bHRcbiAgbGV0IHdhaXRfZXhuIHQgPSB3YWl0IHQgPj58IG9rX2V4blxuICBsZXQgc3RhcnQgdCA9IEl2YXIuZmlsbF9pZl9lbXB0eSB0LnN0YXJ0ICgpXG5cbiAgbGV0IGZvcmNlIHQgPVxuICAgIHN0YXJ0IHQ7XG4gICAgd2FpdCB0XG4gIDs7XG5cbiAgbGV0IGZvcmNlX2V4biB0ID0gZm9yY2UgdCA+Pnwgb2tfZXhuXG4gIGxldCByZXR1cm4gYSA9IGNyZWF0ZSAoZnVuICgpIC0+IHJldHVybiBhKVxuXG4gIGxldCBiaW5kIHQgfmYgPVxuICAgIGNyZWF0ZSAoZnVuICgpIC0+XG4gICAgICBsZXQlYmluZCBhID0gZm9yY2VfZXhuIHQgaW5cbiAgICAgIGZvcmNlX2V4biAoZiBhKSlcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBjcmVhdGUgKGZ1biAoKSAtPiBmb3JjZV9leG4gdCA+PnwgZilcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIE1vbmFkLk1ha2UgKFQpXG5cbmxldCBiaW5kJyB0IGYgPSBiaW5kIHQgfmY6KGZ1biBhIC0+IGNyZWF0ZSAoZnVuICgpIC0+IGYgYSkpXG5sZXQgaXNfZm9yY2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5zdGFydFxubGV0IGlzX2RldGVybWluZWQgdCA9IERlZmVycmVkLmlzX2RldGVybWluZWQgdC5yZXN1bHRcbmxldCBwZWVrIHQgPSBEZWZlcnJlZC5wZWVrIHQucmVzdWx0XG5sZXQgcGVla19leG4gdCA9IE9wdGlvbi5tYXAgKHBlZWsgdCkgfmY6b2tfZXhuXG4iLCJvcGVuIENvcmVcblxudHlwZSAnYSB0ID0geyB3YWl0cyA6ICdhIEl2YXIudCBRdWV1ZS50IH0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGNyZWF0ZSAoKSA9IHsgd2FpdHMgPSBRdWV1ZS5jcmVhdGUgKCkgfVxubGV0IHdhaXQgdCA9IERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT4gUXVldWUuZW5xdWV1ZSB0LndhaXRzIGl2YXIpXG5sZXQgc2lnbmFsIHQgYSA9IE9wdGlvbi5pdGVyIChRdWV1ZS5kZXF1ZXVlIHQud2FpdHMpIH5mOihmdW4gaXZhciAtPiBJdmFyLmZpbGwgaXZhciBhKVxuXG5sZXQgYnJvYWRjYXN0IHQgYSA9XG4gIFF1ZXVlLml0ZXIgdC53YWl0cyB+ZjooZnVuIGl2YXIgLT4gSXZhci5maWxsIGl2YXIgYSk7XG4gIFF1ZXVlLmNsZWFyIHQud2FpdHNcbjs7XG4iLCJvcGVuIENvcmVcbmluY2x1ZGUgR2NcblxuKCoqIFthZGRfZmluYWxpemVyIGYgeF0gaXMgbGlrZSBbR2MuZmluYWxpc2UgZiB4XSwgZXhjZXB0IHRoYXQgdGhlIGZpbmFsaXplciBpcyBndWFyYW50ZWVkXG4gICAgdG8gcnVuIGFzIGFuIEFzeW5jIGpvYiAoaS5lLiB3aXRob3V0IGludGVycnVwdGluZyBvdGhlciBBc3luYyBqb2JzKS4gIFVucHJvdGVjdGVkIHVzZVxuICAgIG9mIFtDYW1sLkdjLmZpbmFsaXNlXSBvciBbQ29yZS5HYy5hZGRfZmluYWxpemVyXSBpbiBBc3luYyBwcm9ncmFtcyBpcyB3cm9uZywgYmVjYXVzZVxuICAgIHRoZSBmaW5hbGl6ZXJzIHdvbid0IGhvbGQgdGhlIGFzeW5jIGxvY2ssIGFuZCB0aHVzIGNvdWxkIGludGVybGVhdmUgYXJiaXRyYXJpbHkgd2l0aFxuICAgIGFzeW5jIGpvYnMuICopXG5sZXQgYWRkX2ZpbmFsaXplciBoZWFwX2Jsb2NrIGYgPSBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXIgKHQgKCkpKSBoZWFwX2Jsb2NrIGZcblxubGV0IGFkZF9maW5hbGl6ZXJfZXhuIGhlYXBfYmxvY2sgZiA9IFNjaGVkdWxlci4oYWRkX2ZpbmFsaXplcl9leG4gKHQgKCkpKSBoZWFwX2Jsb2NrIGZcbmxldCBhZGRfZmluYWxpemVyX2xhc3QgaGVhcF9ibG9jayBmID0gU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2xhc3QgKHQgKCkpKSBoZWFwX2Jsb2NrIGZcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gaGVhcF9ibG9jayBmID1cbiAgU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2xhc3RfZXhuICh0ICgpKSkgaGVhcF9ibG9jayBmXG47O1xuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgbW9kdWxlIEFsYXJtID0gR2MuRXhwZXJ0LkFsYXJtXG5cbiAgdHlwZSB0ID0gQWxhcm0udCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBjcmVhdGUgZiA9IFNjaGVkdWxlci4oY3JlYXRlX2FsYXJtICh0ICgpKSkgZlxuICBsZXQgZGVsZXRlID0gQWxhcm0uZGVsZXRlXG5lbmRcbiIsIigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIHNpZ25hdHVyZXMgdGhhdCBleHRlbmQgW0NvcmUuSW52YXJpYW50XSB3aXRoIGFuIFtBc3luY11cbiAgICBzdWJtb2R1bGUgZm9yIGludmFyaWFudHMgdGhhdCB1c2UgYXN5bmMgY29tcHV0YXRpb24gYW5kIHJldHVybiBbdW5pdCBEZWZlcnJlZC50XS4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBc3luYyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiB1bml0IERlZmVycmVkLnRcbiAgdHlwZSAnYSBpbnYgPSAnYSB0XG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGludmFyaWFudCA6IHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogJ2EgaW52IC0+ICdhIHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogJ2EgaW52IC0+ICdiIGludiAtPiAoJ2EsICdiKSB0IGludlxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2IgaW52IC0+ICdjIGludiAtPiAoJ2EsICdiLCAnYykgdCBpbnZcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgQXN5bmNfaW52YXJpYW50ID0gc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgQ29yZS5JbnZhcmlhbnRcblxuICBtb2R1bGUgQXN5bmMgOiBzaWdcbiAgICBvcGVuIEFzeW5jXG5cbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgQXN5bmMudFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gICAgbW9kdWxlIHR5cGUgUzIgPSBTMlxuICAgIG1vZHVsZSB0eXBlIFMzID0gUzNcblxuICAgIHZhbCBpbnZhcmlhbnRcbiAgICAgIDogIFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnRcbiAgICAgIC0+ICdhXG4gICAgICAtPiAoJ2EgLT4gU2V4cC50KVxuICAgICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgICAgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgICAoKiogW2NoZWNrX2ZpZWxkXSBjYW4gYmUgdXNlZCB0byBjaGVjayByZWNvcmQgZmllbGRzIHdoZW4gdXNpbmcgW1tAQGRlcml2aW5nIGZpZWxkc11dLlxuICAgICAgICBJZGlvbWF0aWMgdXNhZ2UgbG9va3MgbGlrZTpcblxuICAgICAgICB7W1xuICAgICAgICAgIHR5cGUgdCA9IHsgZm9vIDogRm9vLnQgOyBiYXIgOiBCYXIudCB9XG4gICAgICAgICAgW0BAZGVyaXZpbmcgZmllbGRzXVxuXG4gICAgICAgICAgbGV0IGludmFyaWFudCB0ID1cbiAgICAgICAgICAgIEludmFyaWFudC5Bc3luYy5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBsZXQgY2hlY2sgaW52ID0gSW52YXJpYW50LkFzeW5jLmNoZWNrX2ZpZWxkIHQgaW52IGluXG4gICAgICAgICAgICAgIEZpZWxkcy5mb2xkIH5pbml0OihyZXR1cm4gKCkpXG4gICAgICAgICAgICAgICAgfmZvbzogKGNoZWNrIEZvby5pbnZhcmlhbnQpXG4gICAgICAgICAgICAgICAgfmJhcjogKGNoZWNrIEJhci5pbnZhcmlhbnQpIF19XG5cbiAgICAgICAgV2hlbiBzb21lIGZpZWxkcyBoYXZlIHN5bmNocm9ub3VzIGludmFyaWFudHMsIG9yIGRvIG5vdCBuZWVkIHRvIGJlIGNoZWNrZWQsIGl0XG4gICAgICAgIG1heSBiZSB1c2VmdWwgdG8gZGVmaW5lIGEgc2Vjb25kIHdyYXBwZXIgYXJvdW5kIFtjaGVja19maWVsZF06XG5cbiAgICAgICAge1tcbiAgICAgICAgICB0eXBlIHQgPSB7IGZvbyA6IEZvby50IDsgYmFyIDogQmFyLnQgOyBxdXV4IDogUXV1eC50IH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICAgICAgICBsZXQgaW52YXJpYW50IHQgPVxuICAgICAgICAgICAgSW52YXJpYW50LkFzeW5jLmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBjaGVjaycgaW52ID0gSW52YXJpYW50LkFzeW5jLmNoZWNrX2ZpZWxkIHQgaW52IGluXG4gICAgICAgICAgICAgIGxldCBjaGVjayBpbnYgPSBjaGVjaycgKGZ1biB4IC0+IGludiB4OyByZXR1cm4gKCkpIGluXG4gICAgICAgICAgICAgIEZpZWxkcy5mb2xkIH5pbml0OihyZXR1cm4gKCkpXG4gICAgICAgICAgICAgICAgfmZvbzogIChjaGVjaycgRm9vLmludmFyaWFudClcbiAgICAgICAgICAgICAgICB+YmFyOiAgKGNoZWNrICBCYXIuaW52YXJpYW50KVxuICAgICAgICAgICAgICAgIH5xdXV4OiAoY2hlY2sgIGlnbm9yZSkgXX0gKilcbiAgICB2YWwgY2hlY2tfZmllbGQgOiAnYSAtPiAnYiB0IC0+IHVuaXQgRGVmZXJyZWQudCAtPiAoJ2EsICdiKSBGaWVsZC50IC0+IHVuaXQgRGVmZXJyZWQudFxuICBlbmRcbmVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgRGVmZXJyZWQuTGV0X3N5bnRheFxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvcmUuSW52YXJpYW50XG5cbm1vZHVsZSBBc3luYyA9IHN0cnVjdFxuICBpbmNsdWRlIEFzeW5jX2ludmFyaWFudF9pbnRmLkFzeW5jXG5cbiAgbGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cnVuOlxuICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIGZcbiAgICAgICAgfmV4dHJhY3RfZXhuOnRydWVcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiIH5fOihoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCkgKGV4biA6IGV4bikgfl86KHQgOiB0KV1cbiAgOztcblxuICBsZXQgY2hlY2tfZmllbGQgdCBmIHdhaXRfZm9yX3ByZXZpb3VzIGZpZWxkID1cbiAgICBsZXQlYmluZCAoKSA9IHdhaXRfZm9yX3ByZXZpb3VzIGluXG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgIH5ydW46XG4gICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgfmV4dHJhY3RfZXhuOnRydWVcbiAgICAgICAgKGZ1biAoKSAtPiBmIChGaWVsZC5nZXQgZmllbGQgdCkpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIGV4biAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJwcm9ibGVtIHdpdGggZmllbGRcIiB+ZmllbGQ6KEZpZWxkLm5hbWUgZmllbGQgOiBzdHJpbmcpIChleG4gOiBleG4pXVxuICA7O1xuZW5kXG4iLCIoKiogQ29udGFpbnMgQXN5bmMncyBjb3JlIGRhdGEgc3RydWN0dXJlcywgbGlrZSB7eyFBc3luY19rZXJuZWwuRGVmZXJyZWR9W0RlZmVycmVkXX0sXG4gICAge3shQXN5bmNfa2VybmVsLkl2YXJ9W0l2YXJdfSwgYW5kIHt7IUFzeW5jX2tlcm5lbC5DbG9ja19pbnRmLkNsb2NrfVtDbG9ja119LlxuXG4gICAgW0FzeW5jX2tlcm5lbF0gaXMgZGVzaWduZWQgdG8gZGVwZW5kIG9ubHkgb24ge3shQ29yZX1bQ29yZV19IGFuZCBzbyBpcyBtb3JlXG4gICAgcGxhdGZvcm0taW5kZXBlbmRlbnQuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEFzeW5jX2tlcm5lbF9jb25maWcgPSBBc3luY19rZXJuZWxfY29uZmlnXG5tb2R1bGUgQXN5bmNfa2VybmVsX3JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2UgPSBSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9zY2hlZHVsZXJcbm1vZHVsZSBCdmFyID0gQnZhclxubW9kdWxlIENsb2NrX25zID0gQ2xvY2tfbnNcbm1vZHVsZSBDb25kaXRpb24gPSBBc3luY19jb25kaXRpb25cbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkXG5tb2R1bGUgRXhlY3V0aW9uX2NvbnRleHQgPSBFeGVjdXRpb25fY29udGV4dFxubW9kdWxlIEdjID0gQXN5bmNfZ2Ncbm1vZHVsZSBJbnZhcmlhbnQgPSBBc3luY19pbnZhcmlhbnRcbm1vZHVsZSBJdmFyID0gSXZhclxubW9kdWxlIExhenlfZGVmZXJyZWQgPSBMYXp5X2RlZmVycmVkXG5tb2R1bGUgTW9uYWRfc2VxdWVuY2UgPSBNb25hZF9zZXF1ZW5jZVxubW9kdWxlIE1vbml0b3IgPSBNb25pdG9yXG5tb2R1bGUgTXZhciA9IE12YXJcbm1vZHVsZSBQaXBlID0gUGlwZVxubW9kdWxlIFByaW9yaXR5ID0gUHJpb3JpdHlcbm1vZHVsZSBTZXF1ZW5jZXIgPSBUaHJvdHRsZS5TZXF1ZW5jZXJcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cbm1vZHVsZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZSA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlXG5tb2R1bGUgVGFpbCA9IFRhaWxcbm1vZHVsZSBUaHJvdHRsZSA9IFRocm90dGxlXG5tb2R1bGUgVGltZV9zb3VyY2UgPSBUaW1lX3NvdXJjZVxuXG5cbigqKiB7MiBUb3BsZXZlbCBmdW5jdGlvbnMgfVxuXG4gICAgVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYnJvYWRseSB1c2VmdWwgd2hlbiB3cml0aW5nIEFzeW5jIHByb2dyYW1zLCBhbmQgc28gYXJlIG1hZGVcbiAgICBhdmFpbGFibGUgYXQgdGhlIHRvcGxldmVsLiAqKVxuXG5cbmxldCBhZnRlciA9IENsb2NrX25zLmFmdGVyXG5sZXQgYXQgPSBDbG9ja19ucy5hdFxubGV0IGNhdGNoID0gTW9uaXRvci5jYXRjaFxubGV0IGNob2ljZSA9IERlZmVycmVkLmNob2ljZVxubGV0IGNob29zZSA9IERlZmVycmVkLmNob29zZVxubGV0IGRvbid0X3dhaXRfZm9yID0gRGVmZXJyZWQuZG9uJ3Rfd2FpdF9mb3JcbmxldCBldmVyeSA9IENsb2NrX25zLmV2ZXJ5XG5sZXQgbmV2ZXIgPSBEZWZlcnJlZC5uZXZlclxubGV0IHNjaGVkdWxlID0gU2NoZWR1bGVyLnNjaGVkdWxlXG5sZXQgc2NoZWR1bGUnID0gU2NoZWR1bGVyLnNjaGVkdWxlJ1xubGV0IHRyeV93aXRoID0gTW9uaXRvci50cnlfd2l0aFxubGV0IHVwb24gPSBEZWZlcnJlZC51cG9uXG5sZXQgd2l0aF90aW1lb3V0ID0gQ2xvY2tfbnMud2l0aF90aW1lb3V0XG5sZXQgd2l0aGluID0gU2NoZWR1bGVyLndpdGhpblxubGV0IHdpdGhpbicgPSBTY2hlZHVsZXIud2l0aGluJ1xuXG4oKiogezIgSW5maXggb3BlcmF0b3JzIGFuZCBbTGV0X3N5bnRheF0gc3VwcG9ydH0gKilcblxuaW5jbHVkZSAoRGVmZXJyZWQgOiBNb25hZC5JbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBEZWZlcnJlZC50KVxuXG4oKiogZXF1aXZhbGVudCB0byB7IURlZmVycmVkLnVwb259LiAqKVxubGV0ICggPj4+ICkgPSBEZWZlcnJlZC5JbmZpeC4oID4+PiApXG5cbigqKiBlcXVpdmFsZW50IHRvIHshRGVmZXJyZWQuUmVzdWx0LmJpbmR9LiAqKVxubGV0ICggPj49PyApID0gRGVmZXJyZWQuUmVzdWx0LiggPj49IClcblxuKCoqIGVxdWl2YWxlbnQgdG8geyFEZWZlcnJlZC5SZXN1bHQubWFwfS4gKilcbmxldCAoID4+fD8gKSA9IERlZmVycmVkLlJlc3VsdC4oID4+fCApXG5cbmluY2x1ZGUgRGVmZXJyZWQuTGV0X3N5bnRheFxuXG4oKiovKiopXG5cbigqKiBUaGUgbW9kdWxlcyBpbiBbQXN5bmNfa2VybmVsX3ByaXZhdGVdIGFyZSB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgYW5kIHRlc3RpbmcgQXN5bmMsIGFuZFxuICAgIHNob3VsZCBub3Qgb3RoZXJ3aXNlIGJlIHVzZWQuICopXG5tb2R1bGUgQXN5bmNfa2VybmVsX3ByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIERlYnVnID0gRGVidWdcbiAgbW9kdWxlIEl2YXIwID0gSXZhcjBcbiAgbW9kdWxlIEl2YXJfZmlsbGVyID0gSXZhcl9maWxsZXJcbiAgbW9kdWxlIEpvYiA9IEpvYlxuICBtb2R1bGUgU3RhY2tfb3JfY291bnRlciA9IFN0YWNrX29yX2NvdW50ZXJcbmVuZFxuXG4oKiovKiopXG5cbigqIFRoaXMgdGVzdCBtdXN0IGJlIGluIHRoaXMgbGlicmFyeSwgYmVjYXVzZSBpdCByZXF1aXJlcyBbcmV0dXJuXSB0byBiZSBpbmxpbmVkLiAgTW92aW5nXG4gICBpdCB0byBhbm90aGVyIGxpYnJhcnkgd2lsbCBjYXVzZSBpdCB0byBicmVhayB3aXRoIFtYX0xJQlJBUllfSU5MSU5JTkc9ZmFsc2VdLiAqKVxubGV0JXRlc3RfdW5pdCBcIltyZXR1cm4gKCldIGRvZXMgbm90IGFsbG9jYXRlXCIgPVxuICBsZXQgdzEgPSBHYy5taW5vcl93b3JkcyAoKSBpblxuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKHJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKERlZmVycmVkLnJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKERlZmVycmVkLkxldF9zeW50YXgucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQuTGV0X3N5bnRheC5MZXRfc3ludGF4LnJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBsZXQgdzIgPSBHYy5taW5vcl93b3JkcyAoKSBpblxuICBbJXRlc3RfcmVzdWx0OiBpbnRdIHcyIH5leHBlY3Q6dzFcbjs7XG4iXX0=
