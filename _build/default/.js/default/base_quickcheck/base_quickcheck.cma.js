// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck = [0];
   runtime.caml_register_global(0, Base_quickcheck, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _s_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _s_),
     _u_ = caml_ba_dim_1(t) - 1 | 0,
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[19][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _r_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _r_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var
     _p_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _p_),
     _q_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[27],
             _q_,
             function(i){return caml_ba_get_1(t, i + offset | 0);});
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[90], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _o_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[116], state, _o_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _h_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _h_),
     _j_ = caml_ba_dim_1(t) - 1 | 0,
     _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      var _l_ = caml_ba_dim_2(t) - 1 | 0, _k_ = 0;
      if(_l_ >= 0){
       var j = _k_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _n_ = j + 1 | 0;
        if(_l_ === j) break;
        j = _n_;
       }
      }
      var _m_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _m_;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[20][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(param, _g_, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var
     _d_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _d_),
     _e_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[27],
             _e_,
             function(i){
              var _f_ = caml_ba_dim_2(t);
              return caml_call2
                      (Base_Array[27],
                       _f_,
                       function(j){
                        return caml_ba_get_2(t, i + offset | 0, j + offset | 0);
                       });
             });
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[90], sexp_of_elt);
    return caml_call2(Base[90], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[116], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[116], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[202], _d_);
   }
   function opaque(param, _b_, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Assert_failure, Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _b3_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _b4_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _b3_]];
    return caml_call1(Base[202], _b4_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[1][5], random);
              return function(x){
               var
                _b1_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _b1_),
                random = caml_call1(Splittable_random[1][4], random$0),
                _b2_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[1][3], random, _b2_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[1][3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0;
      size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(param, _b0_){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[76],
                       list,
                       function(_bZ_){return generate(_bZ_, size, random);});
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[9],
                       list,
                       function(_bY_){return generate(_bY_, size, random);});
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[5], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2],
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _e_ = [0, cst_src_generator_ml, 225, 6],
    _f_ = [0, cst_src_generator_ml, 198, 4];
   function of_list(list){
    if(caml_call1(Base_List[8], list)){
     var
      _bX_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[30], _bX_);
    }
    var
     array = caml_call1(Base_Array[39], list),
     hi = array.length - 2 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[3], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[8], alist)){
     var
      _bR_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[30], _bR_);
    }
    var
     match = caml_call1(Base_List[92], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[39], values),
     array =
       caml_call2
        (Base_Array[27], value_array.length - 1, function(param){return 0.;}),
     sum =
       caml_call3
        (Base_List[99],
         weights,
         0.,
         function(index, acc, weight){
          if(1 - caml_call1(Base_Float[84], weight)){
           var
            _bT_ =
              [0, [1, [0, _b_, [0, caml_call1(Base[112], weight), 0]]], 0],
            _bU_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
                _bT_]];
           caml_call1(Base_Error[30], _bU_);
          }
          if(caml_call2(Base_Float[13], weight, 0.)){
           var
            _bV_ =
              [0, [1, [0, _c_, [0, caml_call1(Base[112], weight), 0]]], 0],
            _bW_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
                _bV_]];
           caml_call1(Base_Error[30], _bW_);
          }
          var cumulative = caml_call2(Base[190], acc, weight);
          runtime.caml_array_set(array, index, cumulative);
          return cumulative;
         });
    if(caml_call2(Base_Float[10], sum, 0.)){
     var
      _bS_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[30], _bS_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[8], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[5],
                   0,
                   0,
                   array,
                   Base_Float[16],
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var
               _bP_ = caml_obj_tag(lazy_t),
               _bQ_ =
                 250 === _bP_
                  ? lazy_t[1]
                  : 246
                    === _bP_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return generate(_bQ_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _bO_ = caml_obj_tag(lazy_t);
    return 250 === _bO_
            ? lazy_t[1]
            : 246 === _bO_ ? caml_call1(CamlinternalLazy[2], lazy_t) : lazy_t;
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              var
               _bK_ = caml_call1(f, self),
               rec_list =
                 caml_call2
                  (Base_List[76],
                   _bK_,
                   function(param){
                    var t = param[2], w = param[1];
                    return [0,
                            w,
                            caml_call2
                             (For_monad[11][4][2],
                              size,
                              function(n){return with_size(t, n - 1 | 0);})];
                   }),
               _bL_ = caml_call1(Base_List[8], nonrec_list),
               _bM_ = _bL_ || caml_call1(Base_List[8], rec_list);
              if(_bM_){
               var
                _bN_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[202], _bN_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[178], nonrec_list, rec_list));
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(param){return 0 === param ? nonrec_gen : rec_gen;});
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     return caml_call2(Base_List[76], list, function(t){return [0, 1., t];});
    }
    return weighted_recursive_union
            (weighted(nonrec_list),
             function(self){return weighted(caml_call1(f, self));});
   }
   function sizes(opt, _bB_, param){
    if(opt) var sth = opt[1], min_length = sth; else var min_length = 0;
    if(_bB_)
     var sth$0 = _bB_[1], max_length = sth$0;
    else
     var max_length = Base_Int[60];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[189], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[10][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              var
               sizes =
                 caml_call2(Base_Array[27], len, function(param){return 0;}),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _bC_ = 1;
              if(remaining >= 1){
               var for$0 = _bC_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[10][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _bG_ = for$0 + 1 | 0;
                if(remaining === for$0) break;
                for$0 = _bG_;
               }
              }
              var _bE_ = max_index - 1 | 0, _bD_ = 0;
              if(_bE_ >= 0){
               var i = _bD_;
               for(;;){
                var
                 j = caml_call3(Splittable_random[3], random, i, max_index);
                caml_call3(Base_Array[74], sizes, i, j);
                var _bF_ = i + 1 | 0;
                if(_bE_ === i) break;
                i = _bF_;
               }
              }
              if
               ((caml_call3
                 (Base_Array[16],
                  [0,
                   Base_Int[74],
                   function(_bJ_, _bI_){return _bJ_ + _bI_ | 0;}],
                  sizes,
                  function(_bH_){return _bH_;})
                + (len - min_length | 0)
                | 0)
                === size)
               return caml_call1(Base_Array[19], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[2], random);
        }),
    _g_ = [0, 1],
    _h_ = [0, 0];
   function option(value_t){
    var _bA_ = [0, map(value_t, Base_Option[20]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _bA_]);
   }
   function either(fst_t, snd_t){
    var _bz_ = [0, map(snd_t, Base_Either[18]), 0];
    return union([0, map(fst_t, Base_Either[17]), _bz_]);
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function list_generic(min_length, max_length, elt_gen){
    var _by_ = sizes(min_length, max_length, 0);
    return caml_call2
            (For_monad[11][4][2],
             _by_,
             function(sizes){
              return all
                      (caml_call2
                        (Base_List[76],
                         sizes,
                         function(size){return with_size(elt_gen, size);}));
             });
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[39], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[3], random, 0, length_of_input),
               indices =
                 caml_call2
                  (Base_Array[27],
                   length_of_input,
                   function(_bx_){return _bx_;}),
               _bu_ = length_of_output - 1 | 0,
               _bt_ = 0;
              if(_bu_ >= 0){
               var i = _bt_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[3], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[74], indices, i, j);
                var _bv_ = i + 1 | 0;
                if(_bu_ === i) break;
                i = _bv_;
               }
              }
              caml_call4
               (Base_Array[49],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[13]);
              return caml_call2
                      (Base_List[123],
                       length_of_output,
                       function(i){
                        var _bw_ = caml_check_bound(indices, i)[1 + i];
                        return caml_check_bound(elts$0, _bw_)[1 + _bw_];
                       });
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[39], list),
               _br_ = array.length - 2 | 0,
               _bq_ = 1;
              if(_br_ >= 1){
               var i = _bq_;
               for(;;){
                var j = caml_call3(Splittable_random[3], random, 0, i);
                caml_call3(Base_Array[74], array, i, j);
                var _bs_ = i + 1 | 0;
                if(_br_ === i) break;
                i = _bs_;
               }
              }
              return caml_call1(Base_Array[19], array);
             });
   }
   function array(t){var _bp_ = Base_Array[39]; return map(list(t), _bp_);}
   function ref(t){return map(t, function(_bo_){return [0, _bo_];});}
   function lazy_t(t){return map(t, Base_Lazy[21]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _bl_ = caml_call1(Base_Char[29], hi),
               _bm_ = caml_call1(Base_Char[29], lo),
               _bn_ = caml_call3(Splittable_random[3], random, _bm_, _bl_);
              return caml_call1(Base_Char[32], _bn_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[50], Base_Char[51]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[54], Base_Char[1], Base_Char[42])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[51])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[50])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[10][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0);
   function For_integer(Integer){
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[96], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[97], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _bj_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _bk_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _bj_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _bk_]);
    }
    function inclusive(_bh_, _bi_){
     return non_uniform(uniform_inclusive, _bh_, _bi_);
    }
    function log_inclusive(_bf_, _bg_){
     return non_uniform(log_uniform_inclusive, _bf_, _bg_);
    }
    var
     uniform_all = uniform_inclusive(Integer[85], Integer[84]),
     let_syntax_004 =
       non_uniform(log_uniform_inclusive, Integer[38], Integer[84]),
     _be_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all =
       caml_call2
        (For_monad[11][4][3],
         _be_,
         function(param){
          var magnitude = param[2], negative = param[1];
          return negative ? caml_call1(Integer[70], magnitude) : magnitude;
         });
    return [0,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol$2 = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$3 = Base_Int[75],
    symbol$4 = Base_Int[76],
    symbol$5 = Base_Int[77],
    uniform = Splittable_random[3],
    log_uniform = Splittable_random[10][1],
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_bd_, _bc_){return _bc_ <= _bd_ ? 1 : 0;},
         function(_bb_, _ba_){return _bb_ <= _ba_ ? 1 : 0;},
         function(_a$_, _a__){return _a$_ === _a__ ? 1 : 0;},
         function(_a9_, _a8_){return _a8_ < _a9_ ? 1 : 0;},
         function(_a7_, _a6_){return _a7_ < _a6_ ? 1 : 0;},
         function(_a5_, _a4_){return _a5_ !== _a4_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_a3_, _a2_){return _a3_ + _a2_ | 0;},
         function(_a1_, _a0_){return _a1_ - _a0_ | 0;},
         caml_mul,
         symbol$2,
         function(_aZ_){return - _aZ_ | 0;},
         function(_aY_){return - _aY_ | 0;},
         symbol$4,
         symbol$3,
         caml_div,
         rem,
         symbol$5,
         function(_aX_, _aW_){return _aX_ & _aW_;},
         function(_aV_, _aU_){return _aV_ | _aU_;},
         function(_aT_, _aS_){return _aT_ ^ _aS_;},
         lnot,
         function(_aR_, _aQ_){return _aR_ << _aQ_;},
         function(_aP_, _aO_){return _aP_ >> _aO_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         function(_aN_, _aM_){return _aN_ >>> _aM_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_aL_, _aK_){return _aL_ + _aK_ | 0;},
          function(_aJ_, _aI_){return _aJ_ - _aI_ | 0;},
          caml_mul,
          caml_div,
          function(_aH_){return - _aH_ | 0;},
          O[1],
          function(_aG_, _aF_){return _aF_ <= _aG_ ? 1 : 0;},
          function(_aE_, _aD_){return _aE_ <= _aD_ ? 1 : 0;},
          function(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;},
          function(_aA_, _az_){return _az_ < _aA_ ? 1 : 0;},
          function(_ay_, _ax_){return _ay_ < _ax_ ? 1 : 0;},
          function(_aw_, _av_){return _aw_ !== _av_ ? 1 : 0;},
          O[3],
          function(_au_){return - _au_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_at_, _as_){return _at_ & _as_;},
          function(_ar_, _aq_){return _ar_ | _aq_;},
          function(_ap_, _ao_){return _ap_ ^ _ao_;},
          O[2],
          function(_an_, _am_){return _an_ << _am_;},
          function(_al_, _ak_){return _al_ >> _ak_;},
          function(_aj_, _ai_){return _aj_ >>> _ai_ | 0;}],
         uniform,
         log_uniform]),
    int$0 = For_int[7],
    int_uniform = For_int[6],
    int_inclusive = For_int[4],
    int_uniform_inclusive = For_int[1],
    int_log_inclusive = For_int[5],
    int_log_uniform_inclusive = For_int[2],
    t_sexp_grammar$0 = Base_Int32[1],
    of_float$0 = Base_Int32[2],
    to_float$0 = Base_Int32[3],
    of_int_exn$0 = Base_Int32[4],
    to_int_exn$0 = Base_Int32[5],
    hash_fold_t$0 = Base_Int32[6],
    hash$0 = Base_Int32[7],
    t_of_sexp$0 = Base_Int32[8],
    sexp_of_t$0 = Base_Int32[9],
    of_string$0 = Base_Int32[10],
    to_string$0 = Base_Int32[11],
    symbol$6 = Base_Int32[12],
    symbol$7 = Base_Int32[13],
    symbol$8 = Base_Int32[14],
    symbol$9 = Base_Int32[15],
    symbol$10 = Base_Int32[16],
    symbol$11 = Base_Int32[17],
    equal$0 = Base_Int32[18],
    compare$0 = Base_Int32[19],
    min$0 = Base_Int32[20],
    max$0 = Base_Int32[21],
    ascending$0 = Base_Int32[22],
    descending$0 = Base_Int32[23],
    between$0 = Base_Int32[24],
    clamp_exn$0 = Base_Int32[25],
    clamp$0 = Base_Int32[26],
    comparator$0 = Base_Int32[27],
    pp$0 = Base_Int32[28],
    hashable$0 = Base_Int32[29],
    is_positive$0 = Base_Int32[30],
    is_non_negative$0 = Base_Int32[31],
    is_negative$0 = Base_Int32[32],
    is_non_positive$0 = Base_Int32[33],
    sign$0 = Base_Int32[34],
    invariant$0 = Base_Int32[35],
    Hex$0 = Base_Int32[36],
    to_string_hum$0 = Base_Int32[37],
    zero$0 = Base_Int32[38],
    one$0 = Base_Int32[39],
    minus_one$0 = Base_Int32[40],
    symbol$12 = Base_Int32[41],
    symbol$13 = Base_Int32[42],
    symbol$14 = Base_Int32[43],
    symbol$15 = Base_Int32[44],
    neg = Base_Int32[45],
    symbol$16 = Base_Int32[46],
    symbol$17 = Base_Int32[47],
    symbol$18 = Base_Int32[48],
    symbol$19 = Base_Int32[49],
    rem$0 = Base_Int32[50],
    symbol$20 = Base_Int32[51],
    land = Base_Int32[52],
    lor = Base_Int32[53],
    lxor = Base_Int32[54],
    lnot$0 = Base_Int32[55],
    lsl = Base_Int32[56],
    asr = Base_Int32[57],
    round$0 = Base_Int32[58],
    round_towards_zero$0 = Base_Int32[59],
    round_down$0 = Base_Int32[60],
    round_up$0 = Base_Int32[61],
    round_nearest$0 = Base_Int32[62],
    abs$0 = Base_Int32[63],
    succ$0 = Base_Int32[64],
    pred$0 = Base_Int32[65],
    pow$0 = Base_Int32[66],
    bit_and$0 = Base_Int32[67],
    bit_or$0 = Base_Int32[68],
    bit_xor$0 = Base_Int32[69],
    bit_not$0 = Base_Int32[70],
    popcount$0 = Base_Int32[71],
    shift_left$0 = Base_Int32[72],
    shift_right$0 = Base_Int32[73],
    decr$0 = Base_Int32[74],
    incr$0 = Base_Int32[75],
    of_int32_exn$0 = Base_Int32[76],
    to_int32_exn$0 = Base_Int32[77],
    of_int64_exn$0 = Base_Int32[78],
    to_int64$0 = Base_Int32[79],
    of_nativeint_exn$0 = Base_Int32[80],
    to_nativeint_exn$0 = Base_Int32[81],
    of_float_unchecked$0 = Base_Int32[82],
    num_bits$0 = Base_Int32[83],
    max_value$0 = Base_Int32[84],
    min_value$0 = Base_Int32[85],
    lsr = Base_Int32[86],
    shift_right_logical$0 = Base_Int32[87],
    ceil_pow2$0 = Base_Int32[88],
    floor_pow2$0 = Base_Int32[89],
    ceil_log2$0 = Base_Int32[90],
    floor_log2$0 = Base_Int32[91],
    is_pow2$0 = Base_Int32[92],
    clz$0 = Base_Int32[93],
    ctz$0 = Base_Int32[94],
    O$0 = Base_Int32[95],
    uniform$0 = Splittable_random[4],
    log_uniform$0 = Splittable_random[10][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[7],
    int32_uniform = For_int32[6],
    int32_inclusive = For_int32[4],
    int32_uniform_inclusive = For_int32[1],
    int32_log_inclusive = For_int32[5],
    int32_log_uniform_inclusive = For_int32[2],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    to_string_hum$1 = Base_Int63[37],
    zero$1 = Base_Int63[38],
    one$1 = Base_Int63[39],
    minus_one$1 = Base_Int63[40],
    symbol$27 = Base_Int63[41],
    symbol$28 = Base_Int63[42],
    symbol$29 = Base_Int63[43],
    symbol$30 = Base_Int63[44],
    neg$0 = Base_Int63[45],
    symbol$31 = Base_Int63[46],
    symbol$32 = Base_Int63[47],
    symbol$33 = Base_Int63[48],
    symbol$34 = Base_Int63[49],
    rem$1 = Base_Int63[50],
    symbol$35 = Base_Int63[51],
    land$0 = Base_Int63[52],
    lor$0 = Base_Int63[53],
    lxor$0 = Base_Int63[54],
    lnot$1 = Base_Int63[55],
    lsl$0 = Base_Int63[56],
    asr$0 = Base_Int63[57],
    round$1 = Base_Int63[58],
    round_towards_zero$1 = Base_Int63[59],
    round_down$1 = Base_Int63[60],
    round_up$1 = Base_Int63[61],
    round_nearest$1 = Base_Int63[62],
    abs$1 = Base_Int63[63],
    succ$1 = Base_Int63[64],
    pred$1 = Base_Int63[65],
    pow$1 = Base_Int63[66],
    bit_and$1 = Base_Int63[67],
    bit_or$1 = Base_Int63[68],
    bit_xor$1 = Base_Int63[69],
    bit_not$1 = Base_Int63[70],
    popcount$1 = Base_Int63[71],
    shift_left$1 = Base_Int63[72],
    shift_right$1 = Base_Int63[73],
    decr$1 = Base_Int63[74],
    incr$1 = Base_Int63[75],
    of_int32_exn$1 = Base_Int63[76],
    to_int32_exn$1 = Base_Int63[77],
    of_int64_exn$1 = Base_Int63[78],
    to_int64$1 = Base_Int63[79],
    of_nativeint_exn$1 = Base_Int63[80],
    to_nativeint_exn$1 = Base_Int63[81],
    of_float_unchecked$1 = Base_Int63[82],
    num_bits$1 = Base_Int63[83],
    max_value$1 = Base_Int63[84],
    min_value$1 = Base_Int63[85],
    lsr$0 = Base_Int63[86],
    shift_right_logical$1 = Base_Int63[87],
    ceil_pow2$1 = Base_Int63[88],
    floor_pow2$1 = Base_Int63[89],
    ceil_log2$1 = Base_Int63[90],
    is_pow2$1 = Base_Int63[91],
    clz$1 = Base_Int63[92],
    ctz$1 = Base_Int63[93],
    O$1 = Base_Int63[94],
    floor_log2$1 = Base_Int63[113],
    uniform$1 = Splittable_random[5],
    log_uniform$1 = Splittable_random[10][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[7],
    int63_uniform = For_int63[6],
    int63_inclusive = For_int63[4],
    int63_uniform_inclusive = For_int63[1],
    int63_log_inclusive = For_int63[5],
    int63_log_uniform_inclusive = For_int63[2],
    t_sexp_grammar$2 = Base_Int64[1],
    of_float$2 = Base_Int64[2],
    to_float$2 = Base_Int64[3],
    of_int_exn$2 = Base_Int64[4],
    to_int_exn$2 = Base_Int64[5],
    hash_fold_t$2 = Base_Int64[6],
    hash$2 = Base_Int64[7],
    t_of_sexp$2 = Base_Int64[8],
    sexp_of_t$2 = Base_Int64[9],
    of_string$2 = Base_Int64[10],
    to_string$2 = Base_Int64[11],
    equal$2 = Base_Int64[12],
    compare$2 = Base_Int64[13],
    min$2 = Base_Int64[14],
    max$2 = Base_Int64[15],
    ascending$2 = Base_Int64[16],
    descending$2 = Base_Int64[17],
    between$2 = Base_Int64[18],
    clamp_exn$2 = Base_Int64[19],
    clamp$2 = Base_Int64[20],
    comparator$2 = Base_Int64[21],
    pp$2 = Base_Int64[22],
    hashable$2 = Base_Int64[23],
    is_positive$2 = Base_Int64[24],
    is_non_negative$2 = Base_Int64[25],
    is_negative$2 = Base_Int64[26],
    is_non_positive$2 = Base_Int64[27],
    sign$2 = Base_Int64[28],
    invariant$2 = Base_Int64[29],
    Hex$2 = Base_Int64[30],
    to_string_hum$2 = Base_Int64[31],
    one$2 = Base_Int64[32],
    minus_one$2 = Base_Int64[33],
    rem$2 = Base_Int64[34],
    round$2 = Base_Int64[35],
    round_towards_zero$2 = Base_Int64[36],
    round_down$2 = Base_Int64[37],
    round_up$2 = Base_Int64[38],
    round_nearest$2 = Base_Int64[39],
    succ$2 = Base_Int64[40],
    pred$2 = Base_Int64[41],
    pow$2 = Base_Int64[42],
    bit_and$2 = Base_Int64[43],
    bit_or$2 = Base_Int64[44],
    bit_xor$2 = Base_Int64[45],
    bit_not$2 = Base_Int64[46],
    popcount$2 = Base_Int64[47],
    shift_left$2 = Base_Int64[48],
    shift_right$2 = Base_Int64[49],
    decr$2 = Base_Int64[50],
    incr$2 = Base_Int64[51],
    of_int32_exn$2 = Base_Int64[52],
    to_int32_exn$2 = Base_Int64[53],
    of_int64_exn$2 = Base_Int64[54],
    to_int64$2 = Base_Int64[55],
    of_nativeint_exn$2 = Base_Int64[56],
    to_nativeint_exn$2 = Base_Int64[57],
    of_float_unchecked$2 = Base_Int64[58],
    num_bits$2 = Base_Int64[59],
    max_value$2 = Base_Int64[60],
    min_value$2 = Base_Int64[61],
    shift_right_logical$2 = Base_Int64[62],
    ceil_pow2$2 = Base_Int64[63],
    floor_pow2$2 = Base_Int64[64],
    ceil_log2$2 = Base_Int64[65],
    floor_log2$2 = Base_Int64[66],
    is_pow2$2 = Base_Int64[67],
    clz$2 = Base_Int64[68],
    ctz$2 = Base_Int64[69],
    O$2 = Base_Int64[70],
    symbol$36 = Base_Int64[71],
    lnot$2 = Base_Int64[72],
    abs$2 = Base_Int64[73],
    zero$2 = Base_Int64[74],
    symbol$37 = Base_Int64[75],
    symbol$38 = Base_Int64[76],
    symbol$39 = Base_Int64[77],
    uniform$2 = Splittable_random[6],
    log_uniform$2 = Splittable_random[10][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[7],
    int64_uniform = For_int64[6],
    int64_inclusive = For_int64[4],
    int64_uniform_inclusive = For_int64[1],
    int64_log_inclusive = For_int64[5],
    int64_log_uniform_inclusive = For_int64[2],
    t_sexp_grammar$3 = Base_Nativeint[1],
    of_float$3 = Base_Nativeint[2],
    to_float$3 = Base_Nativeint[3],
    of_int_exn$3 = Base_Nativeint[4],
    to_int_exn$3 = Base_Nativeint[5],
    hash_fold_t$3 = Base_Nativeint[6],
    hash$3 = Base_Nativeint[7],
    t_of_sexp$3 = Base_Nativeint[8],
    sexp_of_t$3 = Base_Nativeint[9],
    of_string$3 = Base_Nativeint[10],
    to_string$3 = Base_Nativeint[11],
    symbol$40 = Base_Nativeint[12],
    symbol$41 = Base_Nativeint[13],
    symbol$42 = Base_Nativeint[14],
    symbol$43 = Base_Nativeint[15],
    symbol$44 = Base_Nativeint[16],
    symbol$45 = Base_Nativeint[17],
    equal$3 = Base_Nativeint[18],
    compare$3 = Base_Nativeint[19],
    min$3 = Base_Nativeint[20],
    max$3 = Base_Nativeint[21],
    ascending$3 = Base_Nativeint[22],
    descending$3 = Base_Nativeint[23],
    between$3 = Base_Nativeint[24],
    clamp_exn$3 = Base_Nativeint[25],
    clamp$3 = Base_Nativeint[26],
    comparator$3 = Base_Nativeint[27],
    pp$3 = Base_Nativeint[28],
    hashable$3 = Base_Nativeint[29],
    is_positive$3 = Base_Nativeint[30],
    is_non_negative$3 = Base_Nativeint[31],
    is_negative$3 = Base_Nativeint[32],
    is_non_positive$3 = Base_Nativeint[33],
    sign$3 = Base_Nativeint[34],
    invariant$3 = Base_Nativeint[35],
    Hex$3 = Base_Nativeint[36],
    to_string_hum$3 = Base_Nativeint[37],
    zero$3 = Base_Nativeint[38],
    one$3 = Base_Nativeint[39],
    minus_one$3 = Base_Nativeint[40],
    symbol$46 = Base_Nativeint[41],
    symbol$47 = Base_Nativeint[42],
    symbol$48 = Base_Nativeint[43],
    symbol$49 = Base_Nativeint[44],
    neg$1 = Base_Nativeint[45],
    symbol$50 = Base_Nativeint[46],
    symbol$51 = Base_Nativeint[47],
    symbol$52 = Base_Nativeint[48],
    symbol$53 = Base_Nativeint[49],
    rem$3 = Base_Nativeint[50],
    symbol$54 = Base_Nativeint[51],
    land$1 = Base_Nativeint[52],
    lor$1 = Base_Nativeint[53],
    lxor$1 = Base_Nativeint[54],
    lnot$3 = Base_Nativeint[55],
    lsl$1 = Base_Nativeint[56],
    asr$1 = Base_Nativeint[57],
    round$3 = Base_Nativeint[58],
    round_towards_zero$3 = Base_Nativeint[59],
    round_down$3 = Base_Nativeint[60],
    round_up$3 = Base_Nativeint[61],
    round_nearest$3 = Base_Nativeint[62],
    abs$3 = Base_Nativeint[63],
    succ$3 = Base_Nativeint[64],
    pred$3 = Base_Nativeint[65],
    pow$3 = Base_Nativeint[66],
    bit_and$3 = Base_Nativeint[67],
    bit_or$3 = Base_Nativeint[68],
    bit_xor$3 = Base_Nativeint[69],
    bit_not$3 = Base_Nativeint[70],
    popcount$3 = Base_Nativeint[71],
    shift_left$3 = Base_Nativeint[72],
    shift_right$3 = Base_Nativeint[73],
    decr$3 = Base_Nativeint[74],
    incr$3 = Base_Nativeint[75],
    of_int32_exn$3 = Base_Nativeint[76],
    to_int32_exn$3 = Base_Nativeint[77],
    of_int64_exn$3 = Base_Nativeint[78],
    to_int64$3 = Base_Nativeint[79],
    of_nativeint_exn$3 = Base_Nativeint[80],
    to_nativeint_exn$3 = Base_Nativeint[81],
    of_float_unchecked$3 = Base_Nativeint[82],
    num_bits$3 = Base_Nativeint[83],
    max_value$3 = Base_Nativeint[84],
    min_value$3 = Base_Nativeint[85],
    lsr$1 = Base_Nativeint[86],
    shift_right_logical$3 = Base_Nativeint[87],
    ceil_pow2$3 = Base_Nativeint[88],
    floor_pow2$3 = Base_Nativeint[89],
    ceil_log2$3 = Base_Nativeint[90],
    floor_log2$3 = Base_Nativeint[91],
    is_pow2$3 = Base_Nativeint[92],
    clz$3 = Base_Nativeint[93],
    ctz$3 = Base_Nativeint[94],
    O$3 = Base_Nativeint[95],
    uniform$3 = Splittable_random[7],
    log_uniform$3 = Splittable_random[10][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[7],
    nativeint_uniform = For_nativeint[6],
    nativeint_inclusive = For_nativeint[4],
    nativeint_uniform_inclusive = For_nativeint[1],
    nativeint_log_inclusive = For_nativeint[5],
    nativeint_log_uniform_inclusiv = For_nativeint[2],
    float_zero_exponent = caml_call1(Base_Float[121], 0.),
    float_zero_mantissa = caml_call1(Base_Float[122], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[51], 759637122, Base_Float[47]),
    float_subnormal_exponent = caml_call1(Base_Float[121], Base_Float[46]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[122], Base_Float[46]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[45],
    float_min_normal_exponent = caml_call1(Base_Float[121], Base_Float[47]),
    float_max_normal_exponent =
      caml_call1(Base_Float[121], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[121], Base_Float[33]),
    float_inf_mantissa = caml_call1(Base_Float[122], Base_Float[33]),
    float_nan_exponent = caml_call1(Base_Float[121], Base_Float[32]),
    float_min_nan_mantissa = caml_call1(Base_Int63[64], float_inf_mantissa),
    _j_ = For_int[1].call(null, 0, 52),
    float_normal_mantissa =
      caml_call2
       (For_monad[11][4][2],
        _j_,
        function(num_bits){
         var
          _af_ = caml_call2(Base_Int63[72], Base_Int63[39], num_bits),
          _ag_ = caml_call1(Base_Int63[65], _af_),
          _ah_ = For_int63[4].call(null, Base_Int63[38], _ag_);
         return caml_call2
                 (For_monad[11][4][3],
                  _ah_,
                  function(bits){
                   return caml_call2(Base_Int63[72], bits, 52 - num_bits | 0);
                  });
        }),
    lower_bound = caml_call1(Base_Float[121], 1.),
    _k_ =
      For_int[5].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    _m_ =
      [0,
       caml_call2
        (For_monad[11][4][3],
         _k_,
         function(offset){return lower_bound + offset | 0;}),
       0],
    _l_ =
      For_int[5].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union
       ([0,
         caml_call2
          (For_monad[11][4][3],
           _l_,
           function(offset){return lower_bound - offset | 0;}),
         _m_]),
    float_zero =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[119],
                  negative,
                  float_zero_exponent,
                  float_zero_mantissa);
        }),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[5].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa),
    _n_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _o_ = caml_call2(For_monad[11][4][4], bool, _n_),
    float_subnormal =
      caml_call2
       (For_monad[11][4][3],
        _o_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        }),
    _p_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _q_ = caml_call2(For_monad[11][4][4], bool, _p_),
    float_normal =
      caml_call2
       (For_monad[11][4][3],
        _q_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        }),
    float_infinite =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[119],
                  negative,
                  float_inf_exponent,
                  float_inf_mantissa);
        }),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[4].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa),
    _r_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _s_ = caml_call2(For_monad[11][4][4], bool, _r_),
    float_nan =
      caml_call2
       (For_monad[11][4][3],
        _s_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        });
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    return weighted_union
            (caml_call2
              (Base_List[126],
               Base_Float[113][2],
               function(c){
                if(! caml_call1(filter, c)) return 0;
                var _ad_ = float_of_class(c);
                switch(c){
                  case 0:
                   var _ae_ = 1.; break;
                  case 1:
                   var _ae_ = 1.; break;
                  case 2:
                   var _ae_ = 100.; break;
                  case 3:
                   var _ae_ = 10.; break;
                  default: var _ae_ = 1.;
                }
                return [0, [0, _ae_, _ad_]];
               }));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;}),
    float_strictly_positive =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){return caml_call1(Base_Float[102], t);}),
    float_strictly_negative =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){
         var _ac_ = caml_call1(Base_Float[102], t);
         return caml_call1(Base[196], _ac_);
        }),
    float_positive_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){return caml_call1(Base_Float[102], t);}),
    float_negative_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){
         var _ab_ = caml_call1(Base_Float[102], t);
         return caml_call1(Base[196], _ab_);
        }),
    _t_ = [0, cst_upper_bound],
    _u_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _v_ = [0, cst_upper_bound],
    _w_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty";
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _V_ = 1 - caml_call1(Base_Float[84], lower_bound),
     _W_ = _V_ || 1 - caml_call1(Base_Float[84], upper_bound);
    if(_W_){
     var
      _X_ = [0, [1, [0, _t_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _Y_ =
        [0, [1, [0, _u_, [0, caml_call1(Base[112], lower_bound), 0]]], _X_],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _Y_]];
     caml_call1(Base[202], _Z_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[51], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[51], 759637122, upper_bound);
    if(caml_call2(Base_Float[103][11], lower_inclusive, upper_inclusive)){
     var
      ___ = [0, [1, [0, _v_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _$_ =
        [0, [1, [0, _w_, [0, caml_call1(Base[112], lower_bound), 0]]], ___],
      _aa_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _$_]];
     caml_call1(Base[202], _aa_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[8],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(caml_call2(Base_Float[15], lower_bound, upper_bound))
     return caml_call1(For_monad[11][1], lower_bound);
    var _R_ = caml_call2(Base_Float[51], 19067, lower_bound);
    if(caml_call2(Base_Float[11], _R_, upper_bound)){
     var _S_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _S_]);
    }
    var
     _T_ = [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _U_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _T_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _U_]);
   }
   function string_with_length_of(char_gen, length){
    var _Q_ = list_with_length(char_gen, length);
    return map(_Q_, Base_String[123]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   var bytes = map(string, Base_Bytes[25]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(size){
                        var _O_ = For_int[2].call(null, 0, size + 1 | 0);
                        return caml_call2
                                (For_monad[11][4][2],
                                 _O_,
                                 function(param){
                                  if(0 === param)
                                   return caml_call2
                                           (For_monad[11][4][3],
                                            atom,
                                            function(atom){return [0, atom];});
                                  var _P_ = list(self);
                                  return caml_call2
                                          (For_monad[11][4][3],
                                           _P_,
                                           function(list){return [1, list];});
                                 });
                       });
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    var _K_ = list(key_gen);
    return caml_call2
            (For_monad[11][4][2],
             _K_,
             function(keys){
              var
               keys$0 = caml_call2(Base_List[114], keys, comparator[1]),
               _L_ =
                 list_with_length(data_gen, caml_call1(Base_List[7], keys$0));
              return caml_call2
                      (For_monad[11][4][2],
                       _L_,
                       function(data){
                        var
                         _M_ = caml_call2(Base_List[95], keys$0, data),
                         _N_ = caml_call2(Base_Map[104][3][9], comparator, _M_);
                        return caml_call1(For_monad[11][1], _N_);
                       });
             });
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _J_ = caml_call1(Base_Set[74][3][54], comparator);
    return map(list(elt_gen), _J_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _I_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_I_, caml_call1(Base_Map[104][95], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _H_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_H_, caml_call1(Base_Set[74][64], comparator));
   }
   function bigarray1(t, kind, layout){
    var _F_ = list(t);
    return caml_call2
            (For_monad[11][4][3],
             _F_,
             function(elts){
              var
               elts$0 = caml_call1(Base_Array[39], elts),
               dim = elts$0.length - 1,
               offset =
                 caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim,
                       function(i){
                        var _G_ = i - offset | 0;
                        return caml_check_bound(elts$0, _G_)[1 + _G_];
                       });
             });
   }
   var
    bigstring = bigarray1(char$0, 12, 0),
    float32_vec = bigarray1(float$0, 0, 1),
    float64_vec = bigarray1(float$0, 1, 1),
    _x_ = [0, 0, 0],
    bigarray2_dim =
      caml_call2
       (For_monad[11][4][2],
        size,
        function(max_total_size){
         if(0 === max_total_size) return caml_call1(For_monad[11][1], _x_);
         var _C_ = int_log_uniform_inclusive(1, max_total_size);
         return caml_call2
                 (For_monad[11][4][2],
                  _C_,
                  function(a){
                   var
                    max_b = caml_div(max_total_size, a),
                    _D_ = int_log_uniform_inclusive(0, max_b),
                    _E_ =
                      caml_call2
                       (For_monad[11][4][3],
                        _D_,
                        function(b_weighted_low){return max_b - b_weighted_low | 0;});
                   return caml_call2
                           (For_monad[11][4][2],
                            _E_,
                            function(b){
                             return caml_call2
                                     (For_monad[11][4][3],
                                      bool,
                                      function(param){return param ? [0, a, b] : [0, b, a];});
                            });
                  });
        });
   function bigarray2(t, kind, layout){
    return caml_call2
            (For_monad[11][4][2],
             bigarray2_dim,
             function(param){
              var
               dim2 = param[2],
               dim1 = param[1],
               _z_ = list_with_length(list_with_length(t, dim2), dim1);
              return caml_call2
                      (For_monad[11][4][3],
                       _z_,
                       function(elts){
                        var
                         elts$0 = caml_call2(Base_Array[78], elts, Base_Array[39]),
                         offset =
                           caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
                        return caml_call5
                                (Base_quickcheck_Bigarray_helpe[3][2],
                                 kind,
                                 layout,
                                 dim1,
                                 dim2,
                                 function(i, j){
                                  var _A_ = j - offset | 0, _B_ = i - offset | 0;
                                  return caml_check_bound
                                           (caml_check_bound(elts$0, _B_)[1 + _B_], _A_)
                                          [1 + _A_];
                                 });
                       });
             });
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp){
    return function(sample){
     var _y_ = caml_call1(Base_Map[6], Cmp);
     return caml_call3
             (Base_Sequence[8],
              sample,
              _y_,
              function(counts, value){
               return caml_call3
                       (Base_Map[35],
                        counts,
                        value,
                        function(param){
                         if(! param) return 1;
                         var prev = param[1];
                         return prev + 1 | 0;
                        });
              });};
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (79, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes;
   function atomic(param){return Base_Sequence[38];}
   function create(_X_){return _X_;}
   function shrink(_W_){return _W_;}
   function map(t, f, f_inverse){
    return function(x){
     var _V_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[32], _V_, f);};
   }
   function filter(t, f){
    return function(x){
     var _U_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[51], _U_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _T_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[78], _T_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     return caml_call1
             (Base_Sequence[105],
              [246,
               function(_Q_){
                var
                 _R_ = caml_obj_tag(lazy_t),
                 _S_ =
                   250 === _R_
                    ? lazy_t[1]
                    : 246
                      === _R_
                      ? caml_call1(CamlinternalLazy[2], lazy_t)
                      : lazy_t;
                return caml_call1(_S_, x);
               }]);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var
      snd = param[2],
      fst = param[1],
      _M_ = caml_call1(snd_t, snd),
      _N_ =
        [0,
         caml_call2
          (Base_Sequence[32], _M_, function(snd){return [0, fst, snd];}),
         0],
      _O_ = caml_call1(fst_t, fst),
      _P_ =
        [0,
         caml_call2
          (Base_Sequence[32], _O_, function(fst){return [0, fst, snd];}),
         _N_];
     return caml_call1(Base_Sequence[68], _P_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    return caml_call2
            (Base_Sequence[77],
             dim,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim - 1 | 0,
                       function(i){
                        var i$0 = i < to_skip$0 ? i : i + 1 | 0;
                        return runtime.caml_ba_get_1(src, i$0);
                       });
             });
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   var
    dim2$0 =
      [0,
       function(param){return 0;},
       "dim2",
       0,
       dim2,
       function(r, v){return [0, r[1], v];}],
    dim1$0 =
      [0,
       function(param){return 0;},
       "dim1",
       0,
       dim1,
       function(r, v){return [0, v, r[2]];}];
   function shrink$0(field, src){
    var _K_ = runtime.caml_ba_dim_2(src), dims = [0, caml_ba_dim_1(src), _K_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[41]),
     dim2 = match[2],
     dim1 = match[1],
     _L_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2
            (Base_Sequence[77],
             _L_,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
              return caml_call5
                      (Base_quickcheck_Bigarray_helpe[3][2],
                       kind,
                       layout,
                       dim1,
                       dim2,
                       function(dim1, dim2){
                        var
                         match =
                           caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
                         dim2$0 = match[2],
                         dim1$0 = match[1];
                        return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
                       });
             });
   }
   function float32_mat(src){
    var
     _I_ = [0, shrink$0(dim2$0, src), 0],
     _J_ = [0, shrink$0(dim1$0, src), _I_];
    return caml_call1(Base_Sequence[68], _J_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[38];
     var
      value = param[1],
      _E_ = Base_Option[20],
      _F_ = caml_call1(value_t, value),
      _G_ = caml_call2(Base_Sequence[32], _F_, _E_),
      _H_ = caml_call1(Base_Sequence[99], 0);
     return caml_call2(Base_Sequence[63], _H_, _G_);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[38];
               var
                tail = param[2],
                head = param[1],
                _z_ = caml_call1(list_t, tail),
                _A_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _z_,
                     function(tail){return [0, head, tail];}),
                   0],
                _B_ = caml_call1(elt_t, head),
                _C_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _B_,
                     function(head){return [0, head, tail];}),
                   _A_],
                _D_ = [0, caml_call1(Base_Sequence[99], tail), _C_];
               return caml_call1(Base_Sequence[68], _D_);};
             });
   }
   var
    _a_ = Base_String[16],
    _b_ = Base_String[123],
    string = map(list(atomic), _b_, _a_),
    bytes = map(string, Base_Bytes[25], Base_Bytes[26]);
   function array(t){
    var _x_ = Base_Array[19], _y_ = Base_Array[39];
    return map(list(t), _y_, _x_);
   }
   function ref(t){
    return map
            (t,
             function(_w_){return [0, _w_];},
             function(_v_){return _v_[1];});
   }
   function lazy_t(t){
    return map
            (t,
             Base_Lazy[21],
             function(_t_){
              var _u_ = caml_obj_tag(_t_);
              return 250 === _u_
                      ? _t_[1]
                      : 246 === _u_ ? caml_call1(CamlinternalLazy[2], _t_) : _t_;
             });
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[38];
          var
           l = param[1],
           _s_ = list(shrinker)(l),
           shrink_list =
             caml_call2(Base_Sequence[32], _s_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[104], l);
          return caml_call1
                  (Base_Sequence[68], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _o_ = Base_Either[17],
       _p_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[32], _p_, _o_);
     }
     var snd = either[1], _q_ = Base_Either[18], _r_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[32], _r_, _q_);};
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             },
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var
      alist = caml_call2(Base_Map[104][3][66], 0, tree),
      _j_ = caml_call1(Base_Sequence[104], alist),
      drop_keys =
        caml_call2
         (Base_Sequence[32],
          _j_,
          function(param){
           var k = param[1];
           return caml_call3(Base_Map[104][3][39], comparator, tree, k);
          }),
      _k_ =
        caml_call2
         (Base_List[76],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            tree$0 = caml_call3(Base_Map[104][3][39], comparator, tree, key),
            _n_ = caml_call1(key_t, key);
           return caml_call2
                   (Base_Sequence[78],
                    _n_,
                    function(smaller_key){
                     var
                      match =
                        caml_call4
                         (Base_Map[104][3][29],
                          comparator,
                          tree$0,
                          smaller_key,
                          data);
                     if(typeof match === "number") return 0;
                     var tree = match[2];
                     return [0, tree];
                    });
          }),
      shrink_keys = caml_call1(Base_Sequence[68], _k_),
      _l_ =
        caml_call2
         (Base_List[76],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            _m_ = caml_call1(data_t, data);
           return caml_call2
                   (Base_Sequence[32],
                    _m_,
                    function(smaller_data){
                     return caml_call4
                             (Base_Map[104][3][31], comparator, tree, key, smaller_data);
                    });
          }),
      shrink_data = caml_call1(Base_Sequence[68], _l_);
     return caml_call1
             (Base_Sequence[68],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var
      list = caml_call1(Base_Set[74][3][15], tree),
      _g_ = caml_call1(Base_Sequence[104], list),
      drop_elts =
        caml_call2
         (Base_Sequence[32],
          _g_,
          function(elt){
           return caml_call3(Base_Set[74][3][20], comparator, tree, elt);
          }),
      _h_ =
        caml_call2
         (Base_List[76],
          list,
          function(elt){
           var
            tree$0 = caml_call3(Base_Set[74][3][20], comparator, tree, elt),
            _i_ = caml_call1(elt_t, elt);
           return caml_call2
                   (Base_Sequence[78],
                    _i_,
                    function(smaller_elt){
                     return caml_call3
                              (Base_Set[74][3][18], comparator, tree$0, smaller_elt)
                             ? 0
                             : [0,
                               caml_call3
                                (Base_Set[74][3][19], comparator, tree$0, smaller_elt)];
                    });
          }),
      shrink_elts = caml_call1(Base_Sequence[68], _h_);
     return caml_call1(Base_Sequence[68], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _e_ = Base_Map[104][68],
      _f_ = caml_call1(Base_Map[104][95], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _f_, _e_);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _c_ = Base_Set[74][47],
      _d_ = caml_call1(Base_Set[74][64], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _d_, _c_);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (17, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__Field, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_seed = "seed",
    cst_shrink_count = "shrink_count",
    cst_sizes = "sizes",
    cst_test_count = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    names =
      [0,
       cst_seed,
       [0, cst_test_count, [0, cst_shrink_count, [0, cst_sizes, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_Field = global_data.Base__Field,
    Base_List = global_data.Base__List,
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[164], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sizes(r){return r[4];}
   function shrink_count(r){return r[3];}
   function test_count(r){return r[2];}
   function seed(r){return r[1];}
   var
    sizes$0 =
      [0,
       function(param){return 0;},
       cst_sizes,
       0,
       sizes,
       function(r, v){return [0, r[1], r[2], r[3], v];}],
    shrink_count$0 =
      [0,
       function(param){return 0;},
       cst_shrink_count,
       0,
       shrink_count,
       function(r, v){return [0, r[1], r[2], v, r[4]];}],
    test_count$0 =
      [0,
       function(param){return 0;},
       cst_test_count,
       0,
       test_count,
       function(r, v){return [0, r[1], v, r[3], r[4]];}],
    seed$0 =
      [0,
       function(param){return 0;},
       cst_seed,
       0,
       seed,
       function(r, v){return [0, v, r[2], r[3], r[4]];}];
   function make_creator
   (seed_fun, test_count_fun, shrink_count_fun, sizes_fun, compile_acc){
    var
     match = caml_call2(seed_fun, seed$0, compile_acc),
     compile_acc$0 = match[2],
     seed_gen = match[1],
     match$0 = caml_call2(test_count_fun, test_count$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     test_count_gen = match$0[1],
     match$1 = caml_call2(shrink_count_fun, shrink_count$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     shrink_count_gen = match$1[1],
     match$2 = caml_call2(sizes_fun, sizes$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     sizes_gen = match$2[1];
    return [0,
            function(acc){
             var
              seed = caml_call1(seed_gen, acc),
              test_count = caml_call1(test_count_gen, acc),
              shrink_count = caml_call1(shrink_count_gen, acc),
              sizes = caml_call1(sizes_gen, acc);
             return [0, seed, test_count, shrink_count, sizes];
            },
            compile_acc$3];
   }
   function create(seed, test_count, shrink_count, sizes){return [0, seed, test_count, shrink_count, sizes];
   }
   function map(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ag_ = caml_call1(sizes_fun, sizes$0),
     _ah_ = caml_call1(shrink_count_fun, shrink_count$0),
     _ai_ = caml_call1(test_count_fun, test_count$0);
    return [0, caml_call1(seed_fun, seed$0), _ai_, _ah_, _ag_];
   }
   function iter(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call1(seed_fun, seed$0);
    caml_call1(test_count_fun, test_count$0);
    caml_call1(shrink_count_fun, shrink_count$0);
    return caml_call1(sizes_fun, sizes$0);
   }
   function fold(init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    return caml_call2
            (sizes_fun,
             caml_call2
              (shrink_count_fun,
               caml_call2
                (test_count_fun,
                 caml_call2(seed_fun, init, seed$0),
                 test_count$0),
               shrink_count$0),
             sizes$0);
   }
   function map_poly(record){
    var
     _ad_ = [0, caml_call1(record[1], sizes$0), 0],
     _ae_ = [0, caml_call1(record[1], shrink_count$0), _ad_],
     _af_ = [0, caml_call1(record[1], test_count$0), _ae_];
    return [0, caml_call1(record[1], seed$0), _af_];
   }
   function for_all(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _aa_ = caml_call1(seed_fun, seed$0),
     _ab_ = _aa_ ? caml_call1(test_count_fun, test_count$0) : _aa_,
     _ac_ = _ab_ ? caml_call1(shrink_count_fun, shrink_count$0) : _ab_;
    return _ac_ ? caml_call1(sizes_fun, sizes$0) : _ac_;
   }
   function exists(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _$_ = caml_call1(seed_fun, seed$0),
     _Z_ = _$_ || caml_call1(test_count_fun, test_count$0),
     ___ = _Z_ || caml_call1(shrink_count_fun, shrink_count$0);
    return ___ ? ___ : caml_call1(sizes_fun, sizes$0);
   }
   function to_list(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _W_ = [0, caml_call1(sizes_fun, sizes$0), 0],
     _X_ = [0, caml_call1(shrink_count_fun, shrink_count$0), _W_],
     _Y_ = [0, caml_call1(test_count_fun, test_count$0), _X_];
    return [0, caml_call1(seed_fun, seed$0), _Y_];
   }
   function iter$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call3(seed_fun, seed$0, record, record[1]);
    caml_call3(test_count_fun, test_count$0, record, record[2]);
    caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function fold$0
   (record, init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var _T_ = record[4], _U_ = record[3], _V_ = record[2];
    return caml_call4
            (sizes_fun,
             caml_call4
              (shrink_count_fun,
               caml_call4
                (test_count_fun,
                 caml_call4(seed_fun, init, seed$0, record, record[1]),
                 test_count$0,
                 record,
                 _V_),
               shrink_count$0,
               record,
               _U_),
             sizes$0,
             record,
             _T_);
   }
   function for_all$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _Q_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _R_ =
       _Q_ ? caml_call3(test_count_fun, test_count$0, record, record[2]) : _Q_,
     _S_ =
       _R_
        ? caml_call3(shrink_count_fun, shrink_count$0, record, record[3])
        : _R_;
    return _S_ ? caml_call3(sizes_fun, sizes$0, record, record[4]) : _S_;
   }
   function exists$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _P_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _N_ = _P_ || caml_call3(test_count_fun, test_count$0, record, record[2]),
     _O_ =
       _N_ || caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return _O_ ? _O_ : caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function to_list$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _K_ = [0, caml_call3(sizes_fun, sizes$0, record, record[4]), 0],
     _L_ =
       [0,
        caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
        _K_],
     _M_ =
       [0, caml_call3(test_count_fun, test_count$0, record, record[2]), _L_];
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _M_];
   }
   function map$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _H_ = caml_call3(sizes_fun, sizes$0, record, record[4]),
     _I_ = caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
     _J_ = caml_call3(test_count_fun, test_count$0, record, record[2]);
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _J_, _I_, _H_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    _c_ = [0, cst_sizes],
    _d_ = [0, cst_shrink_count],
    _e_ = [0, cst_test_count],
    _f_ = [0, cst_seed];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[119],
     match = caml_call2(Base_Sequence[88], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[76], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[6], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[178], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _c_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[119], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _d_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[119], test_count_006),
     bnds_003$2 = [0, [1, [0, _e_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _f_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _g_ = caml_call5(Base_List[121], 0, [0, 104758188], [0, 104758188], 0, 30),
    default_config =
      [0,
       [0, "an arbitrary but deterministic string"],
       10000,
       10000,
       caml_call1(Base_Sequence[97], _g_)],
    lazy_nondeterministic_state =
      [246, function(_G_){return caml_call2(Base_Random[18][3], 0, 0);}],
    _h_ = [0, "number_of_size_values"],
    _i_ = [0, cst_test_count],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, "error"],
    _n_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed";
   function with_sample(f, opt, _C_, generator){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_C_) var sth$0 = _C_[1], examples = sth$0; else var examples = 0;
    var match = config[1];
    if(match)
     var
      string = match[1],
      _w_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[1][2], _w_);
    else
     var
      _x_ = runtime.caml_obj_tag(lazy_nondeterministic_state),
      _y_ =
        250 === _x_
         ? lazy_nondeterministic_state[1]
         : 246
           === _x_
           ? caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state)
           : lazy_nondeterministic_state,
      random = caml_call1(Splittable_random[1][1], _y_);
    var
     _z_ =
       caml_call2
        (Base_Sequence[42],
         [0, config[4], 0],
         function(param){
          var number_of_size_values = param[2], sizes = param[1];
          if(config[2] <= number_of_size_values) return 0;
          var match = caml_call1(Base_Sequence[39], sizes);
          if(match){
           var
            match$0 = match[1],
            remaining_sizes = match$0[2],
            size = match$0[1];
           return [0,
                   [0,
                    size,
                    [0, remaining_sizes, number_of_size_values + 1 | 0]]];
          }
          var
           _D_ =
             [0,
              [1,
               [0, _h_, [0, caml_call1(Base[119], number_of_size_values), 0]]],
              0],
           _E_ =
             [0, [1, [0, _i_, [0, caml_call1(Base[119], config[2]), 0]]], _D_],
           _F_ =
             [1,
              [0,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
               _E_]];
          return caml_call1(Base[202], _F_);
         }),
     _A_ =
       caml_call2
        (Base_Sequence[32],
         _z_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[118], generator, size, random);
         }),
     _B_ = caml_call1(Base_Sequence[104], examples),
     sequence = caml_call2(Base_Sequence[63], _B_, _A_);
    return caml_call1(f, sequence);
   }
   function result(f, opt, _v_, m){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_v_) var sth$0 = _v_[1], examples = sth$0; else var examples = 0;
    return with_sample
            (function(sequence){
              var
               match$2 =
                 caml_call3
                  (Base_Sequence[9],
                   sequence,
                   0,
                   function(param, input){
                    var match = caml_call1(f, input);
                    if(0 === match[0]) return _j_;
                    var error = match[1];
                    return [1, [0, input, error]];
                   });
              if(0 === match$2[0]) return _k_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[39], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  shrink_count = shrink_count$0;
                  alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate);
                 shrink_count = shrink_count$0;
                 alternates = alternates$1;
                 input = alternate;
                 error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             [0, config],
             [0, examples],
             m[2]);
   }
   function run(f, config, examples, M){
    function f$0(x){
     var _u_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[29],
              _u_,
              function(param){return caml_call1(f, x);});
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _l_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _r_ = [0, [1, [0, _m_, [0, caml_call1(Base_Error[6], error), 0]]], 0],
     _s_ = [0, [1, [0, _n_, [0, caml_call1(M[1], input), 0]]], _r_],
     _t_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _s_]];
    return caml_call1(Base_Or_error[35], _t_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     return caml_call2
             (Base_Or_error[28], 0, function(param){return caml_call1(f, x);});
    }
    var _q_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[31], _q_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     var _p_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[28],
              _p_,
              function(param){return caml_call1(f, x);});
    }
    var _o_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[31], _o_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0,
        Seed,
        sizes,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$0,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold,
         make_creator,
         create,
         map,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (37, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var
               _n_ = caml_obj_tag(lazy_t),
               _o_ =
                 250 === _n_
                  ? lazy_t[1]
                  : 246
                    === _n_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return caml_call4(observe, _o_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[3]),
    char$0 = of_hash_fold(Base_Char[3]),
    int$0 = of_hash_fold(Base_Int[6]),
    int32 = of_hash_fold(Base_Int32[6]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[6]),
    nativeint = of_hash_fold(Base_Nativeint[6]),
    float$0 = of_hash_fold(Base_Float[4]),
    string = of_hash_fold(Base_String[26]),
    sexp = of_hash_fold(Base[84][1]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[101])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    bytes = unmap(string, Base_Bytes[26]),
    _a_ = [0, 0];
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[116], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[116], hash, 2));
             });
   }
   function result(ok_t, err_t){
    return unmap
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    return unmap
            (either(opaque, value_t),
             function(param){
              if(! param) return _a_;
              var value = param[1];
              return [1, value];
             });
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _k_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _k_),
               length = caml_call1(Base_List[7], list),
               _l_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[118], _l_, size, random),
               _m_ = caml_call2(Base[116], hash, 0);
              return caml_call4
                      (Base_List[46],
                       list,
                       sizes,
                       _m_,
                       function(hash, elt, size){
                        return caml_call4
                                (observe, elt_t, elt, size, caml_call2(Base[116], hash, 1));
                       });
             });
   }
   function array(t){var _j_ = Base_Array[19]; return unmap(list(t), _j_);}
   function ref(t){return unmap(t, function(_i_){return _i_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_g_){
              var _h_ = caml_obj_tag(_g_);
              return 250 === _h_
                      ? _g_[1]
                      : 246 === _h_ ? caml_call1(CamlinternalLazy[2], _g_) : _g_;
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _e_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _e_),
               _f_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[118], _f_, size * 2 | 0, random);
              return caml_call3
                      (Base_List[10],
                       sizes,
                       hash,
                       function(hash, size){
                        var
                         x =
                           caml_call3
                            (Base_quickcheck_Generator[118], dom, size, random);
                        return caml_call4
                                (observe, rng, caml_call1(f, x), size, hash);
                       });
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[104][3][66];
    return unmap
            (list(both(key_obs, data_obs)),
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[74][3][15];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[104][68];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[74][47];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm9mZnNldCIsIml0ZXJpIiwidCIsImYiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwiaW5pdCQwIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJzdGF0ZSQwIiwiaXRlcmkkMCIsImoiLCJkaW0xIiwiZGltMiIsImZvbGQkMCIsImVsdCIsInRvX2FycmF5JDAiLCJzZXhwX29mX3QkMCIsInhfMDAyIiwiaGFzaF9mb2xkJDAiLCJzdGF0ZSQxIiwiY3JlYXRlIiwib2JzZXJ2ZSIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsImlnbm9yZV9tIiwiam9pbiIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5Iiwic3VtIiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwicmVjX2xpc3QiLCJ3IiwibiIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInVuaXQiLCJib29sIiwib3B0aW9uIiwidmFsdWVfdCIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImxpc3RfZ2VuZXJpYyIsImVsdF9nZW4iLCJsaXN0X25vbl9lbXB0eSIsImxpc3Rfd2l0aF9sZW5ndGgiLCJsZW5ndGgiLCJsaXN0X2ZpbHRlcmVkIiwiZWx0cyIsImVsdHMkMCIsImxlbmd0aF9vZl9pbnB1dCIsImxlbmd0aF9vZl9vdXRwdXQiLCJpbmRpY2VzIiwibGlzdF9wZXJtdXRhdGlvbnMiLCJyZWYiLCJjaGFyX3VuaWZvcm1faW5jbHVzaXZlIiwiY2hhcl91cHBlcmNhc2UiLCJjaGFyX2xvd2VyY2FzZSIsImNoYXJfZGlnaXQiLCJjaGFyX3ByaW50X3VuaWZvcm0iLCJjaGFyX3VuaWZvcm0iLCJjaGFyX2FscGhhIiwiY2hhcl9hbHBoYW51bSIsImNoYXJfd2hpdGVzcGFjZSIsImNoYXJfcHJpbnQiLCJjaGFyJDAiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJ1bmlmb3JtX2luY2x1c2l2ZSIsImxvZ191bmlmb3JtX2luY2x1c2l2ZSIsIm5vbl91bmlmb3JtIiwiaW5jbHVzaXZlIiwibG9nX2luY2x1c2l2ZSIsInVuaWZvcm1fYWxsIiwibGV0X3N5bnRheF8wMDQiLCJtYWduaXR1ZGUiLCJuZWdhdGl2ZSIsInVuaWZvcm0iLCJsb2dfdW5pZm9ybSIsImludCQwIiwiaW50X3VuaWZvcm0iLCJpbnRfaW5jbHVzaXZlIiwiaW50X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50X2xvZ19pbmNsdXNpdmUiLCJpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIiwidW5pZm9ybSQwIiwibG9nX3VuaWZvcm0kMCIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJzeW1ib2wkMzYiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInVuaWZvcm0kMiIsImxvZ191bmlmb3JtJDIiLCJpbnQ2NCIsImludDY0X3VuaWZvcm0iLCJpbnQ2NF9pbmNsdXNpdmUiLCJpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2xvZ19pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJ1bmlmb3JtJDMiLCJsb2dfdW5pZm9ybSQzIiwibmF0aXZlaW50IiwibmF0aXZlaW50X3VuaWZvcm0iLCJuYXRpdmVpbnRfaW5jbHVzaXZlIiwibmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlIiwibmF0aXZlaW50X2xvZ19pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXYiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X25vcm1hbF9tYW50aXNzYSIsIm51bV9iaXRzIiwiYml0cyIsImZsb2F0X2V4cG9uZW50IiwiZmxvYXRfemVybyIsImxldF9zeW50YXhfMDEyIiwibGV0X3N5bnRheF8wMTMiLCJmbG9hdF9zdWJub3JtYWwiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiZmxvYXRfbm9ybWFsIiwiZmxvYXRfaW5maW5pdGUiLCJsZXRfc3ludGF4XzAyMSIsImxldF9zeW50YXhfMDIyIiwiZmxvYXRfbmFuIiwiZmxvYXRfb2ZfY2xhc3MiLCJjIiwiZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyIsImZsb2F0X2Zpbml0ZSIsImZsb2F0X3dpdGhvdXRfbmFuIiwiZmxvYXQkMCIsImZsb2F0X2Zpbml0ZV9ub25femVybyIsImZsb2F0X3N0cmljdGx5X3Bvc2l0aXZlIiwiZmxvYXRfc3RyaWN0bHlfbmVnYXRpdmUiLCJmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvIiwiZmxvYXRfbmVnYXRpdmVfb3JfemVybyIsImZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIiwibG93ZXJfaW5jbHVzaXZlIiwidXBwZXJfaW5jbHVzaXZlIiwiZmxvYXRfaW5jbHVzaXZlIiwic3RyaW5nX3dpdGhfbGVuZ3RoX29mIiwiY2hhcl9nZW4iLCJzdHJpbmdfb2YiLCJzdHJpbmdfbm9uX2VtcHR5X29mIiwic3RyaW5nIiwic3RyaW5nX25vbl9lbXB0eSIsInN0cmluZ193aXRoX2xlbmd0aCIsImJ5dGVzIiwic2V4cF9vZiIsImF0b20iLCJzZXhwIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImNvbXBhcmF0b3IiLCJrZXlfZ2VuIiwiZGF0YV9nZW4iLCJrZXlzIiwia2V5cyQwIiwiZGF0YSIsInNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJtYXBfdF9tIiwibSIsInNldF90X20iLCJiaWdhcnJheTEiLCJiaWdzdHJpbmciLCJmbG9hdDMyX3ZlYyIsImZsb2F0NjRfdmVjIiwiYmlnYXJyYXkyX2RpbSIsIm1heF90b3RhbF9zaXplIiwiYSIsIm1heF9iIiwiYl93ZWlnaHRlZF9sb3ciLCJiIiwiYmlnYXJyYXkyIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImNvdmVyYWdlIiwiQ21wIiwic2FtcGxlIiwiY291bnRzIiwidmFsdWUiLCJwcmV2IiwibW9uaXRvciIsImF0b21pYyIsInNocmluayIsImZfaW52ZXJzZSIsIm9mX3Nocmlua2VyIiwic25kIiwiZnN0Iiwic3JjIiwidG9fc2tpcCIsInRvX3NraXAkMCIsImkkMCIsInIiLCJkaW0yJDAiLCJ2IiwiZGltMSQwIiwic2hyaW5rJDAiLCJmaWVsZCIsImRpbXMiLCJza2lwIiwiZWx0X3QiLCJsaXN0X3QiLCJ0YWlsIiwiaGVhZCIsInNocmlua2VyIiwibCIsInNocmlua19saXN0Iiwic2hyaW5rX3RyZWUiLCJrZXlfdCIsImRhdGFfdCIsInRyZWUiLCJkcm9wX2tleXMiLCJrIiwia2V5IiwidHJlZSQwIiwic21hbGxlcl9rZXkiLCJzaHJpbmtfa2V5cyIsInNtYWxsZXJfZGF0YSIsInNocmlua19kYXRhIiwiZHJvcF9lbHRzIiwic21hbGxlcl9lbHQiLCJzaHJpbmtfZWx0cyIsIm1hcF90Iiwic2V0X3QiLCJuYW1lcyIsImFyZzBfMDAxIiwicmVzMF8wMDIiLCJzaHJpbmtfY291bnQiLCJ0ZXN0X2NvdW50Iiwic2VlZCIsInNpemVzJDAiLCJzaHJpbmtfY291bnQkMCIsInRlc3RfY291bnQkMCIsInNlZWQkMCIsIm1ha2VfY3JlYXRvciIsInNlZWRfZnVuIiwidGVzdF9jb3VudF9mdW4iLCJzaHJpbmtfY291bnRfZnVuIiwic2l6ZXNfZnVuIiwiY29tcGlsZV9hY2MiLCJjb21waWxlX2FjYyQwIiwic2VlZF9nZW4iLCJjb21waWxlX2FjYyQxIiwidGVzdF9jb3VudF9nZW4iLCJjb21waWxlX2FjYyQyIiwic2hyaW5rX2NvdW50X2dlbiIsImNvbXBpbGVfYWNjJDMiLCJzaXplc19nZW4iLCJpdGVyIiwibWFwX3BvbHkiLCJyZWNvcmQiLCJmb3JfYWxsIiwiZXhpc3RzIiwidG9fbGlzdCIsIml0ZXIkMCIsImZvcl9hbGwkMCIsImV4aXN0cyQwIiwidG9fbGlzdCQwIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyIsInNpemVzXzAxMCIsInNocmlua19jb3VudF8wMDgiLCJ0ZXN0X2NvdW50XzAwNiIsInNlZWRfMDA0Iiwic3VmZml4IiwicHJlZml4IiwicHJlZml4JDAiLCJibmRzXzAwMyIsInN1ZmZpeCQwIiwiYXJnXzAxMSIsImJuZHNfMDAzJDAiLCJhcmdfMDA5IiwiYm5kc18wMDMkMSIsImFyZ18wMDciLCJibmRzXzAwMyQyIiwiYXJnXzAwNSIsImJuZHNfMDAzJDMiLCJkZWZhdWx0X2NvbmZpZyIsImxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSIsIndpdGhfc2FtcGxlIiwiZ2VuZXJhdG9yIiwiY29uZmlnIiwiZXhhbXBsZXMiLCJudW1iZXJfb2Zfc2l6ZV92YWx1ZXMiLCJyZW1haW5pbmdfc2l6ZXMiLCJzZXF1ZW5jZSIsImlucHV0IiwiZXJyb3IiLCJlcnJvciQxIiwiaW5wdXQkMCIsInNocmlua19jb3VudCQxIiwiYWx0ZXJuYXRlcyQyIiwiYWx0ZXJuYXRlcyIsImFsdGVybmF0ZXMkMCIsImFsdGVybmF0ZSIsImVycm9yJDAiLCJhbHRlcm5hdGVzJDEiLCJydW4iLCJNIiwiZiQwIiwid2l0aF9zYW1wbGVfZXhuIiwicnVuX2V4biIsInRlc3RhYmxlIiwidW5tYXAiLCJvZl9oYXNoX2ZvbGQiLCJ3cmFwIiwiaGFzaCQwIiwiaGFzaCQxIiwibWFwX3RyZWUiLCJrZXlfb2JzIiwiZGF0YV9vYnMiLCJzZXRfdHJlZSIsImVsdF9vYnMiXSwic291cmNlcyI6WyIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL2JpZ2FycmF5X2hlbHBlcnMubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyMC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlX3F1aWNrY2hlY2svZ2VuZXJhdG9yLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL29jYW1sL2ludDY0Lm1saSIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlX3F1aWNrY2hlY2svc2hyaW5rZXIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL3Rlc3QubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2VfcXVpY2tjaGVjay9iYXNlX3F1aWNrY2hlY2subWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7OztZQUtNQSxjQUFBLHFCQUVzQjtHQUxaLGlCQUdWQTtZQVNBQyxNQUFNQyxHQUFHQztJQUNYO0tBQTJCLE1BQUEsZUFEbkJEO0tBQ0pGLFNBQVM7S0FDQSxNQUFBLGNBRkxFO0tBQ0s7O1NBQ2JFOztNQUNFLFdBSFNE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Q0FRO09BQ0FDO09BNkNBeFA7T0FtQkF3UztPQUlBQztPQVZBb0Y7T0FJQUc7T0FyRkFQO09BREFEO09BSUF4VTtPQUZBRjs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7R0NPYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2VcblxubW9kdWxlIExheW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBCaWdhcnJheS5sYXlvdXRcblxuICBsZXQgb2Zmc2V0IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICB8IEJpZ2FycmF5LkZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICB8IEJpZ2FycmF5LkNfbGF5b3V0IC0+IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkxLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkxLmRpbSB0IC0gMSBkb1xuICAgICAgZiAoaSArIG9mZnNldCkgdC57aSArIG9mZnNldH1cbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0gfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSAoXyA6IGVsdCkgLT4gdC57aX0gPC0gZiBpKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IGluaXQgOj0gZiAhaW5pdCB0LntpfSk7XG4gICAgIWluaXRcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTEuZGltIHQpIH5mOihmdW4gaSAtPiB0LntpICsgb2Zmc2V0fSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5MS5kaW0gdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBCaWdhcnJheS5BcnJheTIudFxuXG4gIGxldCBpdGVyaSB0IH5mID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIGZvciBpID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMSB0IC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQgLSAxIGRvXG4gICAgICAgIGYgKGkgKyBvZmZzZXQpIChqICsgb2Zmc2V0KSB0LntpICsgb2Zmc2V0LCBqICsgb2Zmc2V0fVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaW5pdCAodHlwZSBlbHQpIChraW5kIDogKGVsdCwgXykgQmlnYXJyYXkua2luZCkgbGF5b3V0IGRpbTEgZGltMiB+ZiA9XG4gICAgbGV0IHQgPSBCaWdhcnJheS5BcnJheTIuY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIGogKF8gOiBlbHQpIC0+IHQue2ksIGp9IDwtIGYgaSBqKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIChfIDogaW50KSAoXyA6IGludCkgZWx0IC0+IGluaXQgOj0gZiAhaW5pdCBlbHQpO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTIubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgfmY6KGZ1biBpIC0+XG4gICAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTIuZGltMiB0KSB+ZjooZnVuIGogLT4gdC57aSArIG9mZnNldCwgaiArIG9mZnNldH0pKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgX3NleHBfb2ZfcGFjayBfc2V4cF9vZl9sYXlvdXQgdCA9XG4gICAgWyVzZXhwICh0b19hcnJheSB0IDogZWx0IGFycmF5IGFycmF5KV1cbiAgOztcblxuICBsZXQgaGFzaF9mb2xkIGhhc2hfZm9sZF9lbHQgc3RhdGUgdCA9XG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgaW5cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTIuZGltMiB0KSBpblxuICAgIGZvbGQgdCB+aW5pdDpzdGF0ZSB+ZjpoYXNoX2ZvbGRfZWx0XG4gIDs7XG5lbmRcbiIsIm9wZW4hIEJhc2VcblxudHlwZSAnYSB0ID0gJ2EgLT4gc2l6ZTppbnQgLT4gaGFzaDpIYXNoLnN0YXRlIC0+IEhhc2guc3RhdGVcblxubGV0IGNyZWF0ZSBmIDogXyB0ID0gZlxuXG5sZXQgb2JzZXJ2ZSAodCA6IF8gdCkgeCB+c2l6ZSB+aGFzaCA9XG4gIGlmIHNpemUgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suT2JzZXJ2ZXIub2JzZXJ2ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gIGVsc2UgdCB4IH5zaXplIH5oYXNoXG47O1xuXG5sZXQgb3BhcXVlIF8gfnNpemU6XyB+aGFzaCA9IGhhc2hcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIFQgOiBzaWdcbiAgdHlwZSArJ2EgdFxuXG4gIHZhbCBjcmVhdGUgOiAoc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIGdlbmVyYXRlIDogJ2EgdCAtPiBzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYSkgU3RhZ2VkLnRcblxuICBsZXQgY3JlYXRlIGYgOiBfIHQgPSBTdGFnZWQuc3RhZ2UgZlxuXG4gIGxldCBnZW5lcmF0ZSAodCA6IF8gdCkgfnNpemUgfnJhbmRvbSA9XG4gICAgaWYgc2l6ZSA8IDBcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5nZW5lcmF0ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gICAgZWxzZSBTdGFnZWQudW5zdGFnZSB0IH5zaXplIH5yYW5kb21cbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IHNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tOl8gLT4gc2l6ZSlcblxubGV0IGZuIGRvbSBybmcgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnNwbGl0IHJhbmRvbSBpblxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgaGFzaCA9IE9ic2VydmVyMC5vYnNlcnZlIGRvbSB4IH5zaXplIH5oYXNoOihIYXNoLmFsbG9jICgpKSBpblxuICAgICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLmNvcHkgcmFuZG9tIGluXG4gICAgICBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5wZXJ0dXJiIHJhbmRvbSAoSGFzaC5nZXRfaGFzaF92YWx1ZSBoYXNoKTtcbiAgICAgIGdlbmVyYXRlIHJuZyB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IHdpdGhfc2l6ZSB0IH5zaXplID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSlcblxubGV0IHBlcnR1cmIgdCBzYWx0ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnBlcnR1cmIgcmFuZG9tIHNhbHQ7XG4gICAgZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB+c2l6ZSB+cmFuZG9tID1cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgfCBTb21lIHkgLT4geVxuICAgIHwgTm9uZSAtPiBsb29wIH5zaXplOihzaXplICsgMSkgfnJhbmRvbVxuICBpblxuICBjcmVhdGUgbG9vcFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxubGV0IHJldHVybiB4ID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tOl8gLT4geClcbmxldCBtYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gZiAoZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFwcGx5IHRmIHR4ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCBmID0gZ2VuZXJhdGUgdGYgfnNpemUgfnJhbmRvbSBpblxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdHggfnNpemUgfnJhbmRvbSBpblxuICAgIGYgeClcbjs7XG5cbmxldCBiaW5kIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20gaW5cbiAgICBnZW5lcmF0ZSAoZiB4KSB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGFsbCBsaXN0ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBMaXN0Lm1hcCBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFsbF91bml0IGxpc3QgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QuaXRlciBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcbjs7XG5cbm1vZHVsZSBGb3JfYXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBhcHBseSA9IGFwcGx5XG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGJvdGggPSBGb3JfYXBwbGljYXRpdmUuYm90aFxubGV0IG1hcDIgPSBGb3JfYXBwbGljYXRpdmUubWFwMlxubGV0IG1hcDMgPSBGb3JfYXBwbGljYXRpdmUubWFwM1xuXG5tb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBGb3JfYXBwbGljYXRpdmUuQXBwbGljYXRpdmVfaW5maXhcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW5maXhcblxubW9kdWxlIEZvcl9tb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGlnbm9yZV9tID0gRm9yX21vbmFkLmlnbm9yZV9tXG5sZXQgam9pbiA9IEZvcl9tb25hZC5qb2luXG5cbm1vZHVsZSBNb25hZF9pbmZpeCA9IEZvcl9tb25hZC5Nb25hZF9pbmZpeFxuaW5jbHVkZSBNb25hZF9pbmZpeFxubW9kdWxlIExldF9zeW50YXggPSBGb3JfbW9uYWQuTGV0X3N5bnRheFxub3BlbiBMZXRfc3ludGF4XG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxpc3RcbiAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2ZfbGlzdDogZW1wdHkgbGlzdFwiXTtcbiAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gIGxldCBsbyA9IDAgaW5cbiAgbGV0IGhpID0gQXJyYXkubGVuZ3RoIGFycmF5IC0gMSBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbyB+aGkgaW5cbiAgICBhcnJheS4oaW5kZXgpKVxuOztcblxubGV0IHVuaW9uIGxpc3QgPSBqb2luIChvZl9saXN0IGxpc3QpXG5cbmxldCBvZl93ZWlnaHRlZF9saXN0IGFsaXN0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSBhbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgd2VpZ2h0cywgdmFsdWVzID0gTGlzdC51bnppcCBhbGlzdCBpblxuICBsZXQgdmFsdWVfYXJyYXkgPSBBcnJheS5vZl9saXN0IHZhbHVlcyBpblxuICBsZXQgdG90YWxfd2VpZ2h0LCBjdW11bGF0aXZlX3dlaWdodF9hcnJheSA9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHZhbHVlX2FycmF5KSB+ZjooZnVuIF8gLT4gMC4pIGluXG4gICAgbGV0IHN1bSA9XG4gICAgICBMaXN0LmZvbGRpIHdlaWdodHMgfmluaXQ6MC4gfmY6KGZ1biBpbmRleCBhY2Mgd2VpZ2h0IC0+XG4gICAgICAgIGlmIG5vdCAoRmxvYXQuaXNfZmluaXRlIHdlaWdodClcbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5vdCBmaW5pdGVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBpZiBGbG9hdC4oIDwgKSB3ZWlnaHQgMC5cbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5lZ2F0aXZlXCJcbiAgICAgICAgICAgICAgICAod2VpZ2h0IDogZmxvYXQpXTtcbiAgICAgICAgbGV0IGN1bXVsYXRpdmUgPSBhY2MgKy4gd2VpZ2h0IGluXG4gICAgICAgIGFycmF5LihpbmRleCkgPC0gY3VtdWxhdGl2ZTtcbiAgICAgICAgY3VtdWxhdGl2ZSlcbiAgICBpblxuICAgIGlmIEZsb2F0LiggPD0gKSBzdW0gMC5cbiAgICB0aGVuXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogdG90YWwgd2VpZ2h0IGlzIHplcm9cIl07XG4gICAgc3VtLCBhcnJheVxuICBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgY2hvaWNlID0gU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzowLiB+aGk6dG90YWxfd2VpZ2h0IGluXG4gICAgbWF0Y2hcbiAgICAgIEFycmF5LmJpbmFyeV9zZWFyY2hcbiAgICAgICAgY3VtdWxhdGl2ZV93ZWlnaHRfYXJyYXlcbiAgICAgICAgfmNvbXBhcmU6RmxvYXQuY29tcGFyZVxuICAgICAgICBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgICAgIGNob2ljZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgaW5kZXggLT4gdmFsdWVfYXJyYXkuKGluZGV4KVxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgd2VpZ2h0ZWRfdW5pb24gYWxpc3QgPSBqb2luIChvZl93ZWlnaHRlZF9saXN0IGFsaXN0KVxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBnZW5lcmF0ZSAoZm9yY2UgbGF6eV90KSB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2ZfZ2VuZXJhdG9yID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9nZW5lcmF0b3IgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgZm9yY2UgbGF6eV90XG47O1xuXG5sZXQgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0IHJlY19saXN0ID1cbiAgICAgIExpc3QubWFwIChmIHNlbGYpIH5mOihmdW4gKHcsIHQpIC0+XG4gICAgICAgICggd1xuICAgICAgICAsIGxldCViaW5kIG4gPSBzaXplIGluXG4gICAgICAgICAgd2l0aF9zaXplIH5zaXplOihuIC0gMSkgdCApKVxuICAgIGluXG4gICAgaWYgTGlzdC5pc19lbXB0eSBub25yZWNfbGlzdCB8fCBMaXN0LmlzX2VtcHR5IHJlY19saXN0XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iud2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uOiBsaXN0cyBtdXN0IGJlIG5vbi1lbXB0eVwiXTtcbiAgICBsZXQgbm9ucmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIG5vbnJlY19saXN0IGluXG4gICAgbGV0IHJlY19nZW4gPSB3ZWlnaHRlZF91bmlvbiAobm9ucmVjX2xpc3QgQCByZWNfbGlzdCkgaW5cbiAgICBtYXRjaCViaW5kIHNpemUgd2l0aFxuICAgIHwgMCAtPiBub25yZWNfZ2VuXG4gICAgfCBfIC0+IHJlY19nZW4pXG47O1xuXG5sZXQgcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgbGV0IHdlaWdodGVkIGxpc3QgPSBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gdCAtPiAxLiwgdCkgaW5cbiAgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uICh3ZWlnaHRlZCBub25yZWNfbGlzdCkgfmY6KGZ1biBzZWxmIC0+IHdlaWdodGVkIChmIHNlbGYpKVxuOztcblxubGV0IHNpemVzID8obWluX2xlbmd0aCA9IDApID8obWF4X2xlbmd0aCA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGFzc2VydCAobWluX2xlbmd0aCA8PSBtYXhfbGVuZ3RoKTtcbiAgICBsZXQgdXBwZXJfYm91bmQgPSBtaW5fbGVuZ3RoICsgc2l6ZSBpblxuICAgIGxldCBtYXhfbGVuZ3RoID1cbiAgICAgIGlmIHVwcGVyX2JvdW5kID49IG1pbl9sZW5ndGggKCogZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdyAqKVxuICAgICAgdGhlbiBtaW4gbWF4X2xlbmd0aCB1cHBlcl9ib3VuZFxuICAgICAgZWxzZSBtYXhfbGVuZ3RoXG4gICAgaW5cbiAgICAoKiBwaWNrIGEgbGVuZ3RoLCB3ZWlnaHRlZCBsb3cgc28gdGhhdCBtb3N0IG9mIHRoZSBzaXplIGlzIHNwZW50IG9uIGVsZW1lbnRzICopXG4gICAgbGV0IGxlbiA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOm1pbl9sZW5ndGggfmhpOm1heF9sZW5ndGggaW5cbiAgICAoKiBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgcmV0dXJuIGFuIGVtcHR5IGFycmF5LCBvdGhlcndpc2UgcmV0dXJuIGEgbm9uLWVtcHR5IGFycmF5XG4gICAgICAgd2l0aCB0aGUgc2l6ZSBkaXN0cmlidXRlZCBhbW9uZyB0aGUgZWxlbWVudHMgKilcbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNpemVzID0gQXJyYXkuaW5pdCBsZW4gfmY6KGZ1biBfIC0+IDApIGluXG4gICAgICBsZXQgcmVtYWluaW5nID0gc2l6ZSAtIChsZW4gLSBtaW5fbGVuZ3RoKSBpblxuICAgICAgbGV0IG1heF9pbmRleCA9IGxlbiAtIDEgaW5cbiAgICAgIGZvciBfID0gMSB0byByZW1haW5pbmcgZG9cbiAgICAgICAgKCogcGljayBhbiBpbmRleCwgd2VpZ2h0ZWQgbG93IHNvIHRoYXQgd2Ugc2VlIHVuYmFsYW5jZWQgZGlzdHJpYnV0aW9ucyBvZnRlbiAqKVxuICAgICAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzowIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgc2l6ZXMuKGluZGV4KSA8LSBzaXplcy4oaW5kZXgpICsgMVxuICAgICAgZG9uZTtcbiAgICAgICgqIHBlcm11dGUgdGhlIGFycmF5IHNvIHRoYXQgbm8gaW5kZXggaXMgZmF2b3JlZCBvdmVyIGFub3RoZXIgKilcbiAgICAgIGZvciBpID0gMCB0byBtYXhfaW5kZXggLSAxIGRvXG4gICAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86aSB+aGk6bWF4X2luZGV4IGluXG4gICAgICAgIEFycmF5LnN3YXAgc2l6ZXMgaSBqXG4gICAgICBkb25lO1xuICAgICAgYXNzZXJ0IChBcnJheS5zdW0gKG1vZHVsZSBJbnQpIHNpemVzIH5mOkZuLmlkICsgKGxlbiAtIG1pbl9sZW5ndGgpID0gc2l6ZSk7XG4gICAgICBBcnJheS50b19saXN0IHNpemVzKSlcbjs7XG5cbmxldCB1bml0ID0gcmV0dXJuICgpXG5sZXQgYm9vbCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBTcGxpdHRhYmxlX3JhbmRvbS5ib29sIHJhbmRvbSlcbmxldCBvcHRpb24gdmFsdWVfdCA9IHVuaW9uIFsgcmV0dXJuIE5vbmU7IG1hcCB2YWx1ZV90IH5mOk9wdGlvbi5yZXR1cm4gXVxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9IHVuaW9uIFsgbWFwIGZzdF90IH5mOkVpdGhlci5maXJzdDsgbWFwIHNuZF90IH5mOkVpdGhlci5zZWNvbmQgXVxuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgfCBTZWNvbmQgZXJyIC0+IEVycm9yIGVycilcbjs7XG5cbmxldCBsaXN0X2dlbmVyaWMgP21pbl9sZW5ndGggP21heF9sZW5ndGggZWx0X2dlbiA9XG4gIGxldCViaW5kIHNpemVzID0gc2l6ZXMgP21pbl9sZW5ndGggP21heF9sZW5ndGggKCkgaW5cbiAgTGlzdC5tYXAgc2l6ZXMgfmY6KGZ1biBzaXplIC0+IHdpdGhfc2l6ZSB+c2l6ZSBlbHRfZ2VuKSB8PiBhbGxcbjs7XG5cbmxldCBsaXN0IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgZWx0X2dlblxubGV0IGxpc3Rfbm9uX2VtcHR5IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgfm1pbl9sZW5ndGg6MSBlbHRfZ2VuXG5cbmxldCBsaXN0X3dpdGhfbGVuZ3RoIGVsdF9nZW4gfmxlbmd0aCA9XG4gIGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDpsZW5ndGggfm1heF9sZW5ndGg6bGVuZ3RoIGVsdF9nZW5cbjs7XG5cbmxldCBsaXN0X2ZpbHRlcmVkIGVsdHMgPVxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgbGVuZ3RoX29mX2lucHV0ID0gQXJyYXkubGVuZ3RoIGVsdHMgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGxlbmd0aF9vZl9vdXRwdXQgPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzowIH5oaTpsZW5ndGhfb2ZfaW5wdXQgaW5cbiAgICBsZXQgaW5kaWNlcyA9IEFycmF5LmluaXQgbGVuZ3RoX29mX2lucHV0IH5mOkZuLmlkIGluXG4gICAgKCogQ2hvb3NlIFtsZW5ndGhfb2Zfb3V0cHV0XSByYW5kb20gdmFsdWVzIGluIHRoZSBwcmVmaXggb2YgW2luZGljZXNdLiAqKVxuICAgIGZvciBpID0gMCB0byBsZW5ndGhfb2Zfb3V0cHV0IC0gMSBkb1xuICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaToobGVuZ3RoX29mX2lucHV0IC0gMSkgaW5cbiAgICAgIEFycmF5LnN3YXAgaW5kaWNlcyBpIGpcbiAgICBkb25lO1xuICAgICgqIFNvcnQgdGhlIGNob3NlbiBpbmRpY2VzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byByZW9yZGVyIHRoZW0uICopXG4gICAgQXJyYXkuc29ydCBpbmRpY2VzIH5wb3M6MCB+bGVuOmxlbmd0aF9vZl9vdXRwdXQgfmNvbXBhcmU6SW50LmNvbXBhcmU7XG4gICAgKCogUmV0dXJuIHRoZSBjaG9zZW4gZWxlbWVudHMuICopXG4gICAgTGlzdC5pbml0IGxlbmd0aF9vZl9vdXRwdXQgfmY6KGZ1biBpIC0+IGVsdHMuKGluZGljZXMuKGkpKSkpXG47O1xuXG5sZXQgbGlzdF9wZXJtdXRhdGlvbnMgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBhcnJheSA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmkgaW5cbiAgICAgIEFycmF5LnN3YXAgYXJyYXkgaSBqXG4gICAgZG9uZTtcbiAgICBBcnJheS50b19saXN0IGFycmF5KVxuOztcblxubGV0IGFycmF5IHQgPSBtYXAgKGxpc3QgdCkgfmY6QXJyYXkub2ZfbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbFxuXG5sZXQgY2hhcl91bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOihDaGFyLnRvX2ludCBsbykgfmhpOihDaGFyLnRvX2ludCBoaSlcbiAgICB8PiBDaGFyLnVuc2FmZV9vZl9pbnQpXG47O1xuXG5sZXQgY2hhcl91cHBlcmNhc2UgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICdBJyAnWidcbmxldCBjaGFyX2xvd2VyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ2EnICd6J1xubGV0IGNoYXJfZGlnaXQgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcwJyAnOSdcbmxldCBjaGFyX3ByaW50X3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcgJyAnfidcbmxldCBjaGFyX3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIENoYXIubWluX3ZhbHVlIENoYXIubWF4X3ZhbHVlXG5sZXQgY2hhcl9hbHBoYSA9IHVuaW9uIFsgY2hhcl9sb3dlcmNhc2U7IGNoYXJfdXBwZXJjYXNlIF1cblxubGV0IGNoYXJfYWxwaGFudW0gPVxuICB3ZWlnaHRlZF91bmlvblxuICAgICgqIE1vc3QgcGVvcGxlIHByb2JhYmx5IGV4cGVjdCB0aGlzIHRvIGJlIGEgdW5pZm9ybSBkaXN0cmlidXRpb24sIG5vdCB3ZWlnaHRlZFxuICAgICAgIHRvd2FyZCBkaWdpdHMgbGlrZSB3ZSB3b3VsZCBnZXQgd2l0aCBbdW5pb25dIChzaW5jZSB0aGVyZSBhcmUgZmV3ZXIgZGlnaXRzIHRoYW5cbiAgICAgICBsZXR0ZXJzKS4gKilcbiAgICBbIDUyLiwgY2hhcl9hbHBoYTsgMTAuLCBjaGFyX2RpZ2l0IF1cbjs7XG5cbmxldCBjaGFyX3doaXRlc3BhY2UgPSBvZl9saXN0IChMaXN0LmZpbHRlciBDaGFyLmFsbCB+ZjpDaGFyLmlzX3doaXRlc3BhY2UpXG5sZXQgY2hhcl9wcmludCA9IHdlaWdodGVkX3VuaW9uIFsgMTAuLCBjaGFyX2FscGhhbnVtOyAxLiwgY2hhcl9wcmludF91bmlmb3JtIF1cblxubGV0IGNoYXIgPVxuICB3ZWlnaHRlZF91bmlvblxuICAgIFsgMTAwLiwgY2hhcl9wcmludFxuICAgIDsgMTAuLCBjaGFyX3VuaWZvcm1cbiAgICA7IDEuLCByZXR1cm4gQ2hhci5taW5fdmFsdWVcbiAgICA7IDEuLCByZXR1cm4gQ2hhci5tYXhfdmFsdWVcbiAgICBdXG47O1xuXG4oKiBQcm9kdWNlcyBhIG51bWJlciBmcm9tIDAgb3IgMSB0byBzaXplICsgMSwgd2VpZ2h0ZWQgaGlnaC4gV2UgaGF2ZSBmb3VuZCB0aGlzXG4gICBkaXN0cmlidXRpb24gZW1waXJpY2FsbHkgdXNlZnVsIGZvciBzdHJpbmcgbGVuZ3Rocy4gKilcbmxldCBzbWFsbF9pbnQgfmFsbG93X3plcm8gPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGxvd2VyX2JvdW5kID0gaWYgYWxsb3dfemVybyB0aGVuIDAgZWxzZSAxIGluXG4gICAgbGV0IHVwcGVyX2JvdW5kID0gc2l6ZSArIDEgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfbG93ID1cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOih1cHBlcl9ib3VuZCAtIGxvd2VyX2JvdW5kKVxuICAgIGluXG4gICAgbGV0IHdlaWdodGVkX2hpZ2ggPSB1cHBlcl9ib3VuZCAtIHdlaWdodGVkX2xvdyBpblxuICAgIHdlaWdodGVkX2hpZ2gpXG47O1xuXG5sZXQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgPSBzbWFsbF9pbnQgfmFsbG93X3plcm86dHJ1ZVxubGV0IHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzpmYWxzZVxuXG5tb2R1bGUgdHlwZSBJbnRfd2l0aF9yYW5kb20gPSBzaWdcbiAgaW5jbHVkZSBJbnQuU1xuXG4gIHZhbCB1bmlmb3JtIDogU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiBsbzp0IC0+IGhpOnQgLT4gdFxuICB2YWwgbG9nX3VuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG5lbmRcblxubW9kdWxlIEZvcl9pbnRlZ2VyIChJbnRlZ2VyIDogSW50X3dpdGhfcmFuZG9tKSA9IHN0cnVjdFxuICBsZXQgdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLnVuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IGxvZ191bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IEludGVnZXIubG9nX3VuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IG5vbl91bmlmb3JtIGYgbG8gaGkgPVxuICAgIHdlaWdodGVkX3VuaW9uIFsgMC4wNSwgcmV0dXJuIGxvOyAwLjA1LCByZXR1cm4gaGk7IDAuOSwgZiBsbyBoaSBdXG4gIDs7XG5cbiAgbGV0IGluY2x1c2l2ZSA9IG5vbl91bmlmb3JtIHVuaWZvcm1faW5jbHVzaXZlXG4gIGxldCBsb2dfaW5jbHVzaXZlID0gbm9uX3VuaWZvcm0gbG9nX3VuaWZvcm1faW5jbHVzaXZlXG4gIGxldCB1bmlmb3JtX2FsbCA9IHVuaWZvcm1faW5jbHVzaXZlIEludGVnZXIubWluX3ZhbHVlIEludGVnZXIubWF4X3ZhbHVlXG5cbiAgbGV0IGFsbCA9XG4gICAgWyVtYXBcbiAgICAgIGxldCBuZWdhdGl2ZSA9IGJvb2xcbiAgICAgIGFuZCBtYWduaXR1ZGUgPSBsb2dfaW5jbHVzaXZlIEludGVnZXIuemVybyBJbnRlZ2VyLm1heF92YWx1ZSBpblxuICAgICAgaWYgbmVnYXRpdmUgdGhlbiBJbnRlZ2VyLmJpdF9ub3QgbWFnbml0dWRlIGVsc2UgbWFnbml0dWRlXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGb3JfaW50ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludFxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludFxuICBlbmQpXG5cbmxldCBpbnQgPSBGb3JfaW50LmFsbFxubGV0IGludF91bmlmb3JtID0gRm9yX2ludC51bmlmb3JtX2FsbFxubGV0IGludF9pbmNsdXNpdmUgPSBGb3JfaW50LmluY2x1c2l2ZVxubGV0IGludF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZVxubGV0IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDMyID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50MzJcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50MzJcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQzMlxuICBlbmQpXG5cbmxldCBpbnQzMiA9IEZvcl9pbnQzMi5hbGxcbmxldCBpbnQzMl91bmlmb3JtID0gRm9yX2ludDMyLnVuaWZvcm1fYWxsXG5sZXQgaW50MzJfaW5jbHVzaXZlID0gRm9yX2ludDMyLmluY2x1c2l2ZVxubGV0IGludDMyX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfaW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDYzID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjNcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2M1xuICBlbmQpXG5cbmxldCBpbnQ2MyA9IEZvcl9pbnQ2My5hbGxcbmxldCBpbnQ2M191bmlmb3JtID0gRm9yX2ludDYzLnVuaWZvcm1fYWxsXG5sZXQgaW50NjNfaW5jbHVzaXZlID0gRm9yX2ludDYzLmluY2x1c2l2ZVxubGV0IGludDYzX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDY0ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2NFxuICBlbmQpXG5cbmxldCBpbnQ2NCA9IEZvcl9pbnQ2NC5hbGxcbmxldCBpbnQ2NF91bmlmb3JtID0gRm9yX2ludDY0LnVuaWZvcm1fYWxsXG5sZXQgaW50NjRfaW5jbHVzaXZlID0gRm9yX2ludDY0LmluY2x1c2l2ZVxubGV0IGludDY0X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX25hdGl2ZWludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE5hdGl2ZWludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5uYXRpdmVpbnRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5uYXRpdmVpbnRcbiAgZW5kKVxuXG5sZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5hbGxcbmxldCBuYXRpdmVpbnRfdW5pZm9ybSA9IEZvcl9uYXRpdmVpbnQudW5pZm9ybV9hbGxcbmxldCBuYXRpdmVpbnRfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmxvZ19pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBmbG9hdF96ZXJvX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCAwLlxubGV0IGZsb2F0X3plcm9fbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIDAuXG5cbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID1cbiAgRmxvYXQub25lX3VscCBgRG93biBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gRmxvYXQubWF4X2Zpbml0ZV92YWx1ZVxubGV0IGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X2luZl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQuaW5maW5pdHlcbmxldCBmbG9hdF9pbmZfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfbmFuX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5uYW5cbmxldCBmbG9hdF9taW5fbmFuX21hbnRpc3NhID0gSW50NjMuc3VjYyBmbG9hdF9pbmZfbWFudGlzc2FcbmxldCBmbG9hdF9tYXhfbmFuX21hbnRpc3NhID0gZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYVxubGV0IGZsb2F0X251bV9tYW50aXNzYV9iaXRzID0gNTJcblxuKCogV2Ugd2VpZ2h0IG1hbnRpc3NhcyBzbyB0aGF0IFwiaW50ZWdlci1saWtlXCIgdmFsdWVzLCBhbmQgdmFsdWVzIHdpdGggb25seSBhIGZldyBkaWdpdHNcbiAgIHBhc3QgdGhlIGRlY2ltYWwsIGFyZSByZWFzb25hYmx5IGNvbW1vbi4gKilcbmxldCBmbG9hdF9ub3JtYWxfbWFudGlzc2EgPVxuICBsZXQlYmluZCBudW1fYml0cyA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmUgMCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBpblxuICBsZXQlbWFwIGJpdHMgPVxuICAgIEZvcl9pbnQ2My5pbmNsdXNpdmUgSW50NjMuemVybyAoSW50NjMucHJlZCAoSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHMpKVxuICBpblxuICBJbnQ2My5zaGlmdF9sZWZ0IGJpdHMgKEludC4oIC0gKSBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBudW1fYml0cylcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9sb3cgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQlbWFwIG9mZnNldCA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZSAwIChJbnQuKCAtICkgdXBwZXJfYm91bmQgbG93ZXJfYm91bmQpIGluXG4gIEludC4oICsgKSBsb3dlcl9ib3VuZCBvZmZzZXRcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCAtICkgdXBwZXJfYm91bmQgb2Zmc2V0XG47O1xuXG4oKiBXZSB3ZWlnaHQgZXhwb25lbnRzIHN1Y2ggdGhhdCB2YWx1ZXMgbmVhciAxIGFyZSBtb3JlIGxpa2VseS4gKilcbmxldCBmbG9hdF9leHBvbmVudCA9XG4gIGxldCBtaWRwb2ludCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMS4gaW5cbiAgdW5pb25cbiAgICBbIGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2hpZ2ggZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCBtaWRwb2ludFxuICAgIDsgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IG1pZHBvaW50IGZsb2F0X21heF9ub3JtYWxfZXhwb25lbnRcbiAgICBdXG47O1xuXG5sZXQgZmxvYXRfemVybyA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF96ZXJvX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X3plcm9fbWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9zdWJub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSByZXR1cm4gZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9XG4gICAgRm9yX2ludDYzLmxvZ19pbmNsdXNpdmUgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhXG4gIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25vcm1hbCA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IGZsb2F0X2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9IGZsb2F0X25vcm1hbF9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9pbmZpbml0ZSA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF9pbmZfZXhwb25lbnRcbiAgICB+bWFudGlzc2E6ZmxvYXRfaW5mX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfbmFuID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X25hbl9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBGb3JfaW50NjMuaW5jbHVzaXZlIGZsb2F0X21pbl9uYW5fbWFudGlzc2EgZmxvYXRfbWF4X25hbl9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9vZl9jbGFzcyBjID1cbiAgbWF0Y2ggKGMgOiBGbG9hdC5DbGFzcy50KSB3aXRoXG4gIHwgWmVybyAtPiBmbG9hdF96ZXJvXG4gIHwgU3Vibm9ybWFsIC0+IGZsb2F0X3N1Ym5vcm1hbFxuICB8IE5vcm1hbCAtPiBmbG9hdF9ub3JtYWxcbiAgfCBJbmZpbml0ZSAtPiBmbG9hdF9pbmZpbml0ZVxuICB8IE5hbiAtPiBmbG9hdF9uYW5cbjs7XG5cbmxldCBmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gMS5cbiAgfCBTdWJub3JtYWwgLT4gMTAuXG4gIHwgTm9ybWFsIC0+IDEwMC5cbiAgfCBJbmZpbml0ZSAtPiAxLlxuICB8IE5hbiAtPiAxLlxuOztcblxubGV0IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgZmlsdGVyID1cbiAgTGlzdC5maWx0ZXJfbWFwIEZsb2F0LkNsYXNzLmFsbCB+ZjooZnVuIGMgLT5cbiAgICBpZiBmaWx0ZXIgYyB0aGVuIFNvbWUgKGZsb2F0X3dlaWdodF9vZl9jbGFzcyBjLCBmbG9hdF9vZl9jbGFzcyBjKSBlbHNlIE5vbmUpXG4gIHw+IHdlaWdodGVkX3VuaW9uXG47O1xuXG5sZXQgZmxvYXRfZmluaXRlID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgLT4gdHJ1ZVxuICAgIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfd2l0aG91dF9uYW4gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgWmVybyB8IFN1Ym5vcm1hbCB8IE5vcm1hbCB8IEluZmluaXRlIC0+IHRydWVcbiAgICB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdCA9IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1biBfIC0+IHRydWUpXG5cbmxldCBmbG9hdF9maW5pdGVfbm9uX3plcm8gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IFplcm8gfCBJbmZpbml0ZSB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X3N0cmljdGx5X25lZ2F0aXZlID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlX25vbl96ZXJvIGluXG4gIH4tLihGbG9hdC5hYnMgdClcbjs7XG5cbmxldCBmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlIGluXG4gIEZsb2F0LmFicyB0XG47O1xuXG5sZXQgZmxvYXRfbmVnYXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIGlmIChub3QgKEZsb2F0LmlzX2Zpbml0ZSBsb3dlcl9ib3VuZCkpIHx8IG5vdCAoRmxvYXQuaXNfZmluaXRlIHVwcGVyX2JvdW5kKVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IGJvdW5kcyBhcmUgbm90IGZpbml0ZVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgbGV0IGxvd2VyX2luY2x1c2l2ZSA9IEZsb2F0Lm9uZV91bHAgYFVwIGxvd2VyX2JvdW5kIGluXG4gIGxldCB1cHBlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBEb3duIHVwcGVyX2JvdW5kIGluXG4gIGlmIGxvd2VyX2luY2x1c2l2ZSA+IHVwcGVyX2luY2x1c2l2ZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IHJlcXVlc3RlZCByYW5nZSBpcyBlbXB0eVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzpsb3dlcl9pbmNsdXNpdmUgfmhpOnVwcGVyX2luY2x1c2l2ZSlcbjs7XG5cbmxldCBmbG9hdF9pbmNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBpZiBGbG9hdC5lcXVhbCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICB0aGVuIHJldHVybiBsb3dlcl9ib3VuZFxuICBlbHNlIGlmIEZsb2F0LiggPSApIChGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCkgdXBwZXJfYm91bmRcbiAgdGhlbiB1bmlvbiBbIHJldHVybiBsb3dlcl9ib3VuZDsgcmV0dXJuIHVwcGVyX2JvdW5kIF1cbiAgZWxzZVxuICAgIHdlaWdodGVkX3VuaW9uXG4gICAgICBbIDAuMDUsIHJldHVybiBsb3dlcl9ib3VuZFxuICAgICAgOyAwLjA1LCByZXR1cm4gdXBwZXJfYm91bmRcbiAgICAgIDsgMC45LCBmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICAgICAgXVxuOztcblxubGV0IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoID1cbiAgbGlzdF93aXRoX2xlbmd0aCBjaGFyX2dlbiB+bGVuZ3RoIHw+IG1hcCB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0XG47O1xuXG5sZXQgc3RyaW5nX29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhcl9nZW4gPVxuICBiaW5kIHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZyA9IHN0cmluZ19vZiBjaGFyXG5sZXQgc3RyaW5nX25vbl9lbXB0eSA9IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhclxubGV0IHN0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoID0gc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXIgfmxlbmd0aFxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmdcblxubGV0IHNleHBfb2YgYXRvbSA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCViaW5kIHNpemUgPSBzaXplIGluXG4gICAgKCogY2hvb3NlIGEgbnVtYmVyIHdlaWdodGVkIGxvdyBzbyB3ZSBoYXZlIGEgZGVjcmVhc2luZywgYnV0IG5vdCB2YW5pc2hpbmcsIGNoYW5jZVxuICAgICAgIHRvIGdlbmVyYXRlIGF0b21zIGFzIHNpemUgZ3Jvd3MgKilcbiAgICBtYXRjaCViaW5kIEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgKHNpemUgKyAxKSB3aXRoXG4gICAgKCogZ2VuZXJhdGUgYW4gYXRvbSB1c2luZyB0aGUgZ2l2ZW4gc2l6ZSAqKVxuICAgIHwgMCAtPlxuICAgICAgbGV0JW1hcCBhdG9tID0gYXRvbSBpblxuICAgICAgU2V4cC5BdG9tIGF0b21cbiAgICAoKiByZWx5aW5nIG9uIFtMaXN0Lmdlbl0gdG8gZGlzdHJpYnV0ZSBbc2l6ZV0gb3ZlciBzdWItc2V4cHMgKilcbiAgICB8IF8gLT5cbiAgICAgIGxldCVtYXAgbGlzdCA9IGxpc3Qgc2VsZiBpblxuICAgICAgU2V4cC5MaXN0IGxpc3QpXG47O1xuXG5sZXQgc2V4cCA9IHNleHBfb2Ygc3RyaW5nXG5cbmxldCBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQlYmluZCBrZXlzID0gbGlzdCBrZXlfZ2VuIGluXG4gIGxldCBrZXlzID0gTGlzdC5kZWR1cF9hbmRfc29ydCBrZXlzIH5jb21wYXJlOmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gIGxldCViaW5kIGRhdGEgPSBsaXN0X3dpdGhfbGVuZ3RoIGRhdGFfZ2VuIH5sZW5ndGg6KExpc3QubGVuZ3RoIGtleXMpIGluXG4gIHJldHVybiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgKExpc3QuemlwX2V4biBrZXlzIGRhdGEpKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlbiA9XG4gIG1hcCAobGlzdCBlbHRfZ2VuKSB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9saXN0IH5jb21wYXJhdG9yKVxuOztcblxubGV0IGNvbXBhcmF0b3Jfb2ZfbVxuICAgICAgKHR5cGUgYSBjKVxuICAgICAgKG1vZHVsZSBNIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjKVxuICA9XG4gIE0uY29tcGFyYXRvclxuOztcblxubGV0IG1hcF90X20gbSBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW5cbiAgfD4gbWFwIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IHNldF90X20gbSBlbHRfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW5cbiAgfD4gbWFwIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IGJpZ2FycmF5MSB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JW1hcCBlbHRzID0gbGlzdCB0IGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBkaW0gPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IGRpbSB+ZjooZnVuIGkgLT4gZWx0cy4oaSAtIG9mZnNldCkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gYmlnYXJyYXkxIGNoYXIgQ2hhciBDX2xheW91dFxubGV0IGZsb2F0MzJfdmVjID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X3ZlYyA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbmxldCBiaWdhcnJheTJfZGltID1cbiAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgfCAwIC0+IHJldHVybiAoMCwgMClcbiAgfCBtYXhfdG90YWxfc2l6ZSAtPlxuICAgIGxldCViaW5kIGEgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZV0sIHdlaWdodGVkIGxvdyB0byBnaXZlIHRoZSBvdGhlclxuICAgICAgICAgZGltZW5zaW9uIGEgZ29vZCBjaGFuY2Ugb2YgYmVpbmcgY29tcGFyYXRpdmVseSBoaWdoICopXG4gICAgICBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgbWF4X3RvdGFsX3NpemVcbiAgICBpblxuICAgIGxldCViaW5kIGIgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZSAvIGFdLCB3ZWlnaHRlZCBoaWdoIHRvIHJlYWNoIGNsb3NlIHRvXG4gICAgICAgICBbbWF4X3RvdGFsX3NpemVdIG1vc3Qgb2YgdGhlIHRpbWUgKilcbiAgICAgIGxldCBtYXhfYiA9IG1heF90b3RhbF9zaXplIC8gYSBpblxuICAgICAgbGV0JW1hcCBiX3dlaWdodGVkX2xvdyA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCBtYXhfYiBpblxuICAgICAgbWF4X2IgLSBiX3dlaWdodGVkX2xvd1xuICAgIGluXG4gICAgKCogYXZvaWQgYW55IHNrZXcgb2YgYSB2cyBiIGJ5IHJhbmRvbWx5IHN3YXBwaW5nICopXG4gICAgaWYlbWFwIGJvb2wgdGhlbiBhLCBiIGVsc2UgYiwgYVxuOztcblxubGV0IGJpZ2FycmF5MiB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JWJpbmQgZGltMSwgZGltMiA9IGJpZ2FycmF5Ml9kaW0gaW5cbiAgbGV0JW1hcCBlbHRzID0gbGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTEgKGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0yIHQpIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdF9tYXAgfmY6QXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmluaXQga2luZCBsYXlvdXQgZGltMSBkaW0yIH5mOihmdW4gaSBqIC0+XG4gICAgZWx0cy4oaSAtIG9mZnNldCkuKGogLSBvZmZzZXQpKVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBEZWJ1ZyA9IHN0cnVjdFxuICBsZXQgY292ZXJhZ2VcbiAgICAgICAgKHR5cGUgayBjbXApXG4gICAgICAgIChtb2R1bGUgQ21wIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICAgIHNhbXBsZVxuICAgID1cbiAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICBzYW1wbGVcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBDbXApKVxuICAgICAgfmY6KGZ1biBjb3VudHMgdmFsdWUgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBjb3VudHMgdmFsdWUgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2ICsgMSkpXG4gIDs7XG5cbiAgbGV0IG1vbml0b3IgdCB+ZiA9XG4gICAgbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPlxuICAgICAgZiB2YWx1ZTtcbiAgICAgIHZhbHVlKVxuICA7O1xuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIG9wZXJhdGlvbnMgb24gdGhlIHR5cGUgW2ludDY0XSBvZlxuICAgc2lnbmVkIDY0LWJpdCBpbnRlZ2Vycy4gIFVubGlrZSB0aGUgYnVpbHQtaW4gW2ludF0gdHlwZSxcbiAgIHRoZSB0eXBlIFtpbnQ2NF0gaXMgZ3VhcmFudGVlZCB0byBiZSBleGFjdGx5IDY0LWJpdCB3aWRlIG9uIGFsbFxuICAgcGxhdGZvcm1zLiAgQWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvdmVyIFtpbnQ2NF0gYXJlIHRha2VuXG4gICBtb2R1bG8gMnteNjR9XG5cbiAgIFBlcmZvcm1hbmNlIG5vdGljZTogdmFsdWVzIG9mIHR5cGUgW2ludDY0XSBvY2N1cHkgbW9yZSBtZW1vcnlcbiAgIHNwYWNlIHRoYW4gdmFsdWVzIG9mIHR5cGUgW2ludF0sIGFuZCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb25cbiAgIFtpbnQ2NF0gYXJlIGdlbmVyYWxseSBzbG93ZXIgdGhhbiB0aG9zZSBvbiBbaW50XS4gIFVzZSBbaW50NjRdXG4gICBvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGV4YWN0IDY0LWJpdCBhcml0aG1ldGljLlxuXG4gICAgTGl0ZXJhbHMgZm9yIDY0LWJpdCBpbnRlZ2VycyBhcmUgc3VmZml4ZWQgYnkgTDpcbiAgICB7W1xuICAgICAgbGV0IHplcm86IGludDY0ID0gMExcbiAgICAgIGxldCBvbmU6IGludDY0ID0gMUxcbiAgICAgIGxldCBtX29uZTogaW50NjQgPSAtMUxcbiAgICBdfVxuKilcblxudmFsIHplcm8gOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAwLiAqKVxuXG52YWwgb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMS4gKilcblxudmFsIG1pbnVzX29uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIC0xLiAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG4oKiogVW5hcnkgbmVnYXRpb24uICopXG5cbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbigqKiBBZGRpdGlvbi4gKilcblxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuKCoqIFN1YnRyYWN0aW9uLiAqKVxuXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG4oKiogTXVsdGlwbGljYXRpb24uICopXG5cbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbigqKiBJbnRlZ2VyIGRpdmlzaW9uLlxuICAgQHJhaXNlIERpdmlzaW9uX2J5X3plcm8gaWYgdGhlIHNlY29uZFxuICAgYXJndW1lbnQgaXMgemVyby4gIFRoaXMgZGl2aXNpb24gcm91bmRzIHRoZSByZWFsIHF1b3RpZW50IG9mXG4gICBpdHMgYXJndW1lbnRzIHRvd2FyZHMgemVybywgYXMgc3BlY2lmaWVkIGZvciB7IVN0ZGxpYi4oLyl9LiAqKVxuXG52YWwgdW5zaWduZWRfZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshZGl2fSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuKCoqIEludGVnZXIgcmVtYWluZGVyLiAgSWYgW3ldIGlzIG5vdCB6ZXJvLCB0aGUgcmVzdWx0XG4gICBvZiBbSW50NjQucmVtIHggeV0gc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICBbeCA9IEludDY0LmFkZCAoSW50NjQubXVsIChJbnQ2NC5kaXYgeCB5KSB5KSAoSW50NjQucmVtIHggeSldLlxuICAgSWYgW3kgPSAwXSwgW0ludDY0LnJlbSB4IHldIHJhaXNlcyBbRGl2aXNpb25fYnlfemVyb10uICopXG5cbnZhbCB1bnNpZ25lZF9yZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFyZW19LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG52YWwgc3VjYyA6IGludDY0IC0+IGludDY0XG4oKiogU3VjY2Vzc29yLiAgW0ludDY0LnN1Y2MgeF0gaXMgW0ludDY0LmFkZCB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBwcmVkIDogaW50NjQgLT4gaW50NjRcbigqKiBQcmVkZWNlc3Nvci4gIFtJbnQ2NC5wcmVkIHhdIGlzIFtJbnQ2NC5zdWIgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgYWJzIDogaW50NjQgLT4gaW50NjRcbigqKiBSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIGl0cyBhcmd1bWVudC4gKilcblxudmFsIG1heF9pbnQgOiBpbnQ2NFxuKCoqIFRoZSBncmVhdGVzdCByZXByZXNlbnRhYmxlIDY0LWJpdCBpbnRlZ2VyLCAye142M30gLSAxLiAqKVxuXG52YWwgbWluX2ludCA6IGludDY0XG4oKiogVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIC0ye142M30uICopXG5cbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbigqKiBCaXR3aXNlIGxvZ2ljYWwgYW5kLiAqKVxuXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBvci4gKilcblxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBleGNsdXNpdmUgb3IuICopXG5cbnZhbCBsb2dub3QgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIEJpdHdpc2UgbG9naWNhbCBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG4oKiogW0ludDY0LnNoaWZ0X2xlZnQgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSBsZWZ0IGJ5IFt5XSBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuKCoqIFtJbnQ2NC5zaGlmdF9yaWdodCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhbiBhcml0aG1ldGljIHNoaWZ0OiB0aGUgc2lnbiBiaXQgb2YgW3hdIGlzIHJlcGxpY2F0ZWRcbiAgIGFuZCBpbnNlcnRlZCBpbiB0aGUgdmFjYXRlZCBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSByaWdodCBieSBbeV0gYml0cy5cbiAgIFRoaXMgaXMgYSBsb2dpY2FsIHNoaWZ0OiB6ZXJvZXMgYXJlIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHNcbiAgIHJlZ2FyZGxlc3Mgb2YgdGhlIHNpZ24gb2YgW3hdLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBpbnRlZ2VyICh0eXBlIFtpbnRdKSB0byBhIDY0LWJpdCBpbnRlZ2VyXG4gICAgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYW5cbiAgIGludGVnZXIgKHR5cGUgW2ludF0pLiAgT24gNjQtYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteNjN9LCBpLmUuIHRoZSBoaWdoLW9yZGVyIGJpdCBpcyBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMX0sIGkuZS4gdGhlIHRvcCAzMyBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICopXG5cbnZhbCB1bnNpZ25lZF90b19pbnQgOiBpbnQ2NCAtPiBpbnQgb3B0aW9uXG4oKiogU2FtZSBhcyB7IXRvX2ludH0sIGJ1dCBpbnRlcnByZXRzIHRoZSBhcmd1bWVudCBhcyBhbiB7ZSB1bnNpZ25lZH0gaW50ZWdlci5cbiAgICBSZXR1cm5zIFtOb25lXSBpZiB0aGUgdW5zaWduZWQgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGNhbm5vdCBmaXQgaW50byBhblxuICAgIFtpbnRdLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIDY0LWJpdCBpbnRlZ2VyLFxuICAgZGlzY2FyZGluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0ICh0cnVuY2F0ZSB0b3dhcmRzIDApLlxuICAgVGhlIHJlc3VsdCBvZiB0aGUgY29udmVyc2lvbiBpcyB1bmRlZmluZWQgaWYsIGFmdGVyIHRydW5jYXRpb24sXG4gICB0aGUgbnVtYmVyIGlzIG91dHNpZGUgdGhlIHJhbmdlIFxcW3shSW50NjQubWluX2ludH0sIHshSW50NjQubWF4X2ludH1cXF0uICopXG5cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuICopXG5cblxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKS4gVGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LCBpLmUuIHRoZSB0b3AgMzIgYml0cyBhcmUgbG9zdFxuICAgZHVyaW5nIHRoZSBjb252ZXJzaW9uLiAgKilcblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBuYXRpdmUgaW50ZWdlciAodHlwZSBbbmF0aXZlaW50XSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgbmF0aXZlIGludGVnZXIuICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0uICBPbiA2NC1iaXQgcGxhdGZvcm1zLFxuICAgdGhlIGNvbnZlcnNpb24gaXMgZXhhY3QuICopXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBhIDY0LWJpdCBpbnRlZ2VyLlxuICAgVGhlIHN0cmluZyBpcyByZWFkIGluIGRlY2ltYWwgKGJ5IGRlZmF1bHQsIG9yIGlmIHRoZSBzdHJpbmdcbiAgIGJlZ2lucyB3aXRoIFswdV0pIG9yIGluIGhleGFkZWNpbWFsLCBvY3RhbCBvciBiaW5hcnkgaWYgdGhlXG4gICBzdHJpbmcgYmVnaW5zIHdpdGggWzB4XSwgWzBvXSBvciBbMGJdIHJlc3BlY3RpdmVseS5cblxuICAgVGhlIFswdV0gcHJlZml4IHJlYWRzIHRoZSBpbnB1dCBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgW1swLCAyKkludDY0Lm1heF9pbnQrMV1dLiAgSWYgdGhlIGlucHV0IGV4Y2VlZHMgeyFJbnQ2NC5tYXhfaW50fVxuICAgaXQgaXMgY29udmVydGVkIHRvIHRoZSBzaWduZWQgaW50ZWdlclxuICAgW0ludDY0Lm1pbl9pbnQgKyBpbnB1dCAtIEludDY0Lm1heF9pbnQgLSAxXS5cblxuICAgVGhlIFtfXSAodW5kZXJzY29yZSkgY2hhcmFjdGVyIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgYW5kIGlzIGlnbm9yZWQuXG4gICBAcmFpc2UgRmFpbHVyZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdFxuICAgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCBvciBpZiB0aGUgaW50ZWdlciByZXByZXNlbnRlZFxuICAgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgcmVwcmVzZW50YWJsZSBpbiB0eXBlIFtpbnQ2NF0uICopXG5cbnZhbCBvZl9zdHJpbmdfb3B0OiBzdHJpbmcgLT4gaW50NjQgb3B0aW9uXG4oKiogU2FtZSBhcyBbb2Zfc3RyaW5nXSwgYnV0IHJldHVybiBbTm9uZV0gaW5zdGVhZCBvZiByYWlzaW5nLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCB0b19zdHJpbmcgOiBpbnQ2NCAtPiBzdHJpbmdcbigqKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQsIGluIGRlY2ltYWwuICopXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXQgYWNjb3JkaW5nXG4gICB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQuXG4gICBCaXQgNjMgb2YgdGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzaWduIG9mIHRoZSBmbG9hdDtcbiAgIGJpdHMgNjIgdG8gNTIgcmVwcmVzZW50IHRoZSAoYmlhc2VkKSBleHBvbmVudDsgYml0cyA1MSB0byAwXG4gICByZXByZXNlbnQgdGhlIG1hbnRpc3NhLiAqKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdob3NlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLFxuICAgYWNjb3JkaW5nIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dCxcbiAgIGlzIHRoZSBnaXZlbiBbaW50NjRdLiAqKVxuXG50eXBlIHQgPSBpbnQ2NFxuKCoqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiA2NC1iaXQgaW50ZWdlcnMuICopXG5cbnZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRlZ2Vycywgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uIGFzXG4gICAgeyFTdGRsaWIuY29tcGFyZX0uICBBbG9uZyB3aXRoIHRoZSB0eXBlIFt0XSwgdGhpcyBmdW5jdGlvbiBbY29tcGFyZV1cbiAgICBhbGxvd3MgdGhlIG1vZHVsZSBbSW50NjRdIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgZnVuY3RvcnNcbiAgICB7IVNldC5NYWtlfSBhbmQgeyFNYXAuTWFrZX0uICopXG5cbnZhbCB1bnNpZ25lZF9jb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogU2FtZSBhcyB7IWNvbXBhcmV9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGludGVycHJldGVkIGFzIHtlIHVuc2lnbmVkfVxuICAgIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzLjAgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIG1heDogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuICopXG5cbigqKi8qKilcblxuKCoqIHsxIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG4oKiogRG8gbm90IHVzZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24uICBJbnN0ZWFkLFxuICAgdXNlZCB7IVByaW50Zi5zcHJpbnRmfSB3aXRoIGEgWyVMLi4uXSBmb3JtYXQuICopXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBhdG9taWMgOiBfIHRcbiAgdmFsIGNyZWF0ZSA6ICgnYSAtPiAnYSBTZXF1ZW5jZS50KSAtPiAnYSB0XG4gIHZhbCBzaHJpbmsgOiAnYSB0IC0+ICdhIC0+ICdhIFNlcXVlbmNlLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgbGV0IGF0b21pYyBfID0gU2VxdWVuY2UuZW1wdHlcbiAgbGV0IGNyZWF0ZSA9IEZuLmlkXG4gIGxldCBzaHJpbmsgPSBGbi5pZFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbWFwIHQgfmYgfmZfaW52ZXJzZSA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UubWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbmxldCBmaWx0ZXIgdCB+ZiA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyIH5mIChzaHJpbmsgdCB4KSlcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiB+Zl9pbnZlcnNlID1cbiAgY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXJfbWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbjs7XG5cbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2Uub2ZfbGF6eSAobGF6eSAoc2hyaW5rIChmb3JjZSBsYXp5X3QpIHgpKSlcblxubGV0IGZpeGVkX3BvaW50IG9mX3Nocmlua2VyID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9zaHJpbmtlciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBvZl9sYXp5IGxhenlfdFxuOztcblxubGV0IGJvdGggZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biAoZnN0LCBzbmQpIC0+XG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgIFsgU2VxdWVuY2UubWFwIChzaHJpbmsgZnN0X3QgZnN0KSB+ZjooZnVuIGZzdCAtPiBmc3QsIHNuZClcbiAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgc25kX3Qgc25kKSB+ZjooZnVuIHNuZCAtPiBmc3QsIHNuZClcbiAgICAgIF0pXG47O1xuXG5sZXQgdW5pdCA9IGF0b21pY1xubGV0IGJvb2wgPSBhdG9taWNcbmxldCBjaGFyID0gYXRvbWljXG5sZXQgaW50ID0gYXRvbWljXG5sZXQgaW50MzIgPSBhdG9taWNcbmxldCBpbnQ2MyA9IGF0b21pY1xubGV0IGludDY0ID0gYXRvbWljXG5sZXQgbmF0aXZlaW50ID0gYXRvbWljXG5sZXQgZmxvYXQgPSBhdG9taWNcblxubGV0IGJpZ2FycmF5MSBzcmMgPVxuICBsZXQgZGltID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBzcmMgaW5cbiAgbWF0Y2ggZGltIHdpdGhcbiAgfCAwIC0+IFNlcXVlbmNlLmVtcHR5XG4gIHwgXyAtPlxuICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkxLmtpbmQgc3JjIGluXG4gICAgbGV0IGxheW91dCA9IEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgc3JjIGluXG4gICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICBTZXF1ZW5jZS5pbml0IGRpbSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaW5pdCBraW5kIGxheW91dCAoZGltIC0gMSkgfmY6KGZ1biBpIC0+XG4gICAgICAgIHNyYy57aWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDF9KSlcbjs7XG5cbmxldCBiaWdzdHJpbmcgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQzMl92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQ2NF92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5cbmxldCBiaWdhcnJheTIgPVxuICBsZXQgbW9kdWxlIERpbXMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBkaW0xIDogaW50XG4gICAgICA7IGRpbTIgOiBpbnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgICAgU29tZSAoU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5hZGQgdHJlZSB+Y29tcGFyYXRvciBzbWFsbGVyX2VsdCkpKSlcbiAgICBpblxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluIFsgZHJvcF9lbHRzOyBzaHJpbmtfZWx0cyBdKVxuOztcblxubGV0IG1hcF90IGtleV90IGRhdGFfdCA9XG4gIGNyZWF0ZSAoZnVuIG1hcF90IC0+XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBtYXBfdCBpblxuICAgIGxldCB0ID1cbiAgICAgIG1hcFxuICAgICAgICAobWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfdCBkYXRhX3QpXG4gICAgICAgIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOk1hcC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IG1hcF90KVxuOztcblxubGV0IHNldF90IGVsdF90ID1cbiAgY3JlYXRlIChmdW4gc2V0X3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IFNldC5jb21wYXJhdG9yIHNldF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF90KVxuICAgICAgICB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbiAgICAgICAgfmZfaW52ZXJzZTpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4gICAgaW5cbiAgICBzaHJpbmsgdCBzZXRfdClcbjs7XG4iLCJvcGVuISBCYXNlXG5pbmNsdWRlIFRlc3RfaW50ZlxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIG1vZHVsZSBTZWVkID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTm9uZGV0ZXJtaW5pc3RpY1xuICAgICAgfCBEZXRlcm1pbmlzdGljIG9mIHN0cmluZ1xuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIG1vZHVsZSBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgc2VxdWVuY2UgPVxuICAgICAgbGV0IHByZWZpeCwgc3VmZml4ID0gU2VxdWVuY2Uuc3BsaXRfbiBzZXF1ZW5jZSAxMDAgaW5cbiAgICAgIGxldCBwcmVmaXggPSBMaXN0Lm1hcCBwcmVmaXggfmY6c2V4cF9vZl9lbHQgaW5cbiAgICAgIGxldCBzdWZmaXggPVxuICAgICAgICBtYXRjaCBTZXF1ZW5jZS5pc19lbXB0eSBzdWZmaXggd2l0aFxuICAgICAgICB8IHRydWUgLT4gW11cbiAgICAgICAgfCBmYWxzZSAtPiBbIFslbWVzc2FnZSBcIi4uLlwiXSBdXG4gICAgICBpblxuICAgICAgU2V4cC5MaXN0IChwcmVmaXggQCBzdWZmaXgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IHNlZWQgOiBTZWVkLnRcbiAgICA7IHRlc3RfY291bnQgOiBpbnRcbiAgICA7IHNocmlua19jb3VudCA6IGludFxuICAgIDsgc2l6ZXMgOiBpbnQgUG90ZW50aWFsbHlfaW5maW5pdGVfc2VxdWVuY2UudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuZW5kXG5cbmxldCBkZWZhdWx0X2NvbmZpZyA6IENvbmZpZy50ID1cbiAgeyBzZWVkID0gRGV0ZXJtaW5pc3RpYyBcImFuIGFyYml0cmFyeSBidXQgZGV0ZXJtaW5pc3RpYyBzdHJpbmdcIlxuICA7IHRlc3RfY291bnQgPSAxMF8wMDBcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iLCJtb2R1bGUgR2VuZXJhdG9yID0gR2VuZXJhdG9yXG5tb2R1bGUgT2JzZXJ2ZXIgPSBPYnNlcnZlclxubW9kdWxlIFNocmlua2VyID0gU2hyaW5rZXJcbm1vZHVsZSBUZXN0ID0gVGVzdFxubW9kdWxlIEV4cG9ydCA9IEV4cG9ydFxuaW5jbHVkZSBFeHBvcnRcblxuKCoqLyoqKVxuXG4oKl8gVGhpcyBtb2R1bGUgaXMgZXhwb3NlZCBvbmx5IHRvIG1ha2Ugb2NhbWxkb2Mgb3V0cHV0IG1vcmUgcmVhZGFibGUuICopXG5tb2R1bGUgV2l0aF9iYXNpY190eXBlcyA9IFdpdGhfYmFzaWNfdHlwZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEJpZ2FycmF5X2hlbHBlcnMgPSBCaWdhcnJheV9oZWxwZXJzXG5lbmRcbiJdfQ==
