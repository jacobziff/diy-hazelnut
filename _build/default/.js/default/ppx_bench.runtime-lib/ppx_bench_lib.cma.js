// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Ppx_bench_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib = [0];
   runtime.caml_register_global(0, Ppx_bench_lib, "Ppx_bench_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Export
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib_Export = [0];
   runtime.caml_register_global
    (0, Ppx_bench_lib_Export, "Ppx_bench_lib__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Benchmark_accumulator
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ".",
    null$0 = "<unknown>",
    cst$0 = "",
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    r = [0, 0],
    libname_ref = [0, null$0];
   function set(str){libname_ref[1] = str; return 0;}
   function unset(param){libname_ref[1] = null$0; return 0;}
   var t = [0, 0];
   function pop_exn(param){t[1] = caml_call1(Stdlib_List[6], t[1]); return 0;}
   function compare(t1, t2){return runtime.caml_int_compare(t1[1], t2[1]);}
   function get_module_name_opt(t){
    var str = t[3], len = runtime.caml_ml_string_length(str), i = 0;
    for(;;){
     if((i + 4 | 0) > len) return 0;
     if(caml_call3(Stdlib_String[15], str, i, 4) == ".ml.")
      return [0,
              caml_call3
               (Stdlib_String[15], str, i + 4 | 0, (len - i | 0) - 4 | 0)];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function with_test_spec(t, test_spec){
    return [0,
            t[1],
            t[2],
            t[3],
            t[4],
            t[5],
            t[6],
            t[7],
            t[8],
            test_spec,
            t[10]];
   }
   try{var _d_ = caml_sys_getenv("BENCHMARKS_RUNNER"), v = _d_;}
   catch(_s_){
    var _a_ = caml_wrap_exception(_s_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var v = cst$0;
   }
   var
    add_environment_var = v == "TRUE" ? 1 : 0,
    libs_to_entries = caml_call2(Stdlib_Hashtbl[1], 0, 10);
   function lookup_rev_lib(libname){
    try{
     var _q_ = caml_call2(Stdlib_Hashtbl[6], libs_to_entries, libname);
     return _q_;
    }
    catch(_r_){
     var _p_ = caml_wrap_exception(_r_);
     if(_p_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function lookup_lib(libname){
    var _o_ = lookup_rev_lib(libname);
    return caml_call1(Stdlib_List[9], _o_);
   }
   try{caml_sys_getenv("FORCE_DROP_BENCH"); var _c_ = 1, force_drop = _c_;}
   catch(_n_){
    var _b_ = caml_wrap_exception(_n_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var force_drop = 0;
   }
   function get_mode(param){return force_drop ? -950194894 : 984731018;}
   function add_bench
   (name, code, filename, type_conv_path, line, startpos, endpos, test_spec){
    if(984731018 > get_mode(0)) return 0;
    var libname = libname_ref[1], ms = t[1];
    if(ms)
     var
      _k_ = caml_call1(Stdlib_List[9], ms),
      _l_ = [0, caml_call2(Stdlib_String[6], cst, _k_)];
    else
     var _l_ = 0;
    r[1]++;
    var
     entry =
       [0,
        r[1],
        code,
        type_conv_path,
        name,
        filename,
        line,
        startpos,
        endpos,
        test_spec,
        _l_],
     _m_ = [0, entry, lookup_rev_lib(libname)];
    return caml_call3(Stdlib_Hashtbl[5], libs_to_entries, libname, _m_);
   }
   function add_bench_module(name, param, _i_, _h_, _g_, _f_, _e_, f){
    if(984731018 > get_mode(0)) return 0;
    t[1] = [0, name, t[1]];
    try{caml_call1(f, 0); var _j_ = pop_exn(0); return _j_;}
    catch(ex$0){
     var ex = caml_wrap_exception(ex$0);
     pop_exn(0);
     throw caml_maybe_attach_backtrace(ex, 0);
    }
   }
   var
    Ppx_bench_lib_Benchmark_accumu =
      [0,
       [0, set, unset],
       [0, with_test_spec, compare, get_module_name_opt],
       add_environment_var,
       lookup_lib,
       add_bench,
       add_bench_module];
   runtime.caml_register_global
    (11,
     Ppx_bench_lib_Benchmark_accumu,
     "Ppx_bench_lib__Benchmark_accumulator");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfYmVuY2hfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJudWxsJDAiLCJyIiwibGlibmFtZV9yZWYiLCJzZXQiLCJzdHIiLCJ1bnNldCIsInQiLCJwb3BfZXhuIiwiY29tcGFyZSIsInQxIiwidDIiLCJnZXRfbW9kdWxlX25hbWVfb3B0IiwibGVuIiwiaSIsImkkMCIsIndpdGhfdGVzdF9zcGVjIiwidGVzdF9zcGVjIiwidiIsImFkZF9lbnZpcm9ubWVudF92YXIiLCJsaWJzX3RvX2VudHJpZXMiLCJsb29rdXBfcmV2X2xpYiIsImxpYm5hbWUiLCJsb29rdXBfbGliIiwiZm9yY2VfZHJvcCIsImdldF9tb2RlIiwiYWRkX2JlbmNoIiwibmFtZSIsImNvZGUiLCJmaWxlbmFtZSIsInR5cGVfY29udl9wYXRoIiwibGluZSIsInN0YXJ0cG9zIiwiZW5kcG9zIiwibXMiLCJlbnRyeSIsImFkZF9iZW5jaF9tb2R1bGUiLCJmIiwiZXgkMCIsImV4Il0sInNvdXJjZXMiOlsiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3BweF9iZW5jaC9ydW50aW1lLWxpYi9iZW5jaG1hcmtfYWNjdW11bGF0b3IubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0dBQ1U7OztJQVNKQTs7Ozs7O0lBVEFDO0lBVUFDLGtCQURBRjtZQUVBRyxJQUFJQyxLQURKRixpQkFDSUUsY0FBd0I7WUFDNUJDLGFBRkFILGlCQURBRixpQkFHOEI7R0FLMUIsSUFBSk07WUFFQUMsZUFGQUQsT0FFa0IsMkJBRmxCQSxnQkFFNEI7WUFtQzVCRSxRQUFRQyxJQUFHQyxJQUFLLGdDQUFSRCxPQUFHQyxPQUFzQztZQUlqREMsb0JBQW9CTDtJQUN0QixJQUFJRixNQURrQkUsTUFFbEJNLE1BQUosOEJBRElSLE1BRVNTO0lBQ1g7U0FEV0EsYUFEVEQsS0FPRztLQUhBLEdBQUEsOEJBTEhSLEtBRVNTO01BSUo7Y0FBSzttQ0FOVlQsS0FFU1MsWUFEVEQsTUFDU0M7S0FLSixJQUxJQyxNQUFBRDtLQUFBQSxJQUFBQzs7R0FRUDtZQUdKQyxlQUFlVCxHQUFFVTtJQUFZO1lBQWRWO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUVVO1lBQUZWO0dBQWtDO09BUS9DLElBQUEsTUFBQSxzQ0FERlc7Ozs7UUFBQUE7O0dBSUo7SUFMRUMsc0JBQ0VEO0lBVUZFLGtCQUFxRDtZQUVyREMsZUFBZ0JDO0lBQ2xCO0tBQUksVUFBQSw4QkFIRkYsaUJBRWdCRTtLQUNkOzs7OzJCQUNXOzs7R0FBRTtZQUdmQyxXQUFZRDtJQUFtQixVQUwvQkQsZUFLWUM7SUFBbUIsT0FBQTtHQUF5QjtPQU1oRCxxQ0FDUixJQUFBLFNBTEFFOzs7O1FBQUFBOztZQVVBQyxnQkFBYyxPQVZkRCxvQ0FVc0Q7WUFFdkNFO0lBQ0dDLE1BQ0FDLE1BQ0FDLFVBQ0FDLGdCQUNBQyxNQUNBQyxVQUNBQyxRQUNEaEI7SUFFbkIsZUFaRVEsYUFhVztRQUVQSCxVQWpIRm5CLGdCQWNBK0IsS0FQQTNCO09BT0EyQjtLQUE4QjtNQUFBLE1BQUEsMkJBQTlCQTtnQkFBVzs7O0lBeEJYaEM7SUE2SEE7S0FERWlDOztRQTVIRmpDO1FBZ0hnQjBCO1FBRUFFO1FBSEFIO1FBRUFFO1FBRUFFO1FBQ0FDO1FBQ0FDO1FBQ0RoQjs7S0FtQm1CLFVBYmhDa0IsT0FqQ0pkLGVBZ0NJQztJQWNnQyxPQUFBLDhCQWhEcENGLGlCQWtDSUU7R0Fja0U7WUFHdkRjLGlCQUNHVCxzQ0FPRFU7SUFFbkIsZUExQ0VaLGFBMkNXO0lBdElUbEIsV0E0SGdCb0IsTUE1SGhCcEI7SUF5SUYsSUFFRyxXQVJjOEIsT0FTZCxVQTFJRDdCLFlBMElDO1VBRUE4QjtTQUFBQyx5QkFBQUQ7S0E1SUQ5QjtLQThJQyxNQUFBLDRCQUZBK0I7O0dBRVM7Ozs7V0F0SlZuQyxLQUNBRTtXQTREQVUsZ0JBbEJBUCxTQUlBRztPQW9CRk87T0FrQkFJO09BY2VHO09BOEJBVTs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdW5pcXVlX2lkID1cbiAgbGV0IHIgPSByZWYgMCBpblxuICBmdW4gKCkgLT5cbiAgICBpbmNyIHI7XG4gICAgIXJcbjs7XG5cbigqIFVzZWQgdG8gdHJhY2sgdGhlIGN1cnJlbnQgbGlibmFtZSBpbiBzdWNoIGEgd2F5IHRoYXQgZm9yIGZ1bmN0b3IgYXBwbGljYXRpb25zLCBpdCBpc1xuICAgdGhlIGNhbGxpbmcgbGlicmFyaWVzIG5hbWUgdGhhdCBnZXRzIHJlZ2lzdGVyZWQuICopXG5tb2R1bGUgQ3VycmVudF9saWJuYW1lID0gc3RydWN0XG4gIGxldCBudWxsID0gXCI8dW5rbm93bj5cIlxuICBsZXQgbGlibmFtZV9yZWYgPSByZWYgbnVsbFxuICBsZXQgc2V0IHN0ciA9IGxpYm5hbWVfcmVmIDo9IHN0clxuICBsZXQgdW5zZXQgKCkgPSBsaWJuYW1lX3JlZiA6PSBudWxsXG4gIGxldCBnZXQgKCkgPSAhbGlibmFtZV9yZWZcbmVuZFxuXG5tb2R1bGUgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sgPSBzdHJ1Y3RcbiAgbGV0IHQgPSByZWYgW11cbiAgbGV0IHB1c2ggcyA9IHQgOj0gcyA6OiAhdFxuICBsZXQgcG9wX2V4biAoKSA9IHQgOj0gTGlzdC50bCAhdFxuXG4gIGxldCB0b19uYW1lICgpID1cbiAgICBtYXRjaCAhdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBtcyAtPiBTb21lIChTdHJpbmcuY29uY2F0IFwiLlwiIChMaXN0LnJldiBtcykpXG4gIDs7XG5lbmRcblxuKCogVGhpcyBpcyB0aGUgbWFpbiBkYXRhIHN0cnVjdHVyZSBvZiB0aGlzIG1vZHVsZS4gQW4gW0VudHJ5LnRdIHJlcHJlc2VudHMgYSBiZW5jaG1hcmtcbiAgIGFsb25nIHdpdGggc29tZSBtZXRhZGF0YSBhYm91dCBpcyBwb3NpdGlvbiwgYXJndW1lbnRzIGV0Yy4gKilcbm1vZHVsZSBFbnRyeSA9IHN0cnVjdFxuICB0eXBlICgncGFyYW0sICdhKSBwYXJhbWV0ZXJpc2VkX3NwZWMgPVxuICAgIHsgYXJnX25hbWUgOiBzdHJpbmdcbiAgICA7IHBhcmFtcyA6IChzdHJpbmcgKiAncGFyYW0pIGxpc3RcbiAgICA7IHRodW5rIDogJ3BhcmFtIC0+IHVuaXQgLT4gJ2FcbiAgICB9XG5cbiAgdHlwZSB0ZXN0X3NwZWMgPVxuICAgIHwgUmVndWxhcl90aHVuayA6IChbIGBpbml0IF0gLT4gdW5pdCAtPiAnYSkgLT4gdGVzdF9zcGVjXG4gICAgfCBQYXJhbWV0ZXJpc2VkX3RodW5rIDogKCdwYXJhbSwgJ2EpIHBhcmFtZXRlcmlzZWRfc3BlYyAtPiB0ZXN0X3NwZWNcblxuICB0eXBlIHQgPVxuICAgIHsgdW5pcXVlX2lkIDogaW50XG4gICAgOyBjb2RlIDogc3RyaW5nXG4gICAgOyB0eXBlX2NvbnZfcGF0aCA6IHN0cmluZ1xuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIDsgZmlsZW5hbWUgOiBzdHJpbmdcbiAgICA7IGxpbmUgOiBpbnRcbiAgICA7IHN0YXJ0cG9zIDogaW50XG4gICAgOyBlbmRwb3MgOiBpbnRcbiAgICA7IHRlc3Rfc3BlYyA6IHRlc3Rfc3BlY1xuICAgIDsgYmVuY2hfbW9kdWxlX25hbWUgOiBzdHJpbmcgb3B0aW9uXG4gICAgfVxuXG4gIGxldCBjb21wYXJlIHQxIHQyID0gY29tcGFyZSB0MS51bmlxdWVfaWQgdDIudW5pcXVlX2lkXG5cbiAgKCogRXh0cmFjdHMgbW9kdWxlIG5hbWUgZnJvbSBbXCJmaWxlbmFtZS5tbC5Nb2R1bGVcIl0sIHdoaWNoIGlzIHRoZSBmb3JtYXQgb2YgW2V4dF9uYW1lXVxuICAgICBhcyBzZXQgYnkgW3R5cGVjb252XS4gKilcbiAgbGV0IGdldF9tb2R1bGVfbmFtZV9vcHQgdCA9XG4gICAgbGV0IHN0ciA9IHQudHlwZV9jb252X3BhdGggaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpICsgNCA8PSBsZW5cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgU3RyaW5nLnN1YiBzdHIgaSA0ID0gXCIubWwuXCJcbiAgICAgICAgdGhlbiBTb21lIChTdHJpbmcuc3ViIHN0ciAoaSArIDQpIChsZW4gLSBpIC0gNCkpXG4gICAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgICBlbHNlIE5vbmVcbiAgICBpblxuICAgIGxvb3AgMFxuICA7O1xuXG4gIGxldCB3aXRoX3Rlc3Rfc3BlYyB0IHRlc3Rfc3BlYyA9IHsgdCB3aXRoIHRlc3Rfc3BlYyB9XG5lbmRcblxuKCogSW5zcGVjdCBzeXN0ZW0gZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGRlY2lkZSBpZiBiZW5jaG1hcmtzIGFyZSBiZWluZyBydW4uIFRoaXMgaXNcbiAgIGNhbGxlZCBieSB0aGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhlIFtwYV9iZW5jaF0gc3ludGF4IHRvIGRlY2lkZSBpZiB0aGUgZ2xvYmFsIGhhc2h0YWJsZVxuICAgc2hvdWxkIGJlIHBvcHVsYXRlZC4gKilcbmxldCBhZGRfZW52aXJvbm1lbnRfdmFyID1cbiAgbGV0IHYgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQkVOQ0hNQVJLU19SVU5ORVJcIiB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gXCJcIlxuICBpblxuICB2ID0gXCJUUlVFXCJcbjs7XG5cbigqIFRoaXMgaGFzaHRhYmxlIGNvbnRhaW5zIGFsbCB0aGUgYmVuY2htYXJrcyBmcm9tIGFsbCB0aGUgb2YgbGlicmFyaWVzIHRoYXQgaGF2ZSBiZWVuXG4gICBsb2FkZWQuIEF0IHRoZSB0aW1lIHRoZSBiZW5jaG1hcmtzIGFyZSByZWdpc3RlcmluZyB0aGVtc2VsdmVzIHdpdGggW3BweF9iZW5jaF9saWJdIHdlXG4gICBkb24ndCB5ZXQga25vdyB3aGljaCBsaWJyYXJpZXMgd2lsbCBuZWVkIHRvIGJlIHJ1bi4gICopXG5sZXQgbGlic190b19lbnRyaWVzIDogKHN0cmluZywgRW50cnkudCBsaXN0KSBIYXNodGJsLnQgPSBIYXNodGJsLmNyZWF0ZSAxMFxuXG5sZXQgbG9va3VwX3Jldl9saWIgfmxpYm5hbWUgPVxuICB0cnkgSGFzaHRibC5maW5kIGxpYnNfdG9fZW50cmllcyBsaWJuYW1lIHdpdGhcbiAgfCBOb3RfZm91bmQgLT4gW11cbjs7XG5cbmxldCBsb29rdXBfbGliIH5saWJuYW1lID0gTGlzdC5yZXYgKGxvb2t1cF9yZXZfbGliIH5saWJuYW1lKVxuXG5sZXQgZm9yY2VfZHJvcCA9XG4gICgqIFVzZWZ1bCBmb3IganNfb2Zfb2NhbWwgdG8gcGVyZm9ybSBkZWFkY29kZSBlbGltaW5hdGlvbi5cbiAgICAgc2VlIHBweC9wcHhfaW5saW5lX3Rlc3QvcnVudGltZS1saWIvcnVudGltZS5tbCBbQWN0aW9uLmdldF0gZm9yIG1vcmUgZGV0YWlscyAqKVxuICB0cnlcbiAgICBpZ25vcmUgKFN5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0JFTkNIXCIgOiBzdHJpbmcpO1xuICAgIHRydWVcbiAgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiBmYWxzZVxuOztcblxubGV0IGdldF9tb2RlICgpID0gaWYgZm9yY2VfZHJvcCB0aGVuIGBJZ25vcmUgZWxzZSBgQ29sbGVjdFxuXG5sZXRbQGlubGluZSBuZXZlcl0gYWRkX2JlbmNoXG4gICAgICAgICAgICAgICAgICAgICB+bmFtZVxuICAgICAgICAgICAgICAgICAgICAgfmNvZGVcbiAgICAgICAgICAgICAgICAgICAgIH5maWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICAgfnR5cGVfY29udl9wYXRoXG4gICAgICAgICAgICAgICAgICAgICB+bGluZVxuICAgICAgICAgICAgICAgICAgICAgfnN0YXJ0cG9zXG4gICAgICAgICAgICAgICAgICAgICB+ZW5kcG9zXG4gICAgICAgICAgICAgICAgICAgICB0ZXN0X3NwZWNcbiAgPVxuICBtYXRjaCBnZXRfbW9kZSAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBDb2xsZWN0IC0+XG4gICAgbGV0IGxpYm5hbWUgPSBDdXJyZW50X2xpYm5hbWUuZ2V0ICgpIGluXG4gICAgbGV0IGVudHJ5ID1cbiAgICAgIHsgRW50cnkuY29kZVxuICAgICAgOyB1bmlxdWVfaWQgPSB1bmlxdWVfaWQgKClcbiAgICAgIDsgdHlwZV9jb252X3BhdGhcbiAgICAgIDsgYmVuY2hfbW9kdWxlX25hbWUgPSBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjay50b19uYW1lICgpXG4gICAgICA7IG5hbWVcbiAgICAgIDsgZmlsZW5hbWVcbiAgICAgIDsgbGluZVxuICAgICAgOyBzdGFydHBvc1xuICAgICAgOyBlbmRwb3NcbiAgICAgIDsgdGVzdF9zcGVjXG4gICAgICB9XG4gICAgaW5cbiAgICBIYXNodGJsLmFkZCBsaWJzX3RvX2VudHJpZXMgbGlibmFtZSAoZW50cnkgOjogbG9va3VwX3Jldl9saWIgfmxpYm5hbWUpXG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gYWRkX2JlbmNoX21vZHVsZVxuICAgICAgICAgICAgICAgICAgICAgfm5hbWVcbiAgICAgICAgICAgICAgICAgICAgIH5jb2RlOl9cbiAgICAgICAgICAgICAgICAgICAgIH50eXBlX2NvbnZfcGF0aDpfXG4gICAgICAgICAgICAgICAgICAgICB+ZmlsZW5hbWU6X1xuICAgICAgICAgICAgICAgICAgICAgfmxpbmU6X1xuICAgICAgICAgICAgICAgICAgICAgfnN0YXJ0cG9zOl9cbiAgICAgICAgICAgICAgICAgICAgIH5lbmRwb3M6X1xuICAgICAgICAgICAgICAgICAgICAgZlxuICA9XG4gIG1hdGNoIGdldF9tb2RlICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYENvbGxlY3QgLT5cbiAgICAoKiBSdW5uaW5nIGYgcmVnaXN0ZXJzIHRoZSBiZW5jaG1hcmtzIHVzaW5nIEJFTkNIICopXG4gICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucHVzaCBuYW1lO1xuICAgICh0cnlcbiAgICAgICBmICgpO1xuICAgICAgIEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrLnBvcF9leG4gKClcbiAgICAgd2l0aFxuICAgICB8IGV4IC0+XG4gICAgICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucG9wX2V4biAoKTtcbiAgICAgICByYWlzZSBleClcbjs7XG4iXX0=
