// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Ppx_inline_test_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_inline_test_lib = [0];
   runtime.caml_register_global(0, Ppx_inline_test_lib, "Ppx_inline_test_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_inline_test_lib__Runtime
//# unitInfo: Requires: Base, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib_Runtim$0 = "Ppx_inline_test_lib__Runtime",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    enable_everything = [0, 0, 0],
    cst = cst$13,
    am_running_inline_test_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error";
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[25], combine, 0, ts);
   }
   var
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894],
    _E_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _F_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _z_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _A_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _B_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _C_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _D_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _G_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _H_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _J_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _K_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _I_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _x_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _y_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _r_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _t_ = [0, 1],
    _u_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _v_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _w_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _q_ = [0, [2, 0, [10, 0]], cst_s],
    _p_ = [0, [2, 0, [10, 0]], cst_s],
    _o_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib_Runtim = cst_Ppx_inline_test_lib_Runtim$0,
    cst_inline_tests_log = cst_inline_tests_log$0,
    _P_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _O_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    _h_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _g_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _f_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _e_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    _a_ = [0, [2, 0, 0], cst_s$0],
    _b_ = [0, [2, 0, 0], cst_s$0],
    cst_inline_test_runner = cst_inline_test_runner$0,
    _N_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Allow_output_patterns_in_t =
      " Allow output patterns in tests expectations",
    cst_allow_output_patterns = "-allow-output-patterns",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _n_ = [0, 187165616, 545942154],
    _L_ = [0, 187165616, -863538453];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _R_ = 1, force_drop = _R_;
   }
   catch(_br_){
    var _c_ = caml_wrap_exception(_br_);
    if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _d_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _bp_ = current[1] !== cst$13 ? 1 : 0,
     _bq_ = _bp_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _d_, current[1]) : _bp_;
    return _bq_ ? caml_call3(Stdlib_Hashtbl[5], _d_, current[1], 0) : _bq_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return p == current[1] ? 1 : 0;
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var
     t = current$0[1],
     _bo_ = caml_call2(Stdlib_List[19], function(m){return m[2];}, t);
    return caml_call1(Stdlib_List[13], _bo_);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    allow_output_patterns = [0, 0];
   function displayed_descr(param){
    var
     _bm_ = caml_obj_tag(param),
     descr =
       250 === _bm_
        ? param[1]
        : 246 === _bm_ ? caml_call1(CamlinternalLazy[2], param) : param;
    return function(filename, line, start_pos, end_pos){
     var
      _bn_ = descr == cst$13 ? cst$0 : caml_call2(Stdlib[28], cst$1, descr);
     return caml_call6
             (Stdlib_Printf[4], _e_, filename, line, start_pos, end_pos, _bn_);};
   }
   var _i_ = caml_sys_argv(0), match = caml_call1(Stdlib_Array[11], _i_);
   a:
   if(match){
    var _j_ = match[2];
    if(_j_){
     var name = match[1];
     if(_j_[1] === cst_inline_test_runner$0){
      var match$0 = _j_[2];
      if(match$0){
       var rest = match$0[2], lib = match$0[1];
       if(Base[85][1]){
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, enable_everything],
         name_filter = [0, 0],
         msg$1 =
           caml_call4
            (Stdlib_Printf[4], _N_, name, cst_inline_test_runner, lib),
         f =
           function(anon){
            caml_call3(Stdlib_Printf[3], _O_, name, anon);
            return caml_call1(Stdlib[99], 1);
           },
         l =
           caml_call2
            (Stdlib_Arg[11],
             0,
             [0,
              [0,
               cst_list_test_names,
               [0,
                function(param){
                 list_test_names[1] = 1;
                 verbose[1] = 1;
                 return 0;
                }],
               cst_Do_not_run_tests_but_show_],
              [0,
               [0,
                cst_list_partitions,
                [0, function(param){list_partitions[1] = 1; return 0;}],
                cst_Lists_all_the_partitions_t],
               [0,
                [0,
                 cst_partition,
                 [4, function(i){partition[1] = [0, i]; return 0;}],
                 cst_Only_run_the_tests_in_the_],
                [0,
                 [0,
                  cst_verbose,
                  [2, verbose],
                  cst_Show_the_tests_as_they_run],
                 [0,
                  [0,
                   cst_stop_on_error,
                   [2, stop_on_error],
                   cst_Run_tests_only_up_to_the_f],
                  [0,
                   [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
                   [0,
                    [0,
                     cst_show_counts,
                     [2, show_counts],
                     cst_Show_the_number_of_tests_r],
                    [0,
                     [0,
                      cst_log,
                      [0,
                       function(param){
                        try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                        catch(_bl_){}
                        log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                        return 0;
                       }],
                      cst_Log_the_tests_run_in_inlin],
                     [0,
                      [0,
                       cst_drop_tag,
                       [4,
                        function(tag){
                         var t = tag_predicate[1], _bj_ = [0, tag, t[2]];
                         tag_predicate[1] =
                          [0,
                           caml_call2
                            (Stdlib_List[41],
                             function(_bk_){return tag !== _bk_ ? 1 : 0;},
                             t[1]),
                           _bj_];
                         return 0;
                        }],
                       cst_tag_Only_run_tests_not_tag],
                      [0,
                       [0,
                        cst_require_tag,
                        [4,
                         function(tag){
                          var
                           t = tag_predicate[1],
                           _bh_ =
                             caml_call2
                              (Stdlib_List[41],
                               function(_bi_){return tag !== _bi_ ? 1 : 0;},
                               t[2]);
                          tag_predicate[1] = [0, [0, tag, t[1]], _bh_];
                          return 0;
                         }],
                        cst_tag_Only_run_tests_tagged_],
                       [0,
                        [0,
                         cst_matching,
                         [4,
                          function(s){
                           name_filter[1] = [0, s, name_filter[1]];
                           return 0;
                          }],
                         cst_substring_Only_run_tests_w],
                        [0,
                         [0,
                          cst_only_test,
                          [4,
                           function(str){
                            try{
                             var
                              _ba_ =
                                [0,
                                 caml_call3
                                  (Stdlib_Scanf[4],
                                   str,
                                   _h_,
                                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                                   })],
                              match = _ba_;
                            }
                            catch(_be_){
                             try{
                              var
                               _a$_ =
                                 [0,
                                  caml_call3
                                   (Stdlib_Scanf[4],
                                    str,
                                    _g_,
                                    function(file, line){return [0, file, [0, line]];})],
                               match = _a$_;
                             }
                             catch(_bf_){
                              try{
                               var
                                _a__ =
                                  [0,
                                   caml_call3
                                    (Stdlib_Scanf[4],
                                     str,
                                     _f_,
                                     function(file){return [0, file, 0];})],
                                match = _a__;
                              }
                              catch(_bg_){var match = 0;}
                             }
                            }
                            if(match)
                             var
                              match$0 = match[1],
                              index = match$0[2],
                              file = match$0[1],
                              index$0 = index,
                              filename = file;
                            else if(caml_call2(Stdlib_String[14], str, 58)){
                             var
                              i = caml_call2(Stdlib_String[35], str, 58),
                              filename$0 = caml_call3(Stdlib_String[15], str, 0, i),
                              index_string =
                                caml_call3
                                 (Stdlib_String[15],
                                  str,
                                  i + 1 | 0,
                                  (caml_ml_string_length(str) - i | 0) - 1 | 0);
                             try{
                              var
                               _bc_ = runtime.caml_int_of_string(index_string),
                               index$1 = _bc_;
                             }
                             catch(_bd_){
                              var _bb_ = caml_wrap_exception(_bd_);
                              if(_bb_[1] !== Stdlib[7])
                               throw caml_maybe_attach_backtrace(_bb_, 0);
                              caml_call2(Stdlib_Printf[3], _P_, str);
                              var index$1 = caml_call1(Stdlib[99], 1);
                             }
                             var index$0 = [0, index$1], filename = filename$0;
                            }
                            else
                             var index$0 = 0, filename = str;
                            tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
                            return 0;
                           }],
                          cst_location_Run_only_the_test],
                         [0,
                          [0,
                           cst_no_color,
                           [3, use_color],
                           cst_Summarize_tests_without_us],
                          [0,
                           [0,
                            cst_in_place,
                            [2, in_place],
                            cst_Update_expect_tests_in_pla],
                           [0,
                            [0,
                             cst_diff_cmd,
                             [4, function(s){diff_command[1] = [0, s]; return 0;}],
                             cst_Diff_command_for_tests_tha],
                            [0,
                             [0,
                              cst_allow_output_patterns,
                              [2, allow_output_patterns],
                              cst_Allow_output_patterns_in_t],
                             [0,
                              [0,
                               cst_source_tree_root,
                               [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
                               cst_Path_to_the_root_of_the_so],
                              0]]]]]]]]]]]]]]]]]),
         argv = caml_call1(Stdlib_Array[12], [0, name, rest]);
        try{caml_call5(Stdlib_Arg[3], 0, argv, l, f, msg$1);}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] === Stdlib_Arg[8]){
          var msg = exn[2];
          caml_call2(Stdlib_Printf[3], _a_, msg);
          caml_call1(Stdlib[99], 1);
         }
         else{
          if(exn[1] !== Stdlib_Arg[7])
           throw caml_maybe_attach_backtrace(exn, 0);
          var msg$0 = exn[2];
          caml_call2(Stdlib_Printf[2], _b_, msg$0);
          caml_call1(Stdlib[99], 0);
         }
        }
        var
         _Q_ = list_partitions[1] ? -260537174 : [0, 1025081494, partition[1]],
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _Q_]];
        action[1] = v;
        break a;
       }
      }
     }
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_a8_){
     var _k_ = caml_wrap_exception(_a8_);
     if(_k_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_k_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_a9_){
       var _l_ = caml_wrap_exception(_a9_);
       if(_l_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_l_, 0);
       var _m_ = 0;
       break b;
      }
      var _M_ = val !== "inline-test" ? 0 : 1, _m_ = _M_;
     }
     var am_running_inline_test = _m_;
     break a;
    }
    var am_running_inline_test = 1;
   }
   var
    testing = am_test_runner ? _n_ : am_running_inline_test ? _L_ : 822171972;
   function wall_time_clock_ns(param){return caml_call1(Time_now[1], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _a6_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _a7_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib_Runtim, _a6_);
        return caml_call2(Base_String[70][2], 0, _a7_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = wall_time_clock_ns(0);
    try{var _a5_ = [0, caml_call1(f, 0)], res = _a5_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _a3_ = wall_time_clock_ns(0),
     _a4_ = caml_call2(Base_Int63[42], _a3_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _a4_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_a2_){
        return caml_call1(Stdlib_Random[12][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_a1_){
        return caml_call1(Base_Random[18][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var
     t = current$0[1],
     _aW_ = caml_call2(Stdlib_List[19], function(m){return m[1];}, t),
     _aX_ =
       caml_call2
        (Stdlib_List[19],
         function(s){
          var
           _aY_ = caml_call1(Stdlib_String[28], s),
           _aZ_ = caml_call2(Stdlib[28], _aY_, cst$3),
           _a0_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _aZ_);
          return caml_call2(Stdlib[28], cst_in_TES, _a0_);
         },
         _aW_);
    return caml_call2(Stdlib_String[6], cst$4, _aX_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[9], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _aV_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _o_, _aV_);
    return caml_call2
            (Stdlib_List[17],
             function(message){
              return caml_call2(Stdlib_Printf[3], _p_, message);
             },
             delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    return caml_call2
            (Stdlib_Printf[10],
             function(s){
              if(verbose[1])
               delayed_errors[1] = [0, s, delayed_errors[1]];
              else
               caml_call2(Stdlib_Printf[3], _q_, s);
              var _aU_ = stop_on_error[1];
              return _aU_
                      ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2))
                      : _aU_;
             },
             fmt);
   }
   function add_hooks(C){
    return function(f, param){caml_call1(C[1], 0); return caml_call1(f, 0);};
   }
   function hum_backtrace(backtrace){
    var
     _aO_ = caml_call1(Base_String[88], backtrace),
     _aP_ =
       caml_call2
        (Base_List[133],
         _aO_,
         function(str){
          var
           _aS_ = caml_obj_tag(where_to_cut_backtrace),
           _aT_ =
             250 === _aS_
              ? where_to_cut_backtrace[1]
              : 246
                === _aS_
                ? caml_call1(CamlinternalLazy[2], where_to_cut_backtrace)
                : where_to_cut_backtrace;
          return 1 - caml_call2(Base_String[70][5], _aT_, str);
         }),
     _aQ_ =
       caml_call2
        (Base_List[76],
         _aP_,
         function(str){
          var _aR_ = caml_call2(Base[197], str, cst$5);
          return caml_call2(Base[197], cst$6, _aR_);
         });
    return caml_call2(Base_String[54], 0, _aQ_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _ar_ = match[2],
     what_to_do = _ar_[2],
     match$0 = _ar_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1],
     _aF_ = add_hooks(config);
    function f$0(_aM_){var _aN_ = _aM_; return _aF_(f, _aN_);}
    var
     descr$0 =
       [246,
        function(_aL_){
         return displayed_descr(descr)
                 (def_filename, def_line_number, start_pos, end_pos);
        }],
     _as_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _as_),
     _at_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_at_){
     var
      _au_ =
        only_test_location
         ? caml_call2
           (Stdlib_List[33],
            function(param){
             var
              used = param[3],
              line_number_opt = param[2],
              filename = param[1],
              position_start =
                caml_ml_string_length(def_filename)
                - caml_ml_string_length(filename)
                | 0,
              _aG_ = 0 <= position_start ? 1 : 0;
             if(_aG_){
              var
               end_of_def_filename =
                 caml_call3
                  (Stdlib_String[15],
                   def_filename,
                   position_start,
                   caml_ml_string_length(filename)),
               _aH_ = end_of_def_filename == filename ? 1 : 0;
              if(_aH_){
               var
                _aI_ = 0 === position_start ? 1 : 0,
                _aJ_ =
                  _aI_
                  ||
                   (47
                     ===
                      runtime.caml_string_get
                       (def_filename, position_start - 1 | 0)
                     ? 1
                     : 0);
               if(_aJ_)
                if(line_number_opt)
                 var
                  line_number = line_number_opt[1],
                  _aK_ = caml_equal(def_line_number, line_number);
                else
                 var _aK_ = 1;
               else
                var _aK_ = _aJ_;
              }
              else
               var _aK_ = _aH_;
              var found = _aK_;
             }
             else
              var found = _aG_;
             if(found) used[1] = 1;
             return found;
            },
            only_test_location)
         : 1;
     if(_au_){
      var
       _am_ =
         caml_call2
          (Stdlib_List[33],
           function(req){
            return 1 - caml_call2(Stdlib_List[36], req, complete_tags);
           },
           which_tags[1]),
       _av_ =
         _am_
         ||
          caml_call2
           (Stdlib_List[33],
            function(dropped){
             return caml_call2(Stdlib_List[36], dropped, complete_tags);
            },
            which_tags[2]),
       _aw_ = 1 - _av_;
      if(_aw_)
       var
        _ax_ = caml_obj_tag(descr$0),
        descr$1 =
          250 === _ax_
           ? descr$0[1]
           : 246 === _ax_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0,
        _ay_ =
          name_filter
           ? caml_call2
             (Stdlib_List[33],
              function(substring){
               return caml_call2(Base_String[76], descr$1, substring);
              },
              name_filter)
           : 1,
        should_run = _ay_;
      else
       var should_run = _aw_;
     }
     else
      var should_run = _au_;
    }
    else
     var should_run = _at_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _az_ = is_current(partition);
     if(_az_){
      var
       _aA_ = caml_obj_tag(descr$0),
       descr$2 =
         250 === _aA_
          ? descr$0[1]
          : 246 === _aA_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0;
      tests_ran[1]++;
      var match$1 = log[1];
      if(match$1){
       var ch = match$1[1], _aB_ = string_of_module_descr(0);
       caml_call4(Stdlib_Printf[1], ch, _r_, descr$2, _aB_);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _s_, descr$2);
      if(list_test_names[1])
       var result$0 = _t_;
      else{
       var
        caml_random_state = caml_call1(Stdlib_Random[13], 0),
        base_random_state = caml_call1(Base_Random[18][4], Base_Random[18][1]),
        _an_ = caml_obj_tag(saved_caml_random_state),
        _ao_ =
          250 === _an_
           ? saved_caml_random_state[1]
           : 246
             === _an_
             ? caml_call1(CamlinternalLazy[2], saved_caml_random_state)
             : saved_caml_random_state;
       caml_call1(Stdlib_Random[14], _ao_);
       var
        _ap_ = caml_obj_tag(saved_base_random_state),
        _aq_ =
          250 === _ap_
           ? saved_base_random_state[1]
           : 246
             === _ap_
             ? caml_call1(CamlinternalLazy[2], saved_base_random_state)
             : saved_base_random_state;
       caml_call1(Base_Random[19], _aq_);
       var result = time_without_resetting_random_(f$0);
       caml_call1(Stdlib_Random[14], caml_random_state);
       caml_call1(Base_Random[19], base_random_state);
       var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, time_sec[1]);
      if(0 !== result$0[0]){
       var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
       tests_failed[1]++;
       var
        backtrace$0 = hum_backtrace(backtrace),
        exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
        sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$7 : cst$8,
        _aD_ = string_of_module_descr(0);
       return caml_call5
               (eprintf_or_delay(_w_),
                descr$2,
                sep,
                exn_str,
                backtrace$0,
                _aD_);
      }
      if(result$0[1]) return 0;
      tests_failed[1]++;
      var _aC_ = string_of_module_descr(0);
      return caml_call2(eprintf_or_delay(_v_), descr$2, _aC_);
     }
     var _aE_ = _az_;
    }
    else
     var _aE_ = should_run;
    return _aE_;
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _al_ = which_tests[1] == static_lib ? 1 : 0;
    if(! _al_) return _al_;
    a:
    {
     if(typeof what_to_do !== "number" && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(partition == cst$13 && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _aj_ = lib == static_lib ? 1 : 0,
     _ak_ = _aj_ ? (dynamic_lib[1] = 0, 0) : _aj_;
    return _ak_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _$_ = match[2],
     what_to_do = _$_[2],
     match$0 = _$_[1],
     which_tags = match$0[4],
     libname = match$0[1],
     _ag_ = add_hooks(config);
    function f$0(_ah_){var _ai_ = _ah_; return _ag_(f, _ai_);}
    var
     _aa_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _aa_),
     _ab_ = caml_equal([0, libname], dynamic_lib[1]),
     should_run =
       _ab_
        ? 1
         -
          caml_call2
           (Stdlib_List[33],
            function(dropped){
             return caml_call2(Stdlib_List[36], dropped, partial_tags);
            },
            which_tags[2])
        : _ab_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _ac_ = is_current(partition);
     if(_ac_){
      test_modules_ran[1]++;
      var
       descr$0 =
         displayed_descr(descr)
          (def_filename, def_line_number, start_pos, end_pos),
       prev = current$0[1];
      current$0[1] = [0, [0, descr$0, tags], prev];
      try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       current$0[1] = prev;
       throw caml_maybe_attach_backtrace(e, 0);
      }
      if(0 === x[0]) return 0;
      var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
      test_modules_failed[1]++;
      var
       backtrace$0 = hum_backtrace(backtrace),
       exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
       sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$9 : cst$10,
       _ad_ = string_of_module_descr(0),
       _ae_ = caml_call1(Stdlib_String[28], descr$0);
      return caml_call5
              (eprintf_or_delay(caml_call2(Stdlib[98], _y_, _x_)),
               _ae_,
               sep,
               exn_str,
               backtrace$0,
               _ad_);
     }
     var _af_ = _ac_;
    }
    else
     var _af_ = should_run;
    return _af_;
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var _X_ = match[2], which_tests = _X_[1];
     if(typeof _X_[2] === "number"){
      var
       _U_ =
         caml_call3
          (Stdlib_Hashtbl[14],
           function(k, param, acc){return [0, k, acc];},
           _d_,
           0),
       _V_ = caml_call2(Stdlib_List[56], Stdlib_String[9], _U_),
       _Y_ = caml_call1(Stdlib_Printf[2], _B_);
      caml_call2(Stdlib_List[17], _Y_, _V_);
      return 0;
     }
     var match$0 = log[1];
     if(match$0){var ch = match$0[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _C_, tests_ran[1], test_modules_ran[1]);
      var
       unused_tests =
         caml_call2
          (Stdlib_List[41],
           function(param){var used = param[3]; return 1 - used[1];},
           which_tests[2]),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _D_);
       caml_call2
        (Stdlib_List[17],
         function(param){
          var line_number_opt = param[2], filename = param[1];
          if(! line_number_opt)
           return caml_call2(Stdlib_Printf[3], _F_, filename);
          var line_number = line_number_opt[1];
          return caml_call3(Stdlib_Printf[3], _E_, filename, line_number);
         },
         tests);
       caml_call1(Stdlib_Printf[3], _G_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _Z_ = cst$11;
     else
      var
       ___ = caml_call2(Stdlib[98], _K_, _J_),
       _Z_ = caml_call2(Stdlib_Printf[4], ___, count_test_modules);
     caml_call4(Stdlib_Printf[3], _I_, count, tests_ran[1], _Z_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _W_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if(caml_call1(Stdlib_Filename[13], _W_) == "inline_tests_runner.exe"){caml_call1(Stdlib_Printf[3], _z_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _A_);
    }
    return 2;
   }
   var
    use_color$0 = use_color[1],
    in_place$0 = in_place[1],
    diff_command$0 = diff_command[1],
    source_tree_root$0 = source_tree_root[1],
    allow_output_patterns$0 = allow_output_patterns[1],
    evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _S_ = caml_call1(Stdlib_List[9], evaluators[1]);
    switch
     (combine_all
       (caml_call2
         (Stdlib_List[19], function(f){return caml_call1(f, 0);}, _S_))){
      case 0:
       var _T_ = 0; break;
      case 1:
       var _T_ = 2; break;
      default: var _T_ = 1;
    }
    return caml_call1(Stdlib[99], _T_);
   }
   var
    Ppx_inline_test_lib_Runtime =
      [0,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       testing,
       use_color$0,
       in_place$0,
       diff_command$0,
       source_tree_root$0,
       allow_output_patterns$0,
       am_running_inline_test,
       am_running_inline_test_env_var,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (124, Ppx_inline_test_lib_Runtime, cst_Ppx_inline_test_lib_Runtim$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlbmFibGVfZXZlcnl0aGluZyIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciIsInRvX3N0cmluZyIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJhbGxvd19vdXRwdXRfcGF0dGVybnMiLCJkaXNwbGF5ZWRfZGVzY3IiLCJkZXNjciIsImZpbGVuYW1lIiwibGluZSIsInN0YXJ0X3BvcyIsImVuZF9wb3MiLCJuYW1lIiwicmVzdCIsImxpYiIsInRlc3RzIiwibGlzdF9wYXJ0aXRpb25zIiwicGFydGl0aW9uIiwidGFnX3ByZWRpY2F0ZSIsIm5hbWVfZmlsdGVyIiwibXNnJDEiLCJmIiwiYW5vbiIsImwiLCJpIiwidGFnIiwicyIsInN0ciIsImZpbGUiLCJpbmRleCIsImluZGV4JDAiLCJmaWxlbmFtZSQwIiwiaW5kZXhfc3RyaW5nIiwiaW5kZXgkMSIsImFyZ3YiLCJtc2ciLCJtc2ckMCIsInYiLCJhbV90ZXN0X3J1bm5lciIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3QiLCJ0ZXN0aW5nIiwid2FsbF90aW1lX2Nsb2NrX25zIiwid2hlcmVfdG9fY3V0X2JhY2t0cmFjZSIsInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tXyIsImJlZm9yZV9ucyIsInJlcyIsImV4biQwIiwiZXhuIiwic2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUiLCJzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSIsInN0cmluZ19vZl9tb2R1bGVfZGVzY3IiLCJwcmludF9kZWxheWVkX2Vycm9ycyIsImRlbGF5ZWRfZXJyb3JzJDAiLCJtZXNzYWdlIiwiZXByaW50Zl9vcl9kZWxheSIsImZtdCIsImFkZF9ob29rcyIsIkMiLCJodW1fYmFja3RyYWNlIiwiYmFja3RyYWNlIiwidGVzdF9pbm5lciIsImNvbmZpZyIsInRhZ3MiLCJkZWZfZmlsZW5hbWUiLCJkZWZfbGluZV9udW1iZXIiLCJib29sX29mX2YiLCJ3aGF0X3RvX2RvIiwid2hpY2hfdGFncyIsIm9ubHlfdGVzdF9sb2NhdGlvbiIsImxpYm5hbWUiLCJmJDAiLCJkZXNjciQwIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsImRlc2NyJDEiLCJzdWJzdHJpbmciLCJzaG91bGRfcnVuIiwiZGVzY3IkMiIsImNoIiwicmVzdWx0JDAiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwicmVzdWx0IiwiYmFja3RyYWNlJDAiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInBhcnRpYWxfdGFncyIsInByZXYiLCJ4IiwiZSQwIiwiZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJjb3VudCIsImNvdW50X3Rlc3RfbW9kdWxlcyIsInVudXNlZF90ZXN0cyIsImVycm9ycyIsInVzZV9jb2xvciQwIiwiaW5fcGxhY2UkMCIsImRpZmZfY29tbWFuZCQwIiwic291cmNlX3RyZWVfcm9vdCQwIiwiYWxsb3dfb3V0cHV0X3BhdHRlcm5zJDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvcHB4X2lubGluZV90ZXN0L3J1bnRpbWUtbGliL3J1bnRpbWUubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0RE1BOztJQWtQRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXJTRUM7SUFBWTs7T0FDRDs7T0FDQTtlQUNBOztHQUFPO1lBR2xCQyxRQUFRQyxJQUFHQztJQUNiOztZQURVRDs7YUFBR0MsSUFFZ0I7Ozs7Y0FGaEJBLElBSWdCOztJQURBO0dBQ087WUFHbENDLFlBQVlDO0lBQUssT0FBQSw0QkFQakJKLFlBT1lJO0dBQXNDO0dBWWpDO0lBQW5CQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQXFFRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVVO0lBQStDLElBQUEsU0FEekRDOzs7OztRQUFBQTs7WUFHQUMsV0FNRixPQVRFRCwwQkFEQUQsVUFZVTtHQVdKLElBQUEsTUFBQSxzQ0FDTkc7WUFDQUM7SUFDRjtLQUFHLE9BRkREO0tBRUMsa0JBQXNC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O09BVUY7T0FDQTs7O1VBQVUsSUFBZ0J2Qyw0QkFBVmxFO1VBQ2QsS0FEd0JrRTtXQUVkLE9BQUEsa0NBRklsRTtjQUdQcUUsY0FIaUJIO1VBR0YsT0FBQSxrQ0FIUmxFLFVBR1BxRTtTQUNSO1NBTkk5RDtPQU9MO09BQUE7O2VBeGtCUnBDLGdCQTZJQWU7T0ErYlU7T0FBQTs7TUFFTzs7Y0FJTnFIOzs7TUFFa0Q7T0FBQSxNQUFBO2FBQWYsa0NBRm5DQTtLQUNQLGtDQURBRCxPQWxsQkpuSTtLQW1sQkk7Ozs7S0FqREQsR0FBQTtNQUFzQztNQUFsQixHQUFBLG1FQUNyQjs7S0FHQTs7SUFBQTtHQWdEQztHQVFVO0lBTmJ1SSxjQWpjQWpIO0lBa2NBa0gsYUFqY0FqSDtJQWtjQWtILGlCQWpjQWpIO0lBa2NBa0gscUJBamNBakg7SUFrY0FrSCwwQkFqY0FqSDtJQW1jQWtILHFCQS9EQVo7WUFnRUFhLGNBQWVuRyxHQURma0csb0JBQ2VsRyxHQURma0cseUJBQ2lEO1lBQ2pERTtJQUN1QixVQUFBLDJCQUh2QkY7O01BNW1CRWhKO1FBK21CSjtvQ0FBYzhDLEdBQUssT0FBQSxXQUFMQSxNQUFTOzs7Ozs7O0lBQXZCLE9BQUE7R0FHTzs7OztXQXpuQkhqRCxTQU9BRyxhQWJBSjtPQTZkRjBIO09BdUJBSTtPQVVBQztPQUlBRTtPQUllQztPQWpOZjdEO09BOFRBMEU7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0EzVUEvRTtPQVBBckU7T0FxVkFzSjtPQUNBQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFRlc3RfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9IFN1Y2Nlc3MgfCBGYWlsdXJlIHwgRXJyb3JcblxuICBsZXQgdG9fZXhpdF9jb2RlID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gMFxuICAgIHwgRmFpbHVyZSAtPiAyXG4gICAgfCBFcnJvciAgIC0+IDFcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gXCJzdWNjZXNzXCJcbiAgICB8IEZhaWx1cmUgLT4gXCJmYWlsdXJlXCJcbiAgICB8IEVycm9yICAgLT4gXCJlcnJvclwiXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmUgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBTdWNjZXNzLCBTdWNjZXNzICAgICAgICAtPiBTdWNjZXNzXG4gICAgfCBFcnJvciAgLCBfIHwgXywgRXJyb3IgICAtPiBFcnJvclxuICAgIHwgRmFpbHVyZSwgXyB8IF8sIEZhaWx1cmUgLT4gRmFpbHVyZVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbCB0cyA9IExpc3QuZm9sZF9sZWZ0IGNvbWJpbmUgU3VjY2VzcyB0c1xuZW5kXG5cbmxldCBwYXJzZV9hcmd2IGFyZ3YgbCBmIG1zZyA9XG4gIHRyeVxuICAgIEFyZy5wYXJzZV9hcmd2IGFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQXJnLkJhZCBtc2cgLT4gUHJpbnRmLmVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAxXG4gIHwgQXJnLkhlbHAgbXNnIC0+IFByaW50Zi5wcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG47O1xuXG50eXBlIGRlc2NyID0gc3RyaW5nXG5sZXQgdGVzdF9tb2R1bGVzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdF9tb2R1bGVzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgdGVzdHNfcmFuID0gcmVmIDBcbmxldCB0ZXN0c19mYWlsZWQgPSByZWYgMFxubGV0IGR5bmFtaWNfbGliIDogc3RyaW5nIG9wdGlvbiByZWYgPSByZWYgTm9uZVxudHlwZSBmaWxlbmFtZSA9IHN0cmluZ1xudHlwZSBsaW5lX251bWJlciA9IGludFxudHlwZSBzdGFydF9wb3MgPSBpbnRcbnR5cGUgZW5kX3BvcyA9IGludFxudHlwZSBjb25maWcgPSAobW9kdWxlIElubGluZV90ZXN0X2NvbmZpZy5TKVxudHlwZSAnYSB0ZXN0X2Z1bmN0aW9uX2FyZ3NcbiAgPSBjb25maWc6Y29uZmlnXG4gIC0+IGRlc2NyOmRlc2NyIExhenkudFxuICAtPiB0YWdzOnN0cmluZyBsaXN0XG4gIC0+IGZpbGVuYW1lOmZpbGVuYW1lXG4gIC0+IGxpbmVfbnVtYmVyOmxpbmVfbnVtYmVyXG4gIC0+IHN0YXJ0X3BvczpzdGFydF9wb3NcbiAgLT4gZW5kX3BvczplbmRfcG9zXG4gIC0+ICdhXG5cbm1vZHVsZSBUYWdfcHJlZGljYXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyByZXF1aXJlZF90YWdzICA6IHN0cmluZyBsaXN0XG4gICAgOyBkcm9wcGVkX3RhZ3MgOiBzdHJpbmcgbGlzdFxuICAgIH1cblxuICBsZXQgZW5hYmxlX2V2ZXJ5dGhpbmcgPSB7IHJlcXVpcmVkX3RhZ3MgPSBbXTsgZHJvcHBlZF90YWdzID0gW10gfVxuXG4gIGxldCBkcm9wIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IHRhZyA6OiB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IExpc3QuZmlsdGVyICgoPD4pIHRhZykgdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuXG4gIGxldCByZXF1aXJlIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IExpc3QuZmlsdGVyICgoPD4pIHRhZykgdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSB0YWcgOjogdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuXG4gIGxldCBlbnRpcmVfbW9kdWxlX2Rpc2FibGVkIHQgfnBhcnRpYWxfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuXG4gIGxldCBkaXNhYmxlZCB0IH5jb21wbGV0ZV90YWdzOnRhZ3MgPVxuICAgIExpc3QuZXhpc3RzIChmdW4gcmVxIC0+IG5vdCAoTGlzdC5tZW0gcmVxIHRhZ3MpKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB8fCBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuZW5kXG5cblxudHlwZSB3aGljaF90ZXN0cyA9XG4gIHsgbGlibmFtZSA6IHN0cmluZ1xuICA7IG9ubHlfdGVzdF9sb2NhdGlvbiA6IChmaWxlbmFtZSAqIGxpbmVfbnVtYmVyIG9wdGlvbiAqIGJvb2wgcmVmKSBsaXN0XG4gIDsgbmFtZV9maWx0ZXIgOiBzdHJpbmcgbGlzdFxuICA7IHdoaWNoX3RhZ3MgOiBUYWdfcHJlZGljYXRlLnRcbiAgfVxudHlwZSB0ZXN0X21vZGUgPVxuICB7IHdoaWNoX3Rlc3RzIDogd2hpY2hfdGVzdHNcbiAgOyB3aGF0X3RvX2RvIDpcbiAgICAgIFsgYFJ1bl9wYXJ0aXRpb24gb2Ygc3RyaW5nIG9wdGlvblxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zXG4gICAgICBdXG4gIH1cblxubW9kdWxlIEFjdGlvbiA6IHNpZ1xuICB0eXBlIHQgPSBbXG4gICAgfCBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICBdXG4gIHZhbCBnZXQgOiB1bml0IC0+IHRcbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IFtcbiAgICB8IGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gIF1cbiAgbGV0IGFjdGlvbiA6IHQgcmVmID0gcmVmIGBJZ25vcmVcbiAgbGV0IGZvcmNlX2Ryb3AgPVxuICAgIHRyeSBpZ25vcmUgKFN5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCIgOiBzdHJpbmcpOyB0cnVlXG4gICAgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcbiAgbGV0IGdldCAoKSA9XG4gICAgKCogVGhpcyBpcyB1c2VmdWwgd2hlbiBjb21waWxpbmcgdG8gamF2YXNjcmlwdC5cbiAgICAgICBKc19vZl9vY2FtbCBjYW4gc3RhdGljYWxseSBldmFsdWF0ZSBbU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIl1cbiAgICAgICBhbmQgaW5saW5lIHRoZSByZXN1bHQgKFtgSWdub3JlXSkgd2hlbmV2ZXIgW2dldCAoKV0gaXMgY2FsbGVkLlxuICAgICAgIFVuaXQgdGVzdHMgY2FuIHRoZW4gYmUgdHJlYXRlZCBhcyBkZWFkY29kZSBzaW5jZSB0aGUgYXJndW1lbnQgW2ZdIG9mIHRoZSBbdGVzdF1cbiAgICAgICBmdW5jdGlvbiBiZWxvdyBpcyBuZXZlciB1c2VkLiAqKVxuICAgIGlmIGZvcmNlX2Ryb3BcbiAgICB0aGVuIGBJZ25vcmVcbiAgICBlbHNlICFhY3Rpb25cblxuICBsZXQgc2V0IHYgPSBhY3Rpb24gOj0gdlxuZW5kXG5cbm1vZHVsZSBQYXJ0aXRpb24gOiBzaWdcbiAgdmFsIGZvdW5kX3Rlc3QgOiB1bml0IC0+IHVuaXRcbiAgdmFsIHNldF9jdXJyZW50IDogc3RyaW5nIC0+IHVuaXRcbiAgdmFsIGlzX2N1cnJlbnQgOiBzdHJpbmcgb3B0aW9uIC0+IGJvb2xcbiAgdmFsIGFsbCA6IHVuaXQgLT4gc3RyaW5nIGxpc3RcbmVuZCA9IHN0cnVjdFxuICBsZXQgYWxsID0gSGFzaHRibC5jcmVhdGUgMjNcbiAgbGV0IGN1cnJlbnQgPSByZWYgXCJcIiAgbGV0IHNldF9jdXJyZW50IHggPSBjdXJyZW50IDo9IHhcbiAgbGV0IGZvdW5kX3Rlc3QgKCkgPVxuICAgIGlmICFjdXJyZW50IDw+IFwiXCIgJiYgbm90IChIYXNodGJsLm1lbSBhbGwgIWN1cnJlbnQpIHRoZW5cbiAgICAgIEhhc2h0YmwuYWRkIGFsbCAhY3VycmVudCAoKVxuICA7O1xuICBsZXQgaXNfY3VycmVudCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgcCAtPiBwID0gIWN1cnJlbnRcbiAgOztcbiAgbGV0IGFsbCAoKSA9XG4gICAgTGlzdC5zb3J0IFN0cmluZy5jb21wYXJlXG4gICAgICAoSGFzaHRibC5mb2xkIChmdW4gayAoKSBhY2MgLT4gayA6OiBhY2MpIGFsbCBbXSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTW9kdWxlX2NvbnRleHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIG9uZV9tb2R1bGUgPVxuICAgICAgeyBkZXNjciA6IHN0cmluZ1xuICAgICAgOyB0YWdzIDogc3RyaW5nIGxpc3RcbiAgICAgIH1cblxuICAgIHR5cGUgdCA9IG9uZV9tb2R1bGUgbGlzdFxuXG4gICAgbGV0IGRlc2NyIHQgPSBMaXN0Lm1hcCAoZnVuIG0gLT4gbS5kZXNjcikgdFxuICAgIGxldCB0YWdzIHQgPSBMaXN0LmNvbmNhdCAoTGlzdC5tYXAgKGZ1biBtIC0+IG0udGFncykgdClcbiAgZW5kXG5cbiAgbGV0IGN1cnJlbnQgOiBULnQgcmVmID0gcmVmIFtdXG5cbiAgbGV0IHdpdGhfIH5kZXNjciB+dGFncyBmID1cbiAgICBsZXQgcHJldiA9ICFjdXJyZW50IGluXG4gICAgY3VycmVudCA6PSB7IFQuIGRlc2NyOyB0YWdzIH0gOjogcHJldjtcbiAgICB0cnlcbiAgICAgIGxldCB4ID0gZiAoKSBpblxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgeFxuICAgIHdpdGggZSAtPlxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgcmFpc2UgZVxuXG4gIGxldCBjdXJyZW50X2Rlc2NyICgpID0gVC5kZXNjciAhY3VycmVudFxuICBsZXQgY3VycmVudF90YWdzICAoKSA9IFQudGFncyAgIWN1cnJlbnRcbmVuZFxuXG5sZXQgdmVyYm9zZSA9IHJlZiBmYWxzZVxubGV0IHN0cmljdCA9IHJlZiBmYWxzZVxubGV0IHNob3dfY291bnRzID0gcmVmIGZhbHNlXG5sZXQgbGlzdF90ZXN0X25hbWVzID0gcmVmIGZhbHNlXG5sZXQgZGVsYXllZF9lcnJvcnMgPSByZWYgW11cbmxldCBzdG9wX29uX2Vycm9yID0gcmVmIGZhbHNlXG5cbmxldCBsb2cgPSByZWYgTm9uZVxuXG5sZXQgdGltZV9zZWMgPSByZWYgMC5cblxubGV0IHVzZV9jb2xvciA9IHJlZiB0cnVlXG5sZXQgaW5fcGxhY2UgID0gcmVmIGZhbHNlXG5sZXQgZGlmZl9jb21tYW5kID0gcmVmIE5vbmVcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gcmVmIE5vbmVcbmxldCBhbGxvd19vdXRwdXRfcGF0dGVybnMgPSByZWYgZmFsc2VcblxubGV0IGRpc3BsYXllZF9kZXNjciAobGF6eSBkZXNjcikgZmlsZW5hbWUgbGluZSBzdGFydF9wb3MgZW5kX3BvcyA9XG4gIFByaW50Zi5zcHJpbnRmIFwiRmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZCVzXCJcbiAgICBmaWxlbmFtZSBsaW5lIHN0YXJ0X3BvcyBlbmRfcG9zXG4gICAgKGlmIGRlc2NyID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBcIjogXCIgXiBkZXNjcilcbmxldCBwYXJzZV9kZXNjciBzdHIgPVxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICwgbGluZSAlZCAsIGNoYXJhY3RlcnMgJWQgLSAlZCAlIVwiXG4gICAgICAgICAgICAgIChmdW4gZmlsZSBsaW5lIF9zdGFydF9wb3MgX2VuZF9wb3MgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgd2l0aCBfIC0+XG4gIHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgLCBsaW5lICVkICUhXCIgKGZ1biBmaWxlIGxpbmUgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgd2l0aCBfIC0+XG4gIHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgJSFcIiAoZnVuIGZpbGUgLT4gZmlsZSwgTm9uZSkpXG4gIHdpdGggXyAtPiBOb25lXG5cbmxldCAoKSA9XG4gIG1hdGNoIEFycmF5LnRvX2xpc3QgU3lzLmFyZ3Ygd2l0aFxuICB8IG5hbWUgOjogXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiA6OiBsaWIgOjogcmVzdFxuICAgIHdoZW4gQmFzZS5FeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcy5hbV90ZXN0aW5nIC0+IGJlZ2luXG4gICAgICAoKiB3aGVuIHdlIHNlZSB0aGlzIGFyZ3VtZW50LCB3ZSBzd2l0Y2ggdG8gdGVzdCBtb2RlICopXG4gICAgICBsZXQgdGVzdHMgPSByZWYgW10gaW5cbiAgICAgIGxldCBsaXN0X3BhcnRpdGlvbnMgPSByZWYgZmFsc2UgaW5cbiAgICAgIGxldCBwYXJ0aXRpb24gPSByZWYgTm9uZSBpblxuICAgICAgbGV0IHRhZ19wcmVkaWNhdGUgPSByZWYgVGFnX3ByZWRpY2F0ZS5lbmFibGVfZXZlcnl0aGluZyBpblxuICAgICAgbGV0IG5hbWVfZmlsdGVyID0gcmVmIFtdIGluXG4gICAgICBwYXJzZV9hcmd2IChBcnJheS5vZl9saXN0IChuYW1lIDo6IHJlc3QpKSAoQXJnLmFsaWduIFtcbiAgICAgICAgXCItbGlzdC10ZXN0LW5hbWVzXCIsIEFyZy5Vbml0IChmdW4gKCkgLT4gbGlzdF90ZXN0X25hbWVzIDo9IHRydWU7IHZlcmJvc2UgOj0gdHJ1ZSksXG4gICAgICAgIFwiIERvIG5vdCBydW4gdGVzdHMgYnV0IHNob3cgd2hhdCB3b3VsZCBoYXZlIGJlZW4gcnVuXCI7XG4gICAgICAgIFwiLWxpc3QtcGFydGl0aW9uc1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+IGxpc3RfcGFydGl0aW9ucyA6PSB0cnVlKSxcbiAgICAgICAgXCIgTGlzdHMgYWxsIHRoZSBwYXJ0aXRpb25zIHRoYXQgY29udGFpbiBhdCBsZWFzdCBvbmUgdGVzdCBvciB0ZXN0X21vZHVsZVwiO1xuICAgICAgICBcIi1wYXJ0aXRpb25cIiwgQXJnLlN0cmluZyAoZnVuIGkgLT4gcGFydGl0aW9uIDo9IFNvbWUgaSksXG4gICAgICAgIFwiIE9ubHkgcnVuIHRoZSB0ZXN0cyBpbiB0aGUgZ2l2ZW4gcGFydGl0aW9uXCI7XG4gICAgICAgIFwiLXZlcmJvc2VcIiwgQXJnLlNldCB2ZXJib3NlLCBcIiBTaG93IHRoZSB0ZXN0cyBhcyB0aGV5IHJ1blwiO1xuICAgICAgICBcIi1zdG9wLW9uLWVycm9yXCIsIEFyZy5TZXQgc3RvcF9vbl9lcnJvciwgXCIgUnVuIHRlc3RzIG9ubHkgdXAgdG8gdGhlIGZpcnN0IGVycm9yIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2Vzbid0IHdvcmsgZm9yIGV4cGVjdCB0ZXN0cylcIjtcbiAgICAgICAgXCItc3RyaWN0XCIsIEFyZy5TZXQgc3RyaWN0LCBcIiBFbmQgd2l0aCBhbiBlcnJvciBpZiBubyB0ZXN0cyB3ZXJlIHJ1blwiO1xuICAgICAgICBcIi1zaG93LWNvdW50c1wiLCBBcmcuU2V0IHNob3dfY291bnRzLCBcIiBTaG93IHRoZSBudW1iZXIgb2YgdGVzdHMgcmFuXCI7XG4gICAgICAgIFwiLWxvZ1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+XG4gICAgICAgICAgKHRyeSBTeXMucmVtb3ZlIFwiaW5saW5lX3Rlc3RzLmxvZ1wiIHdpdGggXyAtPiAoKSk7XG4gICAgICAgICAgbG9nIDo9IFNvbWUgKG9wZW5fb3V0IFwiaW5saW5lX3Rlc3RzLmxvZ1wiKVxuICAgICAgICApLCBcIiBMb2cgdGhlIHRlc3RzIHJ1biBpbiBpbmxpbmVfdGVzdHMubG9nXCI7XG4gICAgICAgIFwiLWRyb3AtdGFnXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLmRyb3AgIXRhZ19wcmVkaWNhdGUgc1xuICAgICAgICApLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyBub3QgdGFnZ2VkIHdpdGggW3RhZ10gKG92ZXJyaWRlcyBwcmV2aW91cyAtcmVxdWlyZS10YWcpXCI7XG4gICAgICAgIFwiLXJlcXVpcmUtdGFnXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLnJlcXVpcmUgIXRhZ19wcmVkaWNhdGUgc1xuICAgICAgICApLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1kcm9wLXRhZylcIjtcbiAgICAgICAgXCItbWF0Y2hpbmdcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gbmFtZV9maWx0ZXIgOj0gcyA6OiAhbmFtZV9maWx0ZXIpLFxuICAgICAgICBcInN1YnN0cmluZyBPbmx5IHJ1biB0ZXN0cyB3aG9zZSBuYW1lcyBjb250YWluIHRoZSBnaXZlbiBzdWJzdHJpbmdcIjtcbiAgICAgICAgXCItb25seS10ZXN0XCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgbGV0IGZpbGVuYW1lLCBpbmRleCA9XG4gICAgICAgICAgICBtYXRjaCBwYXJzZV9kZXNjciBzIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSAoZmlsZSwgaW5kZXgpIC0+IGZpbGUsIGluZGV4XG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHMgJzonIHRoZW5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc6JyBpblxuICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IFN0cmluZy5zdWIgcyAwIGkgaW5cbiAgICAgICAgICAgICAgICBsZXQgaW5kZXhfc3RyaW5nID0gU3RyaW5nLnN1YiBzIChpICsgMSkgKFN0cmluZy5sZW5ndGggcyAtIGkgLSAxKSBpblxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9XG4gICAgICAgICAgICAgICAgICB0cnkgaW50X29mX3N0cmluZyBpbmRleF9zdHJpbmdcbiAgICAgICAgICAgICAgICAgIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgICAgXCJBcmd1bWVudCAlcyBkb2Vzbid0IGZpdCB0aGUgZm9ybWF0IGZpbGVuYW1lWzpsaW5lX251bWJlcl1cXG4lIVwiIHM7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgMVxuICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUsIFNvbWUgaW5kZXhcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHMsIE5vbmVcbiAgICAgICAgICBpblxuICAgICAgICAgIHRlc3RzIDo9IChmaWxlbmFtZSwgaW5kZXgsIHJlZiBmYWxzZSkgOjogIXRlc3RzXG4gICAgICAgICksIFwibG9jYXRpb24gUnVuIG9ubHkgdGhlIHRlc3RzIHNwZWNpZmllZCBieSBhbGwgdGhlIC1vbmx5LXRlc3Qgb3B0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICBMb2NhdGlvbnMgY2FuIGJlIG9uZSBvZiB0aGVzZSBmb3JtczpcbiAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWxcbiAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWw6bGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyM1xuICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCIsIGxpbmUgMjMsIGNoYXJhY3RlcnMgMi0zXCI7XG4gICAgICAgIFwiLW5vLWNvbG9yXCIsIEFyZy5DbGVhciB1c2VfY29sb3IsIFwiIFN1bW1hcml6ZSB0ZXN0cyB3aXRob3V0IHVzaW5nIGNvbG9yXCI7XG4gICAgICAgIFwiLWluLXBsYWNlXCIsIEFyZy5TZXQgaW5fcGxhY2UsIFwiIFVwZGF0ZSBleHBlY3QgdGVzdHMgaW4gcGxhY2VcIjtcbiAgICAgICAgXCItZGlmZi1jbWRcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gZGlmZl9jb21tYW5kIDo9IFNvbWUgcyksXG4gICAgICAgIFwiIERpZmYgY29tbWFuZCBmb3IgdGVzdHMgdGhhdCByZXF1aXJlIGRpZmZpbmcgKHVzZSAtIHRvIGRpc2FibGUgZGlmZmluZylcIjtcbiAgICAgICAgXCItYWxsb3ctb3V0cHV0LXBhdHRlcm5zXCIsIEFyZy5TZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zLFxuICAgICAgICBcIiBBbGxvdyBvdXRwdXQgcGF0dGVybnMgaW4gdGVzdHMgZXhwZWN0YXRpb25zXCI7XG4gICAgICAgIFwiLXNvdXJjZS10cmVlLXJvb3RcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gc291cmNlX3RyZWVfcm9vdCA6PSBTb21lIHMpLFxuICAgICAgICBcIiBQYXRoIHRvIHRoZSByb290IG9mIHRoZSBzb3VyY2UgdHJlZVwiXG4gICAgICBdKSAoZnVuIGFub24gLT5cbiAgICAgICAgUHJpbnRmLmVwcmludGYgXCIlczogdW5leHBlY3RlZCBhbm9ueW1vdXMgYXJndW1lbnQgJXNcXG4lIVwiIG5hbWUgYW5vbjtcbiAgICAgICAgZXhpdCAxXG4gICAgICApIChQcmludGYuc3ByaW50ZiBcIiVzICVzICVzIFthcmdzXVwiIG5hbWUgXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiBsaWIpO1xuICAgICAgQWN0aW9uLnNldCAoXG4gICAgICAgIGBUZXN0X21vZGVcbiAgICAgICAgICB7IHdoaWNoX3Rlc3RzID1cbiAgICAgICAgICAgICAgeyBsaWJuYW1lID0gbGliXG4gICAgICAgICAgICAgIDsgb25seV90ZXN0X2xvY2F0aW9uID0gIXRlc3RzO1xuICAgICAgICAgICAgICAgIHdoaWNoX3RhZ3MgPSAhdGFnX3ByZWRpY2F0ZTtcbiAgICAgICAgICAgICAgICBuYW1lX2ZpbHRlciA9ICFuYW1lX2ZpbHRlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgOyB3aGF0X3RvX2RvID1cbiAgICAgICAgICAgICAgaWYgIWxpc3RfcGFydGl0aW9uc1xuICAgICAgICAgICAgICB0aGVuIGBMaXN0X3BhcnRpdGlvbnNcbiAgICAgICAgICAgICAgZWxzZSBgUnVuX3BhcnRpdGlvbiAhcGFydGl0aW9uXG4gICAgICAgICAgfSlcbiAgICBlbmRcbiAgfCBfIC0+XG4gICAgKClcblxubGV0IGFtX3Rlc3RfcnVubmVyID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYFRlc3RfbW9kZSBfIC0+IHRydWVcbiAgfCBgSWdub3JlIC0+IGZhbHNlXG5cbmxldCBhbV9ydW5uaW5nX2lubGluZV90ZXN0X2Vudl92YXIgPVxuICAoKiBmb3IgYXBwcm94aW1hdGUgY29tcGF0aWJpbGl0eSwgZ2l2ZW4gdGhhdCB0aGUgdmFyaWFibGUgaXMgbm90IGV4YWN0bHkgZXF1aXZhbGVudFxuICAgICB0byB3aGF0IFBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVCB1c2VkIHRvIGJlICopXG4gIFwiVEVTVElOR19GUkFNRVdPUktcIlxuXG4oKiBUaGlzIHZhbHVlIGlzIGRlcHJlY2F0ZWQgaW4gcHJpbmNpcGxlLCBpbiBmYXZvciBvZiBDb3JlLmFtX3J1bm5pbmdfdGVzdCwgc29cbiAgIHdlJ3JlIGdvaW5nIHRvIGxpdmUgd2l0aCB0aGUgdWdseSBwYXR0ZXJuIG1hdGNoLiAqKVxubGV0IGFtX3J1bm5pbmdfaW5saW5lX3Rlc3QgPVxuICBtYXRjaCBTeXMuZ2V0ZW52IFwiUFBYX0lOTElORV9URVNUX0xJQl9BTV9SVU5OSU5HX0lOTElORV9URVNUXCIgd2l0aFxuICB8IChfIDogc3RyaW5nKSAtPiB0cnVlICgqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcGVvcGxlIHNldHRpbmcgdGhpcyB2YXJpYWJsZSBkaXJlY3RseSAqKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICBtYXRjaCBTeXMuZ2V0ZW52IGFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciB3aXRoXG4gICAgfCBcImlubGluZS10ZXN0XCIgLT4gdHJ1ZVxuICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBmYWxzZVxuICAgIHwgXyAtPiBmYWxzZVxuXG5sZXQgdGVzdGluZyA9XG4gIGlmIGFtX3Rlc3RfcnVubmVyXG4gIHRoZW4gYFRlc3RpbmcgYEFtX3Rlc3RfcnVubmVyXG4gIGVsc2VcbiAgICAoaWYgYW1fcnVubmluZ19pbmxpbmVfdGVzdFxuICAgICB0aGVuIGBUZXN0aW5nIGBBbV9jaGlsZF9vZl90ZXN0X3J1bm5lclxuICAgICBlbHNlIGBOb3RfdGVzdGluZylcblxubGV0IHdhbGxfdGltZV9jbG9ja19ucyAoKSA9XG4gIFRpbWVfbm93Lm5hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2ggKClcblxuXG5sZXQgd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSA9IGxhenkgKFxuICBCYXNlLlN0cmluZy5TZWFyY2hfcGF0dGVybi5jcmVhdGUgKF9fTU9EVUxFX18gXiBcIi5cIiBeIFwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNcIikpXG5cbmxldCB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmID1cbiAgbGV0IGJlZm9yZV9ucyA9IHdhbGxfdGltZV9jbG9ja19ucyAoKSBpblxuICBsZXQgcmVzID1cbiAgICAoKiBUbyBhdm9pZCBub2lzZSBpbiBiYWNrdHJhY2VzLCB3ZSBkbyB0d28gdGhpbmdzLlxuXG4gICAgICAgV2UgdXNlIFt3aGVyZV90b19jdXRfYmFja3RyYWNlXSBhYm92ZSB0byByZW1vdmUgdGhlIHN0YWNrIGZyYW1lcyBmb3IgdGhlIGN1cnJlbnRcbiAgICAgICBmdW5jdGlvbiBhbmQgYW55IGZ1bmN0aW9uIGl0IGdldHMgaW5saW5lZCBpbnRvLCBhcyBpdCdzIG5vdCBvZiBhbnkgaW50ZXJlc3QgdG8gdGhlXG4gICAgICAgdXNlciwgc2luY2UgaXQncyBub3QgdGFsa2luZyBhYm91dCB0aGVpciB0ZXN0IGJ1dCBpbnN0ZWFkIHRhbGtpbmcgYWJvdXQgdGhlXG4gICAgICAgcHB4X2lubGluZV90ZXN0IG1hY2hpbmVyeS5cblxuICAgICAgIFdlIGFsc28gYXZvaWQgaW5zZXJ0aW5nIGFueSBjb2RlIGJldHdlZW4gdGhlIFtmXSB0aGF0IGNvbWVzIGZyb20gdGhlIHVzZXIncyBmaWxlXG4gICAgICAgYW5kIGdyYWJiaW5nIHRoZSBiYWNrdHJhY2UgZnJvbSBpdHMgZXhjZXB0aW9ucyAobm8gd3JhcHBpbmcgb2YgW2ZdIHdpdGggaGlnaCBvcmRlclxuICAgICAgIGZ1bmN0aW9ucyBsaWtlIEV4bi5wcm90ZWN0LCBvciAoZnVuICgpIC0+IGYgKCk7IHRydWUpKS4gKilcbiAgICB0cnkgT2sgKGYgKCkpXG4gICAgd2l0aCBleG4gLT4gRXJyb3IgKGV4biwgUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgaW5cbiAgdGltZV9zZWMgOj0gQmFzZS5JbnQ2My4od2FsbF90aW1lX2Nsb2NrX25zICgpIC0gYmVmb3JlX25zIHw+IHRvX2Zsb2F0KSAgLy4gMWU5O1xuICByZXNcblxuXG5sZXQgc2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUgPSBsYXp5IChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2UgW3wgMTAwOyAyMDA7IDMwMCB8XSlcbmxldCBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSA9IGxhenkgKEJhc2UuUmFuZG9tLlN0YXRlLm1ha2UgW3wgMTExOyAyMjI7IDMzMyB8XSlcblxubGV0IHRpbWVfYW5kX3Jlc2V0X3JhbmRvbV9zZWVkcyBmID1cbiAgbGV0IGNhbWxfcmFuZG9tX3N0YXRlID0gU3RkbGliLlJhbmRvbS5nZXRfc3RhdGUgKCkgaW5cbiAgbGV0IGJhc2VfcmFuZG9tX3N0YXRlID0gQmFzZS5SYW5kb20uU3RhdGUuY29weSBCYXNlLlJhbmRvbS5TdGF0ZS5kZWZhdWx0IGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIChMYXp5LmZvcmNlIHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlKTtcbiAgQmFzZS5SYW5kb20uc2V0X3N0YXRlIChMYXp5LmZvcmNlIHNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlKTtcbiAgbGV0IHJlc3VsdCA9IHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYgaW5cbiAgU3RkbGliLlJhbmRvbS5zZXRfc3RhdGUgY2FtbF9yYW5kb21fc3RhdGU7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSBiYXNlX3JhbmRvbV9zdGF0ZTtcbiAgcmVzdWx0XG5cbmxldCBzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpID1cbiAgU3RyaW5nLmNvbmNhdCBcIlwiIChcbiAgICBMaXN0Lm1hcCAoZnVuIHMgLT4gXCIgIGluIFRFU1wiIF4gXCJUX01PRFVMRSBhdCBcIiBeIFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkgcyBeIFwiXFxuXCIpXG4gICAgICAoTW9kdWxlX2NvbnRleHQuY3VycmVudF9kZXNjciAoKSlcbiAgKVxuXG5sZXQgcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBsID1cbiAgTGlzdC5leGlzdHMgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgdXNlZCkgLT5cbiAgICBsZXQgcG9zaXRpb25fc3RhcnQgPVxuICAgICAgU3RyaW5nLmxlbmd0aCBkZWZfZmlsZW5hbWUgLSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgbGV0IGZvdW5kID1cbiAgICAgIHBvc2l0aW9uX3N0YXJ0ID49IDAgJiZcbiAgICAgIGxldCBlbmRfb2ZfZGVmX2ZpbGVuYW1lID1cbiAgICAgICAgU3RyaW5nLnN1YiBkZWZfZmlsZW5hbWVcbiAgICAgICAgICBwb3NpdGlvbl9zdGFydFxuICAgICAgICAgIChTdHJpbmcubGVuZ3RoIGZpbGVuYW1lKSBpblxuICAgICAgZW5kX29mX2RlZl9maWxlbmFtZSA9IGZpbGVuYW1lXG4gICAgICAmJiAocG9zaXRpb25fc3RhcnQgPSAwIHx8IGRlZl9maWxlbmFtZS5bcG9zaXRpb25fc3RhcnQgLSAxXSA9ICcvJylcbiAgICAgICYmIChtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgbGluZV9udW1iZXIgLT4gZGVmX2xpbmVfbnVtYmVyID0gbGluZV9udW1iZXIpXG4gICAgaW5cbiAgICBpZiBmb3VuZCB0aGVuIHVzZWQgOj0gdHJ1ZTtcbiAgICBmb3VuZFxuICApIGxcblxubGV0IG5hbWVfZmlsdGVyX21hdGNoIH5uYW1lX2ZpbHRlciBkZXNjciA9XG4gIG1hdGNoIG5hbWVfZmlsdGVyIHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyA6OiBfIC0+XG4gICAgTGlzdC5leGlzdHMgKGZ1biBzdWJzdHJpbmcgLT4gQmFzZS5TdHJpbmcuaXNfc3Vic3RyaW5nIH5zdWJzdHJpbmcgZGVzY3IpIG5hbWVfZmlsdGVyXG5cbmxldCBwcmludF9kZWxheWVkX2Vycm9ycyAoKSA9XG4gIG1hdGNoIExpc3QucmV2ICFkZWxheWVkX2Vycm9ycyB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBfIDo6IF8gYXMgZGVsYXllZF9lcnJvcnMgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIlxcbiVzXFxuJSFcIiAoU3RyaW5nLm1ha2UgNzAgJz0nKTtcbiAgICBMaXN0Lml0ZXIgKGZ1biBtZXNzYWdlIC0+XG4gICAgICBQcmludGYuZXByaW50ZiBcIiVzJSFcIiBtZXNzYWdlXG4gICAgKSBkZWxheWVkX2Vycm9yc1xuXG5sZXQgZXByaW50Zl9vcl9kZWxheSBmbXQgPVxuICBQcmludGYua3NwcmludGYgKGZ1biBzIC0+XG4gICAgaWYgIXZlcmJvc2UgdGhlbiBkZWxheWVkX2Vycm9ycyA6PSBzIDo6ICFkZWxheWVkX2Vycm9yc1xuICAgIGVsc2UgUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgcztcbiAgICBpZiAhc3RvcF9vbl9lcnJvciB0aGVuIGJlZ2luXG4gICAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAgIGV4aXQgMlxuICAgIGVuZFxuICApIGZtdFxuXG5sZXQgYWRkX2hvb2tzICgobW9kdWxlIEMpIDogY29uZmlnKSBmID1cbiAgZnVuICgpIC0+IEMucHJlX3Rlc3RfaG9vayAoKTsgZiAoKVxuXG5sZXQgaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgPVxuICBsZXQgb3BlbiBCYXNlIGluXG4gIGJhY2t0cmFjZVxuICB8PiBTdHJpbmcuc3BsaXRfbGluZXNcbiAgfD4gTGlzdC50YWtlX3doaWxlIH5mOihmdW4gc3RyIC0+XG4gICAgbm90IChTdHJpbmcuU2VhcmNoX3BhdHRlcm4ubWF0Y2hlcyAoZm9yY2Ugd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSkgc3RyKSlcbiAgfD4gTGlzdC5tYXAgfmY6KGZ1biBzdHIgLT4gXCIgIFwiIF4gc3RyIF4gXCJcXG5cIilcbiAgfD4gU3RyaW5nLmNvbmNhdFxuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgIH5zdGFydF9wb3MgfmVuZF9wb3MgZiBib29sX29mX2YgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0geyBsaWJuYW1lOyBvbmx5X3Rlc3RfbG9jYXRpb247IHdoaWNoX3RhZ3M7IG5hbWVfZmlsdGVyIH07IHdoYXRfdG9fZG8gfSAtPlxuICAgIGxldCBmID0gYWRkX2hvb2tzIGNvbmZpZyBmIGluXG4gICAgbGV0IGRlc2NyID0gbGF6eSAoZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MpIGluXG4gICAgbGV0IGNvbXBsZXRlX3RhZ3MgPSB0YWdzIEAgTW9kdWxlX2NvbnRleHQuY3VycmVudF90YWdzICgpIGluXG4gICAgbGV0IHNob3VsZF9ydW4gPVxuICAgICAgU29tZSBsaWJuYW1lID0gIWR5bmFtaWNfbGliXG4gICAgICAmJiBiZWdpbiBtYXRjaCBvbmx5X3Rlc3RfbG9jYXRpb24gd2l0aFxuICAgICAgICB8IFtdIC0+IHRydWVcbiAgICAgICAgfCBfIDo6IF8gLT4gcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBvbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgIGVuZFxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmRpc2FibGVkIHdoaWNoX3RhZ3MgfmNvbXBsZXRlX3RhZ3MpXG4gICAgICAmJiBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgKExhenkuZm9yY2UgZGVzY3IpXG4gICAgaW5cbiAgICBpZiBzaG91bGRfcnVuIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIC0+IFBhcnRpdGlvbi5mb3VuZF90ZXN0ICgpXG4gICAgICB8IGBSdW5fcGFydGl0aW9uIHBhcnRpdGlvbiAtPlxuICAgICAgICBpZiBQYXJ0aXRpb24uaXNfY3VycmVudCBwYXJ0aXRpb24gdGhlbiBiZWdpblxuICAgICAgICAgIGxldCBkZXNjciA9IExhenkuZm9yY2UgZGVzY3IgaW5cbiAgICAgICAgICBpbmNyIHRlc3RzX3JhbjtcbiAgICAgICAgICBiZWdpbiBtYXRjaCAhbG9nIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgY2ggLT4gUHJpbnRmLmZwcmludGYgY2ggXCIlc1xcbiVzXCIgZGVzY3IgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCIlcyUhXCIgZGVzY3JcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9XG4gICAgICAgICAgICBpZiAhbGlzdF90ZXN0X25hbWVzXG4gICAgICAgICAgICB0aGVuIE9rIHRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKCogU2VlIFt0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkc10gZm9yIHdoeSB3ZSB1c2UgW2Jvb2xfb2ZfZl1cbiAgICAgICAgICAgICAgICAgcmF0aGVyIGhhdmUgdGhlIGNhbGxlciB3cmFwIFtmXSB0byBhZGp1c3QgaXRzIHJldHVybiB2YWx1ZS4gKilcbiAgICAgICAgICAgICAgUmVzdWx0Lm1hcCBib29sX29mX2YgKHRpbWVfYW5kX3Jlc2V0X3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogSWYgIWxpc3RfdGVzdF9uYW1lcywgdGhpcyBpcyBpcyBhIGhhcm1sZXNzIHplcm8uICopXG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBQcmludGYucHJpbnRmIFwiICglLjNmIHNlYylcXG4lIVwiICF0aW1lX3NlYztcbiAgICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICAgIHwgT2sgdHJ1ZSAtPiAoKVxuICAgICAgICAgIHwgT2sgZmFsc2UgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdHNfZmFpbGVkO1xuICAgICAgICAgICAgZXByaW50Zl9vcl9kZWxheSBcIiVzIGlzIGZhbHNlLlxcbiVzXFxuJSFcIiBkZXNjclxuICAgICAgICAgICAgICAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSlcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdHNfZmFpbGVkO1xuICAgICAgICAgICAgbGV0IGJhY2t0cmFjZSA9IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlIGluXG4gICAgICAgICAgICBsZXQgZXhuX3N0ciA9IFNleHBsaWIwLlNleHBfY29udi5wcmludGV4Y19wcmVmZXJfc2V4cCBleG4gaW5cbiAgICAgICAgICAgIGxldCBzZXAgPSBpZiBTdHJpbmcuY29udGFpbnMgZXhuX3N0ciAnXFxuJyB0aGVuIFwiXFxuXCIgZWxzZSBcIiBcIiBpblxuICAgICAgICAgICAgZXByaW50Zl9vcl9kZWxheSBcIiVzIHRocmV3JXMlcy5cXG4lcyVzXFxuJSFcIiBkZXNjciBzZXAgZXhuX3N0clxuICAgICAgICAgICAgICBiYWNrdHJhY2UgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuXG5sZXQgc2V0X2xpYl9hbmRfcGFydGl0aW9uIHN0YXRpY19saWIgcGFydGl0aW9uID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBTb21lIF8gLT5cbiAgICAoKiBwb3NzaWJsZSBpZiB0aGUgaW50ZXJmYWNlIGlzIHVzZWQgZXhwbGljaXRseSBvciBpZiB3ZSBoYXBwZW4gdG8gZHlubGluayBzb21ldGhpbmdcbiAgICAgICB0aGF0IGNvbnRhaW4gdGVzdHMgKilcbiAgICAoKVxuICB8IE5vbmUgLT5cbiAgICBkeW5hbWljX2xpYiA6PSBTb21lIHN0YXRpY19saWI7XG4gICAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gICAgfCBgSWdub3JlIC0+ICgpXG4gICAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHM7IHdoYXRfdG9fZG8gfSAtPlxuICAgICAgaWYgd2hpY2hfdGVzdHMubGlibmFtZSA9IHN0YXRpY19saWIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcmVxdWlyZXNfcGFydGl0aW9uID1cbiAgICAgICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgfCBgUnVuX3BhcnRpdGlvbiAoU29tZSBfKSAtPiB0cnVlXG4gICAgICAgICAgfCBgUnVuX3BhcnRpdGlvbiBOb25lIC0+IGZhbHNlXG4gICAgICAgIGluXG4gICAgICAgIGlmIHBhcnRpdGlvbiA9IFwiXCIgJiYgcmVxdWlyZXNfcGFydGl0aW9uXG4gICAgICAgIHRoZW4gZmFpbHdpdGggXCJwcHhfaW5saW5lX3Rlc3Q6IGNhbm5vdCB1c2UgLWxpc3QtcGFydGl0aW9uIG9yIC1wYXJ0aXRpb24gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBzcGVjaWZ5aW5nIGEgcGFydGl0aW9uIGF0IHByZXByb2Nlc3NpbmcgdGltZVwiXG4gICAgICAgIGVsc2UgUGFydGl0aW9uLnNldF9jdXJyZW50IHBhcnRpdGlvblxuICAgICAgZW5kXG5cbmxldCB1bnNldF9saWIgc3RhdGljX2xpYiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIG5vdCBnaXZpbmcgYW4gZXJyb3IsIGJlY2F1c2Ugd2hlbiBzb21lIGFubm95aW5nIHBlb3BsZSBwdXQgcGFfb3VuaXQgaW4gdGhlaXIgbGlzdFxuICAgICAgIG9mIHByZXByb2Nlc3NvcnMsIHBhX291bml0IGlzIHNldCB1cCB0d2ljZSBhbmQgd2UgaGF2ZSB0d28gY2FsbHMgdG8gdW5zZXRfbGliIGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYW5kIHRoZSBzZWNvbmQgb25lIGNvbWVzIGluIHRoaXMgYnJhbmNoICopXG4gICAgKClcbiAgfCBTb21lIGxpYiAtPlxuICAgIGlmIGxpYiA9IHN0YXRpY19saWIgdGhlbiBkeW5hbWljX2xpYiA6PSBOb25lXG5cbmxldCB0ZXN0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3NcbiAgICBmIChmdW4gYiAtPiBiKVxuXG5sZXQgdGVzdF91bml0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3NcbiAgICBmIChmdW4gKCkgLT4gdHJ1ZSlcblxubGV0W0BpbmxpbmUgbmV2ZXJdIHRlc3RfbW9kdWxlIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZTpkZWZfZmlsZW5hbWUgfmxpbmVfbnVtYmVyOmRlZl9saW5lX251bWJlclxuICAgICAgICAgICAgICAgICAgICAgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0cyA9IHsgbGlibmFtZTsgb25seV90ZXN0X2xvY2F0aW9uID0gXzsgbmFtZV9maWx0ZXIgPSBfOyB3aGljaF90YWdzIH07IHdoYXRfdG9fZG8gfSAtPlxuICAgIGxldCBmID0gYWRkX2hvb2tzIGNvbmZpZyBmIGluXG4gICAgbGV0IGRlc2NyICgpID0gZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MgaW5cbiAgICBsZXQgcGFydGlhbF90YWdzID0gdGFncyBAIE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfdGFncyAoKSBpblxuICAgIGxldCBzaG91bGRfcnVuID1cbiAgICAgIFNvbWUgbGlibmFtZSA9ICFkeW5hbWljX2xpYlxuICAgICAgKCogSWYsIG5vIG1hdHRlciB3aGF0IHRhZ3MgYSB0ZXN0IGRlZmluZXMsIHdlIGNlcnRhaW5seSB3aWxsIGRyb3AgYWxsIHRlc3RzIHdpdGhpblxuICAgICAgICAgdGhpcyBtb2R1bGUsIHRoZW4gZG9uJ3QgcnVuIHRoZSBtb2R1bGUgYXQgYWxsLiBUaGlzIG1lYW5zIHBlb3BsZSBjYW4gd3JpdGVcbiAgICAgICAgIHRoaW5ncyBsaWtlIHRoZSBmb2xsb3dpbmcgd2l0aG91dCBicmVha2luZyB0aGUgMzItYml0IGJ1aWxkOlxuICAgICAgICAgbGV0JXRlc3RfbW9kdWxlIFtAdGFncyBcIjY0LWJpdHMtb25seVwiXSA9IChtb2R1bGUgc3RydWN0XG4gICAgICAgICBsZXQgaSA9IEludDY0LnRvX2ludF9leG4gLi4uLlxuICAgICAgICAgZW5kKVxuICAgICAgICAgV2UgZG9uJ3Qgc2hvcnRjdXQgYmFzZWQgb24gcG9zaXRpb24sIGFzIHdlIGNhbid0IHRlbGwgd2hhdCBwb3NpdGlvbnMgdGhlXG4gICAgICAgICBpbm5lciB0ZXN0cyB3aWxsIGhhdmUuICopXG4gICAgICAmJiBub3QgKFRhZ19wcmVkaWNhdGUuZW50aXJlX21vZHVsZV9kaXNhYmxlZCB3aGljaF90YWdzIH5wYXJ0aWFsX3RhZ3MpXG4gICAgaW5cbiAgICBpZiBzaG91bGRfcnVuIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIC0+IFBhcnRpdGlvbi5mb3VuZF90ZXN0ICgpXG4gICAgICB8IGBSdW5fcGFydGl0aW9uIHBhcnRpdGlvbiAtPlxuICAgICAgICBpZiBQYXJ0aXRpb24uaXNfY3VycmVudCBwYXJ0aXRpb24gdGhlbiBiZWdpblxuICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICAgICBsZXQgZGVzY3IgPSBkZXNjciAoKSBpblxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBNb2R1bGVfY29udGV4dC53aXRoXyB+ZGVzY3IgfnRhZ3MgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAoKiBXZSBkbyBub3QgcmVzZXQgcmFuZG9tIHN0YXRlcyB1cG9uIGVudGVyaW5nIFtsZXQldGVzdF9tb2R1bGVdLlxuXG4gICAgICAgICAgICAgICAgIENvbjogQ29kZSBpbiB0ZXN0IG1vZHVsZXMgY2FuIGFjY2lkZW50YWxseSBkZXBlbmQgb24gdG9wLWxldmVsIHJhbmRvbVxuICAgICAgICAgICAgICAgICBzdGF0ZSBlZmZlY3RzLlxuXG4gICAgICAgICAgICAgICAgIFByb3M6ICgxKSBXZSBkb24ndCByZXNldCB0byB0aGUgc2FtZSBzZWVkIG9uIGVudGVyaW5nIGEgW2xldCV0ZXN0X21vZHVsZV1cbiAgICAgICAgICAgICAgICAgYW5kIHRoZW4gYSBbbGV0JXRlc3RdIGluc2lkZSB0aGF0IG1vZHVsZSwgd2hpY2ggY291bGQgbGVhZCB0b1xuICAgICAgICAgICAgICAgICBhY2NpZGVudGFsbHkgcmFuZG9tbHkgZ2VuZXJhdGluZyB0aGUgc2FtZSB2YWx1ZXMgaW4gc29tZSB0ZXN0LiAoMikgTW92aW5nXG4gICAgICAgICAgICAgICAgIGNvZGUgaW50byBhbmQgb3V0IG9mIFtsZXQldGVzdF9tb2R1bGVdIGRvZXMgbm90IGNoYW5nZSBpdHMgcmFuZG9tIHNlZWQuXG4gICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgIHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgKFwiVEVTXCIgXl4gXCJUX01PRFVMRSBhdCAlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIpXG4gICAgICAgICAgICAgIChTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIGRlc2NyKSBzZXAgZXhuX3N0ciBiYWNrdHJhY2UgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuXG5sZXQgc3VtbWFyaXplICgpID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPlxuICAgIGlmIFN5cy5hcmd2IDw+IFt8fF0gJiYgRmlsZW5hbWUuYmFzZW5hbWUgU3lzLmFyZ3YuKDApID0gXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZVwiIHRoZW5cbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiaW5saW5lX3Rlc3RzX3J1bm5lci5leGUgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHJ1biBieSBoYW5kLCB5b3UgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgcnVuIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCBpbnN0ZWFkLlxcbiUhXCJcbiAgICBlbHNlXG4gICAgICBQcmludGYuZXByaW50ZiBcIllvdSBhcmUgZG9pbmcgc29tZXRoaW5nIHVuZXhwZWN0ZWQgd2l0aCB0aGUgdGVzdHMuIE5vIHRlc3RzIGhhdmUgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICBiZWVuIHJ1bi4gWW91IHNob3VsZCB1c2UgdGhlIGlubGluZV90ZXN0c19ydW5uZXIgc2NyaXB0IHRvIHJ1biBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgIHRlc3RzLlxcbiUhXCI7XG4gICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSBfOyB3aGF0X3RvX2RvID0gYExpc3RfcGFydGl0aW9ucyB9IC0+XG4gICAgTGlzdC5pdGVyIChQcmludGYucHJpbnRmIFwiJXNcXG5cIikgKFBhcnRpdGlvbi5hbGwgKCkpO1xuICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgfCBgVGVzdF9tb2RlIHsgd2hhdF90b19kbyA9IGBSdW5fcGFydGl0aW9uIF87IHdoaWNoX3Rlc3RzIH0gLT4gYmVnaW5cbiAgICAgIGJlZ2luIG1hdGNoICFsb2cgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgY2ggLT4gY2xvc2Vfb3V0IGNoXG4gICAgICBlbmQ7XG4gICAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAgIG1hdGNoICF0ZXN0c19mYWlsZWQsICF0ZXN0X21vZHVsZXNfZmFpbGVkIHdpdGhcbiAgICAgIHwgMCwgMCAtPiBiZWdpblxuICAgICAgICAgIGlmICFzaG93X2NvdW50cyB0aGVuIGJlZ2luXG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcIiVkIHRlc3RzIHJhbiwgJWQgdGVzdF9tb2R1bGVzIHJhblxcbiUhXCIgIXRlc3RzX3JhbiAhdGVzdF9tb2R1bGVzX3JhblxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBsZXQgZXJyb3JzID1cbiAgICAgICAgICAgIGxldCB1bnVzZWRfdGVzdHMgPVxuICAgICAgICAgICAgICBMaXN0LmZpbHRlciAoZnVuIChfLCBfLCB1c2VkKSAtPiBub3QgIXVzZWQpIHdoaWNoX3Rlc3RzLm9ubHlfdGVzdF9sb2NhdGlvblxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIG1hdGNoIHVudXNlZF90ZXN0cyB3aXRoXG4gICAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICAgIHwgXyA6OiBfIC0+IFNvbWUgdW51c2VkX3Rlc3RzXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCBlcnJvcnMgd2l0aFxuICAgICAgICAgIHwgU29tZSB0ZXN0cyAtPlxuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IHRoZSBmb2xsb3dpbmcgLW9ubHktdGVzdCBmbGFncyBtYXRjaGVkIG5vdGhpbmc6XCI7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgXykgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzXCIgZmlsZW5hbWVcbiAgICAgICAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzOiVkXCIgZmlsZW5hbWUgbGluZV9udW1iZXJcbiAgICAgICAgICAgICkgdGVzdHM7XG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcIi5cXG4lIVwiO1xuICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGlmICF0ZXN0c19yYW4gPSAwICYmICFzdHJpY3QgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBQcmludGYuZXByaW50ZiBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogbm8gdGVzdHMgaGF2ZSBiZWVuIHJ1bi5cXG4lIVwiO1xuICAgICAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgVGVzdF9yZXN1bHQuU3VjY2Vzc1xuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjb3VudCwgY291bnRfdGVzdF9tb2R1bGVzIC0+XG4gICAgICAgIFByaW50Zi5lcHJpbnRmIFwiRkFJTEVEICVkIC8gJWQgdGVzdHMlc1xcbiUhXCIgY291bnQgIXRlc3RzX3JhblxuICAgICAgICAgIChpZiBjb3VudF90ZXN0X21vZHVsZXMgPSAwIHRoZW4gXCJcIiBlbHNlIFByaW50Zi5zcHJpbnRmIChcIiwgJWQgVEVTXCIgXl4gXCJUX01PRFVMRVNcIikgY291bnRfdGVzdF9tb2R1bGVzKTtcbiAgICAgICAgVGVzdF9yZXN1bHQuRmFpbHVyZVxuICAgIGVuZFxuXG5sZXQgdXNlX2NvbG9yID0gIXVzZV9jb2xvclxubGV0IGluX3BsYWNlICA9ICFpbl9wbGFjZVxubGV0IGRpZmZfY29tbWFuZCA9ICFkaWZmX2NvbW1hbmRcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gIXNvdXJjZV90cmVlX3Jvb3RcbmxldCBhbGxvd19vdXRwdXRfcGF0dGVybnMgPSAhYWxsb3dfb3V0cHV0X3BhdHRlcm5zXG5cbmxldCBldmFsdWF0b3JzID0gcmVmIFtzdW1tYXJpemVdXG5sZXQgYWRkX2V2YWx1YXRvciB+ZiA9IGV2YWx1YXRvcnMgOj0gZiA6OiAhZXZhbHVhdG9yc1xubGV0IGV4aXQgKCkgPVxuICBMaXN0Lm1hcCAoZnVuIGYgLT4gZiAoKSkgKExpc3QucmV2ICFldmFsdWF0b3JzKVxuICB8PiBUZXN0X3Jlc3VsdC5jb21iaW5lX2FsbFxuICB8PiBUZXN0X3Jlc3VsdC50b19leGl0X2NvZGVcbiAgfD4gZXhpdFxuIl19
