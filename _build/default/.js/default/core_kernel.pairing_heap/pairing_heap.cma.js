// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Pairing_heap
//# unitInfo: Requires: Assert_failure, Base__Container, Core, Core__Array, Core__Int, Core__List, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Pairing_heap = "Pairing_heap",
    cst_pairing_heap = "pairing_heap",
    cst_pairing_heap_src_pairing_h = "pairing_heap/src/pairing_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Base_Container = global_data.Base__Container;
   caml_call1(Ppx_module_timer_runtime[4], cst_Pairing_heap);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_pairing_heap);
   caml_call1(Expect_test_collector[5][1], cst_pairing_heap_src_pairing_h);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_pairing_heap, cst);
   var
    empty = Tuple_pool[3][4],
    is_empty = Tuple_pool[3][5],
    equal = Tuple_pool[3][7],
    dummy_id = -1,
    _a_ = [0, cst_pairing_heap_src_pairing_h, 110, 4];
   function child(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][4]);
   }
   function sibling(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][5]);
   }
   function prev(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][6]);
   }
   function id(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][7]);
   }
   function set_child(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][4], v);
   }
   function set_sibling(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][5], v);
   }
   function set_prev(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][6], v);
   }
   function value_exn(t, pool){
    if(caml_call1(is_empty, t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][3]);
   }
   function allocate(value, pool, id){
    var
     _E_ = caml_call1(empty, 0),
     _F_ = caml_call1(empty, 0),
     _G_ = caml_call1(empty, 0);
    return caml_call6(Tuple_pool[21], pool, value, _G_, _F_, _E_, id);
   }
   function free(t, pool){return caml_call2(Tuple_pool[16], pool, t);}
   function disconnect_sibling(t, pool){
    var sibling$0 = sibling(t, pool);
    if(1 - caml_call1(is_empty, sibling$0)){
     set_sibling(t, caml_call1(empty, 0), pool);
     set_prev(sibling$0, caml_call1(empty, 0), pool);
    }
    return sibling$0;
   }
   function disconnect_child(t, pool){
    var child$0 = child(t, pool);
    if(1 - caml_call1(is_empty, child$0)){
     set_child(t, caml_call1(empty, 0), pool);
     set_prev(child$0, caml_call1(empty, 0), pool);
    }
    return child$0;
   }
   function detach(t, pool){
    if(1 - caml_call1(is_empty, t)){
     var prev$0 = prev(t, pool);
     if(1 - caml_call1(is_empty, prev$0)){
      var
       relation_to_prev =
         caml_call2(equal, t, child(prev$0, pool)) ? -977688164 : -560648958;
      set_prev(t, caml_call1(empty, 0), pool);
      var sibling = disconnect_sibling(t, pool);
      if(-560648958 <= relation_to_prev)
       set_sibling(prev$0, sibling, pool);
      else
       set_child(prev$0, sibling, pool);
      if(1 - caml_call1(is_empty, sibling))
       return set_prev(sibling, prev$0, pool);
     }
    }
    return;
   }
   function create(capacity){
    var
     _B_ = caml_call1(Tuple_pool[3][4], 0),
     _C_ = caml_call1(Tuple_pool[3][4], 0),
     _D_ = [0, 0, caml_call1(Tuple_pool[3][4], 0), _C_, _B_, dummy_id];
    return caml_call3(Tuple_pool[9], Tuple_pool[1][21], capacity, _D_);
   }
   var
    _c_ = Core_Int[60],
    _d_ = [0, cst_pairing_heap_src_pairing_h, 239, 10],
    _e_ = [0, cst_pairing_heap_src_pairing_h, 237, 8],
    _f_ = [0, cst_pairing_heap_src_pairing_h, 246, 2],
    cst_Heap_top_exn_called_on_an_ = "Heap.top_exn called on an empty heap";
   function invariant(param, t){
    if
     (!
      caml_call1(is_empty, t[3])
      && ! caml_call1(is_empty, sibling(t[3], t[2])))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     _z_ = caml_call1(empty, 0),
     to_visit$2 = [0, [0, t[3], _z_, 0], 0],
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var
      to_visit$0 = to_visit[2],
      match = to_visit[1],
      maybe_parent_value = match[3],
      expected_prev = match[2],
      node = match[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      var this_value = value_exn(node, t[2]);
      if(! caml_call2(equal, prev(node, t[2]), expected_prev))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      let this_value$0 = this_value;
      caml_call2
       (Core_Option[41],
        maybe_parent_value,
        function(parent_value){
         var _A_ = caml_call2(t[1], parent_value, this_value$0);
         if(caml_call2(Core[89], _A_, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
        });
      var
       _y_ =
         [0, [0, sibling(node, t[2]), node, maybe_parent_value], to_visit$0],
       to_visit$1 = [0, [0, child(node, t[2]), node, [0, this_value]], _y_];
      to_visit = to_visit$1;
     }
    }
   }
   function create$0(opt, cmp, param){
    if(opt) var sth = opt[1], min_size = sth; else var min_size = 1;
    var _x_ = caml_call1(empty, 0);
    return [0, cmp, create(min_size), _x_, 0];
   }
   function copy(param){
    var
     cmp = param[1],
     pool$0 = param[2],
     start = param[3],
     num_of_allocated_nodes = param[4],
     pool = create(caml_call1(Tuple_pool[11], pool$0));
    function copy_node(node, to_visit){
     if(caml_call1(is_empty, node))
      return [0, caml_call1(empty, 0), to_visit];
     var
      _v_ = id(node, pool$0),
      new_node = allocate(value_exn(node, pool$0), pool, _v_),
      _w_ = [0, [0, new_node, -560648958, sibling(node, pool$0)], to_visit],
      to_visit$0 = [0, [0, new_node, -977688164, child(node, pool$0)], _w_];
     return [0, new_node, to_visit$0];
    }
    var
     match$1 = copy_node(start, 0),
     to_visit$1 = match$1[2],
     new_start = match$1[1],
     to_visit = to_visit$1;
    for(;;){
     if(! to_visit) return [0, cmp, pool, new_start, num_of_allocated_nodes];
     var
      rest = to_visit[2],
      match = to_visit[1],
      node_to_copy = match[3],
      slot = match[2],
      node_to_update = match[1],
      match$0 = copy_node(node_to_copy, rest),
      to_visit$0 = match$0[2],
      new_node = match$0[1];
     if(-560648958 <= slot)
      set_sibling(node_to_update, new_node, pool);
     else
      set_child(node_to_update, new_node, pool);
     if(1 - caml_call1(is_empty, new_node))
      set_prev(new_node, node_to_update, pool);
     to_visit = to_visit$0;
    }
   }
   function merge(t, root1, root2){
    if(caml_call1(is_empty, root1)) return root2;
    if(caml_call1(is_empty, root2)) return root1;
    function add_child(t, node, new_child){
     var pool = t[2], current_child = disconnect_child(node, pool);
     set_sibling(new_child, current_child, pool);
     if(1 - caml_call1(is_empty, current_child))
      set_prev(current_child, new_child, pool);
     set_child(node, new_child, pool);
     set_prev(new_child, node, pool);
     return node;
    }
    var
     v1 = value_exn(root1, t[2]),
     v2 = value_exn(root2, t[2]),
     _u_ = caml_call2(t[1], v1, v2);
    return caml_call2(Core[92], _u_, 0)
            ? add_child(t, root1, root2)
            : add_child(t, root2, root1);
   }
   function top_exn(t){
    return caml_call1(is_empty, t[3])
            ? caml_call1(Core[6], cst_Heap_top_exn_called_on_an_)
            : value_exn(t[3], t[2]);
   }
   function top(t){return caml_call1(is_empty, t[3]) ? 0 : [0, top_exn(t)];}
   function add_node(t$1, v){
    var t = t$1[2];
    if(caml_call1(Tuple_pool[14], t)){
     var t$0 = t$1[2];
     t$1[2] = caml_call2(Tuple_pool[13], 0, t$0);
    }
    t$1[4] = t$1[4] + 1 | 0;
    var _t_ = caml_call1(_c_, t$1[4]), node = allocate(v, t$1[2], _t_);
    t$1[3] = merge(t$1, t$1[3], node);
    return node;
   }
   function add(t, v){add_node(t, v); return 0;}
   var max_stack_depth = 1000;
   function loop(t, depth, head$0){
    if(! caml_call2(Core[88], depth, max_stack_depth)){
     if(caml_call1(is_empty, head$0)) return head$0;
     var next1$0 = disconnect_sibling(head$0, t[2]);
     if(caml_call1(is_empty, next1$0)) return head$0;
     var
      next2$0 = disconnect_sibling(next1$0, t[2]),
      _s_ = loop(t, depth + 1 | 0, next2$0);
     return merge(t, merge(t, head$0, next1$0), _s_);
    }
    a:
    {
     b:
     {
      var acc = 0, head = head$0;
      for(;;){
       if(caml_call1(is_empty, head)) break b;
       var next1 = disconnect_sibling(head, t[2]);
       if(caml_call1(is_empty, next1)) break;
       var
        next2 = disconnect_sibling(next1, t[2]),
        acc$0 = [0, merge(t, head, next1), acc];
       acc = acc$0;
       head = next2;
      }
      var match = [0, head, acc];
      break a;
     }
     var match = acc;
    }
    if(! match) return caml_call1(empty, 0);
    var h = match[1];
    if(! match[2]) return h;
    var xs = match[2];
    return caml_call3
            (Core_List[10],
             xs,
             h,
             function(acc, heap){return merge(t, acc, heap);});
   }
   function remove_non_empty(t, node){
    var pool = t[2];
    detach(node, pool);
    var
     head = disconnect_child(node, pool),
     merged_children = loop(t, 0, head),
     new_root =
       caml_call2(equal, t[3], node)
        ? merged_children
        : merge(t, t[3], merged_children);
    free(node, pool);
    t[3] = new_root;
    return 0;
   }
   function remove_top(t){
    var _r_ = 1 - caml_call1(is_empty, t[3]);
    return _r_ ? remove_non_empty(t, t[3]) : _r_;
   }
   function clear(t){
    var _p_ = 1 - caml_call1(is_empty, t[3]);
    if(_p_){
     var pool = t[2], node$0 = t[3], node = node$0;
     for(;;){
      var child$0 = child(node, pool), sibling$0 = sibling(node, pool);
      if(caml_call1(is_empty, child$0))
       if(caml_call1(is_empty, sibling$0)){
        var prev$0 = prev(node, pool);
        detach(node, pool);
        free(node, pool);
        if(! (1 - caml_call1(is_empty, prev$0))){
         t[3] = caml_call1(empty, 0);
         var _q_ = 0;
         break;
        }
        node = prev$0;
       }
       else
        node = sibling$0;
      else
       node = child$0;
     }
    }
    else
     var _q_ = _p_;
    return _q_;
   }
   function pop_exn(t){var r = top_exn(t); remove_top(t); return r;}
   function pop(t){return caml_call1(is_empty, t[3]) ? 0 : [0, pop_exn(t)];}
   function pop_if(t, f){
    var match = top(t);
    if(! match) return 0;
    var v = match[1];
    return caml_call1(f, v) ? (remove_top(t), [0, v]) : 0;
   }
   function fold(t, init, f){
    var
     pool = t[2],
     to_visit$2 = [0, t[3], 0],
     acc = init,
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return acc;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      var
       _o_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _o_],
       acc$0 = caml_call2(f, acc, value_exn(node, pool));
      acc = acc$0;
      to_visit = to_visit$1;
     }
    }
   }
   function iter(t, f){
    var pool = t[2], to_visit$2 = [0, t[3], 0], to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      to_visit = to_visit$0;
     else{
      caml_call1(f, value_exn(node, pool));
      var
       _n_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _n_];
      to_visit = to_visit$1;
     }
    }
   }
   function length(t){var t$0 = t[2]; return caml_call1(Tuple_pool[12], t$0);}
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    _b_ = Core_Int[90],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]);
   function is_empty$0(t){return caml_call1(is_empty, t[3]);}
   var
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    cst_Heap_value_exn_node_was_re =
      "Heap.value_exn: node was removed from the heap",
    cst_cannot_remove_from_a_diffe = "cannot remove from a different heap";
   function of_array(arr, cmp){
    var t = create$0([0, arr.length - 1], cmp, 0);
    caml_call2(Core_Array[22], arr, function(v){return add(t, v);});
    return t;
   }
   function of_list(l, cmp){
    return of_array(caml_call1(Core_Array[52], l), cmp);
   }
   function sexp_of_t(f, t){
    var
     _k_ = t[1],
     _l_ = caml_call1(to_array, t),
     _m_ = caml_call2(Core_Array[111], _l_, _k_);
    return caml_call2(Core_Array[16], f, _m_);
   }
   function is_node_valid(t){
    var _j_ = t[2];
    return caml_call2(_b_, id(t[1], t[3][2]), _j_);
   }
   function value_exn$0(t){
    return is_node_valid(t)
            ? value_exn(t[1], t[3][2])
            : caml_call1(Core[6], cst_Heap_value_exn_node_was_re);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var x_001 = is_node_valid(t) ? [0, value_exn(t[1], t[3][2])] : 0;
    return caml_call2(Core[454], sexp_of_a, x_001);
   }
   function remove(t, token){
    if(! caml_call2(Core[246], t, token[3]))
     return caml_call1(Core[6], cst_cannot_remove_from_a_diffe);
    var _h_ = 1 - caml_call1(is_empty, token[1]);
    if(_h_){
     if(is_node_valid(token)) remove_non_empty(t, token[1]);
     token[1] = caml_call1(empty, 0);
     var _i_ = 0;
    }
    else
     var _i_ = _h_;
    return _i_;
   }
   function add_removable(t, v){
    var node = add_node(t, v);
    return [0, node, id(node, t[2]), t];
   }
   function update(t, token, v){remove(t, token); return add_removable(t, v);}
   function find_elt(t, f){
    var nodes$2 = [0, t[3], 0], nodes = nodes$2;
    for(;;){
     if(! nodes) return 0;
     var nodes$0 = nodes[2], node = nodes[1];
     if(caml_call1(is_empty, node))
      nodes = nodes$0;
     else{
      if(caml_call1(f, value_exn(node, t[2])))
       return [0, [0, node, id(node, t[2]), t]];
      var
       _g_ = [0, child(node, t[2]), nodes$0],
       nodes$1 = [0, sibling(node, t[2]), _g_];
      nodes = nodes$1;
     }
    }
   }
   function value(t, heap){return value_exn(t, heap[2]);}
   var Elt = [0, value];
   function update$0(t, elt, v){
    remove_non_empty(t, elt);
    return add_node(t, v);
   }
   var Unsafe = [0, Elt, add_node, remove_non_empty, update$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_pairing_heap);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Pairing_heap);
   var
    Pairing_heap =
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       copy,
       [0, sexp_of_t$0, value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
   runtime.caml_register_global(26, Pairing_heap, cst_Pairing_heap);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVtcHR5IiwiaXNfZW1wdHkiLCJlcXVhbCIsImR1bW15X2lkIiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwic2libGluZyQwIiwiZGlzY29ubmVjdF9jaGlsZCIsImNoaWxkJDAiLCJkZXRhY2giLCJwcmV2JDAiLCJyZWxhdGlvbl90b19wcmV2IiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJpbnZhcmlhbnQiLCJ0b192aXNpdCQyIiwidG9fdmlzaXQiLCJ0b192aXNpdCQwIiwibWF5YmVfcGFyZW50X3ZhbHVlIiwiZXhwZWN0ZWRfcHJldiIsIm5vZGUiLCJ0aGlzX3ZhbHVlIiwidGhpc192YWx1ZSQwIiwicGFyZW50X3ZhbHVlIiwidG9fdmlzaXQkMSIsImNyZWF0ZSQwIiwib3B0IiwiY21wIiwic3RoIiwibWluX3NpemUiLCJjb3B5IiwicG9vbCQwIiwic3RhcnQiLCJudW1fb2ZfYWxsb2NhdGVkX25vZGVzIiwiY29weV9ub2RlIiwibmV3X25vZGUiLCJuZXdfc3RhcnQiLCJyZXN0Iiwibm9kZV90b19jb3B5Iiwic2xvdCIsIm5vZGVfdG9fdXBkYXRlIiwibWVyZ2UiLCJyb290MSIsInJvb3QyIiwiYWRkX2NoaWxkIiwibmV3X2NoaWxkIiwiY3VycmVudF9jaGlsZCIsInYxIiwidjIiLCJ0b3BfZXhuIiwidG9wIiwiYWRkX25vZGUiLCJ0JDEiLCJ0JDAiLCJhZGQiLCJtYXhfc3RhY2tfZGVwdGgiLCJsb29wIiwiZGVwdGgiLCJoZWFkJDAiLCJuZXh0MSQwIiwibmV4dDIkMCIsImFjYyIsImhlYWQiLCJuZXh0MSIsIm5leHQyIiwiYWNjJDAiLCJoIiwieHMiLCJoZWFwIiwicmVtb3ZlX25vbl9lbXB0eSIsIm1lcmdlZF9jaGlsZHJlbiIsIm5ld19yb290IiwicmVtb3ZlX3RvcCIsImNsZWFyIiwibm9kZSQwIiwicG9wX2V4biIsInIiLCJwb3AiLCJwb3BfaWYiLCJmIiwiZm9sZCIsImluaXQiLCJpdGVyIiwibGVuZ3RoIiwiaXRlciQwIiwibGVuZ3RoJDAiLCJpc19lbXB0eSQwIiwibWVtIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJvZl9hcnJheSIsImFyciIsIm9mX2xpc3QiLCJsIiwic2V4cF9vZl90IiwiaXNfbm9kZV92YWxpZCIsInZhbHVlX2V4biQwIiwic2V4cF9vZl90JDAiLCJzZXhwX29mX2EiLCJ4XzAwMSIsInJlbW92ZSIsInRva2VuIiwiYWRkX3JlbW92YWJsZSIsInVwZGF0ZSIsImZpbmRfZWx0Iiwibm9kZXMkMiIsIm5vZGVzIiwibm9kZXMkMCIsIm5vZGVzJDEiLCJ1cGRhdGUkMCIsImVsdCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9jb3JlX2tlcm5lbC9wYWlyaW5nX2hlYXAvcGFpcmluZ19oZWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE4Rk1BO0lBQ0FDO0lBQ0FDO0lBVEFDOztZQVdBQyxNQUFNQyxHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUM1Q0UsUUFBUUYsR0FBR0M7SUFBTyxrQ0FBUEEsTUFBSEQ7R0FBc0M7WUFDOUNHLEtBQUtILEdBQUdDO0lBQU8sa0NBQVBBLE1BQUhEO0dBQXNDO1lBQzNDSSxHQUFHSixHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUd6Q0ssVUFBVUwsR0FB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QXJCQWpCO09BWEFKO09BVUFHO09BMUJBSjtPQWhCQUY7T0FzREFrQjtPQUNBQztPQVhBWDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQXRSQWpGO09BdVJBa0Y7T0FDQUM7T0FuUUF4RTtPQXVRQTJFO09BTUFFO09Bdk5BcEQ7T0FOQUQ7T0FjQUs7T0FrR0FrQjtPQWtCQUM7T0FhQUk7T0FOQUY7T0FRQUc7T0F6TEFoRDtXQTZSRTZFLGFBTkFEO09Ba0JGTTtPQVRBRjtPQWNBRztPQUtBQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQ29yZVxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5tb2R1bGUgUG9pbnRlciA9IFBvb2wuUG9pbnRlclxuXG4oKiBUaGlzIHBvb2wgaG9sZHMgbm9kZXMgdGhhdCB3b3VsZCBiZSByZXByZXNlbnRlZCBtb3JlIHRyYWRpdGlvbmFsbHkgYXM6XG5cbiAgIHtbXG4gICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgfCBFbXB0eVxuICAgICAgIHwgSGVhcCBvZiAnYSAqICdhIHQgbGlzdCBdfVxuXG4gICBXZSB3aWxsIHJlcHJlc2VudCB0aGVtIGFzIGEgbGVmdC1jaGlsZCwgcmlnaHQtc2libGluZyB0cmVlIGluIGEgdHJpcGxldFxuICAgKHZhbHVlICogbGVmdF9jaGlsZCAqIHJpZ2h0X3NpYmxpbmcpLiAgVGhlIGxlZnQgY2hpbGQgYW5kIGFsbCByaWdodCBzaWJsaW5nc1xuICAgb2YgdGhlIGxlZnQgY2hpbGQgZm9ybSBhIGxpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgc3ViaGVhcHMgb2YgYSBnaXZlbiBoZWFwOlxuXG4gICB7dlxuICAgICAgICAgQVxuICAgICAgICAvXG4gICAgICAgQiAtPiBDIC0+IEQgLT4gRSAtPiBGXG4gICAgICAvICAgICAgICAgLyAgICAgICAgIC9cbiAgICAgRyAgICAgICAgIEgtPkktPkogICBLLT5MXG4gICB2fSAqKVxuXG5tb2R1bGUgTm9kZSA6IHNpZ1xuICAoKiBFeHBvc2luZyBbcHJpdmF0ZSBpbnRdIGlzIGEgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQsIGJlY2F1c2UgaXQgYWxsb3dzXG4gICAgIHRoZSBjb21waWxlciB0byBza2lwIHRoZSB3cml0ZSBiYXJyaWVyLiAqKVxuXG4gIHR5cGUgJ2EgdCA9IHByaXZhdGUgaW50XG5cbiAgbW9kdWxlIElkIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgIHR5cGUgJ2Egbm9kZSA9ICdhIHRcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjcmVhdGUgOiBtaW5fc2l6ZTppbnQgLT4gJ2EgdFxuICAgIHZhbCBpc19mdWxsIDogJ2EgdCAtPiBib29sXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIGdyb3cgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2Egbm9kZSAtPiAnYSBub2RlICogJ2EgdFxuICBlbmRcblxuICAoKiogW2FsbG9jYXRlIHYgfnBvb2xdIGFsbG9jYXRlcyBhIG5ldyBub2RlIGZyb20gdGhlIHBvb2wgd2l0aCBubyBjaGlsZCBvciBzaWJsaW5nICopXG4gIHZhbCBhbGxvY2F0ZSA6ICdhIC0+IHBvb2w6J2EgUG9vbC50IC0+IGlkOklkLnQgLT4gJ2EgdFxuXG4gICgqKiBbZnJlZSB0IH5wb29sXSBmcmVlcyBbdF0gZm9yIHJldXNlLiAgSXQgaXMgYW4gZXJyb3IgdG8gYWNjZXNzIFt0XSBhZnRlciB0aGlzLiAqKVxuICB2YWwgZnJlZSA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuXG4gICgqKiBhIHNwZWNpYWwgW3RdIHRoYXQgcmVwcmVzZW50cyB0aGUgZW1wdHkgbm9kZSAqKVxuICB2YWwgZW1wdHkgOiB1bml0IC0+ICdhIHRcblxuICB2YWwgaXNfZW1wdHkgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcblxuICAoKiogW3ZhbHVlX2V4biB0IH5wb29sXSByZXR1cm4gdGhlIHZhbHVlIG9mIFt0XSwgcmFpc2UgaWYgW2lzX2VtcHR5IHRdICopXG4gIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhXG5cbiAgdmFsIGlkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiBJZC50XG4gIHZhbCBjaGlsZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuICB2YWwgc2libGluZyA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbcHJldiB0XSBpcyBlaXRoZXIgdGhlIHBhcmVudCBvZiBbdF0gb3IgdGhlIHNpYmxpbmcgaW1tZWRpYXRlbHkgbGVmdCBvZiBbdF0gKilcbiAgdmFsIHByZXYgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW2FkZF9jaGlsZCB0IH5jaGlsZCB+cG9vbF0gQWRkIGEgY2hpbGQgdG8gW3RdLCBwcmVzZXJ2aW5nIGV4aXN0aW5nIGNoaWxkcmVuIGFzXG4gICAgICBzaWJsaW5ncyBvZiBbY2hpbGRdLiBbdF0gYW5kIFtjaGlsZF0gc2hvdWxkIG5vdCBiZSBlbXB0eSBhbmQgW2NoaWxkXSBzaG91bGQgaGF2ZSBub1xuICAgICAgc2libGluZyBhbmQgaGF2ZSBubyBwcmV2IG5vZGUuICopXG4gIHZhbCBhZGRfY2hpbGQgOiAnYSB0IC0+IGNoaWxkOidhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuXG4gICgqKiBkaXNjb25uZWN0IGFuZCByZXR1cm4gdGhlIHNpYmxpbmcgKilcbiAgdmFsIGRpc2Nvbm5lY3Rfc2libGluZyA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBkaXNjb25uZWN0IGFuZCByZXR1cm4gdGhlIGNoaWxkICopXG4gIHZhbCBkaXNjb25uZWN0X2NoaWxkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFtkZXRhY2ggdCB+cG9vbF0gcmVtb3ZlcyBbdF0gZnJvbSB0aGUgdHJlZSwgYWRqdXN0aW5nIHBvaW50ZXJzIGFyb3VuZCBpdC4gQWZ0ZXJcbiAgICAgIFtkZXRhY2hdLCBbdF0gaXMgdGhlIHJvb3Qgb2YgYSBzdGFuZGFsb25lIGhlYXAsIHdoaWNoIGlzIGRldGFjaGVkIGZyb20gdGhlIG9yaWdpbmFsXG4gICAgICBoZWFwLiAqKVxuICB2YWwgZGV0YWNoIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIElkID0gSW50XG5cbiAgbGV0IGR1bW15X2lkIDogSWQudCA9IC0xXG5cbiAgdHlwZSAnYSBub2RlID1cbiAgICAoJ2EsICdhIG5vZGUgUG9pbnRlci50LCAnYSBub2RlIFBvaW50ZXIudCwgJ2Egbm9kZSBQb2ludGVyLnQsIElkLnQpIFBvb2wuU2xvdHMudDVcblxuICB0eXBlICdhIHQgPSAnYSBub2RlIFBvaW50ZXIudFxuXG4gIGxldCBlbXB0eSA9IFBvaW50ZXIubnVsbFxuICBsZXQgaXNfZW1wdHkgPSBQb2ludGVyLmlzX251bGxcbiAgbGV0IGVxdWFsID0gUG9pbnRlci5waHlzX2VxdWFsXG4gIGxldCB2YWx1ZSB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MFxuICBsZXQgY2hpbGQgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDFcbiAgbGV0IHNpYmxpbmcgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDJcbiAgbGV0IHByZXYgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDNcbiAgbGV0IGlkIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQ0XG5cbiAgKCogbGV0IHNldF92YWx1ZSAgIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDAgdiAqKVxuICBsZXQgc2V0X2NoaWxkIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDEgdlxuICBsZXQgc2V0X3NpYmxpbmcgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MiB2XG4gIGxldCBzZXRfcHJldiB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQzIHZcblxuICBsZXQgdmFsdWVfZXhuIHQgfnBvb2wgPVxuICAgIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gICAgdmFsdWUgdCB+cG9vbFxuICA7O1xuXG4gIGxldCBhbGxvY2F0ZSB2YWx1ZSB+cG9vbCB+aWQgPSBQb29sLm5ldzUgcG9vbCB2YWx1ZSAoZW1wdHkgKCkpIChlbXB0eSAoKSkgKGVtcHR5ICgpKSBpZFxuICBsZXQgZnJlZSB0IH5wb29sID0gUG9vbC51bnNhZmVfZnJlZSBwb29sIHRcblxuICBsZXQgZGlzY29ubmVjdF9zaWJsaW5nIHQgfnBvb2wgPVxuICAgIGxldCBzaWJsaW5nID0gc2libGluZyB0IH5wb29sIGluXG4gICAgaWYgbm90IChpc19lbXB0eSBzaWJsaW5nKVxuICAgIHRoZW4gKFxuICAgICAgc2V0X3NpYmxpbmcgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgc2V0X3ByZXYgc2libGluZyAoZW1wdHkgKCkpIH5wb29sKTtcbiAgICBzaWJsaW5nXG4gIDs7XG5cbiAgbGV0IGRpc2Nvbm5lY3RfY2hpbGQgdCB+cG9vbCA9XG4gICAgbGV0IGNoaWxkID0gY2hpbGQgdCB+cG9vbCBpblxuICAgIGlmIG5vdCAoaXNfZW1wdHkgY2hpbGQpXG4gICAgdGhlbiAoXG4gICAgICBzZXRfY2hpbGQgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgc2V0X3ByZXYgY2hpbGQgKGVtcHR5ICgpKSB+cG9vbCk7XG4gICAgY2hpbGRcbiAgOztcblxuICBsZXQgYWRkX2NoaWxkIHQgfmNoaWxkOm5ld19jaGlsZCB+cG9vbCA9XG4gICAgKCogYXNzZXJ0aW9ucyB3ZSB3b3VsZCBtYWtlLCBidXQgZm9yIHNwZWVkOlxuICAgICAgIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gICAgICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IG5ld19jaGlsZCkpO1xuICAgICAgIGFzc2VydCAoaXNfZW1wdHkgKHNpYmxpbmcgbmV3X2NoaWxkIH5wb29sKSk7XG4gICAgICAgYXNzZXJ0IChpc19lbXB0eSAocHJldiBuZXdfY2hpbGQgfnBvb2wpKTtcbiAgICAqKVxuICAgIGxldCBjdXJyZW50X2NoaWxkID0gZGlzY29ubmVjdF9jaGlsZCB0IH5wb29sIGluXG4gICAgKCogYWRkIFtuZXdfY2hpbGRdIHRvIHRoZSBsaXN0IG9mIFt0XSdzIGNoaWxkcmVuICh3aGljaCBtYXkgYmUgZW1wdHkpICopXG4gICAgc2V0X3NpYmxpbmcgbmV3X2NoaWxkIGN1cnJlbnRfY2hpbGQgfnBvb2w7XG4gICAgaWYgbm90IChpc19lbXB0eSBjdXJyZW50X2NoaWxkKSB0aGVuIHNldF9wcmV2IGN1cnJlbnRfY2hpbGQgbmV3X2NoaWxkIH5wb29sO1xuICAgIHNldF9jaGlsZCB0IG5ld19jaGlsZCB+cG9vbDtcbiAgICBzZXRfcHJldiBuZXdfY2hpbGQgdCB+cG9vbFxuICA7O1xuXG4gIGxldCBkZXRhY2ggdCB+cG9vbCA9XG4gICAgaWYgbm90IChpc19lbXB0eSB0KVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHByZXYgPSBwcmV2IHQgfnBvb2wgaW5cbiAgICAgIGlmIG5vdCAoaXNfZW1wdHkgcHJldilcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgcmVsYXRpb25fdG9fcHJldiA9IGlmIGVxdWFsIHQgKGNoaWxkIHByZXYgfnBvb2wpIHRoZW4gYGNoaWxkIGVsc2UgYHNpYmxpbmcgaW5cbiAgICAgICAgc2V0X3ByZXYgdCAoZW1wdHkgKCkpIH5wb29sO1xuICAgICAgICBsZXQgc2libGluZyA9IGRpc2Nvbm5lY3Rfc2libGluZyB0IH5wb29sIGluXG4gICAgICAgIChtYXRjaCByZWxhdGlvbl90b19wcmV2IHdpdGhcbiAgICAgICAgIHwgYGNoaWxkIC0+IHNldF9jaGlsZCBwcmV2IHNpYmxpbmcgfnBvb2xcbiAgICAgICAgIHwgYHNpYmxpbmcgLT4gc2V0X3NpYmxpbmcgcHJldiBzaWJsaW5nIH5wb29sKTtcbiAgICAgICAgaWYgbm90IChpc19lbXB0eSBzaWJsaW5nKSB0aGVuIHNldF9wcmV2IHNpYmxpbmcgcHJldiB+cG9vbCkpXG4gIDs7XG5cbiAgbW9kdWxlIFBvb2wgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBub2RlIFBvb2wudFxuICAgIHR5cGUgbm9ucmVjICdhIG5vZGUgPSAnYSBub2RlIFBvaW50ZXIudFxuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSBhKSB+bWluX3NpemU6Y2FwYWNpdHkgOiBhIHQgPVxuICAgICAgUG9vbC5jcmVhdGVcbiAgICAgICAgUG9vbC5TbG90cy50NVxuICAgICAgICB+Y2FwYWNpdHlcbiAgICAgICAgfmR1bW15OlxuICAgICAgICAgICggKE9iai5tYWdpYyBOb25lIDogYSlcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIGR1bW15X2lkIClcbiAgICA7O1xuXG4gICAgbGV0IGlzX2Z1bGwgdCA9IFBvb2wuaXNfZnVsbCB0XG4gICAgbGV0IGxlbmd0aCB0ID0gUG9vbC5sZW5ndGggdFxuICAgIGxldCBncm93IHQgPSBQb29sLmdyb3cgdFxuXG4gICAgbGV0IGNvcHkgdCBzdGFydCA9XG4gICAgICBsZXQgdCcgPSBjcmVhdGUgfm1pbl9zaXplOihQb29sLmNhcGFjaXR5IHQpIGluXG4gICAgICBsZXQgY29weV9ub2RlIG5vZGUgdG9fdmlzaXQgPVxuICAgICAgICBpZiBpc19lbXB0eSBub2RlXG4gICAgICAgIHRoZW4gZW1wdHkgKCksIHRvX3Zpc2l0XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIHdlIHVzZSB0aGUgc2FtZSBpZCwgYnV0IHRoYXQncyBvayBzaW5jZSBpZHMgc2hvdWxkIGJlIHVuaXF1ZSBwZXIgaGVhcCAqKVxuICAgICAgICAgIGxldCBuZXdfbm9kZSA9XG4gICAgICAgICAgICBhbGxvY2F0ZSAodmFsdWVfZXhuIG5vZGUgfnBvb2w6dCkgfnBvb2w6dCcgfmlkOihpZCBub2RlIH5wb29sOnQpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgdG9fdmlzaXQgPVxuICAgICAgICAgICAgKG5ld19ub2RlLCBgY2hpbGQsIGNoaWxkIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICAgIDo6IChuZXdfbm9kZSwgYHNpYmxpbmcsIHNpYmxpbmcgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgICAgOjogdG9fdmlzaXRcbiAgICAgICAgICBpblxuICAgICAgICAgIG5ld19ub2RlLCB0b192aXNpdClcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgICAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCAobm9kZV90b191cGRhdGUsIHNsb3QsIG5vZGVfdG9fY29weSkgOjogcmVzdCAtPlxuICAgICAgICAgIGxldCBuZXdfbm9kZSwgdG9fdmlzaXQgPSBjb3B5X25vZGUgbm9kZV90b19jb3B5IHJlc3QgaW5cbiAgICAgICAgICAobWF0Y2ggc2xvdCB3aXRoXG4gICAgICAgICAgIHwgYGNoaWxkIC0+IHNldF9jaGlsZCBub2RlX3RvX3VwZGF0ZSBuZXdfbm9kZSB+cG9vbDp0J1xuICAgICAgICAgICB8IGBzaWJsaW5nIC0+IHNldF9zaWJsaW5nIG5vZGVfdG9fdXBkYXRlIG5ld19ub2RlIH5wb29sOnQnKTtcbiAgICAgICAgICBpZiBub3QgKGlzX2VtcHR5IG5ld19ub2RlKSB0aGVuIHNldF9wcmV2IG5ld19ub2RlIG5vZGVfdG9fdXBkYXRlIH5wb29sOnQnO1xuICAgICAgICAgIGxvb3AgdG9fdmlzaXRcbiAgICAgIGluXG4gICAgICBsZXQgbmV3X3N0YXJ0LCB0b192aXNpdCA9IGNvcHlfbm9kZSBzdGFydCBbXSBpblxuICAgICAgbG9vcCB0b192aXNpdDtcbiAgICAgIG5ld19zdGFydCwgdCdcbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICdhIHQgPVxuICB7ICgqIGNtcCBpcyBwbGFjZWQgZmlyc3QgdG8gc2hvcnQtY2lyY3VpdCBwb2x5bW9ycGhpYyBjb21wYXJlICopXG4gICAgY21wIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgbXV0YWJsZSBwb29sIDogJ2EgTm9kZS5Qb29sLnRcbiAgOyAoKiBpbnZhcmlhbnQ6ICBbcm9vdF0gbmV2ZXIgaGFzIGEgc2libGluZyAqKVxuICAgIG11dGFibGUgcm9vdCA6ICdhIE5vZGUudFxuICA7IG11dGFibGUgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyA6IGludFxuICB9XG5cbmxldCBpbnZhcmlhbnQgXyB0ID1cbiAgbGV0IHJlYyBsb29wIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgKG5vZGUsIGV4cGVjdGVkX3ByZXYsIG1heWJlX3BhcmVudF92YWx1ZSkgOjogcmVzdCAtPlxuICAgICAgaWYgbm90IChOb2RlLmlzX2VtcHR5IG5vZGUpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRoaXNfdmFsdWUgPSBOb2RlLnZhbHVlX2V4biBub2RlIH5wb29sOnQucG9vbCBpblxuICAgICAgICBhc3NlcnQgKE5vZGUuZXF1YWwgKE5vZGUucHJldiBub2RlIH5wb29sOnQucG9vbCkgZXhwZWN0ZWRfcHJldik7XG4gICAgICAgIE9wdGlvbi5pdGVyIG1heWJlX3BhcmVudF92YWx1ZSB+ZjooZnVuIHBhcmVudF92YWx1ZSAtPlxuICAgICAgICAgIGFzc2VydCAodC5jbXAgcGFyZW50X3ZhbHVlIHRoaXNfdmFsdWUgPD0gMCkpO1xuICAgICAgICBsb29wXG4gICAgICAgICAgKChOb2RlLmNoaWxkIG5vZGUgfnBvb2w6dC5wb29sLCBub2RlLCBTb21lIHRoaXNfdmFsdWUpXG4gICAgICAgICAgIDo6IChOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbDp0LnBvb2wsIG5vZGUsIG1heWJlX3BhcmVudF92YWx1ZSlcbiAgICAgICAgICAgOjogcmVzdCkpXG4gICAgICBlbHNlIGxvb3AgcmVzdFxuICBpblxuICBhc3NlcnQgKE5vZGUuaXNfZW1wdHkgdC5yb290IHx8IE5vZGUuaXNfZW1wdHkgKE5vZGUuc2libGluZyB0LnJvb3QgfnBvb2w6dC5wb29sKSk7XG4gIGxvb3AgWyB0LnJvb3QsIE5vZGUuZW1wdHkgKCksIE5vbmUgXVxuOztcblxubGV0IGNyZWF0ZSA/KG1pbl9zaXplID0gMSkgfmNtcCAoKSA9XG4gIHsgY21wXG4gIDsgcG9vbCA9IE5vZGUuUG9vbC5jcmVhdGUgfm1pbl9zaXplXG4gIDsgcm9vdCA9IE5vZGUuZW1wdHkgKClcbiAgOyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzID0gMFxuICB9XG47O1xuXG5sZXQgY29weSB7IGNtcDsgcG9vbDsgcm9vdDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyB9ID1cbiAgbGV0IHJvb3QsIHBvb2wgPSBOb2RlLlBvb2wuY29weSBwb29sIHJvb3QgaW5cbiAgeyBjbXA7IHBvb2w7IHJvb3Q7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgfVxuOztcblxubGV0IGFsbG9jYXRlIHQgdiA9XG4gIGlmIE5vZGUuUG9vbC5pc19mdWxsIHQucG9vbCB0aGVuIHQucG9vbCA8LSBOb2RlLlBvb2wuZ3JvdyB0LnBvb2w7XG4gIHQubnVtX29mX2FsbG9jYXRlZF9ub2RlcyA8LSB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgKyAxO1xuICBOb2RlLmFsbG9jYXRlIHYgfnBvb2w6dC5wb29sIH5pZDooTm9kZS5JZC5vZl9pbnQgdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzKVxuOztcblxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBtYXRjaCByb290MSwgcm9vdDIgd2l0aFxuICAgICB8IE5vbmUsIGggfCBoLCBOb25lIC0+IGhcbiAgICAgfCBTb21lIChOb2RlICh2MSwgY2hpbGRyZW4xKSksIFNvbWUgKE5vZGUgKHYyLCBjaGlsZHJlbjIpKSAtPlxuICAgICAgIGlmIHYxIDwgdjJcbiAgICAgICB0aGVuIFNvbWUgKE5vZGUgKHYxLCByb290MiA6OiBjaGlsZHJlbjEpKVxuICAgICAgIGVsc2UgU29tZSAoTm9kZSAodjIsIHJvb3QxIDo6IGNoaWxkcmVuMikpXG4gICBdfVxuXG4gICBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbmVpdGhlciByb290IGhhcyBhIHByZXYgbm9kZSAodXN1YWxseSBiZWNhdXNlIHRoZSBpbnB1dHMgY29tZVxuICAgZnJvbSBbZGlzY29ubmVjdF8qXSBvciBhcmUgdGhlIHRvcCBvZiB0aGUgaGVhcCBvciBhcmUgdGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uKS4gKilcbmxldCBtZXJnZSB0IHJvb3QxIHJvb3QyID1cbiAgaWYgTm9kZS5pc19lbXB0eSByb290MVxuICB0aGVuIHJvb3QyXG4gIGVsc2UgaWYgTm9kZS5pc19lbXB0eSByb290MlxuICB0aGVuIHJvb3QxXG4gIGVsc2UgKFxuICAgIGxldCBhZGRfY2hpbGQgdCBub2RlIH5jaGlsZCA9XG4gICAgICBOb2RlLmFkZF9jaGlsZCBub2RlIH5wb29sOnQucG9vbCB+Y2hpbGQ7XG4gICAgICBub2RlXG4gICAgaW5cbiAgICBsZXQgdjEgPSBOb2RlLnZhbHVlX2V4biByb290MSB+cG9vbDp0LnBvb2wgaW5cbiAgICBsZXQgdjIgPSBOb2RlLnZhbHVlX2V4biByb290MiB+cG9vbDp0LnBvb2wgaW5cbiAgICBpZiB0LmNtcCB2MSB2MiA8IDBcbiAgICB0aGVuIGFkZF9jaGlsZCB0IHJvb3QxIH5jaGlsZDpyb290MlxuICAgIGVsc2UgYWRkX2NoaWxkIHQgcm9vdDIgfmNoaWxkOnJvb3QxKVxuOztcblxubGV0IHRvcF9leG4gdCA9XG4gIGlmIE5vZGUuaXNfZW1wdHkgdC5yb290XG4gIHRoZW4gZmFpbHdpdGggXCJIZWFwLnRvcF9leG4gY2FsbGVkIG9uIGFuIGVtcHR5IGhlYXBcIlxuICBlbHNlIE5vZGUudmFsdWVfZXhuIHQucm9vdCB+cG9vbDp0LnBvb2xcbjs7XG5cbmxldCB0b3AgdCA9IGlmIE5vZGUuaXNfZW1wdHkgdC5yb290IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHRvcF9leG4gdClcblxubGV0IGFkZF9ub2RlIHQgdiA9XG4gIGxldCBub2RlID0gYWxsb2NhdGUgdCB2IGluXG4gIHQucm9vdCA8LSBtZXJnZSB0IHQucm9vdCBub2RlO1xuICBub2RlXG47O1xuXG5sZXQgYWRkIHQgdiA9IGlnbm9yZSAoYWRkX25vZGUgdCB2IDogXyBOb2RlLnQpXG5cbigqIFttZXJnZV9wYWlyc10gdGFrZXMgYSBsaXN0IG9mIGhlYXAgcm9vdHMgYW5kIG1lcmdlcyBjb25zZWN1dGl2ZSBwYWlycywgcmVkdWNpbmcgdGhlXG4gICBsaXN0IG9mIGxlbmd0aCBuIHRvIG4vMi4gIFRoZW4gaXQgbWVyZ2VzIHRoZSBtZXJnZWQgcGFpcnMgaW50byBhIHNpbmdsZSBoZWFwLiAgT25lXG4gICBpbnR1aXRpb24gaXMgdGhhdCB0aGlzIGlzIHNvbWV3aGF0IGxpa2UgYnVpbGRpbmcgYSBzaW5nbGUgbGV2ZWwgb2YgYSBiaW5hcnkgdHJlZS5cblxuICAgVGhlIG91dHB1dCBoZWFwIGRvZXMgbm90IGNvbnRhaW4gdGhlIHZhbHVlIHRoYXQgd2FzIGF0IHRoZSByb290IG9mIHRoZSBpbnB1dCBoZWFwLlxuXG4gICBXZSBicmVhayB0aGUgZnVuY3Rpb24gaW50byB0d28gcGFydHMuICBBIGZpcnN0IHN0YWdlIHRoYXQgaXMgd2lsbGluZyB0byB1c2UgbGltaXRlZFxuICAgc3RhY2sgaW5zdGVhZCBvZiBoZWFwIGFsbG9jYXRpb24gZm9yIGJvb2trZWVwaW5nLCBhbmQgYSBzZWNvbmQgc3RhZ2UgdGhhdCBzaGlmdHMgdG9cbiAgIHVzaW5nIGEgbGlzdCBhcyBhbiBhY2N1bXVsYXRvciBpZiB3ZSBnbyB0b28gZGVlcC5cblxuICAgVGhpcyBjYW4gYmUgbWFkZSB0YWlsIHJlY3Vyc2l2ZSBhbmQgbm9uLWFsbG9jYXRpbmcgYnkgc3RhcnRpbmcgd2l0aCBhbiBlbXB0eSBoZWFwIGFuZFxuICAgbWVyZ2luZyBtZXJnZWQgcGFpcnMgaW50byBpdC4gVW5mb3J0dW5hdGVseSB0aGlzIFwibGVmdCBmb2xkXCIgdmVyc2lvbiBpcyBub3Qgd2hhdCBpc1xuICAgZGVzY3JpYmVkIGluIHRoZSBvcmlnaW5hbCBwYXBlciBieSBGcmVkbWFuIGV0IGFsLjsgdGhleSBzcGVjaWZpY2FsbHkgc2F5IHRoYXRcbiAgIGNoaWxkcmVuIHNob3VsZCBiZSBtZXJnZWQgdG9nZXRoZXIgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICBsaXN0LiAoW21lcmdlXSBpcyBub3QgYXNzb2NpYXRpdmUsIHNvIG9yZGVyIG1hdHRlcnMuKVxuKilcbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgICAgfCBbXSAtPiBhY2NcbiAgICAgICB8IFtoZWFkXSAtPiBoZWFkIDo6IGFjY1xuICAgICAgIHwgaGVhZCA6OiBuZXh0MSA6OiBuZXh0MiAtPiBsb29wIChtZXJnZSBoZWFkIG5leHQxIDo6IGFjYykgbmV4dDJcbiAgICAgaW5cbiAgICAgbWF0Y2ggbG9vcCBbXSBjaGlsZHJlbiB3aXRoXG4gICAgIHwgW10gLT4gTm9uZVxuICAgICB8IFtoXSAtPiBTb21lIGhcbiAgICAgfCB4IDo6IHhzIC0+IFNvbWUgKExpc3QuZm9sZCB4cyB+aW5pdDp4IH5mOm1lcmdlKVxuICAgXX1cbiopXG5sZXQgYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGhlYWQgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGhlYWQgPVxuICAgIGlmIE5vZGUuaXNfZW1wdHkgaGVhZFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dDEgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBoZWFkIH5wb29sOnQucG9vbCBpblxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBuZXh0MVxuICAgICAgdGhlbiBoZWFkIDo6IGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0MiA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIG5leHQxIH5wb29sOnQucG9vbCBpblxuICAgICAgICBsb29wIChtZXJnZSB0IGhlYWQgbmV4dDEgOjogYWNjKSBuZXh0MikpXG4gIGluXG4gIG1hdGNoIGxvb3AgW10gaGVhZCB3aXRoXG4gIHwgW10gLT4gTm9kZS5lbXB0eSAoKVxuICB8IFsgaCBdIC0+IGhcbiAgfCB4IDo6IHhzIC0+IExpc3QuZm9sZCB4cyB+aW5pdDp4IH5mOihmdW4gYWNjIGhlYXAgLT4gbWVyZ2UgdCBhY2MgaGVhcClcbjs7XG5cbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbWF0Y2ggdC5yb290IHdpdGhcbiAgICAgfCBOb2RlIChfLCBjaGlsZHJlbikgLT5cbiAgICAgICBsZXQgcmVjIGxvb3AgZGVwdGggY2hpbGRyZW4gPVxuICAgICAgICAgaWYgZGVwdGggPj0gbWF4X3N0YWNrX2RlcHRoXG4gICAgICAgICB0aGVuIGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBjaGlsZGVuXG4gICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgIG1hdGNoIGNoaWxkcmVuIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICAgIHwgW2hlYWRdIC0+IFNvbWUgaGVhZFxuICAgICAgICAgICB8IGhlYWQgOjogbmV4dDEgOjogbmV4dDIgLT5cbiAgICAgICAgICAgICBtZXJnZSAobWVyZ2UgaGVhZCBuZXh0MSkgKGxvb3AgKGRlcHRoICsgMSkgbmV4dDIpXG4gICAgICAgICBlbmRcbiAgICAgICBpblxuICAgICAgIGxvb3AgMCBjaGlsZHJlblxuICAgXX1cbiopXG5sZXQgbWVyZ2VfcGFpcnMgPVxuICBsZXQgbWF4X3N0YWNrX2RlcHRoID0gMV8wMDAgaW5cbiAgbGV0IHJlYyBsb29wIHQgZGVwdGggaGVhZCA9XG4gICAgaWYgZGVwdGggPj0gbWF4X3N0YWNrX2RlcHRoXG4gICAgdGhlbiBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgaGVhZFxuICAgIGVsc2UgaWYgTm9kZS5pc19lbXB0eSBoZWFkXG4gICAgdGhlbiBoZWFkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dDEgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBoZWFkIH5wb29sOnQucG9vbCBpblxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBuZXh0MVxuICAgICAgdGhlbiBoZWFkXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5leHQyID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgbmV4dDEgfnBvb2w6dC5wb29sIGluXG4gICAgICAgICgqIG1lcmdlIHRoZSBmaXJzdCB0d28gbm9kZXMgaW4gb3VyIGxpc3QsIGFuZCB0aGVuIG1lcmdlIHRoZSByZXN1bHQgd2l0aCB0aGVcbiAgICAgICAgICAgcmVzdWx0IG9mIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgbWVyZ2VfcGFpcnMgb24gdGhlIHRhaWwgKilcbiAgICAgICAgbWVyZ2UgdCAobWVyZ2UgdCBoZWFkIG5leHQxKSAobG9vcCB0IChkZXB0aCArIDEpIG5leHQyKSkpXG4gIGluXG4gIGZ1biB0IGhlYWQgLT4gbG9vcCB0IDAgaGVhZFxuOztcblxubGV0IHJlbW92ZV9ub25fZW1wdHkgdCBub2RlID1cbiAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgTm9kZS5kZXRhY2ggbm9kZSB+cG9vbDtcbiAgbGV0IG1lcmdlZF9jaGlsZHJlbiA9IG1lcmdlX3BhaXJzIHQgKE5vZGUuZGlzY29ubmVjdF9jaGlsZCBub2RlIH5wb29sKSBpblxuICBsZXQgbmV3X3Jvb3QgPVxuICAgIGlmIE5vZGUuZXF1YWwgdC5yb290IG5vZGUgdGhlbiBtZXJnZWRfY2hpbGRyZW4gZWxzZSBtZXJnZSB0IHQucm9vdCBtZXJnZWRfY2hpbGRyZW5cbiAgaW5cbiAgTm9kZS5mcmVlIG5vZGUgfnBvb2w7XG4gIHQucm9vdCA8LSBuZXdfcm9vdFxuOztcblxubGV0IHJlbW92ZV90b3AgdCA9IGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0LnJvb3QpIHRoZW4gcmVtb3ZlX25vbl9lbXB0eSB0IHQucm9vdFxuXG4oKiBOb3RlIHRoYXQgdGhpcyBpcyB0YWlsLXJlY3Vyc2l2ZSBhbmQgdGhhdCBlYWNoIG5vZGUgaXMgdmlzaXRlZCBhdCBtb3N0IDMgdGltZXMgKG9uY2VcbiAgIGZvciBlYWNoIGJyYW5jaCBvZiB0aGUgXCJpZlwiKSwgc28gaXQgdGFrZXMgbGluZWFyIHRpbWUgYW5kIGNvbnN0YW50IHNwYWNlLiAqKVxubGV0IHJlYyByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBub2RlIH5wb29sID1cbiAgbGV0IGNoaWxkID0gTm9kZS5jaGlsZCBub2RlIH5wb29sIGluXG4gIGxldCBzaWJsaW5nID0gTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2wgaW5cbiAgaWYgbm90IChOb2RlLmlzX2VtcHR5IGNoaWxkKVxuICB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IGNoaWxkIH5wb29sXG4gIGVsc2UgaWYgbm90IChOb2RlLmlzX2VtcHR5IHNpYmxpbmcpXG4gIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgc2libGluZyB+cG9vbFxuICBlbHNlIChcbiAgICBsZXQgcHJldiA9IE5vZGUucHJldiBub2RlIH5wb29sIGluXG4gICAgTm9kZS5kZXRhY2ggbm9kZSB+cG9vbDtcbiAgICBOb2RlLmZyZWUgbm9kZSB+cG9vbDtcbiAgICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgcHJldikgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBwcmV2IH5wb29sKVxuOztcblxubGV0IGNsZWFyIHQgPVxuICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdC5yb290KVxuICB0aGVuIChcbiAgICByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSB0LnJvb3QgfnBvb2w6dC5wb29sO1xuICAgIHQucm9vdCA8LSBOb2RlLmVtcHR5ICgpKVxuOztcblxubGV0IHBvcF9leG4gdCA9XG4gIGxldCByID0gdG9wX2V4biB0IGluXG4gIHJlbW92ZV90b3AgdDtcbiAgclxuOztcblxubGV0IHBvcCB0ID0gaWYgTm9kZS5pc19lbXB0eSB0LnJvb3QgdGhlbiBOb25lIGVsc2UgU29tZSAocG9wX2V4biB0KVxuXG5sZXQgcG9wX2lmIHQgZiA9XG4gIG1hdGNoIHRvcCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHYgLT5cbiAgICBpZiBmIHZcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZV90b3AgdDtcbiAgICAgIFNvbWUgdilcbiAgICBlbHNlIE5vbmVcbjs7XG5cbigqIHBhaXJpbmcgaGVhcHMgYXJlIG5vdCBiYWxhbmNlZCB0cmVlcywgYW5kIHRoZXJlZm9yZSB3ZSBjYW4ndCByZWx5IG9uIGEgYmFsYW5jZVxuICAgcHJvcGVydHkgdG8gc3RvcCBvdXJzZWx2ZXMgZnJvbSBvdmVyZmxvd2luZyB0aGUgc3RhY2suICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyB0b192aXNpdCA9XG4gICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIGFjYyByZXN0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHRvX3Zpc2l0ID0gTm9kZS5zaWJsaW5nIH5wb29sIG5vZGUgOjogTm9kZS5jaGlsZCB+cG9vbCBub2RlIDo6IHJlc3QgaW5cbiAgICAgICAgbG9vcCAoZiBhY2MgKE5vZGUudmFsdWVfZXhuIH5wb29sIG5vZGUpKSB0b192aXNpdClcbiAgaW5cbiAgbG9vcCBpbml0IFsgdC5yb290IF1cbjs7XG5cbigqIGFsbW9zdCBpZGVudGljYWwgdG8gZm9sZCwgY29waWVkIGZvciBzcGVlZCBwdXJwb3NlcyAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgcmVzdFxuICAgICAgZWxzZSAoXG4gICAgICAgIGYgKE5vZGUudmFsdWVfZXhuIH5wb29sIG5vZGUpO1xuICAgICAgICBsZXQgdG9fdmlzaXQgPSBOb2RlLnNpYmxpbmcgfnBvb2wgbm9kZSA6OiBOb2RlLmNoaWxkIH5wb29sIG5vZGUgOjogcmVzdCBpblxuICAgICAgICBsb29wIHRvX3Zpc2l0KVxuICBpblxuICBsb29wIFsgdC5yb290IF1cbjs7XG5cbmxldCBsZW5ndGggdCA9IE5vZGUuUG9vbC5sZW5ndGggdC5wb29sXG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBpc19lbXB0eSB0ID0gTm9kZS5pc19lbXB0eSB0LnJvb3RcbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2FycmF5IGFyciB+Y21wID1cbiAgbGV0IHQgPSBjcmVhdGUgfm1pbl9zaXplOihBcnJheS5sZW5ndGggYXJyKSB+Y21wICgpIGluXG4gIEFycmF5Lml0ZXIgYXJyIH5mOihmdW4gdiAtPiBhZGQgdCB2KTtcbiAgdFxuOztcblxubGV0IG9mX2xpc3QgbCB+Y21wID0gb2ZfYXJyYXkgKEFycmF5Lm9mX2xpc3QgbCkgfmNtcFxubGV0IHNleHBfb2ZfdCBmIHQgPSBBcnJheS5zZXhwX29mX3QgZiAodG9fYXJyYXkgdCB8PiBBcnJheS5zb3J0ZWRfY29weSB+Y29tcGFyZTp0LmNtcClcblxubW9kdWxlIEVsdCA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID1cbiAgICB7IG11dGFibGUgbm9kZSA6ICdhIE5vZGUudFxuICAgIDsgbm9kZV9pZCA6IE5vZGUuSWQudFxuICAgIDsgaGVhcCA6ICdhIHRcbiAgICB9XG5cbiAgKCogSWYgaWRzIGFyZSBkaWZmZXJlbnQsIGl0IG1lYW5zIHRoYXQgdGhlIG5vZGUgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGJ5IHNvbWVcbiAgICAgb3RoZXIgbWVhbnMgKGFuZCBwb3NzaWJseSByZXVzZWQpLiAqKVxuICBsZXQgaXNfbm9kZV92YWxpZCB0ID0gTm9kZS5JZC5lcXVhbCAoTm9kZS5pZCB+cG9vbDp0LmhlYXAucG9vbCB0Lm5vZGUpIHQubm9kZV9pZFxuXG4gIGxldCB2YWx1ZSB0ID1cbiAgICBpZiBpc19ub2RlX3ZhbGlkIHQgdGhlbiBTb21lIChOb2RlLnZhbHVlX2V4biB0Lm5vZGUgfnBvb2w6dC5oZWFwLnBvb2wpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB2YWx1ZV9leG4gdCA9XG4gICAgaWYgaXNfbm9kZV92YWxpZCB0XG4gICAgdGhlbiBOb2RlLnZhbHVlX2V4biB0Lm5vZGUgfnBvb2w6dC5oZWFwLnBvb2xcbiAgICBlbHNlIGZhaWx3aXRoIFwiSGVhcC52YWx1ZV9leG46IG5vZGUgd2FzIHJlbW92ZWQgZnJvbSB0aGUgaGVhcFwiXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFslc2V4cCAodmFsdWUgdCA6IGEgb3B0aW9uKV1cbmVuZFxuXG5sZXQgcmVtb3ZlIHQgKHRva2VuIDogXyBFbHQudCkgPVxuICBpZiBub3QgKHBoeXNfZXF1YWwgdCB0b2tlbi5oZWFwKVxuICB0aGVuIGZhaWx3aXRoIFwiY2Fubm90IHJlbW92ZSBmcm9tIGEgZGlmZmVyZW50IGhlYXBcIlxuICBlbHNlIGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0b2tlbi5ub2RlKVxuICB0aGVuIChcbiAgICBpZiBFbHQuaXNfbm9kZV92YWxpZCB0b2tlbiB0aGVuIHJlbW92ZV9ub25fZW1wdHkgdCB0b2tlbi5ub2RlO1xuICAgIHRva2VuLm5vZGUgPC0gTm9kZS5lbXB0eSAoKSlcbjs7XG5cbmxldCBhZGRfcmVtb3ZhYmxlIHQgdiA9XG4gIGxldCBub2RlID0gYWRkX25vZGUgdCB2IGluXG4gIHsgRWx0Lm5vZGU7IGhlYXAgPSB0OyBub2RlX2lkID0gTm9kZS5pZCB+cG9vbDp0LnBvb2wgbm9kZSB9XG47O1xuXG5sZXQgdXBkYXRlIHQgdG9rZW4gdiA9XG4gIHJlbW92ZSB0IHRva2VuO1xuICBhZGRfcmVtb3ZhYmxlIHQgdlxuOztcblxubGV0IGZpbmRfZWx0ID1cbiAgbGV0IHJlYyBsb29wIHQgZiBub2RlcyA9XG4gICAgbWF0Y2ggbm9kZXMgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgbm9kZSA6OiByZXN0IC0+XG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5vZGVcbiAgICAgIHRoZW4gbG9vcCB0IGYgcmVzdFxuICAgICAgZWxzZSBpZiBmIChOb2RlLnZhbHVlX2V4biBub2RlIH5wb29sOnQucG9vbClcbiAgICAgIHRoZW4gU29tZSB7IEVsdC5ub2RlOyBoZWFwID0gdDsgbm9kZV9pZCA9IE5vZGUuaWQgfnBvb2w6dC5wb29sIG5vZGUgfVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIHQgZiAoTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2w6dC5wb29sIDo6IE5vZGUuY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wgOjogcmVzdClcbiAgaW5cbiAgZnVuIHQgfmYgLT4gbG9vcCB0IGYgWyB0LnJvb3QgXVxuOztcblxubW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgdHlwZSAnYSBoZWFwID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIE5vZGUudFxuXG4gICAgbGV0IHZhbHVlIHQgaGVhcCA9IE5vZGUudmFsdWVfZXhuIH5wb29sOmhlYXAucG9vbCB0XG4gIGVuZFxuXG4gIGxldCBhZGRfcmVtb3ZhYmxlID0gYWRkX25vZGVcbiAgbGV0IHJlbW92ZSA9IHJlbW92ZV9ub25fZW1wdHlcblxuICBsZXQgdXBkYXRlIHQgZWx0IHYgPVxuICAgIHJlbW92ZSB0IGVsdDtcbiAgICBhZGRfcmVtb3ZhYmxlIHQgdlxuICA7O1xuZW5kXG4iXX0=
