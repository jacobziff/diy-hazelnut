// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0];
   runtime.caml_register_global(0, Base, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml;
   function descending(x, y){return caml_compare(y, x);}
   var
    max = Caml[17],
    min = Caml[16],
    Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(1, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Poly0, Caml, Shadow_stdlib, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Caml = global_data.Caml,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    invalid_arg = Caml[1],
    failwith = Caml[2],
    Exit$0 = Caml[3],
    Match_failure = Caml[4],
    Assert_failure = Caml[5],
    Invalid_argument = Caml[6],
    Failure = Caml[7],
    Out_of_memory = Caml[9],
    Stack_overflow = Caml[10],
    Sys_error = Caml[11],
    End_of_file = Caml[12],
    Division_by_zero = Caml[13],
    Sys_blocked_io = Caml[14],
    Undefined_recursive_module = Caml[15],
    min = Caml[16],
    max = Caml[17],
    abs = Caml[18],
    max_int$0 = Caml[19],
    min_int$0 = Caml[20],
    lnot = Caml[21],
    infinity$0 = Caml[22],
    neg_infinity$0 = Caml[23],
    nan$0 = Caml[24],
    max_float$0 = Caml[25],
    min_float$0 = Caml[26],
    epsilon_float$0 = Caml[27],
    symbol_concat = Caml[28],
    char_of_int$0 = Caml[29],
    string_of_bool$0 = Caml[30],
    bool_of_string_opt$0 = Caml[31],
    bool_of_string$0 = Caml[32],
    string_of_int$0 = Caml[33],
    int_of_string_opt$0 = Caml[34],
    string_of_float$0 = Caml[35],
    float_of_string_opt$0 = Caml[36],
    symbol$0 = Caml[37],
    stdin$0 = Caml[38],
    stdout$0 = Caml[39],
    stderr$0 = Caml[40],
    print_char$0 = Caml[41],
    print_string$0 = Caml[42],
    print_bytes$0 = Caml[43],
    print_int$0 = Caml[44],
    print_float$0 = Caml[45],
    print_endline$0 = Caml[46],
    print_newline$0 = Caml[47],
    prerr_char$0 = Caml[48],
    prerr_string$0 = Caml[49],
    prerr_bytes$0 = Caml[50],
    prerr_int$0 = Caml[51],
    prerr_float$0 = Caml[52],
    prerr_endline$0 = Caml[53],
    prerr_newline$0 = Caml[54],
    read_line$0 = Caml[55],
    read_int_opt$0 = Caml[56],
    read_int$0 = Caml[57],
    read_float_opt$0 = Caml[58],
    read_float$0 = Caml[59],
    open_out$0 = Caml[60],
    open_out_bin$0 = Caml[61],
    open_out_gen$0 = Caml[62],
    flush$0 = Caml[63],
    flush_all$0 = Caml[64],
    output_char$0 = Caml[65],
    output_string$0 = Caml[66],
    output_bytes$0 = Caml[67],
    output$0 = Caml[68],
    output_substring$0 = Caml[69],
    output_byte$0 = Caml[70],
    output_binary_int$0 = Caml[71],
    output_value$0 = Caml[72],
    seek_out$0 = Caml[73],
    pos_out$0 = Caml[74],
    out_channel_length$0 = Caml[75],
    close_out$0 = Caml[76],
    close_out_noerr$0 = Caml[77],
    set_binary_mode_out$0 = Caml[78],
    open_in$0 = Caml[79],
    open_in_bin$0 = Caml[80],
    open_in_gen$0 = Caml[81],
    input_char$0 = Caml[82],
    input_line$0 = Caml[83],
    input$0 = Caml[84],
    really_input$0 = Caml[85],
    really_input_string$0 = Caml[86],
    input_byte$0 = Caml[87],
    input_binary_int$0 = Caml[88],
    input_value$0 = Caml[89],
    seek_in$0 = Caml[90],
    pos_in$0 = Caml[91],
    in_channel_length$0 = Caml[92],
    close_in$0 = Caml[93],
    close_in_noerr$0 = Caml[94],
    set_binary_mode_in$0 = Caml[95],
    LargeFile = Caml[96],
    string_of_format$0 = Caml[97],
    symbol$1 = Caml[98],
    exit$0 = Caml[99],
    at_exit$0 = Caml[100],
    valid_float_lexem$0 = Caml[101],
    unsafe_really_input$0 = Caml[102],
    do_at_exit$0 = Caml[103],
    In_channel = Caml[104],
    Out_channel = Caml[105],
    Not_found$0 = Caml[8],
    Caml$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol_concat,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$0,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$1,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       In_channel,
       Out_channel,
       Not_found$0];
   function bool_to_int(x){return x;}
   function symbol$2(_V_, _U_){return _V_ !== _U_ ? 1 : 0;}
   var symbol$3 = runtime.caml_mul;
   function symbol$4(_T_, _S_){return Math.pow(_T_, _S_);}
   function symbol$5(_R_, _Q_){return _R_ * _Q_;}
   function symbol$6(_P_, _O_){return _P_ + _O_ | 0;}
   function symbol$7(_N_, _M_){return _N_ + _M_;}
   function symbol$8(_L_, _K_){return _L_ - _K_ | 0;}
   function symbol$9(_J_, _I_){return _J_ - _I_;}
   var symbol$10 = runtime.caml_div;
   function symbol$11(_H_, _G_){return _H_ / _G_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return y <= x ? x : y;}
   function min$0(x, y){return x <= y ? x : y;}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$12 = caml_lessthan,
    symbol$13 = caml_lessequal,
    symbol$14 = caml_notequal,
    symbol$15 = caml_equal,
    symbol$16 = caml_greaterthan,
    symbol$17 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare = caml_int_compare, equal = caml_equal;
   function max$2(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$2(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$3(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$18 = caml_lessthan,
    symbol$19 = caml_lessequal,
    symbol$20 = caml_notequal,
    symbol$21 = caml_equal,
    symbol$22 = caml_greaterthan,
    symbol$23 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, equal$0 = caml_equal;
   function max$4(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$4(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$4,
       min$4];
   function symbol$24(x, y){return x < y ? 1 : 0;}
   function symbol$25(x, y){return x <= y ? 1 : 0;}
   function symbol$26(x, y){return x !== y ? 1 : 0;}
   function symbol$27(x, y){return x === y ? 1 : 0;}
   function symbol$28(x, y){return y < x ? 1 : 0;}
   function symbol$29(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return y <= x ? x : y;}
   function min$5(x, y){return x <= y ? x : y;}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$5,
       min$5];
   function symbol$30(x, y){return x < y ? 1 : 0;}
   function symbol$31(x, y){return x <= y ? 1 : 0;}
   function symbol$32(x, y){return x !== y ? 1 : 0;}
   function symbol$33(x, y){return x === y ? 1 : 0;}
   function symbol$34(x, y){return y < x ? 1 : 0;}
   function symbol$35(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return y <= x ? x : y;}
   function min$6(x, y){return x <= y ? x : y;}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$6,
       min$6];
   function i(x){return caml_call1(Stdlib_Uchar[10], x);}
   function symbol$36(x, y){var _F_ = i(y); return i(x) < _F_ ? 1 : 0;}
   function symbol$37(x, y){var _E_ = i(y); return i(x) <= _E_ ? 1 : 0;}
   function symbol$38(x, y){var _D_ = i(y); return i(x) !== _D_ ? 1 : 0;}
   function symbol$39(x, y){var _C_ = i(y); return i(x) === _C_ ? 1 : 0;}
   function symbol$40(x, y){var _B_ = i(y); return _B_ < i(x) ? 1 : 0;}
   function symbol$41(x, y){var _A_ = i(y); return _A_ <= i(x) ? 1 : 0;}
   function ascending$6(x, y){
    var _y_ = i(y), _z_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[1], _z_, _y_);
   }
   function descending$6(x, y){
    var _w_ = i(y), _x_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[2], _x_, _w_);
   }
   function compare$3(x, y){
    var _v_ = i(y);
    return caml_int_compare(i(x), _v_);
   }
   function equal$3(x, y){var _u_ = i(y); return i(x) === _u_ ? 1 : 0;}
   function max$7(x, y){return symbol$41(x, y) ? x : y;}
   function min$7(x, y){return symbol$37(x, y) ? x : y;}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       i,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$7,
       min$7];
   function symbol$42(x, y){return x < y ? 1 : 0;}
   function symbol$43(x, y){return x <= y ? 1 : 0;}
   function symbol$44(x, y){return x != y ? 1 : 0;}
   function symbol$45(x, y){return x == y ? 1 : 0;}
   function symbol$46(x, y){return y < x ? 1 : 0;}
   function symbol$47(x, y){return y <= x ? 1 : 0;}
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$4 = runtime.caml_float_compare;
   function equal$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return y <= x ? x : y;}
   function min$8(x, y){return x <= y ? x : y;}
   var
    Float_replace_polymorphic_comp =
      [0,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$8,
       min$8],
    symbol$48 = runtime.caml_string_lessthan,
    symbol$49 = caml_string_lessequal,
    symbol$50 = runtime.caml_string_notequal,
    symbol$51 = caml_string_equal,
    symbol$52 = runtime.caml_string_greaterthan,
    symbol$53 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$5 = runtime.caml_string_compare, equal$5 = caml_string_equal;
   function max$9(x, y){return caml_string_greaterequal(x, y) ? x : y;}
   function min$9(x, y){return caml_string_lessequal(x, y) ? x : y;}
   var
    String_replace_polymorphic_com =
      [0,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$9,
       min$9],
    symbol$54 = runtime.caml_bytes_lessthan,
    symbol$55 = caml_bytes_lessequal,
    symbol$56 = runtime.caml_bytes_notequal,
    symbol$57 = caml_bytes_equal,
    symbol$58 = runtime.caml_bytes_greaterthan,
    symbol$59 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$6 = runtime.caml_bytes_compare, equal$6 = caml_bytes_equal;
   function max$10(x, y){return caml_bytes_greaterequal(x, y) ? x : y;}
   function min$10(x, y){return caml_bytes_lessequal(x, y) ? x : y;}
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$54,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       symbol$59,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$10,
       min$10],
    symbol$60 = Caml$0[36],
    symbol_concat$0 = Caml$0[27];
   function symbol$61(_t_){return - _t_ | 0;}
   function symbol$62(_s_){return - _s_;}
   function asr(_r_, _q_){return _r_ >> _q_;}
   function land(_p_, _o_){return _p_ & _o_;}
   var lnot$0 = Caml$0[20];
   function lor(_n_, _m_){return _n_ | _m_;}
   function lsl(_l_, _k_){return _l_ << _k_;}
   function lsr(_j_, _i_){return _j_ >>> _i_ | 0;}
   function lxor(_h_, _g_){return _h_ ^ _g_;}
   var mod = runtime.caml_mod, abs$0 = Caml$0[17], failwith$0 = Caml$0[2];
   function fst(_f_){return _f_[1];}
   var invalid_arg$0 = Caml$0[1];
   function snd(_e_){return _e_[2];}
   function phys_equal(_d_, _c_){return _d_ === _c_ ? 1 : 0;}
   function decr(_b_){_b_[1]--; return 0;}
   function incr(_a_){_a_[1]++; return 0;}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$60,
       symbol_concat$0,
       symbol$61,
       symbol$62,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[123], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[125], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0);
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[47],
    runtime_warnings_enabled = Stdlib_Sys[48],
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[84][105])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[84][105]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11];
   function create(len, x){return runtime.caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[5],
    blit = Stdlib_ArrayLabels[10],
    concat = Stdlib_ArrayLabels[6],
    copy = Stdlib_ArrayLabels[8],
    fill = Stdlib_ArrayLabels[9],
    init = Stdlib_ArrayLabels[2],
    make_matrix = Stdlib_ArrayLabels[3],
    of_list = Stdlib_ArrayLabels[12],
    sub = Stdlib_ArrayLabels[7],
    to_list = Stdlib_ArrayLabels[11];
   function fold(t, init, f){
    return caml_call3(Stdlib_ArrayLabels[17], f, init, t);
   }
   function fold_right(t, f, init){
    return caml_call3(Stdlib_ArrayLabels[19], f, t, init);
   }
   function iter(t, f){return caml_call2(Stdlib_ArrayLabels[13], f, t);}
   function iteri(t, f){return caml_call2(Stdlib_ArrayLabels[14], f, t);}
   function map(t, f){return caml_call2(Stdlib_ArrayLabels[15], f, t);}
   function mapi(t, f){return caml_call2(Stdlib_ArrayLabels[16], f, t);}
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[33], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(6, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[5];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[6];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       0,
       255,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml,
    to_string = Caml[33],
    of_string = runtime.caml_int_of_string;
   function to_float(_c_){return _c_;}
   function of_float(_b_){return _b_ | 0;}
   var max_value = Caml[19], min_value = Caml[20];
   function succ(_a_){return _a_ + 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       to_float,
       of_float,
       max_value,
       min_value,
       succ];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[5],
    length = Stdlib_ListLabels[1],
    rev_append = Stdlib_ListLabels[12],
    tl_exn = Stdlib_ListLabels[6],
    unzip = Stdlib_ListLabels[54];
   function exists(t, f){return caml_call2(Stdlib_ListLabels[33], f, t);}
   function exists2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[35], f, l1, l2);
   }
   function fold(t, init, f){
    return caml_call3(Stdlib_ListLabels[25], f, init, t);
   }
   function fold2_ok(l1, l2, init, f){
    return caml_call4(Stdlib_ListLabels[30], f, init, l1, l2);
   }
   function for_all(t, f){return caml_call2(Stdlib_ListLabels[32], f, t);}
   function for_all2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[34], f, l1, l2);
   }
   function iter(t, f){return caml_call2(Stdlib_ListLabels[17], f, t);}
   function iter2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[27], f, l1, l2);
   }
   function nontail_map(t, f){return caml_call2(Stdlib_ListLabels[19], f, t);}
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[20], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[44], f, t);}
   function rev_map(t, f){return caml_call2(Stdlib_ListLabels[21], f, t);}
   function rev_map2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[29], f, l1, l2);
   }
   function sort(l, compare){
    return caml_call2(Stdlib_ListLabels[56], compare, l);
   }
   function stable_sort(l, compare){
    return caml_call2(Stdlib_ListLabels[57], compare, l);
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    return l
            ? fold(rev(l), init, function(a, b){return caml_call2(f, b, a);})
            : init;
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right];
   runtime.caml_register_global(1, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _H_(_ah_){return _ah_;}
    function hash_fold_int32(_af_, _ag_){return as_int(_H_, _af_, _ag_);}
    var _I_ = Base_Char0[4];
    function hash_fold_char(_ad_, _ae_){return as_int(_I_, _ad_, _ae_);}
    function _J_(param){return param ? 1 : 0;}
    function hash_fold_bool(_ab_, _ac_){return as_int(_J_, _ab_, _ac_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[2], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x);
      s = s$0;
      list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var
      _$_ = runtime.caml_obj_tag(x),
      _aa_ =
        250 === _$_
         ? x[1]
         : 246 === _$_ ? caml_call1(CamlinternalLazy[2], x) : x;
     return caml_call2(hash_fold_elem, s, _aa_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[90], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e);
      s = s$0;
      i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_nativeint(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_int64(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_int32(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = as_int(_H_, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_char(x){
     var
      _T_ = caml_call1(Hash[6], 0),
      _U_ = as_int(_I_, caml_call2(Hash[7], 0, _T_), x);
     return caml_call1(Hash[8], _U_);
    }
    function hash_int(x){
     var
      _R_ = caml_call1(Hash[6], 0),
      _S_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _R_), x);
     return caml_call1(Hash[8], _S_);
    }
    function hash_bool(x){
     var
      _P_ = caml_call1(Hash[6], 0),
      _Q_ = as_int(_J_, caml_call2(Hash[7], 0, _P_), x);
     return caml_call1(Hash[8], _Q_);
    }
    function hash_string(x){
     var
      _N_ = caml_call1(Hash[6], 0),
      _O_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _N_), x);
     return caml_call1(Hash[8], _O_);
    }
    function hash_float(x){
     var
      _L_ = caml_call1(Hash[6], 0),
      _M_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _L_), x);
     return caml_call1(Hash[8], _M_);
    }
    function hash_unit(x){
     var _K_ = caml_call1(Hash[6], 0), s = caml_call2(Hash[7], 0, _K_);
     return caml_call1(Hash[8], s);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _F_ = caml_call1(Hash[6], 0),
      _G_ = caml_call2(folder, caml_call2(Hash[7], seed, _F_), x);
     return caml_call1(Hash[8], _G_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_E_, _D_){
          return runtime.Base_internalhash_fold_int(_E_, _D_);
         },
         function(_C_, _B_){
          return runtime.Base_internalhash_fold_int64(_C_, _B_);
         },
         function(_A_, _z_){
          return runtime.Base_internalhash_fold_float(_A_, _z_);
         },
         function(_y_, _x_){
          return runtime.Base_internalhash_fold_string(_y_, _x_);
         },
         alloc,
         reset,
         function(_w_){return runtime.Base_internalhash_get_hash_value(_w_);},
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _k_ = caml_call2(Base_Import0[118], t, 21),
     _l_ = caml_call1(Base_Import0[116], t),
     t$0 = caml_call2(Base_Import0[90], _l_, _k_),
     _m_ = caml_call2(Base_Import0[119], t$0, 24),
     t$1 = caml_call2(Base_Import0[120], t$0, _m_),
     _n_ = caml_call2(Base_Import0[118], t$1, 8),
     _o_ = caml_call2(Base_Import0[118], t$1, 3),
     _p_ = caml_call2(Base_Import0[90], t$1, _o_),
     t$2 = caml_call2(Base_Import0[90], _p_, _n_),
     _q_ = caml_call2(Base_Import0[119], t$2, 14),
     t$3 = caml_call2(Base_Import0[120], t$2, _q_),
     _r_ = caml_call2(Base_Import0[118], t$3, 4),
     _s_ = caml_call2(Base_Import0[118], t$3, 2),
     _t_ = caml_call2(Base_Import0[90], t$3, _s_),
     t$4 = caml_call2(Base_Import0[90], _t_, _r_),
     _u_ = caml_call2(Base_Import0[119], t$4, 28),
     t$5 = caml_call2(Base_Import0[120], t$4, _u_),
     _v_ = caml_call2(Base_Import0[118], t$5, 31);
    return caml_call2(Base_Import0[90], t$5, _v_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_j_, _i_){
        return runtime.Base_internalhash_fold_int(_j_, _i_);
       },
       function(_h_, _g_){
        return runtime.Base_internalhash_fold_int64(_h_, _g_);
       },
       function(_f_, _e_){
        return runtime.Base_internalhash_fold_float(_f_, _e_);
       },
       function(_d_, _c_){
        return runtime.Base_internalhash_fold_string(_d_, _c_);
       },
       alloc,
       reset,
       function(_b_){return runtime.Base_internalhash_get_hash_value(_b_);},
       For_tests,
       create,
       of_fold,
       [0,
        hash_fold_nativeint,
        hash_fold_int64,
        hash_fold_int32,
        hash_fold_char,
        hash_fold_int,
        hash_fold_bool,
        hash_fold_string,
        hash_fold_float,
        hash_fold_unit,
        hash_fold_option,
        hash_fold_list,
        hash_fold_lazy_t,
        hash_fold_ref_frozen,
        hash_fold_array_frozen,
        hash_nativeint,
        hash_int64,
        hash_int32,
        hash_char,
        hash_int,
        hash_bool,
        hash_string,
        function(_a_){return runtime.Base_hash_double(_a_);},
        hash_unit],
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int_compare = runtime.caml_int_compare;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    phys_equal = Base_Import0[127],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."],
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _u_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _a_, type_name);
   }
   function equal_abstract(type_name, param, _t_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_char = caml_int_compare,
    compare_float = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int32 = caml_int_compare;
   function compare_int64(_s_, _r_){
    return runtime.caml_int64_compare(_s_, _r_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_string = runtime.caml_string_compare,
    compare_unit = caml_int_compare;
   function compare_array(compare_elt, a, b){
    if(caml_call2(phys_equal, a, b)) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[90], i, 1);
     i = i$0;
    }
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     a$0 = xs;
     b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function equal_char(_o_, _n_){return _o_ === _n_ ? 1 : 0;}
   function equal_int(_m_, _l_){return _m_ === _l_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int64 = caml_equal,
    equal_nativeint = caml_equal,
    equal_string = runtime.caml_string_equal;
   function equal_unit(_k_, _j_){return _k_ === _j_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_array(equal_elt, a, b){
    var _d_ = caml_call2(phys_equal, a, b);
    if(_d_)
     var _e_ = _d_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _f_ = len_a === len_b ? 1 : 0;
     if(_f_){
      var i = 0;
      for(;;){
       var _g_ = i === len_a ? 1 : 0;
       if(_g_)
        var _h_ = _g_;
       else{
        var l = a[1 + i], r = b[1 + i], _i_ = caml_call2(equal_elt, l, r);
        if(_i_){
         var i$0 = caml_call2(Base_Import0[90], i, 1);
         i = i$0;
         continue;
        }
        var _h_ = _i_;
       }
       return _h_;
      }
     }
     var _e_ = _f_;
    }
    return _e_;
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt, x, y);
       if(! _c_) return _c_;
       a$0 = xs;
       b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[6][8], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3(Base_Ppx_compare_lib[6][11], compare, a_005, b_006);
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[59];
   function invariant(param){return 0;}
   var
    Base_Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       0];
   runtime.caml_register_global(4, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    Caml = Base_Import0[84],
    bool_to_int = Base_Import0[85],
    symbol$0 = Base_Import0[86],
    symbol$1 = Base_Import0[87],
    symbol$2 = Base_Import0[88],
    symbol$3 = Base_Import0[89],
    symbol$4 = Base_Import0[90],
    symbol$5 = Base_Import0[91],
    symbol$6 = Base_Import0[92],
    symbol$7 = Base_Import0[93],
    symbol$8 = Base_Import0[94],
    symbol$9 = Base_Import0[95],
    Int_replace_polymorphic_compar = Base_Import0[96],
    ascending = Base_Import0[97],
    descending = Base_Import0[98],
    max = Base_Import0[99],
    min = Base_Import0[100],
    Int32_replace_polymorphic_comp = Base_Import0[101],
    Int64_replace_polymorphic_comp = Base_Import0[102],
    Nativeint_replace_polymorphic_ = Base_Import0[103],
    Bool_replace_polymorphic_compa = Base_Import0[104],
    Char_replace_polymorphic_compa = Base_Import0[105],
    Uchar_replace_polymorphic_comp = Base_Import0[106],
    Float_replace_polymorphic_comp = Base_Import0[107],
    String_replace_polymorphic_com = Base_Import0[108],
    Bytes_replace_polymorphic_comp = Base_Import0[109],
    symbol$10 = Base_Import0[110],
    symbol_concat = Base_Import0[111],
    symbol$11 = Base_Import0[112],
    symbol$12 = Base_Import0[113],
    asr = Base_Import0[114],
    land = Base_Import0[115],
    lnot = Base_Import0[116],
    lor = Base_Import0[117],
    lsl = Base_Import0[118],
    lsr = Base_Import0[119],
    lxor = Base_Import0[120],
    mod = Base_Import0[121],
    abs = Base_Import0[122],
    failwith = Base_Import0[123],
    fst = Base_Import0[124],
    invalid_arg = Base_Import0[125],
    snd = Base_Import0[126],
    phys_equal = Base_Import0[127],
    decr = Base_Import0[128],
    incr = Base_Import0[129],
    float_of_string = Base_Import0[130],
    am_testing = Base_Import0[131],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    unit_sexp_grammar = Sexplib0_Sexp_conv[49],
    bool_sexp_grammar = Sexplib0_Sexp_conv[50],
    string_sexp_grammar = Sexplib0_Sexp_conv[51],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[52],
    char_sexp_grammar = Sexplib0_Sexp_conv[53],
    int_sexp_grammar = Sexplib0_Sexp_conv[54],
    float_sexp_grammar = Sexplib0_Sexp_conv[55],
    int32_sexp_grammar = Sexplib0_Sexp_conv[56],
    int64_sexp_grammar = Sexplib0_Sexp_conv[57],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[58],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[59],
    ref_sexp_grammar = Sexplib0_Sexp_conv[60],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    option_sexp_grammar = Sexplib0_Sexp_conv[62],
    list_sexp_grammar = Sexplib0_Sexp_conv[63],
    array_sexp_grammar = Sexplib0_Sexp_conv[64],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[65],
    fun_sexp_grammar = Sexplib0_Sexp_conv[66],
    sexp_of_exn = Sexplib0_Sexp_conv[67],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[68],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[69],
    Exn_converter = Sexplib0_Sexp_conv[70],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    include = Base_Ppx_compare_lib[6],
    compare_bool = include[1],
    compare_char = include[2],
    compare_float = include[3],
    compare_int = include[4],
    compare_int32 = include[5],
    compare_int64 = include[6],
    compare_nativeint = include[7],
    compare_string = include[8],
    compare_unit = include[9],
    compare_array = include[10],
    compare_list = include[11],
    compare_option = include[12],
    compare_ref = include[13],
    equal_bool = include[14],
    equal_char = include[15],
    equal_float = include[16],
    equal_int = include[17],
    equal_int32 = include[18],
    equal_int64 = include[19],
    equal_nativeint = include[20],
    equal_string = include[21],
    equal_unit = include[22],
    equal_array = include[23],
    equal_list = include[24],
    equal_option = include[25],
    equal_ref = include[26],
    Not_found_s = Base_Sexp[7],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol_concat,
       symbol$11,
       symbol$12,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       Not_found_s];
   runtime.caml_register_global(5, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    cst_unknown_word_size = "unknown word size",
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[123], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[111], M[2], cst_pp));
    return [0, pp];
   }
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       function(_a_){return [0, Register_pp(_a_)[1]];},
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[84][98],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _a_ = [0, "exn.ml.Finally"],
    _b_ = [0, cst_src_exn_ml, 19, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Finally,
     function(param){
      if(param[1] !== Finally)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var
       arg1_002 = param[3],
       arg0_001 = param[2],
       res0_003 = caml_call1(sexp_of_t, arg0_001),
       res1_004 = caml_call1(sexp_of_t, arg1_002);
      return [1, [0, _a_, [0, res0_003, [0, res1_004, 0]]]];
     });
   var
    Reraised = [248, "Base__Exn.Reraised", caml_fresh_oo_id(0)],
    _c_ = [0, "exn.ml.Reraised"],
    _d_ = [0, cst_src_exn_ml, 33, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Reraised,
     function(param){
      if(param[1] !== Reraised)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var
       arg1_006 = param[3],
       arg0_005 = param[2],
       res0_007 = caml_call1(Base_Import[138], arg0_005),
       res1_008 = caml_call1(sexp_of_t, arg1_006);
      return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
     });
   var
    Sexp = [248, "Base__Exn.Sexp", caml_fresh_oo_id(0)],
    _e_ = [0, cst_src_exn_ml, 54, 6];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Sexp,
     function(param){
      if(param[1] !== Sexp)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var t = param[2];
      return t;
     });
   var _f_ = [0, 2];
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    return caml_call2
            (Base_Printf[4],
             function(str, param){return reraise(exc, str);},
             format);
   }
   function to_string(exc){
    var _u_ = caml_call1(Base_Import[198], exc);
    return caml_call2(Base_Sexp[15], _f_, _u_);
   }
   function to_string_mach(exc){
    var _t_ = caml_call1(Base_Import[198], exc);
    return caml_call1(Base_Sexp[16], _t_);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _r_ = 0; return _r_;}catch(_s_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[200], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[11], ppf, sexp);
    }
    var _q_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _q_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    _g_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _h_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[131], _g_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[84][39], raw_backtrace);
    return caml_call1(Base_Import[84][62], Base_Import[84][39]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _m_ = caml_call1(f, 0); return _m_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[84][102], 0);}catch(_p_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_n_){try{caml_call1(Stdlib_Printf[3], _h_);}catch(_o_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_l_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _k_ = caml_call1(func, 0); return _k_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_j_){
    return runtime.Base_clear_caml_backtrace_pos(_j_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_i_){return runtime.Base_caml_exn_is_most_recent_exn(_i_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_Return = "Return",
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[123], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_o_){
    var bind = _o_[1], return$0 = _o_[3];
    function map_via_bind(ma, f){
     return caml_call2
             (_o_[1],
              ma,
              function(a){
               var _p_ = caml_call1(f, a);
               return caml_call1(_o_[3], _p_);
              });
    }
    var match = _o_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _n_ = Make_general([0, bind, map, return$0]);
    return [0,
            _n_[6],
            _n_[7],
            _n_[8],
            _n_[5],
            _n_[1],
            _n_[2],
            _n_[4],
            _n_[9],
            _n_[10],
            _n_[11],
            _n_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _m_ = Make_general([0, bind, map, return$0]);
    return [0,
            _m_[6],
            _m_[7],
            _m_[8],
            _m_[5],
            _m_[1],
            _m_[2],
            _m_[4],
            _m_[9],
            _m_[10],
            _m_[11],
            _m_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _l_ = Make_general([0, bind, map, return$0]);
    return [0,
            _l_[6],
            _l_[7],
            _l_[8],
            _l_[5],
            _l_[1],
            _l_[2],
            _l_[4],
            _l_[9],
            _l_[10],
            _l_[11],
            _l_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _k_ = Make_general([0, bind, map, return$0]);
    return [0,
            _k_[6],
            _k_[7],
            _k_[5],
            _k_[1],
            _k_[2],
            _k_[4],
            _k_[9],
            _k_[10],
            _k_[11],
            _k_[12],
            _k_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _j_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _j_);
    }
    function bind(t, f){
     var
      _g_ = caml_call1(M[1], t),
      _h_ =
        caml_call2
         (Monad[1],
          _g_,
          function(a){
           var _i_ = caml_call1(f, a);
           return caml_call1(M[1], _i_);
          });
     return caml_call1(M[2], _h_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _e_ = caml_call1(M[1], t), _f_ = caml_call2(Monad[2], _e_, f);
         return caml_call1(M[2], _f_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function return$0(a){return a;}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make([0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    Ident =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax],
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$0 = Monad[5],
         map = Monad[6],
         _d_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _d_[6],
                _d_[7],
                _d_[5],
                _d_[1],
                _d_[2],
                _d_[4],
                _d_[9],
                _d_[10],
                _d_[11],
                _d_[12],
                _d_[8]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _c_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _c_[6],
                _c_[7],
                _c_[8],
                _c_[5],
                _c_[1],
                _c_[2],
                _c_[4],
                _c_[9],
                _c_[10],
                _c_[11],
                _c_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _b_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _b_[6],
                _b_[7],
                _b_[8],
                _b_[5],
                _b_[1],
                _b_[2],
                _b_[4],
                _b_[9],
                _b_[10],
                _b_[11],
                _b_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _a_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _a_[6],
                _a_[7],
                _a_[8],
                _a_[5],
                _a_[1],
                _a_[2],
                _a_[4],
                _a_[9],
                _a_[10],
                _a_[11],
                _a_[12]];
       },
       Ident];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_G_){
    var return$0 = _G_[1], symbol = _G_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _G_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     function _J_(x, xs){return [0, x, xs];}
     var _I_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_K_){
               return function(_L_){return map2(_K_, _L_, _J_);};
              },
              _I_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _H_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _H_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_z_){
    var return$0 = _z_[1], map2 = _z_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _z_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     return caml_call3
             (map2,
              caml_call3(map2, ta, tb, f),
              tc,
              function(fab, c){return caml_call1(fab, c);});
    }
    function all(ts){
     function _C_(x, xs){return [0, x, xs];}
     var _B_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_D_){
               var _E_ = caml_call1(map2, _D_);
               return function(_F_){return caml_call2(_E_, _F_, _C_);};
              },
              _B_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _A_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _A_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     return caml_call2(M[5], mf, function(f){return caml_call2(M[7], mx, f);});
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _y_ = caml_call1(F[1], a);
     return caml_call1(G[1], _y_);
    }
    function apply(tf, tx){
     var _x_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _x_, tx);
    }
    function custom_map(t, f){
     var _v_ = F[2];
     return caml_call2
             (G[2], t, function(_w_){return caml_call2(_v_, _w_, f);});
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _u_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _u_];
    }
    function apply(tf, tx){
     var
      _p_ = caml_call1(Base_Import[126], tx),
      _q_ = caml_call1(Base_Import[126], tf),
      _r_ = caml_call2(G[8], _q_, _p_),
      _s_ = caml_call1(Base_Import[124], tx),
      _t_ = caml_call1(Base_Import[124], tf);
     return [0, caml_call2(F[8], _t_, _s_), _r_];
    }
    function custom_map(t, f){
     var
      _m_ = caml_call1(Base_Import[126], t),
      _n_ = caml_call2(G[2], _m_, f),
      _o_ = caml_call1(Base_Import[124], t);
     return [0, caml_call2(F[2], _o_, f), _n_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   var
    Base_Applicative =
      [0,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _k_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _l_ = _k_[8];
        return [0,
                [0,
                 _k_[1],
                 _k_[4],
                 _k_[5],
                 _k_[6],
                 _k_[7],
                 [0, _l_[1], _l_[2], _l_[3], _l_[8]]]];
       },
       function(_h_, _g_, _f_){
        var _i_ = Make_let_syntax2(_h_, _g_, _f_)[1], _j_ = _i_[8];
        return [0,
                [0,
                 _i_[1],
                 _i_[4],
                 _i_[5],
                 _i_[6],
                 _i_[7],
                 [0, _j_[1], _j_[2], _j_[3], _j_[8]]]];
       },
       function(_c_, _b_, _a_){
        var _d_ = Make_let_syntax3(_c_, _b_, _a_)[1], _e_ = _d_[8];
        return [0,
                [0,
                 _d_[1],
                 _d_[4],
                 _d_[5],
                 _d_[6],
                 _d_[7],
                 [0, _e_[1], _e_[2], _e_[3], _e_[8]]]];
       },
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Sys0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Base_Sys0 = global_data.Base__Sys0,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[44],
    copy = Stdlib_BytesLabels[4],
    create = runtime.caml_create_bytes,
    fill = Stdlib_BytesLabels[10],
    make = Stdlib_BytesLabels[1],
    map = Stdlib_BytesLabels[17],
    mapi = Stdlib_BytesLabels[18],
    sub = Stdlib_BytesLabels[7],
    unsafe_blit = runtime.caml_blit_bytes,
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5];
   function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[48], s);}
   var
    unsafe_of_string_promise_no_mu = Stdlib_BytesLabels[49],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       fill,
       make,
       map,
       mapi,
       sub,
       unsafe_blit,
       to_string,
       of_string,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(2, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0];
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare, _a_ = [0, "_"];
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _d_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _c_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _b_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_011 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0],
    cst_Second = cst_Second$0,
    cst_First = cst_First$0;
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_007, of_s_008, sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _c_ = sexp_013[1];
      b:
      if(_c_ !== cst_First$0){
       if(_c_ !== cst_Second$0){
        if(_c_ === cst_first) break b;
        if(_c_ !== cst_second) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
     }
     var _d_ = sexp_013[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_011, sexp_013);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_011, sexp_013);
     var tag_014 = _e_[1];
     b:
     if(tag_014 !== cst_First$0){
      if(tag_014 !== cst_Second$0){
       if(tag_014 === cst_first) break b;
       if(tag_014 !== cst_second) break a;
      }
      var sexp_args_020 = _d_[2];
      if(sexp_args_020 && ! sexp_args_020[2]){
       var
        arg0_021 = sexp_args_020[1],
        res0_022 = caml_call1(of_s_008, arg0_021);
       return [1, res0_022];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_011,
               tag_014,
               sexp_013);
     }
     var sexp_args_015 = _d_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_f_007, arg0_016);
      return [0, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_011,
              tag_014,
              sexp_013);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_011, sexp_013);
   }
   function sexp_of_t(of_f_025, of_s_026, param){
    if(0 === param[0]){
     var arg0_027 = param[1], res0_028 = caml_call1(of_f_025, arg0_027);
     return [1, [0, _a_, [0, res0_028, 0]]];
    }
    var arg0_029 = param[1], res0_030 = caml_call1(of_s_026, arg0_029);
    return [1, [0, _b_, [0, res0_030, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t, t_sexp_grammar];
   runtime.caml_register_global(16, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Bytes0, Base__Import0, Base__Sys0, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import0 = global_data.Base__Import0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol_concat = Base_Import0[111],
    capitalize = Stdlib_StringLabels[27],
    compare = Stdlib_StringLabels[9];
   function copy(x){
    var _a_ = caml_call1(Base_Bytes0[15], x);
    return caml_call1(Base_Bytes0[16], _a_);
   }
   var
    escaped = Stdlib_StringLabels[24],
    lowercase = Stdlib_StringLabels[26],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[15],
    uncapitalize = Stdlib_StringLabels[28],
    unsafe_blit = runtime.caml_blit_string,
    uppercase = Stdlib_StringLabels[25];
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[6], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){return caml_call2(Stdlib_StringLabels[29], f, t);}
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol_concat,
       capitalize,
       compare,
       copy,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       unsafe_blit,
       uppercase,
       concat,
       iter];
   runtime.caml_register_global(6, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__Ppx_compare_lib, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    var n = caml_call2(Base_Import[232], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[228], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[228], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[228], a_001[4], b_002[4]) : n$1;
   }
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[141], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[141], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[141], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[138], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare, hash_fold_t, hash, sexp_of_t],
    compare$0 = T[1],
    hash_fold_t$0 = T[2],
    hash$0 = T[3],
    include = caml_call1(Base_Comparator[5], [0, T[1], T[4]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[92], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[14], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (12, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    length = Base_List0[2],
    rev_append = Base_List0[3],
    tl_exn = Base_List0[4],
    unzip = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    sort = Base_List0[19],
    stable_sort = Base_List0[20],
    rev = Base_List0[21],
    fold_right = Base_List0[22];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0]){
      var y = match[1], fst$0 = [0, y, fst];
      t$0 = t$1;
      fst = fst$0;
     }
     else{var y$0 = match[1], snd$0 = [0, y$0, snd]; t$0 = t$1; snd = snd$0;}
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0;
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _e_ = sexp_007[1];
      b:
      if(_e_ !== cst_Error$0){
       if(_e_ !== cst_Ok$0){
        if(_e_ === cst_error) break b;
        if(_e_ !== cst_ok) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
     }
     var _f_ = sexp_007[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_007);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_007);
     var tag_008 = _g_[1];
     b:
     if(tag_008 !== cst_Error$0){
      if(tag_008 !== cst_Ok$0){
       if(tag_008 === cst_error) break b;
       if(tag_008 !== cst_ok) break a;
      }
      var sexp_args_009 = _f_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _f_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(caml_call2(Base_Ppx_compare_lib[1], a_027, b_028)) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(caml_call2(Base_Ppx_compare_lib[1], a_033, b_034)) return 1;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return 0;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 0;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var
    Error = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    _c_ = [0, 0];
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _d_ = [0, caml_call1(f, 0)]; return _d_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[123], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[24], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    return caml_call2(map$0, combine_errors(l), function(param){return 0;});
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       equal,
       hash_fold_t,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(21, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[90], n, 1) : n;
             });
   }
   function sum(fold, M){
    return function(t, f){
     return caml_call3
             (fold,
              t,
              M[1],
              function(n, a){
               var _j_ = caml_call1(f, a);
               return caml_call2(M[2], n, _j_);
              });};
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[90], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _i_ = caml_call1(f, x);
                 return _i_ ? caml_call1(r, 1) : _i_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _h_ = 1 - caml_call1(f, x);
                 return _h_ ? caml_call1(r, 0) : _h_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _g_ = caml_call1(f, x);
                 return _g_ ? caml_call1(r, [0, x]) : _g_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _f_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[21], _f_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _d_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _d_, x);
       }
       var _e_ = i[1];
       runtime.caml_check_bound(array[1], _e_)[1 + _e_] = x;
       return caml_call1(Base_Import[129], i);
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function sum$0(m, t){
     var _a_ = sum(fold, m);
     return function(_b_){var _c_ = _b_; return _a_(t, _c_);};
    }
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, a, equal){
         return caml_call2(exists, t, caml_call1(equal, a));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, elt){
         return caml_call2(exists, t, caml_call1(T[1][1], elt));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       Make_gen];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[171],
    sexp_of_t = Base_Import[147];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   function compare(compare_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var
     _o_ = caml_obj_tag(t2),
     _p_ =
       250 === _o_
        ? t2[1]
        : 246 === _o_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _q_ = caml_obj_tag(t1),
     _r_ =
       250 === _q_
        ? t1[1]
        : 246 === _q_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(compare_a, _r_, _p_);
   }
   function equal(equal_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 1;
    var
     _k_ = caml_obj_tag(t2),
     _l_ =
       250 === _k_
        ? t2[1]
        : 246 === _k_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _m_ = caml_obj_tag(t1),
     _n_ =
       250 === _m_
        ? t1[1]
        : 246 === _m_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(equal_a, _n_, _l_);
   }
   var hash_fold_t = Base_Hash[13][12];
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_f_){
             var
              _g_ = caml_obj_tag(t),
              _h_ =
                250 === _g_
                 ? t[1]
                 : 246 === _g_ ? caml_call1(CamlinternalLazy[2], t) : t,
              _i_ = caml_call1(f, _h_),
              _j_ = caml_obj_tag(_i_);
             return 250 === _j_
                     ? _i_[1]
                     : 246 === _j_ ? caml_call1(CamlinternalLazy[2], _i_) : _i_;
            }];
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return [246,
                function(_c_){
                 var
                  _d_ = caml_obj_tag(t),
                  _e_ =
                    250 === _d_
                     ? t[1]
                     : 246 === _d_ ? caml_call1(CamlinternalLazy[2], t) : t;
                 return caml_call1(f, _e_);
                }];
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_unforced_lazy = "<unforced lazy>";
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[138], cst_unforced_lazy);
    var
     _a_ = caml_obj_tag(t),
     _b_ =
       250 === _a_
        ? t[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(sexp_of_a, _b_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
   runtime.caml_register_global(6, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[92], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[90], pos, len),
     _d_ = caml_call2(Base_Import[92], total_length, stop),
     _e_ = caml_call2(Base_Import[117], pos, len),
     _f_ = caml_call2(Base_Import[117], _e_, stop),
     _g_ = caml_call2(Base_Import[117], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Base__Array0, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array0 = global_data.Base__Array0;
   function of_state(_e_){return _e_;}
   var Repr = [0, of_state];
   function assign(t1, t2){
    var
     _a_ = caml_obj_tag(t1),
     _b_ =
       250 === _a_
        ? t1[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], t1) : t1,
     t1$0 = caml_call1(Repr[1], _b_),
     _c_ = caml_obj_tag(t2),
     _d_ =
       250 === _c_
        ? t2[1]
        : 246 === _c_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     t2$0 = caml_call1(Repr[1], _d_);
    caml_call5(Base_Array0[7], t2$0[1], 0, t1$0[1], 0, t1$0[1].length - 1);
    t1$0[2] = t2$0[2];
    return 0;
   }
   function make_default(default$0){return default$0;}
   function get_state(state){return state;}
   var Base_Random_repr = [0, Repr, assign, make_default, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Lazy, Base__Printf, Base__Random_repr, Base__Word_size, CamlinternalLazy, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Lazy = global_data.Base__Lazy,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _M_ = Base_Import[131];
    if(! _M_) return _M_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[123], cst_initializing_Random_with_a);
   }
   function bits(t){
    var
     _K_ = caml_obj_tag(t),
     _L_ =
       250 === _K_
        ? t[1]
        : 246 === _K_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][4], _L_);
   }
   function bool(t){
    var
     _I_ = caml_obj_tag(t),
     _J_ =
       250 === _I_
        ? t[1]
        : 246 === _I_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][11], _J_);
   }
   function int$0(t, x){
    var
     _G_ = caml_obj_tag(t),
     _H_ =
       250 === _G_
        ? t[1]
        : 246 === _G_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][5], _H_, x);
   }
   function int32(t, x){
    var
     _E_ = caml_obj_tag(t),
     _F_ =
       250 === _E_
        ? t[1]
        : 246 === _E_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][7], _F_, x);
   }
   function int64(t, x){
    var
     _C_ = caml_obj_tag(t),
     _D_ =
       250 === _C_
        ? t[1]
        : 246 === _C_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][9], _D_, x);
   }
   function nativeint(t, x){
    var
     _A_ = caml_obj_tag(t),
     _B_ =
       250 === _A_
        ? t[1]
        : 246 === _A_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][8], _B_, x);
   }
   function make(seed){
    var _z_ = caml_call1(Stdlib_Random[12][1], seed);
    return caml_call1(Base_Lazy[21], _z_);
   }
   function copy(t){
    var
     _w_ = caml_obj_tag(t),
     _x_ =
       250 === _w_
        ? t[1]
        : 246 === _w_ ? caml_call1(CamlinternalLazy[2], t) : t,
     _y_ = caml_call1(Stdlib_Random[12][3], _x_);
    return caml_call1(Base_Lazy[21], _y_);
   }
   function char$0(t){
    var _v_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _v_);
   }
   function ascii(t){
    var _u_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _u_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    var _t_ = caml_call1(Stdlib_Random[12][2], 0);
    return caml_call1(Base_Lazy[21], _t_);
   }
   var
    assign = Base_Random_repr[2],
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"];
   if(Base_Import[131]){
    var t = caml_call1(Stdlib_Random[13], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Lazy[21], t);
   }
   else
    var
     default$0 =
       [246,
        function(param){
         var _r_ = make_self_init(0, 0), _s_ = caml_obj_tag(_r_);
         return 250 === _s_
                 ? _r_[1]
                 : 246 === _s_ ? caml_call1(CamlinternalLazy[2], _r_) : _r_;
        }];
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function full_range_int32(state){
    var _o_ = bits(state) << 30;
    return bits(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[92], hi, lo);
    if(diff === Base_Int0[5]){
     var
      _i_ = Base_Int0[5],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[115], _j_, _i_);
     return caml_call2(Base_Import[90], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[7], diff));
     return caml_call2(Base_Import[90], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[101][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[101][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[101][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[101][6], int$0, lo)
       && caml_call2(Base_Import[101][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[103][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[103][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[103][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[103][6], int$0, lo)
       && caml_call2(Base_Import[103][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      scale = 9.313225746154785e-10,
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[89], r1, scale),
      _e_ = caml_call2(Base_Import[91], _d_, r2),
      result = caml_call2(Base_Import[89], _e_, scale);
     if(caml_call2(Base_Import[107][1], result, 1.))
      return caml_call2(Base_Import[89], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(caml_call2(Base_Import[107][5], lo, hi))
     raise_crossed_bounds(cst_float, lo, hi, Base_Import[84][34]);
    var _c_ = float$0(state, caml_call2(Base_Import[93], hi, lo));
    return caml_call2(Base_Import[91], lo, _c_);
   }
   var default$1 = caml_call1(Base_Random_repr[3], default$0);
   function bits$1(param){
    return bits(caml_call1(Base_Random_repr[4], default$1));
   }
   function int$2(x){
    return int$1(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int32$0(x){
    return int32(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function nativeint$0(x){
    return nativeint(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int64$0(x){
    return int64(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function float$1(x){
    return float$0(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int_incl$0(x, y){
    return int_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int32_incl$0(x, y){
    return int32_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function nativeint_incl$0(x, y){
    return nativeint_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int64_incl$0(x, y){
    return int64_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function float_range$0(x, y){
    return float_range(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function bool$0(param){
    return bool(caml_call1(Base_Random_repr[4], default$1));
   }
   function char$1(param){
    return char$0(caml_call1(Base_Random_repr[4], default$1));
   }
   function ascii$0(param){
    return ascii(caml_call1(Base_Random_repr[4], default$1));
   }
   function full_init(seed){
    var t = caml_call1(Base_Random_repr[4], default$1);
    return caml_call2(assign, t, make(seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, caml_call1(Base_Random_repr[4], default$1), s);
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$1,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(24, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    blit = Base_Array0[7],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[92], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[90], pos, i),
       _b_ = caml_call2(Base_Import[90], i, 1),
       _c_ = caml_call2(Base_Random[18][6], random_state, _b_),
       random_i = caml_call2(Base_Import[90], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var x$1 = caml_call1(f, x$0), n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(_d_ !== cst_Equal){
       c:
       if(_d_ !== cst_Greater){
        if(_d_ !== cst_Less){
         if(_d_ === cst_equal) break b;
         if(_d_ === cst_greater) break c;
         if(_d_ !== cst_less) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(_g_ !== cst_Equal){
      c:
      if(_g_ !== cst_Greater){
       if(_g_ !== cst_Less){
        if(_g_ === cst_equal) break b;
        if(_g_ === cst_greater) break c;
        if(_g_ !== cst_less) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[19],
    getenv = Base_Sys0[20],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Ppx_compare_lib, Base__Printf, Base__Random, Base__Result, Base__Sys, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_022 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Sys = global_data.Base__Sys,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    length = Base_List1[2],
    rev_append = Base_List1[3],
    tl_exn = Base_List1[4],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold_left = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    nontail_map = Base_List1[14],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    sort = Base_List1[19],
    stable_sort = Base_List1[20],
    rev = Base_List1[21],
    fold_right = Base_List1[22],
    is_empty = Base_List1[23],
    partition_map = Base_List1[24],
    invalid_argf = Base_Printf[7],
    t_of_sexp = Base_Import[175],
    sexp_of_t = Base_Import[151],
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function compare(cmp_a, a_006, b_007){
    if(caml_call2(Base_Ppx_compare_lib[1], a_006, b_007)) return 0;
    if(! a_006) return b_007 ? 1 : 0;
    var a_008 = a_006[1];
    if(! b_007) return -1;
    var b_009 = b_007[1];
    return caml_call2(cmp_a, a_008, b_009);
   }
   function sexp_of_t$0(of_a_010, param){
    if(! param) return _b_;
    var arg0_011 = param[1], res0_012 = caml_call1(of_a_010, arg0_011);
    return [1, [0, _a_, [0, res0_012, 0]]];
   }
   var
    Or_unequal_lengths = [0, compare, sexp_of_t$0],
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    cst_List_range_stride_function$0 =
      "List.range': stride function cannot change direction",
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    cst_iter2_exn = "iter2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_exists2_exn = "exists2_exn";
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function range(compare, stride, opt, _aP_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_aP_) var sth$0 = _aP_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _aR_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[9], _aR_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[125], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i = start_i$0,
     accum = 0;
    for(;;){
     var i_to_stop_order = order(i, stop_i);
     a:
     {
      b:
      {
       switch(i_to_stop_order){
         case 0:
          if(847855481 > initial_stride_order) break b; break;
         case 1:
          if(104758188 <= stop){var _aQ_ = [0, i, accum]; break a;}
          var _aQ_ = accum;
          break a;
         default: if(847855481 <= initial_stride_order) break b;
       }
       var next_i$0 = caml_call1(stride, i);
       c:
       {
        switch(order(i, next_i$0)){
          case 0:
           if(847855481 > initial_stride_order) break c; break;
          case 1:
           var _aQ_ = raise_stride_cannot_return_sam(0); break a;
          default: if(847855481 <= initial_stride_order) break c;
        }
        var accum$0 = [0, i, accum];
        i = next_i$0;
        accum = accum$0;
        continue;
       }
       var
        _aQ_ = caml_call1(Base_Import[125], cst_List_range_stride_function$0);
       break a;
      }
      var _aQ_ = accum;
     }
     return caml_call1(rev, _aQ_);
    }
   }
   function range$0(opt, _aO_, _aN_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_aO_) var sth$0 = _aO_[1], start = sth$0; else var start = 104758188;
    if(_aN_) var sth$1 = _aN_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[125], cst_List_range_stride_must_be_);
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[90], x, stride);},
             [0, start],
             [0, stop],
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[92], n$0, 1);
     t$0 = t$1;
     n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1);
       a = a$0;
       b = b$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aK_ = caml_call1(length, tail_of_b),
     _aL_ = caml_call2(Base_Import[90], shared_length, _aK_),
     _aM_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[90], shared_length, _aM_),
             _aL_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1);
       a = a$0;
       b = b$0;
       c = c$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aH_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[90], shared_length, _aH_),
     _aI_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[90], shared_length, _aI_),
     _aJ_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[90], shared_length, _aJ_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aE_){
              var _aF_ = caml_call1(iter2_ok, _aE_);
              return function(_aG_){return caml_call2(_aF_, _aG_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aB_){
              var _aC_ = caml_call1(rev_map2_ok, _aB_);
              return function(_aD_){return caml_call2(_aC_, _aD_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_ay_){
              var _az_ = caml_call1(fold2_ok, _ay_);
              return function(_aA_){return caml_call3(_az_, _aA_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_av_){
              var _aw_ = caml_call1(for_all2_ok, _av_);
              return function(_ax_){return caml_call2(_aw_, _ax_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_as_){
              var _at_ = caml_call1(exists2_ok, _as_);
              return function(_au_){return caml_call2(_at_, _au_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _ar_ = caml_call2(equal, a, b);
     if(_ar_) return _ar_;
     param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)){
      var accu$0 = [0, x, accu];
      accu = accu$0;
      param = l;
     }
     else
      param = l;
    }
   }
   function filter(t, f){return caml_call1(rev, rev_filter(t, f));}
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     param = l;
    }
   }
   var not_found = [0, Base_Import[251], [0, "List.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     param = l;
    }
   }
   var not_found$0 = [0, Base_Import[251], [0, "List.find_exn: not found"]];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[251], [0, "List.findi_exn: not found"]];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var
    not_found$2 = [0, Base_Import[251], [0, "List.find_mapi_exn: not found"]];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _aq_ = caml_call2(f, i, hd);
     if(! _aq_) return _aq_;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _ap_ = caml_call2(f, i, hd);
     if(_ap_) return _ap_;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   var to_array = Base_Array0[13];
   function to_list(t){return t;}
   var
    cst_List_last = "List.last",
    _n_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _o_ = [0, cst_src_list_ml, 1301, 13],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _m_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _k_ = [0, cst_src_list_ml, 1045, 12],
    _j_ = [0, cst_src_list_ml, 933, 4],
    _i_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _h_ = [0, cst_src_list_ml, 661, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _g_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _f_ = [0, cst_src_list_ml, 528, 11],
    cst_map2_exn = "map2_exn",
    _l_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths",
    max_non_tailcall = typeof Base_Sys[8] === "number" ? 1000 : 50;
   function count_append(l1, l2, count){
    if(! l2) return l1;
    if(! l1) return l2;
    var _al_ = l1[2], x1 = l1[1];
    if(! _al_) return [0, x1, l2];
    var _am_ = _al_[2], x2 = _al_[1];
    if(! _am_) return [0, x1, [0, x2, l2]];
    var _an_ = _am_[2], x3 = _am_[1];
    if(! _an_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _an_[2], x4 = _an_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     _ao_ =
       max_non_tailcall < count
        ? caml_call2(rev_append, caml_call1(rev, tl), l2)
        : count_append(tl, l2, caml_call2(Base_Import[90], count, 1));
    return [0, x1, [0, x2, [0, x3, [0, x4, [0, x5, _ao_]]]]];
   }
   function append(l1, l2){return count_append(l1, l2, 0);}
   function count_map(f, l, ctr){
    if(! l) return 0;
    var _ah_ = l[2], x1$0 = l[1];
    if(! _ah_){var f1$3 = caml_call1(f, x1$0); return [0, f1$3, 0];}
    var _ai_ = _ah_[2], x2$0 = _ah_[1];
    if(! _ai_){
     var f1$2 = caml_call1(f, x1$0), f2$2 = caml_call1(f, x2$0);
     return [0, f1$2, [0, f2$2, 0]];
    }
    var _aj_ = _ai_[2], x3$0 = _ai_[1];
    if(! _aj_){
     var
      f1$1 = caml_call1(f, x1$0),
      f2$1 = caml_call1(f, x2$0),
      f3$1 = caml_call1(f, x3$0);
     return [0, f1$1, [0, f2$1, [0, f3$1, 0]]];
    }
    var match$1 = _aj_[2], x4$0 = _aj_[1];
    if(! match$1){
     var
      f1$0 = caml_call1(f, x1$0),
      f2$0 = caml_call1(f, x2$0),
      f3$0 = caml_call1(f, x3$0),
      f4$0 = caml_call1(f, x4$0);
     return [0, f1$0, [0, f2$0, [0, f3$0, [0, f4$0, 0]]]];
    }
    var
     tl = match$1[2],
     x5$0 = match$1[1],
     f1 = caml_call1(f, x1$0),
     f2 = caml_call1(f, x2$0),
     f3 = caml_call1(f, x3$0),
     f4 = caml_call1(f, x4$0),
     f5 = caml_call1(f, x5$0);
    if(max_non_tailcall < ctr){
     a:
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            var bs$0 = 0, xs = tl;
            for(;;){
             if(! xs) break a;
             var _aa_ = xs[2];
             if(! _aa_) break;
             var _ab_ = _aa_[2];
             if(! _ab_) break h;
             var _ac_ = _ab_[2];
             if(! _ac_) break g;
             var _ad_ = _ac_[2];
             if(! _ad_) break f;
             var _ae_ = _ad_[2];
             if(! _ae_) break e;
             var _af_ = _ae_[2];
             if(! _af_) break d;
             var _ag_ = _af_[2];
             if(! _ag_) break c;
             var match$0 = _ag_[2];
             if(! match$0) break b;
             var
              xs$0 = match$0[2],
              x8 = match$0[1],
              x7 = _ag_[1],
              x6 = _af_[1],
              x5 = _ae_[1],
              x4 = _ad_[1],
              x3 = _ac_[1],
              x2 = _ab_[1],
              x1 = _aa_[1],
              x0 = xs[1],
              y0$0 = caml_call1(f, x0),
              y1$0 = caml_call1(f, x1),
              y2$0 = caml_call1(f, x2),
              y3$0 = caml_call1(f, x3),
              y4$0 = caml_call1(f, x4),
              y5$0 = caml_call1(f, x5),
              y6$0 = caml_call1(f, x6),
              y7$0 = caml_call1(f, x7),
              y8$0 = caml_call1(f, x8),
              bs$1 =
                [0,
                 [0, y0$0, y1$0, y2$0, y3$0, y4$0, y5$0, y6$0, y7$0, y8$0],
                 bs$0];
             bs$0 = bs$1;
             xs = xs$0;
            }
            break a;
           }
           break a;
          }
          break a;
         }
         break a;
        }
        break a;
       }
       break a;
      }
      break a;
     }
     var ys$1 = caml_call2(nontail_map, xs, f), ys = ys$1, param = bs$0;
     for(;;){
      if(! param){var _ak_ = ys; break;}
      var
       bs = param[2],
       match = param[1],
       y8 = match[9],
       y7 = match[8],
       y6 = match[7],
       y5 = match[6],
       y4 = match[5],
       y3 = match[4],
       y2 = match[3],
       y1 = match[2],
       y0 = match[1],
       ys$0 =
         [0,
          y0,
          [0,
           y1,
           [0, y2, [0, y3, [0, y4, [0, y5, [0, y6, [0, y7, [0, y8, ys]]]]]]]]];
      ys = ys$0;
      param = bs;
     }
    }
    else
     var _ak_ = count_map(f, tl, caml_call2(Base_Import[90], ctr, 1));
    return [0, f1, [0, f2, [0, f3, [0, f4, [0, f5, _ak_]]]]];
   }
   function map(l, f){return count_map(f, l, 0);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    return caml_call1(rev, caml_call3(rev_map2_ok, l1, l2, f));
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(___){
              return function(_$_){return map2_ok(___, _$_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac];
       l1$0 = l1$1;
       l2$0 = l2$1;
       l3$0 = l3$1;
       ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_X_){
              return function(_Y_){
               return function(_Z_){return rev_map3_ok(_X_, _Y_, _Z_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    return caml_call1(rev, rev_map3_ok(l1, l2, l3, f));
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_U_){
              return function(_V_){
               return function(_W_){return map3_ok(_U_, _V_, _W_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], h = l1$0[1], l2$1 = [0, caml_call1(f, h), l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
     l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _S_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _S_;
    }
    catch(_T_){
     var _R_ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _g_, caml_call1(length, l1), _R_, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     acc = acc$0;
     param = t;
    }
   }
   function mapi(l, f){return caml_call1(rev, rev_mapi(l, f));}
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold_left,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[90], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _P_ =
       caml_call3
        (fold_left,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _Q_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[90], i, 1), _Q_];
         });
    return caml_call1(Base_Import[126], _P_);
   }
   function filteri(l, f){
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(pos, acc, x){
                return caml_call2(f, pos, x) ? [0, x, acc] : acc;
               }));
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold_left, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[125], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[115], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[114], num$0, 1);
      num$0 = num$1;
      acc$0 = acc$1;
      x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold_left, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[125], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var
     groups =
       foldi
        (l,
         0,
         function(i, acc, x){
          if(! acc) return [0, [0, x, 0], 0];
          var tl = acc[2], current_group = acc[1];
          return caml_call3(break$0, i, caml_call1(hd_exn, current_group), x)
                  ? [0, [0, x, 0], [0, current_group, tl]]
                  : [0, [0, x, current_group], tl];
         });
    return groups ? caml_call2(rev_map, groups, rev) : 0;
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function sort_and_group(l, compare){
    return group
            (caml_call2(stable_sort, l, compare),
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function concat_map(l, f){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call1(f, hd), acc);
     acc = acc$0;
     param = tl;
    }
   }
   function concat_mapi(l, f){
    var cont = 0, acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call2(f, cont, hd), acc),
      cont$0 = caml_call2(Base_Import[90], cont, 1);
     cont = cont$0;
     acc = acc$0;
     param = tl;
    }
   }
   function merge(l1, l2, compare){
    var acc = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return caml_call2(rev_append, acc, l2$0);
     if(! l2$0) return caml_call2(rev_append, acc, l1$0);
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var acc$0 = [0, h2, acc];
      acc = acc$0;
      l2$0 = t2;
     }
     else{var acc$1 = [0, h1, acc]; acc = acc$1; l1$0 = t1;}
    }
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function return$0(x){return [0, x, 0];}
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[11], [0, return$0, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, return$0, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, return$0, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[125], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _O_ = caml_call2(equal, hd, hd$0);
     if(! _O_) return _O_;
     list$0 = list$1;
     prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     a1$0 = a2;
     t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep)){
      var to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep;
      to_keep = to_keep$1;
      param = tl;
     }
     else{
      var accum$0 = [0, to_keep, accum];
      to_keep = to_keep$0;
      accum = accum$0;
      param = tl;
     }
    }
   }
   function dedup_and_sort(list, compare){
    if(list && list[2]){
     var
      equal =
        function(x$0, x){return 0 === caml_call2(compare, x$0, x) ? 1 : 0;},
      sorted = caml_call2(sort, list, compare);
     return remove_consecutive_duplicates(0, sorted, equal);
    }
    return list;
   }
   function find_a_dup(l, compare){
    var sorted = caml_call2(sort, l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    function compare$0(a, b){
     var _N_ = caml_call2(compare, a, b);
     return caml_call2(Base_Import[87], -1, _N_);
    }
    var sorted = caml_call2(sort, l, compare$0);
    if(! sorted) return 0;
    var
     sorted$2 = sorted[2],
     prev$1 = sorted[1],
     sorted$0 = sorted$2,
     prev = prev$1,
     already_recorded = 0,
     acc = 0;
    for(;;){
     if(! sorted$0) return acc;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === compare$0(prev, prev$0))
      if(already_recorded){
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
      }
      else{
       var acc$0 = [0, prev$0, acc];
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
       acc = acc$0;
      }
     else{sorted$0 = sorted$1; prev = prev$0; already_recorded = 0;}
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _L_ = caml_call2(equal, x, x$0);
      if(_L_){t = xs; continue;}
      var _M_ = _L_;
     }
     else
      var _M_ = 1;
     return _M_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){
    return caml_call3(Base_Container[2], fold_left, t, f);
   }
   function sum(m, t, f){
    return caml_call4(Base_Container[7], fold_left, m, t, f);
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold_left, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold_left, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _i_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[92], i, 1)), accum],
      i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var x = match[1], accum$0 = [0, x, accum];
      l$0 = tl;
      accum = accum$0;
     }
     else
      l$0 = tl;
    }
   }
   function filter_map(l, f){return caml_call1(rev, rev_filter_map(l, f));}
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match){
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      l$0 = tl;
      accum = accum$0;
     }
     else{var i$1 = caml_call2(Base_Import[90], i, 1); i = i$1; l$0 = tl;}
    }
   }
   function filter_mapi(l, f){return caml_call1(rev, rev_filter_mapi(l, f));}
   function filter_opt(l){return filter_map(l, function(_K_){return _K_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _I_ = caml_call1(rev, trd), _J_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _J_, _I_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _H_ = match[1];
     if(4152137 === _H_){
      var y = match[2], snd$0 = [0, y, snd];
      t$0 = t$1;
      snd = snd$0;
     }
     else if(4202758 <= _H_){
      var y$0 = match[2], trd$0 = [0, y$0, trd];
      t$0 = t$1;
      trd = trd$0;
     }
     else{var y$1 = match[2], fst$0 = [0, y$1, fst]; t$0 = t$1; fst = fst$0;}
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[35]);
   }
   function t_of_sexp$0(of_a_014, of_b_015, x_023){
    return caml_call2
            (Base_Import[175],
             function(sexp_021){
              if(1 === sexp_021[0]){
               var _F_ = sexp_021[1];
               if(_F_){
                var _G_ = _F_[2];
                if(_G_ && ! _G_[2]){
                 var
                  arg1_018 = _G_[1],
                  arg0_017 = _F_[1],
                  res0_019 = caml_call1(of_a_014, arg0_017),
                  res1_020 = caml_call1(of_b_015, arg1_018);
                 return [0, res0_019, res1_020];
                }
               }
              }
              return caml_call3
                      (Sexplib0_Sexp_conv_error[2], error_source_022, 2, sexp_021);
             },
             x_023);
   }
   function sexp_of_t$1(of_a_024, of_b_025, x_030){
    return caml_call2
            (Base_Import[151],
             function(param){
              var
               arg1_027 = param[2],
               arg0_026 = param[1],
               res0_028 = caml_call1(of_a_024, arg0_026),
               res1_029 = caml_call1(of_b_025, arg1_027);
              return [1, [0, res0_028, [0, res1_029, 0]]];
             },
             x_030);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    return caml_call1
            (Base_Import[194],
             [2, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]);
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[126])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _E_){
                var y = _E_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _D_){
                var y = _D_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[126], x)];
   }
   var not_found$3 = [0, Base_Import[251], _l_];
   function find_exn$0(t, equal, key){
    var match = find$0(t, equal, key);
    if(! match) throw caml_maybe_attach_backtrace(not_found$3, 1);
    var value = match[1];
    return value;
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _z_ = pos < 0 ? 1 : 0;
    if(_z_)
     var _A_ = _z_;
    else{
     var _B_ = len < 0 ? 1 : 0;
     if(_B_)
      var _A_ = _B_;
     else
      var
       _C_ = caml_call1(length, l),
       _A_ = caml_call2(Base_Import[92], _C_, len) < pos ? 1 : 0;
    }
    if(_A_) caml_call1(Base_Import[125], cst_List_sub);
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(i, acc, el){
                if(pos <= i && i < caml_call2(Base_Import[90], pos, len))
                 return [0, el, acc];
                return acc;
               }));
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     if(! t) return [0, t_orig, 0];
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return caml_call1(rev, accum);
     if(! t) return t_orig;
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[92], n$0, 1);
       t$0 = tl;
       n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _m_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc];
     acc = acc$0;
     l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[123], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1, accum = 0;
    for(;;){
     if(! l1) return caml_call1(rev, accum);
     var tl = l1[2], hd = l1[1];
     let hd$0 = hd;
     var
      accum$0 =
        caml_call2
         (rev_append, map(list2, function(x){return [0, hd$0, x];}), accum);
     l1 = tl;
     accum = accum$0;
    }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold_left,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _y_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _y_) return _y_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _x_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _x_) return _x_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(list){
     var _w_ = list[2];
     if(_w_){
      if(_w_[2]){
       var arr = caml_call1(Base_Array0[13], list);
       caml_call4(Base_Array_permute[24], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[15], arr);
      }
      var y = _w_[1], x = list[1];
      return caml_call1(Base_Random[18][16], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[123], cst_List_random_element_exn_em);
    var _v_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[18][6], random_state, _v_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{
     var _t_ = [0, random_element_exn([0, random_state], list)];
     return _t_;
    }
    catch(_u_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     a$0 = xs;
     b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _s_ = caml_call2(equal, x1, x2);
       if(! _s_) return _s_;
       t1$0 = t1$1;
       t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match){
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc];
       t = tl;
       column_acc = column_acc$0;
       trimmed_rows = trimmed;
      }
      else{var tl$0 = t[2]; t = tl$0; found_empty = 1;}
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns];
     rows = trimmed_rows;
     columns = columns$0;
     do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Transpose_got_lists_of_differe,
     function(param){
      if(param[1] !== Transpose_got_lists_of_differe)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
      var
       arg0_031 = param[2],
       res0_032 = caml_call2(Base_Import[151], Base_Import[141], arg0_031);
      return [1, [0, _n_, [0, res0_032, 0]]];
     });
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1];
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              0)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold_left, init, f, t);
   }
   function fold_until(t, init, f){
    var _q_ = caml_call3(Base_Container[9], fold_left, init, f);
    return function(_r_){return caml_call2(_q_, _r_, t);};
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _p_ = suffix_len <= list_len ? 1 : 0;
    return _p_
            ? equal
              (equal_elt,
               drop(list, caml_call2(Base_Import[92], list_len, suffix_len)),
               suffix)
            : _p_;
   }
   var
    Base_List =
      [0,
       compare$0,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold_left,
       fold_result,
       fold_until,
       exists,
       for_all,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        return$0,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, return$0, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       Or_unequal_lengths,
       of_list,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       concat_map,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold_left,
       unzip,
       unzip3,
       zip,
       zip_exn,
       mapi,
       rev_mapi,
       iteri,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count,
       counti,
       range$0,
       range,
       init,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(54, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Assert_failure, Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__Lazy, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ": ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "",
    cst$3 = "; ",
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Lazy = global_data.Base__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_could_not_construct_info = "could not construct info: ",
    _j_ =
      [0,
       [11, "and ", [4, 0, 0, 0, [11, " more info", 0]]],
       "and %d more info"],
    cst_Backtrace = "\nBacktrace:\n";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[4], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[138], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[198], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[4], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[138], arg0_009),
        res1_013 = caml_call1(Base_Sexp[4], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[148], Base_Source_code_position0[8], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[138], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[138], arg0_019),
        res1_023 = caml_call1(Base_Sexp[4], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[148], Base_Import[141], arg0_025),
        res1_028 = caml_call2(Base_Import[151], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[138], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_strings_hum(t, ac){
    var t$0 = t, ac$0 = ac;
    for(;;)
     switch(t$0[0]){
       case 0:
        var sexp = t$0[1];
        return [0,
                cst_could_not_construct_info,
                [0, caml_call1(Base_Sexp[16], sexp), ac$0]];
       case 1:
        var string = t$0[1]; return [0, string, ac$0];
       case 2:
        var exn = t$0[1], _P_ = caml_call1(Base_Exn[1], exn);
        return [0, caml_call1(Base_Sexp[16], _P_), ac$0];
       case 3:
        var sexp$0 = t$0[1];
        return [0, caml_call1(Base_Sexp[16], sexp$0), ac$0];
       case 4:
        var sexp$1 = t$0[2], tag = t$0[1];
        return [0,
                tag,
                [0, cst, [0, caml_call1(Base_Sexp[16], sexp$1), ac$0]]];
       case 5:
        var t$1 = t$0[2], tag$0 = t$0[1];
        return [0, tag$0, [0, cst$0, to_strings_hum(t$1, ac$0)]];
       case 6:
        var
         t$2 = t$0[3],
         sexp$2 = t$0[2],
         tag$1 = t$0[1],
         _Q_ = [0, cst$1, to_strings_hum(t$2, ac$0)],
         body = [0, caml_call1(Base_Sexp[16], sexp$2), _Q_];
        return 0 === caml_ml_string_length(tag$1)
                ? body
                : [0, tag$1, [0, cst$2, body]];
       case 7:
        var ts = t$0[2], trunc_after = t$0[1];
        if(trunc_after){
         var max = trunc_after[1], n = caml_call1(Base_List[7], ts);
         if(n <= max)
          var ts$0 = ts;
         else
          var
           _S_ = caml_call2(Base_Import[92], n, max),
           _T_ = [0, [1, caml_call2(Base_Printf[2], _j_, _S_)], 0],
           _U_ = caml_call2(Base_List[131], ts, max),
           ts$0 = caml_call2(Base_Import[110], _U_, _T_);
         var ts$1 = ts$0;
        }
        else
         var ts$1 = ts;
        var _R_ = caml_call1(Base_List[38], ts$1);
        return caml_call3
                (Base_List[10],
                 _R_,
                 ac$0,
                 function(ac, t){
                  var
                   ac$0 = caml_call1(Base_List[8], ac) ? ac : [0, cst$3, ac];
                  return to_strings_hum(t, ac$0);
                 });
       default:
        var
         backtrace = t$0[2],
         t$3 = t$0[1],
         ac$1 = [0, cst_Backtrace, [0, backtrace, ac$0]];
        t$0 = t$3;
        ac$0 = ac$1;
     }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _N_ = [0, caml_call1(Base_Source_code_position0[8], here$0), 0];
       else
        var _N_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _N_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var ts = t[2], _O_ = caml_call1(Base_List[38], ts);
       return caml_call3
               (Base_List[10],
                _O_,
                ac,
                function(ac, t){return to_sexps_hum(t, ac);});
      default:
       var backtrace = t[2], t$2 = t[1];
       return [0, [1, [0, to_sexp_hum(t$2), [0, [0, backtrace], 0]]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function protect(f){
    try{var _M_ = caml_call1(f, 0); return _M_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, caml_call1(Base_Exn[1], exn)];
    }
   }
   function to_message(info){
    return protect
            (function(param){
              var _L_ = caml_obj_tag(info);
              return 250 === _L_
                      ? info[1]
                      : 246 === _L_ ? caml_call1(CamlinternalLazy[2], info) : info;
             });
   }
   function of_message(t){return [250, t];}
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return [246, function(_K_){return [3, sexp];}];}
   function compare(t1, t2){
    var _I_ = sexp_of_t$0(t2), _J_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _J_, _I_);
   }
   function equal(t1, t2){
    var _G_ = sexp_of_t$0(t2), _H_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[5], _H_, _G_);
   }
   function hash_fold_t(state, t){
    var _F_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[1], state, _F_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _E_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[15], 0, _E_);
   }
   function to_string_hum_deprecated(t){
    var t$0 = to_message(t), _D_ = to_strings_hum(t$0, 0);
    return caml_call2(Base_String0[14], 0, _D_);
   }
   function to_string_mach(t){
    var _C_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[16], _C_);
   }
   function of_lazy(l){
    return [246,
            function(_z_){
             return protect
                     (function(param){
                       var
                        _A_ = caml_obj_tag(l),
                        _B_ =
                          250 === _A_
                           ? l[1]
                           : 246 === _A_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [1, _B_];
                      });
            }];
   }
   function of_lazy_sexp(l){
    return [246,
            function(_w_){
             return protect
                     (function(param){
                       var
                        _x_ = caml_obj_tag(l),
                        _y_ =
                          250 === _x_
                           ? l[1]
                           : 246 === _x_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [3, _y_];
                      });
            }];
   }
   function of_lazy_t(lazy_t){return caml_call1(Base_Lazy[13], lazy_t);}
   function of_string(message){
    return caml_call1(Base_Lazy[21], [1, message]);
   }
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return [246,
            function(_v_){
             return protect(function(param){return [1, caml_call1(f, 0)];});
            }];
   }
   function create(here, strict, tag, x, sexp_of_x){
    if(! strict)
     return [246,
             function(_u_){
              return protect
                      (function(param){
                        return [4, tag, caml_call1(sexp_of_x, x), here];
                       });
             }];
    var t = [4, tag, caml_call1(sexp_of_x, x), here];
    return [250, t];
   }
   function create_s(sexp){return caml_call1(Base_Lazy[21], [3, sexp]);}
   function tag(t, tag){
    return [246, function(param){return [5, tag, to_message(t)];}];
   }
   function tag_s_lazy(t, tag){
    return [246,
            function(_q_){
             return protect
                     (function(param){
                       var
                        _r_ = to_message(t),
                        _s_ = caml_obj_tag(tag),
                        _t_ =
                          250 === _s_
                           ? tag[1]
                           : 246 === _s_ ? caml_call1(CamlinternalLazy[2], tag) : tag;
                       return [6, cst$4, _t_, _r_];
                      });
            }];
   }
   function tag_s(t, tag){
    return tag_s_lazy(t, caml_call1(Base_Lazy[21], tag));
   }
   function tag_arg(t, tag, x, sexp_of_x){
    return [246,
            function(_o_){
             return protect
                     (function(param){
                       var _p_ = to_message(t);
                       return [6, tag, caml_call1(sexp_of_x, x), _p_];
                      });
            }];
   }
   function of_list(trunc_after, ts){
    return [246,
            function(param){
             return [7,
                     trunc_after,
                     caml_call2(Base_List[76], ts, to_message)];
            }];
   }
   var
    Exn = [248, "Base__Info.Exn", runtime.caml_fresh_oo_id(0)],
    _k_ = [0, "src/info.ml", 204, 6];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Exn,
     function(param){
      if(param[1] !== Exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
      var t = param[2];
      return sexp_of_t$0(t);
     });
   function to_exn(t){
    if(! caml_call1(Base_Lazy[22], t)) return [0, Exn, t];
    var
     _n_ = caml_obj_tag(t),
     match =
       250 === _n_
        ? t[1]
        : 246 === _n_ ? caml_call1(CamlinternalLazy[2], t) : t;
    if(2 !== match[0]) return [0, Exn, t];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _m_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _m_ = [0, s];
     var backtrace$0 = _m_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return [246, function(param){return [8, to_message(t), backtrace$1];}];
    }
    if(! backtrace$0) return caml_call1(Base_Lazy[21], [2, exn]);
    var backtrace$2 = backtrace$0[1];
    return [246,
            function(param){
             return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
            }];
   }
   function pp(ppf, t){
    var _l_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _l_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(37, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    equal = Base_Info[2],
    hash_fold_t = Base_Info[3],
    hash = Base_Info[4],
    t_of_sexp = Base_Info[5],
    sexp_of_t = Base_Info[6],
    invariant = Base_Info[8],
    to_string_hum = Base_Info[9],
    to_string_mach = Base_Info[10],
    to_string_hum_deprecated = Base_Info[11],
    of_string = Base_Info[12],
    of_lazy = Base_Info[13],
    of_lazy_sexp = Base_Info[14],
    of_thunk = Base_Info[15],
    of_lazy_t = Base_Info[16],
    create = Base_Info[17],
    create_s = Base_Info[18],
    createf = Base_Info[19],
    tag = Base_Info[20],
    tag_s = Base_Info[21],
    tag_s_lazy = Base_Info[22],
    tag_arg = Base_Info[23],
    of_list = Base_Info[24],
    of_exn = Base_Info[25],
    to_exn = Base_Info[26],
    pp = Base_Info[27],
    Internal_repr = Base_Info[28];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed",
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[198], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[8], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[198], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[138], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    ignore_m = Base_Result[14],
    join = Base_Result[13],
    return$0 = Base_Result[12],
    bind = Base_Result[11],
    symbol_bind = Base_Result[7];
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[6], hash_fold_a, Base_Error[3], hsv, arg);
   }
   function t_of_sexp(of_a_013, x_015){
    return caml_call3(Base_Result[1], of_a_013, Base_Error[5], x_015);
   }
   function sexp_of_t(of_a_016, x_017){
    return caml_call3(Base_Result[2], of_a_016, Base_Error[6], x_017);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[7]);
   }
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[8], error);
   }
   function apply(f, x){
    return caml_call4
            (Base_Result[32],
             f,
             x,
             function(f, x){return caml_call1(f, x);},
             function(e1, e2){
              return caml_call2(Base_Error[24], 0, [0, e1, [0, e2, 0]]);
             });
   }
   var
    map = [0, -198771759, Base_Result[30]],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    include$0 = Base_Result[10],
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Open_on_rhs = [0],
    ok = Base_Result[23],
    is_ok = Base_Result[21],
    is_error = Base_Result[22],
    _a_ = [0, 3553398],
    cst_unimplemented = "unimplemented",
    _b_ = [0, "src/or_error.ml", 135, 22];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _n_ = [0, caml_call1(f, 0)]; return _n_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _m_ = backtrace ? _a_ : 0;
     return [1, caml_call2(Base_Error[25], _m_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[29], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[25], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[17], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[18], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[12], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _k_ = Base_Error[20];
    return caml_call2
            (Base_Result[31],
             t,
             function(_l_){return caml_call2(_k_, _l_, tag);});
   }
   function tag_s(t, tag){
    var _i_ = Base_Error[21];
    return caml_call2
            (Base_Result[31],
             t,
             function(_j_){return caml_call2(_i_, _j_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _g_ = Base_Error[22];
    return caml_call2
            (Base_Result[31],
             t,
             function(_h_){return caml_call2(_g_, _h_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Base_Result[31],
             t,
             function(e){
              return caml_call4(Base_Error[23], e, message, a, sexp_of_a);
             });
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[138]);
   }
   function combine_errors(l){
    var arg = Base_Error[24], _f_ = caml_call1(Base_Result[33], l);
    return caml_call2
            (Base_Result[31],
             _f_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function combine_errors_unit(l){
    var _e_ = combine_errors(l);
    return caml_call2(Base_Result[30], _e_, function(param){return 0;});
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[57], l, Base_Result[35]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call2(Base_Error[24], 0, errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[17], l, Base_Result[23]);
    if(match){var x = match[1]; return [0, x];}
    var
     _d_ =
       caml_call2
        (Base_List[76],
         l,
         function(param){
          if(0 === param[0])
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          var err = param[1];
          return err;
         });
    return [1, caml_call2(Base_Error[24], 0, _d_)];
   }
   function find_map_ok(l, f){
    return caml_call1
            (Base_With_return[1],
             function(param){
              var
               _c_ =
                 caml_call2
                  (Base_List[76],
                   l,
                   function(elt){
                    var x = caml_call1(f, elt);
                    if(0 === x[0]) return caml_call1(param, x);
                    var err = x[1];
                    return err;
                   });
              return [1, caml_call2(Base_Error[24], 0, _c_)];
             });
   }
   var
    map$1 = Base_Result[30],
    iter = Base_Result[28],
    iter_error = Base_Result[29],
    Base_Or_error =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[10],
       bind,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(_e_ !== cst_Neg){
       c:
       if(_e_ !== cst_Pos){
        if(_e_ !== cst_Zero){
         if(_e_ === cst_neg) break b;
         if(_e_ === cst_pos) break c;
         if(_e_ !== cst_zero) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(_h_ !== cst_Neg){
      c:
      if(_h_ !== cst_Pos){
       if(_h_ !== cst_Zero){
        if(_h_ === cst_neg) break b;
        if(_h_ === cst_pos) break c;
        if(_h_ !== cst_zero) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Assert_failure, Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    _a_ = [0, cst_src_comparable_ml, 47, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 133, 4],
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1;
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Polymorphic_compare(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Polymorphic_compare([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _r_ = caml_call2(symbol$0, low, t);
     return _r_ ? caml_call2(symbol$0, t, high) : _r_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _o_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _p_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _o_],
      _q_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max$0, _p_);
     return caml_call1(Base_Or_error[35], _q_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[5], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _m_ = caml_call1(T[2], t), _n_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _n_, _m_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _l_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _l_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       equal,
       max,
       min,
       Infix,
       Polymorphic_compare,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _j_ = caml_lessequal(low, t),
          _k_ = _j_ ? caml_lessequal(t, high) : _j_;
         return _k_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _g_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _h_ = [0, [0, cst_min, caml_call1(T[1], min)], _g_],
          _i_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _h_);
         return caml_call1(Base_Or_error[35], _i_);
        }
        var
         include =
           caml_call1(Base_Comparator[5], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       function(_c_){
        var _d_ = _c_[3], _e_ = _c_[1];
        function is_positive(t){return 0 < caml_call2(_e_, t, _d_) ? 1 : 0;}
        function is_non_negative(t){
         return 0 <= caml_call2(_e_, t, _d_) ? 1 : 0;
        }
        function is_negative(t){return caml_call2(_e_, t, _d_) < 0 ? 1 : 0;}
        function is_non_positive(t){
         return caml_call2(_e_, t, _d_) <= 0 ? 1 : 0;
        }
        function sign(t){
         var _f_ = caml_call2(_e_, t, _d_);
         return caml_call1(Base_Sign0[13], _f_);
        }
        return [0,
                is_positive,
                is_non_negative,
                is_negative,
                is_non_positive,
                sign];
       }];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels;
   function equal(a, b){
    var _b_ = caml_call2(Base_Import[127], a, b);
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = caml_call2(Base_Import[127], a[1], b[1]);
     if(_d_){
      var _e_ = caml_call2(Base_Import[127], a[2], b[2]);
      if(_e_) return caml_call2(Base_Import[127], a[3], b[3]);
      var _c_ = _e_;
     }
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Stdlib_MoreLabels[1][30],
    hash = Stdlib_MoreLabels[1][28],
    _a_ = [0, "_"],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(3, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[10], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _a_ = caml_call1(Base_Comparable[11], [0, T[5], T[9]]),
         symbol = _a_[1],
         symbol$0 = _a_[2],
         symbol$1 = _a_[3],
         symbol$2 = _a_[4],
         symbol$3 = _a_[5],
         symbol$4 = _a_[6],
         equal = _a_[7],
         compare = _a_[8],
         min = _a_[9],
         max = _a_[10],
         ascending = _a_[11],
         descending = _a_[12],
         between = _a_[13],
         clamp_exn = _a_[14],
         clamp = _a_[15],
         comparator = _a_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       }];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    hash_fold_t = Base_Import[210],
    func = Base_Import[224];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[180],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function compare(param, _a_){return 0;}
   function of_string(param){
    return param !== cst$0
            ? caml_call1(Base_Import[123], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Or_error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Or_error = global_data.Base__Or_error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return caml_call1(Base_Or_error[36], s);
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Fn, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Fn = global_data.Base__Fn;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[90], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[92], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[92], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[92], hi, lo$1),
      _d_ = caml_call2(Base_Import[94], _c_, 2),
      mid = caml_call2(Base_Import[90], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      hi = mid;
     else{var lo$2 = caml_call2(Base_Import[90], mid, 1); lo$1 = lo$2;}
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[90], lo, 1);
     lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0], [0, len$0], t, get, length, caml_call1(Base_Fn[2], pred));
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[92], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[90], pos$0, len$0);
    return [0, caml_call2(Base_Import[92], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(3, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       function(T){
        var get = T[1], length = T[2], _a_ = Make_gen([0, get, length]);
        return [0, _a_[3], _a_[4]];
       }];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Bytes0, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _n_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _n_);
     var _o_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _o_);
     var _p_ = 0 < len ? 1 : 0;
     return _p_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _p_;
    }
    function blito(src, opt, _l_, dst, _k_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_l_)
      var sth$0 = _l_[1], src_len = sth$0;
     else
      var
       _m_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[92], _m_, src_pos);
     if(_k_) var sth$1 = _k_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _j_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _j_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _i_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[92], _i_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     var _h_ = caml_call3(To_bytes[4], src, pos, len);
     return caml_call1(Base_Bytes0[16], _h_);
    }
    function subo(pos, len, src){
     var _g_ = caml_call3(To_bytes[5], pos, len, src);
     return caml_call1(Base_Bytes0[16], _g_);
    }
    return [0, sub, subo];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       function(Src, Dst){
        var length = Dst[1];
        function create_like(len, param){return caml_call1(Dst[2], len);}
        var
         unsafe_blit = Dst[3],
         length$0 = Src[1],
         _f_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
        return [0, _f_[2], _f_[3], _f_[1], _f_[4], _f_[5]];
       },
       Make_to_string,
       function(_c_){
        var
         _d_ = [0, _c_[2], _c_[1], _c_[3]],
         _e_ = Make_gen([0, _d_[1]], _d_);
        return [0, _e_[2], _e_[3], _e_[1], _e_[4], _e_[5]];
       },
       function(_a_){
        var _b_ = Make_gen([0, _a_[2]], [0, _a_[2], _a_[1], _a_[3]]);
        return [0, _b_[2], _b_[3], _b_[1], _b_[4], _b_[5]];
       }];
   runtime.caml_register_global(3, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Container, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Container = global_data.Base__Container,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare = Base_Import[236],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[172],
    sexp_of_t = Base_Import[148],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _g_ =
         caml_call2
          (Base_Import[149], Base_Error[6], Base_Source_code_position0[8]),
       _h_ = value(message, cst),
       _i_ = caml_call5(Base_Error[17], 0, 0, _h_, [0, e, p], _g_);
     else if(message)
      var
       m = message[1],
       _i_ =
         caml_call5(Base_Error[17], 0, 0, m, p, Base_Source_code_position0[8]);
     else
      var
       _i_ =
         caml_call5
          (Base_Error[17],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[8]);
     var error$0 = _i_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _j_ = caml_call2(Base_Error[20], e$0, m$0);
     else
      var _j_ = e$0;
     var error$0 = _j_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[12], m$1);
    else
     var error$0 = caml_call1(Base_Error[12], cst_Option_value_exn_None);
    return caml_call1(Base_Error[29], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function min_elt(t, param){return t;}
   function max_elt(t, param){return t;}
   function sum(M){return function(t, f){return value_map(t, M[1], f);};}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function count(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a) ? 1 : 0;
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_f_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_e_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function apply(f, x){if(! f) return 0; var f$0 = f[1]; return _a_(x, f$0);}
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    _b_ = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = _b_[1],
    Monad_infix = _b_[3],
    bind$0 = _b_[4],
    join = _b_[7],
    ignore_m = _b_[8],
    Let_syntax = _b_[11],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _c_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_d_){return caml_call2(_c_, _d_, t);};
   }
   var
    Base_Option =
      [0,
       compare,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result,
       fold_until,
       min_elt,
       max_elt,
       count,
       sum];
   runtime.caml_register_global(9, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[158], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    return [0, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(2, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__Option, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_Option = global_data.Base__Option,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare = Base_Either0[1],
    hash_fold_t = Base_Either0[2],
    t_of_sexp = Base_Either0[3],
    sexp_of_t = Base_Either0[4],
    t_sexp_grammar = Base_Either0[5];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     either = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         return caml_call2
                 (bind,
                  t,
                  function(x){return caml_call1(return$0, caml_call1(f, x));});
        }],
     include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9];
    function apply(t1, t2){
     return caml_call2
             (bind$0,
              t1,
              function(f){
               return caml_call2
                       (bind$0,
                        t2,
                        function(x){return caml_call1(return$1, caml_call1(f, x));});
              });
    }
    var
     map$0 = [0, -198771759, include[7]],
     App = caml_call1(Base_Applicative[6], [0, return$1, apply, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply$0 = App[8],
     map2 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function other_loop(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return other_loop(f, acc, ts);},
              function(o){return other_loop(f, caml_call2(f, acc, o), ts);});
    }
    function return_loop(f, acc, param){
     if(! param) return caml_call1(return$2, caml_call1(Base_List0[21], acc));
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(x){return return_loop(f, [0, x, acc], ts);},
              function(o){return other_loop(f, o, ts);});
    }
    function combine_all(ts, f){return return_loop(f, 0, ts);}
    function other_loop$0(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return other_loop$0(f, acc, ts);},
              function(o){return other_loop$0(f, caml_call2(f, acc, o), ts);});
    }
    function return_loop$0(f, param){
     if(! param) return caml_call1(return$2, 0);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return return_loop$0(f, ts);},
              function(o){return other_loop$0(f, o, ts);});
    }
    function combine_all_unit(ts, f){return return_loop$0(f, ts);}
    function to_option(t){
     return caml_call3(either, t, Base_Option[46], function(param){return 0;});
    }
    function value(t, default$0){
     return caml_call3
             (either,
              t,
              function(_a_){return _a_;},
              function(param){return default$0;});
    }
    function with_return(f){
     return caml_call1
             (Base_With_return[1],
              function(ret){
               return caml_call1
                       (other,
                        caml_call1
                         (f, caml_call2(Base_With_return[3], ret, return$2)));
              });
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function either(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(return$0, x);}
    var y = t[1];
    return caml_call1(other, y);
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, either, combine, bind]);
   function either$0(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(other, x);}
    var y = t[1];
    return caml_call1(return$0, y);
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, either$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(6, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Container, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Container = global_data.Base__Container,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold, t, 0, function(i, x){caml_call2(f, i, x); return i + 1 | 0;});
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = i[1] + 1 | 0;
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){return caml_call2(f, i, a) ? n + 1 | 0 : n;});
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _c_ = caml_call2(f, i, x);
                 return _c_ ? caml_call1(r, 1) : _c_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _b_ = 1 - caml_call2(f, i, x);
                 return _b_ ? caml_call1(r, 0) : _b_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _a_ = caml_call2(f, i, x);
                 return _a_ ? caml_call1(r, [0, [0, i, x]]) : _a_;
                });
              return 0;
             });
   }
   function Make_gen(T){
    var
     include = caml_call1(Base_Container[18], [0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     iter = include[3],
     fold = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         C = caml_call1(Base_Container[16], [0, T[1], T[2], T[3]]),
         mem = C[1],
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       function(T){
        var
         C = caml_call1(Base_Container[17], [0, T[1], T[2], T[3], T[4]]),
         mem = C[1],
         fold = T[2],
         iter = T[3],
         length = T[4],
         iteri = T[5],
         foldi = T[6],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       Make_gen];
   runtime.caml_register_global
    (2, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Result, Base__With_return, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_025 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_With_return = global_data.Base__With_return,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, "Done"],
    _b_ = [0, "Skip"],
    _c_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var arg0_003 = param[1], res0_004 = caml_call1(of_s_002, arg0_003);
     return [1, [0, _b_, [0, res0_004, 0]]];
    }
    var
     arg1_006 = param[2],
     arg0_005 = param[1],
     res0_007 = caml_call1(of_a_001, arg0_005),
     res1_008 = caml_call1(of_s_002, arg1_006);
    return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
   }
   var Step = [0, sexp_of_t];
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_K_){return loop(s$0, next, finish, f, _K_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_J_){return loop(s$1, next, finish, f, _J_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   var
    Expert = [0, next_step, delayed_fold_step],
    _e_ = [0, 0, 0],
    _f_ = [0, "src/sequence.ml", 259, 14];
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    function f$0(s){
     var match = caml_call1(f, s);
     if(! match) return 0;
     var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
     return [1, a, s$0];
    }
    return [0, init, f$0];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(init){
    function f(param){
     if(! param) return 0;
     var l = param[2], x = param[1];
     return [1, x, l];
    }
    return [0, init, f];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1], v$0 = caml_call2(f, v, a);
      seed = seed$1;
      v = v$0;
     }
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1];
    function to_list(s, next, i){
     var s$0 = s;
     for(;;){
      if(0 === i){
       var t = [0, s$0, next], _I_ = to_list_rev(t);
       return caml_call1(Base_List1[21], _I_);
      }
      var match = caml_call1(next, s$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s$2 = match[2], a = match[1];
       return [0, a, to_list(s$2, next, caml_call2(Base_Import[92], i, 1))];
      }
      var s$1 = match[1];
      s$0 = s$1;
     }
    }
    return to_list(s, next, 500);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _H_ = to_list(t);
    return caml_call2(Base_Import[151], sexp_of_a, _H_);
   }
   function range(opt, _G_, _F_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_G_) var sth$0 = _G_[1], start = sth$0; else var start = 104758188;
    if(_F_) var sth$1 = _F_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[90], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    function f(t_lazy){
     var
      _E_ = caml_obj_tag(t_lazy),
      match =
        250 === _E_
         ? t_lazy[1]
         : 246 === _E_ ? caml_call1(CamlinternalLazy[2], t_lazy) : t_lazy,
      next = match[2],
      s = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 === "number") return 0;
     if(0 === match$0[0]){
      var s$0 = match$0[1], v = [0, s$0, next];
      return [0, v];
     }
     var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
     return [1, x, v$0];
    }
    return [0, t_lazy, f];
   }
   function _d_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _D_ = [0, caml_call2(Base_Import[90], i, 1), s$1];
             return [1, caml_call2(f, i, a), _D_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[90], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _C_ = Base_Import[126];
    return _d_
            (filter
              (mapi(t, function(i, s){return [0, i, s];}),
               function(param){
                var s = param[2], i = param[1];
                return caml_call2(f, i, s);
               }),
             _C_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      s = s$1;
     }
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _e_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[90], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[92], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1];
     s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    function f$0(param){
     var
      rest = param[2],
      match = param[1],
      next = match[2],
      seed = match[1],
      match$0 = caml_call1(next, seed);
     if(typeof match$0 === "number"){
      var
       next$0 = rest[2],
       seed$0 = rest[1],
       match$1 = caml_call1(next$0, seed$0);
      if(typeof match$1 === "number") return 0;
      if(0 === match$1[0]){
       var s = match$1[1];
       return [0, [0, empty, [0, s, next$0]]];
      }
      var s$0 = match$1[2], a = match$1[1];
      return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
     }
     if(0 === match$0[0]){
      var s$1 = match$0[1];
      return [0, [0, [0, s$1, next], rest]];
     }
     var s$2 = match$0[2], a$0 = match$0[1];
     return [1, a$0, [0, [0, s$2, next], rest]];
    }
    var init = [0, empty, t];
    return [0, init, f$0];
   }
   function return$0(x){
    function f(param){
     if(! param) return 0;
     var x = param[1];
     return [1, x, 0];
    }
    var init = [0, x];
    return [0, init, f];
   }
   var
    map = [0, -198771759, _d_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_Sequence_nth = cst_Sequence_nth$1,
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _i_ = [0, cst_Both$0],
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(caml_call2(Base_Import[127], i, 0)) return [0, a];
      var i$0 = caml_call2(Base_Import[92], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[125], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare(cmp_a, cmp_b, a_011, b_012){
    if(caml_call2(Base_Ppx_compare_lib[1], a_011, b_012)) return 0;
    switch(a_011[0]){
      case 0:
       var a_013 = a_011[1];
       if(0 !== b_012[0]) return -1;
       var b_014 = b_012[1];
       return caml_call2(cmp_a, a_013, b_014);
      case 1:
       var a_015 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          var b_016 = b_012[1]; return caml_call2(cmp_b, a_015, b_016);
         default: return -1;
       }
       break;
      default:
       var a_019 = a_011[2], a_017 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_020 = b_012[2],
           b_018 = b_012[1],
           n = caml_call2(cmp_a, a_017, b_018);
          return 0 === n ? caml_call2(cmp_b, a_019, b_020) : n;
       }
    }
    return 1;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_021, of_b_022, sexp_027){
    a:
    {
     if(0 === sexp_027[0]){
      var _y_ = sexp_027[1];
      b:
      if(_y_ !== cst_Both$0){
       c:
       if(_y_ !== cst_Left$0){
        if(_y_ !== cst_Right$0){
         if(_y_ === cst_both) break b;
         if(_y_ === cst_left) break c;
         if(_y_ !== cst_right) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
     }
     var _z_ = sexp_027[1];
     if(! _z_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_025, sexp_027);
     var _A_ = _z_[1];
     if(0 !== _A_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_025, sexp_027);
     var tag_028 = _A_[1];
     b:
     if(tag_028 !== cst_Both$0){
      c:
      if(tag_028 !== cst_Left$0){
       if(tag_028 !== cst_Right$0){
        if(tag_028 === cst_both) break b;
        if(tag_028 === cst_left) break c;
        if(tag_028 !== cst_right) break a;
       }
       var sexp_args_034 = _z_[2];
       if(sexp_args_034 && ! sexp_args_034[2]){
        var
         arg0_035 = sexp_args_034[1],
         res0_036 = caml_call1(of_b_022, arg0_035);
        return [1, res0_036];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_025,
                tag_028,
                sexp_027);
      }
      var sexp_args_029 = _z_[2];
      if(sexp_args_029 && ! sexp_args_029[2]){
       var
        arg0_030 = sexp_args_029[1],
        res0_031 = caml_call1(of_a_021, arg0_030);
       return [0, res0_031];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_025,
               tag_028,
               sexp_027);
     }
     var sexp_args_039 = _z_[2];
     if(sexp_args_039){
      var _B_ = sexp_args_039[2];
      if(_B_ && ! _B_[2]){
       var
        arg1_041 = _B_[1],
        arg0_040 = sexp_args_039[1],
        res0_042 = caml_call1(of_a_021, arg0_040),
        res1_043 = caml_call1(of_b_022, arg1_041);
       return [2, res0_042, res1_043];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_025,
              tag_028,
              sexp_027);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_025, sexp_027);
   }
   function sexp_of_t$1(of_a_046, of_b_047, param){
    switch(param[0]){
      case 0:
       var arg0_048 = param[1], res0_049 = caml_call1(of_a_046, arg0_048);
       return [1, [0, _g_, [0, res0_049, 0]]];
      case 1:
       var arg0_050 = param[1], res0_051 = caml_call1(of_b_047, arg0_050);
       return [1, [0, _h_, [0, res0_051, 0]]];
      default:
       var
        arg1_053 = param[2],
        arg0_052 = param[1],
        res0_054 = caml_call1(of_a_046, arg0_052),
        res1_055 = caml_call1(of_b_047, arg1_053);
       return [1, [0, _i_, [0, res0_054, [0, res1_055, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   var
    Merge_with_duplicates_element =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t$1, t_sexp_grammar],
    cst_hd_exn = "hd_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_drop = "Sequence.drop";
   function merge_with_duplicates(param, _x_, compare){
    var next2 = _x_[2], s2 = _x_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    return caml_call2
            (map$0,
             merge_with_duplicates(s1, s2, compare),
             function(param){var x = param[1]; return x;});
   }
   function merge_sorted(param, _w_, compare){
    var next2 = _w_[2], s2 = _w_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[123], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1]; s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    return filter_map
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[21], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[21], accum), empty];
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[92], i, 1);
      s$0 = s$2;
      i = i$0;
      accum = accum$0;
     }
    }
   }
   function chunks_exn(init, n){
    if(0 >= n) return caml_call1(Base_Import[125], cst_Sequence_chunks_exn);
    function f(t){
     var match = split_n(t, n), xs = match[1];
     if(! xs) return 0;
     var t$0 = match[2];
     return [1, xs, t$0];
    }
    return [0, init, f];
   }
   function findi(s, f){
    return find
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){
    function f(_v_){return _v_;}
    return caml_call2(bind$0, s, f);
   }
   function concat_mapi(s, f){
    function f$0(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    var s$0 = mapi(s, function(i, s){return [0, i, s];});
    return caml_call2(bind$0, s$0, f$0);
   }
   function zip(param, _t_){
    var next2 = _t_[2], s2 = _t_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _u_ = param[1];
     if(typeof _u_ !== "number"){
      if(1 === _u_[0]){
       var match = param[2], s1$0 = _u_[2], a = _u_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _u_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _u_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _s_){
    var next2 = _s_[2], s2 = _s_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0]){
      var seed$1 = match[1];
      seed$0 = seed$1;
     }
     else{
      var seed$2 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      seed$0 = seed$2;
     }
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], acc$0 = caml_call2(Base_Import[90], acc, 1);
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function iteri(s, f){
    return iter
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function foldi(s, init, f){
    return fold
            (mapi(s, function(i, s){return [0, i, s];}),
             init,
             function(acc, param){
              var s = param[2], i = param[1];
              return caml_call3(f, i, acc, s);
             });
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    function f(param){
     if(! param) return 0;
     var
      match = param[1],
      s = match[2],
      acc = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 !== "number" && 0 === match$0[0]){
      var s$2 = match$0[1];
      return [0, [0, [0, acc, s$2]]];
     }
     if(acc){
      if(typeof match$0 === "number")
       return [1, caml_call1(Base_List1[21], acc), 0];
      var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
      return caml_call2(break$0, prev, cur)
              ? [1,
                caml_call1(Base_List1[21], acc),
                [0, [0, [0, cur, 0], s$0]]]
              : [0, [0, [0, [0, cur, acc], s$0]]];
     }
     if(typeof match$0 === "number") return 0;
     var s$1 = match$0[2], cur$0 = match$0[1];
     return [0, [0, [0, [0, cur$0, 0], s$1]]];
    }
    var init = [0, [0, 0, s]];
    return [0, init, f];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a];
      last_elt = last_elt$0;
      s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){return length(filter(s, f));}
   function counti(t, f){return length(filteri(t, f));}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    function f$0(i){
     if(n <= i) return 0;
     var _r_ = caml_call2(Base_Import[90], i, 1);
     return [1, caml_call1(f, i), _r_];
    }
    return [0, 0, f$0];
   }
   function sub(s, pos, len){
    var _p_ = pos < 0 ? 1 : 0, _q_ = _p_ || (len < 0 ? 1 : 0);
    if(_q_) caml_call1(Base_Import[123], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[92], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var
    Infix = [0, append],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn";
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _o_ = param[1];
             if(815032112 === _o_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _o_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(init){
    function f(x){return [1, x, x];}
    return [0, init, f];
   }
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[23], xs))
     caml_call1(Base_Import[125], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function f(param){return s;}
    var s$0 = repeat(0);
    return caml_call2(bind$0, s$0, f);
   }
   function cartesian_product(sa, sb){
    function f(a){return zip(repeat(a), sb);}
    return caml_call2(bind$0, sa, f);
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    return caml_call4
            (Expert[2],
             s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$0, t, init, f){
    return caml_call4
            (Expert[2],
             t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$0);
   }
   function iter_m(bind, return$0, t, f){
    return caml_call4
            (Expert[2],
             t,
             0,
             function(param, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[12], acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_n_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1];
                s$0 = s$1;
               }
              }]];
    }
    return [0,
            memoize(s),
            function(param){
             var l = param[1], _m_ = caml_obj_tag(l);
             return 250 === _m_
                     ? l[1]
                     : 246 === _m_ ? caml_call1(CamlinternalLazy[2], l) : l;
            }];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      s$0 = s$2;
     }
    }
   }
   function compare$0(compare_a, t1, t2){
    return caml_call1
            (Base_With_return[1],
             function(r){
              iter
               (zip_full(t1, t2),
                function(param){
                 var _k_ = param[1];
                 if(737457313 !== _k_)
                  return 847852583 <= _k_
                          ? caml_call1(r, 1)
                          : caml_call1(r, -1);
                 var
                  match = param[2],
                  v2 = match[2],
                  v1 = match[1],
                  c = caml_call2(compare_a, v1, v2),
                  _l_ = 0 !== c ? 1 : 0;
                 return _l_ ? caml_call1(r, c) : _l_;
                });
              return 0;
             });
   }
   function equal(equal_a, t1, t2){
    return for_all
            (zip_full(t1, t2),
             function(param){
              if(737457313 !== param[1]) return 0;
              var match = param[2], a2 = match[2], a1 = match[1];
              return caml_call2(equal_a, a1, a2);
             });
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[23], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[21], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[21], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(init){
    function f(seq){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var tl = match[2], hd = match[1];
     return [1, hd, tl];
    }
    return [0, init, f];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1];
      state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11],
    _j_ = [0, 0];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _j_;});}
    function f(thunk){var step = caml_call1(thunk, 0)[1]; return step;}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       sexp_of_t$0,
       equal,
       compare$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       Expert];
   runtime.caml_register_global(48, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23],
    compare = Base_Import[234],
    t_of_sexp = Base_Import[176],
    sexp_of_t = Base_Import[152];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function get(_aD_, _aC_){return caml_check_bound(_aD_, _aC_)[1 + _aC_];}
   function set(_aB_, _aA_, _az_){
    caml_check_bound(_aB_, _aA_)[1 + _aA_] = _az_;
    return 0;
   }
   function swap$0(arr, i, j){
    var tmp = get(arr, i);
    set(arr, i, get(arr, j));
    return set(arr, j, tmp);
   }
   function sort(arr, compare, left, right){
    var _ax_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _ax_){
     var pos = _ax_;
     for(;;){
      var v = get(arr, pos), final_pos = pos;
      for(;;){
       var i_next = caml_call2(Base_Import[92], final_pos, 1);
       if(left > i_next) break;
       if(0 >= caml_call2(compare, get(arr, i_next), v)) break;
       set(arr, final_pos, get(arr, i_next));
       final_pos = i_next;
      }
      set(arr, final_pos, v);
      var _ay_ = pos + 1 | 0;
      if(right === pos) break;
      pos = _ay_;
     }
    }
    return 0;
   }
   var Insertion_sort = [0, sort];
   function heapify(arr, compare, root, left, right){
    var root$0 = root;
    for(;;){
     var
      relative_root = caml_call2(Base_Import[92], root$0, left),
      _aq_ = caml_call2(Base_Import[87], 2, relative_root),
      _ar_ = caml_call2(Base_Import[90], _aq_, left),
      left_child = caml_call2(Base_Import[90], _ar_, 1),
      _as_ = caml_call2(Base_Import[87], 2, relative_root),
      _at_ = caml_call2(Base_Import[90], _as_, left),
      right_child = caml_call2(Base_Import[90], _at_, 2);
     a:
     {
      if(left_child <= right){
       var _au_ = get(arr, root$0);
       if(0 < caml_call2(compare, get(arr, left_child), _au_)){var largest = left_child; break a;}
      }
      var largest = root$0;
     }
     a:
     {
      if(right_child <= right){
       var _av_ = get(arr, largest);
       if(0 < caml_call2(compare, get(arr, right_child), _av_)){var largest$0 = right_child; break a;}
      }
      var largest$0 = largest;
     }
     var _aw_ = largest$0 !== root$0 ? 1 : 0;
     if(! _aw_) return _aw_;
     swap$0(arr, root$0, largest$0);
     root$0 = largest$0;
    }
   }
   function sort$0(arr, compare, left, right){
    var
     _al_ = caml_call2(Base_Import[90], left, right),
     _am_ = caml_call2(Base_Import[94], _al_, 2);
    if(_am_ >= left){
     var i = _am_;
     for(;;){
      heapify(arr, compare, i, left, right);
      var _an_ = i - 1 | 0;
      if(left === i) break;
      i = _an_;
     }
    }
    var _ao_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _ao_){
     var i$0 = right;
     for(;;){
      swap$0(arr, left, i$0);
      heapify(arr, compare, left, left, caml_call2(Base_Import[92], i$0, 1));
      var _ap_ = i$0 - 1 | 0;
      if(_ao_ === i$0) break;
      i$0 = _ap_;
     }
    }
    return 0;
   }
   var Heap_sort = [0, sort$0];
   function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
    function compare_and_swap(i, j){
     var
      _aj_ = get(arr, j),
      _ak_ = 0 < caml_call2(compare, get(arr, i), _aj_) ? 1 : 0;
     return _ak_ ? swap$0(arr, i, j) : _ak_;
    }
    compare_and_swap(m1, m2);
    compare_and_swap(m4, m5);
    compare_and_swap(m1, m3);
    compare_and_swap(m2, m3);
    compare_and_swap(m1, m4);
    compare_and_swap(m3, m4);
    compare_and_swap(m2, m5);
    compare_and_swap(m2, m3);
    return compare_and_swap(m4, m5);
   }
   function intro_sort(arr, max_depth, compare, left, right){
    var max_depth$0 = max_depth, left$0 = left;
    for(;;){
     var
      _ai_ = caml_call2(Base_Import[92], right, left$0),
      len = caml_call2(Base_Import[90], _ai_, 1);
     if(32 >= len)
      return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
     if(0 > max_depth$0)
      return caml_call4(Heap_sort[1], arr, compare, left$0, right);
     var
      max_depth$1 = caml_call2(Base_Import[92], max_depth$0, 1),
      _ah_ = caml_call2(Base_Import[92], right, left$0),
      sixth = caml_call2(Base_Import[94], _ah_, 6),
      m1 = caml_call2(Base_Import[90], left$0, sixth),
      m2 = caml_call2(Base_Import[90], m1, sixth),
      m3 = caml_call2(Base_Import[90], m2, sixth),
      m4 = caml_call2(Base_Import[90], m3, sixth),
      m5 = caml_call2(Base_Import[90], m4, sixth);
     five_element_sort(arr, compare, m1, m2, m3, m4, m5);
     var
      m2_val = get(arr, m2),
      m3_val = get(arr, m3),
      m4_val = get(arr, m4),
      match =
        0 === caml_call2(compare, m2_val, m3_val)
         ? [0, m2_val, m3_val, 1]
         : 0
           === caml_call2(compare, m3_val, m4_val)
           ? [0, m3_val, m4_val, 1]
           : [0, m2_val, m4_val, 0],
      middle_sorted = match[3],
      pivot2 = match[2],
      pivot1 = match[1],
      l$0 = left$0,
      p$1 = left$0,
      r$2 = right;
     for(;;){
      if(r$2 < p$1) break;
      var pv = get(arr, p$1);
      if(0 <= caml_call2(compare, pv, pivot1))
       if(0 < caml_call2(compare, pv, pivot2)){
        var r = r$2;
        for(;;){
         if(p$1 >= r) break;
         if(0 >= caml_call2(compare, get(arr, r), pivot2)) break;
         var r$0 = caml_call2(Base_Import[92], r, 1);
         r = r$0;
        }
        swap$0(arr, r, p$1);
        var r$1 = caml_call2(Base_Import[92], r, 1);
        r$2 = r$1;
       }
       else{var p = caml_call2(Base_Import[90], p$1, 1); p$1 = p;}
      else{
       swap$0(arr, p$1, l$0);
       var
        p$0 = caml_call2(Base_Import[90], p$1, 1),
        l = caml_call2(Base_Import[90], l$0, 1);
       l$0 = l;
       p$1 = p$0;
      }
     }
     intro_sort
      (arr, max_depth$1, compare, left$0, caml_call2(Base_Import[92], l$0, 1));
     if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
     var left$1 = caml_call2(Base_Import[90], r$2, 1);
     max_depth$0 = max_depth$1;
     left$0 = left$1;
    }
   }
   function sort$1(arr, compare, left, right){
    return intro_sort(arr, 32, compare, left, right);
   }
   var
    Intro_sort = [0, sort$1, five_element_sort],
    _a_ = [0, cst_src_array_ml, 435, 14],
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    cst_Array_iter2_exn = "Array.iter2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    _c_ = [0, "Array.findi_exn: not found"],
    _d_ = [0, "Array.find_exn: not found"];
   function sort$2(pos, len, arr, compare){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1], pos, len, 0, arr.length - 1),
     len$0 = match[2],
     pos$0 = match[1],
     _af_ = caml_call2(Base_Import[90], pos$0, len$0),
     _ag_ = caml_call2(Base_Import[92], _af_, 1);
    return caml_call4(Intro_sort[1], arr, compare, pos$0, _ag_);
   }
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _aa_ = a1[1 + caml_call2(Base_Import[92], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _aa_))
     return caml_call2(append, a1, a2);
    var _ab_ = a2[1 + caml_call2(Base_Import[92], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _ab_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[90], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _ad_ = caml_call2(Base_Import[92], len, 1),
     _ac_ = 0;
    if(_ad_ >= 0){
     var i = _ac_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[90], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[90], a2_index[1], 1);
      }
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      i = _ae_;
     }
    }
    return merged;
   }
   function copy_matrix(_$_){return caml_call2(map, _$_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _Z_ = caml_call3(Base_Container[9], fold, init, f);
    return function(___){return caml_call2(_Z_, ___, t);};
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _X_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[92], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     caml_call1(Base_Import[129], i);
     caml_call1(Base_Import[128], j);
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _T_ = caml_call1(Base_List[7], l$0),
     len = caml_call2(Base_Import[90], 1, _T_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _U_ = caml_call2(Base_Import[92], len, 2);
    if(_U_ >= 0){
     var i = _U_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _V_ = i - 1 | 0;
      if(0 === i) break;
      i = _V_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _R_ = caml_call1(f, hd),
     _S_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, _S_), _R_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _P_ = caml_call2(f, 0, hd),
     _Q_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, _Q_), _P_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _N_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       caml_call1(Base_Import[129], k);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_L_){return _L_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _K_ = n1 !== n2 ? 1 : 0;
    return _K_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _K_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[92], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){caml_call1(Base_Import[128], i); continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function equal(equal, t1, t2){
    var _J_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _J_ ? for_all2_exn(t1, t2, equal) : _J_;
   }
   function map_inplace(t, f){
    var _H_ = caml_call2(Base_Import[92], t.length - 1, 1), _G_ = 0;
    if(_H_ >= 0){
     var i = _G_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _I_ = i + 1 | 0;
      if(_H_ === i) break;
      i = _I_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       caml_call1(Base_Import[129], i);
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, [0, i, value]];},
             function(param){return 0;});
   }
   function findi_exn(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, i, value];},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[251], _c_], 1);
             });
   }
   function find_exn(t, f){
    return findi_internal
            (t,
             function(i, x){return caml_call1(f, x);},
             function(param, value){return value;},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[251], _d_], 1);
             });
   }
   function find(t, f){
    var _F_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2
            (Base_Option[21],
             _F_,
             function(param){var x = param[2]; return x;});
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found = [0, Base_Import[251], [0, "Array.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found$0 = [0, Base_Import[251], [0, "Array.find_mapi_exn: not found"]],
    cst_Array_reduce_exn = "Array.reduce_exn";
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; caml_call1(Base_Import[129], i);}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _D_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _C_ = 1;
    if(_D_ >= 1){
     var i = _C_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _E_ = i + 1 | 0;
      if(_D_ === i) break;
      i = _E_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[125], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var
    permute = Base_Array_permute[24],
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_transpose_exn = "Array.transpose_exn";
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(is_empty(t))
     return caml_call1(Base_Import[123], cst_Array_random_element_exn_e);
    var _B_ = caml_call2(Base_Random[18][6], random_state, t.length - 1);
    return caml_check_bound(t, _B_)[1 + _B_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{var _z_ = [0, random_element_exn([0, random_state], t)]; return _z_;}
    catch(_A_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[123], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _x_ = caml_call2(Base_Import[92], n, 1),
     _w_ = 1;
    if(_x_ >= 1){
     var i = _w_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort$2(0, 0, t1, compare);
    return t1;
   }
   function partitioni_tf(t, f){
    var
     both =
       caml_call2
        (mapi,
         t,
         function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];}),
     trues =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     falses =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, trues, falses];
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(i, x){return caml_call1(f, x);});
   }
   function last(t){
    var _v_ = caml_call2(Base_Import[92], t.length - 1, 1);
    return caml_check_bound(t, _v_)[1 + _v_];
   }
   function to_sequence_mutable(t){
    return caml_call2
            (Base_Sequence[41],
             0,
             function(i){
              if(t.length - 1 <= i) return 0;
              var _u_ = caml_call2(Base_Import[90], i, 1);
              return [1, caml_check_bound(t, i)[1 + i], _u_];
             });
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _j_ = caml_check_bound(t2, 0)[1],
      _k_ = [0, caml_check_bound(t1, 0)[1], _j_],
      t = caml_call2(create, caml_call2(Base_Import[87], n1, n2), _k_),
      r = [0, 0],
      _m_ = caml_call2(Base_Import[92], n1, 1),
      _l_ = 0;
     if(_m_ >= 0){
      var i1 = _l_;
      for(;;){
       var _o_ = caml_call2(Base_Import[92], n2, 1), _n_ = 0;
       if(_o_ >= 0){
        var i2 = _n_;
        for(;;){
         var
          _q_ = caml_check_bound(t2, i2)[1 + i2],
          _r_ = [0, caml_check_bound(t1, i1)[1 + i1], _q_],
          _s_ = r[1];
         caml_check_bound(t, _s_)[1 + _s_] = _r_;
         caml_call1(Base_Import[129], r);
         var _t_ = i2 + 1 | 0;
         if(_o_ === i2) break;
         i2 = _t_;
        }
       }
       var _p_ = i1 + 1 | 0;
       if(_m_ === i1) break;
       i1 = _p_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[125], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_i_, _h_){return caml_check_bound(_i_, _h_)[1 + _h_];}
   function length(_g_){return _g_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length]),
    binary_search = include[1],
    binary_search_segmented = include[2],
    _e_ = [0, cst_src_array_ml, 858, 8];
   function length$0(_f_){return _f_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$0, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   var
    Base_Array =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       max_length,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       of_list,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       iteri,
       mapi,
       foldi,
       fold_right,
       sort$2,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       concat_map,
       concat_mapi,
       partition_tf,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       filter_map,
       filter_mapi,
       for_alli,
       existsi,
       counti,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       filter,
       filteri,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi,
       findi_exn,
       find_mapi,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Insertion_sort, Heap_sort, Intro_sort]]];
   runtime.caml_register_global(28, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _a_ = [0, "src/obj_array.ml", 11, 18],
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""];
   function invariant(t){
    var _t_ = Stdlib_Obj[15];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[14], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    var _l_ = Stdlib_Obj[14];
    if(caml_obj_tag(x) !== _l_) return caml_call2(Base_Array0[4], len, x);
    var
     t = create_zero(len),
     _n_ = caml_call2(Base_Import[92], len, 1),
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      unsafe_set_with_caml_modify(t, i, x);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _o_;
     }
    }
    return t;
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[92], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var i$0 = caml_call2(Base_Import[90], src_pos, i), _i_ = src[1 + i$0];
       unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i), _i_);
       var _f_ = i + 1 | 0;
       if(_e_ === i) break;
       i = _f_;
      }
     }
     return 0;
    }
    var _g_ = caml_call2(Base_Import[92], len, 1);
    if(_g_ >= 0){
     var i$1 = _g_;
     for(;;){
      var i$2 = caml_call2(Base_Import[90], src_pos, i$1), _j_ = src[1 + i$2];
      unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i$1), _j_);
      var _h_ = i$1 - 1 | 0;
      if(0 === i$1) break;
      i$1 = _h_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub = include[4],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Blit, Base__Container, Base__Import, Base__List, Base__Obj_array, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    empty = Base_Obj_array[12];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[9], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[9], len);}
   function create(len, x){return caml_call2(Base_Obj_array[8], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[11], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[18], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[14], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[16], arr, i, x);}
   function unsafe_get(arr, i){return caml_call2(Base_Obj_array[15], arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[17], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[22], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   var
    length = Base_Obj_array[13],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[10];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[24], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[19], t, i, x);
   }
   var
    unsafe_clear_if_pointer = Base_Obj_array[25],
    _a_ = [0, cst_src_uniform_array_ml, 71, 18],
    cst_Uniform_array_init = "Uniform_array.init",
    cst_Array_map2_exn = "Array.map2_exn";
   function invariant(t){
    var _H_ = Stdlib_Obj[15];
    if(runtime.caml_obj_tag(t) !== _H_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[125], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _F_ = caml_call2(Base_Import[92], l, 1),
     _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _G_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _G_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_D_){return arr[1 + _D_];});
   }
   function map(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call1(f, unsafe_get(a, i));});
   }
   function mapi(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call2(f, i, unsafe_get(a, i));});
   }
   function iter(a, f){
    var
     _A_ = caml_call1(length, a),
     _B_ = caml_call2(Base_Import[92], _A_, 1),
     _z_ = 0;
    if(_B_ >= 0){
     var i = _z_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _C_ = i + 1 | 0;
      if(_B_ === i) break;
      i = _C_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _w_ = caml_call1(length, a),
     _x_ = caml_call2(Base_Import[92], _w_, 1),
     _v_ = 0;
    if(_x_ >= 0){
     var i = _v_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     _r_ = caml_call1(length, a),
     _s_ = caml_call2(Base_Import[92], _r_, 1),
     _q_ = 0;
    if(_s_ >= 0){
     var i = _q_;
     for(;;){
      var _t_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _t_);
      var _u_ = i + 1 | 0;
      if(_s_ === i) break;
      i = _u_;
     }
    }
    return acc[1];
   }
   function to_list(t){
    var _o_ = caml_call1(length, t);
    return caml_call2(Base_List[123], _o_, function(_p_){return get(t, _p_);});
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[7], l),
     res = unsafe_create_uninitialized(len);
    caml_call2(Base_List[98], l, function(i, x){return set(res, i, x);});
    return res;
   }
   function to_array(t){
    var _n_ = caml_call1(length, t);
    return caml_call2
            (Base_Array[27], _n_, function(i){return unsafe_get(t, i);});
   }
   function exists(t, f){
    var
     _m_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _m_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 0;
     var _l_ = caml_call1(f, unsafe_get(t, i));
     if(_l_) return _l_;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function for_all(t, f){
    var
     _k_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _k_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 1;
     var _j_ = caml_call1(f, unsafe_get(t, i));
     if(! _j_) return _j_;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[125], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _i_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _i_);
             });
   }
   function t_sexp_grammar(grammar){
    var _h_ = caml_call1(Base_Array[4], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _h_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[2], Base_Array[3]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2],
    _b_ = [0, cst_src_uniform_array_ml, 164, 8];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5];
   function fold(t, init, f){
    var
     r = [0, init],
     _d_ = caml_call1(length, t),
     _e_ = caml_call2(Base_Import[92], _d_, 1),
     _c_ = 0;
    if(_e_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _f_);
      var _g_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _g_;
     }
    }
    return r[1];
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare(compare_elt, a, b){
    if(caml_call2(Base_Import[127], a, b)) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get(a, i),
      r = unsafe_get(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   var
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       foldi,
       of_array,
       to_array,
       of_list,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists,
       for_all,
       map2_exn,
       min_elt,
       max_elt];
   runtime.caml_register_global(14, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Import0, Base__Option, Base__Printf, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float;
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    nan = Base_Import[84][23],
    infinity = Base_Import[84][21],
    neg_infinity = Base_Import[84][22],
    max_finite_value = Base_Import[84][24],
    epsilon_float = Base_Import[84][26],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var
    is_integer = Stdlib_Float[16],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(caml_call2(Base_Import[107][1], b, 0.))
     caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return caml_call2(Base_Import[107][1], m, 0.)
            ? caml_call2(Base_Import[91], m, b)
            : m;
   }
   var
    frexp = runtime.caml_frexp_float,
    ldexp = runtime.caml_ldexp_float,
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _f_ = [0, cst_src_float0_ml, 174, 4],
    _g_ = [0, cst_src_float0_ml, 170, 4];
   function is_nan(x){return caml_call2(Base_Import[107][3], x, x);}
   function to_int64_preserve_order(t){
    return is_nan(t)
            ? 0
            : caml_call2
               (Base_Import[107][4], t, 0.)
              ? _b_
              : caml_call2
                 (Base_Import[107][5], t, 0.)
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[113], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[28], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[113], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[84][23];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[92], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[93], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[92], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[113], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[92], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[93], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[107][1], t, min)
            ? min
            : caml_call2(Base_Import[107][1], max, t) ? max : t;
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[91], f, x);}
   var
    include = Base_Import[107],
    symbol$1 = include[1],
    symbol$2 = include[2],
    symbol$3 = include[3],
    symbol$4 = include[4],
    symbol$5 = include[5],
    symbol$6 = include[6],
    ascending = include[7],
    descending = include[8],
    compare = include[9],
    equal = include[10],
    max = include[11],
    min = include[12],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       ascending,
       descending,
       compare,
       equal,
       max,
       min];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[184],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function to_string(t){return caml_call2(Base_String0[9], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24],
    _b_ = [0, [1, 0], "%C"];
   function pp(fmt, c){return caml_call3(Stdlib_Format[129], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[11], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[15], _c_),
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit";
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _u_ = param - 48 | 0;
    a:
    {
     if(42 < _u_ >>> 0){
      if(25 < _u_ - 49 >>> 0) break a;
     }
     else if(6 >= _u_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _s_ = caml_call1(to_int, 48), _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[92], _t_, _s_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _r_ = param - 48 | 0;
    a:
    {
     if(22 < _r_ >>> 0){
      if(5 < _r_ - 49 >>> 0) break a;
     }
     else if(6 >= _r_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _j_ = caml_call1(to_int, 97),
        _k_ = caml_call1(to_int, t),
        _l_ = caml_call2(Base_Import[92], _k_, _j_);
       return caml_call2(Base_Import[90], _l_, 10);
      }
     }
     else if(71 > t){
      var
       _m_ = caml_call1(to_int, 65),
       _n_ = caml_call1(to_int, t),
       _o_ = caml_call2(Base_Import[92], _n_, _m_);
      return caml_call2(Base_Import[90], _o_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _p_ = caml_call1(to_int, 48), _q_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[92], _q_, _p_);
    }
    var
     _h_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _i_ = caml_call2(Base_Sexp[9], cst_Char_get_hex_digit_exn_not, _h_);
    return caml_call1(Base_Error[30], _i_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[105][6],
    symbol$0 = Base_Import[105][2],
    symbol$1 = Base_Import[105][4],
    symbol$2 = Base_Import[105][5],
    symbol$3 = Base_Import[105][1],
    symbol$4 = Base_Import[105][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[164],
    sexp_of_t$1 = Base_Import[140],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var _f_ = caml_call1(lowercase, c2), _g_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[105][9], _g_, _f_);
   }
   function hash_fold_t$1(state, t){
    var _e_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[205], state, _e_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16],
    include$1 = Base_Import[105],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$0 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_Char =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[31], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[96][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[96][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[29], first_target));
    if(! caml_call2(Base_Char[14], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[31], i);
       if(! caml_call2(Base_Char[14], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0; i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, caml_call1(Base_Bytes0[16], tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Import, Base__Indexed_container, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Ppx_compare_lib, Base__Printf, Base__Sexp, Base__Staged, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$1 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$10 = cst$11,
    cst$9 = cst$11,
    cst$8 = cst$11,
    cst$6 = cst$11,
    cst$7 = cst$11,
    cst$5 = cst$11,
    cst$4 = cst$11,
    cst$3 = cst$11,
    cst$2 = cst$11,
    cst$1 = cst$11,
    cst$0 = cst$11,
    cst = cst$11,
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Array0 = global_data.Base__Array0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol_concat = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    copy = Base_String0[6],
    escaped = Base_String0[7],
    lowercase = Base_String0[8],
    make = Base_String0[9],
    uncapitalize = Base_String0[11],
    uppercase = Base_String0[13],
    concat = Base_String0[14],
    iter = Base_String0[15],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[30],
    stage = Base_Staged[1],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    runtime.caml_blit_string(src, pos, dst, 0, len);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[92], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _df_ = caml_call2(Base_Import[92], total_length, pos$1),
     len$0 = caml_call2(Base_Option[27], len, _df_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[90], pos$1, len$0), pos = pos$1;
    for(;;){
     var _dc_ = pos < end ? 1 : 0;
     if(_dc_){
      var
       _dd_ =
         caml_call2(Base_Char[15], caml_string_unsafe_get(t, pos), char$0);
      if(! _dd_){
       var pos$0 = caml_call2(Base_Import[90], pos, 1);
       pos = pos$0;
       continue;
      }
      var _de_ = _dd_;
     }
     else
      var _de_ = _dc_;
     return _de_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[90], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function index_exn_internal(t, not_found, char$0){
    return index_from_exn_internal
            (t, 0, caml_ml_string_length(t), not_found, char$0);
   }
   var not_found = [0, Base_Import[251], [0, "String.index_exn: not found"]];
   function index_exn(t, char$0){
    return index_exn_internal(t, not_found, char$0);
   }
   var
    not_found$0 =
      [0, Base_Import[251], [0, "String.index_from_exn: not found"]],
    cst_String_index_from_exn = "String.index_from_exn";
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_exn_internal(t, pos, len, not_found$0, char$0);
    return caml_call1(Base_Import[125], cst_String_index_from_exn);
   }
   function rindex_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[92], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_exn_internal(t, not_found, char$0){
    var len = caml_ml_string_length(t);
    return rindex_from_exn_internal
            (t, caml_call2(Base_Import[92], len, 1), len, not_found, char$0);
   }
   var
    not_found$1 = [0, Base_Import[251], [0, "String.rindex_exn: not found"]];
   function rindex_exn(t, char$0){
    return rindex_exn_internal(t, not_found$1, char$0);
   }
   var
    not_found$2 =
      [0, Base_Import[251], [0, "String.rindex_from_exn: not found"]],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    _a_ = [0, cst_case_sensitive],
    _b_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _c_ = [0, "kmp_array"],
    _d_ = [0, cst_case_sensitive],
    _e_ = [0, cst_pattern];
   function rindex_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(-1 <= pos && len > pos)
     return rindex_from_exn_internal(t, pos, len, not_found$2, char$0);
    return caml_call1(Base_Import[125], cst_String_rindex_from_exn);
   }
   function index(t, char$0){
    try{var _da_ = [0, index_exn_internal(t, not_found, char$0)]; return _da_;
    }
    catch(_db_){
     var _c$_ = caml_wrap_exception(_db_);
     if(_c$_[1] !== Base_Import[251] && _c$_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c$_, 0);
     return 0;
    }
   }
   function rindex(t, char$0){
    try{
     var _c9_ = [0, rindex_exn_internal(t, not_found$1, char$0)];
     return _c9_;
    }
    catch(_c__){
     var _c8_ = caml_wrap_exception(_c__);
     if(_c8_[1] !== Base_Import[251] && _c8_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c8_, 0);
     return 0;
    }
   }
   function index_from(t, pos, char$0){
    try{var _c6_ = [0, index_from_exn(t, pos, char$0)]; return _c6_;}
    catch(_c7_){
     var _c5_ = caml_wrap_exception(_c7_);
     if(_c5_[1] !== Base_Import[251] && _c5_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c5_, 0);
     return 0;
    }
   }
   function rindex_from(t, pos, char$0){
    try{var _c3_ = [0, rindex_from_exn(t, pos, char$0)]; return _c3_;}
    catch(_c4_){
     var _c2_ = caml_wrap_exception(_c4_);
     if(_c2_[1] !== Base_Import[251] && _c2_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c2_, 0);
     return 0;
    }
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _c1_ =
       [0,
        [1, [0, _a_, [0, caml_call1(Base_Import[137], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _b_, [0, caml_call1(Base_Import[138], pattern), 0]]],
             _c1_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[92], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[90], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[15] : Base_Char[52][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _cZ_ = caml_call2(Base_Import[92], n, 1),
      _cY_ = 1;
     if(_cZ_ >= 1){
      var i = _cY_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _c0_ = i + 1 | 0;
       if(_cZ_ === i) break;
       i = _c0_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[92],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[90], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[92], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){return 0 <= index_internal(0, t)(str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    if(0 <= p) return p;
    var _cX_ = [0, [0, cst_substring, caml_call1(Base_Import[138], t[1])], 0];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[9], cst_Substring_not_found, _cX_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var _cS_ = caml_call2(Base_Import[90], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[123], _cS_, function(_cW_){return _cW_;});
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _cT_ = 0;
    if(n >= 0){
     var j = _cT_;
     for(;;){
      if(matched_chars[1] === k){
       var _cU_ = found[1];
       found[1] = [0, caml_call2(Base_Import[92], j, k), _cU_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[92], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _cV_ = j + 1 | 0;
      if(n === j) break;
      j = _cV_;
     }
    }
    return caml_call1(Base_List[38], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _cM_ = caml_call2(Base_Import[90], len_s, len_with),
     _cN_ = caml_call2(Base_Import[92], _cM_, len_t),
     dst = caml_call1(Base_Bytes0[7], _cN_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _cO_ = caml_call2(Base_Import[92], len_s, i),
     _cP_ = caml_call2(Base_Import[92], _cO_, len_t),
     _cQ_ = caml_call2(Base_Import[90], i, len_with),
     _cR_ = caml_call2(Base_Import[90], i, len_t);
    caml_call5(Base_Bytes0[4], s, _cR_, dst, _cQ_, _cP_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[7], matches),
     _cF_ = caml_call2(Base_Import[92], len_with, len_t),
     _cG_ = caml_call2(Base_Import[87], _cF_, num_matches),
     _cH_ = caml_call2(Base_Import[90], len_s, _cG_),
     dst = caml_call1(Base_Bytes0[7], _cH_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    caml_call2
     (Base_List[9],
      matches,
      function(i){
       var len = caml_call2(Base_Import[92], i, next_src_pos[1]);
       caml_call5
        (Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
       var _cJ_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
       caml_call5(Base_Bytes0[4], with$0, 0, dst, _cJ_, len_with);
       var _cK_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
       next_dst_pos[1] = caml_call2(Base_Import[90], _cK_, len_with);
       var _cL_ = caml_call2(Base_Import[90], next_src_pos[1], len);
       next_src_pos[1] = caml_call2(Base_Import[90], _cL_, len_t);
       return 0;
      });
    var _cI_ = caml_call2(Base_Import[92], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _cI_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s),
     _cB_ =
       caml_call2(Base_Import[110], matches, [0, caml_ml_string_length(s), 0]),
     _cC_ = [0, caml_call1(Base_Import[112], pattern_len), matches];
    return caml_call3
            (Base_List[83],
             _cC_,
             _cB_,
             function(i, j){
              var
               _cD_ = caml_call2(Base_Import[92], j, i),
               _cE_ = caml_call2(Base_Import[92], _cD_, pattern_len);
              return sub(s, caml_call2(Base_Import[90], i, pattern_len), _cE_);
             });
   }
   function equal(a_002, b_003){
    if(caml_call2(Base_Ppx_compare_lib[1], a_002, b_003)) return 1;
    var _cy_ = caml_call2(Base_Import[245], a_002[1], b_003[1]);
    if(_cy_){
     var _cz_ = caml_call2(Base_Import[238], a_002[2], b_003[2]);
     if(_cz_)
      return caml_call3
              (Base_Import[247], Base_Import[241], a_002[3], b_003[3]);
     var _cA_ = _cz_;
    }
    else
     var _cA_ = _cy_;
    return _cA_;
   }
   function sexp_of_t$1(param){
    var
     kmp_array_011 = param[3],
     case_sensitive_009 = param[2],
     pattern_007 = param[1],
     arg_012 = caml_call2(Base_Import[152], Base_Import[141], kmp_array_011),
     bnds_006 = [0, [1, [0, _c_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[137], case_sensitive_009),
     bnds_006$0 = [0, [1, [0, _d_, [0, arg_010, 0]]], bnds_006],
     arg_008 = caml_call1(Base_Import[138], pattern_007),
     bnds_006$1 = [0, [1, [0, _e_, [0, arg_008, 0]]], bnds_006$0];
    return [1, bnds_006$1];
   }
   function representation(_cx_){return _cx_;}
   var Private = [0, equal, sexp_of_t$1, representation];
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _cv_ = create(pattern, case_sensitive);
    return function(_cw_){return replace_first(pos, _cv_, t, _cw_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _ct_ = create(pattern, case_sensitive);
    return function(_cu_){return replace_all(_ct_, t, _cu_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _cs_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[50], _cs_);
   }
   var _f_ = 1;
   function substr_index(_cp_, _cq_, _cr_){
    return substr_index_gen(_f_, _cp_, _cq_, _cr_);
   }
   var _g_ = 1;
   function substr_index_exn(_cm_, _cn_, _co_){
    return substr_index_exn_gen(_g_, _cm_, _cn_, _co_);
   }
   var _h_ = 1;
   function substr_index_all(_cj_, _ck_, _cl_){
    return substr_index_all_gen(_h_, _cj_, _ck_, _cl_);
   }
   var _i_ = 1;
   function substr_replace_first(_cg_, _ch_, _ci_){
    return substr_replace_first_gen(_i_, _cg_, _ch_, _ci_);
   }
   var _j_ = 1;
   function substr_replace_all(_ce_, _cf_){
    return substr_replace_all_gen(_j_, _ce_, _cf_);
   }
   var
    _k_ = 1,
    _l_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"];
   function is_substring(_cc_, _cd_){
    return is_substring_gen(_k_, _cc_, _cd_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _b$_ = str_pos$1 < 0 ? 1 : 0,
     _ca_ = _b$_ || (str_len < str_pos$1 ? 1 : 0);
    if(_ca_) caml_call4(invalid_argf, _l_, str_pos$1, str_len, 0);
    var
     _cb_ = caml_call2(Base_Import[90], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _cb_) return _cb_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[90], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[90], str_pos, 1);
     str_pos = str_pos$0;
     sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _b__ = suffix_len <= string_len ? 1 : 0;
    return _b__
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[92], string_len, suffix_len),
               suffix,
               char_equal)
            : _b__;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _b9_ = prefix_len <= string_len ? 1 : 0;
    return _b9_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _b9_;
   }
   var
    t_of_sexp$0 = Base_Import[162],
    sexp_of_t$2 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[182];
   function compare$0(string1, string2){
    if(caml_call2(Base_Import[127], string1, string2)) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _b7_ = caml_call1(Base_Char[34], c2),
      _b8_ = caml_call1(Base_Char[34], c1),
      c = caml_call2(Base_Char[16], _b8_, _b7_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
    }
   }
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     _b4_ = caml_call2(Base_Import[92], len, 1),
     _b3_ = 0;
    if(_b4_ >= 0){
     var pos = _b3_;
     for(;;){
      var _b5_ = caml_call1(Base_Char[34], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], _b5_);
      var _b6_ = pos + 1 | 0;
      if(_b4_ === pos) break;
      pos = _b6_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[52][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[52][12]);
   }
   var _m_ = 0;
   function substr_index$0(_b0_, _b1_, _b2_){
    return substr_index_gen(_m_, _b0_, _b1_, _b2_);
   }
   var _n_ = 0;
   function substr_index_exn$0(_bX_, _bY_, _bZ_){
    return substr_index_exn_gen(_n_, _bX_, _bY_, _bZ_);
   }
   var _o_ = 0;
   function substr_index_all$0(_bU_, _bV_, _bW_){
    return substr_index_all_gen(_o_, _bU_, _bV_, _bW_);
   }
   var _p_ = 0;
   function substr_replace_first$0(_bR_, _bS_, _bT_){
    return substr_replace_first_gen(_p_, _bR_, _bS_, _bT_);
   }
   var _q_ = 0;
   function substr_replace_all$0(_bP_, _bQ_){
    return substr_replace_all_gen(_q_, _bP_, _bQ_);
   }
   var _r_ = 0;
   function is_substring$0(_bN_, _bO_){
    return is_substring_gen(_r_, _bN_, _bO_);
   }
   var _s_ = Base_Char[52][12];
   function is_substring_at(_bK_){
    return function(_bL_){
     return function(_bM_){
      return is_substring_at_gen(_bK_, _bL_, _bM_, _s_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$2]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16],
    _t_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"];
   function of_string(_bJ_){return _bJ_;}
   function to_string(_bI_){return _bI_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _t_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _bG_ = caml_call2(Base_Import[92], n, 1),
     _bF_ = 0;
    if(_bG_ >= 0){
     var i = _bF_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _bH_ = i + 1 | 0;
      if(_bG_ === i) break;
      i = _bH_;
     }
    }
    return caml_call1(Base_Bytes0[16], t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[92], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[90], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _bC_ = caml_call2(Base_Import[92], len, 1),
     _bB_ = 0;
    if(_bC_ >= 0){
     var i = _bB_;
     for(;;){
      var _bD_ = caml_call2(Base_Import[92], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[92], _bD_, i)));
      var _bE_ = i + 1 | 0;
      if(_bC_ === i) break;
      i = _bE_;
     }
    }
    return caml_call1(Base_Bytes0[16], res);
   }
   var
    not_found$3 = [0, Base_Import[251], [0, "String.lsplit2_exn: not found"]];
   function lsplit2_exn(line, delim){
    var
     pos = index_exn_internal(line, not_found$3, delim),
     _by_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bz_ = caml_call2(Base_Import[92], _by_, 1),
     _bA_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bz_);
    return [0, sub(line, 0, pos), _bA_];
   }
   var
    not_found$4 = [0, Base_Import[251], [0, "String.rsplit2_exn: not found"]],
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    cst_drop_prefix = "drop_prefix",
    cst_drop_suffix = "drop_suffix",
    cst_prefix = "prefix",
    cst_suffix = "suffix",
    _u_ = [0, cst_src_string_ml, 765, 17],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _v_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    _w_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _x_ = [0, [3, 0, 0], "%S"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _y_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_is_char_escaping = "is_char_escaping",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_literal = "is_char_literal",
    cst_index_from = "index_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$1,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$1,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    _z_ = [0, cst_src_string_ml, 1573, 19],
    _A_ = [0, cst_src_string_ml, 1587, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function rsplit2_exn(line, delim){
    var
     pos = rindex_exn_internal(line, not_found$4, delim),
     _bv_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bw_ = caml_call2(Base_Import[92], _bv_, 1),
     _bx_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bw_);
    return [0, sub(line, 0, pos), _bx_];
   }
   function lsplit2(line, on){
    try{var _bt_ = [0, lsplit2_exn(line, on)]; return _bt_;}
    catch(_bu_){
     var _bs_ = caml_wrap_exception(_bu_);
     if(_bs_[1] !== Base_Import[251] && _bs_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bs_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _bq_ = [0, rsplit2_exn(line, on)]; return _bq_;}
    catch(_br_){
     var _bp_ = caml_wrap_exception(_br_);
     if(_bp_[1] !== Base_Import[251] && _bp_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bp_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _bo_ = caml_call2(Base_Char[15], hd, c);
     if(_bo_) return _bo_;
     l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[92], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0))){
      var
       pos1 = caml_call2(Base_Import[90], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[92], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[92], last_pos$0, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      last_pos$1 = last_pos$0;
      last_pos$0 = pos;
     }
     else{
      var pos$0 = caml_call2(Base_Import[92], last_pos$0, 1);
      last_pos$0 = pos$0;
     }
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _bm_ = caml_string_get(t, caml_call2(Base_Import[92], pos[1], 1));
      if(caml_call2(Base_Char[15], _bm_, 13)){var _bn_ = 2; break a;}
     }
     var _bn_ = 1;
    }
    pos[1] = caml_call2(Base_Import[92], pos[1], _bn_);
    eol[1] = caml_call2(Base_Import[90], pos[1], 1);
    return;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import[92], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _bi_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char[15], _bi_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var _bl_ = ac[1]; return [0, sub(t, 0, eol[1]), _bl_];}
     var _bj_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char[14], _bj_, 10))
      caml_call1(Base_Import[128], pos);
     else{
      var start = caml_call2(Base_Import[90], pos[1], 1), _bk_ = ac[1];
      ac[1] =
       [0, sub(t, start, caml_call2(Base_Import[92], eol[1], start)), _bk_];
      back_up_at_newline(t, pos, eol);
     }
    }
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[15]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[15]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[15]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _bf_ = sub(t, pos, len); return _bf_;}
     catch(_bh_){return on_error;}
    var
     _bg_ = caml_call2(symbol_concat, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[125], _bg_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[92], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     var last = match$0[1], _be_ = caml_call2(Base_Import[92], last, first);
     return sub(t, first, caml_call2(Base_Import[90], _be_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bc_ = caml_call2(Base_Import[92], l, 1),
     _bb_ = 0;
    if(_bc_ >= 0){
     var i = _bb_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _bd_ = i + 1 | 0;
      if(_bc_ === i) break;
      i = _bd_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _a$_ = caml_call2(Base_Import[92], l, 1),
     _a__ = 0;
    if(_a$_ >= 0){
     var i = _a__;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _ba_ = i + 1 | 0;
      if(_a$_ === i) break;
      i = _ba_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function to_array(s){
    return caml_call2
            (Base_Array0[11],
             caml_ml_string_length(s),
             function(i){return caml_string_get(s, i);});
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _a7_ = i < len ? 1 : 0;
     if(_a7_){
      var _a8_ = caml_call1(f, caml_string_get(s, i));
      if(! _a8_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _a9_ = _a8_;
     }
     else
      var _a9_ = _a7_;
     return _a9_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _a4_ = i === len ? 1 : 0;
     if(_a4_)
      var _a5_ = _a4_;
     else{
      var _a6_ = caml_call1(f, caml_string_get(s, i));
      if(_a6_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _a5_ = _a6_;
     }
     return _a5_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _a2_ = caml_call2(Base_Import[92], caml_ml_string_length(t), 1),
     _a1_ = 0;
    if(_a2_ >= 0){
     var i = _a1_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _a3_ = i + 1 | 0;
      if(_a2_ === i) break;
      i = _a3_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _aZ_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_a0_){return caml_call2(_aZ_, _a0_, t);};
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _aW_ = i < len ? 1 : 0;
     if(_aW_){
      var _aX_ = caml_call2(Base_Char[15], c, caml_string_unsafe_get(t, i));
      if(! _aX_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _aY_ = _aX_;
     }
     else
      var _aY_ = _aW_;
     return _aY_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[15], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[15], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_aV_){return _aV_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_aU_){return _aU_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _aT_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[29], c));
                         return caml_call2(Base_Char[14], c, _aT_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[29], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[15], ar));
   }
   function concat_map(sep, s, f){
    var _aS_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[20], _aS_, f));
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     caml_call1(Base_Import[129], i);
    }
    if(i[1] === n) return t;
    var
     _aQ_ = caml_call2(Base_Import[92], n, 1),
     out = caml_call1(Base_Bytes0[7], _aQ_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[129], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _aR_ = caml_call2(Base_Import[92], n, 1);
      return out_pos[1] === _aR_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[129], out_pos);
     }
     caml_call1(Base_Import[129], i);
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _aN_ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _aN_)) break;
     caml_call1(Base_Import[129], i);
    }
    if(i[1] === n) return t;
    var
     _aO_ = caml_call2(Base_Import[92], n, 1),
     out = caml_call1(Base_Bytes0[7], _aO_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[129], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _aP_ = caml_call2(Base_Import[92], n, 1);
      return out_pos[1] === _aP_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[129], out_pos);
     }
     caml_call1(Base_Import[129], i);
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _v_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _w_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[10], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _aM_ = caml_call2(Base_Import[92], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[92], _aM_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _aK_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _aL_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[15], _aL_, _aK_)) return len_so_far$0;
     var len_so_far$1 = caml_call2(Base_Import[90], len_so_far$0, 1);
     len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[100], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0);
     first$0 = second;
     list$0 = rest;
     max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[129], ppf, _x_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _aJ_ = caml_call1(Base_List[7], l),
     t = caml_call1(Base_Bytes0[7], _aJ_);
    caml_call2
     (Base_List[98], l, function(i, c){return caml_bytes_set(t, i, c);});
    return caml_call1(Base_Bytes0[16], t);
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[129][7], escapeworthy_map, Base_Char[15], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[29], c_to);
     else
      var k$0 = caml_call1(Base_Char[29], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _aB_ = caml_call1(Base_Char[29], v);
     if(caml_check_bound(vals, _aB_)[1 + _aB_]) break;
     var _aH_ = caml_call1(Base_Char[29], v);
     caml_check_bound(arr, k)[1 + k] = _aH_;
     var _aI_ = caml_call1(Base_Char[29], v);
     caml_check_bound(vals, _aI_)[1 + _aI_] = 1;
     param = l;
    }
    var
     _aC_ = caml_call2(Base_Import[149], Base_Import[140], Base_Import[140]),
     _aD_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[151], _aC_, escapeworthy_map$0)],
        0],
     _aE_ = [0, [0, cst_c_to, caml_call1(Base_Import[140], c_to)], _aD_],
     _aF_ = [0, [0, cst_c_from, caml_call1(Base_Import[140], c_from)], _aE_],
     _aG_ = caml_call2(Base_Sexp[9], cst_escapeworthy_map_not_one_t, _aF_);
    return caml_call1(Base_Or_error[35], _aG_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _aA_ = caml_call1(Base_Char[29], c),
                    n = caml_check_bound(escapeworthy, _aA_)[1 + _aA_];
                   return -1 === n
                           ? acc
                           : (caml_call1
                              (Base_Import[129], to_escape_len),
                             [0, [0, i, caml_call1(Base_Char[32], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[90], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_call1(Base_Bytes0[16], dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _ay_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[92], _ay_, 1),
               dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
               _az_ = caml_call2(Base_Import[90], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _az_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[90], last_dst_pos$1, 1),
                escaped_char);
              last_idx$0 = last_idx$1;
              last_dst_pos$0 = last_dst_pos$1;
              param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _ax_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _ax_));
   }
   function escape(escapeworthy, escape_char){
    var
     _aw_ = caml_call2(Base_List[114], escapeworthy, Base_Char[16]),
     escapeworthy_map =
       caml_call2(Base_List[76], _aw_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _ao_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[15], _ao_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[90], i, 1);
              i = i$0;
              status = status$0;
              to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _ap_ = caml_call1(Base_List[7], to_unescape),
              _aq_ =
                caml_call2(Base_Import[92], caml_ml_string_length(src), _ap_),
              dst = caml_call1(Base_Bytes0[7], _aq_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _ar_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[92], _ar_, 2),
                dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
                _as_ = caml_call2(Base_Import[90], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _as_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 1),
                _at_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[90], last_idx$1, 1)),
                _au_ = caml_call1(Base_Char[29], _at_),
                n = caml_check_bound(escapeworthy, _au_)[1 + _au_],
                _av_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[90], last_idx$1, 1))
                   : caml_call1(Base_Char[32], n);
               caml_bytes_set(dst, last_dst_pos$1, _av_);
               last_idx$0 = last_idx$1;
               last_dst_pos$0 = last_dst_pos$1;
               param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[92], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[92], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_call1(Base_Bytes0[16], dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _an_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _an_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[92], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _am_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[14], _am_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[90], cnt, 1),
        p$0 = caml_call2(Base_Import[92], p, 1);
       p = p$0;
       cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _al_ = caml_string_get(str, i);
    return caml_call2(Base_Char[15], _al_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _aj_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[121], _aj_, 2) ? 1 : 0,
     _ak_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[15], _ak_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _ah_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _ai_ = _ah_ || (pos < 0 ? 1 : 0);
    return _ai_ ? caml_call3(invalid_argf, _y_, function_name, 0) : _ai_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _af_ = -512962225 === status ? 1 : 0;
      if(_af_){
       var _ag_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[15], _ag_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[90], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var status$0 = update_escape_status(str, escape_char, i$0, status);
     i = i$0;
     status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _ab_ = [0, [0, cst_char, caml_call1(Base_Import[140], char$0)], 0],
     _ac_ = [0, [0, cst_pos, caml_call1(Base_Import[141], pos)], _ab_],
     _ad_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[140], escape_char)],
        _ac_],
     _ae_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _ad_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_index_from_exn_not_found, _ae_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[15], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[121], escape_chars, 2)){
      var _$_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[15], _$_, char$0)) return [0, pos$0];
     }
     var
      _aa_ = caml_call2(Base_Import[92], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[92], _aa_, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _X_ = [0, [0, cst_char$0, caml_call1(Base_Import[140], char$0)], 0],
     _Y_ = [0, [0, cst_pos$0, caml_call1(Base_Import[141], pos)], _X_],
     _Z_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[140], escape_char)],
        _Y_],
     ___ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _Z_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_rindex_from_exn_not_found, ___));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _V_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[92], len, last_pos)),
          acc];
      return caml_call1(Base_List[38], _V_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _W_ = -512962225 === status$0 ? 1 : 0;
     if(_W_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[92], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[90], pos, 1),
       last_pos$0 = caml_call2(Base_Import[90], pos, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      status = status$0;
      last_pos = last_pos$0;
      pos = pos$0;
      continue;
     }
     var pos$1 = caml_call2(Base_Import[90], pos, 1);
     status = status$0;
     pos = pos$1;
    }
   }
   function split$0(str, on){
    var _T_ = [0, -1044422954, on];
    return function(_U_){return split_gen$0(str, _U_, _T_);};
   }
   function split_on_chars$0(str, chars){
    var _R_ = [0, 552554919, chars];
    return function(_S_){return split_gen$0(str, _S_, _R_);};
   }
   function split_at(str, pos){
    var
     _O_ = caml_call2(Base_Import[92], caml_ml_string_length(str), pos),
     _P_ = caml_call2(Base_Import[92], _O_, 1),
     _Q_ = sub(str, caml_call2(Base_Import[90], pos, 1), _P_);
    return [0, sub(str, 0, pos), _Q_];
   }
   function lsplit2$0(str, on, escape_char){
    var _N_ = index$1(str, escape_char, on);
    return caml_call2
            (Base_Option[21], _N_, function(x){return split_at(str, x);});
   }
   function rsplit2$0(str, on, escape_char){
    var _M_ = rindex$0(str, escape_char, on);
    return caml_call2
            (Base_Option[21], _M_, function(x){return split_at(str, x);});
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _J_ = 1 - caml_call1(drop, c);
              if(_J_)
               var _K_ = _J_;
              else{
               var _L_ = is_char_escaping(t, escape_char, i);
               if(! _L_) return is_char_escaped(t, escape_char, i);
               var _K_ = _L_;
              }
              return _K_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _G_ = 1 - caml_call1(drop, c);
              if(_G_)
               var _H_ = _G_;
              else{
               var _I_ = is_char_escaping(t, escape_char, i);
               if(! _I_) return is_char_escaped(t, escape_char, i);
               var _H_ = _I_;
              }
              return _H_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$8;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$9;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$10;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
     var last = match$0[1], _F_ = caml_call2(Base_Import[92], last, first);
     return sub(t, first, caml_call2(Base_Import[90], _F_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _E_ = caml_call2(Base_Import[108][2], low, t);
    return _E_ ? caml_call2(Base_Import[108][2], t, high) : _E_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[108][1], t, min)
            ? min
            : caml_call2(Base_Import[108][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[108][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _B_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _C_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _B_],
     _D_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _C_);
    return caml_call1(Base_Or_error[35], _D_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   var
    include$1 = Base_Import[108],
    symbol$5 = include$1[1],
    symbol$6 = include$1[2],
    symbol$7 = include$1[3],
    symbol$8 = include$1[4],
    symbol$9 = include$1[5],
    symbol$10 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$1 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_String =
      [0,
       t_sexp_grammar,
       sub,
       subo,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$10,
       symbol$6,
       symbol$8,
       symbol$9,
       symbol$5,
       symbol$7,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       invariant,
       max_length,
       make,
       copy,
       init,
       symbol_concat,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map,
       mapi,
       foldi,
       concat_map,
       filter,
       filteri,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal$1,
       of_char,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
   runtime.caml_register_global(86, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    fill = Base_Bytes0[8],
    make = Base_Bytes0[9],
    map = Base_Bytes0[10],
    mapi = Base_Bytes0[11],
    unsafe_blit = Base_Bytes0[13],
    to_string = Base_Bytes0[14],
    of_string = Base_Bytes0[15],
    unsafe_to_string = Base_Bytes0[16],
    unsafe_of_string_promise_no_mu = Base_Bytes0[17],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _w_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[129], fmt, _a_, _w_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1], [0, caml_ml_bytes_length, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$1 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$1]),
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _c_ = [0, "src/bytes.ml", 128, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _u_ = caml_call2(Base_Import[92], n, 1),
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[7], l));
    caml_call2
     (Base_List[98], l, function(i, c){return caml_bytes_set(t, i, c);});
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     acc = acc$0;
    }
   }
   function to_array(t){
    return caml_call2
            (Base_Array0[11],
             caml_ml_bytes_length(t),
             function(i){return caml_bytes_unsafe_get(t, i);});
   }
   function map$0(t, f){return caml_call2(map, f, t);}
   function mapi$0(t, f){return caml_call2(mapi, f, t);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[15], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[29], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[109][2], low, t);
    return _k_ ? caml_call2(Base_Import[109][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[90], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[15], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    include$0 = Base_Import[109],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    equal = include$0[10],
    max = include$0[11],
    min = include$0[12],
    Base_Bytes =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       caml_bytes_set,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Assert_failure, Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Int0, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Base__Sys0, Base__Word_size, Sexplib0__Sexp_grammar, Stdlib__Int32, Stdlib__Int64, Stdlib__Lexing, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Printf = global_data.Base__Printf,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    Base_Sexp = global_data.Base__Sexp,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"];
   function convert_failure(x, a, b, to_string){
    var _P_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _P_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    _g_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _l_ = [0, cst_src_int_conversions_ml, 19, 9],
    _k_ = [0, cst_src_int_conversions_ml, 75, 9],
    _j_ = [0, cst_src_int_conversions_ml, 96, 9],
    _i_ = [0, cst_src_int_conversions_ml, 148, 9],
    _h_ = [0, cst_src_int_conversions_ml, 176, 9],
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15];
   function int32_to_int_trunc(_O_){return _O_;}
   function int_to_int32_trunc(_N_){return _N_;}
   var
    _b_ = Base_Import[84][32],
    _c_ = Stdlib_Int32[14],
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _L_ = caml_call2(Base_Import[228], min_int32, x) <= 0 ? 1 : 0,
          _M_ =
            _L_
             ? caml_call2(Base_Import[228], x, max_int32) <= 0 ? 1 : 0
             : _L_;
         return _M_;
        };
   if(32 <= num_bits_int)
    var _d_ = function(param){return 1;};
   else
    var
     min$1 = Base_Int0[6],
     max$1 = Base_Int0[5],
     _d_ =
       function(x){
        var
         _J_ = caml_call2(Base_Import[229], min$1, x) <= 0 ? 1 : 0,
         _K_ = _J_ ? caml_call2(Base_Import[229], x, max$1) <= 0 ? 1 : 0 : _J_;
        return _K_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){return _d_(x) ? [0, x] : 0;}
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return _d_(x) ? x : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min$4 = caml_int64_of_int32(Base_Int0[6]),
    max$4 = caml_int64_of_int32(Base_Int0[5]);
   function int64_is_representable_as_int(x){
    var
     _H_ = caml_call2(Base_Import[230], min$4, x) <= 0 ? 1 : 0,
     _I_ = _H_ ? caml_call2(Base_Import[230], x, max$4) <= 0 ? 1 : 0 : _H_;
    return _I_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64, cst_int$1, int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   function int_to_nativeint(_G_){return _G_;}
   function nativeint_to_int_trunc(_F_){return _F_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$0 = Base_Int0[6],
     max$0 = Base_Int0[5],
     _e_ =
       function(x){
        var
         _D_ = caml_call2(Base_Import[231], min$0, x) <= 0 ? 1 : 0,
         _E_ = _D_ ? caml_call2(Base_Import[231], x, max$0) <= 0 ? 1 : 0 : _D_;
        return _E_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$3 = caml_int64_of_int32(min_int32),
    max$3 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _B_ = caml_call2(Base_Import[230], min$3, x) <= 0 ? 1 : 0,
     _C_ = _B_ ? caml_call2(Base_Import[230], x, max$3) <= 0 ? 1 : 0 : _B_;
    return _C_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   function int32_to_nativeint(_A_){return _A_;}
   function nativeint_to_int32_trunc(_z_){return _z_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _x_ = caml_call2(Base_Import[231], min_int32, x) <= 0 ? 1 : 0,
          _y_ =
            _x_
             ? caml_call2(Base_Import[231], x, max_int32) <= 0 ? 1 : 0
             : _x_;
         return _y_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _v_ = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
         _w_ = _v_ ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : _v_;
        return _w_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min = caml_int64_shift_right(min_int64, 1),
    max = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _t_ = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     _u_ = _t_ ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : _t_;
    return _u_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[92], input_length, 1) : input_length,
     _q_ = caml_call2(Base_Import[92], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[94], _q_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[90], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[31], output_length),
     input_pos = [0, caml_call2(Base_Import[92], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[92], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign){
       var _s_ = caml_string_get(input, 0);
       caml_call3(Base_Bytes[39], output, 0, _s_);
      }
      return caml_call1(Base_Bytes[49], output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_call3(Base_Bytes[39], output, output_pos[1], delimiter);
      caml_call1(Base_Import[128], output_pos);
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _r_ = caml_string_get(input, input_pos[1]);
     caml_call3(Base_Bytes[39], output, output_pos[1], _r_);
     caml_call1(Base_Import[128], input_pos);
     caml_call1(Base_Import[128], output_pos);
     caml_call1(Base_Import[128], num_chars_until_delimiter);
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var
    sexp_of_int_style = Base_Sexp[19],
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       function(I){
        var compare = I[1], hash_fold_t = I[2], func = I[3];
        function hash(x){return caml_call1(func, x);}
        var chars_per_delimiter = 4;
        function to_string(delimiter, t){
         if(delimiter)
          var
           delimiter$0 = delimiter[1],
           make_suffix =
             function(t){
              return insert_delimiter_every
                      (caml_call1(I[4], t), delimiter$0, chars_per_delimiter);
             };
         else
          var make_suffix = I[4];
         if(caml_call2(I[7], t, I[6])){
          var _o_ = caml_call1(make_suffix, caml_call1(I[8], t));
          return caml_call2(Base_Import[111], cst_0x, _o_);
         }
         var _p_ = caml_call1(make_suffix, t);
         return caml_call2(Base_Import[111], cst_0x$0, _p_);
        }
        function to_string$0(t){return to_string(0, t);}
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return to_string([0, delimiter], t);
        }
        function invalid(str){
         return caml_call4(Base_Printf[6], _g_, I[9], str, 0);
        }
        function of_string_with_delimiter(str){
         var
          _n_ =
            caml_call2
             (Base_String[98],
              str,
              function(c){return caml_call2(Base_Char[14], c, 95);});
         return caml_call1(I[5], _n_);
        }
        function of_string(str){
         var
          lex = caml_call2(Stdlib_Lexing[3], 0, str),
          result =
            caml_call1
             (Base_Option[44],
              function(param){return caml_call1(Base_Hex_lexer[1], lex);});
         if(lex[6] !== lex[3]) return invalid(str);
         if(! result) return invalid(str);
         var match = result[1];
         if(0 === match[0]){
          var body = match[1], _m_ = of_string_with_delimiter(body);
          return caml_call1(I[8], _m_);
         }
         var body$0 = match[1];
         return of_string_with_delimiter(body$0);
        }
        var
         t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
         include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
         t_of_sexp = include[1],
         sexp_of_t = include[2];
        return [0,
                [0,
                 t_of_sexp,
                 sexp_of_t,
                 t_sexp_grammar,
                 compare,
                 hash_fold_t,
                 hash,
                 of_string,
                 to_string$0,
                 to_string_hum]];
       },
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (44, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[119], -1, 1),
    switcher = Base_Int_conversions[29] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 218, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _h_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else
    var
     int_positive_overflow_bounds =
       switcher
        ? caml_call2
          (Base_Array0[20],
           int32_positive_overflow_bounds,
           function(_i_){return _i_;})
        : _h_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati],
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[122], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[122], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var
    abs = Stdlib_Int64[8],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0);
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[95], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Assert_failure, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure;
   function int64_popcount(x$1){
    var
     x$0 =
       runtime.caml_int64_sub
        (x$1, caml_int64_and(caml_int64_shift_right_unsigne(x$1, 1), m1)),
     x =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x, caml_int64_shift_right_unsigne(x, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9], _b_ = [0, "src/popcount.ml", 45, 9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    all = Base_Sign0[6],
    Replace_polymorphic_compare = Base_Sign0[7],
    to_int = Base_Sign0[10],
    of_int = Base_Sign0[13],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[4],
         Base_Sign0[5],
         Base_Sign0[11],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[8],
         Base_Sign0[9],
         Base_Sign0[12]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24];
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[87], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    max = Replace_polymorphic_compare[11],
    min = Replace_polymorphic_compare[12],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(6, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare,
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function of_string$0(s){
    try{var _an_ = caml_call1(of_string, s); return _an_;}
    catch(_ao_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[29],
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"];
   function to_float(_am_){return _am_;}
   function of_float_unchecked(_al_){return _al_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _ak_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _b_, _ak_, 0);
   }
   var
    zero = 0,
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare$0 = Base_Import[228],
    hash_fold_t$0 = Base_Import[206],
    func$0 = Base_Import[220];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    neg = Base_Import[112],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x];
   function symbol(_aj_, _ai_){return _aj_ < _ai_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_ah_){return _ah_;});
   }
   var
    include$0 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1],
    _f_ = [0, "src/int.ml", 108, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _af_ = low <= t ? 1 : 0, _ag_ = _af_ ? t <= high ? 1 : 0 : _af_;
    return _ag_;
   }
   function clamp_unchecked(t, min, max){
    return t < min ? min : t <= max ? t : max;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _ac_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ad_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _ac_],
     _ae_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _ad_);
    return caml_call1(Base_Or_error[35], _ae_);
   }
   function pred(i){return caml_call2(Base_Import[92], i, 1);}
   function succ(i){return caml_call2(Base_Import[90], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[84][18],
    min_value = Base_Import[84][19],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[11],
    of_int64_exn = Base_Int_conversions[12],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[22],
    of_nativeint_exn = Base_Int_conversions[23],
    to_nativeint = Base_Int_conversions[5];
   function abs(x){return caml_call1(Base_Import[122], x);}
   function rem(a, b){return caml_call2(Base_Import[121], a, b);}
   function incr(_ab_){_ab_[1]++; return 0;}
   function decr(_aa_){_aa_[1]--; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[114], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[119], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_not(a){return caml_call1(Base_Import[116], a);}
   function bit_or(a, b){return caml_call2(Base_Import[117], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[115], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[120], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var
    raise_s = Base_Error[30],
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[92], x, 1),
     _W_ = caml_call2(Base_Import[119], x$0, 1),
     x$1 = caml_call2(Base_Import[117], x$0, _W_),
     _X_ = caml_call2(Base_Import[119], x$1, 2),
     x$2 = caml_call2(Base_Import[117], x$1, _X_),
     _Y_ = caml_call2(Base_Import[119], x$2, 4),
     x$3 = caml_call2(Base_Import[117], x$2, _Y_),
     _Z_ = caml_call2(Base_Import[119], x$3, 8),
     x$4 = caml_call2(Base_Import[117], x$3, _Z_),
     ___ = caml_call2(Base_Import[119], x$4, 16),
     x$5 = caml_call2(Base_Import[117], x$4, ___),
     _$_ = caml_call2(Base_Import[119], x$5, 32),
     x$6 = caml_call2(Base_Import[117], x$5, _$_);
    return caml_call2(Base_Import[90], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _P_ = caml_call2(Base_Import[119], x, 1),
     x$0 = caml_call2(Base_Import[117], x, _P_),
     _Q_ = caml_call2(Base_Import[119], x$0, 2),
     x$1 = caml_call2(Base_Import[117], x$0, _Q_),
     _R_ = caml_call2(Base_Import[119], x$1, 4),
     x$2 = caml_call2(Base_Import[117], x$1, _R_),
     _S_ = caml_call2(Base_Import[119], x$2, 8),
     x$3 = caml_call2(Base_Import[117], x$2, _S_),
     _T_ = caml_call2(Base_Import[119], x$3, 16),
     x$4 = caml_call2(Base_Import[117], x$3, _T_),
     _U_ = caml_call2(Base_Import[119], x$4, 32),
     x$5 = caml_call2(Base_Import[117], x$4, _U_),
     _V_ = caml_call2(Base_Import[119], x$5, 1);
    return caml_call2(Base_Import[92], x$5, _V_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _O_ = caml_call2(Base_Import[92], x, 1);
    return 0 === caml_call2(Base_Import[115], x, _O_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _L_ = [0, [0, cst, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _L_));
    }
    var
     _M_ = runtime.Base_int_math_int_clz(i),
     _N_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _N_, _M_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var _J_ = [0, [0, cst$0, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_ceil_log2_got_invalid_, _J_));
    }
    if(1 === i) return 0;
    var
     _K_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[92], i, 1));
    return caml_call2(Base_Import[92], num_bits, _K_);
   }
   var
    sign = Base_Sign[27],
    popcount = Base_Popcount[1],
    F =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string$0,
         to_string,
         function(_I_, _H_){return _I_ + _H_ | 0;},
         function(_G_, _F_){return _G_ - _F_ | 0;},
         runtime.caml_mul,
         caml_div,
         function(_E_){return - _E_ | 0;},
         function(_D_, _C_){return _C_ <= _D_ ? 1 : 0;},
         function(_B_, _A_){return _B_ <= _A_ ? 1 : 0;},
         function(_z_, _y_){return _z_ === _y_ ? 1 : 0;},
         function(_x_, _w_){return _w_ < _x_ ? 1 : 0;},
         function(_v_, _u_){return _v_ < _u_ ? 1 : 0;},
         function(_t_, _s_){return _t_ !== _s_ ? 1 : 0;},
         abs,
         function(_r_){return - _r_ | 0;},
         zero,
         of_int_exn,
         rem]),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8],
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"];
   function symbol$1(x, y){
    if(y <= 0){
     var _p_ = caml_call1(to_string, y), _q_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _h_, _q_, _p_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _n_ = caml_call1(to_string, y), _o_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _i_, _o_, _n_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[95], x, y);}
   var
    lnot = Base_Import[116],
    include$2 = Base_Import[96],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    Base_Int =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
       caml_int_compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       1,
       -1,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_int_clz(_k_);},
       function(_j_){return runtime.Base_int_math_int_ctz(_j_);},
       [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       1073741823,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       [0, [0, F[1], F[2], F[3]]]];
   runtime.caml_register_global(33, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Comparable, Base__Hash, Base__Import, Base__Pretty_printer, Base__Printf, Base__String, Base__Uchar0, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed";
   function hash_fold_t(state, t){
    var _s_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _s_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string(t){
    var _r_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _r_);
   }
   function sexp_of_t(t){return [0, to_string(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _p_ =
        caml_call3
         (Stdlib_Scanf[4],
          s,
          _b_,
          function(i){return caml_call1(Base_Uchar0[7], i);});
     return _p_;
    }
    catch(_q_){
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name, to_string])[1],
    _c_ = caml_call1(Base_Comparable[10], [0, compare, sexp_of_t]),
    between = _c_[13],
    clamp_exn = _c_[14],
    clamp = _c_[15],
    comparator = _c_[16],
    _d_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _e_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _f_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _g_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _o_ = caml_call1(Base_Uchar0[1], c); return _o_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function succ(c){
    try{var _m_ = [0, caml_call1(Base_Uchar0[1], c)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function pred_exn(c){
    try{var _k_ = caml_call1(Base_Uchar0[2], c); return _k_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _e_, msg, 0);
    }
   }
   function pred(c){
    try{var _i_ = [0, caml_call1(Base_Uchar0[2], c)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _f_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _g_, caml_call1(to_int, c), 0);
   }
   function utf8_byte_length(uchar){
    var codepoint = to_scalar(uchar);
    return 128 <= codepoint
            ? 2048 <= codepoint ? 65536 <= codepoint ? 4 : 3 : 2
            : 1;
   }
   var
    include = Base_Import[106],
    symbol = include[2],
    symbol$0 = include[3],
    symbol$1 = include[4],
    symbol$2 = include[5],
    symbol$3 = include[6],
    symbol$4 = include[7],
    ascending = include[8],
    descending = include[9],
    compare$0 = include[10],
    equal = include[11],
    max = include[12],
    min = include[13],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value,
       max_value];
   runtime.caml_register_global(19, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Error, Base__Import, Base__Int, Base__Option, Base__Sexp, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    some_t = [0, 0],
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Int = global_data.Base__Int,
    _a_ = [0, "T"];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var
    _b_ = [0, 0, 0],
    _c_ = [0, "type_witness"],
    cst_Key = "Key",
    _d_ = [0, "witness"],
    _e_ = [0, "name"],
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids";
   function sym(param){return 0;}
   function trans(param, _H_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, _G_){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _F_, _E_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _D_){return 0;}
   function Composition_preserves_injectiv(M1, M2){
    function strip(e){
     var _C_ = caml_call1(M2[1], e);
     return caml_call1(M1[1], _C_);
    }
    return [0, strip];
   }
   function sexp_of_t$0(param, _B_){
    var name = _B_[2], witness = _B_[1];
    if(Base_Import[131]) return [0, name];
    var
     t = witness[1],
     _A_ = caml_call1(Stdlib_Obj[22][1], t),
     v_005 = caml_call1(Stdlib_Obj[22][3], _A_);
    return [1,
            [0,
             [1, [0, _e_, [0, [0, name], 0]]],
             [0,
              [1,
               [0,
                _d_,
                [0,
                 [1, [0, _c_, [0, caml_call1(Base_Import[141], v_005), 0]]],
                 0]]],
              0]]];
   }
   function to_sexp(t){return t[3];}
   function name(t){return t[2];}
   function create(name, to_sexp){
    var Key = [248, cst_Key, runtime.caml_fresh_oo_id(0)];
    return [0, [0, Key], name, to_sexp];
   }
   function uid(t){
    var M = t[1], _z_ = caml_call1(Stdlib_Obj[22][1], M[1]);
    return caml_call1(Stdlib_Obj[22][3], _z_);
   }
   function hash(t){return uid(t);}
   function hash_fold_t(s, t){
    var _y_ = uid(t);
    return caml_call2(Base_Import[206], s, _y_);
   }
   function same_witness(t1, t2){
    var b = t2[1], a = t1[1];
    return a[1] === b[1] ? some_t : 0;
   }
   function same(t1, t2){
    var _x_ = same_witness(t1, t2);
    return caml_call1(Base_Option[50], _x_);
   }
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var w = match[1]; return w;}
    var
     _r_ = Base_Import[154],
     _s_ = Base_Import[154],
     _t_ =
       [0,
        [0,
         cst,
         caml_call3
          (Base_Import[149],
           function(_w_){return sexp_of_t$0(_s_, _w_);},
           function(_v_){return sexp_of_t$0(_r_, _v_);},
           [0, t1, t2])],
        0],
     _u_ = caml_call2(Base_Sexp[9], cst_Type_equal_Id_same_witness, _t_);
    return caml_call1(Base_Error[30], _u_);
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       0,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$0,
        [0,
         Base_Int[6],
         Base_Int[7],
         Base_Int[8],
         Base_Int[9],
         function(_q_, _p_){return _p_ <= _q_ ? 1 : 0;},
         function(_o_, _n_){return _o_ <= _n_ ? 1 : 0;},
         function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
         function(_k_, _j_){return _j_ < _k_ ? 1 : 0;},
         function(_i_, _h_){return _i_ < _h_ ? 1 : 0;},
         function(_g_, _f_){return _g_ !== _f_ ? 1 : 0;},
         Base_Int[12],
         Base_Int[13],
         Base_Int[14],
         Base_Int[15],
         Base_Int[16],
         Base_Int[17],
         Base_Int[18],
         Base_Int[19],
         Base_Int[20],
         Base_Int[21]],
        uid,
        create,
        hash,
        name,
        to_sexp,
        hash_fold_t,
        same,
        same_witness,
        same_witness_exn]];
   runtime.caml_register_global(15, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[12], 1),
    none = 24791911,
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]";
   function is_none(x){return caml_call2(Base_Import[127], x, none);}
   function is_some(x){return 1 - caml_call2(Base_Import[127], x, none);}
   function some(x){
    return caml_call2(Base_Import[127], x, none) ? none_substitute : x;
   }
   function value_unsafe(x){
    return caml_call2(Base_Import[127], x, none_substitute) ? none : x;
   }
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[123], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[6], Base_Option[7]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _w_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _w_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _v_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _v_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _t_ = caml_call1(Base_Option[3], a_sexp_grammar),
     _u_ = caml_call1(Sexplib0_Sexp_grammar[1], _t_);
    return caml_call1(Base_Uniform_array[3], _u_);
   }
   var empty = Base_Uniform_array[6];
   function create(len){return caml_call2(Base_Uniform_array[7], len, none);}
   function init(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return of_sexpable(caml_call1(f, i));});
   }
   function init_some(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return some(caml_call1(f, i));});
   }
   var _a_ = Base_Uniform_array[10];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[11], t, i));
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_none$0(t, i){
    return is_none(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[11], t, i));
   }
   function set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[13], t, i, _s_);
   }
   function set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[13], t, i, _r_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[13], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[15], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_set(t, i, x){
    var _q_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[14], t, i, _q_);
   }
   function unsafe_set_some(t, i, x){
    var _p_ = some(x);
    return caml_call3(Base_Uniform_array[14], t, i, _p_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[14], t, i, none);
   }
   function clear(t){
    var
     _m_ = caml_call1(_a_, t),
     _n_ = caml_call2(Base_Import[92], _m_, 1),
     _l_ = 0;
    if(_n_ >= 0){
     var i = _l_;
     for(;;){
      unsafe_set_none(t, i);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _o_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _i_ = caml_call1(_a_, input),
     _j_ = caml_call2(Base_Import[92], _i_, 1),
     _h_ = 0;
    if(_j_ >= 0){
     var i = _h_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _k_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _k_;
     }
    }
    return 0;
   }
   function _c_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _c_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _c_],
    iter =
      [0,
       -198771759,
       function(input, f){
        return _b_(input, function(param, x){return caml_call1(f, x);});
       }],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    length$0 = include$0[1],
    is_empty = include$0[2],
    iter$0 = include$0[3],
    fold$0 = include$0[4],
    fold_result = include$0[5],
    fold_until = include$0[6],
    exists = include$0[7],
    for_all = include$0[8],
    count = include$0[9],
    sum = include$0[10],
    find = include$0[11],
    find_map = include$0[12],
    to_list = include$0[13],
    min_elt = include$0[15],
    max_elt = include$0[16],
    foldi$0 = include$0[17],
    iteri$0 = include$0[18],
    existsi = include$0[19],
    for_alli = include$0[20],
    counti = include$0[21],
    findi = include$0[22],
    find_mapi = include$0[23];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _f_ = caml_call2(Base_Import[92], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[12], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    var _d_ = caml_call1(length$0, t);
    return caml_call2
            (Base_Array[27], _d_, function(i){return unsafe_get(t, i);});
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[30],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[33],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       length$0,
       is_empty,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Assert_failure, Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[30],
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _c_ = [0, cst_src_stack_ml, 46, 6],
    _d_ = [0, cst_src_stack_ml, 39, 4];
   function capacity(t){return caml_call1(Base_Option_array[6], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[6], elts)){
      var _B_ = caml_call2(Base_Import[92], length, 1), _A_ = 0;
      if(_B_ >= 0){
       var i$0 = _A_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[34], elts, i$0));
        var _G_ = i$0 + 1 | 0;
        if(_B_ === i$0) break;
        i$0 = _G_;
       }
      }
      var
       _C_ = caml_call1(Base_Option_array[6], elts),
       _D_ = caml_call2(Base_Import[92], _C_, 1);
      if(_D_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[36], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _F_ = i + 1 | 0;
        if(_D_ === i) break;
        i = _F_;
       }
      }
      var _E_ = 0;
      return _E_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[154],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[141], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _z_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Stack_invariant_failed, _z_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _w_ = caml_call2(Base_Import[92], t[1], 1);
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      var _x_ = caml_call2(Base_Option_array[34], t[2], i);
      r[1] = caml_call2(f, r[1], _x_);
      var _y_ = i - 1 | 0;
      if(0 === i) break;
      i = _y_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _u_ = caml_call2(Base_Import[92], t[1], 1);
    if(_u_ >= 0){
     var i = _u_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[34], t[2], i));
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      i = _v_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    _e_ = [0, cst_src_stack_ml, 107, 14];
   function of_list(l){
    if(caml_call1(Base_List[8], l)) return create(0);
    var
     length = caml_call1(Base_List[7], l),
     _r_ = caml_call2(Base_Import[87], 2, length),
     elts = caml_call1(Base_Option_array[5], _r_),
     r = [0, l],
     _s_ = caml_call2(Base_Import[92], length, 1);
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[42], elts, i, a);
      r[1] = l$0;
      var _t_ = i - 1 | 0;
      if(0 === i) break;
      i = _t_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _q_ = caml_call1(to_list, t);
    return caml_call2(Base_List[4], sexp_of_a, _q_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _p_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _p_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[51], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[99], new_capacity, t[1]),
     _o_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _o_ ? resize(t, new_capacity$0) : _o_;
   }
   function push(t, a){
    var _m_ = caml_call1(Base_Option_array[6], t[2]);
    if(t[1] === _m_){
     var _n_ = caml_call2(Base_Import[90], t[1], 1);
     resize(t, caml_call2(Base_Import[87], 2, _n_));
    }
    caml_call3(Base_Option_array[42], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[92], t[1], 1),
     result = caml_call2(Base_Option_array[34], t[2], i);
    caml_call2(Base_Option_array[43], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[12], "Stack.pop of empty stack");
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _l_ = caml_call2(Base_Import[92], t[1], 1);
    return caml_call2(Base_Option_array[34], t[2], _l_);
   }
   var top_error = caml_call1(Base_Error[12], "Stack.top of empty stack");
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[56], elts)];
   }
   function clear(t){
    var _g_ = 0 < t[1] ? 1 : 0;
    if(_g_){
     var _i_ = caml_call2(Base_Import[92], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       caml_call2(Base_Option_array[43], t[2], i);
       var _k_ = i + 1 | 0;
       if(_i_ === i) break;
       i = _k_;
      }
     }
     t[1] = 0;
     var _j_ = 0;
    }
    else
     var _j_ = _g_;
    return _j_;
   }
   function until_empty(t, f){
    for(;;){
     var _f_ = 0 < t[1] ? 1 : 0;
     if(! _f_) return _f_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Int = global_data.Base__Int,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _a_ = caml_call1(Base_Int[7], pos_cnum),
     _b_ = caml_call1(Base_Int[7], pos_bol),
     _c_ = caml_call1(Base_Int[7], pos_lnum),
     _d_ = runtime.Base_hash_string(pos_fname),
     _e_ = caml_call2(Base_Import[120], _d_, _c_),
     _f_ = caml_call2(Base_Import[120], _e_, _b_);
    return caml_call2(Base_Import[120], _f_, _a_);
   }
   var
    hash_fold_t = Base_Source_code_position0[3],
    comparator = Base_Source_code_position0[5],
    to_string = Base_Source_code_position0[7],
    sexp_of_t = Base_Source_code_position0[8],
    include = caml_call1(Base_Comparable[11], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _k_ = sexp_004[1];
      b:
      if(_k_ !== cst_Nan){
       c:
       if(_k_ !== cst_Neg){
        d:
        if(_k_ !== cst_Pos){
         if(_k_ !== cst_Zero){
          if(_k_ === cst_nan) break b;
          if(_k_ === cst_neg) break c;
          if(_k_ === cst_pos) break d;
          if(_k_ !== cst_zero) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _l_ = sexp_004[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _n_ = _m_[1];
     b:
     if(_n_ !== cst_Nan){
      c:
      if(_n_ !== cst_Neg){
       d:
       if(_n_ !== cst_Pos){
        if(_n_ !== cst_Zero){
         if(_n_ === cst_nan) break b;
         if(_n_ === cst_neg) break c;
         if(_n_ === cst_pos) break d;
         if(_n_ !== cst_zero) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      case 2:
       return caml_call2(Base_Hash[3], hsv, 2);
      default: return caml_call2(Base_Hash[3], hsv, 3);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24],
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan";
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[125], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[27], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[28], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[31], _g_, _f_));
    }
    return 3;
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(31, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    hash_fold_t = Base_Sexp[1],
    hash = Base_Sexp[2],
    t_of_sexp = Base_Sexp[3],
    sexp_of_t = Base_Sexp[4],
    Not_found_s = Base_Sexp[7],
    Of_sexp_error = Base_Sexp[8],
    message = Base_Sexp[9],
    default_indent = Base_Sexp[10],
    pp_hum = Base_Sexp[11],
    pp_hum_indent = Base_Sexp[12],
    pp_mach = Base_Sexp[13],
    pp = Base_Sexp[14],
    to_string_hum = Base_Sexp[15],
    to_string_mach = Base_Sexp[16],
    to_string = Base_Sexp[17],
    of_float_style = Base_Sexp[18],
    of_int_style = Base_Sexp[19],
    t_sexp_grammar = Base_Sexp[21],
    invariant = Base_Sexp[22],
    of_string = Base_Sexp[23],
    include = caml_call1(Base_Comparable[10], [0, Base_Sexp[6], Base_Sexp[4]]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator = include[16],
    Base_Sexp_with_comparable =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_027 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    _a_ = [0, 0, 0],
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc];
     l = l$0;
     acc = acc$0;
    }
    var
     _q_ = caml_call1(Base_List[38], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _r_ = caml_call2(Base_List[75], _q_, _a_);
    for(;;){
     if(! l$1){
      var _s_ = caml_call1(Base_List[38], acc$1);
      return caml_call2(Base_List[75], _s_, _r_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1];
     l$1 = l$2;
     acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _n_ = sexp_008[1];
      b:
      if(_n_ !== cst_Excl$0){
       c:
       if(_n_ !== cst_Incl$0){
        if(_n_ !== cst_Unbounded){
         if(_n_ === cst_excl) break b;
         if(_n_ === cst_incl) break c;
         if(_n_ !== cst_unbounded) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
     }
     var _o_ = sexp_008[1];
     if(! _o_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
     var _p_ = _o_[1];
     if(0 !== _p_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_008);
     var tag_009 = _p_[1];
     b:
     if(tag_009 !== cst_Excl$0){
      c:
      if(tag_009 !== cst_Incl$0){
       if(tag_009 !== cst_Unbounded){
        if(tag_009 === cst_excl) break b;
        if(tag_009 === cst_incl) break c;
        if(tag_009 !== cst_unbounded) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_008);
      }
      var sexp_args_010 = _o_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _o_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function interval_comparison_of_sexp(sexp_028){
    a:
    {
     if(0 === sexp_028[0]){
      var _j_ = sexp_028[1];
      b:
      if(_j_ !== cst_Above_upper_bound){
       c:
       if(_j_ !== cst_Below_lower_bound){
        if(_j_ !== cst_In_range){
         if(_j_ === cst_above_upper_bound) break b;
         if(_j_ === cst_below_lower_bound) break c;
         if(_j_ !== cst_in_range) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _k_ = sexp_028[1];
     if(! _k_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_028);
     var _l_ = _k_[1];
     if(0 !== _l_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_028);
     var _m_ = _l_[1];
     b:
     if(_m_ !== cst_Above_upper_bound){
      c:
      if(_m_ !== cst_Below_lower_bound){
       if(_m_ !== cst_In_range){
        if(_m_ === cst_above_upper_bound) break b;
        if(_m_ === cst_below_lower_bound) break c;
        if(_m_ !== cst_in_range) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_028);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var
    compare_interval_comparison = runtime.caml_int_compare,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound";
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[123], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(-1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(caml_call2(Base_Ppx_compare_lib[1], a_005, b_006)) return 1;
    if(typeof a_005 === "number"){
     if(-1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0],
    _c_ = [0, cst_Left$0],
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(caml_call2(Base_Ppx_compare_lib[1], t_014, t_016)) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(caml_call2(Base_Ppx_compare_lib[1], t_030, t_032)) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            atom_047 !== cst_Left$0
             ? atom_047
               !== cst_Right$0
               ? atom_047
                 !== cst_Unequal$0
                 ? caml_call1(Sexplib0_Sexp_conv_error[19], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(atom_047$0 !== cst_Left$0)
            if(atom_047$0 !== cst_Right$0)
             if(atom_047$0 !== cst_Unequal$0)
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[19], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[22],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[22],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[22],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[18])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[20], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[2], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar],
    _f_ = [0, "Both"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(caml_call2(Base_Ppx_compare_lib[1], a_085, b_086)) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(caml_call2(Base_Ppx_compare_lib[1], a_097, b_098)) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare,
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"];
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"];
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3];
   function Check_accessors(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors3(M){return [0];}
   function Check_accessors3_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators3_with_comparato(M){return [0];}
   var
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
   runtime.caml_register_global(26, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
//# unitInfo: Requires: Base__Map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data();
   global_data.Base__Map_intf;
   function Check_accessors(T, Tree, Elt, Named, Cmp, Options, symbol){return [0];
   }
   function Check_accessors0(M){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors2_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Elt, Cmp, Options, symbol){return [0];}
   function Check_creators0(M){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators2_with_comparato(M){return [0];}
   var
    Base_Set_intf =
      [0,
       Check_accessors,
       Check_accessors0,
       Check_accessors1,
       Check_accessors2,
       Check_accessors2_with_comparat,
       Check_creators,
       Check_creators0,
       Check_creators1,
       Check_creators2,
       Check_creators2_with_comparato];
   runtime.caml_register_global(1, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Comparator, Base__Container, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    with_return = Base_With_return[1],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    _a_ = [0, cst_src_set_ml, 199, 17],
    _b_ = [0, cst_src_set_ml, 200, 18],
    _c_ = [0, cst_src_set_ml, 206, 21],
    _d_ = [0, cst_src_set_ml, 208, 12],
    _e_ = [0, cst_src_set_ml, 214, 17],
    _f_ = [0, cst_src_set_ml, 215, 18],
    _g_ = [0, cst_src_set_ml, 221, 21],
    _h_ = [0, cst_src_set_ml, 223, 12];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bC_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bC_ = 1;
    if(_bC_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bD_ = 1;
    }
    else
     var _bD_ = _bC_;
    return _bD_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _br_ = caml_call2(Base_Import[92], hl, hr),
      _bs_ = caml_call1(Base_Import[122], _br_) <= 2 ? 1 : 0;
     if(_bs_){
      var
       _bt_ = caml_call2(Base_Import[99], hl, hr),
       _bu_ = h === caml_call2(Base_Import[90], _bt_, 1) ? 1 : 0;
      if(_bu_){
       var
        _bv_ = length(r),
        _bw_ = length(l),
        _bx_ = caml_call2(Base_Import[90], _bw_, _bv_),
        _by_ = n === caml_call2(Base_Import[90], _bx_, 1) ? 1 : 0;
       if(_by_){
        var _bz_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bz_){
         var _bA_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bA_){
          var lower$1 = [0, v$0];
          lower$0 = lower$1;
          t$0 = r;
          continue;
         }
         var _bB_ = _bA_;
        }
        else
         var _bB_ = _bz_;
       }
       else
        var _bB_ = _by_;
      }
      else
       var _bB_ = _bu_;
     }
     else
      var _bB_ = _bs_;
     return _bB_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(1 === h) return [0, v];
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    var _bq_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _bq_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[90], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[90], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _bo_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _bo_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      _bp_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _bp_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _bl_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bl_)){
       var
        next =
          function(i){
           var
            _bm_ = caml_call2(Base_Import[92], array_length, 1),
            _bn_ = caml_call2(Base_Import[92], _bm_, i);
           return caml_check_bound(array, _bn_)[1 + _bn_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bf_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bf_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _bh_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _bg_ = 1;
               if(_bh_ >= 1){
                var i$0 = _bg_;
                for(;;){
                 var
                  _bi_ = caml_call2(Base_Import[90], i$0, 1),
                  _bj_ = caml_check_bound(array, _bi_)[1 + _bi_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bj_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _bk_ = i$0 + 1 | 0;
                 if(_bh_ === i$0) break;
                 i$0 = _bk_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _a__ = height(lr);
     if(_a__ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _ba_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _ba_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _a$_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _a$_);
    }
    if(caml_call2(Base_Import[90], hl, 2) < hr){
     if(typeof r === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(0 === r[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var rr = r[3], rv = r[2], rl = r[1], _bb_ = height(rl);
     if(_bb_ <= height(rr)) return create(create(l, v, rl), rv, rr);
     if(typeof rl === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     if(0 !== rl[0]){
      var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bd_ = create(rlr, rv, rr);
      return create(create(l, v, rll), rlv$0, _bd_);
     }
     var rlv = rl[1];
     if(! is_empty(rr))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var _bc_ = create(0, rv, rr);
     return create(create(l, v, 0), rlv, _bc_);
    }
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    if(1 === h) return [0, v];
    var _be_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _be_, 1)];
   }
   var Same = [248, "Base__Set.Tree0.Same", caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      if(0 === c) throw caml_maybe_attach_backtrace(Same, 1);
      return 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) throw caml_maybe_attach_backtrace(Same, 1);
     return 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _a8_ = aux(t); return _a8_;}
    catch(_a9_){
     var _a7_ = caml_wrap_exception(_a9_);
     if(_a7_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a7_, 0);
    }
   }
   function join(l, v, r, compare_elt){
    if(typeof l === "number") return add(r, v, compare_elt);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rv = r[1];
       return add(add(l, v, compare_elt), rv, compare_elt);
      }
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r, compare_elt))
              : caml_call2
                 (Base_Import[90], lh, 2)
                < rh
                ? bal(join(l, v, rl, compare_elt), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add(l, v, compare_elt);
    var lv = l[1];
    return add(add(r, v, compare_elt), lv, compare_elt);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _i_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _j_ = [0, cst_src_set_ml, 296, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Set_min_elt_exn_of_empty_set,
     function(param){
      if(param === Set_min_elt_exn_of_empty_set) return _i_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     });
   var
    Set_max_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _k_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _l_ = [0, cst_src_set_ml, 309, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Set_max_elt_exn_of_empty_set,
     function(param){
      if(param === Set_max_elt_exn_of_empty_set) return _k_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     });
   var cst_Set_remove_min_elt = "Set.remove_min_elt", _m_ = [0, 0, 0, 0];
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1];
      t$0 = right;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3];
       param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[125], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _a6_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _a6_);
   }
   function concat(t1, t2, compare_elt){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _a5_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _a5_, compare_elt);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _m_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr, compare_elt), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r, compare_elt)];
    }
    return split(t);
   }
   var empty_without_value_restrictio = 0, _n_ = [0, 0, 0];
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _a4_ = 0 === c$0 ? 1 : 0;
     if(_a4_) return _a4_;
     var r$0 = 0 <= c$0 ? r : l;
     t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 !== t[0]){
      var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
      return 0 === c
              ? merge(l, r)
              : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
     }
     var v = t[1];
     if(0 === caml_call2(compare_elt, x, v)) return 0;
     throw caml_maybe_attach_backtrace(Same, 1);
    }
    try{var _a2_ = aux(t); return _a2_;}
    catch(_a3_){
     var _a1_ = caml_wrap_exception(_a3_);
     if(_a1_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a1_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 === t[0]){
      if(0 === i) return 0;
      throw caml_maybe_attach_backtrace(Same, 1);
     }
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _a0_ = caml_call2(Base_Import[92], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[92], _a0_, 1)));
    }
    try{var _aY_ = aux(t, i); return _aY_;}
    catch(_aZ_){
     var _aX_ = caml_wrap_exception(_aZ_);
     if(_aX_ === Same) return t;
     throw caml_maybe_attach_backtrace(_aX_, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2$0)) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1];
          s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _aV_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _aV_, compare_elt);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _aW_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _aW_, compare_elt);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
        s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    return caml_call3
            (Base_List[10],
             xs,
             empty_without_value_restrictio,
             function(ac, x){
              return union(ac, caml_call1(to_tree, x), compare_elt);
             });
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(caml_call2(Base_Import[127], s1, s2)) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _aS_ = split(s2, v1, compare_elt),
          match = _aS_[2],
          l2 = _aS_[1];
         if(match){
          var r2 = _aS_[3], v1$0 = match[1], _aT_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _aT_, compare_elt);
         }
         var r2$0 = _aS_[3], _aU_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _aU_, compare_elt);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2)) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _aP_ = split(s2, v1$0, compare_elt),
        l2 = _aP_[1];
       if(_aP_[2]){
        var r2 = _aP_[3], _aQ_ = diff(r1, r2);
        return concat(diff(l1, l2), _aQ_, compare_elt);
       }
       var r2$0 = _aP_[3], _aR_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _aR_, compare_elt);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
      s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, r, e$0];
     s$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, l, e$0];
     s$0 = r;
     e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _aO_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _aO_];
     return [0, next_state];
    }
    var _aM_ = of_set(t2), _aN_ = [0, of_set(t1), _aM_];
    return caml_call2(Base_Sequence[41], _aN_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aG_ = Base_Import[124],
      t$4 =
        caml_call3
         (Base_Option[31],
          less_or_equal_to,
          t$3,
          function(_aK_, _aL_){return inclusive_bound(_aG_, _aK_, _aL_);}),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0]){
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1];
        t = t$0;
       }
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key)){
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e];
         t = l;
         e = e$0;
        }
        else
         t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[41], init, next);
    }
    var
     _aH_ = Base_Import[126],
     t$5 =
       caml_call3
        (Base_Option[31],
         greater_or_equal_to,
         t$3,
         function(_aI_, _aJ_){return inclusive_bound(_aH_, _aI_, _aJ_);});
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0]){
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1];
       t$1 = t$2;
      }
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        t$1 = l$0;
       else{
        var r$1 = t$1[3], v$4 = t$1[2], e$2 = [0, v$4, l$0, e$1];
        t$1 = r$1;
        e$1 = e$2;
       }
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[41], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aD_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aE_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aF_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[56], _aF_, _aE_, _aD_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(caml_call2(Base_Import[127], r1, r2)){e1 = e1$0; e2 = e2$0;}
     else{
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0);
      e1 = e1$1;
      e2 = e2$1;
     }
    }
   }
   function iter2(s1, s2, compare_elt){
    var t2 = of_set(s2), t1 = of_set(s1);
    return function(f){
     a:
     {
      var t1$0 = t1, t2$0 = t2;
      for(;;){
       if(! t1$0) break;
       if(! t2$0) break a;
       var
        enum2 = t2$0[3],
        tree2 = t2$0[2],
        a2 = t2$0[1],
        enum1 = t1$0[3],
        tree1 = t1$0[2],
        a1 = t1$0[1],
        compare_result = caml_call2(compare_elt, a1, a2);
       if(0 === compare_result){
        caml_call1(f, [0, 737457313, [0, a1, a2]]);
        var t2$1 = cons(tree2, enum2), t1$1 = cons(tree1, enum1);
        t1$0 = t1$1;
        t2$0 = t2$1;
       }
       else if(0 <= compare_result){
        caml_call1(f, [0, -57574468, a2]);
        var t2$2 = cons(tree2, enum2);
        t2$0 = t2$2;
       }
       else{
        caml_call1(f, [0, 847852583, a1]);
        var t1$2 = cons(tree1, enum1);
        t1$0 = t1$2;
       }
      }
      return t2$0
              ? iter
                (function(a){return caml_call1(f, [0, -57574468, a]);}, t2$0)
              : 0;
     }
     return iter(function(a){return caml_call1(f, [0, 847852583, a]);}, t1$0);};
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aB_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aB_) return _aB_;
          s1$0 = l1;
          continue;
         }
         var _aC_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aC_) return _aC_;
         s1$0 = r1;
         continue;
        }
        var _ay_ = caml_call2(Base_Import[127], s1$0, s2$0);
        if(_ay_)
         var _az_ = _ay_;
        else{
         var _aA_ = is_subset(l1, l2);
         if(_aA_){s1$0 = r1; s2$0 = r2; continue;}
         var _az_ = _aA_;
        }
        return _az_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(caml_call2(Base_Import[127], s1$0, s2$0)) return 0;
         var _aw_ = split(s2$0, v1, compare_elt), l2 = _aw_[1];
         if(_aw_[2]) return 0;
         var r2 = _aw_[3], _ax_ = are_disjoint(l1, l2, compare_elt);
         if(! _ax_) return _ax_;
         s1$0 = r1;
         s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0);
     s$0 = r;
     accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f));
     s$0 = l;
     accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _at_ = caml_call1(p, v$0);
     if(_at_){
      var _au_ = for_all(l, p);
      if(_au_){t$0 = r; continue;}
      var _av_ = _au_;
     }
     else
      var _av_ = _at_;
     return _av_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aq_ = caml_call1(p, v$0);
     if(_aq_)
      var _ar_ = _aq_;
     else{
      var _as_ = exists(l, p);
      if(! _as_){t$0 = r; continue;}
      var _ar_ = _as_;
     }
     return _ar_;
    }
   }
   function filter(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v) ? add(accu$0, v, compare_elt) : accu$0;
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _ap_ = caml_call1(p, v$0) ? add(accu$0, v$0, compare_elt) : accu$0,
       accu$1 = filt(_ap_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return filt(0, s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ao_ = add(accu$0, v$2, compare_elt);
      else
       var _ao_ = accu$0;
      var accu$1 = filt(_ao_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p, compare_elt){
    function part(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      var f = accu$0[2], t = accu$0[1];
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v)
               ? [0, add(t, v, compare_elt), f]
               : [0, t, add(f, v, compare_elt)];
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _an_ =
         caml_call1(p, v$0)
          ? [0, add(t, v$0, compare_elt), f]
          : [0, t, add(f, v$0, compare_elt)],
       accu$1 = part(_an_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return part(_n_, s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)];
     accu$0 = accu$1;
     param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var
    not_found = [0, Base_Import[251], [0, "Set.choose_exn: empty set"]],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    _o_ = [0, cst_src_set_ml, 1047, 8],
    _p_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ";
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    return caml_call3
            (Base_List[10],
             lst,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_sequence(sequence, compare_elt){
    return caml_call3
            (Base_Sequence[8],
             sequence,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_array(a, compare_elt){
    return caml_call3
            (Base_Array[10],
             a,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[25], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _al_ = pos_ref[1];
       caml_check_bound(res, _al_)[1 + _al_] = v;
       return caml_call1(Base_Import[129], pos_ref);
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _am_ = pos_ref[1];
      caml_check_bound(res, _am_)[1 + _am_] = v$0;
      caml_call1(Base_Import[129], pos_ref);
      param$0 = r;
     }
    }
    loop(l);
    caml_call1(Base_Import[129], pos_ref);
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv, compare_elt){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var x = choose_exn(set$0);
     let x$0 = x;
     var
      match =
        partition_tf
         (set$0,
          function(elt){
           var _ak_ = caml_call2(Base_Import[127], x$0, elt);
           return _ak_ ? _ak_ : caml_call2(equiv, x$0, elt);
          },
          compare_elt),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes];
     set$0 = not_equiv_x;
     equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[123], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _aj_ = caml_call2(Base_Import[92], i$0, l_size),
       i$1 = caml_call2(Base_Import[92], _aj_, 1);
      t$0 = r;
      i$0 = i$1;
     }
     else
      t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[38], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      xs$0 = tl;
     else{
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers];
      xs$0 = tl;
      leftovers = leftovers$0;
      already_seen = already_seen$0;
     }
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[76], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _ai_ = caml_call1(Base_List[7], lst);
    if(length(set) === _ai_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    caml_call3
     (Base_List[42],
      lst,
      elt_lst,
      function(el_sexp, el){
       return mem(set$0[1], el, compare_elt)
               ? caml_call2
                 (Base_Import[158], cst_Set_t_of_sexp_duplicate_el, el_sexp)
               : (set$0[1] = add(set$0[1], el, compare_elt), 0);
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _p_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _af_ = caml_call2(Base_Import[111], cst_is_not_a_subset_of, superset[2]),
     _ag_ = caml_call2(Base_Import[111], subset[2], _af_),
     _ah_ =
       caml_call2
        (Base_Sexp[9],
         _ag_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[35], _ah_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function invariants$0(t){
    var _ae_ = compare_elt(t);
    return invariants(t[2], _ae_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list(t){var s = t[2]; return elements(s);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _ac_ = t[2];
    return function(_ad_){return fold_until(_ac_, init, f, _ad_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ab_ = compare_elt(a);
    return iter2(a[2], b[2], _ab_)(f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _aa_ = compare_elt(t); return mem(t[2], a, _aa_);}
   function filter$0(t, f){
    var _$_ = compare_elt(t);
    return like(t, filter(t[2], f, _$_));
   }
   function add$0(t, a){
    var ___ = compare_elt(t);
    return like(t, add(t[2], a, ___));
   }
   function remove$0(t, a){
    var _Z_ = compare_elt(t);
    return like(t, remove(t[2], a, _Z_));
   }
   function union$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _Y_));
   }
   function inter$0(t1, t2){
    var _X_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _X_));
   }
   function diff$0(t1, t2){
    var _W_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _W_));
   }
   function symmetric_diff$0(t1, t2){
    var _V_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _V_);
   }
   function compare_direct(t1, t2){
    var _T_ = t2[2], _U_ = t1[2];
    return compare(compare_elt(t1), _U_, _T_);
   }
   function equal$0(t1, t2){
    var _S_ = compare_elt(t1);
    return equal(t1[2], t2[2], _S_);
   }
   function is_subset$1(t, of){
    var _R_ = compare_elt(t);
    return is_subset(t[2], of[2], _R_);
   }
   function are_disjoint$0(t1, t2){
    var _Q_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _Q_);
   }
   function to_named_tree(param){
    var name = param[2], set = param[1];
    return [0, set[2], name];
   }
   function is_subset$2(subset, superset){
    var
     _N_ = compare_elt(subset[1]),
     _O_ = subset[1][1][2],
     _P_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _P_, _O_, _N_);
   }
   function equal$1(t1, t2){
    var
     _L_ = [0, is_subset$2(t2, t1), 0],
     _M_ = [0, is_subset$2(t1, t2), _L_];
    return caml_call1(Base_Or_error[47], _M_);
   }
   function partition_tf$0(t, f){
    var
     _J_ = compare_elt(t),
     match = partition_tf(t[2], f, _J_),
     tree_f = match[2],
     tree_t = match[1],
     _K_ = like(t, tree_f);
    return [0, like(t, tree_t), _K_];
   }
   function split$0(t, a){
    var
     _H_ = compare_elt(t),
     match = split(t[2], a, _H_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _I_ = like(t, tree2);
    return [0, like(t, tree1), b, _I_];
   }
   function group_by$0(t, equiv){
    var _E_ = compare_elt(t), _F_ = group_by(t[2], equiv, _E_);
    return caml_call2(Base_List[76], _F_, function(_G_){return like(t, _G_);});
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _D_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _D_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _C_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _C_), hash_fold_elem);
   }
   function compare$0(param, _B_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$0(t){return elements(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f){
    return function(_A_){return fold_until(t, init, f, _A_);};
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(comparator, t, f){return filter(t, f, comparator[1]);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(comparator, t, f){
    return partition_tf(t, f, comparator[1]);
   }
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1])(f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_z_){return _z_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(comparator, t, equiv){
    return group_by(t, equiv, comparator[1]);
   }
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _x_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _y_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _x_];
    return caml_call1(Base_Or_error[47], _y_);
   }
   var Named = [0, is_subset$4, equal$3], _q_ = [0, "_"];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    var tree = t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
    return [0, comparator, tree];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    var tree = union_list(comparator, to_tree$0, l);
    return [0, comparator, tree];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    var tree = of_increasing_iterator_uncheck(len, f);
    return [0, comparator, tree];
   }
   function of_sorted_array$1(comparator, array){
    var _w_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[18][2],
             _w_,
             function(tree){return [0, comparator, tree];});
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function empty$1(m){
    var comparator = m[1];
    return [0, comparator, empty_without_value_restrictio];
   }
   function singleton$1(m, a){return singleton$0(m[1], a);}
   function union_list$2(m, a){return union_list$1(m[1], a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_list$2(m, a){return of_list$1(m[1], a);}
   function of_sequence$2(m, a){return of_sequence$1(m[1], a);}
   function of_array$2(m, a){return of_array$1(m[1], a);}
   function stable_dedup_list$2(m, a){return stable_dedup_list$1(m[1], a);}
   function map$2(m, a, f){return map$1(m[1], a, f);}
   function filter_map$2(m, a, f){return filter_map$1(m[1], a, f);}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){
     return sexp_of_t$0(Elt[1], function(param){return _q_;}, t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _v_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _v_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt){
    return function(state){
     var _t_ = Elt[1];
     return function(_u_){return hash_fold_direct(_t_, state, _u_);};};
   }
   function hash_m_t(folder, t){
    var
     _s_ = caml_call2(Base_Hash[11], 0, 0),
     state = caml_call1(hash_fold_m_t(folder)(_s_), t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$1(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _r_ = Base_Sequence[55],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _r_[1], _r_[3], _r_[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$1],
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         Named,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$0,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio]];
   runtime.caml_register_global(45, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare = Base_Import[237],
    equal = Base_Import[250],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[191], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    return caml_call2
            (Base_Exn[13], f, function(param){t[1] = restore_to; return 0;});
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[9], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[76], and_values, snapshot);
    sets(and_values);
    return caml_call2
            (Base_Exn[13], f, function(param){return sets(restore_to);});
   }
   var
    Base_Ref =
      [0,
       compare,
       equal,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"],
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    _g_ = [0, cst_src_queue_ml, 165, 9],
    _h_ = [0, cst_src_queue_ml, 159, 2],
    _i_ = [0, cst_src_queue_ml, 158, 2],
    _j_ = [0, cst_src_queue_ml, 157, 2],
    _k_ = [0, cst_src_queue_ml, 156, 2],
    _l_ = [0, cst_src_queue_ml, 155, 2],
    _m_ = [0, cst_src_queue_ml, 153, 2],
    _n_ = [0, cst_src_queue_ml, 152, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _o_ = [0, cst_src_queue_ml, 193, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length";
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return;
   }
   function capacity(t){return caml_call2(Base_Import[90], t[3], 1);}
   function elts_index(t, i){
    var _aX_ = t[3], _aY_ = caml_call2(Base_Import[90], t[2], i);
    return caml_call2(Base_Import[115], _aY_, _aX_);
   }
   function unsafe_get(t, i){
    var _aW_ = elts_index(t, i);
    return caml_call2(Base_Option_array[38], t[5], _aW_);
   }
   function unsafe_set(t, i, a){
    var _aV_ = elts_index(t, i);
    return caml_call3(Base_Option_array[49], t[5], _aV_, a);
   }
   function check_index_exn(t, i){
    var _aQ_ = i < 0 ? 1 : 0, _aR_ = _aQ_ || (t[4] <= i ? 1 : 0);
    if(! _aR_) return _aR_;
    var
     _aS_ = [0, [0, cst_length, caml_call1(Base_Int[9], t[4])], 0],
     _aT_ = [0, [0, cst_index, caml_call1(Base_Int[9], i)], _aS_],
     _aU_ = caml_call2(Base_Sexp[9], cst_Queue_index_out_of_bounds, _aT_);
    return caml_call1(Base_Error[30], _aU_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aO_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aO_) return _aO_;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = t[1],
     front_005 = t[2],
     mask_007 = t[3],
     length_009 = t[4],
     elts_011 = t[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[141], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[141], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[141], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[141], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aP_ =
       caml_call2
        (Base_Sexp[9],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], 0]);
    return caml_call1(Base_Error[30], _aP_);
   }
   function compare(compare_elt, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aN_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aN_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
    }
   }
   function equal(equal_elt, t1, t2){
    var _aK_ = caml_call2(Base_Import[127], t1, t2);
    if(_aK_)
     var _aL_ = _aK_;
    else{
     var len1 = t1[4], len2 = t2[4], _aM_ = len1 === len2 ? 1 : 0;
     if(_aM_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aH_ = pos === len1 ? 1 : 0;
       if(_aH_)
        var _aI_ = _aH_;
       else{
        var
         _aJ_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aJ_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[90], pos, 1);
         pos = pos$0;
         continue;
        }
        var _aI_ = b;
       }
       return _aI_;
      }
     }
     var _aL_ = _aM_;
    }
    return _aL_;
   }
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[6], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[67], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aF_ = caml_call2(Base_Import[92], capacity$0, 1), _aE_ = 0;
    if(_aF_ >= 0){
     var i = _aE_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aD_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[40], t[5], _aD_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aG_ = i + 1 | 0;
      if(_aF_ === i) break;
      i = _aG_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _az_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[63], capacity$0);
     else
      var
       _aB_ = [0, [0, cst_capacity, caml_call1(Base_Int[9], capacity$0)], 0],
       _aC_ = caml_call2(Base_Sexp[9], cst_cannot_have_queue_with_neg, _aB_),
       _az_ = caml_call1(Base_Error[30], _aC_);
     var capacity$1 = _az_;
    }
    else
     var capacity$1 = 1;
    var _aA_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[92], capacity$1, 1), 0, _aA_];
   }
   function blit_to_array(src, dst){
    var _av_ = caml_call1(Base_Option_array[6], dst);
    if(src[4] > _av_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aw_ = src[2],
     _ax_ = capacity(src),
     _ay_ = caml_call2(Base_Import[92], _ax_, _aw_),
     front_len = caml_call2(Base_Int[14], src[4], _ay_),
     rest_len = caml_call2(Base_Import[92], src[4], front_len);
    caml_call5(Base_Option_array[51], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[51], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _ar_ = caml_call2(Base_Import[99], desired_capacity, t[4]),
     _as_ = caml_call2(Base_Import[99], 1, _ar_),
     new_capacity = caml_call1(Base_Int[63], _as_),
     _at_ = new_capacity !== capacity(t) ? 1 : 0;
    if(_at_){
     var dst = caml_call1(Base_Option_array[5], new_capacity);
     blit_to_array(t, dst);
     t[2] = 0;
     t[3] = caml_call2(Base_Import[92], new_capacity, 1);
     t[5] = dst;
     var _au_ = 0;
    }
    else
     var _au_ = _at_;
    return _au_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _aq_ = capacity(t);
    if(t[4] === _aq_) set_capacity(t, caml_call2(Base_Import[87], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[90], t[4], 1);
    return 0;
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[34], elts, front);
    caml_call2(Base_Option_array[43], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[92], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function front_nonempty(t){
    return caml_call2(Base_Option_array[38], t[5], t[2]);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[92], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function clear(t){
    inc_num_mutations(t);
    var _al_ = 0 < t[4] ? 1 : 0;
    if(_al_){
     var _an_ = caml_call2(Base_Import[92], t[4], 1), _am_ = 0;
     if(_an_ >= 0){
      var i = _am_;
      for(;;){
       var _ak_ = elts_index(t, i);
       caml_call2(Base_Option_array[50], t[5], _ak_);
       var _ap_ = i + 1 | 0;
       if(_an_ === i) break;
       i = _ap_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _ao_ = 0;
    }
    else
     var _ao_ = _al_;
    return _ao_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _W_ = [0, [0, cst_length$0, caml_call1(Base_Int[9], len$0)], 0],
       _X_ = caml_call2(Base_Sexp[9], cst_Queue_blit_transfer_negati, _W_);
      caml_call1(Base_Error[30], _X_);
     }
     var len$1 = caml_call2(Base_Import[100], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _Y_ = 0 < len$1 ? 1 : 0;
    if(_Y_){
     var
      _Z_ = caml_call2(Base_Import[90], dst[4], len$1),
      ___ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[99], ___, _Z_));
     var
      dst_start = caml_call2(Base_Import[90], dst[2], dst[4]),
      _aa_ = caml_call2(Base_Import[92], len$1, 1),
      _$_ = 0;
     if(_aa_ >= 0){
      var i = _$_;
      for(;;){
       var
        _ae_ = src[3],
        _af_ = caml_call2(Base_Import[90], src[2], i),
        src_i = caml_call2(Base_Import[115], _af_, _ae_),
        _ag_ = dst[3],
        _ah_ = caml_call2(Base_Import[90], dst_start, i),
        dst_i = caml_call2(Base_Import[115], _ah_, _ag_),
        _ai_ = caml_call2(Base_Option_array[38], src[5], src_i);
       caml_call3(Base_Option_array[49], dst[5], dst_i, _ai_);
       caml_call2(Base_Option_array[50], src[5], src_i);
       var _aj_ = i + 1 | 0;
       if(_aa_ === i) break;
       i = _aj_;
      }
     }
     dst[4] = caml_call2(Base_Import[90], dst[4], len$1);
     var _ab_ = src[3], _ac_ = caml_call2(Base_Import[90], src[2], len$1);
     src[2] = caml_call2(Base_Import[115], _ac_, _ab_);
     src[4] = caml_call2(Base_Import[92], src[4], len$1);
     var _ad_ = 0;
    }
    else
     var _ad_ = _Y_;
    return _ad_;
   }
   function enqueue_all(t, l){
    var
     _T_ = caml_call1(Base_List[7], l),
     _U_ = caml_call2(Base_Import[90], t[4], _T_),
     _V_ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[15], _V_, _U_));
    return caml_call2(Base_List[9], l, function(x){return enqueue(t, x);});
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _Q_ = caml_call2(Base_Import[92], t[4], 1),
     _P_ = 0;
    if(_Q_ >= 0){
     var i = _P_;
     for(;;){
      var _R_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _R_);
      ensure_no_mutation(t, num_mutations);
      var _S_ = i + 1 | 0;
      if(_Q_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _N_ = caml_call2(Base_Import[92], t[4], 1),
     _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _K_ = caml_call2(Base_Import[92], t[4], 1),
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _G_ = caml_call2(Base_Import[92], t[4], 1);
    if(_G_ >= 0){
     var i = _G_;
     for(;;){
      var _H_ = result[1];
      result[1] = [0, unsafe_get(t, i), _H_];
      var _I_ = i - 1 | 0;
      if(0 === i) break;
      i = _I_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 451, 2];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _F_ = caml_call1(f, a);
       return caml_call2
               (Base_List[9], _F_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _E_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[9], _E_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _D_ = caml_call1(f, a);
       return _D_ ? enqueue(t_result, a) : _D_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _C_ = caml_call2(f, i, a);
       return _C_ ? enqueue(t_result, a) : _C_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[7], l)], 0);
    caml_call2(Base_List[9], l, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _w_ = [0, [0, cst_length$1, caml_call1(Base_Int[9], len)], 0],
      _x_ = caml_call2(Base_Sexp[9], cst_Queue_init_negative_length, _w_);
     caml_call1(Base_Error[30], _x_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[6], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _z_ = caml_call2(Base_Import[92], len, 1), _y_ = 0;
    if(_z_ >= 0){
     var i = _y_;
     for(;;){
      var _A_ = caml_call1(f, i);
      caml_call3(Base_Option_array[49], t[5], i, _A_);
      var _B_ = i + 1 | 0;
      if(_z_ === i) break;
      i = _B_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_v_){return a[1 + _v_];});
   }
   function to_array(t){
    return caml_call2
            (Base_Array[27], t[4], function(i){return unsafe_get(t, i);});
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _t_ = caml_call2(Base_Import[92], ta[4], 1), _s_ = 0;
    if(_t_ >= 0){
     var i = _s_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[49], tb[5], i, b);
      var _u_ = i + 1 | 0;
      if(_t_ === i) break;
      i = _u_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(0, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _r_ = to_list(t);
    return caml_call1(caml_call1(Base_List[4], sexp_of_a), _r_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _q_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _q_);
   }
   var
    Base_Queue =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       invariant,
       create,
       last,
       last_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity];
   runtime.caml_register_global(38, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Match_failure, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, "src/nothing.ml", 6, 25];
   function unreachable_code(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   var
    cst_Base_Nothing_t = "Base.Nothing.t",
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported";
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[26], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[123], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24],
    Base_Nothing =
      [0,
       0,
       t_sexp_grammar,
       unreachable_code,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    include = Base_Import[103],
    compare = include[9],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[103][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    comparator = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare$1 = Base_Import[231],
    hash_fold_t$0 = Base_Import[202],
    func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(_Q_){return - _Q_ | 0;}
   var
    symbol = Base_Import[103][1],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _c_, function(_P_){return _P_;});
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$1,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _d_, _z_, 0);
   }
   var
    raise_s = Base_Error[30],
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    _f_ = [0, "src/nativeint.ml", 202, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$6 = x$0 | x$0 >>> 1 | 0,
     x$5 = x$6 | x$6 >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[103][2], x$0, 0)) non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$5 = x | x >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var _y_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[103][4], _y_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _v_ = [0, [0, cst, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_floor_log2_got_i, _v_));
    }
    var
     _w_ = runtime.Base_int_math_nativeint_clz(i),
     _x_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _x_, _w_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _t_ = [0, [0, cst$0, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_ceil_log2_got_in, _t_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _u_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[92], num_bits, _u_);
   }
   function between(t, low, high){
    var _s_ = caml_call2(Base_Import[103][2], low, t);
    return _s_ ? caml_call2(Base_Import[103][2], t, high) : _s_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[103][1], t, min)
            ? min
            : caml_call2(Base_Import[103][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[103][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[103][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _p_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _q_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _p_],
     _r_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _q_);
    return caml_call1(Base_Or_error[35], _r_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_o_, _n_){return _o_ - _n_ | 0;}
   function symbol$4(_m_, _l_){return _m_ + _l_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[22],
    to_int_exn = Base_Int_conversions[23],
    to_int_trunc = Base_Int_conversions[24],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[25],
    to_int32_exn = Base_Int_conversions[26],
    to_int32_trunc = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[17],
    of_int64_exn = Base_Int_conversions[18],
    of_int64_trunc = Base_Int_conversions[19],
    to_int64 = Base_Int_conversions[28];
   function pow(b, e){
    var _j_ = caml_call1(to_int_exn, e), _k_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _k_, _j_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var
    _g_ = Base_Import[103],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[103],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$2 = include$4[9],
    equal = include$4[10],
    max = include$4[11],
    min = include$4[12],
    Base_Nativeint =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_nativeint_clz(_i_);},
       function(_h_){return runtime.Base_int_math_nativeint_ctz(_h_);},
       [0,
        symbol$4,
        symbol$3,
        symbol$2,
        symbol$1,
        symbol$0,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$0,
        zero$1,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       to_int32_trunc,
       of_int64_trunc,
       runtime.caml_int32_bswap];
   runtime.caml_register_global(34, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    name = "alist",
    name$0 = "sequence",
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4];
   function of_continue_or_stop(_dh_){return _dh_;}
   function to_continue_or_stop(_dg_){return _dg_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _df_ = param[1];
    if(737457313 === _df_)
     var left = param[2][1];
    else{if(847852583 > _df_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _de_ = param[1];
    if(737457313 === _de_)
     var right = param[2][2];
    else{if(847852583 <= _de_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dd_ = t[1];
    if(737457313 === _dd_)
     var left = t[2][1];
    else{if(847852583 > _dd_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dc_ = t[1];
    if(737457313 === _dc_)
     var right = t[2][2];
    else{if(847852583 <= _dc_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _db_ = t[1];
    if(737457313 === _db_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _db_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, "Base__Map.Duplicate", caml_fresh_oo_id(0)],
    _a_ = [0, "map.ml.Duplicate"],
    _b_ = [0, cst_src_map_ml, 67, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Duplicate,
     function(param){
      if(param === Duplicate) return _a_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     });
   var
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_Map_bal = cst_Map_bal$3,
    _c_ = [0, cst_src_map_ml, 196, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 210, 18],
    cst_Map_bal$2 = cst_Map_bal$3;
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _c$_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _c$_ = 1;
    if(_c$_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _da_ = 1;
    }
    else
     var _da_ = _c$_;
    return _da_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _c4_ = caml_call2(Base_Import[92], hl, hr),
      _c5_ = caml_call1(Base_Import[122], _c4_) <= 2 ? 1 : 0;
     if(_c5_){
      var
       _c6_ = caml_call2(Base_Import[99], hl, hr),
       _c7_ = h === caml_call2(Base_Import[90], _c6_, 1) ? 1 : 0;
      if(_c7_){
       var _c8_ = in_range(lower$0, upper, compare_key, k$0);
       if(_c8_){
        var _c9_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_c9_){
         var lower$1 = [0, k$0];
         lower$0 = lower$1;
         t$0 = r;
         continue;
        }
        var _c__ = _c9_;
       }
       else
        var _c__ = _c8_;
      }
      else
       var _c__ = _c7_;
     }
     else
      var _c__ = _c5_;
     return _c__;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _c3_ =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    return [1, l, x, d, r, _c3_];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[90], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _c1_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _c1_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      v = match[2],
      k = match[1],
      _c2_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _c2_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _cZ_ = caml_call2(Base_Import[92], array_length, 1),
            _c0_ = caml_call2(Base_Import[92], _cZ_, i);
           return caml_check_bound(array, _c0_)[1 + _c0_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _cP_ = caml_check_bound(array, 1)[2],
                _cQ_ = caml_call1(Base_Import[124], _cP_),
                _cR_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[124], _cR_), _cQ_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _cT_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _cS_ = 1;
               if(_cT_ >= 1){
                var i$0 = _cS_;
                for(;;){
                 var
                  _cU_ = caml_call2(Base_Import[90], i$0, 1),
                  _cV_ = caml_check_bound(array, _cU_)[1 + _cU_],
                  _cW_ = caml_call1(Base_Import[124], _cV_),
                  _cX_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[124], _cX_), _cW_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _cY_ = i$0 + 1 | 0;
                 if(_cT_ === i$0) break;
                 i$0 = _cY_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_key)];
              });
    return [0, of_sorted_array_unchecked(array, compare_key)];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[125], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _cJ_ = height(lr);
     if(_cJ_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[125], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _cK_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _cK_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _cL_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _cL_);
    }
    if(caml_call2(Base_Import[90], hl, 2) >= hr) return create(l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _cM_ = height(rl);
    if(_cM_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _cN_ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _cN_);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _cO_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _cO_);
   }
   var
    empty_without_value_restrictio = 0,
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    _e_ = [1, 0],
    cst_Map_singleton_to_tree_exn_ =
      "Map.singleton_to_tree_exn: not a singleton",
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    _f_ = [0, 0, 0, 0],
    _g_ = [0, "Map.find_exn: not found"];
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _cH_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _cI_ = caml_call2(Base_Sexp[9], cst_Map_add_exn_got_key_alread, _cH_);
    return caml_call1(Base_Error[30], _cI_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[90], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[90], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[90], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0){
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1];
     return [0, bal(l, v$0, d$0, r$0), length$0];
    }
    var
     match$0 =
       find_and_add_or_set
        (l, length, x, data, compare_key, sexp_of_key, add_or_set),
     length$1 = match$0[2],
     l$0 = match$0[1];
    return [0, bal(l$0, v$0, d$0, r), length$1];
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _e_;},
             2);
   }
   function set$0(t, key, data, compare_key){
    var _cG_ = set(t, 0, key, data, compare_key);
    return caml_call1(Base_Import[124], _cG_);
   }
   function singleton_to_tree_exn(param){
    if(typeof param[1] !== "number")
     return caml_call1(Base_Import[123], cst_Map_singleton_to_tree_exn_);
    var data = param[3], key = param[2];
    return [0, key, data];
   }
   function collapse(l, r){return create(l[1], l[2], l[3], r);}
   function join(l, r){
    var _cE_ = r[3], _cF_ = r[2];
    return [0, collapse(l, r[1]), _cF_, _cE_];
   }
   function go(t, x){
    switch(t[0]){
      case 0:
       return [1, t, x];
      case 1:
       var y = t[2], t$0 = t[1]; return [2, t$0, y, x];
      default:
       var y$0 = t[3], z = t[2], t$1 = t[1];
       return [1, go(t$1, join(z, y$0)), x];
    }
   }
   function add_unchecked(t, key, data){return go(t, [0, 0, key, data]);}
   function go$0(t, r){
    var t$0 = t, r$0 = r;
    for(;;)
     switch(t$0[0]){
       case 0:
        return r$0;
       case 1:
        var l = t$0[2], t$1 = t$0[1], r$1 = collapse(l, r$0);
        t$0 = t$1;
        r$0 = r$1;
        break;
       default:
        var
         l$0 = t$0[3],
         ll = t$0[2],
         t$2 = t$0[1],
         r$2 = collapse(join(ll, l$0), r$0);
        t$0 = t$2;
        r$0 = r$2;
     }
   }
   function to_tree_unchecked(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2], t = param[1];
       return go$0(t, singleton_to_tree_exn(r));
      default:
       var r$0 = param[3], l = param[2], t$0 = param[1];
       return go$0([1, t$0, l], singleton_to_tree_exn(r$0));
    }
   }
   function max_key(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2]; break;
      default: var r = param[3];
    }
    return [0, r[2]];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              var
               match =
                 caml_call3
                  (Base_Sequence[8],
                   seq,
                   [0, empty, 0],
                   function(param$0, _cC_){
                    var
                     data = _cC_[2],
                     key = _cC_[1],
                     length = param$0[2],
                     builder = param$0[1],
                     match = max_key(builder);
                    if(match){
                     var prev_key = match[1];
                     if(0 <= caml_call2(compare_key, prev_key, key))
                      return caml_call1
                              (param,
                               caml_call1
                                (Base_Or_error[36], cst_of_increasing_sequence_non));
                    }
                    var _cD_ = caml_call2(Base_Import[90], length, 1);
                    return [0, add_unchecked(builder, key, data), _cD_];
                   }),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join$0(l, k, d, r, compare_key){
    if(typeof l === "number") return set$0(r, k, d, compare_key);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set$0(set$0(l, k, d, compare_key), rk, rd, compare_key);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 3) < lh
              ? bal(ll, lk$0, ld$0, join$0(lr, k, d, r, compare_key))
              : caml_call2
                 (Base_Import[90], lh, 3)
                < rh
                ? bal(join$0(l, k, d, rl, compare_key), rk$0, rd$0, rr)
                : bal(l, k, d, r);
     }
    }
    if(typeof r === "number") return set$0(l, k, d, compare_key);
    var ld = l[2], lk = l[1];
    return set$0(set$0(r, k, d, compare_key), lk, ld, compare_key);
   }
   function split(t, x, compare_key){
    if(typeof t === "number") return _f_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call2(compare_key, x, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call2(compare_key, x, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join$0(l, k$0, d$0, rl, compare_key), maybe, rr];
    }
    var
     match$0 = split(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join$0(lr, k$0, d$0, r, compare_key)];
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     match = split(t, x, compare_key),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(! boundary_opt) return [0, left, right];
    var match$0 = boundary_opt[1], data = match$0[2], key = match$0[1];
    function insert_into(tree){
     var _cB_ = set(tree, 0, key, data, compare_key);
     return caml_call1(Base_Import[124], _cB_);
    }
    return 847852583 <= into
            ? [0, insert_into(left), right]
            : [0, left, insert_into(right)];
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(caml_call3(Base_Maybe_bound[9], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _cz_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _cz_[2],
      left = _cz_[1];
    else
     var
      lb$2 = lower_bound[1],
      _cA_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _cA_[2],
      left$0 = _cA_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _cx_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _cx_[2],
      mid = _cx_[1];
    else
     var
      lb$0 = upper_bound[1],
      _cy_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _cy_[2],
      mid$0 = _cy_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _cw_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[27], _cw_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _cv_ = [1, [0, _g_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _cv_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cu_ = find(t, x, compare_key);
    return caml_call1(Base_Option[50], _cu_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _h_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _i_ = [0, cst_src_map_ml, 534, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Map_min_elt_exn_of_empty_map,
     function(param){
      if(param === Map_min_elt_exn_of_empty_map) return _h_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     });
   var
    Map_max_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _j_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _k_ = [0, cst_src_map_ml, 547, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Map_max_elt_exn_of_empty_map,
     function(param){
      if(param === Map_max_elt_exn_of_empty_map) return _j_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
     });
   var cst_Map_remove_min_elt = "Map.remove_min_elt";
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4];
     param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[125], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _ct_ = match$0[1],
     v = _ct_[2],
     min_upper = _ct_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0,
            17724,
            join$0
             (lower_part, min_upper, v, upper_part_without_min, compare_key)];
   }
   function go$1(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min){
       var init$1 = caml_call3(f, k$0, d$0, init$0);
       t$0 = r;
       init$0 = init$1;
      }
      else{
       var
        z = go$1(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       t$0 = r;
       init$0 = init$2;
      }
     else
      t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go$1(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cs_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[21], _cs_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   var
    Remove_no_op = [248, "Base__Map.Tree0.Remove_no_op", caml_fresh_oo_id(0)];
   function remove(t, x, length, compare_key){
    function remove_loop(t, x, length, compare_key){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Remove_no_op);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_key, x, v)
              ? [0, 0, caml_call2(Base_Import[92], length, 1)]
              : caml_call1(Base_Exn[6], Remove_no_op);
     }
     var
      r = t[4],
      d = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c){
      var _cr_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l, r), _cr_];
     }
     if(0 <= c){
      var
       match = remove_loop(r, x, length, compare_key),
       length$0 = match[2],
       r$0 = match[1];
      return [0, bal(l, v$0, d, r$0), length$0];
     }
     var
      match$0 = remove_loop(l, x, length, compare_key),
      length$1 = match$0[2],
      l$0 = match$0[1];
     return [0, bal(l$0, v$0, d, r), length$1];
    }
    try{var _cp_ = remove_loop(t, x, length, compare_key); return _cp_;}
    catch(_cq_){
     var _co_ = caml_wrap_exception(_cq_);
     if(_co_ === Remove_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_co_, 0);
    }
   }
   var
    Change_no_op = [248, "Base__Map.Tree0.Change_no_op", caml_fresh_oo_id(0)],
    _l_ = [0, 0, 0],
    _m_ = [0, 0, 0],
    _n_ = [0, 0, 0],
    _o_ = [0, 0, 0],
    _p_ = [0, 0, 0],
    _q_ = [0, [0, 0, 0], [0, 0, 0]],
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1;
   function change(t, key, f, length, compare_key){
    function change_core(t, key, f){
     if(typeof t === "number"){
      var match = caml_call1(f, 0);
      if(! match) throw caml_maybe_attach_backtrace(Change_no_op, 1);
      var data = match[1];
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var match$0 = caml_call1(f, [0, d]);
       if(! match$0) return [0, 0, caml_call2(Base_Import[92], length, 1)];
       var d$0 = match$0[1];
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var
        match$1 = change_core(0, key, f),
        length$0 = match$1[2],
        r = match$1[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$2 = change_core(0, key, f),
       length$1 = match$2[2],
       l = match$2[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var match$3 = caml_call1(f, [0, d$1]);
      if(match$3){
       var data$0 = match$3[1];
       return [0, [1, l$0, key, data$0, r$0, h], length];
      }
      var _cn_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l$0, r$0), _cn_];
     }
     if(0 <= c$0){
      var
       match$4 = change_core(r$0, key, f),
       length$2 = match$4[2],
       r$1 = match$4[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$5 = change_core(l$0, key, f),
      length$3 = match$5[2],
      l$1 = match$5[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    try{var _cl_ = change_core(t, key, f); return _cl_;}
    catch(_cm_){
     var _ck_ = caml_wrap_exception(_cm_);
     if(_ck_ === Change_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_ck_, 0);
    }
   }
   function update(t, key, f, length, compare_key){
    function update_core(t, key, f){
     if(typeof t === "number"){
      var data = caml_call1(f, 0);
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var d$0 = caml_call1(f, [0, d]);
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var match = update_core(0, key, f), length$0 = match[2], r = match[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$0 = update_core(0, key, f),
       length$1 = match$0[2],
       l = match$0[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var data$0 = caml_call1(f, [0, d$1]);
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     if(0 <= c$0){
      var
       match$1 = update_core(r$0, key, f),
       length$2 = match$1[2],
       r$1 = match$1[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$2 = update_core(l$0, key, f),
      length$3 = match$2[2],
      l$1 = match$2[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    return update_core(t, key, f);
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cj_ = param[1];
               if(_cj_){
                var non_empty_tail = _cj_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _ci_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _ci_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f));
     t$0 = r;
     accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1];
      t$0 = r;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f));
     t$0 = l;
     accu$0 = accu$1;
    }
   }
   function filter_keys(t, f, compare_key){
    return fold
            (t,
             _l_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, key)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter(t, f, compare_key){
    return fold
            (t,
             _m_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filteri(t, f, compare_key){
    return fold
            (t,
             _n_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call2(f, key, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter_map(t, f, compare_key){
    return fold
            (t,
             _o_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call1(f, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function filter_mapi(t, f, compare_key){
    return fold
            (t,
             _p_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call2(f, key, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function partition_mapi(t, f, compare_key){
    return fold
            (t,
             _q_,
             function(key, data, param){
              var
               pair2 = param[2],
               pair1 = param[1],
               match = caml_call2(f, key, data);
              if(0 === match[0]){
               var x = match[1], length = pair1[2], t = pair1[1];
               return [0, set(t, length, key, x, compare_key), pair2];
              }
              var y = match[1], length$0 = pair2[2], t$0 = pair2[1];
              return [0, pair1, set(t$0, length$0, key, y, compare_key)];
             });
   }
   function partition_map(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){return caml_call1(f, data);},
             compare_key);
   }
   function partitioni_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function partition_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){
              return caml_call1(f, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0];
     t$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0];
     t$0 = r;
     e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0);
     init$0 = next;
     param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    a:
    {
     var t1$0 = t1, t2$0 = t2, curr = init;
     for(;;){
      if(! t1$0) break;
      if(! t2$0) break a;
      var
       enum2 = t2$0[4],
       tree2 = t2$0[3],
       v2 = t2$0[2],
       k2 = t2$0[1],
       enum1 = t1$0[4],
       tree1 = t1$0[3],
       v1 = t1$0[2],
       k1 = t1$0[1],
       compare_result = caml_call2(compare_key, k1, k2);
      if(0 === compare_result){
       var
        next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1);
       t1$0 = t1$1;
       t2$0 = t2$1;
       curr = next;
      }
      else if(0 <= compare_result){
       var
        next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
        t2$2 = cons(tree2, enum2);
       t2$0 = t2$2;
       curr = next$0;
      }
      else{
       var
        next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
        t1$2 = cons(tree1, enum1);
       t1$0 = t1$2;
       curr = next$1;
      }
     }
     return t2$0
             ? fold$0
               (curr,
                function(key, data, acc){
                 return caml_call3(f, key, [0, -57574468, data], acc);
                },
                t2$0)
             : curr;
    }
    return fold$0
            (curr,
             function(key, data, acc){
              return caml_call3(f, key, [0, 847852583, data], acc);
             },
             t1$0);
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var
       enum$0 = match[4],
       tree = match[3],
       data$0 = match[2],
       key$0 = match[1];
      return [1,
              [0, key$0, [0, -57574468, data$0]],
              [0, 0, cons(tree, enum$0)]];
     }
     var
      right = state[2],
      enum1 = left[4],
      tree1 = left[3],
      data = left[2],
      key = left[1];
     if(! right)
      return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[4],
      tree2 = right[3],
      v2 = right[2],
      k2 = right[1],
      compare_result = caml_call2(compare_key, key, k2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1,
                [0, k2, [0, -57574468, v2]],
                [0, left, cons(tree2, enum2)]]
              : [1,
                [0, key, [0, 847852583, data]],
                [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _ch_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _ch_];
     return caml_call2(data_equal, data, v2)
             ? [0, next_state]
             : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
    }
    var _cf_ = of_tree(t2), _cg_ = [0, of_tree(t1), _cf_];
    return caml_call2(Base_Sequence[41], _cg_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set$0(t$0, key, data, compare_key);
    }
    if(511974747 <= order){
     var
      _b$_ = Base_Import[126],
      tree =
        caml_call3
         (Base_Option[31],
          keys_greater_or_equal_to,
          t$3,
          function(_cd_, _ce_){return inclusive_bound(_b$_, _cd_, _ce_);}),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0]){
        var d$1 = t$1[2], v$2 = t$1[1], t$2 = [1, 0, v$2, d$1, 0, 1];
        t$1 = t$2;
       }
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         t$1 = l$0;
        else{
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1];
         t$1 = r$1;
         e$1 = e$2;
        }
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[41], init$0, next$0);
    }
    var
     _ca_ = Base_Import[124],
     t$4 =
       caml_call3
        (Base_Option[31],
         keys_less_or_equal_to,
         t$3,
         function(_cb_, _cc_){return inclusive_bound(_ca_, _cb_, _cc_);});
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0]){
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1];
       t = t$0;
      }
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key)){
        var r$0 = t[4], d$0 = t[3], v$1 = t[2], e$0 = [0, v$1, d$0, r$0, e];
        t = l;
        e = e$0;
       }
       else
        t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[41], init, next);
   }
   function compare$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     if(caml_call2(Base_Import[127], r1, r2)){t1 = e1; t2 = e2;}
     else{var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1); t1 = t1$0; t2 = t2$0;}
    }
   }
   function equal$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _b8_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_b8_){
        var _b9_ = caml_call2(compare_data, d1, d2);
        if(_b9_){
         if(caml_call2(Base_Import[127], r1, r2)){t1 = e1; t2 = e2; continue;}
         var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1);
         t1 = t1$0;
         t2 = t2$0;
         continue;
        }
        var _b__ = _b9_;
       }
       else
        var _b__ = _b8_;
       return _b__;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    var _b7_ = of_tree(t2);
    return fold2
            (compare_key,
             of_tree(t1),
             _b7_,
             0,
             function(key, data, param){return caml_call2(f, key, data);});
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _b6_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _b6_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(caml_call2(Base_Import[127], t1, t2)) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var l$0 = t2[1], r$0 = t2[4], v$2 = t2[3], k$2 = t2[2];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var acc$6 = loop(l, l$0, init), acc$7 = delta(acc$6, k$1, v$1, v$2);
          t1 = r;
          t2 = r$0;
          init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        right$2 = of_tree(t2),
        left$2 = of_tree(t1);
       b:
       {
        var left = left$2, right = right$2, acc = init;
        for(;;){
         if(! left) break;
         if(! right) break b;
         var
          enum2 = right[4],
          tree2 = right[3],
          v2 = right[2],
          k2 = right[1],
          enum1 = left[4],
          tree1 = left[3],
          v1 = left[2],
          k1 = left[1],
          compare_result = caml_call2(compare_key, k1, k2);
         if(0 === compare_result){
          var
           acc$0 =
             caml_call2(data_equal, v1, v2)
              ? acc
              : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]);
          if(caml_call2(Base_Import[127], tree1, tree2)){left = enum1; right = enum2; acc = acc$0;}
          else{
           var right$0 = cons(tree2, enum2), left$0 = cons(tree1, enum1);
           left = left$0;
           right = right$0;
           acc = acc$0;
          }
         }
         else if(0 <= compare_result){
          var acc$1 = add$0(acc, k2, v2), right$1 = cons(tree2, enum2);
          right = right$1;
          acc = acc$1;
         }
         else{
          var acc$2 = remove$0(acc, k1, v1), left$1 = cons(tree1, enum1);
          left = left$1;
          acc = acc$2;
         }
        }
        return fold$0
                (acc,
                 function(key, data, acc){return add$0(acc, key, data);},
                 right);
       }
       return fold$0
               (acc,
                function(key, data, acc){return remove$0(acc, key, data);},
                left);
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _b3_ = length(r),
     _b4_ = length(l),
     _b5_ = caml_call2(Base_Import[90], _b4_, _b3_);
    return caml_call2(Base_Import[90], _b5_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(param, _b2_){
               var
                data = _b2_[2],
                key = _b2_[1],
                length = param[2],
                accum = param[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], prev_data = prev;
               else
                var prev_data = init;
               var data$0 = caml_call2(f, prev_data, data);
               return set(accum, length, key, data$0, compare_key);
              });
    }
    function of_foldable_reduce(foldable, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(param, _b1_){
               var
                data = _b1_[2],
                key = _b1_[1],
                length = param[2],
                accum = param[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], new_data = caml_call2(f, prev, data);
               else
                var new_data = data;
               return set(accum, length, key, new_data, compare_key);
              });
    }
    function of_foldable(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    function(param, _b0_){
                     var
                      data = _b0_[2],
                      key = _b0_[1],
                      length = param[2],
                      t = param[1],
                      acc = set(t, length, key, data, compare_key),
                      length$0 = acc[2];
                     return length === length$0
                             ? caml_call1(r, [0, -1048878709, key])
                             : acc;
                    });
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _bX_ = comparator[2],
      _bY_ = caml_call2(Base_Import[111], M[1], cst_or_error_duplicate_key),
      _bZ_ = caml_call2(Base_Import[111], cst_Map_of, _bY_);
     return caml_call5(Base_Or_error[34], 0, 0, _bZ_, key, _bX_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _bT_ = comparator[2],
      _bU_ = caml_call2(Base_Import[111], M[1], cst_exn_duplicate_key),
      _bV_ = caml_call2(Base_Import[111], cst_Map_of$0, _bU_),
      _bW_ = caml_call5(Base_Error[17], 0, 0, _bV_, key, _bT_);
     return caml_call1(Base_Error[29], _bW_);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable,
            of_foldable_or_error,
            of_foldable_exn];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5];
   function of_foldable_multi(foldable, fold, compare_key){
    var
     alist = caml_call3(fold, foldable, 0, function(l, x){return [0, x, l];});
    return of_alist_fold
            (alist, 0, function(l, x){return [0, x, l];}, compare_key);
   }
   function of_alist_multi(alist, compare_key){
    return of_foldable_multi(alist, Base_List0[8], compare_key);
   }
   var
    fold$2 = Base_Sequence[8],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    _r_ = [0, 0],
    _s_ = [0, 0],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _t_ = [0, cst_src_map_ml, 1639, 6],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    _u_ = [0, 0, 0],
    _v_ = [0, "Map.Build_increasing.add: non-increasing key"];
   function of_sequence_multi(sequence, compare_key){
    return of_foldable_multi(sequence, Base_Sequence[8], compare_key);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _bS_ = 1 - caml_call1(f, data);
                 return _bS_ ? caml_call1(r, 0) : _bS_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bR_ = 1 - caml_call2(f, key, data);
                 return _bR_ ? caml_call1(r, 0) : _bR_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _bQ_ = caml_call1(f, data);
                 return _bQ_ ? caml_call1(r, 1) : _bQ_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bP_ = caml_call2(f, key, data);
                 return _bP_ ? caml_call1(r, 1) : _bP_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _bM_ = length(t2),
     _bN_ = length(t1),
     _bO_ = caml_call2(Base_Import[90], _bN_, _bM_),
     elts = caml_call1(Base_Uniform_array[34], _bO_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[13], elts, i[1], [0, key, value]);
       return caml_call1(Base_Import[129], i);
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[11], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return update
                      (t,
                       key,
                       function(param){
                        if(! param) return data;
                        var data$0 = param[1];
                        return caml_call4(call, combine, key, data$0, data);
                       },
                       length,
                       compare_key);
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       t = l;
       found_marker = 1;
       found_key = found_key$0;
       found_value = found_value$0;
       continue;
      }
      t = r;
      continue;
     }
     if(0 <= c$0)
      t = l;
     else{
      t = r;
      found_marker = 1;
      found_key = found_key$0;
      found_value = found_value$0;
     }
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _bL_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _bL_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _r_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var _bI_ = rank(r, k, compare_key);
      return caml_call2
              (Base_Option[21],
               _bI_,
               function(rank){
                var
                 _bJ_ = length(l),
                 _bK_ = caml_call2(Base_Import[90], rank, 1);
                return caml_call2(Base_Import[90], _bK_, _bJ_);
               });
     }
     t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (caml_call1(Base_Import[128], num_to_search), 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     caml_call1(Base_Import[128], num_to_search);
     param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _s_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[49], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = pair;
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bH_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bH_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bA_ = caml_call2(Base_Import[173], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[175], _bA_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _bB_ =
       caml_call2
        (Base_Import[173],
         function(_bG_){return _bG_;},
         function(_bF_){return _bF_;}),
     alist_sexps = caml_call2(Base_Import[175], _bB_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List0[13],
      alist,
      alist_sexps,
      function(param, _bC_){
       var
        k2_sexp = _bC_[1],
        k2 = param[1],
        _bD_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
       if(_bD_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[158], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
        found_first_k[1] = 1;
        var _bE_ = 0;
       }
       else
        var _bE_ = _bD_;
       return _bE_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bz_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bz_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, compare_key, sexp_of_key){
    var
     _bx_ = partition_map(t, Base_Result[35], compare_key),
     error_tree = _bx_[2][1],
     oks = _bx_[1];
    if(is_empty(error_tree)) return [0, oks];
    var _by_ = sexp_of_t$1(sexp_of_key, Base_Error[6], error_tree);
    return caml_call1(Base_Or_error[35], _by_);
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bv_ =
                             add_exn_internal
                              (t2, length, key$0, data, compare_key, sexp_of_key);
                          return _bv_;
                         }
                         catch(_bw_){
                          var _bu_ = caml_wrap_exception(_bw_);
                          if(_bu_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bu_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bs_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bt_ = caml_call2(Base_Sexp[9], cst_Map_map_keys_exn_duplicate, _bs_);
    return caml_call1(Base_Error[30], _bt_);
   }
   function compare_key(t){return t[1][1];}
   function like(param, _br_){
    var length = _br_[2], tree = _br_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like2(x, param){
    var z = param[2], y = param[1], _bq_ = like(x, z);
    return [0, like(x, y), _bq_];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return caml_call2(Base_Import[127], old_tree, tree)
            ? old_t
            : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bm_ = compare_key(t), _bn_ = invariants(t[2], _bm_);
    if(_bn_)
     var _bo_ = t[3], _bp_ = length(t[2]) === _bo_ ? 1 : 0;
    else
     var _bp_ = _bn_;
    return _bp_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$1(t, key, data){
    var _bl_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bl_));
   }
   function add_exn$0(t, key, data){
    var _bj_ = t[1][2], _bk_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bk_, _bj_));
   }
   function add(t, key, data){
    try{
     var
      _bf_ = t[1][2],
      _bg_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _bg_, _bf_));
    }
    catch(_bi_){
     var _bh_ = caml_wrap_exception(_bi_);
     if(_bh_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bh_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _be_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _be_));
   }
   function remove_multi$0(t, key){
    var _bd_ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _bd_));
   }
   function find_multi$0(t, key){
    var _bc_ = compare_key(t);
    return find_multi(t[2], key, _bc_);
   }
   function change$0(t, key, f){
    var _bb_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _bb_));
   }
   function update$0(t, key, f){
    var _ba_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _ba_));
   }
   function find_exn$0(t, key){
    var _a__ = t[1][2], _a$_ = compare_key(t);
    return find_exn(t[2], key, _a$_, _a__);
   }
   function find$0(t, key){
    var _a9_ = compare_key(t);
    return find(t[2], key, _a9_);
   }
   function remove$0(t, key){
    var _a8_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _a8_));
   }
   function mem$0(t, key){
    var _a7_ = compare_key(t);
    return mem(t[2], key, _a7_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _a6_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _a6_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _a4_ = t[2];
    return function(_a5_){return fold_until(_a4_, init, f, _a5_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _a3_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _a3_);
   }
   function filter_keys$0(t, f){
    var _a2_ = compare_key(t);
    return like(t, filter_keys(t[2], f, _a2_));
   }
   function filter$0(t, f){
    var _a1_ = compare_key(t);
    return like(t, filter(t[2], f, _a1_));
   }
   function filteri$0(t, f){
    var _a0_ = compare_key(t);
    return like(t, filteri(t[2], f, _a0_));
   }
   function filter_map$0(t, f){
    var _aZ_ = compare_key(t);
    return like(t, filter_map(t[2], f, _aZ_));
   }
   function filter_mapi$0(t, f){
    var _aY_ = compare_key(t);
    return like(t, filter_mapi(t[2], f, _aY_));
   }
   function partition_mapi$0(t, f){
    var _aX_ = compare_key(t);
    return like2(t, partition_mapi(t[2], f, _aX_));
   }
   function partition_map$0(t, f){
    var _aW_ = compare_key(t);
    return like2(t, partition_map(t[2], f, _aW_));
   }
   function partitioni_tf$0(t, f){
    var _aV_ = compare_key(t);
    return like2(t, partitioni_tf(t[2], f, _aV_));
   }
   function partition_tf$0(t, f){
    var _aU_ = compare_key(t);
    return like2(t, partition_tf(t[2], f, _aU_));
   }
   function combine_errors$0(t){
    var
     _aQ_ = t[1][2],
     _aR_ = compare_key(t),
     _aS_ = combine_errors(t[2], _aR_, _aQ_);
    return caml_call2
            (Base_Or_error[43], _aS_, function(_aT_){return like(t, _aT_);});
   }
   function compare_direct(compare_data, t1, t2){
    var _aO_ = t2[2], _aP_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aP_, _aO_);
   }
   function equal$2(compare_data, t1, t2){
    var _aM_ = t2[2], _aN_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aN_, _aM_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aL_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aL_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aK_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aK_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aJ_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aJ_));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aH_ = compare_key(t1),
     _aI_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aH_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aI_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function split$0(t, k){
    var
     _aF_ = compare_key(t),
     match = split(t[2], k, _aF_),
     tree = match[3],
     maybe = match[2],
     tree$0 = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[50], maybe)
        ? caml_call2(Base_Import[92], t[3], 1)
        : t[3],
     _aG_ = height(tree);
    if(height(tree$0) < _aG_){
     var
      l = of_tree$0(comparator, tree$0),
      length = caml_call2(Base_Import[92], both_len, l[3]);
     return [0, l, maybe, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = caml_call2(Base_Import[92], both_len, r[3]);
    return [0, [0, comparator, tree$0, length$0], maybe, r];
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aB_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aB_),
     right = match[3],
     tree = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[90], h_l, 1)
        : caml_call2(Base_Import[99], h_l, h_r);
    if(outer_joined_height >= height(tree)) return of_tree$0(t[1], tree);
    var
     _aC_ = length(right),
     _aD_ = length(left),
     _aE_ = caml_call2(Base_Import[90], _aD_, _aC_),
     mid_length = caml_call2(Base_Import[92], t[3], _aE_),
     comparator = t[1];
    return [0, comparator, tree, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aA_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aA_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     length = caml_call2(Base_Import[90], lower_part[3], upper_part[3]),
     comparator = lower_part[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _az_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _az_);
   }
   function range_to_alist$0(t, min, max){
    var _ay_ = compare_key(t);
    return range_to_alist(t[2], min, max, _ay_);
   }
   function closest_key$0(t, dir, key){
    var _ax_ = compare_key(t);
    return closest_key(t[2], dir, key, _ax_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _aw_ = nth$1(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _aw_);
   }
   function rank$0(t, key){
    var _av_ = compare_key(t);
    return rank(t[2], key, _av_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2], _au_ = length(t$0);
    return fold
            (t$0,
             caml_call2(Base_Import[206], state, _au_),
             function(key, data, state){
              return caml_call2
                      (hash_fold_data,
                       caml_call2(hash_fold_key, state, key),
                       data);
             });
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, _u_);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, key, data){return [0, key, data];}
   function of_sorted_array_unchecked$0(comparator, array){
    var _at_ = of_sorted_array_unchecked(array, comparator[1]);
    return caml_call1(Base_Import[124], _at_);
   }
   function of_sorted_array$0(comparator, array){
    var _as_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _as_, Base_Import[124]);
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _ar_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Or_error[43], _ar_, Base_Import[124]);
   }
   function of_alist_exn$0(comparator, alist){
    var _aq_ = of_alist_exn(alist, comparator);
    return caml_call1(Base_Import[124], _aq_);
   }
   function of_alist_multi$0(comparator, alist){
    var _ap_ = of_alist_multi(alist, comparator[1]);
    return caml_call1(Base_Import[124], _ap_);
   }
   function of_alist_fold$0(comparator, alist, init, f){
    var _ao_ = of_alist_fold(alist, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _ao_);
   }
   function of_alist_reduce$0(comparator, alist, f){
    var _an_ = of_alist_reduce(alist, f, comparator[1]);
    return caml_call1(Base_Import[124], _an_);
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    var _am_ = of_iteri_exn(iteri, comparator);
    return caml_call1(Base_Import[124], _am_);
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var
     _ak_ = Base_Import[124],
     _al_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _al_, _ak_);
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var _aj_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Or_error[43], _aj_, Base_Import[124]);
   }
   function of_sequence_exn$0(comparator, seq){
    var _ai_ = of_sequence_exn(seq, comparator);
    return caml_call1(Base_Import[124], _ai_);
   }
   function of_sequence_multi$0(comparator, seq){
    var _ah_ = of_sequence_multi(seq, comparator[1]);
    return caml_call1(Base_Import[124], _ah_);
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    var _ag_ = of_sequence_fold(seq, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _ag_);
   }
   function of_sequence_reduce$0(comparator, seq, f){
    var _af_ = of_sequence_reduce(seq, f, comparator[1]);
    return caml_call1(Base_Import[124], _af_);
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$2(comparator, t, key, data){
    var _ae_ = set(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _ae_);
   }
   function add_exn$1(comparator, t, key, data){
    var _ad_ = add_exn(t, 0, key, data, comparator[1], comparator[2]);
    return caml_call1(Base_Import[124], _ad_);
   }
   function add$0(comparator, t, key, data){
    try{
     var _ab_ = [0, 17724, add_exn$1(comparator, t, key, data)];
     return _ab_;
    }
    catch(_ac_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    var _aa_ = add_multi(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _aa_);
   }
   function remove_multi$1(comparator, t, key){
    var _$_ = remove_multi(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _$_);
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    var ___ = change(t, key, f, 0, comparator[1]);
    return caml_call1(Base_Import[124], ___);
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    var _Z_ = remove(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _Z_);
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(comparator, t, f){
    var _Y_ = filter_keys(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _Y_);
   }
   function filter$1(comparator, t, f){
    var _X_ = filter(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _X_);
   }
   function filteri$1(comparator, t, f){
    var _W_ = filteri(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _W_);
   }
   function filter_map$1(comparator, t, f){
    var _V_ = filter_map(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _V_);
   }
   function filter_mapi$1(comparator, t, f){
    var _U_ = filter_mapi(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _U_);
   }
   function partition_mapi$1(comparator, t, f){
    var
     _T_ = partition_mapi(t, f, comparator[1]),
     b = _T_[2][1],
     a = _T_[1][1];
    return [0, a, b];
   }
   function partition_map$1(comparator, t, f){
    var
     _S_ = partition_map(t, f, comparator[1]),
     b = _S_[2][1],
     a = _S_[1][1];
    return [0, a, b];
   }
   function partitioni_tf$1(comparator, t, f){
    var
     _R_ = partitioni_tf(t, f, comparator[1]),
     b = _R_[2][1],
     a = _R_[1][1];
    return [0, a, b];
   }
   function partition_tf$1(comparator, t, f){
    var _Q_ = partition_tf(t, f, comparator[1]), b = _Q_[2][1], a = _Q_[1][1];
    return [0, a, b];
   }
   function combine_errors$1(comparator, t){
    var
     _O_ = Base_Import[124],
     _P_ = combine_errors(t, comparator[1], comparator[2]);
    return caml_call2(Base_Or_error[43], _P_, _O_);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    var _N_ = merge(t1, t2, f, comparator[1]);
    return caml_call1(Base_Import[124], _N_);
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var
     _K_ = comparator[1],
     _M_ = length(t2),
     _L_ = merge_skewed(t1, t2, length(t1), _M_, combine, _K_);
    return caml_call1(Base_Import[124], _L_);
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _J_ = nth$0(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _J_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    var _I_ = t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator);
    return caml_call1(Base_Import[124], _I_);
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    var _H_ = map_keys_exn(t, f, comparator);
    return caml_call1(Base_Import[124], _H_);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[30], _v_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1], _w_ = [0, "_"];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, key, data){return [0, comparator, [0, key, data], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    var _G_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _G_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    var _F_ = of_alist_or_error(alist, comparator);
    return caml_call2
            (Base_Result[30],
             _F_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    var _D_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _D_,
             function(_E_){return of_tree0(comparator, _E_);});
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    var _C_ = of_sequence_or_error(seq, comparator);
    return caml_call2
            (Base_Result[30],
             _C_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function of_tree$3(M){
    return function(tree){return of_tree$0(M[1], tree);};
   }
   function empty$2(m){return empty$1(m[1]);}
   function singleton$1(m, a){
    var _A_ = m[1];
    return function(_B_){return singleton$0(_A_, a, _B_);};
   }
   function of_alist$2(m, a){return of_alist$1(m[1], a);}
   function of_alist_or_error$2(m, a){return of_alist_or_error$1(m[1], a);}
   function of_alist_exn$2(m, a){return of_alist_exn$1(m[1], a);}
   function of_alist_multi$2(m, a){return of_alist_multi$1(m[1], a);}
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(m[1], a, init, f);
   }
   function of_alist_reduce$2(m, a, f){return of_alist_reduce$1(m[1], a, f);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_iteri$2(m, iteri){return of_iteri$1(m[1], iteri);}
   function of_iteri_exn$2(m, iteri){return of_iteri_exn$1(m[1], iteri);}
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(m[1], seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(m[1], s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(m[1], s);
   }
   function of_sequence_exn$2(m, s){return of_sequence_exn$1(m[1], s);}
   function of_sequence_multi$2(m, s){return of_sequence_multi$1(m[1], s);}
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(m[1], s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(m[1], s, f);
   }
   function map_keys$2(m, t, f){return map_keys$1(m[1], t, f);}
   function map_keys_exn$2(m, t, f){return map_keys_exn$1(m[1], t, f);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){
     return sexp_of_t$2(K[1], sexp_of_v, function(param){return _w_;}, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){
     return [2, [1, [2, [0, K[1], [0, v_grammar, 0]]]]];};
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K){
    return function(hash_fold_v, state){
     var _y_ = K[1];
     return function(_z_){
      return hash_fold_direct(_y_, hash_fold_v, state, _z_);};};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_x_){return singleton$0(comparator$0, a, _x_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$0,
       length$0,
       set$1,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       split$0,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$2,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$1,
         iter2$1,
         map$1,
         mapi$1,
         fold$4,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         split$1,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){return caml_call2(Stdlib_Queue[15], f, t);}
   function fold(t, init, f){return caml_call3(Stdlib_Queue[16], f, init, t);}
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var
    peek_exn = Base_Linked_queue0[6],
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _k_ = caml_call1(f, a);
       return caml_call2
               (Base_List[9], _k_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _j_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[9], _j_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _i_ = caml_call1(f, a);
       return _i_ ? enqueue(res, a) : _i_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _h_ = caml_call2(f, i, a);
       return _h_ ? enqueue(res, a) : _h_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    return caml_call2(Base_List[9], list, function(x){return enqueue(t, x);});
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    caml_call2(Base_List[9], list, function(x){return enqueue(t, x);});
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    caml_call2(Base_Array[9], array, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[92], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[25], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       return caml_call1(Base_Import[129], i);
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[175], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[151], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[203],
    func = Base_Import[217];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_y_, _x_){return caml_int64_compare(_y_, _x_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    num_bits = 64,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    float_of_bits = runtime.caml_int64_float_of_bits,
    bits_of_float = runtime.caml_int64_bits_of_float,
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    pow = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return caml_int64_of_float(f);
    var _w_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _w_, 0);
   }
   function symbol(b, e){return caml_call2(pow, b, e);}
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    _b_ = [0, "src/int64.ml", 100, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _u_ = caml_lessequal(low, t),
     _v_ = _u_ ? caml_lessequal(t, high) : _u_;
    return _v_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _r_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _s_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _r_],
     _t_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _s_);
    return caml_call1(Base_Or_error[35], _t_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_q_){return _q_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[11],
    to_int_exn = Base_Int_conversions[12],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[14],
    to_int32_exn = Base_Int_conversions[15],
    of_nativeint = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[17],
    to_nativeint_exn = Base_Int_conversions[18],
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$6 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x$6, caml_int64_shift_right_unsigne(x$6, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_call1(Stdlib_Int64[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_lessequal(x$0, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_int64_sub(x$1, caml_int64_shift_right_unsigne(x$1, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _p_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _p_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _m_ = [0, [0, cst, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_floor_log2_got_inval, _m_));
    }
    var
     _n_ = runtime.Base_int_math_int64_clz(i),
     _o_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _o_, _n_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _k_ = [0, [0, cst$0, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_ceil_log2_got_invali, _k_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _l_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[92], num_bits, _l_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare$0 = Base_Import[230],
    hash_fold_t$0 = Base_Import[203],
    func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    symbol$0 = caml_lessthan,
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_j_){return _j_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$3[1],
    symbol$2 = include$3[2],
    symbol$3 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[102],
    ascending = include$4[1],
    descending = include$4[2],
    max = include$4[3],
    min = include$4[4],
    Base_Int64 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_i_, _h_){return caml_int64_compare(_i_, _h_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int64_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int64_ctz(_f_);},
       [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       of_nativeint,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(29, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Import[230],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _e_ = [0, cst_src_int63_emul_ml, 114, 20];
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[20], x);
    return caml_int64_mul(x, _a_);
   }
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function invariant(t){
    if(caml_equal(caml_int64_and(t, mask), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(runtime.caml_int64_create_lo_mi_hi(1, 0, 0));
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var
    x = Stdlib_Int64[10],
    min_value = caml_int64_and(x, mask),
    x$0 = Stdlib_Int64[9],
    max_value = caml_int64_and(x$0, mask);
   function bit_not(x){
    var x$0 = caml_call1(Stdlib_Int64[11], x);
    return caml_int64_and(x$0, mask);
   }
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){
    var x$0 = caml_int64_shift_right(x, i);
    return caml_int64_and(x$0, mask);
   }
   function shift_right_logical(x, i){
    var x$0 = caml_int64_shift_right_unsigne(x, i);
    return caml_int64_and(x$0, mask);
   }
   var
    f = Base_Int_math[2][3],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){
    var x = runtime.caml_int64_div(a, b);
    return caml_int64_mul(x, _c_);
   }
   var
    rem = runtime.caml_int64_mod,
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[21], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return caml_int64_mul(t, _c_);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[168], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[144], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare, x, y);}
   function is_pow2(x){
    return caml_call1(Base_Int64[67], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[68], x);}
   function ctz(x){
    return caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[65], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Stdlib_MoreLabels[1][28], x);}
   var
    hashable = [0, hash, compare$0, sexp_of_t$0],
    _f_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function invalid_str(x){return caml_call3(Base_Printf[6], _f_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string(str){
    try{
     var len = caml_ml_string_length(str);
     a:
     if(0 < len){
      var switcher = caml_string_get(str, 0) - 43 | 0;
      if(2 >= switcher >>> 0)
       switch(switcher){
         case 0:
          var sign = 4003188, pos = 1; break a;
         case 1: break;
         default: var sign = 3901488, pos = 1; break a;
       }
      var sign = 4003188, pos = 0;
     }
     else
      var sign = 4003188, pos = 0;
     if(caml_call2(Base_Import[90], pos, 2) < len)
      var
       c1 = caml_string_get(str, pos),
       c2 = caml_string_get(str, caml_call2(Base_Import[90], pos, 1)),
       match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
     else
      var match = [0, , 1];
     var signedness = match[2];
     if(signedness)
      var t = caml_int64_of_string(str), _t_ = wrap_exn(t);
     else{
      if(4003188 <= sign)
       var pos_str = str;
      else
       var
        _u_ = caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
        pos_str = caml_call3(Base_String[2], str, 1, _u_);
      var int64 = caml_int64_of_string(pos_str);
      if(caml_lessthan(int64, _g_)) invalid_str(str);
      var
       int63$0 = caml_int64_mul(int64, _c_),
       int63 = 4003188 <= sign ? int63$0 : caml_int64_neg(int63$0),
       _t_ = int63;
     }
     return _t_;
    }
    catch(_v_){return invalid_str(str);}
   }
   function bswap16(t){
    var x = caml_call1(Base_Int64[84], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap32(t){
    var x = caml_call1(Base_Int64[85], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap48(t){
    var x = caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   var
    num_bits = 63,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    _h_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"];
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){
    var x$0 = caml_int64_of_float(x);
    return caml_int64_mul(x$0, _c_);
   }
   function of_float(t){
    if
     (caml_call2(Base_Import[107][6], t, float_lower_bound)
      && caml_call2(Base_Import[107][2], t, float_upper_bound)){
     var x = caml_int64_of_float(t);
     return caml_int64_mul(x, _c_);
    }
    var _s_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _h_, _s_, 0);
   }
   var
    _i_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _i_[1],
    is_non_negative = _i_[2],
    is_negative = _i_[3],
    is_non_positive = _i_[4],
    sign = _i_[5],
    _j_ = [0, cst_src_int63_emul_ml, 317, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function between(t, low, high){
    var
     _q_ = caml_lessequal(low, t),
     _r_ = _q_ ? caml_lessequal(t, high) : _q_;
    return _r_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _n_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _o_ = [0, [0, cst_min, sexp_of_t$0(min)], _n_],
     _p_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _o_);
    return caml_call1(Base_Or_error[35], _p_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){var x = r[1]; r[1] = caml_int64_add(x, one$0); return 0;}
   function decr(r){var x = r[1]; r[1] = caml_int64_sub(x, one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[11], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_trunc(x){
    var t = caml_call1(Base_Int_conversions[28], x);
    return caml_int64_mul(t, _c_);
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   var
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$1 = include$0[2];
   function hash$0(x){return hash(x);}
   var
    symbol$5 = caml_lessthan,
    _k_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_0x = "0x";
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _k_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[111], cst_0x, s));
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$1[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$2 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    round = include$2[4],
    round_towards_zero = include$2[5],
    round_down = include$2[6],
    round_up = include$2[7],
    round_nearest = include$2[8],
    Repr = [0],
    include$3 = Base_Import[102],
    ascending = include$3[1],
    descending = include$3[2],
    max = include$3[3],
    min = include$3[4],
    Base_Int63_emul =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_m_, _l_){return runtime.caml_int64_compare(_m_, _l_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       [0,
        symbol,
        symbol$0,
        symbol$2,
        symbol$3,
        symbol$1,
        symbol$4,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$1,
        zero,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       [0, wrap_exn, unwrap],
       Repr,
       1];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"];
   function of_string(s){
    return s !== "false"
            ? s !== "true" ? caml_call3(invalid_argf, _a_, s, 0) : 1
            : 0;
   }
   var
    to_string = Base_Import[84][29],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1],
    _b_ = [0, cst_src_bool_ml, 56, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[104][2], low, t);
    return _k_ ? caml_call2(Base_Import[104][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[104][1], t, min)
            ? min
            : caml_call2(Base_Import[104][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[85], x);}
   function symbol(a, b){
    var
     _f_ = to_int(b),
     _g_ = to_int(a),
     x = caml_call2(Base_Import[117], _g_, _f_);
    return x;
   }
   function symbol$0(a, b){
    var
     _d_ = to_int(b),
     _e_ = to_int(a),
     x = caml_call2(Base_Import[115], _e_, _d_);
    return x;
   }
   var _c_ = [0, cst_src_bool_ml, 83, 9];
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[104],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     equal = include$1[10],
     max = include$1[11],
     min = include$1[12],
     Base_Bool =
       [0,
        all,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[204],
    func = Base_Import[218];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    include = caml_call1(Base_Comparator[5], [0, ascending, sexp_of_t]),
    comparator = include[1],
    num_bits = 32,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float;
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _z_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = runtime.caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = caml_lessthan,
    symbol$5 = runtime.caml_notequal,
    _b_ = [0, "src/int32.ml", 97, 4],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function descending(x, y){return ascending(y, x);}
   function min(x, y){return caml_lessthan(x, y) ? x : y;}
   function max(x, y){return caml_greaterthan(x, y) ? x : y;}
   function equal(x, y){return caml_equal(x, y);}
   function between(t, low, high){
    var _y_ = caml_lessequal(low, t);
    return _y_ ? caml_lessequal(t, high) : _y_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _v_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _w_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _v_],
     _x_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _w_);
    return caml_call1(Base_Or_error[35], _x_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_u_, _t_){return _u_ - _t_ | 0;}
   function symbol$9(_s_, _r_){return _s_ + _r_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[14],
    of_int64_exn = Base_Int_conversions[15],
    of_int64_trunc = Base_Int_conversions[16],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[25],
    of_nativeint_exn = Base_Int_conversions[26],
    of_nativeint_trunc = Base_Int_conversions[27],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _p_ = caml_call1(to_int_exn, e), _q_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _q_, _p_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$5 = x$0 | x$0 >>> 1 | 0,
     x$4 = x$5 | x$5 >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[101][2], x$0, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$4 = x | x >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _o_ = Stdlib_Int32[1], _n_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[101][4], _n_, _o_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _k_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_floor_log2_got_inval, _k_));
    }
    var
     _l_ = runtime.Base_int_math_int32_clz(i),
     _m_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _m_, _l_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _i_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_ceil_log2_got_invali, _i_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _j_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[92], num_bits, _j_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare = Base_Import[229],
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_h_){return _h_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$3[1],
    symbol$12 = include$3[2],
    symbol$13 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    Base_Int32 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int32_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int32_ctz(_f_);},
       [0,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        symbol,
        symbol$10,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        abs,
        symbol,
        zero,
        symbol$11,
        symbol$12,
        symbol$13,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       caml_int32_bswap];
   runtime.caml_register_global(29, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Assert_failure, Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[30],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _b_ = [0, "src/int63.ml", 155, 9],
    repr = Base_Word_size[3] ? 0 : 1,
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$0 = Base_Int[75],
    symbol$1 = Base_Int[76],
    symbol$2 = Base_Int[77],
    of_int = Base_Int[79],
    to_int32 = Base_Int[82],
    of_int64 = Base_Int[83],
    of_nativeint = Base_Int[84],
    _a_ = Base_Int[85];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_a_, x);}
   function to_nativeint(x){return [0, caml_call1(_a_, x)];}
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[85], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[86], caml_int64_of_int32(t)));
   }
   var
    repr$0 = 0,
    include =
      repr
       ? [0,
         Base_Int63_emul[1],
         Base_Int63_emul[2],
         Base_Int63_emul[3],
         Base_Int63_emul[4],
         Base_Int63_emul[5],
         Base_Int63_emul[6],
         Base_Int63_emul[7],
         Base_Int63_emul[8],
         Base_Int63_emul[9],
         Base_Int63_emul[10],
         Base_Int63_emul[11],
         Base_Int63_emul[12],
         Base_Int63_emul[13],
         Base_Int63_emul[14],
         Base_Int63_emul[15],
         Base_Int63_emul[16],
         Base_Int63_emul[17],
         Base_Int63_emul[18],
         Base_Int63_emul[19],
         Base_Int63_emul[20],
         Base_Int63_emul[21],
         Base_Int63_emul[22],
         Base_Int63_emul[23],
         Base_Int63_emul[24],
         Base_Int63_emul[25],
         Base_Int63_emul[26],
         Base_Int63_emul[27],
         Base_Int63_emul[28],
         Base_Int63_emul[29],
         Base_Int63_emul[30],
         Base_Int63_emul[31],
         Base_Int63_emul[32],
         Base_Int63_emul[33],
         Base_Int63_emul[34],
         Base_Int63_emul[35],
         Base_Int63_emul[36],
         Base_Int63_emul[37],
         Base_Int63_emul[38],
         Base_Int63_emul[39],
         Base_Int63_emul[40],
         Base_Int63_emul[41],
         Base_Int63_emul[42],
         Base_Int63_emul[43],
         Base_Int63_emul[44],
         Base_Int63_emul[45],
         Base_Int63_emul[46],
         Base_Int63_emul[47],
         Base_Int63_emul[48],
         Base_Int63_emul[49],
         Base_Int63_emul[50],
         Base_Int63_emul[51],
         Base_Int63_emul[52],
         Base_Int63_emul[53],
         Base_Int63_emul[54],
         Base_Int63_emul[55],
         Base_Int63_emul[56],
         Base_Int63_emul[57],
         Base_Int63_emul[58],
         Base_Int63_emul[59],
         Base_Int63_emul[60],
         Base_Int63_emul[61],
         Base_Int63_emul[62],
         Base_Int63_emul[63],
         Base_Int63_emul[64],
         Base_Int63_emul[65],
         Base_Int63_emul[66],
         Base_Int63_emul[67],
         Base_Int63_emul[68],
         Base_Int63_emul[69],
         Base_Int63_emul[70],
         Base_Int63_emul[71],
         Base_Int63_emul[72],
         Base_Int63_emul[73],
         Base_Int63_emul[74],
         Base_Int63_emul[75],
         Base_Int63_emul[76],
         Base_Int63_emul[77],
         Base_Int63_emul[78],
         Base_Int63_emul[79],
         Base_Int63_emul[80],
         Base_Int63_emul[81],
         Base_Int63_emul[83],
         Base_Int63_emul[84],
         Base_Int63_emul[85],
         Base_Int63_emul[86],
         Base_Int63_emul[87],
         Base_Int63_emul[88],
         Base_Int63_emul[89],
         Base_Int63_emul[90],
         ,
         Base_Int63_emul[92],
         Base_Int63_emul[93],
         Base_Int63_emul[94],
         Base_Int63_emul[95],
         Base_Int63_emul[96],
         Base_Int63_emul[97],
         Base_Int63_emul[98],
         Base_Int63_emul[99],
         Base_Int63_emul[100],
         Base_Int63_emul[101],
         Base_Int63_emul[102],
         Base_Int63_emul[103],
         Base_Int63_emul[104],
         Base_Int63_emul[105],
         Base_Int63_emul[106],
         Base_Int63_emul[107],
         Base_Int63_emul[82],
         Base_Int63_emul[113],
         Base_Int63_emul[108],
         Base_Int63_emul[109],
         Base_Int63_emul[110]]
       : [0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_aG_, _aF_){return _aF_ <= _aG_ ? 1 : 0;},
         function(_aE_, _aD_){return _aE_ <= _aD_ ? 1 : 0;},
         function(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;},
         function(_aA_, _az_){return _az_ < _aA_ ? 1 : 0;},
         function(_ay_, _ax_){return _ay_ < _ax_ ? 1 : 0;},
         function(_aw_, _av_){return _aw_ !== _av_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_au_, _at_){return _au_ + _at_ | 0;},
         function(_as_, _ar_){return _as_ - _ar_ | 0;},
         caml_mul,
         symbol,
         function(_aq_){return - _aq_ | 0;},
         function(_ap_){return - _ap_ | 0;},
         symbol$1,
         symbol$0,
         caml_div,
         rem,
         symbol$2,
         function(_ao_, _an_){return _ao_ & _an_;},
         function(_am_, _al_){return _am_ | _al_;},
         function(_ak_, _aj_){return _ak_ ^ _aj_;},
         lnot,
         function(_ai_, _ah_){return _ai_ << _ah_;},
         function(_ag_, _af_){return _ag_ >> _af_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         num_bits,
         max_value,
         min_value,
         function(_ae_, _ad_){return _ae_ >>> _ad_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         ,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_ac_, _ab_){return _ac_ + _ab_ | 0;},
          function(_aa_, _$_){return _aa_ - _$_ | 0;},
          caml_mul,
          caml_div,
          function(___){return - ___ | 0;},
          O[1],
          function(_Z_, _Y_){return _Y_ <= _Z_ ? 1 : 0;},
          function(_X_, _W_){return _X_ <= _W_ ? 1 : 0;},
          function(_V_, _U_){return _V_ === _U_ ? 1 : 0;},
          function(_T_, _S_){return _S_ < _T_ ? 1 : 0;},
          function(_R_, _Q_){return _R_ < _Q_ ? 1 : 0;},
          function(_P_, _O_){return _P_ !== _O_ ? 1 : 0;},
          O[3],
          function(_N_){return - _N_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_M_, _L_){return _M_ & _L_;},
          function(_K_, _J_){return _K_ | _J_;},
          function(_I_, _H_){return _I_ ^ _H_;},
          O[2],
          function(_G_, _F_){return _G_ << _F_;},
          function(_E_, _D_){return _E_ >> _D_;},
          function(_C_, _B_){return _C_ >>> _B_ | 0;}],
         of_int,
         to_int,
         to_int_trunc,
         of_int32_exn,
         to_int32,
         function(_A_){return _A_;},
         of_int64,
         caml_int64_to_int32,
         of_nativeint,
         to_nativeint,
         function(_z_){return _z_;},
         to_nativeint_trunc,
         of_float_unchecked,
         repr$0,
         runtime.caml_bswap16,
         bswap32,
         bswap48],
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    invariant$0 = include[35],
    Hex$0 = include[36],
    to_string_hum$0 = include[37],
    zero$0 = include[38],
    one$0 = include[39],
    minus_one$0 = include[40],
    symbol$9 = include[41],
    symbol$10 = include[42],
    symbol$11 = include[43],
    symbol$12 = include[44],
    neg = include[45],
    symbol$13 = include[46],
    symbol$14 = include[47],
    symbol$15 = include[48],
    symbol$16 = include[49],
    rem$0 = include[50],
    symbol$17 = include[51],
    land = include[52],
    lor = include[53],
    lxor = include[54],
    lnot$0 = include[55],
    lsl = include[56],
    asr = include[57],
    round$0 = include[58],
    round_towards_zero$0 = include[59],
    round_down$0 = include[60],
    round_up$0 = include[61],
    round_nearest$0 = include[62],
    abs$0 = include[63],
    succ$0 = include[64],
    pred$0 = include[65],
    pow$0 = include[66],
    bit_and$0 = include[67],
    bit_or$0 = include[68],
    bit_xor$0 = include[69],
    bit_not$0 = include[70],
    popcount$0 = include[71],
    shift_left$0 = include[72],
    shift_right$0 = include[73],
    decr$0 = include[74],
    incr$0 = include[75],
    of_int32_exn$0 = include[76],
    to_int32_exn$0 = include[77],
    of_int64_exn$0 = include[78],
    to_int64$0 = include[79],
    of_nativeint_exn$0 = include[80],
    to_nativeint_exn$0 = include[81],
    num_bits$0 = include[82],
    max_value$0 = include[83],
    min_value$0 = include[84],
    lsr = include[85],
    shift_right_logical$0 = include[86],
    ceil_pow2$0 = include[87],
    floor_pow2$0 = include[88],
    ceil_log2$0 = include[89],
    is_pow2$0 = include[91],
    clz$0 = include[92],
    ctz$0 = include[93],
    O$0 = include[94],
    of_int$0 = include[95],
    to_int$0 = include[96],
    to_int_trunc$0 = include[97],
    of_int32 = include[98],
    to_int32$0 = include[99],
    to_int32_trunc = include[100],
    of_int64$0 = include[101],
    of_int64_trunc = include[102],
    of_nativeint$0 = include[103],
    to_nativeint$0 = include[104],
    of_nativeint_trunc = include[105],
    to_nativeint_trunc$0 = include[106],
    of_float_unchecked$0 = include[107],
    repr$1 = include[108],
    bswap16 = include[109],
    bswap32$0 = include[110],
    bswap48$0 = include[111];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _v_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _v_),
        zero$0))
     return sum;
    var
     _w_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _x_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _w_],
     _y_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _x_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow, _y_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _r_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[14], pos_diff, _r_)){
      var
       _s_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _t_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _s_],
       _u_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _t_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$0, _u_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _q_ = caml_call2(symbol$5, t, min_value$0);
    return _q_ ? caml_call2(symbol$5, u, negative_one) : _q_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _n_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _o_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _n_],
      _p_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _o_];
     return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$1, _p_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _k_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _l_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _k_],
     _m_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _l_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$2, _m_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _j_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[18][6], state, _j_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _i_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[18][9], state, _i_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var
     _g_ = caml_call1(to_int_exn$0, hi),
     _h_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[18][11], state, _h_, _g_));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _e_ = caml_call1(to_int64$0, hi), _f_ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[18][14], state, _f_, _e_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _c_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[66], _c_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _d_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _d_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$0,
       Hex$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[112], repr$1]];
   runtime.caml_register_global(31, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Merge_into_action = [0],
    Base_Hashtbl_intf = [0, Key, Merge_into_action];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Assert_failure, Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30];
   function max(x, y){return y < x ? x : y;}
   var
    _a_ = [0, cst_src_avltree_ml, 50, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _j_ = [0, cst_src_avltree_ml, 193, 9],
    _k_ = [0, cst_src_avltree_ml, 205, 9],
    _l_ = [0, cst_src_avltree_ml, 417, 15],
    _m_ = [0, cst_src_avltree_ml, 436, 18],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl";
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _B_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[90], _B_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _C_ = caml_call2(Base_Import[92], hl, hr);
      if(2 < caml_call1(Base_Import[122], _C_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _z_ = height(right),
      _A_ = max(height(left), _z_),
      new_height = caml_call2(Base_Import[90], _A_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[90], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _x_ = height(left_node_right);
       if(_x_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[90], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _y_ = height(right_node_left);
      if(_y_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function set_left(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var left = node[1];
     if(! caml_call2(Base_Import[127], left, tree$0)) node[1] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function set_right(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var right = node[5];
     if(! caml_call2(Base_Import[127], right, tree$0)) node[5] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function add(t, replace, added, compare, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     added[1] = 0;
     if(replace) t[3] = v;
    }
    else if(0 <= c)
     set_right(t, add(right, replace, added, compare, k, v));
    else
     set_left(t, add(left, replace, added, compare, k, v));
    return t;
   }
   function add$0(t, replace, compare, added, key, data){
    var t$0 = add(t, replace, added, compare, key, data);
    return added[1] ? balance(t$0) : t$0;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _v_ = t$0[2], _w_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5]; t$0 = r; continue;}
      var v = _w_, k = _v_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left;
     t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _u_, _t_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _s_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _r_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _q_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _p_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 === left[0]){set_left(tree, remove_min_elt(left)); return tree;}
    var k = tree[2], v = tree[3];
    return typeof tree[5] === "number" ? [1, k, v] : (set_left(tree, 0), tree);
   }
   function remove(t, removed, compare, k$0){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$2 = t[1];
     return 0 === caml_call2(compare, k$0, k$2)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left$0 = t[1],
     k$1 = t[2],
     right = t[5],
     c = caml_call2(compare, k$0, k$1);
    if(0 !== c)
     return 0 <= c
             ? (set_right(t, remove(right, removed, compare, k$0)), t)
             : (set_left(t, remove(left$0, removed, compare, k$0)), t);
    removed[1] = 1;
    if(typeof left$0 === "number") return right;
    if(typeof right === "number") return left$0;
    var tree = right;
    for(;;){
     if(typeof tree === "number")
      var tree$0 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){tree = left; continue;}
      var tree$0 = tree;
     }
     else
      var tree$0 = tree;
     if(typeof tree$0 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     if(0 === tree$0[0]){
      set_right(tree$0, remove_min_elt(right));
      set_left(tree$0, left$0);
      return tree$0;
     }
     var
      k = tree$0[1],
      v = tree$0[2],
      t2 = balance(remove_min_elt(right)),
      _n_ = height(t2),
      _o_ = max(height(left$0), _n_);
     return [0, left$0, k, v, caml_call2(Base_Import[90], _o_, 1), t2];
    }
   }
   function remove$0(t, removed, compare, k){
    return balance(remove(t, removed, compare, k));
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0));
       t$0 = right$0;
       init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f));
     t$0 = right;
     init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       0,
       is_empty,
       invariant,
       add$0,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove$0,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(18, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[30],
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[5][3];}
   function compare_key(t){return t[5][2];}
   function ensure_mutation_allowed(t){
    var _aC_ = 1 - t[6];
    return _aC_
            ? caml_call1(Base_Import[123], cst_Hashtbl_mutation_not_allow)
            : _aC_;
   }
   function without_mutating(t, f){
    if(! t[6]) return caml_call1(f, 0);
    t[6] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = 1;
    return x;
   }
   var
    max_table_length = caml_call1(Base_Int[64], Base_Array[24]),
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    _a_ = [0, cst_src_hashtbl_ml, 323, 2],
    _b_ = [0, "Hashtbl.find_exn: not found"],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 575, 4],
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values";
   function create(opt, _aA_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aA_) var sth$0 = _aA_[1], size = sth$0; else var size = 0;
    var
     _aB_ = caml_call2(Base_Int[15], 1, size),
     size$0 = caml_call2(Base_Int[14], _aB_, max_table_length),
     size$1 = caml_call1(Base_Int[63], size$0);
    return [0,
            caml_call2(Base_Array[25], size$1, Base_Avltree[1]),
            0,
            [0, 0],
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[5][1], key),
     _az_ = caml_call2(Base_Import[92], t[1].length - 1, 1);
    return caml_call2(Base_Import[115], hash, _az_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = t[3];
    added[1] = 0;
    var
     _aw_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aw_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[90], t[2], 1);
    var
     _ax_ = 1 - caml_call2(Base_Import[127], new_root, root),
     _ay_ = _ax_ ? (caml_check_bound(t[1], i)[1 + i] = new_root, 0) : _ax_;
    return _ay_;
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _an_ = should_grow ? t[4] : should_grow;
    if(_an_){
     var
      _ao_ = caml_call2(Base_Import[87], len, 2),
      new_array_length = caml_call2(Base_Int[14], _ao_, max_table_length),
      _ap_ = len < new_array_length ? 1 : 0;
     if(_ap_){
      var
       new_table =
         caml_call2(Base_Array[25], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){return add_worker(t, 1, key, data);},
       _ar_ = caml_call2(Base_Import[92], old_table.length - 1, 1),
       _aq_ = 0;
      if(_ar_ >= 0){
       var i = _aq_;
       for(;;){
        var _au_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _au_, f);
        var _av_ = i + 1 | 0;
        if(_ar_ === i) break;
        i = _av_;
       }
      }
      var _as_ = 0;
     }
     else
      var _as_ = _ap_;
     var _at_ = _as_;
    }
    else
     var _at_ = _an_;
    return _at_;
   }
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 0, key, data);
    return t[3][1] ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[29], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _ak_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      var _al_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _al_;
      var _am_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _am_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _ai_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _af_ = slot(t, key), tree = caml_check_bound(t[1], _af_)[1 + _af_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _ag_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _ag_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ad_ = slot(t, key), tree = caml_check_bound(t[1], _ad_)[1 + _ad_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ae_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _ae_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _ab_ = slot(t, key), tree = caml_check_bound(t[1], _ab_)[1 + _ab_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ac_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ac_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _$_ = slot(t, key), tree = caml_check_bound(t[1], _$_)[1 + _$_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _aa_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _aa_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _Z_ = slot(t, key), tree = caml_check_bound(t[1], _Z_)[1 + _Z_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var ___ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, ___, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _X_ = slot(t, key), tree = caml_check_bound(t[1], _X_)[1 + _X_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _Y_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _Y_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added_or_removed = t[3];
    added_or_removed[1] = 0;
    var
     _U_ = compare_key(t),
     new_root = caml_call4(Base_Avltree[15], root, added_or_removed, _U_, key);
    if(1 - caml_call2(Base_Import[127], root, new_root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _V_ = added_or_removed[1],
     _W_ = _V_ ? (t[2] = caml_call2(Base_Import[92], t[2], 1), 0) : _V_;
    return _W_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[6];
    try{
     t[6] = 0;
     var _S_ = caml_call2(Base_Import[92], n, 1), _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _T_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _T_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[6];
    try{
     t[6] = 0;
     var _P_ = caml_call2(Base_Import[92], n, 1), _O_ = 0;
     if(_P_ >= 0){
      var i = _O_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _Q_ = i + 1 | 0;
       if(_P_ === i) break;
       i = _Q_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = caml_check_bound(table, i$0)[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var i$1 = caml_call2(Base_Import[90], i$0, 1);
     i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function invariant(invariant_key, invariant_data, t){
    var _K_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var _L_ = compare_key(t), _M_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _M_, _L_);
      var _N_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _N_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[90], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _I_ = [1, [0, _b_, [0, caml_call1(t[5][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _I_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _H_ = caml_call2(f, key, data);
                 return _H_ ? caml_call1(r, 1) : _H_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_G_){return _G_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[4]], [0, t[2]], t[5], 0),
     t1 = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _F_){return data;},
             function(key, t, default$0){
              var default$1 = caml_call1(default$0, 0);
              set(t, key, default$1);
              return default$1;
             });
   }
   function findi_or_add(t, id, default$0){
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _E_){return data;},
             function(key, t, default$0){
              var default$1 = caml_call1(default$0, key);
              set(t, key, default$1);
              return default$1;
             });
   }
   function find_and_remove(t, key){
    var result = find_and_call(t, key, if_found, if_not_found);
    if(caml_call1(Base_Option[50], result)) remove(t, key);
    return result;
   }
   function change(t, key, f){
    var match = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    if(! match) return remove(t, key);
    var data = match[1];
    return set(t, key, data);
   }
   function update_and_return(t, key, f){
    var data = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    set(t, key, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _D_ = caml_call2(Base_Option[27], opt, 0),
                 n = caml_call2(Base_Import[90], by, _D_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[90], by, i);
               });
   }
   function incr(opt, _C_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_C_)
     var sth$0 = _C_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _B_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_B_)
     var sth$0 = _B_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[112], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var _A_ = match[1];
    if(_A_ && _A_[2]){var tl = _A_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[7], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    caml_call2
     (Base_List[9],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return mem(res, key)
               ? (dupes[1] = [0, key, dupes[1]], 0)
               : set(res, key, data);
      });
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[114], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[124],
         Base_Import[126],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[67], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[124],
             Base_Import[126],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[29], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[126], get_key = Base_Import[124];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[7], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    caml_call2
     (Base_List[9],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return add_multi(res, key, data);
      });
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _w_ = to_alist(t),
     _x_ =
       caml_call2
        (Base_List[62],
         _w_,
         function(param, _z_){
          var k2 = _z_[1], k1 = param[1];
          return caml_call2(t[5][2], k1, k2);
         }),
     _y_ = caml_call2(Base_Import[149], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[151], _y_), _x_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _p_ = caml_call2(Base_Import[173], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[175], _p_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[7], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _q_ =
       caml_call2
        (Base_Import[173],
         function(_v_){return _v_;},
         function(_u_){return _u_;}),
     alist_sexps = caml_call2(Base_Import[175], _q_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List[42],
      alist,
      alist_sexps,
      function(param, _r_){
       var
        k2_sexp = _r_[1],
        k2 = param[1],
        _s_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
       if(_s_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[158], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
        found_first_k[1] = 1;
        var _t_ = 0;
       }
       else
        var _t_ = _s_;
       return _t_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _o_ = caml_call2(Base_List[129][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _o_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    caml_call2
     (Base_List[9],
      rows,
      function(row){
       var
        key = caml_call1(get_key, row),
        data = caml_call1(get_data, row),
        match = find_and_call(groups, key, if_found, if_not_found);
       if(match)
        var old = match[1], data$0 = caml_call2(combine, old, data);
       else
        var data$0 = data;
       return set(groups, key, data$0);
      });
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_n_){return _n_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _l_ =
        [0, [0, cst_keys, caml_call2(Base_Import[151], sexp_of_key, keys)], 0],
      _m_ = caml_call2(Base_Sexp[9], cst_Hashtbl_create_with_key_du, _l_);
     return caml_call1(Base_Or_error[35], _m_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _k_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[31], _k_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[5], t_right[5]))
     caml_call1(Base_Import[125], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[4]], [0, t_left[2]], t_left[5], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var
                     match = find_and_call(t_right, key, if_found, if_not_found);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find_and_call(t_left, key, if_found, if_not_found)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data$0 = find_and_call(dst, key, if_found, if_not_found),
               action =
                 without_mutating
                  (dst,
                   function(param){
                    return caml_call3(f, key, data, dst_data$0);
                   });
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data$0) return set(dst, key, data$0);
              var
               dst_data = dst_data$0[1],
               _j_ = 1 - caml_call2(Base_Import[127], dst_data, data$0);
              return _j_ ? set(dst, key, data$0) : _j_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    return caml_call2
            (Base_List[9], to_remove, function(key){return remove(t, key);});
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    return caml_call2
            (Base_List[9],
             map_results,
             function(param){
              var result = param[2], key = param[1];
              if(! result) return remove(t, key);
              var data = result[1];
              return set(t, key, data);
             });
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              return caml_call2
                      (Base_Array[9],
                       t[1],
                       function(_i_){return caml_call2(_h_, _i_, f);});
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find_and_call(t, key, if_found, if_not_found);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[5];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[5]);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){return sexp_of_t(K[1], sexp_of_v, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     var _e_ = K[1];
     return t_of_sexp
             (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
              _e_,
              v_of_sexp,
              sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){return t_sexp_grammar(K[1], v_grammar);};
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(24, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[81],
    hashable = Base_Hashtbl[90][1],
    poly_hashable = Base_Hashtbl[84][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[30],
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[29], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (Base_Hashtbl[19],
                t,
                function(elt){
                 var o = caml_call1(f, elt);
                 return o ? caml_call1(r, o) : 0;
                });
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[34], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[36], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[34], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _r_ = strict_add(t, k);
    return caml_call1(Base_Or_error[31], _r_);
   }
   var
    remove = Base_Hashtbl[31],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set";
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _q_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[34], 0, 0, cst_element_not_in_set, k, _q_);
   }
   function strict_remove_exn(t, k){
    var _p_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[31], _p_);
   }
   function fold(t, init, f){
    return caml_call3
            (Base_Hashtbl[18],
             t,
             init,
             function(key, param, acc){return caml_call2(f, acc, key);});
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _n_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_o_){return caml_call2(_n_, _o_, t);};
   }
   var
    to_list = Base_Hashtbl[64],
    _c_ = [0, 0],
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element";
   function sexp_of_t(sexp_of_e, t){
    var
     _l_ = caml_call1(to_list, t),
     func = Base_List[62],
     _m_ = caml_call2(func, _l_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[151], sexp_of_e, _m_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[92], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[25], len, key);
              index[1] = caml_call2(Base_Import[92], index[1], 1);
              var _k_ = index[1];
              runtime.caml_check_bound(acc, _k_)[1 + _k_] = key;
              return acc;
             });
   }
   function exists(t, f){
    return caml_call2
            (Base_Hashtbl[22],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function for_all(t, f){
    return 1
           -
            caml_call2
             (Base_Hashtbl[22],
              t,
              function(key, param){return 1 - caml_call1(f, key);});
   }
   function equal(t1, t2){
    return caml_call3
            (Base_Hashtbl[73], function(param, _j_){return 1;}, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    return caml_call2
            (Base_Hashtbl[46],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function union(t1, t2){
    return caml_call3
            (Base_Hashtbl[62], t1, t2, function(param, _i_){return _c_;});
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[30], t2, key);});
   }
   function inter(t1, t2){
    var _h_ = caml_call1(length, t2);
    if(_h_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    return caml_call2
            (Base_Hashtbl[46],
             smaller,
             function(key, param){
              return caml_call2(Base_Hashtbl[30], larger, key);
             });
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    return caml_call2
            (Base_List[9],
             to_remove,
             function(x){return caml_call2(remove, t, x);});
   }
   function of_hashtbl_keys(hashtbl){
    return caml_call2(Base_Hashtbl[40], hashtbl, function(_g_){return 0;});
   }
   function to_hashtbl(t, f){
    return caml_call2
            (Base_Hashtbl[41],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[7], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    caml_call2(Base_List[9], l, function(k){return add(t, k);});
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Hash_set_t_of_sexp_require, sexp);
    var list = sexp[1], t = create(0, [0, caml_call1(Base_List[7], list)], m);
    caml_call2
     (Base_List[9],
      list,
      function(sexp){
       var e = caml_call1(e_of_sexp, sexp);
       return 0 === strict_add(t, e)[0]
               ? 0
               : caml_call2
                 (Base_Import[158], cst_Hash_set_t_of_sexp_got_a_d, sexp);
      });
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){return sexp_of_t(Elt[1], t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){
     return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[90][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Assert_failure, Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_006 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    nan = Base_Float0[6],
    max_value = Base_Float0[7],
    neg_infinity = Base_Float0[8],
    max_finite_value = Base_Float0[9],
    epsilon_float = Base_Float0[10],
    classify_float = Base_Float0[11],
    abs_float = Base_Float0[12],
    is_integer = Base_Float0[13],
    symbol = Base_Float0[14],
    symbol$0 = Base_Float0[15],
    frexp = Base_Float0[16],
    ldexp = Base_Float0[17],
    is_nan = Base_Float0[18],
    to_int64_preserve_order = Base_Float0[19],
    to_int64_preserve_order_exn = Base_Float0[20],
    of_int64_preserve_order = Base_Float0[21],
    one_ulp = Base_Float0[22],
    upper_bound_for_int = Base_Float0[23],
    lower_bound_for_int = Base_Float0[25],
    clamp_unchecked = Base_Float0[26],
    box = Base_Float0[27],
    compare = Base_Float0[36],
    raise_s = Base_Error[30],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[107][9],
    include = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t]),
    comparator = include[1],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _aV_ = caml_call1(float_of_string, s); return _aV_;}
    catch(_aW_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     _aU_ = caml_call1(float_of_string, y),
     y$0 =
       caml_call2(Base_Import[107][4], _aU_, x)
        ? y
        : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[111], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    zero = 0.,
    of_int = Base_Int[3],
    to_int = Base_Int[2];
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[59]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[59]),
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"];
   function iround_up(t){
    if(! caml_call2(Base_Import[107][5], t, 0.))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_up, t);
    return caml_call2(Base_Import[107][2], t$0, iround_ubound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aS_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _aS_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aT_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _aT_, 0);
   }
   function iround_down(t){
    if(caml_call2(Base_Import[107][6], t, 0.))
     return caml_call2(Base_Import[107][2], t, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_down, t);
    return caml_call2(Base_Import[107][6], t$0, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aQ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aQ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, iround_lbound))
     return caml_call1(Base_Int[58], t$0);
    var _aR_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _aR_, 0);
   }
   function iround_towards_zero(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return [0, caml_call1(Base_Int[58], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return caml_call1(Base_Int[58], t);
    var _aP_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aP_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[113], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var
     _aO_ =
       caml_call2(Base_Import[107][4], t, one_ulp_less_than_half)
        ? one_ulp_less_than_half
        : 0.5;
    return caml_call2(Base_Import[91], t, _aO_);
   }
   function iround_nearest_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     return caml_call2(Base_Import[107][2], t$0, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t$0)]
             : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return caml_call2(Base_Import[107][6], t$1, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$1)]
            : 0;
   }
   function iround_nearest_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(! caml_call2(Base_Import[107][1], t, round_nearest_ub))
      return caml_call2(Base_Import[107][2], t, iround_ubound)
              ? [0, caml_call1(Base_Int[58], t)]
              : 0;
     var _aM_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[58], _aM_)];
    }
    if(! caml_call2(Base_Import[107][5], t, round_nearest_lb))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var _aN_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return [0, caml_call1(Base_Int[58], _aN_)];
   }
   var
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 859, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 697, 8],
    _E_ = [0, cst_src_float_ml, 700, 8],
    _A_ = [0, cst_src_float_ml, 707, 8],
    _B_ = [0, cst_src_float_ml, 708, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 684, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329,
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aK_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aK_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    if(caml_call2(Base_Import[107][6], t$1, iround_lbound))
     return caml_call1(Base_Int[58], t$1);
    var _aL_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aL_, 0);
   }
   function iround_nearest_exn_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][1], t, round_nearest_ub)){
      var _aG_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[58], _aG_);
     }
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aH_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aH_, 0);
    }
    if(caml_call2(Base_Import[107][5], t, round_nearest_lb)){
     var _aI_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
     return caml_call1(Base_Int[58], _aI_);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aJ_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aJ_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aE_ = [0, iround_exn([0, dir], t)]; return _aE_;}
    catch(_aF_){return 0;}
   }
   function is_inf(t){
    var _aD_ = caml_call2(Base_Import[95], 1., t);
    return caml_call2(Base_Import[107][4], _aD_, 0.);
   }
   function is_finite(t){
    var _aC_ = caml_call2(Base_Import[93], t, t);
    return caml_call2(Base_Import[107][4], _aC_, 0.);
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][1], x, y) ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][5], x, y) ? x : y;
   }
   var
    add = Base_Import[91],
    sub = Base_Import[93],
    neg = Base_Import[113],
    scale = Base_Import[89];
   function square(x){return caml_call2(Base_Import[89], x, x);}
   function fractional(t){return caml_call1(Base_Import[124], t);}
   function integral(t){return caml_call1(Base_Import[126], t);}
   function round_towards_zero(t){
    return caml_call2(Base_Import[107][6], t, 0.)
            ? caml_call1(round_down, t)
            : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if
     (caml_call2(Base_Import[107][5], t, round_nearest_lb)
      && caml_call2(Base_Import[107][1], t, round_nearest_ub))
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[91], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if
     (!
      caml_call2(Base_Import[107][2], t, round_nearest_lb)
      && ! caml_call2(Base_Import[107][6], t, round_nearest_ub)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[91], floor, 1.),
      diff_floor = caml_call2(Base_Import[93], t, floor),
      diff_ceil = caml_call2(Base_Import[93], ceil_or_succ, t);
     if(caml_call2(Base_Import[107][1], diff_floor, diff_ceil)) return floor;
     if(caml_call2(Base_Import[107][5], diff_floor, diff_ceil))
      return ceil_or_succ;
     var _aB_ = caml_call2(mod_float, floor, 2.);
     return caml_call2(Base_Import[107][4], _aB_, 0.) ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[91], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[83]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[83]);
   function int63_round_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, int63_round_ubound))
      return caml_call1(Base_Int63[82], t$0);
     var _az_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _l_, _az_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aA_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _m_, _aA_, 0);
   }
   function int63_round_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _ax_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _n_, _ax_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, int63_round_lbound))
     return caml_call1(Base_Int63[82], t$0);
    var _ay_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _o_, _ay_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(caml_call2(Base_Import[107][5], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _av_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _av_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aw_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _aw_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _au_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[96], _au_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? round_towards_zero(t)
              : round_nearest_inline(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare$1 = runtime.caml_int_compare;
   function t_of_sexp$0(sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _ao_ = sexp_007[1], _ap_ = caml_string_compare(_ao_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _ap_){
           if(0 < _ap_){
            if(_ao_ === cst_nan$1) break e;
            if(_ao_ === cst_normal) break d;
            if(_ao_ === cst_subnormal) break c;
            if(_ao_ !== cst_zero) break a;
            break b;
           }
          }
          else if(_ao_ !== cst_Infinite){
           if(_ao_ === cst_Nan) break e;
           if(_ao_ === cst_Normal) break d;
           if(_ao_ === cst_Subnormal) break c;
           if(_ao_ !== cst_Zero) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _aq_ = sexp_007[1];
     if(! _aq_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_007);
     var _ar_ = _aq_[1];
     if(0 !== _ar_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_007);
     var _as_ = _ar_[1], _at_ = caml_string_compare(_as_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _at_){
          if(0 < _at_){
           if(_as_ === cst_nan$1) break e;
           if(_as_ === cst_normal) break d;
           if(_as_ === cst_subnormal) break c;
           if(_as_ !== cst_zero) break a;
           break b;
          }
         }
         else if(_as_ !== cst_Infinite){
          if(_as_ === cst_Nan) break e;
          if(_as_ === cst_Normal) break d;
          if(_as_ === cst_Subnormal) break c;
          if(_as_ !== cst_Zero) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_007);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _an_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[162], _an_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[138], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _al_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_al_) var sth$0 = _al_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[84], string, 46);
    if(! match)
     return caml_call2(Base_Int_conversions[37], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_conversions[37], left, delimiter),
     right$0 =
       strip_zero
        ? caml_call2
          (Base_String[92],
           [0, function(c){return caml_call2(Base_Char[11], c, 48);}],
           right)
        : right;
    if(right$0 === cst$4) return left$0;
    var _am_ = caml_call2(Base_Import[111], cst$0, right$0);
    return caml_call2(Base_Import[111], left$0, _am_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _ak_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_ak_)
     var sth$0 = _ak_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match)
     return caml_call2(Base_Import[107][5], f, 0.) ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[18][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[56], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _aj_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[4], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_sexp_of_float_produced_str, _aj_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match)
     return caml_call2(Base_Import[107][1], t, 0.) ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if
        (caml_call2(Base_Import[107][4], denominator, 100.)
         && caml_call2(Base_Import[107][6], numerator, 999.95))
        break a;
       if(caml_call2(Base_Import[107][6], denominator, 100000.)){
        var
         t$0 = caml_call2(Base_Import[89], denominator, 9.9995),
         _ai_ = round_nearest_inline(t$0);
        if(caml_call2(Base_Import[107][6], numerator, _ai_)) break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      var
       t = caml_call2(Base_Import[89], denominator, 9999.5),
       _ah_ = round_nearest_inline(t);
      if(! caml_call2(Base_Import[107][1], numerator, _ah_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[95], numerator, denominator)),
       lower = caml_call2(Base_Import[89], denominator, k),
       _ag_ = caml_call2(Base_Import[91], k, 1.),
       higher = caml_call2(Base_Import[89], denominator, _ag_),
       diff_right = caml_call2(Base_Import[93], higher, numerator),
       diff_left = caml_call2(Base_Import[93], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         caml_call2(Base_Import[107][1], diff_right, diff_left)
          ? caml_call2(Base_Import[90], k$0, 1)
          : caml_call2
             (Base_Import[107][5], diff_right, diff_left)
            ? k$0
            : 0
              === caml_call2(Base_Import[121], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[90], k$0, 1),
       d = caml_call2(Base_Import[121], k$1, 10),
       i = caml_call2(Base_Import[94], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! caml_call2(Base_Import[107][1], t, 999.95)){
      if(caml_call2(Base_Import[107][1], t, 999950.))
       return conv(kilo, t, 100.);
      if(caml_call2(Base_Import[107][1], t, 999950000.))
       return conv(mega, t, 100000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000.))
       return conv(giga, t, 100000000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000000.))
       return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return caml_call2(Base_Import[107][1], t, 999950000000000000.)
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if
      (caml_call2(Base_Import[107][2], 0., t)
       && caml_call2(Base_Import[107][1], t, 999.95)){
      var
       x = caml_call2(Base_Import[111], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[80], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[15], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 2), 32);
      return caml_call1(Base_Bytes0[16], x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(caml_call2(Base_Import[107][6], t, 0.)) return go(t);
    var _af_ = go(caml_call1(Base_Import[113], t));
    return caml_call2(Base_Import[111], cst$1, _af_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[91], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[95], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[112], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; caml_call1(Base_Import[128], n$0);}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[89], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[115], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[89], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[89], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[119], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(caml_call2(Base_Import[107][4], x, 0.)) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ab_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[92], sd, _ab_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _ae_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[90], dd$1, _ae_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[73], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ac_ =
         round_nearest_half_to_even(caml_call2(Base_Import[89], x, order));
      return caml_call2(Base_Import[95], _ac_, order);
     }
     var
      _ad_ = round_nearest_half_to_even(caml_call2(Base_Import[95], x, order));
     return caml_call2(Base_Import[89], _ad_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _aa_ = caml_call2(Base_Import[107][2], low, t);
    return _aa_ ? caml_call2(Base_Import[107][2], t, high) : _aa_;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     _Z_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     ___ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _Z_],
     _$_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, ___);
    return caml_call1(Base_Or_error[35], _$_);
   }
   var
    symbol$1 = Base_Import[91],
    symbol$2 = Base_Import[93],
    symbol$3 = Base_Import[89],
    symbol$4 = Base_Import[95],
    symbol$5 = Base_Import[113];
   function sign_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)) return 2;
    if(caml_call2(Base_Import[107][1], t, 0.)) return 0;
    if(caml_call2(Base_Import[107][4], t, 0.)) return 1;
    var
     _X_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _Y_ = caml_call2(Base_Sexp[9], cst_Float_sign_exn_of_NAN, _X_);
    return caml_call1(Base_Error[30], _Y_);
   }
   function sign_or_nan(t){
    return caml_call2(Base_Import[107][5], t, 0.)
            ? 2
            : caml_call2
               (Base_Import[107][1], t, 0.)
              ? 0
              : caml_call2(Base_Import[107][4], t, 0.) ? 1 : 3;
   }
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    mantissa_bits = 52,
    _M_ = Base_Int64[32],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[48], Base_Int64[32], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[5], exponent_mask64),
    _N_ = Base_Int63[39],
    _O_ = caml_call2(Base_Int63[72], Base_Int63[39], mantissa_bits),
    mantissa_mask = caml_call2(Base_Int63[42], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[79], mantissa_mask);
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _W_ = caml_call2(Base_Int64[62], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[43], _W_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[78], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[43], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _T_ = caml_call2(Base_Int63[67], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _T_, mantissa)){
     var
      _U_ = caml_call1(Base_Int63[11], mantissa_mask),
      _V_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _V_, _U_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[79], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    return caml_call2
            (Base_Or_error[28],
             0,
             function(param){
              return create_ieee_exn(negative, exponent, mantissa);
             });
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return caml_call2(Base_Import[107][5], t, 0.);}
   function is_non_negative(t){return caml_call2(Base_Import[107][6], t, 0.);}
   function is_negative(t){return caml_call2(Base_Import[107][1], t, 0.);}
   function is_non_positive(t){return caml_call2(Base_Import[107][2], t, 0.);}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1],
    _S_ = Base_Import[107],
    symbol$6 = _S_[3],
    symbol$7 = _S_[1],
    symbol$8 = _S_[5],
    symbol$9 = _S_[4],
    symbol$10 = _S_[2],
    symbol$11 = _S_[6];
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[107],
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    symbol$15 = include$2[4],
    symbol$16 = include$2[5],
    symbol$17 = include$2[6],
    ascending = include$2[7],
    descending = include$2[8],
    compare$2 = include$2[9],
    equal = include$2[10];
   function min(x, y){
    if(! caml_call2(symbol$12, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! caml_call2(symbol$16, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       symbol$17,
       symbol$13,
       symbol$15,
       symbol$16,
       symbol$12,
       symbol$14,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       invariant,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$1,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[138], _c_);
   }
   function create$0(len){return caml_call1(Base_Bytes[31], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(Stdlib_Buffer[5], src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0];
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[60];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _f_ = to_string(t);
    return caml_call1(Base_String[88], _f_);
   }
   function sexp_of_t(t){
    var _e_ = to_string_list(t);
    return [1, caml_call2(Base_List[76], _e_, function(x){return [0, x];})];
   }
   var
    set_recording = Stdlib_Printexc[7],
    am_recording = Stdlib_Printexc[8],
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM",
    cst_b = "b";
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    return caml_call2
            (Base_Exn[13],
             f,
             function(param){return caml_call1(set_recording, saved);});
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[20], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[81],
      _b_ = caml_call2(Base_String[86], x, 44),
      ocamlrunparam_mentions_backtra =
        caml_call2
         (Base_List[13],
          _b_,
          function(_d_){return caml_call2(_a_, _d_, cst_b);});
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _c_ = 1 - ocamlrunparam_mentions_backtra;
    return _c_ ? caml_call1(set_recording, 1) : _c_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    hash_fold_t = Base_Sexp_with_comparable[1],
    hash = Base_Sexp_with_comparable[2],
    t_of_sexp = Base_Sexp_with_comparable[3],
    sexp_of_t = Base_Sexp_with_comparable[4],
    Not_found_s = Base_Sexp_with_comparable[5],
    Of_sexp_error = Base_Sexp_with_comparable[6],
    message = Base_Sexp_with_comparable[7],
    default_indent = Base_Sexp_with_comparable[8],
    pp_hum = Base_Sexp_with_comparable[9],
    pp_hum_indent = Base_Sexp_with_comparable[10],
    pp_mach = Base_Sexp_with_comparable[11],
    pp = Base_Sexp_with_comparable[12],
    to_string_hum = Base_Sexp_with_comparable[13],
    to_string_mach = Base_Sexp_with_comparable[14],
    to_string = Base_Sexp_with_comparable[15],
    of_float_style = Base_Sexp_with_comparable[16],
    of_int_style = Base_Sexp_with_comparable[17],
    t_sexp_grammar = Base_Sexp_with_comparable[18],
    invariant = Base_Sexp_with_comparable[19],
    of_string = Base_Sexp_with_comparable[20],
    symbol$0 = Base_Sexp_with_comparable[21],
    symbol$1 = Base_Sexp_with_comparable[22],
    symbol$2 = Base_Sexp_with_comparable[23],
    symbol$3 = Base_Sexp_with_comparable[24],
    symbol$4 = Base_Sexp_with_comparable[25],
    symbol$5 = Base_Sexp_with_comparable[26],
    equal = Base_Sexp_with_comparable[27],
    compare = Base_Sexp_with_comparable[28],
    min = Base_Sexp_with_comparable[29],
    max = Base_Sexp_with_comparable[30],
    ascending = Base_Sexp_with_comparable[31],
    descending = Base_Sexp_with_comparable[32],
    between = Base_Sexp_with_comparable[33],
    clamp_exn = Base_Sexp_with_comparable[34],
    clamp = Base_Sexp_with_comparable[35],
    comparator = Base_Sexp_with_comparable[36],
    Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator],
    am_testing = Base_Import[131],
    Exported_for_specific_uses = [0, am_testing],
    compare_array = Base_Array[1],
    equal_array = Base_Array[100],
    array_of_sexp = Base_Array[2],
    sexp_of_array = Base_Array[3];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[4], a_sexp_grammar);
   }
   var
    compare_bool = Base_Bool[16],
    equal_bool = Base_Bool[15],
    hash_fold_bool = Base_Bool[3],
    func = Base_Bool[4];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[5],
    sexp_of_bool = Base_Bool[6],
    bool_sexp_grammar = Base_Bool[2],
    compare_char = Base_Char[16],
    equal_char = Base_Char[15],
    hash_fold_char = Base_Char[3],
    func$0 = Base_Char[4];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[5],
    sexp_of_char = Base_Char[6],
    char_sexp_grammar = Base_Char[2],
    sexp_of_exn = Base_Exn[1],
    compare_float = Base_Float[16],
    equal_float = Base_Float[15],
    hash_fold_float = Base_Float[4],
    func$1 = Base_Float[5];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[6],
    sexp_of_float = Base_Float[7],
    float_sexp_grammar = Base_Float[1],
    compare_int = Base_Int[13],
    equal_int = Base_Int[12],
    hash_fold_int = Base_Int[6],
    func$2 = Base_Int[7];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[8],
    sexp_of_int = Base_Int[9],
    int_sexp_grammar = Base_Int[1],
    compare_int32 = Base_Int32[19],
    equal_int32 = Base_Int32[18],
    hash_fold_int32 = Base_Int32[6],
    func$3 = Base_Int32[7];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[8],
    sexp_of_int32 = Base_Int32[9],
    int32_sexp_grammar = Base_Int32[1],
    compare_int64 = Base_Int64[13],
    equal_int64 = Base_Int64[12],
    hash_fold_int64 = Base_Int64[6],
    func$4 = Base_Int64[7];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[8],
    sexp_of_int64 = Base_Int64[9],
    int64_sexp_grammar = Base_Int64[1],
    compare_list = Base_List[1],
    equal_list = Base_List[147],
    hash_fold_list = Base_List[2],
    list_of_sexp = Base_List[3],
    sexp_of_list = Base_List[4];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[5], a_sexp_grammar);
   }
   var
    compare_nativeint = Base_Nativeint[19],
    equal_nativeint = Base_Nativeint[18],
    hash_fold_nativeint = Base_Nativeint[6],
    func$5 = Base_Nativeint[7];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[8],
    sexp_of_nativeint = Base_Nativeint[9],
    nativeint_sexp_grammar = Base_Nativeint[1],
    compare_option = Base_Option[1],
    equal_option = Base_Option[4],
    hash_fold_option = Base_Option[2],
    option_of_sexp = Base_Option[6],
    sexp_of_option = Base_Option[7];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[3], a_sexp_grammar);
   }
   var
    compare_ref = Base_Ref[1],
    equal_ref = Base_Ref[2],
    ref_of_sexp = Base_Ref[3],
    sexp_of_ref = Base_Ref[4];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[5], a_sexp_grammar);
   }
   var
    compare_string = Base_String[37],
    equal_string = Base_String[121],
    hash_fold_string = Base_String[26];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[27],
    sexp_of_string = Base_String[28],
    string_sexp_grammar = Base_String[1],
    compare_bytes = Base_Bytes[16],
    equal_bytes = Base_Bytes[15],
    bytes_of_sexp = Base_Bytes[1],
    sexp_of_bytes = Base_Bytes[2],
    bytes_sexp_grammar = Base_Bytes[3],
    compare_unit = Base_Unit[16],
    equal_unit = Base_Unit[15],
    hash_fold_unit = Base_Unit[3],
    func$6 = Base_Unit[4];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[5],
    sexp_of_unit = Base_Unit[6],
    unit_sexp_grammar = Base_Unit[2],
    symbol$6 = Base_List[148][1],
    _a_ = Base_Int[70],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[96],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[104],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol_concat = Base_String[53],
    fst = Base_Import[124],
    snd = Base_Import[126],
    failwith = Base_Import[123],
    invalid_arg = Base_Import[125],
    raise_s = Base_Error[30],
    phys_equal = Base_Import[127],
    Export =
      [0,
       compare_array,
       equal_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool,
       equal_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char,
       equal_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float,
       equal_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int,
       equal_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32,
       equal_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64,
       equal_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list,
       equal_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint,
       equal_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option,
       equal_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref,
       equal_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string,
       equal_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit,
       equal_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol_concat,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s,
       phys_equal],
    compare_array$0 = Export[1],
    equal_array$0 = Export[2],
    array_of_sexp$0 = Export[3],
    sexp_of_array$0 = Export[4],
    array_sexp_grammar$0 = Export[5],
    compare_bool$0 = Export[6],
    equal_bool$0 = Export[7],
    hash_fold_bool$0 = Export[8],
    hash_bool$0 = Export[9],
    bool_of_sexp$0 = Export[10],
    sexp_of_bool$0 = Export[11],
    bool_sexp_grammar$0 = Export[12],
    compare_char$0 = Export[13],
    equal_char$0 = Export[14],
    hash_fold_char$0 = Export[15],
    hash_char$0 = Export[16],
    char_of_sexp$0 = Export[17],
    sexp_of_char$0 = Export[18],
    char_sexp_grammar$0 = Export[19],
    sexp_of_exn$0 = Export[20],
    compare_float$0 = Export[21],
    equal_float$0 = Export[22],
    hash_fold_float$0 = Export[23],
    hash_float$0 = Export[24],
    float_of_sexp$0 = Export[25],
    sexp_of_float$0 = Export[26],
    float_sexp_grammar$0 = Export[27],
    compare_int$0 = Export[28],
    equal_int$0 = Export[29],
    hash_fold_int$0 = Export[30],
    hash_int$0 = Export[31],
    int_of_sexp$0 = Export[32],
    sexp_of_int$0 = Export[33],
    int_sexp_grammar$0 = Export[34],
    compare_int32$0 = Export[35],
    equal_int32$0 = Export[36],
    hash_fold_int32$0 = Export[37],
    hash_int32$0 = Export[38],
    int32_of_sexp$0 = Export[39],
    sexp_of_int32$0 = Export[40],
    int32_sexp_grammar$0 = Export[41],
    compare_int64$0 = Export[42],
    equal_int64$0 = Export[43],
    hash_fold_int64$0 = Export[44],
    hash_int64$0 = Export[45],
    int64_of_sexp$0 = Export[46],
    sexp_of_int64$0 = Export[47],
    int64_sexp_grammar$0 = Export[48],
    compare_list$0 = Export[49],
    equal_list$0 = Export[50],
    hash_fold_list$0 = Export[51],
    list_of_sexp$0 = Export[52],
    sexp_of_list$0 = Export[53],
    list_sexp_grammar$0 = Export[54],
    compare_nativeint$0 = Export[55],
    equal_nativeint$0 = Export[56],
    hash_fold_nativeint$0 = Export[57],
    hash_nativeint$0 = Export[58],
    nativeint_of_sexp$0 = Export[59],
    sexp_of_nativeint$0 = Export[60],
    nativeint_sexp_grammar$0 = Export[61],
    compare_option$0 = Export[62],
    equal_option$0 = Export[63],
    hash_fold_option$0 = Export[64],
    option_of_sexp$0 = Export[65],
    sexp_of_option$0 = Export[66],
    option_sexp_grammar$0 = Export[67],
    compare_ref$0 = Export[68],
    equal_ref$0 = Export[69],
    ref_of_sexp$0 = Export[70],
    sexp_of_ref$0 = Export[71],
    ref_sexp_grammar$0 = Export[72],
    compare_string$0 = Export[73],
    equal_string$0 = Export[74],
    hash_fold_string$0 = Export[75],
    hash_string$0 = Export[76],
    string_of_sexp$0 = Export[77],
    sexp_of_string$0 = Export[78],
    string_sexp_grammar$0 = Export[79],
    compare_bytes$0 = Export[80],
    equal_bytes$0 = Export[81],
    bytes_of_sexp$0 = Export[82],
    sexp_of_bytes$0 = Export[83],
    bytes_sexp_grammar$0 = Export[84],
    compare_unit$0 = Export[85],
    equal_unit$0 = Export[86],
    hash_fold_unit$0 = Export[87],
    hash_unit$0 = Export[88],
    unit_of_sexp$0 = Export[89],
    sexp_of_unit$0 = Export[90],
    unit_sexp_grammar$0 = Export[91],
    symbol$18 = Export[92],
    symbol$19 = Export[93],
    lnot$0 = Export[94],
    abs$0 = Export[95],
    zero$0 = Export[96],
    symbol$20 = Export[97],
    symbol$21 = Export[98],
    symbol$22 = Export[99],
    ascending$1 = Export[100],
    descending$1 = Export[101],
    max$1 = Export[102],
    min$1 = Export[103],
    symbol$23 = Export[104],
    symbol$24 = Export[105],
    symbol$25 = Export[106],
    symbol$26 = Export[107],
    symbol$27 = Export[108],
    symbol$28 = Export[109],
    symbol$29 = Export[110],
    symbol_concat$0 = Export[111],
    fst$0 = Export[112],
    snd$0 = Export[113],
    failwith$0 = Export[114],
    invalid_arg$0 = Export[115],
    raise_s$0 = Export[116],
    phys_equal$0 = Export[117],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[251];
   caml_call1(Base_Backtrace[7], 0);
   var
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Sexp,
       Exported_for_specific_uses,
       Export,
       compare_array$0,
       equal_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char$0,
       equal_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float$0,
       equal_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int$0,
       equal_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32$0,
       equal_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64$0,
       equal_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list$0,
       equal_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option$0,
       equal_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string$0,
       equal_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes$0,
       equal_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit$0,
       equal_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$18,
       symbol$19,
       lnot$0,
       abs$0,
       zero$0,
       symbol$20,
       symbol$21,
       symbol$22,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$23,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol_concat$0,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       phys_equal$0,
       Continue_or_stop,
       Not_found_s$0];
   runtime.caml_register_global(21, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZXNjZW5kaW5nIiwieCIsInkiLCJtYXgiLCJtaW4iLCJkb19hdF9leGl0IiwidW5zYWZlX3JlYWxseV9pbnB1dCIsInZhbGlkX2Zsb2F0X2xleGVtIiwiYXRfZXhpdCIsImV4aXQiLCJzeW1ib2wiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW5fbm9lcnIiLCJjbG9zZV9pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwicG9zX2luIiwic2Vla19pbiIsImlucHV0X3ZhbHVlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X2J5dGUiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwicmVhbGx5X2lucHV0IiwiaW5wdXQiLCJpbnB1dF9saW5lIiwiaW5wdXRfY2hhciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbl9iaW4iLCJvcGVuX2luIiwic2V0X2JpbmFyeV9tb2RlX291dCIsImNsb3NlX291dF9ub2VyciIsImNsb3NlX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInBvc19vdXQiLCJzZWVrX291dCIsIm91dHB1dF92YWx1ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0Iiwib3V0cHV0X2J5dGVzIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9jaGFyIiwiZmx1c2hfYWxsIiwiZmx1c2giLCJvcGVuX291dF9nZW4iLCJvcGVuX291dF9iaW4iLCJvcGVuX291dCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9saW5lIiwicHJlcnJfbmV3bGluZSIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9mbG9hdCIsInByZXJyX2ludCIsInByZXJyX2J5dGVzIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfY2hhciIsInByaW50X25ld2xpbmUiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfZmxvYXQiLCJwcmludF9pbnQiLCJwcmludF9ieXRlcyIsInByaW50X3N0cmluZyIsInByaW50X2NoYXIiLCJzdGRlcnIiLCJzdGRvdXQiLCJzdGRpbiIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9ib29sIiwiY2hhcl9vZl9pbnQiLCJlcHNpbG9uX2Zsb2F0IiwibWluX2Zsb2F0IiwibWF4X2Zsb2F0IiwibmFuIiwibmVnX2luZmluaXR5IiwiaW5maW5pdHkiLCJtaW5faW50IiwibWF4X2ludCIsImJvb2xfdG9faW50Iiwic3ltYm9sJDIiLCJzeW1ib2wkMyIsInN5bWJvbCQ0Iiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJzeW1ib2wkOSIsInN5bWJvbCQxMCIsInN5bWJvbCQxMSIsImFzY2VuZGluZyIsIm1heCQwIiwibWluJDAiLCJhc2NlbmRpbmckMCIsImRlc2NlbmRpbmckMCIsIm1heCQxIiwibWluJDEiLCJzeW1ib2wkMTIiLCJzeW1ib2wkMTMiLCJzeW1ib2wkMTQiLCJzeW1ib2wkMTUiLCJzeW1ib2wkMTYiLCJzeW1ib2wkMTciLCJhc2NlbmRpbmckMSIsImRlc2NlbmRpbmckMSIsImNvbXBhcmUiLCJlcXVhbCIsIm1heCQyIiwibWluJDIiLCJhc2NlbmRpbmckMiIsImRlc2NlbmRpbmckMiIsIm1heCQzIiwibWluJDMiLCJzeW1ib2wkMTgiLCJzeW1ib2wkMTkiLCJzeW1ib2wkMjAiLCJzeW1ib2wkMjEiLCJzeW1ib2wkMjIiLCJzeW1ib2wkMjMiLCJhc2NlbmRpbmckMyIsImRlc2NlbmRpbmckMyIsImNvbXBhcmUkMCIsImVxdWFsJDAiLCJtYXgkNCIsIm1pbiQ0Iiwic3ltYm9sJDI0Iiwic3ltYm9sJDI1Iiwic3ltYm9sJDI2Iiwic3ltYm9sJDI3Iiwic3ltYm9sJDI4Iiwic3ltYm9sJDI5IiwiYXNjZW5kaW5nJDQiLCJkZXNjZW5kaW5nJDQiLCJjb21wYXJlJDEiLCJlcXVhbCQxIiwibWF4JDUiLCJtaW4kNSIsInN5bWJvbCQzMCIsInN5bWJvbCQzMSIsInN5bWJvbCQzMiIsInN5bWJvbCQzMyIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsImFzY2VuZGluZyQ1IiwiZGVzY2VuZGluZyQ1IiwiY29tcGFyZSQyIiwiZXF1YWwkMiIsIm1heCQ2IiwibWluJDYiLCJpIiwic3ltYm9sJDM2Iiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwiYXNjZW5kaW5nJDYiLCJkZXNjZW5kaW5nJDYiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwibWF4JDciLCJtaW4kNyIsInN5bWJvbCQ0MiIsInN5bWJvbCQ0MyIsInN5bWJvbCQ0NCIsInN5bWJvbCQ0NSIsInN5bWJvbCQ0NiIsInN5bWJvbCQ0NyIsImFzY2VuZGluZyQ3IiwiZGVzY2VuZGluZyQ3IiwiY29tcGFyZSQ0IiwiZXF1YWwkNCIsIm1heCQ4IiwibWluJDgiLCJzeW1ib2wkNDgiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJzeW1ib2wkNTEiLCJzeW1ib2wkNTIiLCJzeW1ib2wkNTMiLCJhc2NlbmRpbmckOCIsImRlc2NlbmRpbmckOCIsImNvbXBhcmUkNSIsImVxdWFsJDUiLCJtYXgkOSIsIm1pbiQ5Iiwic3ltYm9sJDU0Iiwic3ltYm9sJDU1Iiwic3ltYm9sJDU2Iiwic3ltYm9sJDU3Iiwic3ltYm9sJDU4Iiwic3ltYm9sJDU5IiwiYXNjZW5kaW5nJDkiLCJkZXNjZW5kaW5nJDkiLCJjb21wYXJlJDYiLCJlcXVhbCQ2IiwibWF4JDEwIiwibWluJDEwIiwic3ltYm9sJDYwIiwic3ltYm9sX2NvbmNhdCQwIiwic3ltYm9sJDYxIiwic3ltYm9sJDYyIiwiYXNyIiwibGFuZCIsImxub3QkMCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMkMCIsImZhaWx3aXRoJDAiLCJmc3QiLCJpbnZhbGlkX2FyZyQwIiwic25kIiwicGh5c19lcXVhbCIsImRlY3IiLCJpbmNyIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsImZhaWx3aXRoZiIsImZtdCIsInMiLCJpbnZhbGlkX2FyZ2YiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImludF9zaXplX2luX2JpdHMiLCJiaWdfZW5kaWFuIiwibWF4X3N0cmluZ19sZW5ndGgiLCJtYXhfYXJyYXlfbGVuZ3RoIiwicnVudGltZV92YXJpYW50IiwicnVudGltZV9wYXJhbWV0ZXJzIiwiYXJndiIsImdldF9hcmd2Iiwib2NhbWxfdmVyc2lvbiIsImVuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwicnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiZ2V0ZW52X2V4biIsInZhciQwIiwiZ2V0ZW52IiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImxlbiIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwidCIsImYiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidDEiLCJ0MiIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzdWNjIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0IiwibCIsInJldiIsInJlcyIsInJlc3QiLCJhIiwiYiIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ZvbGRfY2hhciIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9vcHRpb24iLCJoYXNoX2ZvbGRfZWxlbSIsImhhc2hfZm9sZF9saXN0IiwicyQxIiwibGlzdCQxIiwicyQyIiwibGlzdCIsImxpc3QkMCIsInMkMCIsImhhc2hfZm9sZF9sYXp5X3QiLCJoYXNoX2ZvbGRfcmVmX2Zyb3plbiIsImhhc2hfZm9sZF9hcnJheV9mcm96ZW4iLCJhcnJheSIsImUiLCJpJDAiLCJoYXNoX25hdGl2ZWludCIsImhhc2hfaW50NjQiLCJoYXNoX2ludDMyIiwiaGFzaF9jaGFyIiwiaGFzaF9pbnQiLCJoYXNoX2Jvb2wiLCJoYXNoX3N0cmluZyIsImhhc2hfZmxvYXQiLCJoYXNoX3VuaXQiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwicnVuIiwiZm9sZGVyIiwib3B0Iiwic3RoIiwiY29tcGFyZV9zdGF0ZSIsInN0YXRlX3RvX3N0cmluZyIsInN0YXRlIiwidCQwIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwibGVuX2EiLCJsZW5fYiIsInJldCIsInIiLCJjb21wYXJlX2xpc3QiLCJhJDAiLCJiJDAiLCJ5cyIsInhzIiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX3JlZiIsImVxdWFsX2Jvb2wiLCJlcXVhbF9jaGFyIiwiZXF1YWxfaW50IiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQ2NCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3VuaXQiLCJlcXVhbF9mbG9hdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfZWx0IiwiZXF1YWxfbGlzdCIsImVxdWFsX29wdGlvbiIsImVxdWFsX3JlZiIsImFfMDAxIiwiYl8wMDIiLCJhXzAwMyIsImJfMDA0IiwiYV8wMDUiLCJiXzAwNiIsImhhc2giLCJoc3YiLCJhcmciLCJhMCIsImhzdiQwIiwiYTAkMCIsImhzdiQxIiwidF9zZXhwX2dyYW1tYXIiLCJpbnZhcmlhbnQiLCJzZXhwX29mX3QiLCJudW1fYml0cyIsIndvcmRfc2l6ZSIsImFsbCIsInJlZ2lzdGVyIiwicCIsInBwIiwibW9kdWxlX25hbWUiLCJmb3JtYXR0ZXIiLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsImFyZzFfMDA2IiwiYXJnMF8wMDUiLCJyZXMwXzAwNyIsInJlczFfMDA4IiwiY3JlYXRlX3MiLCJzZXhwIiwicmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJyZXJhaXNlIiwiZXhuIiwic3RyIiwiZXhuJDAiLCJidCIsInJlcmFpc2VmIiwiZXhjIiwiZm9ybWF0IiwidG9fc3RyaW5nX21hY2giLCJzZXhwX29mX3QkMCIsInByb3RlY3R4IiwiZmluYWxseSQwIiwiZmluYWxfZXhuJDAiLCJmaW5hbF9leG4iLCJwcm90ZWN0IiwiZG9lc19yYWlzZSIsInBwZiIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJleGMkMCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsImV4aXQkMCIsInJlcmFpc2VfdW5jYXVnaHQiLCJmdW5jIiwicmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UiLCJpbml0aWFsaXplX21vZHVsZSIsImNsZWFyX2JhY2t0cmFjZSIsIndpdGhfcmV0dXJuIiwiaXNfYWxpdmUiLCJyZXR1cm4kMCIsIndpdGhfcmV0dXJuX29wdGlvbiIsInByZXBlbmQiLCJwYXJhbSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJhbGxfdW5pdCIsIm1hcF92aWFfYmluZCIsIm1hIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsInN5bWJvbF9iaW5kJDEiLCJzeW1ib2xfbWFwJDEiLCJib3RoIiwibG9vcCIsInZzIiwidHMiLCJ2IiwiYmluZCQwIiwicmV0dXJuJDEiLCJtYXAkMCIsInRvX21vbmFkIiwib2ZfbW9uYWQiLCJkZXJpdmVkX21hcCIsIm1hcDIiLCJ0YSIsInRiIiwibWFwMyIsInRjIiwic3ltYm9sJDAiLCJ1Iiwic3ltYm9sJDEiLCJ0ZiIsImZhYiIsImMiLCJhcHBseSIsIm1mIiwibXgiLCJ0eCIsImN1c3RvbV9tYXAiLCJhcHBseSQwIiwiYmxpdF9zdHJpbmciLCJtYWtlIiwidW5zYWZlX2JsaXQiLCJ1bnNhZmVfdG9fc3RyaW5nIiwidW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211IiwiY29tcGFyYXRvciIsImVycm9yX3NvdXJjZV8wMTEiLCJjbXBfZiIsImNtcF9zIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCIsIm9mX2ZfMDA3Iiwib2Zfc18wMDgiLCJzZXhwXzAxMyIsInRhZ18wMTQiLCJzZXhwX2FyZ3NfMDIwIiwiYXJnMF8wMjEiLCJyZXMwXzAyMiIsInNleHBfYXJnc18wMTUiLCJhcmcwXzAxNiIsInJlczBfMDE3Iiwib2ZfZl8wMjUiLCJvZl9zXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJhcmcwXzAyOSIsInJlczBfMDMwIiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwidXBkYXRlciIsImZpZWxkIiwic3ltYm9sX2NvbmNhdCIsImNhcGl0YWxpemUiLCJ1bmNhcGl0YWxpemUiLCJzZXAiLCJuIiwibiQwIiwibiQxIiwiaHN2JDIiLCJwb3NfY251bV8wMTAiLCJwb3NfYm9sXzAwOCIsInBvc19sbnVtXzAwNiIsInBvc19mbmFtZV8wMDQiLCJhcmdfMDExIiwiYm5kc18wMDMiLCJhcmdfMDA5IiwiYm5kc18wMDMkMCIsImFyZ18wMDciLCJibmRzXzAwMyQxIiwiYXJnXzAwNSIsImJuZHNfMDAzJDIiLCJoYXNoX2ZvbGRfdCQwIiwiaGFzaCQwIiwibWFrZV9sb2NhdGlvbl9zdHJpbmciLCJwb3NfZm5hbWUiLCJwb3NfbG51bSIsInBvc19jbnVtIiwicG9zX2JvbCIsImlzX2VtcHR5IiwicGFydGl0aW9uX21hcCIsImZzdCQwIiwieSQwIiwic25kJDAiLCJlcnJvcl9zb3VyY2VfMDA1Iiwib2ZfYV8wMDEiLCJvZl9iXzAwMiIsInNleHBfMDA3IiwidGFnXzAwOCIsInNleHBfYXJnc18wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwic2V4cF9hcmdzXzAxNCIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJvZl9hXzAxOSIsIm9mX2JfMDIwIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJjbXBfYSIsImNtcF9iIiwiYV8wMjciLCJiXzAyOCIsImFfMDI5IiwiYl8wMzAiLCJhXzAzMSIsImJfMDMyIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsIngkMCIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQxIiwibWFwJDEiLCJyZXR1cm4kMiIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMSIsIm9rMiIsImVycjEiLCJlcnIyIiwiY29tYmluZV9lcnJvcnMiLCJlcnJzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImNvdW50Iiwic3VtIiwiTSIsImZvbGRfcmVzdWx0IiwiYWNjIiwiaXRlbSIsImZvbGRfdW50aWwiLCJmaW5pc2giLCJtaW5fZWx0IiwiZWx0IiwibWF4X2VsdCIsImZpbmRfbWFwIiwiZmluZCIsInRvX2FycmF5IiwiaXRlciQwIiwiaXRlciQxIiwibGVuZ3RoJDAiLCJsZW5ndGgkMSIsImlzX2VtcHR5JDAiLCJzdW0kMCIsIm0iLCJjb3VudCQwIiwiZXhpc3RzJDAiLCJmb3JfYWxsJDAiLCJmaW5kX21hcCQwIiwiZmluZCQwIiwidG9fbGlzdCQwIiwidG9fYXJyYXkkMCIsIm1pbl9lbHQkMCIsIm1heF9lbHQkMCIsImZvbGRfcmVzdWx0JDAiLCJmb2xkX3VudGlsJDAiLCJmb2xkJDAiLCJtZW0iLCJjb21wYXJlX2EiLCJlcXVhbF9hIiwic2V4cF9vZl9hIiwic2xvd19jaGVja19wb3NfbGVuX2V4biIsInBvcyIsInRvdGFsX2xlbmd0aCIsImNoZWNrX3Bvc19sZW5fZXhuIiwic3RvcCIsImdldF9wb3NfbGVuX2V4biIsImxlbiQwIiwib2Zfc3RhdGUiLCJhc3NpZ24iLCJ0MSQwIiwidDIkMCIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQkMCIsImdldF9zdGF0ZSIsImZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyIsImFsbG93X2luX3Rlc3RzIiwiYml0cyIsImludCQwIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJzY2FsZSIsInIxIiwicjIiLCJyZXN1bHQiLCJmbG9hdF9yYW5nZSIsImRlZmF1bHQkMSIsImJpdHMkMSIsImludCQyIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJpbnRfaW5jbCQwIiwiaW50MzJfaW5jbCQwIiwibmF0aXZlaW50X2luY2wkMCIsImludDY0X2luY2wkMCIsImZsb2F0X3JhbmdlJDAiLCJib29sJDAiLCJjaGFyJDEiLCJhc2NpaSQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic2V0X3N0YXRlIiwicGVybXV0ZSIsInJhbmRvbV9zdGF0ZSIsInN0aCQwIiwibnVtX3N3YXBzIiwidGhpc19pIiwicmFuZG9tX2kiLCJjb25zdCQwIiwibm9uIiwiZm9yZXZlciIsImUkMCIsImNvbXBvc2UiLCJnIiwiZmxpcCIsImFwcGx5X25fdGltZXMiLCJ4JDEiLCJzZXhwXzAwNiIsImVycm9yX3NvdXJjZV8wMjIiLCJmb2xkX2xlZnQiLCJhXzAwNiIsImJfMDA3IiwiYV8wMDgiLCJiXzAwOSIsIm9mX2FfMDEwIiwiYXJnMF8wMTEiLCJyZXMwXzAxMiIsInJhbmdlIiwic3RyaWRlIiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0IiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImFjY3VtIiwiaV90b19zdG9wX29yZGVyIiwibmV4dF9pJDAiLCJhY2N1bSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImwzIiwiYyQwIiwiY2hlY2tfbGVuZ3RoM19leG4iLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9yX2FsbDIiLCJmb3JfYWxsMl9leG4iLCJleGlzdHMyIiwiZXhpc3RzMl9leG4iLCJicyIsInJldl9maWx0ZXIiLCJhY2N1IiwiZmlsdGVyIiwibm90X2ZvdW5kIiwiZmluZF9tYXBfZXhuIiwibm90X2ZvdW5kJDAiLCJmaW5kX2V4biIsImZpbmRpIiwibm90X2ZvdW5kJDEiLCJmaW5kaV9leG4iLCJmaW5kX21hcGkiLCJub3RfZm91bmQkMiIsImZpbmRfbWFwaV9leG4iLCJmb3JfYWxsaSIsImV4aXN0c2kiLCJtYXhfbm9uX3RhaWxjYWxsIiwiY291bnRfYXBwZW5kIiwieDEiLCJ4MiIsIngzIiwieDQiLCJ4NSIsImNvdW50X21hcCIsImN0ciIsIngxJDAiLCJmMSQzIiwieDIkMCIsImYxJDIiLCJmMiQyIiwieDMkMCIsImYxJDEiLCJmMiQxIiwiZjMkMSIsIng0JDAiLCJmMSQwIiwiZjIkMCIsImYzJDAiLCJmNCQwIiwieDUkMCIsImYxIiwiZjIiLCJmMyIsImY0IiwiZjUiLCJicyQwIiwieHMkMCIsIng4IiwieDciLCJ4NiIsIngwIiwieTAkMCIsInkxJDAiLCJ5MiQwIiwieTMkMCIsInk0JDAiLCJ5NSQwIiwieTYkMCIsInk3JDAiLCJ5OCQwIiwieTgiLCJ5NyIsInk2IiwieTUiLCJ5NCIsInkzIiwieTIiLCJ5MSIsInkwIiwiZm9sZGluZ19tYXAiLCJuZXdfYWNjIiwiZm9sZF9tYXAiLCJtYXAyX29rIiwibWFwMl9leG4iLCJyZXZfbWFwM19vayIsImwxJDAiLCJsMiQwIiwibDMkMCIsImFjIiwibDMkMSIsImwyJDEiLCJsMSQxIiwiYWMkMCIsInJldl9tYXAzIiwicmV2X21hcDNfZXhuIiwibWFwM19vayIsIm1hcDNfZXhuIiwicmV2X21hcF9hcHBlbmQiLCJoIiwibGlzdCQyIiwidW56aXAzIiwieiIsInppcF9leG4iLCJ6aXAiLCJyZXZfbWFwaSIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsImZvbGRpIiwiZmlsdGVyaSIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZWR1Y2VfYmFsYW5jZWQiLCJzdGVwX2FjY3VtIiwibnVtIiwibnVtJDAiLCJhY2MkMCIsImFjYyQxIiwibnVtJDEiLCJyZWR1Y2VfYmFsYW5jZWRfZXhuIiwiZ3JvdXBpIiwiYnJlYWskMCIsImdyb3VwcyIsImN1cnJlbnRfZ3JvdXAiLCJncm91cCIsInNvcnRfYW5kX2dyb3VwIiwiY29uY2F0X21hcCIsImNvbmNhdF9tYXBpIiwiY29udCIsIm1lcmdlIiwiaDIiLCJoMSIsIm1hcDIkMCIsIm1hcDMkMCIsImxhc3RfZXhuIiwibGFzdCIsImlzX3ByZWZpeCIsInByZWZpeCIsInByZWZpeCQwIiwicHJlZml4JDEiLCJoZCQwIiwiZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUiLCJhMSIsImExJDAiLCJhMiIsInJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIiwid2hpY2hfdG9fa2VlcCIsInRsJDAiLCJ0b19rZWVwJDIiLCJ0b19rZWVwIiwidG9fa2VlcCQwIiwidG9fa2VlcCQxIiwiZGVkdXBfYW5kX3NvcnQiLCJzb3J0ZWQiLCJmaW5kX2FfZHVwIiwibCQwIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInNvcnRlZCQyIiwicHJldiQxIiwic29ydGVkJDAiLCJwcmV2IiwiYWxyZWFkeV9yZWNvcmRlZCIsInNvcnRlZCQxIiwicHJldiQwIiwiYWxsX2VxdWFsIiwiY291bnRpIiwiaWR4IiwicmV2X2ZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwIiwicmV2X2ZpbHRlcl9tYXBpIiwiaSQxIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfb3B0IiwicGFydGl0aW9uM19tYXAiLCJ0cmQiLCJ0cmQkMCIsInkkMSIsInBhcnRpdGlvbl90ZiIsImYkMCIsInBhcnRpdGlvbl9yZXN1bHQiLCJ0X29mX3NleHAkMCIsIm9mX2FfMDE0Iiwib2ZfYl8wMTUiLCJ4XzAyMyIsInNleHBfMDIxIiwiYXJnMV8wMTgiLCJhcmcwXzAxNyIsInJlczBfMDE5IiwicmVzMV8wMjAiLCJzZXhwX29mX3QkMSIsIm9mX2FfMDI0Iiwib2ZfYl8wMjUiLCJ4XzAzMCIsImFyZzFfMDI3IiwiYXJnMF8wMjYiLCJyZXMxXzAyOSIsInRfc2V4cF9ncmFtbWFyJDAiLCJwYWlyX29mX2dyb3VwIiwiayIsImdyb3VwJDAiLCJhbGlzdCIsInNvcnRfYW5kX2dyb3VwJDAiLCJrZXkiLCJrZXkkMCIsIm5vdF9mb3VuZCQzIiwiZmluZF9leG4kMCIsInZhbHVlIiwibWVtJDAiLCJyZW1vdmUiLCJhZGQiLCJpbnZlcnNlIiwibWFwJDIiLCJlbCIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsImwkMSIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImNtcCIsInQyJDEiLCJ0MSQxIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uX2FjYyQwIiwiY29sdW1uIiwiZG9fcmV2JDAiLCJjb2x1bW5zJDAiLCJhcmcwXzAzMSIsInJlczBfMDMyIiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMV8wMTMiLCJyZXMyXzAxNCIsImFyZzFfMDE2IiwicmVzMV8wMTgiLCJhcmcyXzAyMSIsImFyZzFfMDIwIiwiYXJnMF8wMTkiLCJyZXMxXzAyMyIsInJlczJfMDI0IiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJhcmcxXzAzMCIsInJlczBfMDMxIiwicmVzMV8wMzIiLCJ0b19zdHJpbmdzX2h1bSIsInN0cmluZyIsInNleHAkMCIsInNleHAkMSIsInRhZyIsInRhZyQwIiwic2V4cCQyIiwidGFnJDEiLCJib2R5IiwidHJ1bmNfYWZ0ZXIiLCJ0cyQwIiwidHMkMSIsImFjJDEiLCJ0b19zZXhwc19odW0iLCJoZXJlIiwiaGVyZSQwIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsInRvX21lc3NhZ2UiLCJpbmZvIiwib2ZfbWVzc2FnZSIsInRvX3N0cmluZ19odW0iLCJtZXNzYWdlIiwidG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImxhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMDciLCJiXzAwOCIsIm9mX2FfMDEzIiwieF8wMTUiLCJvZl9hXzAxNiIsInhfMDE3IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX29rIiwiZmluZF9tYXBfb2siLCJlcnJvcl9zb3VyY2VfMDAzIiwic2V4cF8wMDQiLCJnZXEiLCJsZXEiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsImNsYW1wX2V4biIsImNsYW1wIiwibGV4aWNvZ3JhcGhpYyIsImNtcHMiLCJjbXBzJDAiLCJsaWZ0IiwicmV2ZXJzZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInByZWQiLCJwb3MkMCIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsImNhbGwiLCJ2YWx1ZV9leG4iLCJlcnJvciQwIiwibSQwIiwibSQxIiwidmFsdWVfb3JfdGh1bmsiLCJzb21lIiwiZmlyc3Rfc29tZSIsInNvbWVfaWYiLCJjb25kIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJmaXJzdCIsInNlY29uZCIsImVxMSIsImVxMiIsIm90aGVyIiwiZWl0aGVyIiwib3RoZXJfbG9vcCIsInJldHVybl9sb29wIiwiY29tYmluZV9hbGwiLCJvdGhlcl9sb29wJDAiLCJyZXR1cm5fbG9vcCQwIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImVpdGhlciQwIiwiY29tYmluZSQwIiwiaXRlcmkkMCIsIml0ZXJpJDEiLCJmb2xkaSQwIiwiZm9sZGkkMSIsImNvdW50aSQwIiwiZXhpc3RzaSQwIiwiZm9yX2FsbGkkMCIsImZpbmRfbWFwaSQwIiwiZmluZGkkMCIsImVycm9yX3NvdXJjZV8wMjUiLCJvZl9zXzAwMiIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwibmV4dCIsInVuZm9sZF9zdGVwIiwidW5mb2xkIiwidW5mb2xkX3dpdGgiLCJzZWVkJDAiLCJzZWVkJDEiLCJ1bmZvbGRfd2l0aF9hbmRfZmluaXNoIiwicnVubmluZ19zdGVwIiwiaW5uZXJfZmluaXNoZWQiLCJmaW5pc2hpbmdfc3RlcCIsInN0YXRlJDAiLCJzdGF0ZSQxIiwic3RhdGUkMiIsImlubmVyX3N0YXRlIiwic3RhdGUkMyIsImlubmVyX3N0YXRlJDAiLCJpbm5lcl9zdGF0ZSQxIiwic3RhdGUkNCIsInN0YXRlJDUiLCJzZWVkJDIiLCJ2JDAiLCJ0b19saXN0X3JldiIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdGVwIiwidF9sYXp5IiwibCQyIiwic29tZV9iIiwiZW1wdHkiLCJuZXh0JDAiLCJzJDMiLCJhXzAxMSIsImJfMDEyIiwiYV8wMTMiLCJiXzAxNCIsImFfMDE1IiwiYl8wMTYiLCJhXzAxOSIsImFfMDE3IiwiYl8wMjAiLCJiXzAxOCIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInRhZ18wMjgiLCJzZXhwX2FyZ3NfMDM0IiwiYXJnMF8wMzUiLCJyZXMwXzAzNiIsInNleHBfYXJnc18wMjkiLCJhcmcwXzAzMCIsInNleHBfYXJnc18wMzkiLCJhcmcxXzA0MSIsImFyZzBfMDQwIiwicmVzMF8wNDIiLCJyZXMxXzA0MyIsIm9mX2FfMDQ2Iiwib2ZfYl8wNDciLCJhcmcwXzA0OCIsInJlczBfMDQ5IiwiYXJnMF8wNTAiLCJyZXMwXzA1MSIsImFyZzFfMDUzIiwiYXJnMF8wNTIiLCJyZXMwXzA1NCIsInJlczFfMDU1IiwibWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIiwibmV4dDIiLCJzMiIsIm5leHQxIiwiczEiLCJzMiQwIiwiczIkMSIsInMxJDAiLCJzMiQyIiwiczEkMSIsInMyJDMiLCJjb21wYXJpc29uIiwibWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIiwibWVyZ2Vfc29ydGVkIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiY2h1bmtzX2V4biIsInppcF9mdWxsIiwiYm91bmRlZF9sZW5ndGgiLCJhdF9tb3N0IiwibGVuZ3RoX2lzX2JvdW5kZWRfYnkiLCJjdXIiLCJjdXIkMCIsImxhc3RfZWx0IiwibGFzdF9lbHQkMCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfd2l0aF9saXN0IiwicyQ1IiwiYSQxIiwicyQ0IiwicmVwZWF0IiwiY3ljbGVfbGlzdF9leG4iLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9yY2VfZWFnZXJseSIsIm1lbW9pemUiLCJkcm9wX2VhZ2VybHkiLCJkcm9wX3doaWxlX29wdGlvbiIsInYyIiwidjEiLCJyb3VuZF9yb2JpbiIsImRvbmVfc3RhY2siLCJ0b2RvX3N0YWNrIiwidG9kb19zdGFjayQwIiwiaW50ZXJsZWF2ZSIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsInNldCIsInN3YXAkMCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJwdiIsInIkMCIsInIkMSIsInAkMCIsImxlZnQkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJ0b19zZXF1ZW5jZV9tdXRhYmxlIiwidG9fc2VxdWVuY2UiLCJpMSIsImkyIiwidHQiLCJ3aWR0aCIsImRlcHRoIiwiZCIsInciLCJ0dCQwIiwiZ2V0JDAiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJ1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV8iLCJ1bnNhZmVfc2V0X2ludCIsInVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIiwiaSQyIiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwiY3JlYXRlX29ial9hcnJheSIsIm9mX2FycmF5IiwiZ3JhbW1hciIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJtYXhfZmluaXRlX3ZhbHVlIiwiY2xhc3NpZnlfZmxvYXQiLCJhYnNfZmxvYXQiLCJpc19pbnRlZ2VyIiwiZnJleHAiLCJsZGV4cCIsImlzX25hbiIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIiwib2ZfaW50NjRfcHJlc2VydmVfb3JkZXIiLCJvbmVfdWxwIiwiZGlyIiwidXBwZXJfYm91bmRfZm9yX2ludCIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbV9leG4iLCJyaW5kZXhfZnJvbV9leG5faW50ZXJuYWwiLCJyaW5kZXhfZXhuX2ludGVybmFsIiwicmluZGV4X2V4biIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiaW5kZXhfaW50ZXJuYWwiLCJ0ZXh0IiwibWF0Y2hlcyIsImluJDAiLCJpbmRleF9leG4kMCIsImluZGV4X2FsbCIsIm1heV9vdmVybGFwIiwicmVwbGFjZV9maXJzdCIsIndpdGgkMCIsImxlbl9zIiwibGVuX3QiLCJsZW5fd2l0aCIsInJlcGxhY2VfYWxsIiwibnVtX21hdGNoZXMiLCJuZXh0X2RzdF9wb3MiLCJuZXh0X3NyY19wb3MiLCJzcGxpdF9vbiIsInBhdHRlcm5fbGVuIiwiYV8wMDIiLCJiXzAwMyIsImttcF9hcnJheV8wMTEiLCJjYXNlX3NlbnNpdGl2ZV8wMDkiLCJwYXR0ZXJuXzAwNyIsImFyZ18wMTIiLCJibmRzXzAwNiIsImFyZ18wMTAiLCJibmRzXzAwNiQwIiwiYXJnXzAwOCIsImJuZHNfMDA2JDEiLCJyZXByZXNlbnRhdGlvbiIsInN1YnN0cl9pbmRleF9nZW4iLCJzdWJzdHJfaW5kZXhfZXhuX2dlbiIsInN1YnN0cl9pbmRleF9hbGxfZ2VuIiwic3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIiwic3Vic3RyX3JlcGxhY2VfYWxsX2dlbiIsImlzX3N1YnN0cmluZ19nZW4iLCJzdWJzdHJpbmciLCJzdWJzdHJfaW5kZXgiLCJzdWJzdHJfaW5kZXhfZXhuIiwic3Vic3RyX2luZGV4X2FsbCIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0Iiwic3Vic3RyX3JlcGxhY2VfYWxsIiwiaXNfc3Vic3RyaW5nIiwiaXNfc3Vic3RyaW5nX2F0X2dlbiIsInN0cl9wb3MkMSIsInN0cl9sZW4iLCJzdWJfbGVuIiwic3RyX3BvcyIsInN1Yl9wb3MiLCJzdWJfcG9zJDAiLCJzdHJfcG9zJDAiLCJpc19zdWZmaXhfZ2VuIiwic3RyaW5nX2xlbiIsImlzX3ByZWZpeF9nZW4iLCJwcmVmaXhfbGVuIiwic2V4cF9vZl90JDIiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwic3Vic3RyX2luZGV4JDAiLCJzdWJzdHJfaW5kZXhfZXhuJDAiLCJzdWJzdHJfaW5kZXhfYWxsJDAiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCQwIiwic3Vic3RyX3JlcGxhY2VfYWxsJDAiLCJpc19zdWJzdHJpbmckMCIsImlzX3N1YnN0cmluZ19hdCIsImxzcGxpdDJfZXhuIiwibGluZSIsImRlbGltIiwibm90X2ZvdW5kJDQiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsImxhc3RfcG9zJDEiLCJsYXN0X3BvcyQwIiwicG9zMSIsInN1Yl9zdHIiLCJzcGxpdCIsInNwbGl0X29uX2NoYXJzIiwiY2hhcnMiLCJiYWNrX3VwX2F0X25ld2xpbmUiLCJlb2wiLCJzcGxpdF9saW5lcyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJvbl9lcnJvciIsImRyb3BfcHJlZml4IiwiZHJvcF9zdWZmaXgiLCJsZmluZGkiLCJyZmluZGkiLCJsYXN0X25vbl9kcm9wIiwicnN0cmlwIiwiZmlyc3Rfbm9uX2Ryb3AiLCJsc3RyaXAiLCJzdHJpcCIsInRyIiwidHJfbXVsdGkiLCJjb25jYXRfYXJyYXkiLCJhciIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwib2ZfY2hhciIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiayQwIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImxhc3RfaWR4JDAiLCJsYXN0X2RzdF9wb3MkMCIsInRvX2VzY2FwZSQwIiwiZXNjYXBlZF9jaGFyIiwibGFzdF9pZHgkMSIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJ0b191bmVzY2FwZSIsInN0YXR1cyQwIiwidG9fdW5lc2NhcGUkMCIsInVuZXNjYXBlX2dlbl9leG4iLCJ1bmVzY2FwZSIsInByZWNlZGluZ19lc2NhcGVfY2hhcnMiLCJjbnQiLCJjbnQkMCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJpbmRleF9mcm9tJDAiLCJzdGF0dXMkMSIsImluZGV4X2Zyb21fZXhuJDAiLCJpbmRleCQxIiwiaW5kZXhfZXhuJDEiLCJyaW5kZXhfZnJvbSQwIiwiZXNjYXBlX2NoYXJzIiwicmluZGV4X2Zyb21fZXhuJDAiLCJyaW5kZXgkMCIsInJpbmRleF9leG4kMCIsInNwbGl0X2dlbiQwIiwic3BsaXQkMCIsInNwbGl0X29uX2NoYXJzJDAiLCJzcGxpdF9hdCIsImxzcGxpdDIkMCIsInJzcGxpdDIkMCIsImxzcGxpdDJfZXhuJDAiLCJyc3BsaXQyX2V4biQwIiwibGFzdF9ub25fZHJvcF9saXRlcmFsIiwiZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsInJzdHJpcF9saXRlcmFsIiwibHN0cmlwX2xpdGVyYWwiLCJzdHJpcF9saXRlcmFsIiwiYmV0d2VlbiQwIiwiY2xhbXBfZXhuJDAiLCJjbGFtcCQwIiwiY3JlYXRlJDAiLCJjcmVhdGUkMSIsInVuc2FmZV9ibGl0JDEiLCJtYXBpJDAiLCJvY2FtbF9sZXhfdGFibGVzIiwicGFyc2VfaGV4IiwibGV4YnVmIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJjb252ZXJ0X2ZhaWx1cmUiLCJudW1fYml0c19pbnQiLCJudW1fYml0c19uYXRpdmVpbnQiLCJudW1fYml0c19pbnQzMiIsIm51bV9iaXRzX2ludDY0IiwibWluX2ludDMyIiwibWF4X2ludDMyIiwibWluX2ludDY0IiwibWF4X2ludDY0IiwibWluX25hdGl2ZWludCIsIm1heF9uYXRpdmVpbnQiLCJpbnQ2NF90b19zdHJpbmciLCJuYXRpdmVpbnRfdG9fc3RyaW5nIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50X3RvX2ludDMyX3RydW5jIiwiaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSIsImRlbGltaXRlciIsImNoYXJzX3Blcl9kZWxpbWl0ZXIiLCJpbnB1dF9sZW5ndGgiLCJoYXNfc2lnbiIsIm51bV9kaWdpdHMiLCJudW1fZGVsaW1pdGVycyIsIm91dHB1dF9sZW5ndGgiLCJpbnB1dF9wb3MiLCJvdXRwdXRfcG9zIiwibnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciIsImZpcnN0X2RpZ2l0X3BvcyIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJzZXhwX29mX2ludF9zdHlsZSIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW4iLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUiLCJpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIiwiaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbCIsImludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyIsIm5lZ2F0aXZlX2V4cG9uZW50Iiwib3ZlcmZsb3ciLCJpbnRfcG93IiwiYmFzZSIsImV4cG9uZW50IiwiaW50NjRfcG93IiwiaW50NjNfcG93X29uX2ludDY0IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJtb2R1bHVzIiwicm91bmRfdXAiLCJyZW1haW5kZXIiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJ0b19tdWx0aXBsZV9vZiIsInJvdW5kX25lYXJlc3QiLCJtb2R1bHVzX21pbnVzX3JlbWFpbmRlciIsInJvdW5kIiwiaDAxIiwibWFzayIsImludDY0X3BvcGNvdW50IiwieCQyIiwiaW50MzJfcG9wY291bnQiLCJuYXRpdmVpbnRfcG9wY291bnQiLCJtb2R1bGVfbmFtZSQwIiwib2Zfc3RyaW5nJDAiLCJmbG9hdF9sb3dlcl9ib3VuZCIsImZsb2F0X3VwcGVyX2JvdW5kIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwiemVybyIsImZ1bmMkMCIsIm5lZyIsIm9mX3N0cmluZyQxIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50IiwiYWJzIiwicmVtIiwic2hpZnRfcmlnaHRfbG9naWNhbCIsInNoaWZ0X2xlZnQiLCJiaXRfbm90IiwiYml0X29yIiwiYml0X2FuZCIsImJpdF94b3IiLCJwb3ciLCJub25fcG9zaXRpdmVfYXJndW1lbnQiLCJjZWlsX3BvdzIiLCJ4JDMiLCJ4JDQiLCJ4JDUiLCJ4JDYiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJjZWlsX2xvZzIiLCJwb3Bjb3VudCIsImxub3QiLCJzdWNjX2V4biIsIm1zZyIsInByZWRfZXhuIiwib2Zfc2NhbGFyIiwib2Zfc2NhbGFyX2V4biIsInRvX3NjYWxhciIsInRvX2NoYXIiLCJ0b19jaGFyX2V4biIsInV0ZjhfYnl0ZV9sZW5ndGgiLCJ1Y2hhciIsImNvZGVwb2ludCIsInNvbWVfdCIsInN5bSIsInRyYW5zIiwiY29udiIsImRldHVwbGUyIiwidHVwbGUyIiwid2l0bmVzcyIsInZfMDA1IiwidG9fc2V4cCIsInVpZCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNpemUiLCJzZXRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkkMCIsInB1c2giLCJwb3Bfbm9uZW1wdHkiLCJwb3BfZXJyb3IiLCJwb3AiLCJwb3BfZXhuIiwidG9wX25vbmVtcHR5IiwidG9wX2Vycm9yIiwidG9wIiwidG9wX2V4biIsInVudGlsX2VtcHR5IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMjgiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJlcnJvcl9zb3VyY2VfMDU3IiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJyaWdodF8wMDgiLCJsZWZ0XzAwNyIsIm9mX2FfMDA5Iiwidl8wMTAiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsInRfMDMwIiwidF8wMjkiLCJ0XzAzMiIsInRfMDMxIiwicmlnaHRfMDM0IiwibGVmdF8wMzMiLCJyaWdodF8wMzgiLCJsZWZ0XzAzNyIsInRfMDQwIiwidF8wMzkiLCJ0XzA0MiIsInRfMDQxIiwicmlnaHRfMDM2IiwibGVmdF8wMzUiLCJvZl9rXzA0MyIsIm9mX3ZfMDQ0Iiwic2V4cF8wNzEiLCJhcmcxXzA2OCIsImFyZzBfMDY3IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJyZXMwXzA1OSIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJhcmcwXzA2NCIsInJlczBfMDY1IiwicmVzMV8wNzAiLCJvZl9rXzA3MiIsIm9mX3ZfMDczIiwiYXJnMV8wODIiLCJhcmcwXzA4MSIsInJlczBfMDgzIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJsaCIsImx2JDAiLCJyaCIsInJ2JDAiLCJtaW5fZWx0X2V4biIsImZvbGRfdW50aWxfaGVscGVyIiwidmFsdWUkMCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyJDAiLCJyMiQwIiwicjEkMCIsInVuaW9uX2xpc3QiLCJ0b190cmVlIiwiaW50ZXIiLCJvdGhlcl9zZXQiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiZW51bSQwIiwidHJlZSIsInN5bW1ldHJpY19kaWZmIiwiZWx0JDAiLCJlbnVtMSIsInRyZWUxIiwiZW51bTIiLCJ0cmVlMiIsImNvbXBhcmVfcmVzdWx0IiwibmV4dF9zdGF0ZSIsImdyZWF0ZXJfb3JfZXF1YWxfdG8iLCJsZXNzX29yX2VxdWFsX3RvIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsIm1heWJlIiwidiQxIiwiaW5pdCQwIiwidiQyIiwidiQzIiwidiQ0IiwiZSQyIiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJ0MiQyIiwidDEkMiIsImlzX3N1YnNldCIsImFyZV9kaXNqb2ludCIsImFjY3UkMCIsImFjY3UkMSIsImZpbHQiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJjaG9vc2VfZXhuIiwicG9zX3JlZiIsImdyb3VwX2J5IiwiZXF1aXYiLCJzZXQkMCIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJpc19zdWJzZXQkMCIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImludmFyaWFudHMkMCIsImVsZW1lbnRzJDAiLCJtaW5fZWx0X2V4biQwIiwibWF4X2VsdF9leG4kMCIsImNob29zZSQwIiwiY2hvb3NlX2V4biQwIiwiZm9sZF9yaWdodCQwIiwiaXRlcjIkMCIsImZpbHRlciQwIiwiYWRkJDAiLCJyZW1vdmUkMCIsInVuaW9uJDAiLCJpbnRlciQwIiwiZGlmZiQwIiwic3ltbWV0cmljX2RpZmYkMCIsImNvbXBhcmVfZGlyZWN0IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJncm91cF9ieSQwIiwibnRoJDAiLCJyZW1vdmVfaW5kZXgkMCIsInRvX3NlcXVlbmNlJDAiLCJiaW5hcnlfc2VhcmNoJDAiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQwIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJ0X29mX3NleHBfZGlyZWN0JDAiLCJpbnZhcmlhbnRzJDEiLCJpc19lbXB0eSQxIiwiZWxlbWVudHMkMSIsIm1pbl9lbHQkMSIsIm1pbl9lbHRfZXhuJDEiLCJtYXhfZWx0JDEiLCJtYXhfZWx0X2V4biQxIiwiY2hvb3NlJDEiLCJjaG9vc2VfZXhuJDEiLCJ0b19hcnJheSQxIiwiaXRlciQyIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJjb3VudCQxIiwic3VtJDEiLCJmaW5kJDEiLCJmaW5kX2V4biQxIiwiZmluZF9tYXAkMSIsImZvbGQkMSIsImZvbGRfdW50aWwkMSIsImZvbGRfcmlnaHQkMSIsImZpbHRlciQxIiwiZmlsdGVyX21hcCQwIiwicGFydGl0aW9uX3RmJDEiLCJpdGVyMiQxIiwibWVtJDEiLCJhZGQkMSIsInJlbW92ZSQxIiwidW5pb24kMSIsImludGVyJDEiLCJkaWZmJDEiLCJzeW1tZXRyaWNfZGlmZiQxIiwiY29tcGFyZV9kaXJlY3QkMCIsImlzX3N1YnNldCQzIiwiYXJlX2Rpc2pvaW50JDEiLCJvZl9saXN0JDAiLCJvZl9zZXF1ZW5jZSQwIiwib2ZfYXJyYXkkMCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQwIiwib2Zfc29ydGVkX2FycmF5JDAiLCJ1bmlvbl9saXN0JDAiLCJzdGFibGVfZGVkdXBfbGlzdCQwIiwiZ3JvdXBfYnkkMSIsInNwbGl0JDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsImNvbXBhcmF0b3JfcyIsImVtcHR5JDEiLCJzaW5nbGV0b24kMSIsInVuaW9uX2xpc3QkMiIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQyIiwib2Zfc29ydGVkX2FycmF5JDIiLCJvZl9saXN0JDIiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMiIsInN0YWJsZV9kZWR1cF9saXN0JDIiLCJmaWx0ZXJfbWFwJDIiLCJzZXhwX29mX21fdCIsIkVsdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiZXF1YWxfbV90IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfbV90IiwiY29tcGFyYXRvciQwIiwiZW1wdHkkMiIsInNpbmdsZXRvbiQyIiwidW5pb25fbGlzdCQzIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDMiLCJvZl9zb3J0ZWRfYXJyYXkkMyIsIm9mX2xpc3QkMyIsIm9mX3NlcXVlbmNlJDMiLCJvZl9hcnJheSQzIiwic3RhYmxlX2RlZHVwX2xpc3QkMyIsIm1hcCQzIiwiZmlsdGVyX21hcCQzIiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwicmVwbGFjZSIsInNldF90ZW1wb3JhcmlseSIsInJlc3RvcmVfdG8iLCJzZXRzIiwic25hcHNob3QiLCJzZXRzX3RlbXBvcmFyaWx5IiwiYW5kX3ZhbHVlcyIsImluY19udW1fbXV0YXRpb25zIiwiZWx0c19pbmRleCIsImNoZWNrX2luZGV4X2V4biIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJudW1fbXV0YXRpb25zXzAwMyIsImZyb250XzAwNSIsIm1hc2tfMDA3IiwibGVuZ3RoXzAwOSIsImVsdHNfMDExIiwiYm5kc18wMDIkMSIsImJuZHNfMDAyJDIiLCJibmRzXzAwMiQzIiwibXV0MiIsIm11dDEiLCJmcm9udCIsImNhcGFjaXR5JDAiLCJjYXBhY2l0eSQxIiwiYmxpdF90b19hcnJheSIsImZyb250X2xlbiIsInJlc3RfbGVuIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwiYmxpdF90cmFuc2ZlciIsImxlbiQxIiwiZHN0X3N0YXJ0Iiwic3JjX2kiLCJkc3RfaSIsImVucXVldWVfYWxsIiwidF9yZXN1bHQiLCJmaWx0ZXJfaW5wbGFjZSIsImZpbHRlcmlfaW5wbGFjZSIsInVucmVhY2hhYmxlX2NvZGUiLCJ6ZXJvJDAiLCJtaW51c19vbmUiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJ0b19pbnQzMl90cnVuYyIsIm9mX2ludDY0X3RydW5jIiwibmFtZSQwIiwib2ZfY29udGludWVfb3Jfc3RvcCIsInRvX2NvbnRpbnVlX29yX3N0b3AiLCJsZWZ0X3ZhbHVlIiwicmlnaHRfdmFsdWUiLCJ2YWx1ZXMiLCJsZWZ0X2RlZmF1bHQiLCJyaWdodF9kZWZhdWx0IiwicmlnaHQkMCIsImNvbXBhcmVfa2V5IiwidmwiLCJ2bCQwIiwidnIiLCJrMCIsImsxIiwibGQiLCJscmQiLCJscmQkMCIsInJkIiwicmxkIiwicmxkJDAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNpbmdsZXRvbl90b190cmVlX2V4biIsImNvbGxhcHNlIiwiZ28iLCJhZGRfdW5jaGVja2VkIiwiZ28kMCIsInRvX3RyZWVfdW5jaGVja2VkIiwibWF4X2tleSIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJqb2luJDAiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJhZGRfbXVsdGkiLCJkYXRhJDAiLCJmaW5kX211bHRpIiwibG93ZXJfcGFydCIsInVwcGVyX3BhcnQiLCJtaW5fdXBwZXIiLCJtYXhfbG93ZXIiLCJ1cHBlcl9wYXJ0X3dpdGhvdXRfbWluIiwiZ28kMSIsImNfbWluIiwiaW5pdCQxIiwiY19tYXgiLCJpbml0JDIiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSIsInJhbmdlX3RvX2FsaXN0IiwiY29uY2F0X3VuY2hlY2tlZCIsInJlbW92ZV9sb29wIiwiY2hhbmdlIiwiY2hhbmdlX2NvcmUiLCJkJDEiLCJsZW5ndGgkMiIsImxlbmd0aCQzIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJub25fZW1wdHlfdGFpbCIsIml0ZXJfa2V5cyIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsImZvbGRfdW50aWxfbG9vcCIsImZpbmFsJDEiLCJmaW5hbCQwIiwiZmlsdGVyX2tleXMiLCJwYXJ0aXRpb25fbWFwaSIsInBhaXIyIiwicGFpcjEiLCJjdXJyIiwiazIiLCJuZXh0JDEiLCJkYXRhX2VxdWFsIiwia2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIiwia2V5c19sZXNzX29yX2VxdWFsX3RvIiwiZCQyIiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImZvbGQyJDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwicmlnaHQkMiIsImxlZnQkMiIsInJpZ2h0JDEiLCJrZXlzIiwib2ZfZm9sZGFibGVfZm9sZCIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwibmV3X2RhdGEiLCJvZl9mb2xkYWJsZSIsIm9mX2ZvbGRhYmxlX29yX2Vycm9yIiwib2ZfZm9sZGFibGVfZXhuIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsIm9mX2FsaXN0X211bHRpIiwiZm9sZCQyIiwib2Zfc2VxdWVuY2VfZm9sZCIsIm9mX3NlcXVlbmNlX3JlZHVjZSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJmb3VuZF92YWx1ZSQwIiwiZm91bmRfa2V5JDAiLCJyYW5rIiwibnVtX3RvX3NlYXJjaCIsInBhaXIiLCJwYWlyJDAiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJlcnJvcl90cmVlIiwib2tzIiwibWFwX2tleXMiLCJtYXBfa2V5c19leG4iLCJsaWtlMiIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwid2l0aF9zYW1lX2xlbmd0aCIsInNldCQxIiwiYWRkX2V4biQwIiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJpdGVyX2tleXMkMCIsIml0ZXJpX3VudGlsJDAiLCJmb2xkJDMiLCJmb2xkMiQxIiwiZmlsdGVyX2tleXMkMCIsImZpbHRlcmkkMCIsImZpbHRlcl9tYXBpJDAiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQwIiwicGFydGl0aW9uaV90ZiQwIiwiY29tYmluZV9lcnJvcnMkMCIsImtleXMkMCIsInRvX2FsaXN0JDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQwIiwibWVyZ2Vfc2tld2VkJDAiLCJ0cmVlJDAiLCJib3RoX2xlbiIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJvZl9hbGlzdCQwIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMCIsIm9mX2FsaXN0X2V4biQwIiwib2ZfYWxpc3RfbXVsdGkkMCIsIm9mX2FsaXN0X2ZvbGQkMCIsIm9mX2FsaXN0X3JlZHVjZSQwIiwib2ZfaXRlcmkkMCIsIm9mX2l0ZXJpX2V4biQwIiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDAiLCJvZl9zZXF1ZW5jZV9leG4kMCIsIm9mX3NlcXVlbmNlX211bHRpJDAiLCJvZl9zZXF1ZW5jZV9mb2xkJDAiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMCIsInNldCQyIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2Vfc2tld2VkJDEiLCJmb3JfYWxsaSQxIiwiZXhpc3RzaSQxIiwiY291bnRpJDEiLCJhcHBlbmQkMSIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkMiIsIm50aF9leG4kMCIsInJhbmskMSIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UkMCIsIm1hcF9rZXlzJDAiLCJkdXAiLCJtYXBfa2V5c19leG4kMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfdHJlZSQyIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwibWFwX2tleXMkMSIsIm1hcF9rZXlzX2V4biQxIiwib2ZfdHJlZSQzIiwib2ZfYWxpc3QkMiIsIm9mX2FsaXN0X29yX2Vycm9yJDIiLCJvZl9hbGlzdF9leG4kMiIsIm9mX2FsaXN0X211bHRpJDIiLCJvZl9hbGlzdF9mb2xkJDIiLCJvZl9hbGlzdF9yZWR1Y2UkMiIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMiIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsIksiLCJ2X2dyYW1tYXIiLCJjb21wYXJlX3YiLCJlcXVhbF92IiwiaGFzaF9mb2xkX3YiLCJvZl90cmVlJDQiLCJlbXB0eSQzIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX2l0ZXJpJDMiLCJvZl9pdGVyaV9leG4kMyIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDMiLCJvZl9zZXF1ZW5jZV9leG4kMyIsIm9mX3NlcXVlbmNlX211bHRpJDMiLCJvZl9zZXF1ZW5jZV9mb2xkJDMiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMyIsIm1hcF9rZXlzJDMiLCJtYXBfa2V5c19leG4kMyIsInRyYW5zZmVyIiwicSIsInEkMCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0IiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwidW53cmFwIiwiY2x6IiwiY3R6IiwiaW52YWxpZF9zdHIiLCJzaWduZWRuZXNzIiwicG9zX3N0ciIsImludDYzJDAiLCJpbnQ2MyIsIm9uZSQwIiwib2ZfbmF0aXZlaW50X3RydW5jIiwidG9fbmF0aXZlaW50X3RydW5jIiwidG9fc3RyaW5nJDEiLCJvZl9pbnRfdHJ1bmMiLCJyZXByIiwicmVwciQwIiwiaW5jbHVkZSIsIm9mX2Zsb2F0JDAiLCJ0b19mbG9hdCQwIiwib2ZfaW50X2V4biQwIiwidG9faW50X2V4biQwIiwicHAkMCIsImhhc2hhYmxlJDAiLCJpc19wb3NpdGl2ZSQwIiwiaXNfbm9uX25lZ2F0aXZlJDAiLCJpc19uZWdhdGl2ZSQwIiwiaXNfbm9uX3Bvc2l0aXZlJDAiLCJzaWduJDAiLCJpbnZhcmlhbnQkMCIsInRvX3N0cmluZ19odW0kMCIsIm1pbnVzX29uZSQwIiwicmVtJDAiLCJyb3VuZCQwIiwicm91bmRfdG93YXJkc196ZXJvJDAiLCJyb3VuZF9kb3duJDAiLCJyb3VuZF91cCQwIiwicm91bmRfbmVhcmVzdCQwIiwic3VjYyQwIiwicHJlZCQwIiwicG93JDAiLCJiaXRfYW5kJDAiLCJiaXRfb3IkMCIsImJpdF94b3IkMCIsImJpdF9ub3QkMCIsInBvcGNvdW50JDAiLCJzaGlmdF9sZWZ0JDAiLCJzaGlmdF9yaWdodCQwIiwiZGVjciQwIiwiaW5jciQwIiwib2ZfaW50MzJfZXhuJDAiLCJ0b19pbnQzMl9leG4kMCIsIm9mX2ludDY0X2V4biQwIiwidG9faW50NjQkMCIsIm9mX25hdGl2ZWludF9leG4kMCIsInRvX25hdGl2ZWludF9leG4kMCIsIm51bV9iaXRzJDAiLCJtYXhfdmFsdWUkMCIsIm1pbl92YWx1ZSQwIiwic2hpZnRfcmlnaHRfbG9naWNhbCQwIiwiY2VpbF9wb3cyJDAiLCJmbG9vcl9wb3cyJDAiLCJjZWlsX2xvZzIkMCIsImlzX3BvdzIkMCIsImNseiQwIiwiY3R6JDAiLCJvZl9pbnQkMCIsInRvX2ludCQwIiwidG9faW50X3RydW5jJDAiLCJ0b19pbnQzMiQwIiwib2ZfaW50NjQkMCIsIm9mX25hdGl2ZWludCQwIiwidG9fbmF0aXZlaW50JDAiLCJ0b19uYXRpdmVpbnRfdHJ1bmMkMCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQwIiwicmVwciQxIiwiYnN3YXAzMiQwIiwiYnN3YXA0OCQwIiwicG9zX2RpZmYiLCJuZWdhdGl2ZV9vbmUiLCJkaXZfd291bGRfb3ZlcmZsb3ciLCJwcm9kdWN0IiwiYWJzJDEiLCJuZWckMCIsInJhbmRvbV9vZl9pbnQiLCJyYW5kb21fb2ZfaW50NjQiLCJyYW5kb21fb2ZfaW50JDAiLCJyYW5kb21faW5jbF9vZl9pbnQiLCJyYW5kb21faW5jbF9vZl9pbnQ2NCIsInJhbmRvbV9pbmNsIiwiaW52IiwibGVmdF9rZXkiLCJyaWdodF9rZXkiLCJ1cGRhdGVfaGVpZ2h0Iiwib2xkX2hlaWdodCIsIm5ld19oZWlnaHQiLCJiYWxhbmNlIiwicm9vdF9ub2RlIiwibGVmdF9ub2RlIiwicmlnaHRfbm9kZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsInNldF9sZWZ0Iiwibm9kZSIsInNldF9yaWdodCIsImFkZGVkIiwiZmluZGlfYW5kX2NhbGxfaW1wbCIsImFyZzEiLCJhcmcyIiwiY2FsbF9pZl9mb3VuZCIsImNhbGxfaWZfbm90X2ZvdW5kIiwiZmluZF9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMCIsImNhbGxfaWZfbm90X2ZvdW5kJDAiLCJmaW5kaV9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMSIsImNhbGxfaWZfbm90X2ZvdW5kJDEiLCJmaW5kX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMiIsImNhbGxfaWZfbm90X2ZvdW5kJDIiLCJmaW5kaV9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDMiLCJjYWxsX2lmX25vdF9mb3VuZCQzIiwiZmluZF9hbmRfY2FsbDIiLCJjYWxsX2lmX2ZvdW5kJDQiLCJjYWxsX2lmX25vdF9mb3VuZCQ0IiwiZmluZGlfYW5kX2NhbGwyIiwiaWZfZm91bmQkMCIsImlmX25vdF9mb3VuZCQwIiwicmVtb3ZlZCIsImtleSQ0IiwiZGF0YSQ0IiwicmtleSIsInJkYXRhIiwia2V5JDEiLCJya2V5JDAiLCJyZGF0YSQwIiwibGtleSQwIiwibGRhdGEkMCIsImtleSQzIiwiZGF0YSQzIiwicmtleSQxIiwicmRhdGEkMSIsImxrZXkiLCJsZGF0YSIsImtleSQyIiwiZGF0YSQyIiwibWFwaV9pbnBsYWNlIiwiZW5zdXJlX211dGF0aW9uX2FsbG93ZWQiLCJ3aXRob3V0X211dGF0aW5nIiwibWF4X3RhYmxlX2xlbmd0aCIsImdyb3d0aF9hbGxvd2VkIiwic2l6ZSQwIiwic2l6ZSQxIiwic2xvdCIsImFkZF93b3JrZXIiLCJuZXdfcm9vdCIsIm1heWJlX3Jlc2l6ZV90YWJsZSIsInNob3VsZF9ncm93IiwibmV3X2FycmF5X2xlbmd0aCIsIm5ld190YWJsZSIsIm9sZF90YWJsZSIsInNleHBfb2Zfa2V5JDAiLCJhZGRlZF9vcl9yZW1vdmVkIiwiYnVja2V0IiwiY2hvb3NlX25vbmVtcHR5IiwidGFibGUiLCJhdmx0cmVlIiwiaW52YXJpYW50X2tleSIsImludmFyaWFudF9kYXRhIiwicmVhbF9sZW4iLCJuZXdfdCIsInQwIiwibmV3X2RhdGEkMCIsImZpbmRfb3JfYWRkIiwiaWQiLCJmaW5kaV9vcl9hZGQiLCJmaW5kX2FuZF9yZW1vdmUiLCJ1cGRhdGVfYW5kX3JldHVybiIsImluY3JfYnkiLCJyZW1vdmVfaWZfemVybyIsImJ5IiwiY3JlYXRlX21hcHBlZCIsImdldF9rZXkiLCJnZXRfZGF0YSIsImR1cGVzIiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwic2V4cF9vZl9kYXRhIiwiZF9vZl9zZXhwIiwia19ncmFtbWFyIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsInRfbGVmdCIsInRfcmlnaHQiLCJtZXJnZV9pbnRvIiwiZHN0X2RhdGEkMCIsImFjdGlvbiIsImRzdF9kYXRhIiwidG9fcmVtb3ZlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsInNpbWlsYXIiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMCIsImNyZWF0ZV9tYXBwZWQkMCIsImNyZWF0ZV93aXRoX2tleSQwIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDAiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDAiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMSIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQxIiwiaGFzaGFibGVfcyIsInBvbHlfaGFzaGFibGUiLCJzdHJpY3RfYWRkIiwic3RyaWN0X2FkZF9leG4iLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJzZXhwX29mX2UiLCJsYXJnZXIiLCJzbWFsbGVyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJlX29mX3NleHAiLCJtaW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlIiwibWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZSIsIm9mX2ludDYzIiwiaXJvdW5kX2xib3VuZCIsImlyb3VuZF91Ym91bmQiLCJpcm91bmRfdXAiLCJpcm91bmRfdXBfZXhuIiwiaXJvdW5kX2Rvd24iLCJpcm91bmRfZG93bl9leG4iLCJpcm91bmRfdG93YXJkc196ZXJvIiwiaXJvdW5kX3Rvd2FyZHNfemVyb19leG4iLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCIsImlyb3VuZF9uZWFyZXN0XzMyIiwiaXJvdW5kX25lYXJlc3RfNjQiLCJwaSIsInNxcnRfcGkiLCJzcXJ0XzJwaSIsImV1bGVyIiwiaXJvdW5kX25lYXJlc3RfNjQkMCIsImlyb3VuZF9uZWFyZXN0X2V4bl8zMiIsImlyb3VuZF9uZWFyZXN0X2V4bl82NCIsImlyb3VuZF9uZWFyZXN0X2V4biIsImlyb3VuZF9leG4iLCJpcm91bmQiLCJpc19pbmYiLCJpc19maW5pdGUiLCJtaW5faW5hbiIsIm1heF9pbmFuIiwic3F1YXJlIiwiZnJhY3Rpb25hbCIsImludGVncmFsIiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwiY2xhc3NpZnkiLCJzdHJpcF96ZXJvIiwiZGVjaW1hbHMiLCJleHBsaWNpdF9wbHVzIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvIiwia2lsbyIsIm1lZ2EiLCJnaWdhIiwidGVyYSIsInBldGEiLCJtYWciLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImhpZ2hlciIsImRpZmZfcmlnaHQiLCJkaWZmX2xlZnQiLCJwZXRhJDAiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmciLCJyb3VuZF9nZW4iLCJzZCIsImRkIiwiZGQkMCIsInNkJDAiLCJkZCQxIiwic2QkMSIsImFic19kZCIsInJvdW5kX3NpZ25pZmljYW50Iiwic2lnbmlmaWNhbnRfZGlnaXRzIiwicm91bmRfZGVjaW1hbCIsImRlY2ltYWxfZGlnaXRzIiwic2lnbl9leG4iLCJzaWduX29yX25hbiIsImllZWVfbmVnYXRpdmUiLCJtYW50aXNzYV9iaXRzIiwiZXhwb25lbnRfbWFzazY0IiwiZXhwb25lbnRfbWFzayIsIm1hbnRpc3NhX21hc2siLCJtYW50aXNzYV9tYXNrNjQiLCJpZWVlX2V4cG9uZW50IiwiaWVlZV9tYW50aXNzYSIsImNyZWF0ZV9pZWVlX2V4biIsIm5lZ2F0aXZlIiwibWFudGlzc2EiLCJzaWduX2JpdHMiLCJleHB0X2JpdHMiLCJtYW50X2JpdHMiLCJjcmVhdGVfaWVlZSIsInNwZWNpYWxpemVkX2hhc2giLCJhZGRfc3Vic3RyaW5nIiwiYWRkX3N1YmJ5dGVzIiwiZWxpZGVkX21lc3NhZ2UiLCJlbGlkZSIsImF0X21vc3RfbnVtX2ZyYW1lcyIsInRvX3N0cmluZ19saXN0Iiwic2V0X3JlY29yZGluZyIsImFtX3JlY29yZGluZyIsIm1vc3RfcmVjZW50IiwibW9zdF9yZWNlbnRfZm9yX2V4biIsIndpdGhfcmVjb3JkaW5nIiwic2F2ZWQiLCJvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmEiLCJhcnJheV9vZl9zZXhwIiwic2V4cF9vZl9hcnJheSIsImFycmF5X3NleHBfZ3JhbW1hciIsImJvb2xfb2Zfc2V4cCIsInNleHBfb2ZfYm9vbCIsImJvb2xfc2V4cF9ncmFtbWFyIiwiY2hhcl9vZl9zZXhwIiwic2V4cF9vZl9jaGFyIiwiY2hhcl9zZXhwX2dyYW1tYXIiLCJzZXhwX29mX2V4biIsImZ1bmMkMSIsImZsb2F0X29mX3NleHAiLCJzZXhwX29mX2Zsb2F0IiwiZmxvYXRfc2V4cF9ncmFtbWFyIiwiZnVuYyQyIiwiaW50X29mX3NleHAiLCJzZXhwX29mX2ludCIsImludF9zZXhwX2dyYW1tYXIiLCJmdW5jJDMiLCJpbnQzMl9vZl9zZXhwIiwic2V4cF9vZl9pbnQzMiIsImludDMyX3NleHBfZ3JhbW1hciIsImZ1bmMkNCIsImludDY0X29mX3NleHAiLCJzZXhwX29mX2ludDY0IiwiaW50NjRfc2V4cF9ncmFtbWFyIiwibGlzdF9vZl9zZXhwIiwic2V4cF9vZl9saXN0IiwibGlzdF9zZXhwX2dyYW1tYXIiLCJmdW5jJDUiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInNleHBfb2ZfbmF0aXZlaW50IiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9vZl9zZXhwIiwic2V4cF9vZl9vcHRpb24iLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicmVmX29mX3NleHAiLCJzZXhwX29mX3JlZiIsInJlZl9zZXhwX2dyYW1tYXIiLCJzdHJpbmdfb2Zfc2V4cCIsInNleHBfb2Zfc3RyaW5nIiwic3RyaW5nX3NleHBfZ3JhbW1hciIsImNvbXBhcmVfYnl0ZXMiLCJlcXVhbF9ieXRlcyIsImJ5dGVzX29mX3NleHAiLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXNfc2V4cF9ncmFtbWFyIiwiZnVuYyQ2IiwidW5pdF9vZl9zZXhwIiwic2V4cF9vZl91bml0IiwidW5pdF9zZXhwX2dyYW1tYXIiLCJmYWlsd2l0aCIsImludmFsaWRfYXJnIiwiY29tcGFyZV9hcnJheSQwIiwiZXF1YWxfYXJyYXkkMCIsImFycmF5X29mX3NleHAkMCIsInNleHBfb2ZfYXJyYXkkMCIsImFycmF5X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9ib29sJDAiLCJlcXVhbF9ib29sJDAiLCJoYXNoX2ZvbGRfYm9vbCQwIiwiaGFzaF9ib29sJDAiLCJib29sX29mX3NleHAkMCIsInNleHBfb2ZfYm9vbCQwIiwiYm9vbF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfY2hhciQwIiwiZXF1YWxfY2hhciQwIiwiaGFzaF9mb2xkX2NoYXIkMCIsImhhc2hfY2hhciQwIiwiY2hhcl9vZl9zZXhwJDAiLCJzZXhwX29mX2NoYXIkMCIsImNoYXJfc2V4cF9ncmFtbWFyJDAiLCJzZXhwX29mX2V4biQwIiwiY29tcGFyZV9mbG9hdCQwIiwiZXF1YWxfZmxvYXQkMCIsImhhc2hfZm9sZF9mbG9hdCQwIiwiaGFzaF9mbG9hdCQwIiwiZmxvYXRfb2Zfc2V4cCQwIiwic2V4cF9vZl9mbG9hdCQwIiwiZmxvYXRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludCQwIiwiZXF1YWxfaW50JDAiLCJoYXNoX2ZvbGRfaW50JDAiLCJoYXNoX2ludCQwIiwiaW50X29mX3NleHAkMCIsInNleHBfb2ZfaW50JDAiLCJpbnRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDMyJDAiLCJlcXVhbF9pbnQzMiQwIiwiaGFzaF9mb2xkX2ludDMyJDAiLCJoYXNoX2ludDMyJDAiLCJpbnQzMl9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDMyJDAiLCJpbnQzMl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfaW50NjQkMCIsImVxdWFsX2ludDY0JDAiLCJoYXNoX2ZvbGRfaW50NjQkMCIsImhhc2hfaW50NjQkMCIsImludDY0X29mX3NleHAkMCIsInNleHBfb2ZfaW50NjQkMCIsImludDY0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9saXN0JDAiLCJlcXVhbF9saXN0JDAiLCJoYXNoX2ZvbGRfbGlzdCQwIiwibGlzdF9vZl9zZXhwJDAiLCJzZXhwX29mX2xpc3QkMCIsImxpc3Rfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX25hdGl2ZWludCQwIiwiZXF1YWxfbmF0aXZlaW50JDAiLCJoYXNoX2ZvbGRfbmF0aXZlaW50JDAiLCJoYXNoX25hdGl2ZWludCQwIiwibmF0aXZlaW50X29mX3NleHAkMCIsInNleHBfb2ZfbmF0aXZlaW50JDAiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX29wdGlvbiQwIiwiZXF1YWxfb3B0aW9uJDAiLCJoYXNoX2ZvbGRfb3B0aW9uJDAiLCJvcHRpb25fb2Zfc2V4cCQwIiwic2V4cF9vZl9vcHRpb24kMCIsIm9wdGlvbl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfcmVmJDAiLCJlcXVhbF9yZWYkMCIsInJlZl9vZl9zZXhwJDAiLCJzZXhwX29mX3JlZiQwIiwicmVmX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9zdHJpbmckMCIsImVxdWFsX3N0cmluZyQwIiwiaGFzaF9mb2xkX3N0cmluZyQwIiwiaGFzaF9zdHJpbmckMCIsInN0cmluZ19vZl9zZXhwJDAiLCJzZXhwX29mX3N0cmluZyQwIiwic3RyaW5nX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9ieXRlcyQwIiwiZXF1YWxfYnl0ZXMkMCIsImJ5dGVzX29mX3NleHAkMCIsInNleHBfb2ZfYnl0ZXMkMCIsImJ5dGVzX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV91bml0JDAiLCJlcXVhbF91bml0JDAiLCJoYXNoX2ZvbGRfdW5pdCQwIiwiaGFzaF91bml0JDAiLCJ1bml0X29mX3NleHAkMCIsInNleHBfb2ZfdW5pdCQwIiwidW5pdF9zZXhwX2dyYW1tYXIkMCIsInJhaXNlX3MkMCIsInBoeXNfZXF1YWwkMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3BvbHkwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW1wb3J0MC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3ByaW50Zi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3N5czAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9hcnJheTAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9jaGFyMC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludDAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9saXN0MC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2gubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9wcHhfY29tcGFyZV9saWIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9wcHhfaGFzaF9saWIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zZXhwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvd29yZF9zaXplLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9leG4ubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS93aXRoX3JldHVybi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL21vbmFkX2ludGYubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9tb25hZC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2FwcGxpY2F0aXZlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYnl0ZXMwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvY29tcGFyYXRvci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2VpdGhlcjAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9maWVsZC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3N0cmluZzAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zb3VyY2VfY29kZV9wb3NpdGlvbjAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9saXN0MS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3Jlc3VsdC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2NvbnRhaW5lcl9pbnRmLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvY29udGFpbmVyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbGF6eS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL29yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvcmFuZG9tX3JlcHIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9yYW5kb20ubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9hcnJheV9wZXJtdXRlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZm4ubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcmRlcmluZy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2xpc3QubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbmZvLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZXJyb3IubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnZhcmlhbnQubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcl9lcnJvci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3NpZ24wLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvY29tcGFyYWJsZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2hhYmxlX2ludGYubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pZGVudGlmaWFibGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS91bml0Lm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoYWJsZV9pbnRmLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ibGl0Lm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvb3B0aW9uLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2V4cGFibGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9laXRoZXIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbmRleGVkX2NvbnRhaW5lci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3NlcXVlbmNlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYXJyYXkubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vYmpfYXJyYXkubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS91bmlmb3JtX2FycmF5Lm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZmxvYXQwLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvY2hhci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3BweF9lbnVtZXJhdGVfbGliLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYnl0ZXNfdHIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zdGFnZWQubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zdHJpbmcubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ieXRlcy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hleF9sZXhlci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludF9jb252ZXJzaW9ucy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3Bvd19vdmVyZmxvd19ib3VuZHMubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnRfbWF0aC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3BvcGNvdW50Lm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2lnbi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3VjaGFyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL29wdGlvbl9hcnJheS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3N0YWNrLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zaWduX29yX25hbi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL21heWJlX2JvdW5kLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbWFwX2ludGYubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zZXRfaW50Zi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3NldC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3JlZi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3F1ZXVlLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvbm90aGluZy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL25hdGl2ZWludC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL21hcC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2xpbmtlZF9xdWV1ZTAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9saW5rZWRfcXVldWUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnQ2NC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludDYzX2VtdWwubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ib29sLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW50MzIubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnQ2My5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2h0YmxfaW50Zi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2F2bHRyZWUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9oYXNodGJsLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaGFzaF9zZXQubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9mbG9hdC5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2J1ZmZlci5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2JhY2t0cmFjZS5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2Jhc2UubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztZQWdCSUEsV0FBV0MsR0FBRUMsR0FBSSxPQUFBLGFBQUpBLEdBQUZELEdBQWlCOztJQUM1QkU7SUFDQUM7bUNBRkFKLFlBRUFJLEtBREFEOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0M0QlU7Ozs7OztJQXZDVkU7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXVDVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF3RlZDLFlBQWFyRixHQUFrQixPQUFsQkEsRUFBa0M7WUFLL0NzRixtQjtPQUNBQztZQUNBQyxtQjtZQUNBQyxtQjtZQUNBQyxtQjtZQUNBQyxtQjtZQUNBQyxtQjtZQUNBQyxtQjtPQUNBQztZQUNBQyxvQjtPQWdCRUM7WUFDQWpHLFdBQVlDLEdBQVNDLEdBQUksd0JBQUpBLEdBQVRELEdBQXdCO1lBQ3BDaUcsTUFBS2pHLEdBQVNDLEdBQUksT0FBSkEsS0FBVEQsSUFBQUEsSUFBU0MsRUFBMkI7WUFDekNpRyxNQUFLbEcsR0FBU0MsR0FBSSxPQUFiRCxLQUFTQyxJQUFURCxJQUFTQyxFQUEyQjtHQWZOO0lBQUEscUNBWW5DK0YsV0FDQWpHLFlBQ0FrRyxPQUNBQztJQUhBQztJQUNBQztJQUNBQztJQUNBQztJQU1BQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxZQUFXN0csR0FBa0JDLEdBQUksT0FBQSwwQkFBdEJELEdBQWtCQyxHQUFzQjtZQUNuRDZHLGFBQVk5RyxHQUFrQkMsR0FBSSxPQUFBLDBCQUF0QkQsR0FBa0JDLEdBQXVCO09BQ3JEOEcsNEJBQ0FDO1lBQ0FDLE1BTFFqSCxHQUFrQkMsR0FLQyxPQUxHLGtCQUF0QkQsR0FBa0JDLEtBQWxCRCxJQUFrQkMsRUFLd0I7WUFDbERpSCxNQVZRbEgsR0FBa0JDLEdBVUMsT0FWRyxlQUF0QkQsR0FBa0JDLEtBQWxCRCxJQUFrQkMsRUFVd0I7R0FaYjs7O09BQ3JDc0c7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7WUFlQUMsWUFBV25ILEdBQWtCQyxHQUFJLE9BQUEsMEJBQXRCRCxHQUFrQkMsR0FBc0I7WUFDbkRtSCxhQUFZcEgsR0FBa0JDLEdBQUksT0FBQSwwQkFBdEJELEdBQWtCQyxHQUF1QjtZQUNyRG9ILE1BQUtySCxHQUFrQkMsR0FBSSxPQUFHLGtCQUF6QkQsR0FBa0JDLEtBQWxCRCxJQUFrQkMsRUFBMkI7WUFDbERxSCxNQUFLdEgsR0FBa0JDLEdBQUksT0FBRyxlQUF6QkQsR0FBa0JDLEtBQWxCRCxJQUFrQkMsRUFBMkI7R0FmYjtJQUFBO1VBWXJDa0gsYUFDQUMsY0FDQUMsT0FDQUM7SUFJQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsWUFBVzdILEdBQXNCQyxHQUFJLE9BQUEsMEJBQTFCRCxHQUFzQkMsR0FBc0I7WUFDdkQ2SCxhQUFZOUgsR0FBc0JDLEdBQUksT0FBQSwwQkFBMUJELEdBQXNCQyxHQUF1QjtPQUN6RDhILDhCQUNBQztZQUNBQyxNQUxRakksR0FBc0JDLEdBS0MsT0FMRyxrQkFBMUJELEdBQXNCQyxLQUF0QkQsSUFBc0JDLEVBS3dCO1lBQ3REaUksTUFWUWxJLEdBQXNCQyxHQVVDLE9BVkcsZUFBMUJELEdBQXNCQyxLQUF0QkQsSUFBc0JDLEVBVXdCO0dBWmI7OztPQUN6Q3NIO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO1lBSUFDLFVBQU9uSSxHQUFVQyxHQUFJLE9BQWRELElBQVVDLFVBQWtCO1lBQ25DbUksVUFBUXBJLEdBQVVDLEdBQUksT0FBZEQsS0FBVUMsVUFBbUI7WUFDckNvSSxVQUFRckksR0FBVUMsR0FBSSxPQUFkRCxNQUFVQyxVQUFtQjtZQUNyQ3FJLFVBQU90SSxHQUFVQyxHQUFJLE9BQWRELE1BQVVDLFVBQWtCO1lBQ25Dc0ksVUFBT3ZJLEdBQVVDLEdBQUksT0FBSkEsSUFBVkQsVUFBNEI7WUFDbkN3SSxVQUFReEksR0FBVUMsR0FBSSxPQUFKQSxLQUFWRCxVQUE2QjtZQUNyQ3lJLFlBQVd6SSxHQUFVQyxHQUFJLE9BQUEsMEJBQWRELEdBQVVDLEdBQXNCO1lBQzNDeUksYUFBWTFJLEdBQVVDLEdBQUksT0FBQSwwQkFBZEQsR0FBVUMsR0FBdUI7T0FDN0MwSTtZQUNBQyxRQUFPNUksR0FBVUMsR0FBSSxPQUFkRCxNQUFVQyxVQUFrQjtZQUNuQzRJLE1BTFE3SSxHQUFVQyxHQUtDLE9BTERBLEtBQVZELElBQUFBLElBQVVDLEVBS3dCO1lBQzFDNkksTUFWUTlJLEdBQVVDLEdBVUMsT0FWWEQsS0FBVUMsSUFBVkQsSUFBVUMsRUFVd0I7R0FaTjs7O09BQ3BDa0k7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7WUFJQUMsVUFBTy9JLEdBQVVDLEdBQUksT0FBZEQsSUFBVUMsVUFBa0I7WUFDbkMrSSxVQUFRaEosR0FBVUMsR0FBSSxPQUFkRCxLQUFVQyxVQUFtQjtZQUNyQ2dKLFVBQVFqSixHQUFVQyxHQUFJLE9BQWRELE1BQVVDLFVBQW1CO1lBQ3JDaUosVUFBT2xKLEdBQVVDLEdBQUksT0FBZEQsTUFBVUMsVUFBa0I7WUFDbkNrSixVQUFPbkosR0FBVUMsR0FBSSxPQUFKQSxJQUFWRCxVQUE0QjtZQUNuQ29KLFVBQVFwSixHQUFVQyxHQUFJLE9BQUpBLEtBQVZELFVBQTZCO1lBQ3JDcUosWUFBV3JKLEdBQVVDLEdBQUksT0FBQSwwQkFBZEQsR0FBVUMsR0FBc0I7WUFDM0NxSixhQUFZdEosR0FBVUMsR0FBSSxPQUFBLDBCQUFkRCxHQUFVQyxHQUF1QjtPQUM3Q3NKO1lBQ0FDLFFBQU94SixHQUFVQyxHQUFJLE9BQWRELE1BQVVDLFVBQWtCO1lBQ25Dd0osTUFMUXpKLEdBQVVDLEdBS0MsT0FMREEsS0FBVkQsSUFBQUEsSUFBVUMsRUFLd0I7WUFDMUN5SixNQVZRMUosR0FBVUMsR0FVQyxPQVZYRCxLQUFVQyxJQUFWRCxJQUFVQyxFQVV3QjtHQVpOOzs7T0FDcEM4STtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztZQUlBQyxFQUFFM0osR0FBSSxPQUFBLDZCQUFKQSxHQUF1QjtZQUN6QjRKLFVBQU81SixHQUFrQkMsR0FBZ0QsVUFEekUwSixFQUN5QjFKLElBQTBDLE9BRG5FMEosRUFDTzNKLGlCQUF1RTtZQUM5RTZKLFVBQVE3SixHQUFrQkMsR0FBaUQsVUFGM0UwSixFQUUwQjFKLElBQTJDLE9BRnJFMEosRUFFUTNKLGtCQUF3RTtZQUNoRjhKLFVBQVE5SixHQUFrQkMsR0FBaUQsVUFIM0UwSixFQUcwQjFKLElBQTJDLE9BSHJFMEosRUFHUTNKLG1CQUF3RTtZQUNoRitKLFVBQU8vSixHQUFrQkMsR0FBZ0QsVUFKekUwSixFQUl5QjFKLElBQTBDLE9BSm5FMEosRUFJTzNKLG1CQUF1RTtZQUM5RWdLLFVBQU9oSyxHQUFrQkMsR0FBZ0QsVUFMekUwSixFQUt5QjFKLElBQTBDLGFBTG5FMEosRUFLTzNKLFdBQXVFO1lBQzlFaUssVUFBUWpLLEdBQWtCQyxHQUFpRCxVQU4zRTBKLEVBTTBCMUosSUFBMkMsY0FOckUwSixFQU1RM0osV0FBd0U7WUFFaEZrSyxZQUFXbEssR0FBa0JDO0lBQy9CLElBQWdELE1BVDlDMEosRUFRNkIxSixJQUNXLE1BVHhDMEosRUFRVzNKO0lBQ21DLE9BQUE7R0FBSztZQUduRG1LLGFBQVluSyxHQUFrQkM7SUFDaEMsSUFBaUQsTUFiL0MwSixFQVk4QjFKLElBQ1csTUFiekMwSixFQVlZM0o7SUFDbUMsT0FBQTtHQUFLO1lBR3BEb0ssVUFBU3BLLEdBQWtCQztJQUFrRCxVQWhCN0UwSixFQWdCMkIxSjtJQUE0QyxPQUFBLGlCQWhCdkUwSixFQWdCUzNKO0dBQXlFO1lBQ2xGcUssUUFBT3JLLEdBQWtCQyxHQUFnRCxVQWpCekUwSixFQWlCeUIxSixJQUEwQyxPQWpCbkUwSixFQWlCTzNKLG1CQUF1RTtZQUM5RXNLLE1BQUt0SyxHQUFrQkMsR0FBSSxPQVozQmdLLFVBWUtqSyxHQUFrQkMsS0FBbEJELElBQWtCQyxFQUEyQjtZQUNsRHNLLE1BQUt2SyxHQUFrQkMsR0FBSSxPQWpCM0I0SixVQWlCSzdKLEdBQWtCQyxLQUFsQkQsSUFBa0JDLEVBQTJCO0dBcEJiOzs7T0FDckMwSjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQUlBQztPQUlBQztPQUNBQztPQUNBQztPQUNBQztZQUlBQyxVQUFPeEssR0FBV0MsR0FBSSxPQUFmRCxJQUFXQyxVQUFrQjtZQUNwQ3dLLFVBQVF6SyxHQUFXQyxHQUFJLE9BQWZELEtBQVdDLFVBQW1CO1lBQ3RDeUssVUFBUTFLLEdBQVdDLEdBQUksT0FBZkQsS0FBV0MsVUFBbUI7WUFDdEMwSyxVQUFPM0ssR0FBV0MsR0FBSSxPQUFmRCxLQUFXQyxVQUFrQjtZQUNwQzJLLFVBQU81SyxHQUFXQyxHQUFJLE9BQUpBLElBQVhELFVBQTZCO1lBQ3BDNkssVUFBUTdLLEdBQVdDLEdBQUksT0FBSkEsS0FBWEQsVUFBOEI7WUFDdEM4SyxZQUFXOUssR0FBV0MsR0FBSSxPQUFBLDBCQUFmRCxHQUFXQyxHQUFzQjtZQUM1QzhLLGFBQVkvSyxHQUFXQyxHQUFJLE9BQUEsMEJBQWZELEdBQVdDLEdBQXVCO09BQzlDK0s7WUFDQUMsUUFBT2pMLEdBQVdDLEdBQUksT0FBZkQsS0FBV0MsVUFBa0I7WUFDcENpTCxNQUxRbEwsR0FBV0MsR0FLQyxPQUxEQSxLQUFYRCxJQUFBQSxJQUFXQyxFQUt3QjtZQUMzQ2tMLE1BVlFuTCxHQUFXQyxHQVVDLE9BVlpELEtBQVdDLElBQVhELElBQVdDLEVBVXdCO0dBWk47SUFBQTs7T0FDckN1SztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztJQUlBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxZQUFXMUwsR0FBWUMsR0FBSSxPQUFBLDBCQUFoQkQsR0FBWUMsR0FBc0I7WUFDN0MwTCxhQUFZM0wsR0FBWUMsR0FBSSxPQUFBLDBCQUFoQkQsR0FBWUMsR0FBdUI7T0FDL0MyTCx5Q0FDQUM7WUFDQUMsTUFMUTlMLEdBQVlDLEdBS0MsT0FMRyx5QkFBaEJELEdBQVlDLEtBQVpELElBQVlDLEVBS3dCO1lBQzVDOEwsTUFWUS9MLEdBQVlDLEdBVUMsT0FWRyxzQkFBaEJELEdBQVlDLEtBQVpELElBQVlDLEVBVXdCO0dBWk47SUFBQTs7T0FDdENtTDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztJQUlBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxZQUFXdE0sR0FBV0MsR0FBSSxPQUFBLDBCQUFmRCxHQUFXQyxHQUFzQjtZQUM1Q3NNLGFBQVl2TSxHQUFXQyxHQUFJLE9BQUEsMEJBQWZELEdBQVdDLEdBQXVCO09BQzlDdU0sd0NBQ0FDO1lBQ0FDLE9BTFExTSxHQUFXQyxHQUtDLE9BTEcsd0JBQWZELEdBQVdDLEtBQVhELElBQVdDLEVBS3dCO1lBQzNDME0sT0FWUTNNLEdBQVdDLEdBVUMsT0FWRyxxQkFBZkQsR0FBV0MsS0FBWEQsSUFBV0MsRUFVd0I7R0FaTjtJQUFBOztPQUNyQytMO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO0lBWUZDO0lBQ0FDO1lBQ0FDLGU7WUFDQUMsZTtZQUNBQyxjO1lBQ0FDLGU7T0FDQUM7WUFDQUMsYztZQUNBQyxjO1lBQ0FDLGM7WUFDQUMsZTtPQUNBQyx3QkFDQUMsb0JBQ0FDO1lBQ0FDLFM7T0FDQUM7WUFDQUMsUztZQU1BQyxxQjtZQUNBQyxVO1lBQ0FDLFU7R0FXYTtJQVJiQztJQVFBQyxhQUFhOzs7OztPQW5XYjdJO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEOztPQStIQWlGO09BS0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDOztPQWdCRUk7T0FDQUM7T0FDQUM7T0FDQUM7Ozs7Ozs7Ozs7T0FnS0ZzRztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQU1BQztPQUNBQztPQUNBQztPQUdBQztPQVFBQzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7OztZQ3BXQUMsVUFBVUM7SUFBTSxPQUFBOztzQkFBY0MsVUFBUSxPQUFBLDhCQUFSQSxHQUFrQjthQUF0Q0Q7R0FBMkM7WUFDckRFLGFBQWFGO0lBQU0sT0FBQTs7c0JBQWNDLFVBQVEsT0FBQSw4QkFBUkEsR0FBcUI7YUFBekNEO0dBQThDOzs7Ozs7Ozs7T0FEM0REO09BQ0FHOzs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Ozs7OztJQ1VBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxnQkFBYyx3QkFBYTs7SUFDM0JDO0lBQ0FDO0lBQ0FDOzs7Ozs7O1lBRUFDLFdBQVdDO0lBQ2IsSUFBSSxVQUFBLGdCQURTQSxRQUNUOzs7O01BRUYsT0FBQSxnQ0FIV0E7OztHQUdpRTtZQUc1RUMsT0FBT0Q7SUFDVCxJQUFNLElBQ0p6UCxJQURJLGdCQURHeVA7Ozt1Q0FHcUI7OztJQUR2QixXQUFMelA7R0FDZ0M7Ozs7O09BNUJoQ3NPO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BTUFFOzs7O0U7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztHQzFCVzs7O0lBRlhyQjtJQUVXO0lBcUJYc0I7WUFFQUMsT0FBUUMsS0FBSTdQLEdBQ2QsT0FBSSx1QkFETTZQLEtBQUk3UCxHQUVvRTtZQUdoRjhQLDJCQUE0QkQ7SUFDOUIsT0FBSSw2QkFEMEJBO0dBR2tEOztJQUc5RUU7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFJQUMsS0FBS0MsR0FBR04sTUFBTU87SUFBSSxPQUFBLG1DQUFKQSxHQUFOUCxNQUFITTtHQUE0QztZQUNqREUsV0FBV0YsR0FBR0MsR0FBR1A7SUFBTyxPQUFBLG1DQUFWTyxHQUFIRCxHQUFNTjtHQUF1QztZQUN4RFMsS0FBS0gsR0FBR0MsR0FBSSxPQUFBLG1DQUFKQSxHQUFIRCxHQUEyQjtZQUNoQ0ksTUFBTUosR0FBR0MsR0FBSSxPQUFBLG1DQUFKQSxHQUFIRCxHQUE0QjtZQUNsQ0ssSUFBSUwsR0FBR0MsR0FBSSxPQUFBLG1DQUFKQSxHQUFIRCxHQUEwQjtZQUM5Qk0sS0FBS04sR0FBR0MsR0FBSSxPQUFBLG1DQUFKQSxHQUFIRCxHQUEyQjtZQUNoQ08sWUFBWVAsR0FBRzNKO0lBQVUsT0FBQSxtQ0FBVkEsU0FBSDJKO0dBQWtEO1lBRTlEUSxLQUFLUixHQUFFL0csR0FBRXdIO0lBQ1g7S0FBSUMseUJBREdWLEdBQUUvRyxPQUFBQTtLQUVMMEgseUJBRkdYLEdBQUlTLE9BQUFBO0lBQUpULE1BQUUvRyxLQUVMMEg7SUFGR1gsTUFBSVMsS0FDUEM7SUFHSjtHQUFvQjs7OztPQTdEbEIvQzs7T0F1QkFzQjtPQUVBQztPQUtBRTtPQU1BQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUlBQztPQUNBRztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQzs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7SUM1REFoRDtJQUNBb0Q7SUFDQUM7WUFDQUMsWTtZQUNBQyxtQjtHQUFnQixJQUNoQkM7WUFLQUMsVUFBVWhJO0lBQUksZUFBSkEsdUJBQUFBOztHQUFzQjs7Ozs7O1lBR2hDaUksT0FBT2pJLEdBQUksT0FIWGdJLFVBR09oSSxTQUFBQSxPQUF3RDtZQUUvRGtJLFdBQVdsSTtJQUNiLE9BTkVnSSxVQUtXaEksS0FBQUEsSUFHUixXQWxCSHVFLGdCQWVXdkU7R0FHcUQ7WUFHaEUzQyxNQUFPOEssSUFBV0MsSUFBSyxPQUFoQkQsT0FBV0MsV0FBcUI7Ozs7T0FyQnZDN0Q7T0FDQW9EO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BS0FDOzs7T0FHQUM7T0FFQUM7T0FNQTdLOzs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztJQ2ZBZ0w7SUFDQUM7WUFDQUMsYztZQUNBQyxjO0dBQVcsSUFDWEMsc0JBQ0FDO1lBQ0FDLFU7Ozs7T0FOQU47T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUNaQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFJQUMsT0FBT2xDLEdBQUdDLEdBQUksT0FBQSxrQ0FBSkEsR0FBSEQsR0FBNEI7WUFDbkNtQyxXQUFXQyxJQUFHQyxJQUFJcEM7SUFBSSxPQUFBLGtDQUFKQSxHQUFQbUMsSUFBR0M7R0FBa0M7WUFDaER0QyxLQUFLQyxHQUFHTixNQUFNTztJQUFJLE9BQUEsa0NBQUpBLEdBQU5QLE1BQUhNO0dBQTJDO1lBQ2hEc0MsU0FBU0YsSUFBR0MsSUFBSTNDLE1BQU1PO0lBQUksT0FBQSxrQ0FBSkEsR0FBTlAsTUFBUDBDLElBQUdDO0dBQWlEO1lBQzdERSxRQUFRdkMsR0FBR0MsR0FBSSxPQUFBLGtDQUFKQSxHQUFIRCxHQUE2QjtZQUNyQ3dDLFlBQVlKLElBQUdDLElBQUlwQztJQUFJLE9BQUEsa0NBQUpBLEdBQVBtQyxJQUFHQztHQUFtQztZQUNsRGxDLEtBQUtILEdBQUdDLEdBQUksT0FBQSxrQ0FBSkEsR0FBSEQsR0FBMEI7WUFDL0J5QyxTQUFTTCxJQUFHQyxJQUFJcEM7SUFBSSxPQUFBLGtDQUFKQSxHQUFQbUMsSUFBR0M7R0FBZ0M7WUFDNUNLLFlBQVkxQyxHQUFHQyxHQUFJLE9BQUEsa0NBQUpBLEdBQUhELEdBQXlCO1lBQ3JDMkMsYUFBYTNDLEdBQUdDO0lBQUksT0FBQSxrQ0FBSkEsR0FBSEQ7R0FBMEI7WUFDdkM0QyxVQUFVNUMsR0FBR0MsR0FBSSxPQUFBLGtDQUFKQSxHQUFIRCxHQUErQjtZQUN6QzZDLFFBQVE3QyxHQUFHQyxHQUFJLE9BQUEsa0NBQUpBLEdBQUhELEdBQTZCO1lBQ3JDOEMsWUFBWVYsSUFBR0MsSUFBSXBDO0lBQUksT0FBQSxrQ0FBSkEsR0FBUG1DLElBQUdDO0dBQW1DO1lBQ2xEVSxLQUFLQyxHQUFHM007SUFBVSxPQUFBLGtDQUFWQSxTQUFIMk07R0FBMEM7WUFDL0N6QyxZQUFZeUMsR0FBRzNNO0lBQVUsT0FBQSxrQ0FBVkEsU0FBSDJNO0dBQWlEO1lBRTdEQyxJQUNBQztJQURNLEdBQ05BO2lCQUFBQTs7VUFDVUMsaUJBQUw1VCxjQUFMRCxJQURBNFQ7TUFDa0MsT0FBQSxXQXhCbENuQixZQXdCVW9CLFVBQUw1VCxPQUFMRDs7O0lBRHVCLE9BQXZCNFQ7R0FDMEM7WUFHMUNoRCxXQUFXOEMsR0FBRy9DLEdBQUdQO0lBQ25CLE9BRGFzRDtjQW5CWGpELEtBY0FrRCxJQUtXRCxJQUFNdEQsZUFHQzBELEdBQUVDLEdBQUssT0FBQSxXQUhYcEQsR0FHTW9ELEdBQUZELEdBQVk7Y0FIYjFEO0dBRzRCOzs7O09BaEM3Q21DO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BSUFDO09BQ0FDO09BQ0FwQztPQUNBdUM7T0FDQUM7T0FDQUM7T0FDQXJDO09BQ0FzQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBeEM7T0FFQTBDO09BS0EvQzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7OzthQ0hFb0QsZUFBZTVGLFVBQU8sT0FBUEEsRUFBUTs7S0FDdkI2RjtLQUNBQztLQUNBQztLQUNBQzthQUNBQyxPQUFPMUQsR0FBRXZDLEdBQUVwTztLQUFJLE9BQWdCLFdBSi9CaVUsZUFJUzdGLEdBQXNCLFdBQXhCdUMsR0FBSTNRO0lBQXlCO3VCO0lBSWxCLFNBQWxCc1UsNEIsT0FKQUQ7SUFJa0I7SUFDRCxTQUFqQkUsMkIsT0FMQUY7d0JBUUsscUJBRVE7SUFGZixTQURFRywyQixPQVBBSDthQWFBSSxvQkFBb0JyRyxHQUFFcE87S0FBSSxPQUFrQixXQWhCNUNrVSxpQkFnQm9COUYsR0FBd0IsNEJBQXRCcE87SUFBaUQ7YUFFdkUwVSxpQkFBaUJDLGdCQUFldkc7SyxZQUN4QixPQUFBLFdBcEJSNkYsZUFtQmdDN0Y7U0FFM0JwTztLQUFLLE9BQUEsV0FGTzJVLGdCQUVRLFdBckJ6QlYsZUFtQmdDN0YsT0FFM0JwTzs7YUFTTDRVLGVBQWVELGdCQUFlRSxLQUFFQztLQUtsQztNQVh5Q0MsTUFXakMsV0FuQ05kLGVBOEI4QlksS0FLUiwwQkFMVUM7TUFOTzFHLElBQUEyRztNQUFFQyxPQU1URjtLQUxsQztXQUQyQ0UsTUFFbkMsT0FGaUM1RztNQUdPO09BSEw2RyxTQUFBRDtPQUd6Q2hWLElBSHlDZ1Y7T0FBRkUsTUFHTyxXQUcvQlAsZ0JBTndCdkcsR0FHdkNwTztNQUh1Q29PLElBQUE4RztNQUFFRixPQUFBQzs7SUFhMUM7YUFHQ0UsaUJBQWlCUixnQkFBZXZHLEdBQUVwTztLQUFJO2lDQUFKQTs7O1dBQUFBO3lEQUFBQSxLQUFBQTtLQUFxQixPQUFBLFdBQXRDMlUsZ0JBQWV2RztJQUEwQzthQUMxRWdILHFCQUFxQlQsZ0JBQWV2RyxHQUFFcE8sR0FBSSxrQkFBckIyVSxnQkFBZXZHLEdBQUVwTztJQUF1QjthQVU3RHFWLHVCQUF1QlYsZ0JBQWVFLEtBQUVTO0tBQzFDO01BVDhDUCxNQVk1QyxXQXZEQWQsZUFtRHNDWSxLQUFFUztNQVJJbEgsSUFBQTJHO01BQVFwTDtLQUN0RDtTQURzREEsTUFRWjJMLGtCQU5yQyxPQUZ5Q2xIO01BSXBDO09BQUptSCxJQUlvQ0QsVUFSWTNMO09BQUE2TCxNQUtlLDZCQUxmN0w7T0FBUnVMLE1BS0osV0FHakJQLGdCQVJxQnZHLEdBSXhDbUg7TUFKd0NuSCxJQUFBOEc7TUFBUXZMLElBQUE2TDs7SUFjbkQ7YUFLREMsZUFBZXpWO0tBQ2pCO01BQXFELE1BQUE7TUFBakMsTUE5Q2xCeVUsb0JBOEN1Qyw2QkFEeEJ6VTtLQUNHLE9BQUE7SUFBb0Q7YUFHdEUwVixXQUFXMVY7S0FBSTtNQUFpRCxNQUFBO01BQTdCLE1BQUEsV0FqRW5Da1UsaUJBaUVvRCw2QkFBekNsVTtLQUF3QixPQUFBO0lBQWdEO2FBQ25GMlYsV0FBVzNWO0tBQUk7TUFBaUQsTUFBQTtZQS9EaEVxVSxZQStEb0QsNkJBQXpDclU7S0FBd0IsT0FBQTtJQUFnRDthQUNuRjRWLFVBQVU1VjtLQUFJO01BQWdELE1BQUE7WUFoRTlEcVUsWUFnRWtELDZCQUF4Q3JVO0tBQXdCLE9BQUE7SUFBK0M7YUFDakY2VixTQUFTN1Y7S0FBSTtNQUErQyxNQUFBO01BQTNCLE1BQUEsV0FyRWpDaVUsZUFxRWdELDZCQUF2Q2pVO0tBQXdCLE9BQUE7SUFBOEM7YUFDL0U4VixVQUFVOVY7S0FBSTtNQUFnRCxNQUFBO1lBbEU5RHFVLFlBa0VrRCw2QkFBeENyVTtLQUF3QixPQUFBO0lBQStDO2FBRWpGK1YsWUFBWS9WO0tBQ2Q7TUFBa0QsTUFBQTtNQUE5QixNQUFBLFdBdEVsQm9VLGtCQXNFb0MsNkJBRHhCcFU7S0FDTSxPQUFBO0lBQWlEO2FBR25FZ1csV0FBV2hXO0tBQUk7TUFBaUQsTUFBQTtNQUE3QixNQUFBLFdBMUVuQ21VLGlCQTBFb0QsNkJBQXpDblU7S0FBd0IsT0FBQTtJQUFnRDthQUNuRmlXLFVBQVVqVztLQUFJLElBQWdELE1BQUEsd0JBOUUvQ29PLElBOEVtQztLQUFoQixPQUFBLG9CQTlFbkJBO0lBOEVrRTtJQW5GNUM7WUF1QnJDcUc7WUFoQkFQO1lBT0FJO1lBQ0FDO1lBVEFOO1lBV0FPO1lBUkFKO1lBREFEO1lBSEFIO1lBb0JBVTtZQVdBRTtZQVVBTztZQUNBQztZQVVBQztZQVdBSTtZQUlBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUVBQztZQUlBQztZQUNBQzs7Ozs7Ozs7Ozs7OzthQVlBckcsT0FBUXNHO0tBQVUsT0FBWSxrQkFBdEJBLE1BQXNCO0lBQVU7YUFDeENDLFFBQVFDLGFBQVkxRjtLQUFJLE9BQWU7OEJBQUEsV0FBL0IwRixhQURSeEcsY0FDb0JjO0lBQThDOzthQUlsRTJGLElBQUtILE1BQUtJLFFBQU90VztLQUNuQjtNQUE4QyxNQUFBO01BQTFCLE1BQUEsV0FEUnNXLFFBQ2dCLG9CQURyQkosWUFBWWxXO0tBQ0MsT0FBQTtJQUE2QztJQVh0Qzs7Ozs7Ozs7OztZQUt6QjRQO1lBQ0F1Rzs7WUFJQUU7O3lCQWlDVyxTQUFlO2tCQUNsQkUsS0FBVTdGO0lBQUssR0FBZjZGLFNBQU9DLE1BQVBELFFBQUFMLE9BQU9NLGNBQVBOO0lBQWUsT0FBZkE7R0FBaUM7T0FHdkNPO1lBQ0FDLGdCQUFpQkMsT0FBaUIsT0FBQSx5QkFBakJBLE9BQTZDO0dBRmpELG9CQUNiRixlQUNBQztZQVNGOUcsT0FBUXNHLGFBQVUsYUFBVkEsU0FBZ0M7WUFDeENHLElBQUtILE1BQUtJLFFBQU90VztJQUFJLE9BQUE7YUFBZSxXQUExQnNXLGNBQUxKLFVBQVlsVztHQUFzRDtZQUN2RW1XLFFBQVFDLGFBQVkxRjtJQUFJLE9BQUE7YUFBZSxXQUEvQjBGLGFBRlJ4RyxjQUVvQmM7R0FBOEM7Ozs7Ozs7VTs7O1U7OztVOzs7VTs7Ozt1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFXaEVrRjtZQWFnQkMsU0FBVW5GO0lBQzVCO0tBQWlCLE1BQUEsOEJBRFdBO0tBQ3BCLE1BQUEsOEJBRG9CQTtLQUN4QmtHLE1BQUk7S0FDTyxNQUFBLDhCQURYQTtLQUNBQyxNQUFJLDhCQURKRDtLQUVvQixNQUFBLDhCQURwQkM7S0FDUSxNQUFBLDhCQURSQTtLQUNJLE1BQUEsNkJBREpBO0tBQ0FDLE1BQUk7S0FDTyxNQUFBLDhCQURYQTtLQUNBQyxNQUFJLDhCQURKRDtLQUVvQixNQUFBLDhCQURwQkM7S0FDUSxNQUFBLDhCQURSQTtLQUNJLE1BQUEsNkJBREpBO0tBQ0FDLE1BQUk7S0FDTyxNQUFBLDhCQURYQTtLQUNBQyxNQUFJLDhCQURKRDtLQUVBLE1BQUEsOEJBREFDO0lBQ0EsT0FBQSw2QkFEQUE7R0FDVTtZQUdabkIsVUFBVTlWLEdBQUksT0FBSkEsVUFBc0I7WUFJaENpVyxpQkFBZSxTQUFDOzs7Ozs7O1E7OztROzs7UTs7O1E7Ozs7cUI7O09BeENsQnJHO09BRUF1Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVdFUDtRQWFnQkM7UUFVaEJDOztzQjtRQUlBRztPQXZDRkk7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDakxGeEk7Ozs7Ozs7Ozs7Ozs7WUFNQXFKLGlCQUFrQkM7SUFDcEIsT0FBQSxtREFEb0JBO0dBSVQ7WUFHVEMsZUFBZ0JEO0lBQ2xCLE9BQUEsbURBRGtCQTtHQUlQO0dBTU87SUFBQTtJQTBCTDtJQTJCVEU7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUM7STs7O0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLGNBQWNDLGFBQVlqRSxHQUFFQztJQUM5QixHQUFHLFdBdkZIbEcsWUFzRjRCaUcsR0FBRUMsSUFFekI7SUFHSDtLQURJaUUsUUFKc0JsRTtLQUt0Qm1FLFFBTHdCbEU7S0FNeEJtRSx1QkFGQUYsT0FDQUM7SUFFSixTQURJQyxLQUVDLE9BRkRBO1FBSVd2TztJQUNYO1FBRFdBLE1BTlhxTyxPQVFLO0tBRUssSUFBSnRFLElBZGdCSSxNQVVYbkssSUFLTHdPLElBZmtCcEUsTUFVYnBLLElBTUxpSyxNQUFNLFdBaEJGbUUsYUFjSnJFLEdBQ0F5RTtLQUVKLFNBREl2RSxLQUNhLE9BRGJBO0tBQzJCLElBUHRCNEIsTUFPc0IsNkJBUHRCN0w7S0FBQUEsSUFBQTZMOztHQVNMO1lBR040QyxhQUFhTCxhQUFZakUsR0FBRUM7SUFDakMsSUFEK0JzRSxNQUFBdkUsR0FBRXdFLE1BQUF2RTtJQUNqQztVQUQrQnNFLFlBQUVDO1VBQUFBLEtBSXRCO0tBRUM7TUFOcUJDLEtBQUFEO01BS3RCclksSUFMc0JxWTtNQUFGRSxLQUFBSDtNQUs3QnJZLElBTDZCcVk7TUFNekJ6RSxNQUFNLFdBTk9tRSxhQUtqQi9YLEdBQVNDO0tBRVQsU0FESTJULEtBQ2EsT0FEYkE7S0FOeUJ5RSxNQUFBRztLQUFFRixNQUFBQzs7R0FPeUI7WUFHeERFLGVBQWVWLGFBQVlqRSxHQUFFQztJQUMvQixLQUQ2QkQsVUFBRUM7UUFLeEJzRSxNQUxzQnZFO1NBQUVDLEdBSWI7UUFDSHVFLE1BTGdCdkU7SUFLWCxPQUFBLFdBTEhnRSxhQUtWTSxLQUFRQztHQUFvQjtZQUdqQ0ksWUFBWVgsYUFBWWpFLEdBQUVDO0lBQUksa0JBQWxCZ0UsYUFBWWpFLE1BQUVDO0dBQXFCO1lBQy9DNEUscUI7WUFDQUMscUI7WUFDQUMsb0I7O0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBQ0FDLHFCO1lBR0FDLFlBQVluWixHQUFFQyxHQUFJLDBCQUFORCxHQUFFQyxpQkFBbUM7WUFFakRtWixZQUFZQyxXQUFVdkYsR0FBRUM7SUFDMUIsVUFBQSxXQTVJQWxHLFlBMkl3QmlHLEdBQUVDO0lBQzFCOzs7S0FHQTtNQURJaUUsUUFIb0JsRTtNQUlwQm1FLFFBSnNCbEU7WUFHdEJpRSxVQUNBQzs7VUFHU3RPO01BQ1g7aUJBRFdBLE1BSlRxTzs7OztRQU9NLElBQUp0RSxJQVZrQkksTUFPWG5LLElBSVB3TyxJQVhvQnBFLE1BT2JwSyxJQUtYLE1BQUEsV0FaWTBQLFdBVVIzRixHQUNBeUU7UUFDSjtTQUFzQixJQUxYM0MsTUFLVyw2QkFMWDdMO1NBQUFBLElBQUE2TDs7Ozs7Ozs7OztJQU5iO0dBYU07WUFHQThELFdBQVdELFdBQVV2RixHQUFFQztJQUM3QixJQUQyQnNFLE1BQUF2RSxHQUFFd0UsTUFBQXZFO0lBQzdCO1FBRDJCc0U7U0FBRUM7T0FJUDtRQUpPQyxLQUFBRDtRQUlsQnJZLElBSmtCcVk7UUFBRkUsS0FBQUg7UUFJekJyWSxJQUp5QnFZO1FBSUwsTUFBQSxXQUpMZ0IsV0FJZnJaLEdBQVNDO09BQVcsVUFBQTtPQUpLb1ksTUFBQUc7T0FBRUYsTUFBQUM7Ozs7ZUFBQUQsS0FFakI7S0FDTzs7R0FDOEM7WUFHL0RpQixhQUFhRixXQUFVdkYsR0FBRUM7SUFDM0IsR0FEeUJEO1FBQUVDO1VBSVp1RSxNQUpZdkUsTUFJcEJzRSxNQUprQnZFO01BSUwsT0FBQSxXQUpMdUYsV0FJUmhCLEtBQVFDOzs7Y0FKWXZFLEdBRVg7SUFDaUI7R0FDQTtZQUcvQnlGLFVBQVVILFdBQVV2RixHQUFFQztJQUFJLGtCQUFoQnNGLFdBQVV2RixNQUFFQztHQUFtQjs7OztPQTFLM0NsRztPQU1BcUo7T0FPQUU7Ozs7UUErREVDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBc0JJTTtRQVVKSztRQVFBQztRQUNBQztRQUNBQztRQVNBTztRQVJBTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUtBRTtRQWlCSUU7UUFPSkM7UUFPQUM7Ozs7RTs7Ozs7O0dDM0tPOztJQUFBO0lBTUs7Ozs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0dWelMsUUFDRDBTLE9BQVFDO0lBQ1YsR0FBRyxvQ0FEREQsT0FBUUMsUUFFTDthQUZIRDtTQUtPRSxRQUxQRjtjQUFRQyxVQU1PO1NBRE9FLFFBTGRGO0tBSzBCLE9BQUEsdUNBQTNCQyxPQUFlQzs7UUFHZkMsUUFSUEo7YUFBUUMsVUFPTztRQUNPSSxRQVJkSjtJQVEwQixPQUFBLHdDQVRqQzNTLFNBU004UyxPQUFlQztHQUFtRDs7SUFJdkUxRDtJQWFKMkQ7O0tBYkkzRDtjQUNGNEQsS0FBSUM7TUFDTixTQURNQTtPQUdNLElBRExDLEtBRkRELFFBSUFFLFFBRE0seUJBSFZIO09BS0EsT0FBQSw2QkFESUcsT0FGQ0Q7O01BS0ssSUFETEUsT0FOREgsUUFRQUksUUFETSx5QkFQVkw7TUFTQSxPQUFBLDhCQVZFNUQsYUFTRWlFLE9BRkNEO0tBRzZCOztLQUdwQ0w7Y0FNQ0U7TUFBSztPQUhBRCxNQUFNO09BQ1YsTUFBQSxXQWpCRTVELGFBZ0JFNEQsS0FHTEM7TUFGQyxPQUFBO0tBRVU7T0FLYks7WUFFQUMsaUJBQW9CLFNBQUU7Ozs7T0ExQmpCbkU7T0FhSjJEOzs7O09BMUJHaFQ7Ozs7Ozs7Ozs7Ozs7OztPQXFDSnVUO09BRUFDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7OztZQ3pDQUMsaUJBQ0QseUJBRWtDO1lBTWpDQyxnQkFBVyx1QkFFRjtHQUZFO0lBQUE7O0lBS1hDOzs7MEJBSUs7eUJBbEJMRixXQVNBQyxVQUtBQzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0NwQkk7Ozs7SUFBSnZDOztZQUNBd0MsV0FBUyxPQURUeEMsS0FDVztZQUNYeUMsU0FBU0MsR0FGVDFDLFdBRVMwQyxHQUZUMUMsZ0JBRXlCOztRQUszQjJDO0lBTEVGLFNBZ0JnQjtJQUhwQixXQVJFRTs7Ozs7T0FORUg7O1lBdUJBSTtpQkFNSUQsR0FBR0UsV0FBVXRLO1NBQTBDLFVBQUEsaUJBQTFDQTtTQUEwQyxPQUFBLDhCQUFwRHNLO1FBQW1FO21DQUF0RUYsSUFOSkM7O3FCO09BdEJBSDs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0NNSjs7SUFxR1FHOzs7Ozs7Ozs7O0lBM0dKUDtJQUlBaGE7SUFFSjs7O0dBR0U7Ozs7OztNQUFzRTtPQUs3RCxNQUFBO01BSFk7T0FESXlhO09BQVpDO09BQ0xDLFdBQWEsV0FYbkJYLFdBVVdVO09BRUxFLFdBQWEsV0FabkJaLFdBVXVCUztNQUdyQix3QkFGSUUsY0FDQUM7S0FFYztHQUt4QjtJQUFBOzs7R0FHRTs7Ozs7O01BQXVFO09BTTlELE1BQUE7TUFKWTtPQURLQztPQUFaQztPQUNOQyxXQUFhLDZCQURQRDtPQUVORSxXQUFhLFdBekJuQmhCLFdBdUJ3QmE7TUFHdEIsd0JBRklFLGNBQ0FDO0tBR2M7R0FLeEI7SUFBQTs7R0FZRTs7Ozs7O01BQW1FO09BSS9ELE1BQUE7VUFISzlLO01BQUssT0FBTEE7S0FHUTs7WUFHZitLLFNBQVNDLE1BQU8saUJBQVBBLE1BQWdCO1lBRXpCQyw4QkFBOEJqTCxHQUFFa0w7SUFDbEMsbUNBRGdDbEwsR0FBRWtMO0lBQ2xDLE1BQUEsNEJBRGdDbEw7R0FDYztZQUs1Q21MLFFBQVFDLEtBQUlDO0lBQ0gsSUFBUEMsc0JBRFVELEtBQUpEO0lBRVAsS0FBQSx5Q0FGT0E7S0FNTCxNQUFBLDRCQUxERTtJQUdPLElBQUxDLEtBQUs7SUFDVCxPQVhBTiw4QkFPRUssT0FHRUM7R0FFUztZQUdiQyxTQUFTQyxLQUFJQztJQUFTLE9BQUE7O3NCQUFxQkwsWUFBVSxPQVRyREYsUUFTU00sS0FBa0NKLEtBQXlCO2FBQXZESztHQUErRDtZQUM1RXBLLFVBQVVtSztJQUFtQyxVQUFBLDZCQUFuQ0E7SUFBbUMsT0FBQTtHQUFpQjtZQUM5REUsZUFBZUY7SUFBMEIsVUFBQSw2QkFBMUJBO0lBQTBCLE9BQUE7R0FBaUI7T0FDMURHO1lBRUFDLFNBQVU1TCxHQUFFM1EsR0FBSXdjO0lBQ2xCLElBQU0sSUFDSjVJLE1BREksV0FETWpELEdBQUUzUTtVQUtGZ2M7S0FDRDtNQURDRiwwQkFBQUU7TUFDTkMsS0FBSztLQUNULElBQU8sV0FQU08sV0FBSnhjO1dBU0N5YztVQUFBQyxnQ0FBQUQ7TUFFVixPQS9CSGQsMkNBeUJVRyxLQUlHWSxZQUhUVDs7S0FFSyxPQTVCVE4sOEJBeUJVRyxLQUNORzs7SUFISixXQUhnQk8sV0FBSnhjO0lBR1osT0FEQTRUO0dBUytEO1lBRy9EK0ksUUFBU2hNLEdBQUc2TCxXQUFVLE9BZHRCRCxTQWNTNUwsTUFBRzZMLFdBQWlDO1lBRTdDSSxXQUFxQmpNO0lBQ3ZCLElBQ1UsV0FGYUEsT0FHckIsYUFBQSx1QkFFSztHQUFJO1lBTUxtSyxHQUFHK0IsS0FBSW5NO0lBQ0gsWUFBQSw2QkFER0E7O1NBRUZnTDtLQUFRLE9BQUEsMEJBRlZtQixLQUVFbkI7O0lBQ21DLFVBQUEsK0JBSGpDaEw7SUFHaUMsT0FBQSw4QkFIckNtTTtHQUdnRTs7cURBSG5FL0IsSUFNQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUdKK0IscUJBQXFCWCxLQUFJWTtJQUMzQiwwQ0FEdUJaO0lBRXBCLEdBQUE7S0FDRSxxREFIc0JZOztHQUlMO1lBT3BCQyxvQkFBcUI1YyxZQUFZSSxNQUFLbVE7SUFDeEMsSUFBSSxVQUFBLFdBRG9DQSxPQUNwQztVQUNGc007S0FDb0I7TUFEcEJkLDBCQUFBYztNQUNJRixnQkFBZ0I7S0FLcEIsR0FScUIzYyxZQVNoQixJQUNDO0tBRU4sSUF2QkEwYyxxQkFhQVgsS0FDSVk7Z0JBV0QsSUFDRztLQUdOLE9BQUEsV0FsQmlDdmM7O0dBa0IzQjtZQUdOMGMseUJBQXlCdk07SUFBSSxPQXJCN0JxTSx1QkFySEF4YyxNQTBJeUJtUTtHQUFnRDtZQUV6RXdNLGdCQUFzQkMsV0FBVXpNO0lBQ2xDLElBN0lFME0sU0E0SXNCRCxZQTVJdEI1YyxxQjtJQTZJRixPQXhCRXdjLG9CQXVCc0JJLFdBNUl0QkMsUUE0SWdDMU07R0FDb0Q7WUFHcEYyTSxpQkFBaUJ2QixLQUFJd0I7SUFDdkIsSUFBSSxVQUFBLFdBRG1CQSxVQUNuQjtVQUNGdkI7S0FDUztNQURURiwwQkFBQUU7TUFDSUMsS0FBSztLQUNULE9BbEdBTiw0Q0E4RmlCSSxLQUVqQkQsTUFDSUc7O0dBQ2tEO1lBS3REdUIsd0JBQXdCakk7SUFHMUI7SUFDQSxNQUowQkE7R0FJTjtZQUdsQmtJO0lBQXVCLHVDQXREdkJYO0dBc0R3RDtZQUd0RFk7STs7R0FEVztJQUFBLGNBQ1hBOzs7T0EvRkZwQjs7OztPQXBCQWI7T0F5R0ErQjtPQXZHQTdCO09BTUFFO09BU0FLO09BQ0FsSztPQUNBcUs7T0FHQUU7T0FjQUk7T0F3REFRO09BRkFEO09BTUFJO09BMURBVjtxQjtPQTBFQWE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7OztZQ2xLQUUsWUFBcUJoTjtJQUN2QjtLQUdFO0tBR0VpTjthQUNBQyxTQUFPL0o7S0FDVCxPQUZFOEo7TUFHRztLQUN1QixPQUFBLG9DQUhuQjlKO0lBRytCO0lBRTFDLElBQ1UsSUFBSnVFLE1BQUksV0FkYTFILEdBUW5Ca04sV0FEQUQsaUJBU0YsT0FGSXZGO1VBSUoyRDtTQUFBRiwwQkFBQUU7S0FYRTRCO1FBV0Y5QixtQkFJUSxNQUFBLDRCQUpSQTtTQUdZaEksSUFIWmdJO0tBR2lCLE9BQUxoSTs7R0FDTTtZQUdsQmdLLG1CQUFtQm5OO0lBQ3JCLE9BMUJFZ047c0JBMEJlRTtjQUNmLFdBRm1CbE4sWUFFRG1ELEdBQUssT0FBYyxXQUR0QitKLGNBQ0cvSixJQUEyQjtjQUE3QzthQUNJO0dBQUM7WUFHTGlLLFFBQVVDLE9BQVVyTjtJQUFlLGdCQUFLM1EsR0FBSyxPQUFPLFdBQTFDZ2UsT0FBMEMsV0FBaENyTixHQUFvQjNRLElBQWlCOzs4QkEvQnpEMmQsYUF5QkFHLG9CQU1BQzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0tDMkRNRTtLQUFBQzs7S0FBQUM7S0FBQU47S0FBQTlNO0tBQUFxTjtLQUFBQztLQUFBMUQ7S0FBQTJEOztJQStNa0Q7WUEvTWxETDtZQUFBQzs7O1lBQUFDO1lBQUFOO1lBQUE5TTtZQUFBcU47WUFBQUM7WUFBQTFEO1lBQUEyRDs7OztLQW1EQUw7S0FBQUM7OztLQUlSQztLQUNBTjtLQUNBOU07S0FDQXFOO0tBQ0FDO0tBQ0ExRDtLQUNBMkQ7SUF3SnNFO1lBbEs5REw7WUFBQUM7OztZQUlSQztZQUNBTjtZQUNBOU07WUFDQXFOO1lBQ0FDO1lBQ0ExRDtZQUNBMkQ7Ozs7S0E3RFFMO0tBQUFDOztLQUFBQztLQUFBTjtLQUFBOU07S0FBQXFOO0tBQUFDO0tBQUExRDtLQUFBMkQ7O0lBMk5vRTtZQTNOcEVMO1lBQUFDOzs7WUFBQUM7WUFBQU47WUFBQTlNO1lBQUFxTjtZQUFBQztZQUFBMUQ7WUFBQTJEOzs7O0tBbURBTDtLQUFBQzs7O0tBSVJDO0tBQ0FOO0tBQ0E5TTtLQUNBcU47S0FDQUM7S0FDQTFEO0tBQ0EyRDtJQW9LNEQ7WUE5S3BETDtZQUFBQzs7WUFJUkM7WUFDQU47WUFDQTlNO1lBQ0FxTjtZQUNBQztZQUNBMUQ7WUFDQTJEOzs7OztLQW9EUUw7S0FBQUM7OztLQUlSQztLQUNBTjtLQUNBOU07S0FDQXFOO0tBQ0FDO0tBQ0ExRDtLQUNBMkQ7SUE0R3dFO1lBdEhoRUw7WUFBQUM7OztZQUlSQztZQUNBTjtZQUNBOU07WUFDQXFOO1lBQ0FDO1lBQ0ExRDtZQUNBMkQ7Ozs7S0F1RVFMO0tBQUFDOzs7S0FJUkM7S0FDQU47S0FDQTlNO0tBQ0FxTjtLQUNBQztLQUNBMUQ7S0FDQTJEO0lBa0NGO1lBNUNVTDtZQUFBQzs7O1lBSVJDO1lBQ0FOO1lBQ0E5TTtZQUNBcU47WUFDQUM7WUFDQTFEO1lBQ0EyRDs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7OztRQ3ZSSUgsZUFDQU47YUFDQVUsYUFBYUMsSUFBSTdOO0tBQUksT0FBYTs7Y0FBckI2Tjt1QkFBMEIxSztlQUFjLFVBQUEsV0FBcENuRCxHQUFzQm1EO2VBQWMsT0FBQTtjQUFLO0lBQUM7OztTQUUzRC9DLE1BRkF3Tjs7U0FLUXZlLGNBSFIrUSxNQUdRL1E7YUFJTmllLFlBQVF2TixHQUFFQyxHQUFJLE9BQUEsV0FYaEJ3TixNQVdVek4sR0FBRUMsR0FBYTthQUN2QnVOLFdBQVF4TixHQUFFQyxHQUFJLE9BQUEsV0FSaEJJLEtBUVVMLEdBQUVDLEdBQVk7SUFGUDtLQUFBLGtCQUNmc04sYUFDQUM7S0FEQU87S0FDQUM7S0FEQUM7S0FDQUM7YUFjRUMsS0FBSy9LLEdBQUVDO0tBQUksT0FBTTtjQWZuQjRLO2NBZU83Szt1QkFBZ0JBO2VBQUssT0FBTTt3QkFkbEM4SyxjQWNTN0ssWUFBNkJBLEdBQUssV0FBcEJELEdBQWVDLEdBQVM7Y0FBQTtJQUFBO0lBRTVCO0tBQUE7S0FOSCxpQkFyQmxCOEosVUFEQU0sTUFJQXBOLEtBc0JJOE47S0FUWSxtQkFoQmhCaEIsVUFVRWMsZUFDQUM7YUFvQkZSLEtBQUsxTjtLQUFJLE9BQU0sV0FyQmIrTixlQXFCRy9OLFlBQWNBLEdBQU0sT0FBTkEsRUFBUTtJQUFBO2FBQzNCMk4sU0FBUzNOO0tBQUksT0FBUyxXQTdCdEJLLEtBNkJTTCxtQkFBdUIsU0FBRTtJQUFDO2FBRzdCb08sS0FBS0M7SyxZQUNJLE9BQUEsV0FwQ2ZsQixVQW9DZSwyQkFESmtCO1NBRUpDLGVBQUx0TztLQUFpQixPQUFBO2NBM0JqQitOLGVBMkJBL04sWUFBcUJ1TyxHQUFLLE9BRnRCSCxTQUVpQkcsR0FGWkYsS0FFSkMsSUFBc0M7O2FBSDdDckUsSUFLRXFFLElBQU0sT0FKRkYsUUFJSkUsSUFBZ0I7YUFHZFY7S0FBVyxZQUNULE9BQUEsV0EzQ05UO1NBNENLbUIsZUFBTHRPO0tBQWlCLE9BQUE7Y0FsQ2YrTixlQWtDRi9OLG1CQUEyQixPQUZ2QjROLFNBRUNVLElBQWlDO0lBQUE7SUE5Q0Y7WUFDcENiO1lBQ0FOOztZQUdBOU07O1lBT0UwTjtZQUNBQzs7WUFvQkZOO1lBQ0FDO1lBRUExRDtZQVFJMkQ7Ozs7Ozs7O0lBT2lEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBT3pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTW9FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTWY7Ozs7Ozs7Ozs7Ozs7O2FBeUIvQ1QsU0FBTy9KO0tBQWUsVUFBQSxxQkFBZkE7S0FBZSxPQUFBO0lBQWdCO2FBQ3RDcUssS0FBS3pOLEdBQUdDO0tBQUk7TUFBdUIsTUFBQSxpQkFBOUJEO01BQWtCO1FBQUE7OzttQkFBbUNvRDtXQUFnQixVQUFBLFdBQWxFbkQsR0FBa0RtRDtXQUFnQixPQUFBO1VBQUs7S0FBeEQsT0FBQTtJQUEwRDtJQUMzRTtLQUFOL0M7OztpQkFBbUJMLEdBQUdDO1NBQUssSUFBc0IsTUFBQSxpQkFBOUJELElBQW1CLE1BQUEsMEJBQWhCQztTQUFnQixPQUFBO1FBQTZCO0lBTDNELHdCQUlSd04sTUFDQXBOLEtBRkE4TTs7WUF1RkVNLEtBQUtySyxHQUFHbkQsR0FBSSxPQUFBLFdBQUpBLEdBQUhtRCxHQUFVO1lBQ2YrSixTQUFPL0osR0FBSSxPQUFKQSxFQUFLO0dBQ047SUFBTi9DLCtCQUFtQitDLEdBQUduRCxHQUFLLE9BQUEsV0FBTEEsR0FBSG1ELEdBQVc7dUJBRjlCcUssTUFDQU4sVUFDQTlNO0lBbEhnQmtOO0lBQUFDOztJQUFBZ0I7SUFBQUM7SUFBQUM7SUFBQWhCO0lBQUFDO0lBQUExRDtJQUFBMkQ7O0lBMEdYOztPQTFHV0w7T0FBQUM7O09BQUFnQjtPQUFBQztPQUFBQztPQUFBaEI7T0FBQUM7T0FBQTFEO09BQUEyRDs7Ozs7Ozs7OztTQTJGUGU7U0FDQUM7Ozs7OzBEQURBRCxVQUNBQzs7Ozs7Ozs7Ozs7Ozs7OztTQXBCQ0Q7U0FDQUM7Ozs7OzBEQURBRCxVQUNBQzs7Ozs7Ozs7Ozs7Ozs7OztTQXBCQUQ7U0FDQUM7Ozs7OzBEQURBRCxVQUNBQzs7Ozs7Ozs7Ozs7Ozs7OztTQXBCT0Q7U0FDQUM7Ozs7OzBEQURBRCxVQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDdkhpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1VOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNRTs7Ozs7Ozs7Ozs7Ozs7OzsyQkFTcEU3ZTthQUNBOGUsWUFBWTdPLEdBQUdDO0tBQUksT0FBQSxXQURuQmxRLFFBQ21CLHFCQUFKa1EsSUFBSEQ7SUFBcUI7OztTQUVqQ0ssTUFGQXdPOztTQUtRdmYsY0FIUitRLE1BR1EvUTthQUdSa2UsV0FBUXhOLEdBQUVDLEdBQUksT0FBQSxXQU5kSSxLQU1RTCxHQUFFQyxHQUFZO2FBQ3RCNk8sS0FBS0MsSUFBR0MsSUFBSS9PO0tBQUksT0FBQSxXQVZoQmxRLFFBVWdCLFdBUGhCc1EsS0FPSzBPLElBQU85TyxJQUFKK087SUFBd0I7YUFDaENDLEtBQUtGLElBQUdDLElBQUdFLElBQUlqUDtLQUFJLE9BQUE7Y0FYbkJsUSxRQVdtQixXQVhuQkEsUUFXbUIsV0FSbkJzUSxLQVFLME8sSUFBVTlPLElBQVArTyxLQUFHRTtJQUErQjthQUMxQ2pGLElBQUlxRTtrQkFBMkRoZixHQUFFd1ksSUFBTSxXQUFSeFksR0FBRXdZLElBQWE7S0FBNUMsVUFBQTtLQUFBLE9BQUE7O2NBQTlCd0c7O2VBQTZDLHFCLE9BRmpEUTs7O0lBRWdGO2FBQ2hGWCxLQUFLWSxJQUFHQztLQUFLLE9BSGJGLEtBR0tDLElBQUdDLGFBQXdCNUwsR0FBRUMsR0FBSyxXQUFQRCxHQUFFQyxHQUFTO0lBQUM7YUFDNUM4TCxTQUFPQyxHQUFFYjtLQUFJLE9BQUE7Y0FkYnhlO2NBY2E7Z0JBZGJBO2dCQWNhLHFDQUFlUixHQUFLLE9BQUxBLEVBQU07Z0JBQTNCNmY7Y0FBRWI7SUFBc0M7YUFDL0NjLFNBQU9ELEdBQUViO0tBQUksT0FBQTtjQWZieGU7Y0FlYTtnQkFmYkE7Z0JBZWEsOEJBQVlULFVBQVEsT0FBUkEsRUFBUztnQkFBM0I4ZjtjQUFFYjtJQUFzQzthQUMvQ1gsU0FBU1U7S0FBd0IsVUFBQTtzQ0FBeEJBLFNBRlRhO0lBRXNEO0lBbkJrQjs7WUFNeEU5TztZQVVBOE47WUFiQXBlO1lBZUFzZjtZQURBRjtZQUxBM0I7WUFUQXpkO1lBVUErZTtZQUNBRztZQUNBaEY7WUFJQTJEO2dCQWhCQTdkLFFBZUFzZixVQURBRixVQUxBM0I7Ozs7SUFpQnVFOzs7O0lBTWY7OztJQWV0Qzs7Ozs7Ozs7Ozs7Ozs7O0tBQUE7Ozs7Ozs7Ozs7S0FIRjs7Ozs7Ozs7OztJQUR0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBa0RNemQsT0FETXVmLElBQUdQO0tBQUssT0FBYyxpQkFBdEJPLElBQUdQLGFBQXdCOU8sR0FBRW1ELEdBQUssT0FBQSxXQUFQbkQsR0FBRW1ELEdBQVE7SUFBQzthQUU1Q3lMLFlBQVk3TyxHQUFHQyxHQUFJLE9BRG5CbFEsT0FDbUIscUJBQUprUSxJQUFIRCxHQUFxQjs7O1NBRWpDSyxNQUZBd087O1NBS1F2ZixjQUhSK1EsTUFHUS9RO2FBR1JrZSxXQUFReE4sR0FBRUMsR0FBSSxPQUFBLFdBTmRJLEtBTVFMLEdBQUVDLEdBQVk7YUFDdEJrTyxLQUFLWSxJQUFHQztLQUFLLE9BQWMsaUJBQXRCRCxJQUFHQyxhQUF3QjVMLEdBQUVDLEdBQUssV0FBUEQsR0FBRUMsR0FBUztJQUFDO2FBQzVDNEwsS0FBS0YsSUFBR0MsSUFBR0UsSUFBSWpQO0tBQUksT0FBMkI7O2NBQXRCLGlCQUFuQjhPLElBQUdDLElBQU8vTztjQUFKaVA7dUJBQXdDSyxLQUFJQyxHQUFLLE9BQUEsV0FBVEQsS0FBSUMsR0FBVTtJQUFDO2FBQ2xFdkYsSUFBSXFFO2tCQUEyRGhmLEdBQUV3WSxJQUFNLFdBQVJ4WSxHQUFFd1ksSUFBYTtLQUE1QyxVQUFBO0tBQUEsT0FBQTs7Y0FBOUJ3Rzs7O2VBQTZDLHFCQUFTLE9BQUE7OztJQUFzQjthQUNoRmEsU0FBT0MsR0FBRWI7S0FBSSxPQUFZLGlCQUFsQmEsR0FBRWIsbUJBQXdCaGYsR0FBSyxPQUFMQSxFQUFNO0lBQUM7YUFDeEM4ZixTQUFPRCxHQUFFYjtLQUFJLE9BQVksaUJBQWxCYSxHQUFFYixZQUFxQmpmLFVBQVEsT0FBUkEsRUFBUztJQUFDO2FBQ3hDc2UsU0FBU1U7S0FBd0IsVUFBQTtzQ0FBeEJBLFNBRlRhO0lBRXNEO0lBbkJSOztZQU85QzlPO1lBT0E4TjtZQVZBcGU7WUFjQXNmO1lBREFGO1lBSkEzQjtZQVRBemQ7O1lBV0FrZjtZQUNBaEY7WUFHQTJEO2dCQWZBN2QsUUFjQXNmLFVBREFGLFVBSkEzQjs7OztJQWlCd0Q7Ozs7SUFPMUM7OztRQVNaTDthQUNBc0MsTUFBTUMsSUFBR0M7S0FBSyxPQUFhLGlCQUFyQkQsYUFBMEJ6UCxHQUFLLE9BQUEsaUJBQTVCMFAsSUFBdUIxUCxHQUFnQjtJQUFDO0lBQzNDLElBQU5JO0lBTDJFLGlCQUczRThNLFVBQ0FzQyxPQUNBcFA7Ozs7Ozs7Ozs7Ozs7OztJQUdnRTs7Ozs7Ozs7Ozs7Ozs7O2FBWTlEOE0sU0FBTy9KO0tBQWEsVUFBQSxpQkFBYkE7S0FBYSxPQUFBO0lBQVk7YUFDaENxTSxNQUFNSCxJQUFHTTtLQUFhLFVBQUEsaUJBQWhCTjtLQUFRLE9BQUEsc0JBQUxNO0lBQXFDO2FBQzlDQyxXQUFXN1AsR0FBR0M7S0FBSTtLQUFTLE9BQUE7b0JBQWhCRCxpQiw0QkFBR0M7SUFBeUI7SUFDakM7S0FBTkksc0JBREF3UDt3QkFGQTFDLFVBQ0FzQyxPQUVBcFA7S0EzSGdCb087S0FBQUM7S0FBQVA7S0FBQXBlO0tBQUFvZjtLQUFBRTtLQUFBN0I7S0FBQXNDO0tBQUFoQjtLQUFBRztLQUFBaEY7S0FBQTJEOztJQWtIdUM7WUFsSHZDYTtZQUFBQztZQUFBUDtZQUFBcGU7WUFBQW9mO1lBQUFFO1lBQUE3QjtZQUFBc0M7WUFBQWhCO1lBQUFHO1lBQUFoRjtZQUFBMkQ7Ozs7YUFxSWhCVCxTQUFPL0o7S0FBZ0IsVUFBQSxpQkFBaEJBO0tBQUksV0FBQSxpQkFBSkE7SUFBMEI7YUFDakNxTSxNQUFNSCxJQUFHTTtLQUFLO01BQTRDLE1BQUEsNkJBQWpEQTtNQUF3QyxNQUFBLDZCQUEzQ047TUFBbUMsTUFBQTtNQUFWLE1BQUEsNkJBQXRCTTtNQUFhLE1BQUEsNkJBQWhCTjtLQUFRLFdBQUE7SUFBb0Q7YUFDbEVPLFdBQVc3UCxHQUFHQztLQUFJO01BQTJCLE1BQUEsNkJBQWxDRDtNQUF5QixNQUFBLHNCQUF0QkM7TUFBYSxNQUFBLDZCQUFoQkQ7S0FBTyxXQUFBLHNCQUFKQztJQUFzQztJQUM5QztLQUFOSSxzQkFEQXdQO3dCQUZBMUMsVUFDQXNDLE9BRUFwUDtLQXhJZ0JvTztLQUFBQztLQUFBUDtLQUFBcGU7S0FBQW9mO0tBQUFFO0tBQUE3QjtLQUFBc0M7S0FBQWhCO0tBQUFHO0tBQUFoRjtLQUFBMkQ7O0lBK0h5QztZQS9IekNhO1lBQUFDO1lBQUFQO1lBQUFwZTtZQUFBb2Y7WUFBQUU7WUFBQTdCO1lBQUFzQztZQUFBaEI7WUFBQUc7WUFBQWhGO1lBQUEyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHQzlDTjs7OztJQUFBO0lBd0JoQjNPO0lBQ0FLO0lBQ0F5UTtJQUNBMVo7SUFDQW1KO0lBQ0FOO0lBQ0FPO0lBQ0F1UTtJQUNBM1A7SUFDQUM7SUFDQVQ7SUFDQW9RO0lBQ0EzTztJQUNBQztZQUNBMk8saUJBQXFEeFMsR0FBSSxPQUFBLG1DQUFKQSxHQUFpQzs7SUFDdEZ5Uzs7OztPQWZBbFI7T0FDQUs7T0FDQXlRO09BQ0ExWjtPQUNBbUo7T0FDQU47T0FDQU87T0FDQXVRO09BQ0EzUDtPQUNBQztPQUNBVDtPQUNBb1E7T0FDQTNPO09BQ0FDO09BQ0EyTztPQUNBQzs7O0U7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0M3Qlk7WUFJWkgsS0FBZTNaLFNBQVN5VDtJQUtQLElBQWJzRyxpQkFMVy9aLFNBQVN5VDtJQUNsQixXQUlGc0c7OzJCQVdGQSxtQkFObUIsV0FNbkJBOztJQTZCZSxJQUFmQTtJQUhOLFdBR01BOztPQVNJL1o7WUFDQXlULGlCQUFjLFdBQWE7R0FQdkI7d0JBTUp6VCxTQUNBeVQ7SUFWSnNHO0lBR1EsV0FIUkE7O2FBaUNBQSxXQUFXaE47S0FDZ0MsVUFBQSxpQkFEaENBO0tBQ2IsV0FBWSxpQkFEQ0E7SUFDeUQ7SUFKMUUsV0FHTWdOOzs7YUErQkFBLFdBQVdoTixHQUFFQztLQUVELFVBQUEsaUJBRkRELE1BQUVDO0tBQ2YsV0FBWSxpQkFEQ0QsTUFBRUM7SUFHZDtJQU5MLFdBR00rTTs7O2FBeUJBQSxXQUFXaE47S0FDZ0MsVUFBQSxpQkFEaENBO0tBQ2IsV0FBWSxpQkFEQ0E7SUFDeUQ7SUFKMUUsV0FHTWdOOzs7OztPQXRJRko7Ozs7bUJBaUNpQixJQUFmSSx5Q0FBQUE7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUNsQkVDOzs7Ozs7OztZQXpDSmhhLFFBR0VpYSxPQUFRQyxPQUFReEgsT0FBUUM7SUFDNUIsR0FBRyxvQ0FEaUJELE9BQVFDLFFBRXZCO2FBRmVEO1NBS1ZFLFFBTFVGO2NBQVFDLFVBTVY7U0FEUUUsUUFMRUY7S0FLVSxPQUFBLFdBTGxDc0gsT0FLTXJILE9BQWdCQzs7UUFHZkMsUUFSU0o7YUFBUUMsVUFPVjtRQUNVSSxRQVJBSjtJQVFZLE9BQUEsV0FSNUJ1SCxPQVFEcEgsT0FBaUJDO0dBQXNDO1lBR2hFMUQsWUFRRThLLGFBQWFDLGFBQWFuSCxLQUFJQztJQUNsQyxTQURrQ0E7S0FHdEIsSUFESkMsS0FGMEJELFFBSTVCRSxRQURNLHlCQUhrQkg7S0FLNUIsT0FBQSxXQUxFa0gsYUFJRS9HLE9BRkVEOztJQUtJLElBREhFLE9BTnlCSCxRQVE1QkksUUFETSx5QkFQa0JMO0lBUzVCLE9BQUEsV0FUZW1ILGFBUVg5RyxPQUZHRDtHQUdhO0dBV3BCLFNBUkFnSCxVQVFJQyxVQUFZQyxVQStCWkM7SUEvQko7O2NBK0JJQTtnQkFBQUE7Ozs7Ozs7T0FIQSxPQUFBOzZDQTdCQVIsa0JBZ0NBUTs7TUFMQSxPQUFBOzRDQTNCQVIsa0JBZ0NBUTs7ZUFBQUE7O01BQ0EsT0FBQTs0Q0FqQ0FSLGtCQWdDQVE7OztNQURBLE9BQUE7NENBL0JBUixrQkFnQ0FRO1NBN0JzQkM7O1FBQUFBO1NBQUFBO1VBQUFBO1VBQUFBOztVQVl5Q0M7U0FBQUEsbUJBQUFBO09BSTNDO1FBRGZDLFdBSDBERDtRQUl4REUsV0FBYSxXQWxCUkwsVUFpQlBJO09BRUYsV0FESUM7O01BR0osT0FBQTs7ZUF0QkhaO2VBR3NCUztlQTZCdEJEOztTQTdCNkRLO1FBQUFBLG1CQUFBQTtNQUl6QztPQURmQyxXQUh3REQ7T0FJdERFLFdBQWEsV0FOcEJULFVBS0tRO01BRUYsV0FESUM7O0tBR0osT0FBQTs7Y0FWSGY7Y0FHc0JTO2NBNkJ0QkQ7O0lBR0EsT0FBQSx3Q0FuQ0FSLGtCQWdDQVE7R0FHc0U7WUFHMUUvRyxVQU9JdUgsVUFBWUM7SUFIbEI7S0FLdUIsSUFEWEMscUJBQ0ZDLFdBQWEsV0FGakJILFVBQ01FO0tBRU4sd0JBRElDOztJQUdhLElBRFZDLHFCQUNIQyxXQUFhLFdBTExKLFVBSUxHO0lBRVAsd0JBRElDO0dBQzBEO1lBR2pFOUgsZUFLQytILGdCQUFpQkM7SUFDckI7Ozs7eUNBRElEOzhDQUFpQkM7R0FpQnBCOzs7VUFySEN2YixTQWNBcVAsYUFvQkFnTCxXQTZDQTVHLFdBZ0JDRjs7O0U7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7WUMxRENpSSxxQjtHQVhzQiw2QkFXdEJBO1lBVUZDLEtBQVl4RSxPQUFTLE9BQVRBO1lBQ1p5RSxJQUFXekUsT0FBTzdGLEdBQUksT0FBQSxXQUFYNkYsVUFBTzdGO1lBQ2xCdUssS0FBWTFFLE9BQU83RixHQUFFOEcsR0FBSSxPQUFBLFdBQWJqQixVQUFPN0YsR0FBRThHO1lBQ3JCMEQsT0FBYzNFLE9BQVMsT0FBVEE7WUFLZGpOLElBQVdpTixPQUFPN0YsR0FBR3hIO0lBQWlCLFVBQUEsV0FBakJBLEdBQW9CLFdBQTlCcU4sVUFBTzdGO0lBQW9CLE9BQUEsV0FBM0I2RixVQUFPN0Y7O1lBRWxCeUssUUFBZUM7SUFDakIsWUFEaUJBO2dCQUVQO1FBQ0hGO0lBQVU7cUJBQVV4SyxHQUFHeEg7YUFBSyxPQUFTO3NCQUFyQ2dTLFFBQW9CeEssR0FBaUIsV0FBZHhILEdBQWlCLFdBSDlCa1MsVUFHVTFLO1lBQXFDOzs7OzhCQWI5RHFLLE1BQ0FDLEtBQ0FDLE1BQ0FDLFFBS0E1UixLQUVBNlI7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0MzQ1k7Ozs7Ozs7O0lBQUE7SUFVWmpUO0lBQ0FtVDtJQUNBQztJQUNBaGM7WUFFQW1KLEtBQUtsUTtJQUdILFVBQUEsNEJBSEdBO0lBR0gsT0FBQTtHQUFtQjtHQVFQO0lBTGRzUjtJQUNBQztJQUNBbVA7SUFDQW5RO0lBQ0F5UztJQUNBckM7SUFDQWpQO1lBRUF6QixPQUFTc0csS0FBVTdDO0lBQ3JCLEdBRFc2QyxTQUFNQyxNQUFORCxRQUFBME0sTUFBTXpNLGNBQU55TTtJQUNYLEtBRHFCdlAsR0FFYjtPQUZhQSxNQUtkLE9BQUEsbUNBTEl1UCxLQUFVdlA7UUFJakIxVCxJQUppQjBUO0lBSVYsT0FBUDFUO0dBQzRCO1lBSzlCNlEsS0FBS0gsR0FBR0MsR0FBSSxPQUFBLG9DQUFKQSxHQUFIRCxHQUE0Qjs7Ozs7T0E3QmpDZjtPQUNBbVQ7T0FDQUM7T0FDQWhjO09BRUFtSjtPQU1Bb0I7T0FDQUM7T0FDQW1QO09BQ0FuUTtPQUNBeVM7T0FDQXJDO09BQ0FqUDtPQUVBekI7T0FVQVk7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQy9DRTlKLFFBQ0cwUyxPQUFRQztJQUNWLEdBQUcsb0NBRERELE9BQVFDLFFBRUw7SUFFRyxJQVFKd0osSUFSSSw2QkFKTnpKLFVBQVFDO2FBWU53SixHQUFLLE9BQUxBO0lBTk8sSUFLSkMsTUFMSSw2QkFOVDFKLFVBQVFDO2FBV0h5SixLQUFLLE9BQUxBO0lBSE8sSUFFSkMsTUFGSSw2QkFSWjNKLFVBQVFDO2lCQVVBMEosbUNBVlIzSixVQUFRQyxZQVVBMEo7R0FFQztZQUlYaE4sWUFLUzRELEtBSkpDO0lBQ047S0FFUUUsUUFFRiw2QkFESUgsS0FKSkM7S0FFQUksUUFLRiw2QkFKSUYsT0FIRkY7S0FDRm9KLFFBUUYsNkJBUEloSixPQUZBSjtJQVdOLE9BQUEsNkJBVklvSixPQURFcEo7R0FXd0I7R0FTaEMsU0FOR0YsS0FNQ0U7SUFBSyxJQUhBRCxNQUFNLGlDQUNWLE1BbkJGNUQsWUFrQk00RCxLQUdMQztJQUZDLE9BQUE7R0FFVTtZQUdiTztJQUNEO0tBR2lCOEk7S0FEREM7S0FEQ0M7S0FEQ0M7S0FPWEMsVUFBWSw2QkFKRko7S0FHWkssZ0NBQ0VEO0tBSUFFLFVBQVksNkJBVEhMO0tBUVhNLGtDQUNFRCxlQUxGRDtLQVNFRyxVQUFZLDZCQWRGTjtLQWFaTyxrQ0FDRUQsZUFMRkQ7S0FTRUcsVUFBWSw2QkFuQkRQO0tBa0JiUSxrQ0FDRUQsZUFMRkQ7SUFRSixXQUpJRTtHQUl5QjtHQXpFeEI7SUFBQSxRQVNMbGQsU0FpQkNxUCxhQWVBMkQsTUFTRFM7SUF6Q0F6UztJQWlCQ21jO0lBZUFDOzs7WUEyQ0hDLHFCQUFzQkMsV0FBV0MsVUFBVUMsVUFBVUM7SUFDdkQ7S0FDK0QsTUFBQSw0QkFGbEJELFVBQVVDO3dCQUVOO0tBQS9DOztRQUZzQkg7dUJBRUoseUJBRmVDO0lBRWpDLE9BQUE7R0FBbUY7WUFHbkZ0Uzs7S0FBNkN1UztLQUFVQztLQUFwQkY7S0FBdkJEO0lBQ2QsT0FORUQscUJBS1lDLFdBQXVCQyxVQUFVQyxVQUFVQzs7WUFJdkRsSSxZQUFVNUwsR0FBSSxXQUpkc0IsVUFJVXRCLElBQTJCOzs7OztPQXBGbkMzSTtPQWlCQ21jO09BZUFDOztPQTJDSEM7T0FLQXBTO09BSUFzSzs7OztFOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUM5RkFtSSxnQkFBVyxxQkFFRDtZQUdWQyxjQUNXaFUsR0FETUM7SUFDbkIsSUFBYWlHLE1BQUFsRyxHQUFFaEQsU0FBSUU7SUFDakI7VUFEV2dKO01BRU0sVUFBQSxnQkFGQWhKO01BRVQsV0FBQSxnQkFGS0Y7O0tBSUgsSUFKQ21KLE1BQUFELFFBR1Q1VyxJQUhTNFcsUUFJRCxRQUFBLFdBTE9qRyxHQUlmM1E7O01BRXFCLElBQVpDLGNBTEUwa0IsWUFLRjFrQixHQUxFeU47TUFBRmtKLE1BQUFDO01BQUVuSixNQUFBaVg7O1VBTWUsSUFBaEJDLGdCQU5LQyxZQU1MRCxLQU5LaFgsTUFBTmdKLE1BQUFDLEtBQU1qSixNQUFBaVg7O0dBUVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BZFZKO09BS0FDOzs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDT0lJOzs7Ozs7Ozs7Ozs7R0FDSixTQVJBMUQsVUFRSTJELFVBQVlDLFVBK0JaQztJQS9CSjs7Y0ErQklBO2dCQUFBQTs7Ozs7OztPQUxBLE9BQUE7NkNBM0JBSCxrQkFnQ0FHOztNQUhBLE9BQUE7NENBN0JBSCxrQkFnQ0FHOztlQUFBQTs7TUFDQSxPQUFBOzRDQWpDQUgsa0JBZ0NBRzs7O01BREEsT0FBQTs0Q0EvQkFILGtCQWdDQUc7U0FqQnNCQzs7UUFBQUE7U0FBQUE7VUFBQUE7VUFBQUE7O1VBWmlDQztTQUFBQSxtQkFBQUE7T0FJbkM7UUFEZkMsV0FIa0REO1FBSWhERSxXQUFhLFdBTnBCTixVQUtLSztPQUVGLFdBRElDOztNQUdKLE9BQUE7O2VBVkhQO2VBZXNCSTtlQWlCdEJEOztTQWpCNkRLO1FBQUFBLG1CQUFBQTtNQUl6QztPQURmQyxXQUh3REQ7T0FJdERFLFdBQWEsV0FsQlJSLFVBaUJQTztNQUVGLFdBRElDOztLQUdKLE9BQUE7O2NBdEJIVjtjQWVzQkk7Y0FpQnRCRDs7SUFHQSxPQUFBLHdDQW5DQUgsa0JBZ0NBRztHQUdzRTtZQUcxRXpLLFVBT0lpTCxVQUFZQztJQUhsQjtLQUt1QixJQURkaEUscUJBQ0NDLFdBQWEsV0FGakI4RCxVQUNHL0Q7S0FFSCx3QkFESUM7O0lBR2EsSUFEWGdFLHFCQUNGQyxXQUFhLFdBTExGLFVBSU5DO0lBRU4sd0JBRElDO0dBQ3lEO1lBR2hFdEwsZUFLQ3VMLGdCQUFpQkM7SUFDckI7Ozs7c0NBRElEOzZDQUFpQkM7R0FpQnBCO1lBR0MvZSxRQUdFZ2YsT0FBUUMsT0FBUUMsT0FBUUM7SUFDNUIsR0FBRyxvQ0FEaUJELE9BQVFDLFFBRXZCO2FBRmVEO1NBS2JFLFFBTGFGO2NBQVFDLFVBTWI7U0FES0UsUUFMUUY7S0FLSSxPQUFBLFdBTDVCSCxPQUtHSSxPQUFhQzs7UUFHVkMsUUFSVUo7YUFBUUMsVUFPYjtRQUNXSSxRQVJFSjtJQVFVLE9BQUEsV0FSMUJGLE9BUUZLLE9BQWdCQztHQUFzQztZQUc5RHRmLE1BR0UrZSxPQUFRQyxPQUFRTyxPQUFRQztJQUM1QixHQUFHLG9DQURpQkQsT0FBUUMsUUFFdkI7YUFGZUQ7U0FLYkUsUUFMYUY7Y0FBUUMsVUFNYjtTQURLRSxRQUxRRjtLQUtJLE9BQUEsV0FMNUJULE9BS0dVLE9BQWFDOztRQUdWQyxRQVJVSjthQUFRQyxVQU9iO1FBQ1dJLFFBUkVKO0lBUVUsT0FBQSxXQVIxQlIsT0FRRlcsT0FBZ0JDO0dBQXNDO1lBRzlEeFEsWUFRRXlRLGFBQWFDLGFBQWE5TSxLQUFJQztJQUNsQyxTQURrQ0E7S0FHdEIsSUFEUEMsS0FGNkJELFFBSTVCRSxRQURNLHlCQUhrQkg7S0FLNUIsT0FBQSxXQUxFNk0sYUFJRTFNLE9BRkREOztJQUtPLElBREpFLE9BTjBCSCxRQVE1QkksUUFETSx5QkFQa0JMO0lBUzVCLE9BQUEsV0FUZThNLGFBUVh6TSxPQUZFRDtHQUdjO1lBUWhCK0QsS0FFQW5lLEdBRlEyUTtJQUNWLFNBQ0UzUSxNQUFnQixPQUFoQkE7UUFDRyttQixNQURIL21CO0lBQ1EsT0FBQSxXQUhBMlEsR0FHTG9XO0dBQVE7R0FTTDtJQUFOaFc7OztnQkFKQS9RLEdBRk8yUTtRQUNULFNBQ0UzUSxNQUFnQixPQUFoQkE7WUFDRyttQixNQURIL21CO1FBQ1EsV0FBRyxXQUhKMlEsR0FHSm9XO09BQWE7WUFJaEJsSixTQUFPN2QsR0FBSSxXQUFKQSxHQUFROzs0Q0FiZm1lLE1BWUFwTixLQUNBOE07Ozs7Ozs7Ozs7OztZQUdKdEQsVUFBVXlNLFVBQVNDLGFBQVl2VztJQUNqQyxTQURpQ0EsVUFFNUJ3VyxLQUY0QnhXLE1BRXRCLE9BQUEsV0FGQ3NXLFVBRVBFO1FBQ0dDLFFBSHlCelc7SUFHaEIsT0FBQSxXQUhJdVcsYUFHYkU7R0FBMEI7WUFHaENDLEtBQUtwbkIsR0FBSSxXQUFKQSxHQUFXO1lBQ2hCcW5CLE1BQU1qTCxRQUFTLE9BQUEsMkJBRGZnTCxNQUNNaEwsUUFBb0M7WUFFMUNrTCxVQUFVNVcsR0FBR0M7SUFDZixTQURZRCxNQUVHLE9BRkhBO1FBR0oxUSxJQUhJMFE7SUFHQyxXQUFNLFdBSEpDLEdBR1AzUTtHQUFnQjtZQU1sQnVuQixPQUFLdm5CLEdBQUcyUTtJQUNWLFNBRE8zUSxNQUVTLE9BRlRBO1FBR0N1VixJQUhEdlY7SUFHTSxPQUFBLFdBSEgyUSxHQUdGNEU7R0FBUTtHQUdSLElBQU5pUyx3QkFmSkY7WUFnQklHLFNBQU9sUyxHQUFJLFdBQUpBLEdBQVc7OzBDQVBsQmdTLFFBTUFDLE9BQ0FDOztZQUdKQyxhQUFRLDhCQUVRO1lBR2hCQyxnQkFBVyw4QkFFSTtZQUdmVDtJQUFLLG1CQUVNO1FBRFJsbkI7SUFBSyxXQUFMQTtHQUNZO1lBR2ZtbkI7SUFBUSxtQkFDQTtRQUNGbm5CO0lBQUssV0FBTEE7R0FBVztZQUdqQjRuQixVQUFVclIsS0FBSzRRO0lBQ2pCLEtBRFk1USxLQUdGLFdBSE80UTtRQUVWbm5CLElBRkt1VztJQUVBLFdBQUx2VztHQUNjO1lBR25CNlEsS0FBS29PLEdBQUd0TztJQUNWLFNBRE9zTyxNQUdNO1FBRFJqZixJQUZFaWY7SUFFRyxPQUFBLFdBRkF0TyxHQUVMM1E7R0FDVTtZQUdiNm5CLFdBQVc1SSxHQUFHdE87SUFDaEIsU0FEYXNPLE1BRUg7UUFDRmpmLElBSEtpZjtJQUdBLE9BQUEsV0FIR3RPLEdBR1IzUTtHQUFRO1lBR2Q4bkI7SUFBZ0MsdUJBQzdCOW5CLGNBQUssV0FBTEE7UUFDRyttQjtJQUFLLFdBQUxBO0dBQWE7WUFHbkJnQjtJQUFnQyx1QkFDMUIvbkIsY0FBSyxXQUFMQTtRQUNDK21CO0lBQUssV0FBTEE7R0FBWTtZQUduQmlCLFdBQVdDLE1BQU1kLE9BQVEsT0FBZGMsaUJBQU1kLE9BQTJDO1lBRTVEZSxTQUFTdlg7SUFDWCxJQUFJLGNBQUcsV0FESUEsUUFDUDtVQUNGcUwsV0FBQUYsMEJBQUFFLFFBQU8sV0FBUEY7R0FBZ0I7WUFHaEJxTTtJQUFTLHVCQUNObm9CLGNBQUssT0FBTEE7UUFDRzhiO0lBQU8sTUFBQSw0QkFBUEE7R0FBZ0I7WUFHdEJzTTtJQUFpQix1QkFDZHBvQixjQUFLLE9BQUxBO1FBQ0crYjtJQUFPLE9BQUEsNkJBQVBBO0dBQW1CO1lBWXpCc00sUUFBUXZXLElBQUdDLElBQUltVixJQUFJb0I7SUFDckIsU0FEVXhXO1NBR0x5VyxNQUhLelc7Y0FBR0MsV0FHQXlXLE1BSEF6VyxPQUdPLFdBQUcsV0FITm1WLElBR1pxQixLQUFRQztTQURDalQsSUFGRHhEOzs7U0FJTDBXLE9BSkUzVztjQUFHQztVQUlPMlcsT0FKUDNXO01BSWUsV0FBTSxXQUpidVcsS0FJYkcsTUFBWUM7O1NBRk5uVCxJQUVOa1Q7O0lBRjJCLFdBQXJCbFQ7R0FFbUM7WUFHL0NvVCxlQUFlalY7SUFDakI7S0FBZSxRQUFBLDJCQURFQSxHQTNDZm9VO0tBNENNYztLQUFKMUI7SUFDSixPQURRMEIsV0FBQUEsWUFBSjFCO0dBR2tCO1lBR3BCMkIsb0JBQW9CblY7SUFBSSxPQUEwQixrQkFQbERpVixlQU9vQmpWLG9CQUFzRCxTQUFFO0dBQUM7Ozs7T0EvUTdFME47T0E2Q0E1RztPQWdCQ0Y7T0F5QkR2VDtPQWNBQztPQWNBb1A7Ozs7Ozs7Ozs7OztPQXlDQW1FO09BTUE2TTtPQUNBQztPQXFCQUs7T0FLQUM7T0FLQVQ7T0E2Q0FpQjtPQUtBQztPQTdDQWpCO09BS0FTO09BTUEvVztPQU1BZ1g7O09BbkRBUDtPQTZGQWU7T0FPQU07T0FPQUU7T0FsREFmO09BS0FDO09BTEFEO09BVUFFO09BRUFFO1dBbERBUixPQUtBQzs7O0U7Ozs7OztHQ3JMd0I7O0lBQUE7SUFOWjs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OztJQ0paaEs7WUFNQTlNLEtBQU1KLE1BQUtDLEdBQUdDO0lBQUksT0FBbUI7YUFBL0JGLE1BQUtDLHNCQUFrQ29ELEdBQUssT0FBQSxXQUFwQ25ELEdBQStCbUQsR0FBUTtHQUFDO1lBQ3REZ1YsTUFBT3JZLE1BQUtDLEdBQUdDO0lBQUksT0FBa0I7YUFBOUJGO2FBQUtDOztzQkFBOEJ3UyxHQUFFcFA7Y0FBSyxPQUFHLFdBQXJDbkQsR0FBNkJtRCxLQUFpQiw0QkFBbkJvUCxRQUFBQTthQUErQjtHQUFDO1lBRTFFNkYsSUFBY3RZLE1BQWF1WTtJLGdCQUE4QnRZLEdBQUdDO0tBQzlELE9BQXVCO2NBRFBGO2NBQTJDQztjQUE5QnNZO3VCQUNEOUYsR0FBRXBQO2VBQWUsVUFBQSxXQURpQm5ELEdBQ2hDbUQ7ZUFBZSxPQUFBLFdBRGhCa1YsTUFDRDlGO2NBQXNCLEdBQUM7O1lBR2pEK0YsWUFBYXhZLE1BQU1MLE1BQU1PLEdBQUVEO0lBQzdCLE9BQVk7YUFkVmlOO3NCQWNpQks7Y0FBUDtzQkFFUjt3QkFIV3ZOO3dCQUFjQzt3QkFBUk47aUNBR0s4WSxLQUFJQzt5QkFDakIsSUFFSjVULElBRkksV0FKYzVFLEdBR0R1WSxLQUFJQztrQ0FHckI1VCxNQUFnQixPQUFBLFdBTE55SSxPQUtWekk7NkJBRFV2VixJQUNWdVY7eUJBRGUsT0FBTHZWO3dCQUNjO2FBQUc7R0FBQTtZQUdsQ29wQixXQUFZM1ksTUFBTUwsTUFBTU8sR0FBRzBZLFFBQU8zWTtJQUNwQyxPQUFZO2FBdkJWaU47c0JBdUJpQks7Y0FBUCxPQUVSO3VCQUh5QnFMO3VCQUd6Qjt5QkFIVTVZO3lCQUFzQkM7eUJBQWhCTjtrQ0FHTThZLEtBQUlDOzBCQUNqQixZQUFBLFdBSmF4WSxHQUdBdVksS0FBSUM7aURBRUtucEIsY0FBSyxPQUFMQTs4QkFDckIrbUI7MEJBQUssT0FBQSxXQUxBL0ksT0FLTCtJO3lCQUFhO2FBQUc7R0FBQTtZQUc1QnVDLFFBQVM3WSxNQUFLQyxHQUFHM0o7SUFDbkIsT0FBcUI7YUFEVjBKO2FBQUtDOztzQkFDVXdZLEtBQUlLO2NBQzVCLEtBRHdCTCxLQUVkLFdBRmtCSztrQkFHckJwcEIsTUFIaUIrb0I7Y0FHUCxXQUFBLFdBSkFuaUIsU0FJVjVHLEtBSHFCb3BCLFdBQUFBLE9BQUpMO2FBR21DO0dBQUM7WUFHNURNLFFBQVMvWSxNQUFLQyxHQUFHM0o7SUFDbkIsT0FBcUI7YUFEVjBKO2FBQUtDOztzQkFDVXdZLEtBQUlLO2NBQzVCLEtBRHdCTCxLQUVkLFdBRmtCSztrQkFHckJycEIsTUFIaUJncEI7Y0FHUCxZQUFBLFdBSkFuaUIsU0FJVjdHLEtBSHFCcXBCLE9BQUpMLFVBQUlLO2FBRytCO0dBQUM7WUFHNUQvVyxPQUFRL0IsTUFBS3lQO0lBQUksT0FBa0I7YUFBM0J6UDthQUFLeVA7O3NCQUEyQmdKLFlBQVMsT0FBQSw0QkFBVEEsUUFBZ0I7R0FBQztZQUV6RHpFLFNBQVU1VCxNQUFLcVA7SUFDakIsT0FBWTthQWhEVnZDO3NCQWdEZXhGO2NBQ2YsV0FGVXRILE1BQUtxUCxtQkFFSyxPQUFBLFdBREwvSCxNQUNtQjtjQUFsQzthQUNJO0dBQUM7WUFHTHZGLE9BQVEvQixNQUFLcVAsR0FBR3ZQO0lBQ2xCLE9BQVk7YUF0RFZnTjtzQkFzRGV4RjtjQUNmO2dCQUZRdEg7Z0JBQUtxUDt5QkFFRWxnQjtpQkFBUSxVQUFBLFdBRlAyUSxHQUVEM1E7aUJBQVEsYUFBUyxXQURqQm1ZO2dCQUM4QjtjQUE3QzthQUNLO0dBQUM7WUFHTmxGLFFBQVNwQyxNQUFLcVAsR0FBR3ZQO0lBQ25CLE9BQVk7YUE1RFZnTjtzQkE0RGV4RjtjQUNmO2dCQUZTdEg7Z0JBQUtxUDt5QkFFQ2xnQjtpQkFBWSxjQUFBLFdBRlYyUSxHQUVGM1E7OEJBQXVCLFdBRHZCbVk7Z0JBQ3FDO2NBQXBEO2FBQ0k7R0FBQztZQUdMc1IsU0FBVTVZLE1BQUtILEdBQUdDO0lBQ3BCLE9BQVk7YUFsRVZnTjtzQkFrRWV4RjtjQUNmO2dCQUZVdEg7Z0JBQUtIO3lCQUVBMVE7aUJBQ1AsSUFFSjRULE1BRkksV0FIVWpELEdBRUgzUTt3QkFHWDRULE1BQWlCLFdBSk51RSxHQUlYdkU7Z0JBQTZCO2NBSGpDO2FBSUk7R0FBQztZQUdMOFYsS0FBTTdZLE1BQUtxUCxHQUFHdlA7SUFDaEIsT0FBWTthQTNFVmdOO3NCQTJFZXhGO2NBQ2Y7Z0JBRk10SDtnQkFBS3FQO3lCQUVJbGdCO2lCQUFRLFVBQUEsV0FGVDJRLEdBRUMzUTtpQkFBUSxhQUFrQixXQUQxQm1ZLE9BQ0FuWTtnQkFBa0M7Y0FBakQ7YUFDSTtHQUFDO1lBR0x3USxRQUFTQyxNQUFLeVA7SUFBYSxVQUFBLFdBQWxCelAsTUFBS3lQLGVBQXNDZ0osS0FBSWxwQixHQUFLLFdBQUxBLEdBQUprcEIsS0FBaUI7SUFBMUMsT0FBQTtHQUE0QztZQUV2RVMsU0FBVW5YLFFBQVEzQixNQUFLcVA7SUFDekIsSUFBSTVLLGtCQUNBM0w7SUFDSjtNQUhvQmtIO01BQUtxUDtlQUdWbGdCO09BQ2IsU0FGRTJKO1FBRXdDLFVBQUEsV0FKaEM2SSxRQUFhME47UUFDckI1SyxXQUdzQixnQ0FEWHRWOztpQkFEWDJKO09BR0YseUJBSkUyTCwwQkFFV3RWO09BQWYsT0FBQSw2QkFESTJKO01BSUk7V0FMSjJMO0dBTUU7O1FBTUY3RTs7U0FFQW1aLGtCQUcwQmxaLEdBQUdDLEdBQUssT0E5RnBDRSxLQXlGRUosTUFLMEJDLEdBQUdDLEdBQW9COztTQUR6Q2taLG1CQUZSRCxTQUVRQzs7O1NBSVJDLG9CQUcwQnBaLEdBQUssT0E3RGpDOEIsT0FrREUvQixNQVcwQkMsR0FBbUI7O1NBRHJDcVosdUJBRlJELFdBRVFDO2FBSVJDLFdBQVN0WixHQUFJLE9BOURmK1QsU0FrREVtRixRQVlTbFosR0FBb0I7YUFDN0J1WixNQUFJQyxHQUFFeFo7S0FBSSxVQXJHWnFZLElBc0ZFdFksTUFlSXlaO0tBQU0sK0NBQUp4WjtJQUFpQjthQUN2QnlaLFFBQU16WixHQUFHQyxHQUFJLE9BeEdmbVksTUF3RkVyWSxNQWdCTUMsR0FBR0MsR0FBb0I7YUFDN0J5WixTQUFPMVosR0FBR0MsR0FBSSxPQTNEaEJpQyxPQTRDRWdYLFFBZU9sWixHQUFHQyxHQUFxQjthQUMvQjBaLFVBQVEzWixHQUFHQyxHQUFJLE9BdERqQnNDLFFBc0NFMlcsUUFnQlFsWixHQUFHQyxHQUFzQjthQUNqQzJaLFdBQVM1WixHQUFHQyxHQUFJLE9BakRsQjhZLFNBZ0NFRyxRQWlCU2xaLEdBQUdDLEdBQXVCO2FBQ25DNFosT0FBSzdaLEdBQUdDLEdBQUksT0F6Q2QrWSxLQXVCRUUsUUFrQktsWixHQUFHQyxHQUFtQjthQUMzQjZaLFVBQVE5WixHQUFJLE9BcENkRixRQWVFQyxNQXFCUUMsR0FBbUI7YUFDM0IrWixXQUFTL1osR0FBSSxPQW5DZmlaLFNBcUJFRyxVQU5BRixRQW9CU2xaLEdBQTRCO2FBQ3JDZ2EsVUFBUWhhLEdBQUczSixTQUFVLE9BdkZ2QnVpQixRQWdFRTdZLE1BdUJRQyxHQUFHM0osU0FBa0M7YUFDN0M0akIsVUFBUWphLEdBQUczSixTQUFVLE9BakZ2QnlpQixRQXlERS9ZLE1Bd0JRQyxHQUFHM0osU0FBa0M7YUFDN0M2akIsY0FBWWxhLEdBQUdOLE1BQU1PLEdBQUksT0EzRzNCc1ksWUFrRkV4WSxNQXlCZUwsTUFBTU8sR0FBVEQsR0FBeUM7YUFDckRtYSxhQUFXbmEsR0FBR04sTUFBTU8sR0FBRzBZO0tBQVMsT0FuR2xDRCxXQXlFRTNZLE1BMEJjTCxNQUFNTyxHQUFHMFksUUFBWjNZO0lBQXdEO0lBM0JuRTtZQVNBb1o7WUFNQUU7WUFaQUo7WUFGQW5aO1lBeUJBbWE7WUFDQUM7WUFUQVQ7WUFDQUM7WUFGQUY7WUFEQUY7WUFLQU07WUFEQUQ7WUFFQUU7WUFDQUM7WUFDQUM7WUFDQUM7Ozs7O09BakhGOVo7T0FDQWlZO09Bd0JBUTtPQU9BRTtPQU9BaFg7T0FtQ0FoQztPQXZFQXVZO09BSUFFO09BU0FHO09BeUJBM0U7T0FNQTdSO09BTUFLO09BZUF5VztPQVRBRDtPQWlCQUU7Ozs7Ozs7U0FXTUc7U0FBQXJGO1NBQUFtRjtTQUFBa0I7U0FBQTdCO1NBQUFHO1NBQUF4VztTQUFBSztTQUFBNlY7U0FBQUM7U0FBQVc7U0FBQUQ7U0FBQWpaO1NBQUFtWjtTQUFBTDtTQUFBRTtpQkFzQ0p1QixJQUFJcmEsR0FBRW9ELEdBQUc5TTtTQUFRLE9BQVksV0F0Q3pCNEwsUUFzQ0FsQyxHQUF5QixXQUFwQjFKLE9BQUg4TTtRQUFnQzs7Z0JBQXRDaVg7Z0JBdENJakI7Z0JBQUFyRjtnQkFBQW1GO2dCQUFBa0I7Z0JBQUE3QjtnQkFBQUc7Z0JBQUF4VztnQkFBQUs7Z0JBQUE2VjtnQkFBQUM7Z0JBQUFXO2dCQUFBRDtnQkFBQWpaO2dCQUFBbVo7Z0JBQUFMO2dCQUFBRTs7Ozs7Ozs7U0FBQU07U0FBQXJGO1NBQUFtRjtTQUFBa0I7U0FBQTdCO1NBQUFHO1NBQUF4VztTQUFBSztTQUFBNlY7U0FBQUM7U0FBQVc7U0FBQUQ7U0FBQWpaO1NBQUFtWjtTQUFBTDtTQUFBRTtpQkFpREp1QixJQUFJcmEsR0FBRTZZO1NBQU0sT0FBWSxXQWpEcEIzVyxRQWlEQWxDLEdBQW9CLG9CQUFsQjZZO1FBQW1DOztnQkFBekN3QjtnQkFqRElqQjtnQkFBQXJGO2dCQUFBbUY7Z0JBQUFrQjtnQkFBQTdCO2dCQUFBRztnQkFBQXhXO2dCQUFBSztnQkFBQTZWO2dCQUFBQztnQkFBQVc7Z0JBQUFEO2dCQUFBalo7Z0JBQUFtWjtnQkFBQUw7Z0JBQUFFOzs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM3Rk5wSTtJQUNBNUc7WUFFQ0YsZUFDQ3VMO0lBQW9CLE9BQUEsNkJBQXBCQTtHQUF3RDtZQU8xRDllLFFBQVFpa0IsV0FBVWxaLElBQUdDO0lBQ3ZCLEdBQUcsNkJBRGlCRCxJQUFHQyxLQUNFOzt3QkFERkE7OztVQUFBQTt3REFBQUEsTUFBQUE7d0JBQUhEOzs7VUFBQUE7d0RBQUFBLE1BQUFBO0lBQ2lDLE9BQUEsV0FEM0NrWjtHQUNxRDtZQUc3RGhrQixNQUFNaWtCLFNBQVFuWixJQUFHQztJQUFLLEdBQUcsNkJBQVhELElBQUdDLEtBQThCOzt3QkFBOUJBOzs7VUFBQUE7d0RBQUFBLE1BQUFBO3dCQUFIRDs7O1VBQUFBO3dEQUFBQSxNQUFBQTtJQUE4RCxPQUFBLFdBQXRFbVo7R0FBZ0Y7T0FDdEY3VTtZQUtJeUgsU0FBTzdkLEdBQUksT0FBQSxxQkFBSkEsR0FBYztZQUNyQm1lLEtBQUt6TixHQUFHQztJQUFJOzthQUFZO2lDQUFuQkQ7OzttQkFBQUE7aUVBQUFBLEtBQUFBO2NBQW1CLE1BQUEsV0FBaEJDOzs7O3FDQUFnQjs7R0FBYztHQUVoQztJQUFOSTs7O2dCQWZBTCxHQUFHQztRQUFJOzs7cUNBQVBEOzs7dUJBQUFBO3FFQUFBQSxLQUFBQTtpQkFBZSxPQUFBLFdBQVpDOztPQUFzQjs0Q0FhekJ3TixNQURBTixVQUdBOU07Ozs7Ozs7Ozs7Ozs7WUFNRnVMLFlBQVU0TyxXQUFVeGE7SUFDdEIsS0FBRyxtQkFEbUJBO0tBQ29CLE9BQUE7O3dCQURwQkE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFDSyxPQUFBLFdBRGZ3YTtHQUM4RDtHQUp6RDtJQUFBLGtCQUdmNU87OztPQW5CRnZWO09BSUFDO09BQ0FvUDtPQWhCQWdMO09BQ0E1RztPQUVDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUNKRGpNOzs7Ozs7Ozs7Ozs7O1lBRUE4Yyx1QkFBd0JDLEtBQUt2YixLQUFLd2I7SUFDcEMsR0FEMEJELFNBQ1YsV0FIZC9jLG1CQUV3QitjO09BQUt2YixTQUVmLFdBSmR4QixtQkFFNkJ3QjtjQUt0Qiw0QkFMMkJ3YixjQUFMeGIsT0FBTHViOztjQU1yQixXQVJIL2MsbUJBRXdCK2MsS0FBS3ZiLEtBQUt3Yjs7R0FNd0M7WUFJMUVDLGtCQUFtQkYsS0FBS3ZiLEtBQUt3YjtJQVkvQjtLQUFJRSxPQUFPLDRCQVpVSCxLQUFLdmI7S0FhRSxNQUFBLDRCQWJHd2IsY0FZM0JFO0tBQ0QsTUFBQSw2QkFia0JILEtBQUt2YjtLQWF2QixNQUFBLGtDQURDMGI7V0FDRDtpQkF2QkRKLHVCQVVtQkMsS0FBS3ZiLEtBQUt3YjtHQWNvQjtZQUdqREcsZ0JBQWtCalYsS0FBVTFHLFlBQVF3YjtJQUN0QyxHQURvQjlVLFNBQU1DLE1BQU5ELFFBQUE2VSxNQUFNNVUsY0FBTjRVO0lBQ3BCLEdBRDhCdmI7U0FHckJsRyxJQUhxQmtHLFFBQzFCNGIsUUFFSzloQjs7U0FGTDhoQixRQUdRLDRCQUowQkosY0FBbEJEO0lBakJsQkUsa0JBaUJrQkYsS0FDaEJLLE9BRGtDSjtJQU90QyxXQVBvQkQsS0FDaEJLO0dBTUk7R0FHTztJQUFBLGNBckNiTjs7VUEyQkFLLGlCQWpCQUY7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztZQ1BFSSxjO0dBTlEsZUFNUkE7WUFHRkMsT0FBTzdaLElBQUdDO0lBQ1o7d0JBRFNEOzs7VUFBQUE7d0RBQUFBLE1BQUFBO0tBQ0w4WixPQUFLO3dCQURHN1o7OztVQUFBQTt3REFBQUEsTUFBQUE7S0FFUjhaLE9BQUs7SUFDVCwyQkFESUEsWUFEQUQsWUFBQUE7SUFBQUEsVUFDQUM7O0dBRVk7WUFFZEMsYUFBYUMsV0FBVSxPQUFWQSxVQUFpQjtZQUVkQyxVQUFVclYsT0FBUSxPQUFSQSxNQUFhO29DQVJ2Q2dWLFFBTUFHLGNBRWdCRTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNGaEJDLCtCQUFnQ0M7SUFDbEM7Y0FBQTtPQURrQ0Esa0JBQUFBLG1CQUlqQjtJQUViLE9BQUE7R0FDa0Y7WUFlbEZDLEtBQUt6YjtJQUFJO3dCQUFKQTs7O1VBQUFBO3dEQUFBQSxLQUFBQTtJQUEyQixPQUFBO0dBQWM7WUFDOUN1WCxLQUFLdlg7SUFBSTt3QkFBSkE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBMkIsT0FBQTtHQUFjO1lBQzlDMGIsTUFBSTFiLEdBQUUxUTtJQUFJO3dCQUFOMFE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBTSxPQUFBLHNDQUFKMVE7R0FBMEM7WUFDaERxc0IsTUFBTTNiLEdBQUUxUTtJQUFJO3dCQUFOMFE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBTSxPQUFBLHNDQUFKMVE7R0FBNEM7WUFDcERzc0IsTUFBTTViLEdBQUUxUTtJQUFJO3dCQUFOMFE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBTSxPQUFBLHNDQUFKMVE7R0FBNEM7WUFDcER1c0IsVUFBVTdiLEdBQUUxUTtJQUFJO3dCQUFOMFE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBTSxPQUFBLHNDQUFKMVE7R0FBZ0Q7WUFDNUQwZ0IsS0FBS3hLO0lBQXFCLFVBQUEsaUNBQXJCQTtJQUFxQixPQUFBO0dBQTZCO1lBQ3ZEaEcsS0FBS1E7SUFBSTt3QkFBSkE7OztVQUFBQTt3REFBQUEsS0FBQUE7S0FBa0IsTUFBQTtJQUFBLE9BQUE7R0FBdUM7WUFDOUQ4YixPQUFLOWI7SUFBSSxVQU5UMGIsTUFNSzFiO0lBQUksT0FBQTtHQUErQjtZQUN4QytiLE1BQU0vYjtJQUFJLFVBUFYwYixNQU9NMWI7SUFBSSxPQUFBO0dBQStCO1lBRXpDZ2MsZUFBZ0JSO0lBakNsQkQsK0JBaUNrQkM7SUFFSixVQUFBO0lBQUEsT0FBQTtHQUFxQzs7SUFHakRQOzs7Ozs7Ozs7Ozs7Ozs7O0lBY1EsSUFBSmpiLElBQUk7SUFDUjtRQVhBcWIsWUFZQSwwQkFGSXJiOzs7O0tBVkpxYjs7O1NBa0JjLElBQUEsTUEzQmRXOzs7aUNBMkJjOztZQUdkQyxjQUFjamMsR0FBRWtjO0lBQ2xCLG9CQURrQkE7Y0FHSyxvQkF4Q3JCTixNQXFDYzViLEdBR2dCLG9CQUhka2M7Y0F2Q2hCUixNQXVDYzFiLEdBQUVrYztHQUd3QztZQUd4REMsY0FBY25jLEdBQUVrYztJQUVsQixvQkFGa0JBLFFBNUNoQlAsTUE0Q2MzYixHQUFFa2MsU0E3Q2hCUixNQTZDYzFiLEdBQUVrYztHQUl3QztPQUd4REUsNEJBYkFILGdCQU1BRTtZQWVFRSxPQUFLcFcsT0FBUSxPQUFBLG9CQTlEZndWLEtBOERPeFYsUUFBMkI7R0FDcEMsU0FIRXFXLGlCQUdFclc7SUFDRjtLQUV1QyxNQUFBLHNCQUpyQ29XLE9BQ0FwVztLQUdBLE1BQUEsZUFBUSxzQkFKUm9XLE9BQ0FwVztJQUNGLE9BQUEsZUFGRW9XLE9BQ0FwVztHQUdrRTtHQU10RSxTQUhFc1csaUJBRU90VztJQUN3QixVQXhFL0J3VixLQXVFT3hWO0lBQ0ksT0F4RVh3VixLQXVFT3hWO0dBQ29EO1lBRzNEdVcseUJBQXlCdlc7SUFBUSxPQUFrQixvQkFmbkRxVyxpQkFleUJyVztHQUFrRDtZQUMzRXdXLHlCQUF5QnhXLE9BQVEsT0FQakNzVyxpQkFPeUJ0VyxPQUFrRDs7SUFFM0V5VzswQkFIQUYsMkJBQ0FDO1lBUUFFLCtCQUErQjFXO0lBQ2pDLE9BQUEsb0JBekJFcVcsaUJBd0IrQnJXO0dBQ2U7WUFHOUMyVywrQkFBK0IzVyxPQUNqQyxPQXBCRXNXLGlCQW1CK0J0VztHQUNlOztJQUc5QzRXOztTQVJBRjtTQUlBQztZQVVBRTtJQUFxQmhMLE1BQUtpTCxhQUFZQyxhQUFZQztJQUNwRDtLQUlFLE1BQUEsV0FMa0RBLGlCQUFaRDtLQUl0QyxNQUFBLFdBSmtEQyxpQkFBeEJGO0lBQzVCLE9BQUEsZ0NBRHVCakw7R0FNbkI7WUFJRm9MLFNBS0VqWCxPQUFNa1gsSUFBR0M7SUFDWCxHQURXQSxLQUFIRCxJQWZSTCw4QkFlUUssSUFBR0M7SUFFQSxJQUFQQyxPQUFPLDRCQUZBRCxJQUFIRDtPQUVKRTtLQUVDO01BQUE7TUFBTSxNQXZDWFgsMkJBbUNFelc7TUFJUSxNQUFBO0tBQUEsT0FBQSw0QkFKRmtYOztZQUVKRTtLQUlNLFVBakVWakIsTUEyREVuVyxPQU1rQix5QkFKaEJvWDtLQUlNLE9BQUEsNEJBTkZGOztJQUhSO0tBQVUsSUFBTnpCLFFBaENKZ0IsMkJBbUNFelc7UUFBTWtYLE1BSEp6QixTQUFBQSxTQUdPMEIsSUFGb0IsT0FEM0IxQjs7R0FVcUI7WUFHekI0QixXQU9FclgsT0FBTWtYLElBQUdDO0lBQ1gsR0FBRyxnQ0FES0QsSUFBR0M7S0FoQ1hOLGdDQWdDUUssSUFBR0M7SUFFQSxJQUFQQyxPQUZPRCxLQUFIRDtJQUdMLEdBQUEsZ0NBRENFO0tBRUM7S0FBQSxPQUpHRixNQTdEUlosaUJBNkRFdFc7O0lBS00sR0FBQSxnQ0FISm9YO0tBSUMsT0FOR0YsS0EvSFJ4QixNQStIRTFWLE9BTXVCLDRCQUpyQm9YO0lBTko7S0FBVSxJQUFOM0IsUUF6REphLGlCQTZERXRXO0tBSGM7T0FBYixnQ0FEQ3lWLE9BSUl5QjtVQUhRLGdDQURaekIsT0FJTzBCO01BSG9CLE9BRDNCMUI7O0dBV3FCO1lBR3pCNkIsZUFPRXRYLE9BQU1rWCxJQUFHQztJQUNYLEdBQUcsZ0NBREtELElBQUdDO0tBakRYTixvQ0FpRFFLLElBQUdDO0lBRUEsSUFBUEMsT0FGT0QsS0FBSEQ7SUFHTCxHQUFBLGdDQURDRTtLQUVDO0tBQUEsT0FKR0YsTUF2RFJOLHFCQXVERTVXOztJQUtNLEdBQUEsZ0NBSEpvWDtLQUlDLE9BTkdGLEtBOUlSdEIsVUE4SUU1VixPQU0yQixnQ0FKekJvWDtJQU5KO0tBQVUsSUFBTjNCLFFBbkRKbUIscUJBdURFNVc7S0FIYztPQUFiLGdDQURDeVYsT0FJSXlCO1VBSFEsZ0NBRFp6QixPQUlPMEI7TUFIb0IsT0FEM0IxQjs7R0FXcUI7WUFHekI4QixXQU9FdlgsT0FBTWtYLElBQUdDO0lBQ1gsR0FBRyx5QkFES0QsSUFBR0M7S0FsRVhOLGdDQWtFUUssSUFBR0M7SUFFQSxJQUFQQyxPQUFPLHVCQUZBRCxJQUFIRDtJQUdMLEdBQUEsbUJBRENFO0tBRUM7S0FBQSxPQUFBO2NBSkdGLElBSUksdUJBNUdaYixpQkF3R0VyVzs7SUFLTSxHQUFBLGtCQUhKb1g7S0FJQyxPQUFBO2NBTkdGLElBaEtSdkIsTUFnS0UzVixPQU11Qiw0QkFKckJvWDtJQU5KO0tBQVUsSUFBTjNCLFFBcEdKWSxpQkF3R0VyVztLQUhjLEdBQWIsa0JBREN5VixPQUlJeUIsT0FIUSx1QkFEWnpCLE9BSU8wQjtNQUhvQixPQUQzQjFCOztHQVdxQjtZQWdCekIrQixRQUFNeFgsT0FBTW1YO0lBQUs7S0FYbkI7TUFDSU07TUFFQUMsS0FuTEZsQyxLQTJMTXhWO01BUEoyWCxLQXBMRm5DLEtBMkxNeFY7TUFOTSxNQUFBLDRCQUZWMFgsSUFGQUQ7TUFJUyxNQUFBLGlDQURURTtNQUNBQyxTQUFTLGlDQUpUSDtLQU9ELEdBQUEsZ0NBSENHO01BTWUsT0FBQSw0QkFOZkEsUUFNVVQ7O0dBQXlCO1lBRXJDVSxZQUFZN1gsT0FBTWtYLElBQUdDO0lBQ3ZCLEdBQ0csZ0NBRmlCRCxJQUFHQztLQTNGckJOLGdDQTJGa0JLLElBQUdDO0lBR2pCLFVBTEpLLFFBRVl4WCxPQUdJLDRCQUhLbVgsSUFBSEQ7SUFHZCxPQUFBLDRCQUhjQTtHQUdRO0dBSWxCLElBQVZZLFlBQVUsZ0NBaExSMUM7WUFrTEYyQztJQUFVLE9BdE1SdkMsS0FzTW1CLGdDQUZyQnNDO0dBRW9EO1lBQ3BERSxNQUFJM3VCO0lBQUksT0FqSk44c0IsTUFpSmdCLGdDQUhsQjJCLFlBR0l6dUI7R0FBK0M7WUFDbkQ0dUIsUUFBTTV1QjtJQUFJLE9Bck1ScXNCLE1BcU1vQixnQ0FKdEJvQyxZQUlNenVCO0dBQWlEO1lBQ3ZENnVCLFlBQVU3dUI7SUFBSSxPQXBNWnVzQixVQW9NNEIsZ0NBTDlCa0MsWUFLVXp1QjtHQUFxRDtZQUMvRDh1QixRQUFNOXVCO0lBQUksT0F0TVJzc0IsTUFzTW9CLGdDQU50Qm1DLFlBTU16dUI7R0FBaUQ7WUFDdkQrdUIsUUFBTS91QjtJQUFJLE9BaEJSbXVCLFFBZ0JvQixnQ0FQdEJNLFlBT016dUI7R0FBaUQ7WUFDdkRndkIsV0FBU2h2QixHQUFFQztJQUFJLE9BaEdiMnRCLFNBZ0c0QixnQ0FSOUJhLFlBUVN6dUIsR0FBRUM7R0FBc0Q7WUFDakVndkIsYUFBV2p2QixHQUFFQztJQUFJLE9BbEZmK3RCLFdBa0ZnQyxnQ0FUbENTLFlBU1d6dUIsR0FBRUM7R0FBd0Q7WUFDckVpdkIsaUJBQWVsdkIsR0FBRUM7SUFBSSxPQWxFbkJndUIsZUFrRXdDLGdDQVYxQ1EsWUFVZXp1QixHQUFFQztHQUE0RDtZQUM3RWt2QixhQUFXbnZCLEdBQUVDO0lBQUksT0FsRGZpdUIsV0FrRGdDLGdDQVhsQ08sWUFXV3p1QixHQUFFQztHQUF3RDtZQUNyRW12QixjQUFZcHZCLEdBQUVDO0lBQUksT0FuQmhCdXVCLFlBbUJrQyxnQ0FacENDLFlBWVl6dUIsR0FBRUM7R0FBeUQ7WUFDdkVvdkI7SUFBVSxPQWhOUnBILEtBZ05tQixnQ0FickJ3RztHQWFvRDtZQUNwRGE7SUFBVSxPQTFNUjlDLE9BME1tQixnQ0FkckJpQztHQWNvRDtZQUNwRGM7SUFBVyxPQTFNVDlDLE1BME1xQixnQ0FmdkJnQztHQWVzRDtZQUN0RGUsVUFBVXRaO0lBQXVCLElBbE1yQnhGLElBa01xQixnQ0FoQmpDK2Q7SUFsTDhCLE9BQUEsV0FGNUI5QyxRQUVVamIsR0FaVmdRLEtBOE1ReEs7R0FBMkQ7WUFDckU5RixLQUFLOEYsTUFBTyxPQURac1osY0FDS3RaLE9BQTJCO1lBQ2hDdVosVUFBV3ZEO0lBNU9YRCwrQkE0T1dDO0lBQThCLE9BRnpDc0QsVUE1TkY7R0E4TjJFO1lBQ3pFRSxVQUFVdGhCO0lBQUksT0FBQSxXQXZNWnVkLFFBdU15QixnQ0FuQjNCOEMsWUFtQlVyZ0I7R0FBa0Q7Ozs7T0FGNURnQztPQURBb2Y7T0FFQUM7T0FoQkFmO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDOztRQS9MRXhEO1FBZEFyTDtRQUtBZ007UUFKQXhjO1FBUEFpYztRQXNEQVc7UUFuREFUO1FBRUFFO1FBREFEO1FBdUxBNkI7UUEvRUFQO1FBZUFJO1FBaUJBQztRQWlCQUM7UUFnQ0FNO1FBNUxBdkc7UUFPQXVFO1FBQ0FDO09BOE1GaUQ7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUN6UEFDLFFBQVVwWixVQUFpRDFHLEtBQUlhO0lBR2pFLEdBSFk2RjtTQUFlQyxNQUFmRCxRQUFBcVosZUFBZXBaOztTQUFmb1o7SUFHWixZQUh5REMsZ0JBQU56RSxNQUFNeUUsZ0JBQU56RTtJQUduRCxJQUFJQyxlQUg2RDNhO0lBSWpFLEdBSjZEYjtTQU1wRDZELElBTm9EN0QsUUFJekQ0YixRQUVLL1g7O1NBRkwrWCxRQUdRLDRCQUpSSixjQUgrQ0Q7SUFTbkQsOENBVG1EQSxLQUkvQ0ssT0FEQUo7SUFPWSxJQUFaeUUsWUFBWSw0QkFOWnJFO09BTUFxRTtTQUNKbm1CLElBREltbUI7O01BRVc7T0FBVEMsU0FBUyw0QkFab0MzRSxLQVduRHpoQjtPQUdxRCxNQUFBLDRCQUhyREE7T0FHdUIsTUFBQSwrQkFkWGltQjtPQWNOSSxXQUFXLDRCQWRrQzVFO01BZWpELGlCQWYrRDFhLEdBWTNEcWYsUUFFQUM7TUFITixVQUFBcm1CO2VBQUFBO01BQUFBOzs7O0dBS0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhCRmdtQjs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7OztZQ0pBTSxRQUFNL1AsVUFBTSxPQUFOQSxFQUFPO1lBTWJnUSxJQUFJdmYsR0FBRTNRLEdBQUksV0FBSSxXQUFWMlEsR0FBRTNRLEdBQWE7WUFFbkJtd0IsUUFBUXhmO0lBQ1YsSUFDRSxRQUFBLFdBRlFBO1VBTVJ5ZixTQUFBN2Esd0JBQUE2YSxNQUFLLE9BQUw3YTtHQUFNO1lBUU44YSxRQUFRMWYsR0FBRTJmLEdBQUV0d0IsR0FBSSxPQUFFLFdBQVYyUSxHQUFVLFdBQVIyZixHQUFFdHdCLElBQVc7WUFDdkJ1d0IsS0FBSzVmLEdBQUUzUSxHQUFFQyxHQUFJLE9BQUEsV0FBUjBRLEdBQUkxUSxHQUFGRCxHQUFXO1lBQ2R3d0IsY0FBZXROLEdBQUV2UyxHQUFFM1E7SUFBSSxJQUFSbWpCLE1BQUFELEdBQUk2RCxNQUFBL21CO0lBQUk7YUFBUm1qQixLQUF1QixPQUFuQjREO0tBQXFELElBQXJEMEosTUFBcUQsV0FBdkQ5ZixHQUFFb1csTUFBSjNELE1BQStDLDRCQUEvQ0Q7S0FBQUEsTUFBQUM7S0FBSTJELE1BQUEwSjs7R0FBMEQ7cUJBeEJqRlIsU0FNQUMsS0FFQUMsU0FnQklLLGVBRkpILFNBQ0FFOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ0dBNVY7SUFHR21LO0lBMkJGeEs7Ozs7Ozs7OztJQWxERHZUOzs7O1lBRUNxUCxZQUNFNEQsS0FBSUM7SUFDTixPQURNQTs7T0FFSSxPQUFBLHlCQUZSRDs7T0FHUyxPQUFBLHlCQUhUQTtlQUlXLE9BQUEseUJBSlhBOztHQUkrQztHQVVwRCxTQU5HRCxLQU1DRTtJQUFLLElBSEFELE1BQU0saUNBQ1YsTUFiRjVELFlBWU00RCxLQUdMQztJQUZDLE9BQUE7R0FFVTtHQU9kLFNBRkNtSCxVQWNDc1A7SUFaRjs7Y0FZRUE7Z0JBQUFBOzs7Ozs7Ozs7O1FBWHdDOztPQUVNOztNQURKOztlQVUxQ0E7O01BQ0EsT0FBQTs0Q0FkRTVMLGtCQWFGNEw7OztNQURBLE9BQUE7NENBWkU1TCxrQkFhRjRMOzs7Ozs7Ozs7OztPQVBBLE9BQUE7NkNBTkU1TCxrQkFhRjRMOztNQUhBLE9BQUE7NENBVkU1TCxrQkFhRjRMOztLQUxBLE9BQUE7MkNBUkU1TCxrQkFhRjRMOztJQUVjLE9BQUEsd0NBZlo1TCxrQkFhRjRMO0dBRW9GO1lBSXJGbFc7SUFDRCxzQkFDVyxtQkFDQyxvQkFDRTs7R0FBNEI7WUFtQnpDeFQsTUFBTThNLEdBQUVDLEdBQUksOEJBQU5ELEdBQUVDLFdBQW1CO0dBRWY7WUFPWm5DLE9BQU9zUixHQUFJLFlBQUpBLFVBQUFBLGNBQTREO1lBRW5FMVI7SUFBUyxzQkFDRCxrQkFDQyxrQkFDRTs7R0FBQzs7OztPQS9FWnpLO09BRUNxUDtPQVNBMkQ7T0FXRHFIO09Bb0JBNUc7T0FRQ0Y7T0E5QkRLO09BNkNBM1Q7T0FTQTRLO09BRUFKOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7OztJQ2k1QkltZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE5bUJKQzs7Ozs7Ozs7Ozs7Ozs7O0lBOVdBdmlCO0lBS0UrUztJQUNBNUc7OztZQUVDRixlQUNDdUw7SUFBb0IsT0FBQSw2QkFBcEJBO0dBQXNEO1lBWXhEOWUsUUFDRWdmLE9BQVE4SyxPQUFRQztJQUNwQixHQUFHLG9DQURTRCxPQUFRQyxRQUVmO1NBRk9ELGNBQVFDO1FBS2JDLFFBTEtGO1NBQVFDLE9BTUw7UUFES0UsUUFMQUY7SUFLWSxPQUFBLFdBTDVCL0ssT0FLR2dMLE9BQWFDO0dBR3NCO1lBR3hDMVUsWUFFRTJVO0lBREosWUFLdUI7SUFGRixJQURkQyxxQkFDQ0MsV0FBYSxXQUZqQkYsVUFDR0M7SUFFSCx3QkFESUM7R0FFbUQ7R0F4Qm5DO0lBQUEseUJBTXRCcHFCLFNBWUF1Vjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQWNGL0IsVUFBVTVKLEdBQUVELEdBQUksT0FBQSxpQkFBSkEsR0FBRkMsR0FBZTtZQUN6QkwsUUFBUUksR0FBSSxPQUFKQSxFQUFLO1lBRWIwZ0IsTUFBUXJxQixTQUFTc3FCLFFBQVM5YSxXQUF5QythLFNBQVFDO0lBQzdFLEdBRDRCaGIsU0FBUUMsTUFBUkQsUUFBQWliLFFBQVFoYixjQUFSZ2I7SUFDNUIsYUFEeUQzQixpQkFBUHRFLE9BQU9zRSxnQkFBUHRFO0lBQ3JDLElBQVRrRyxTQUFTLFdBRE1KLFFBQWtEQztJQUVyRSxTQUFJSSxNQUFNMXhCLEdBQUVDO0tBQW9CLFdBQUEsV0FGdEI4RyxTQUVBL0csR0FBRUM7S0FBb0IsT0FBQTtJQUFhO0lBQzdDLFNBQUkweEI7S0FDRixPQUFBO0lBQXVFO1dBRnJFRCxNQUZpRUosU0FDakVHOztXQUtBRzs7V0FBQUEsdUJBSEFEO21CQUdBQzs7O0tBTVNDLHlCQVplTCxRQUF5Q0YsVUFDakVHO0tBV1M5bkIsSUFBQWtvQjtLQUFFQztJQUNiO0tBQXNCLElBQWxCQyxrQkFYRkwsTUFVUy9uQixHQVpnRTRuQjs7Ozs7T0FjM0UsT0FESVE7O3lCQVBGSDs7MEJBTjhDckcscUJBWXJDNWhCLEdBQUVtb0I7cUJBQUFBOztrQ0FOWEY7O09BV2EsSUFBVEksV0FBUyxXQWpCRVgsUUFZTjFuQjs7O2VBVlQrbkIsTUFVUy9uQixHQUtMcW9COzswQkFYSko7O3NCQUhBRDttQ0FHQUM7O1FBZ0JrRCxJQVZ2Q0ssY0FBRnRvQixHQUFFbW9CO1FBQUZub0IsSUFLTHFvQjtRQUxPRixRQUFBRzs7OztlQVNSOzs7aUJBVFFIOztLQXlCWCxPQUFBOztHQUFpQjtZQUduQkksUUFBUTNiLGlCQUF1RCthLFNBQVFDO0lBQ3pFLEdBRFVoYixTQUFTQyxNQUFURCxRQUFBOGEsU0FBUzdhLGNBQVQ2YTtJQUNWLGFBRGdDeEIsaUJBQVIyQixRQUFRM0IsZ0JBQVIyQjtJQUN4QixhQURxRFcsaUJBQVA1RyxPQUFPNEcsZ0JBQVA1RzthQUFwQzhGO0tBQ1M7SUFBQSxPQXpDakJEOztzQkEwQzJCcHhCLEdBQUssT0FBYSw0QkFBbEJBLEdBRm5CcXhCLFFBRWtDO2lCQUZwQkc7aUJBQXNCakc7YUFBbUIrRjthQUFRQztHQUVBO1lBR3ZFYSxHQUFHMWhCLEdBQ0wsS0FES0EsR0FFRyxjQUNOMVEsSUFIRzBRLE1BR08sV0FBVjFRLEdBQWdCO1lBR2hCcXlCLEdBQUczaEIsR0FDTCxLQURLQSxHQUVHLGNBQ0RrRyxNQUhGbEcsTUFHUSxXQUFOa0csS0FBYTtZQUdsQjBiLElBSWdCNWhCLEdBQUV3UztJQUhwQixPQUdvQkEsR0FGZjtRQUVhdE0sTUFBQWxHLEdBQUV5UyxNQUFBRDtJQUNoQjtVQURjdE0sS0FFTjtTQUZNQyxNQUFBRCxRQUdaOUMsSUFIWThDO0tBR0YsU0FISXVNLEtBR1UsV0FBeEJyUDtLQUE4QyxJQUhoQ3NQLE1BR2dDLDRCQUhoQ0Q7S0FBRnZNLE1BQUFDO0tBQUVzTSxNQUFBQzs7R0FLTjtZQUdabVAsUUFBUTdoQixHQUFFd1M7SUFDTixZQWJKb1AsSUFZUTVoQixHQUFFd1M7O0tBRUYsT0FBQSxXQXpIUjdVLG1CQXVIVTZVLEdBRTJELG1CQUY3RHhTO1FBR0hvRDtJQUFLLE9BQUxBO0dBQU07WUFHWDBlLGlCQUFpQjFmLElBQUdDO0lBQ3RCLEdBRG1CRDtRQUFHQyxJQUdmLE9BQUEsdUJBSFlELElBQUdDO1NBRWhCVyxJQUZhWjs7O1NBRWJZLElBRmdCWDtJQUVILE9BQWJXO0dBQ2lCO1lBYW5CK2UsU0FDVzNmLElBQUVDO0lBQWYsSUFBYWUsSUFBQWhCLElBQUVpQixJQUFBaEIsSUFBRTJmO0lBQ2Y7UUFEVzVlO1NBQUVDO09BR2dCO1FBSGhCdUUsTUFBQXZFO1FBQUZzRSxNQUFBdkU7UUFBSTZlLGtCQUdjLDRCQUhkRDtPQUFKNWUsSUFBQXVFO09BQUV0RSxJQUFBdUU7T0FBRW9hLGdCQUFBQzs7OztlQUFGNWUsR0FFRCxXQUZHMmU7S0FJb0IsV0FKcEJBLGVBQUo1ZSxHQUFFQzs7R0FNSDtZQUlaNmUsa0JBQWtCcFEsTUFBSzFQLElBQUdDO0lBQ3RCLFlBWkYwZixTQVdxQjNmLElBQUdDO3VCQUVUO0lBTUU7S0FMeUI4ZjtLQUFYQztLQUFmSjtLQUtDLE9BQUEsbUJBTHlCRztLQUsxQyxPQUFBLDRCQUxnQkg7S0FJQyxPQUFBLG1CQUpjSTtJQUNqQyxPQUFBO2FBNUpBemtCOzthQXdKa0JtVTthQU9oQiw0QkFKZ0JrUTs7O0dBTWQ7WUFHSkssY0FBY2pnQixJQUFHQyxJQUFJcEM7SUFDdkIsYUF4Qkk4aEIsU0F1QlkzZixJQUFHQyxhQUVzQixXQUZsQnBDLEdBQVBtQyxJQUFHQztHQUdtQjtZQWNsQ2lnQixXQUNXbGdCLElBQUVDLElBQUVrZ0I7SUFBakIsSUFBYW5mLElBQUFoQixJQUFFaUIsSUFBQWhCLElBQUVtTixJQUFBK1MsSUFBRVA7SUFDakI7UUFEVzVlO1NBQUVDLEtBQUVtTTtPQUd3QjtRQUh4QmdULE1BQUFoVDtRQUFGNUgsTUFBQXZFO1FBQUZzRSxNQUFBdkU7UUFBTTZlLGtCQUdzQiw0QkFIdEJEO09BQU41ZSxJQUFBdUU7T0FBRXRFLElBQUF1RTtPQUFFNEgsSUFBQWdUO09BQUVSLGdCQUFBQzs7OztlQUFKNWUsT0FBRW1NLEdBRUMsV0FGQ3dTO0tBS0MsV0FMREEsZUFBTjVlLEdBQUVDLEdBQUVtTTs7R0FPRjtZQUlmaVQsa0JBQWtCM1EsTUFBSzFQLElBQUdDLElBQUdrZ0I7SUFDekIsWUFiRkQsV0FZcUJsZ0IsSUFBR0MsSUFBR2tnQjt1QkFFWjtJQUVRO0tBRDhCRztLQUFYUDtLQUFYQztLQUFmSjtLQUNPLE9BQUEsbUJBRFFJO0tBQzdCTyxLQUFLLDRCQURTWDtLQUVPLE9BQUEsbUJBRm1CRztLQUV4Q1MsS0FBSyw0QkFGU1o7S0FHTyxPQUFBLG1CQUg4QlU7S0FHbkRHLEtBQUssNEJBSFNiO0lBSWxCLE9BQUEsV0F4TUFya0IsbUJBaU1rQm1VLE1BSWQ2USxJQUNBQyxJQUFBQSxJQUNBQztHQUMwRTtZQUc5RUMsY0FBYzFnQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7SUFDMUIsYUF2QklxaUIsV0FzQllsZ0IsSUFBR0MsSUFBR2tnQjtrQkFFbUIsV0FGZnRpQixHQUFWbUMsSUFBR0MsSUFBR2tnQjs7R0FHZ0I7WUFHcENRLE1BQU0zZ0IsSUFBR0MsSUFBSXBDO0lBQUksT0E3Q2pCb2lCO2FBNkNNamdCO2FBQUdDOzs7Y0FBK0Isc0JBQXZCLE9BQUEsdUJBQUpwQzs7R0FBd0M7WUFFckQraUIsVUFBVTVnQixJQUFHQyxJQUFJcEM7SUEzRGpCaWlCLGlDQTJEVTlmLElBQUdDO0lBQ2YsT0FBQSxxQkFEWUQsSUFBR0MsSUFBSXBDO0dBRUY7WUFHZmdqQixTQUFTN2dCLElBQUdDLElBQUlwQztJQUFJLE9BcERwQm9pQjthQW9EU2pnQjthQUFHQzs7O2NBQStCLHNCQUF2QixPQUFBLHVCQUFKcEM7O0dBQTJDO1lBRTNEaWpCLGFBQWE5Z0IsSUFBR0MsSUFBSXBDO0lBbEVwQmlpQixvQ0FrRWE5ZixJQUFHQztJQUNsQixPQUFBLHdCQURlRCxJQUFHQyxJQUFJcEM7R0FFRjtZQUdsQmtqQixNQUFNL2dCLElBQUdDLElBQUkzQyxNQUFNTztJQUFJLE9BM0R2Qm9pQjthQTJETWpnQjthQUFHQzs7O2NBQXFDLHNCQUF2QixPQUFBLHVCQUFWM0MsTUFBTU87O0dBQThDO1lBRWpFbWpCLFVBQVVoaEIsSUFBR0MsSUFBSTNDLE1BQU1PO0lBekV2QmlpQixpQ0F5RVU5ZixJQUFHQztJQUNmLE9BQUEscUJBRFlELElBQUdDLElBQUkzQyxNQUFNTztHQUVGO1lBR3JCb2pCLFNBQVNqaEIsSUFBR0MsSUFBSXBDO0lBQUksT0FsRXBCb2lCO2FBa0VTamdCO2FBQUdDOzs7Y0FBK0Isc0JBQXZCLE9BQUEsdUJBQUpwQzs7R0FBMkM7WUFFM0RxakIsYUFBYWxoQixJQUFHQyxJQUFJcEM7SUFoRnBCaWlCLG9DQWdGYTlmLElBQUdDO0lBQ2xCLE9BQUEsd0JBRGVELElBQUdDLElBQUlwQztHQUVGO1lBR2xCc2pCLFFBQVFuaEIsSUFBR0MsSUFBSXBDO0lBQUksT0F6RW5Cb2lCO2FBeUVRamdCO2FBQUdDOzs7Y0FBK0Isc0JBQXZCLE9BQUEsdUJBQUpwQzs7R0FBMEM7WUFFekR1akIsWUFBWXBoQixJQUFHQyxJQUFJcEM7SUF2Rm5CaWlCLG1DQXVGWTlmLElBQUdDO0lBQ2pCLE9BQUEsdUJBRGNELElBQUdDLElBQUlwQztHQUVGO1lBR2pCb2EsSUFBSXJhLEdBQ2FvRCxHQUFOOU07SUFBYixZQURNMEo7O2lCQUVJO0tBQ0ssSUFBTnlqQixlQUFMcGdCLGNBQVcsT0FBQSxXQUZGL00sT0FBTThNLEdBRWZDO0tBQVcsU0FBQTthQUFOb2dCOztHQUVLO1lBS1pDLFdBQVcxakIsR0FDQ0M7SUFBZCxJQUFnQjBqQixrQkFESDNqQjs7aUJBRUgsT0FETTJqQjtTQUVQM2dCLGNBQUwxVDtLQUFhLEdBQUEsV0FGSDJRLEdBRVYzUTtNQUE4QixpQkFBOUJBLEdBRllxMEI7TUFBQUE7Y0FFUDNnQjs7O2NBQUFBOztHQUVHO1lBR1Y0Z0IsT0FBTzVqQixHQUFHQyxHQUFJLE9BQUksZ0JBUmxCeWpCLFdBUU8xakIsR0FBR0MsSUFBeUI7WUFFbkM4WSxTQUFTL1ksR0FBR0M7SUFDZCxZQURXRDtJQUNJO2lCQUNMO0tBRUMsSUFERmdELGNBQUwxVCxjQUdHbVksSUFGSSxXQUpHeEgsR0FHVjNRO1FBR0dtWSxHQUFlLE9BQWZBO2FBSEV6RTs7R0FLSDtHQUlVLElBQVo2Z0I7WUFERkMsYUFFZTlqQixHQUFHQztJQUNaLFlBZE44WSxTQWFlL1ksR0FBR0M7Z0JBRVIsTUFBQSw0QkFIUjRqQjtRQUlLdjBCO0lBQUssT0FBTEE7R0FBTTtZQU1iMHBCLEtBQUtoWixHQUFHQztJQUNWLFlBRE9EO0lBQ1E7aUJBQ0w7U0FDRGdELGNBQUwxVDtLQUFhLEdBQUEsV0FIUDJRLEdBR04zUSxJQUFzQixXQUF0QkE7YUFBSzBUOztHQUVIO0dBSVUsSUFBWitnQjtHQUNKLFNBRkVDLFNBRWVoa0IsR0FBR0M7SUFDbEIsSUFEZWlHLE1BQUFsRztJQUNmO1VBRGVrRyxLQUVQLE1BQUEsNEJBSE42ZDtTQUNhNWQsTUFBQUQsUUFHYjVXLElBSGE0VztLQUdBLEdBQUEsV0FIR2pHLEdBR2hCM1EsSUFBc0IsT0FBdEJBO0tBSGE0VyxNQUFBQzs7R0FHNkI7WUFNNUM4ZCxNQUNhamtCLEdBREpDO0lBQ1gsSUFBYWhILE9BQUVpTixNQUFBbEc7SUFDYjtVQURha0csS0FFTDtTQUZLbEQsSUFBQWtELFFBR1g1VyxJQUhXNFc7S0FHRSxHQUFBLFdBSk5qRyxHQUNFaEgsR0FHVDNKLElBQXdCLGVBSGYySixHQUdUM0o7S0FBOEMsSUFIckN3VixNQUdxQyw0QkFIckM3TDtLQUFBQSxJQUFBNkw7S0FBRW9CLE1BQUFsRDs7R0FLUDtHQUlRLElBQVpraEI7WUFERkMsVUFFWW5rQixHQUFHQztJQUNULFlBWk5na0IsTUFXWWprQixHQUFHQztnQkFFTCxNQUFBLDRCQUhSaWtCO1FBSUs1MEI7SUFBSyxPQUFMQTtHQUFNO1lBS2I4MEIsVUFDYXBrQixHQURBQztJQUNmLElBQWFoSCxPQUFFaU4sTUFBQWxHO0lBQ2I7VUFEYWtHLEtBRUw7S0FFQyxJQUpJbEQsSUFBQWtELFFBR1g1VyxJQUhXNFcsUUFLUjJYLFNBREksV0FMSTVkLEdBQ0ZoSCxHQUdUM0o7UUFFR3V1QixRQUFvQixPQUFwQkE7S0FDYSxJQU5QL1ksTUFNTyw0QkFOUDdMO0tBQUFBLElBQUE2TDtLQUFFb0IsTUFBQWxEOztHQVFQO0dBSVE7SUFBWnFoQjtZQURGQyxjQUVnQnRrQixHQUFHQztJQUNiLFlBZk5ta0IsVUFjZ0Jwa0IsR0FBR0M7Z0JBRVQsTUFBQSw0QkFIUm9rQjtRQUlLLzBCO0lBQUssT0FBTEE7R0FBTTtZQU1iaTFCLFNBQ2F2a0IsR0FEREM7SUFDZCxJQUFhaEgsT0FBRWlOLE1BQUFsRztJQUNiO1VBRGFrRyxLQUVMO0tBQ00sSUFIRHliLEtBQUF6YixRQUdYd2IsS0FIV3hiLFFBR0MsT0FBQSxXQUpGakcsR0FDRGhILEdBR1R5b0I7S0FBWSxXQUFBO0tBQWUsSUFIbEI1YyxNQUdrQiw0QkFIbEI3TDtLQUFBQSxJQUFBNkw7S0FBRW9CLE1BQUF5Yjs7R0FLUDtZQUdONkMsUUFDYXhrQixHQURGQztJQUNiLElBQWFoSCxPQUFFaU4sTUFBQWxHO0lBQ2I7VUFEYWtHLEtBRUw7S0FDTSxJQUhEeWIsS0FBQXpiLFFBR1h3YixLQUhXeGIsUUFHQyxPQUFBLFdBSkhqRyxHQUNBaEgsR0FHVHlvQjtLQUFZLFNBQUE7S0FBZSxJQUhsQjVjLE1BR2tCLDRCQUhsQjdMO0tBQUFBLElBQUE2TDtLQUFFb0IsTUFBQXliOztHQUtQO09BTU4xSTtZQUNBblosUUFBUUUsR0FBSSxPQUFKQSxFQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRWJ5a0I7WUF5QklDLGFBQWF0aUIsSUFBR0MsSUFBRytWO0lBQ3pCLEtBRHNCL1YsSUFFZCxPQUZXRDtTQUFBQSxJQUtSLE9BTFdDO2VBQUhELE9BTVp1aUIsS0FOWXZpQjtlQU1KLFdBQVJ1aUIsSUFOZXRpQjt3QkFPWHVpQjtlQUFRLFdBRFpELFFBQ0lDLElBUFd2aUI7d0JBUVB3aUI7ZUFBUSxXQUZoQkYsUUFDSUMsUUFDSUMsSUFST3hpQjt5QkFTSHlpQjtnQkFBUSxXQUhwQkgsUUFDSUMsUUFDSUMsUUFDSUMsSUFUR3ppQjs7S0FVYXNmO0tBQU5vRDs7T0FuQzNCTixtQkF5QnVCck07VUFkSCx1QkFBVyxnQkF3QkV1SixLQVZidGY7VUFBaEJxaUIsYUFVNkIvQyxJQVZidGYsSUFtQlEsNEJBbkJMK1Y7SUFXcEIsV0FMRXVNLFFBQ0lDLFFBQ0lDLFFBQ0lDLFFBQ1VDO0dBU2M7WUFHekMxbEIsT0FBTytDLElBQUdDLElBQUssT0F0QlhxaUIsYUFzQkd0aUIsSUFBR0MsT0FBeUI7WUE4Qi9CMmlCLFVBQVcva0IsR0FBRStDLEdBQUVpaUI7SUFDckIsS0FEbUJqaUIsR0FFWDtlQUZXQSxNQUdma2lCLE9BSGVsaUI7ZUFJUixJQUFMbWlCLE9BQUssV0FKTWxsQixHQUdiaWxCLE9BRUYsV0FESUM7d0JBRUVDOztLQUNHLElBQUxDLE9BQUssV0FQTXBsQixHQUdiaWxCLE9BS0VJLE9BQUssV0FSTXJsQixHQU1UbWxCO0tBR04sV0FGSUMsVUFDQUM7O3dCQUVNQzs7S0FDRDtNQUFMQyxPQUFLLFdBWE12bEIsR0FHYmlsQjtNQVNFTyxPQUFLLFdBWk14bEIsR0FNVG1sQjtNQU9GTSxPQUFLLFdBYk16bEIsR0FVTHNsQjtLQUlWLFdBSElDLFVBQ0FDLFVBQ0FDOzsyQkFFVUM7O0tBQ0w7TUFBTEMsT0FBSyxXQWhCTTNsQixHQUdiaWxCO01BY0VXLE9BQUssV0FqQk01bEIsR0FNVG1sQjtNQVlGVSxPQUFLLFdBbEJNN2xCLEdBVUxzbEI7TUFTTlEsT0FBSyxXQW5CTTlsQixHQWVEMGxCO0tBS2QsV0FKSUMsVUFDQUMsVUFDQUMsVUFDQUM7O0lBR0s7S0FEcUJwRTtLQUFOcUU7S0FDcEJDLEtBQUssV0F0Qk1obUIsR0FHYmlsQjtLQW9CRWdCLEtBQUssV0F2Qk1qbUIsR0FNVG1sQjtLQWtCRmUsS0FBSyxXQXhCTWxtQixHQVVMc2xCO0tBZU5hLEtBQUssV0F6Qk1ubUIsR0FlRDBsQjtLQVdWVSxLQUFLLFdBMUJNcG1CLEdBcUJTK2xCO09BbEd4QnZCLG1CQTZFbUJROzs7Ozs7Ozs7Ozs7Ozs7O2dCQWpCUnFCLFVBWVR4ZSxLQTBCNEI2Wjs7a0JBMUI1QjdaO3dCQUFBQTs7Ozs7Ozs7Ozs7Ozs7OzthQVZTO2NBRDZDeWU7Y0FBTkM7Y0FBTkM7Y0FBTkM7Y0FBTjNCO2NBQU5EO2NBQU5EO2NBQU5EO2NBQU5EO2NBQU5nQyxLQVdBN2U7Y0FWSThlLE9BQUssV0FlSTNtQixHQWhCYjBtQjtjQUVJRSxPQUFLLFdBY0k1bUIsR0FoQlAwa0I7Y0FHRm1DLE9BQUssV0FhSTdtQixHQWhCRDJrQjtjQUlSbUMsT0FBSyxXQVlJOW1CLEdBaEJLNGtCO2NBS2RtQyxPQUFLLFdBV0kvbUIsR0FoQlc2a0I7Y0FNcEJtQyxPQUFLLFdBVUlobkIsR0FoQmlCOGtCO2NBTzFCbUMsT0FBSyxXQVNJam5CLEdBaEJ1QnltQjtjQVFoQ1MsT0FBSyxXQVFJbG5CLEdBaEI2QndtQjtjQVN0Q1csT0FBSyxXQU9Jbm5CLEdBaEJtQ3VtQjtjQVUzQzs7cUJBVERJLE1BQ0FDLE1BQ0FDLE1BQ0FDLE1BQ0FDLE1BQ0FDLE1BQ0FDLE1BQ0FDLE1BQ0FDO2lCQVZLZDthQUFBQTthQVlUeGUsS0FYc0R5ZTs7Ozs7Ozs7Ozs7Ozs7OztLQVczQyxJQUFBLE9BQUEsd0JBQVh6ZSxJQUthN0gsSUF0Qko0SCxtQkFLQXllOzs2QkFMQXplO01BR0o7T0FEbUM0Yjs7T0FBUDREO09BQUpDO09BQUpDO09BQUpDO09BQUpDO09BQUpDO09BQUpDO09BQUpDO09BQUpDO09BQ0k7O1VBREpBOztXQUFJRDtlQUFJRCxRQUFJRCxRQUFJRCxRQUFJRCxRQUFJRCxRQUFJRCxRQUFJRCxJQUZ4QnhmO01BQUFBO2NBRStCNGI7Ozs7Z0JBb0J0Q3VCLFVBQVcva0IsR0FxQmUwaEIsSUFXeUMsNEJBaENwRHNEO0lBMkJuQixXQUxJZ0IsUUFDQUMsUUFDQUMsUUFDQUMsUUFDQUM7R0FNNkU7WUF3VHhEaG1CLElBclRyQjJDLEdBQUcvQyxHQUFJLE9BbkNQK2tCLFVBbUNHL2tCLEdBQUgrQyxNQUF1QjtZQUUzQjhrQixZQUFZOW5CLEdBQUdOLE1BQU1PO0lBQ2IsSUFBTnVZLFVBRGE5WTtJQUVSLE9BaVRrQlc7YUFuVGJMO3NCQUVBMVE7Y0FDWjtlQUFpQixRQUFBLFdBSEkyUSxHQUNuQnVZLFFBQ1VscEI7ZUFDQ0M7ZUFBVHc0QjtjQUZGdlAsU0FFRXVQO2NBRUosT0FGYXg0QjthQUVaO0dBQUM7WUFHRnk0QixTQUFTaG9CLEdBQUdOLE1BQU1PO0lBQ3BCO0tBQUl1WSxVQURVOVk7S0FFVm1lO09BeVN1QnhkO1NBM1NoQkw7a0JBR0sxUTtVQUNaO1dBQWlCLFFBQUEsV0FKRDJRLEdBQ2hCdVksUUFFWWxwQjtXQUNDQztXQUFUdzRCO1VBSEp2UCxTQUdJdVA7VUFFSixPQUZheDRCO1NBRVo7SUFFTCxXQVBJaXBCLFFBQ0FxRjtHQU1RO1lBbVNlclEsV0FoU2pCeEssR0FBRS9DLEdBQUksT0FnU1dJLElBaFNqQjJDLEdBQUUvQyxHQUFZO1lBQ3RCZ29CLFFBQVE3bEIsSUFBR0MsSUFBSXBDO0lBQUksT0FBSSxnQkFBQSx3QkFBZm1DLElBQUdDLElBQUlwQztHQUE4QjtZQUM3QzZPLEtBQUsxTSxJQUFHQyxJQUFJcEM7SUFBSSxPQXRWaEJvaUI7YUFzVktqZ0I7YUFBR0M7O2NBQStCLHFCLE9BRHZDNGxCLGtCQUNZaG9COztHQUF1QztZQUVuRGlvQixTQUFTOWxCLElBQUdDLElBQUlwQztJQXBXaEJpaUIsZ0NBb1dTOWYsSUFBR0M7SUFDZCxPQUpFNGxCLFFBR1M3bEIsSUFBR0MsSUFBSXBDO0dBRUY7WUFHZGtvQixZQUNXL2xCLElBQUdDLElBQUdrZ0IsSUFES3RpQjtJQUN4QixJQUFhbW9CLE9BQUFobUIsSUFBR2ltQixPQUFBaG1CLElBQUdpbUIsT0FBQS9GLElBQUdnRztJQUNwQjtRQURXSDtTQUFHQyxRQUFHQztPQUcrQjtRQUgvQkUsT0FBQUY7UUFHS3pELEtBSEx5RDtRQUFIRyxPQUFBSjtRQUdGekQsS0FIRXlEO1FBQUhLLE9BQUFOO1FBR1R6RCxLQUhTeUQ7UUFBU08sV0FHNkIsV0FKM0Ixb0IsR0FJcEIwa0IsSUFBVUMsSUFBVUMsS0FIRjBEO09BQVRILE9BQUFNO09BQUdMLE9BQUFJO09BQUdILE9BQUFFO09BQUdELEtBQUFJOzs7O2VBQU5OLFVBQUdDLE1BRUQsT0FGSUM7S0FJYixNQUFBOztHQUVPO1lBR2RLLFNBQVN4bUIsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0lBQUksT0FoVXZCNmlCO2FBZ1VTMWdCO2FBQUdDO2FBQUdrZ0I7O2NBQWtDO2VBQUEscUIsT0FWakQ0RiwyQkFVbUJsb0I7O0dBQThDO1lBRWpFNG9CLGFBQWF6bUIsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0lBNVV2QndpQixvQ0E0VWFyZ0IsSUFBR0MsSUFBR2tnQjtJQUNyQixPQWJFNEYsWUFZYS9sQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7R0FFRjtZQUdyQjZvQixRQUFRMW1CLElBQUdDLElBQUdrZ0IsSUFBSXRpQjtJQUFJLE9BQUksZ0JBakIxQmtvQixZQWlCUS9sQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7R0FBaUM7WUFDbkRnUCxLQUFLN00sSUFBR0MsSUFBR2tnQixJQUFJdGlCO0lBQUksT0F4VW5CNmlCO2FBd1VLMWdCO2FBQUdDO2FBQUdrZ0I7O2NBQWtDO2VBQUEscUIsT0FEN0N1Ryx1QkFDZTdvQjs7R0FBMEM7WUFFekQ4b0IsU0FBUzNtQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7SUFwVm5Cd2lCLGdDQW9WU3JnQixJQUFHQyxJQUFHa2dCO0lBQ2pCLE9BSkV1RyxRQUdTMW1CLElBQUdDLElBQUdrZ0IsSUFBSXRpQjtHQUVGO1lBR2Irb0IsZUFBZTVtQixJQUFHQyxJQUFJcEM7SUFDNUIsSUFEcUJtb0IsT0FBQWhtQixJQUFHaW1CLE9BQUFobUI7SUFDeEI7VUFEcUIrbEIsTUFFYixPQUZnQkM7S0FHUSxJQUhYSyxPQUFBTixTQUduQmEsSUFIbUJiLFNBQUdLLFdBR1MsV0FITHhvQixHQUcxQmdwQixJQUhzQlo7S0FBSEQsT0FBQU07S0FBR0wsT0FBQUk7O0dBR21CO1lBR3pDeG1CLE1BQU1xQztJQUNSLElBQWE0a0IsU0FLUixnQkFORzVrQixPQUNLQyxTQUFBMmtCLFFBQUs5bUIsUUFBR0M7SUFDbkI7VUFEV2tDLFFBRUgsV0FGUW5DLElBQUdDO0tBR2lCO01BSHpCK0IsU0FBQUc7Y0FBQUE7TUFHTGhWO01BQUhEO01BSGdCKzRCLFdBR2I5NEIsR0FIYThTO01BQUgrbEIsV0FHYjk0QixHQUhhOFM7S0FBTG1DLFNBQUFIO0tBQUtoQyxLQUFBZ21CO0tBQUcvbEIsS0FBQWdtQjs7R0FLQTtZQUduQmMsT0FBTzdrQjtJQUNUO0tBQWE0a0IsU0FLUixnQkFOSTVrQjtLQUNJQyxTQUFBMmtCO0tBQUs5bUI7S0FBR0M7S0FBR2tnQjtJQUN0QjtVQURXaGUsUUFFSCxXQUZRbkMsSUFBR0MsSUFBR2tnQjtLQUcyQjtNQUh0Q25lLFNBQUFHO2NBQUFBO01BR0Y2a0I7TUFBSDc1QjtNQUFIRDtNQUhtQmc1QixXQUdiYyxHQUhhN0c7TUFBSDhGLFdBR2I5NEIsR0FIYThTO01BQUgrbEIsV0FHYjk0QixHQUhhOFM7S0FBTG1DLFNBQUFIO0tBQUtoQyxLQUFBZ21CO0tBQUcvbEIsS0FBQWdtQjtLQUFHOUYsS0FBQStGOztHQUtBO1lBR3RCZSxRQUFRam5CLElBQUdDO0lBQ2I7S0FBSSxVQTFERjRsQixRQXlEUTdsQixJQUFHQyxhQUNPZSxHQUFFQyxHQUFLLFdBQVBELEdBQUVDLEdBQVM7S0FBM0I7OztLQUNtRSxVQUFBLG1CQUYxRGhCO0tBRU4sT0FBQSxXQXBqQkwxRSxtQkFvakJ5RCxtQkFGakR5RTs7R0FFMkU7WUFHbkZrbkIsSUFBSWxuQixJQUFHQztJQUFLLE9BN0RaeU0sS0E2REkxTSxJQUFHQyxhQUFrQmUsR0FBRUMsR0FBSyxXQUFQRCxHQUFFQyxHQUFTO0dBQU87WUFJM0NrbUIsU0FBU3ZtQixHQUFHL0M7SUFDZCxJQUFhaEgsT0FBRXVmLGlCQURKeFY7O2lCQUVELE9BREt3VjtLQUVZO01BQWxCeFk7TUFBTGlwQjtNQUF1QixZQUFDLFdBSGRocEIsR0FDRGhILEdBRVRnd0IsSUFGV3pRO01BRUksTUFBQSw0QkFGTnZmO0tBQUFBO0tBQUV1ZjthQUVOeFk7O0dBRUU7WUFHVE0sS0FBSzBDLEdBQUcvQyxHQUFJLE9BQUksZ0JBUmhCc3BCLFNBUUt2bUIsR0FBRy9DLElBQXVCO1lBRS9CdXBCLGFBQWF4cEIsR0FBR04sTUFBTU87SUFDZCxJQUFOdVksVUFEYzlZO0lBRVIsT0FKUlk7YUFFYU47c0JBRUEvRyxHQUFFM0o7Y0FDZjtlQUFpQixRQUFBLFdBSEsyUSxHQUVUaEgsR0FEWHVmLFFBQ2FscEI7ZUFDRkM7ZUFBVHc0QjtjQUZGdlAsU0FFRXVQO2NBRUosT0FGYXg0QjthQUVaO0dBQUM7WUFHRms2QixVQUFVenBCLEdBQUdOLE1BQU1PO0lBQ3JCO0tBQUl1WSxVQURXOVk7S0FFWG1lO09BWkZ2ZDtTQVVVTjtrQkFHSy9HLEdBQUUzSjtVQUNmO1dBQWlCLFFBQUEsV0FKQTJRLEdBR0poSCxHQUZidWYsUUFFZWxwQjtXQUNGQztXQUFUdzRCO1VBSEp2UCxTQUdJdVA7VUFFSixPQUZheDRCO1NBRVo7SUFFTCxXQVBJaXBCLFFBQ0FxRjtHQU1RO1lBR1Z6ZCxNQUFNNEMsR0FBRy9DO0lBRVI7TUE1T0RpZ0I7TUEwT01sZDs7ZUFFa0IvSixHQUFFM0o7T0FDdkIsV0FITTJRLEdBRWVoSCxHQUFFM0o7T0FDdkIsT0FBQSw0QkFEcUIySjtNQUVoQjtJQUZQO0dBR007WUFHUHl3QixNQUFNMXBCLEdBQUdOLE1BQU1PO0lBQ2I7O09BQUE7U0FuUEZpZ0I7U0FrUE1sZ0I7Z0JBQUdOO3lCQUNrQzZPO1VBQWQsSUFBU2lLLGdCQUFIdmYsY0FBb0IsTUFBQSxXQUR4Q2dILEdBQ29CaEgsR0FBR3VmLEtBQUtqSztVQUFLLFdBQUEsNEJBQWJ0VjtTQUE4QjtJQUEvRCxPQUFBO0dBQWdFO1lBR2xFMHdCLFFBQVEzbUIsR0FBRy9DO0lBQ2IsT0FBSTs7YUFMRnlwQjtlQUlRMW1COzt3QkFDVzBYLEtBQUlsQyxLQUFJbHBCO2dCQUFLLE9BQUcsV0FEeEIyUSxHQUNReWEsS0FBUXByQixTQUFBQSxHQUFKa3BCLE9BQUFBO2VBQTBDO0dBQVc7WUFHNUVvUixPQUFPNW1CLEdBQUcvQztJQUNaLEtBRFMrQyxHQUVEO1FBQ0EyZSxLQUhDM2UsTUFHUDBlLEtBSE8xZTtJQUdLLFdBQUssV0E3UGpCa2QsV0E2UE15QixJQUFORCxJQUhVemhCO0dBRzRCO1lBR3RDNHBCLFdBQVc3bUIsR0FBRy9DO0lBQ1YsWUFQSjJwQixPQU1XNW1CLEdBQUcvQztnQkFFTixPQUFBO1FBQ0hzTztJQUFLLE9BQUxBO0dBQU07WUFHWHViLGdCQUFnQjltQixHQUFHL0M7YUFrQmI4cEIsV0FBV0MsS0FBSXhSLEtBQUlscEI7S0FDekIsSUFEaUIyNkIsUUFBQUQsS0FBSUUsUUFBQTFSLEtBQUluQyxNQUFBL21CO0tBQ3pCO01BQUcsU0FBQSw2QkFEYzI2QixXQUVaLFdBRm9CNVQsS0FBSjZUO1dBQUFBO09BS1gsTUFBQTtNQUkrQjtPQVRwQkMsUUFBQUQ7T0FTakIzNkIsSUFUaUIyNkI7T0FBSW5LLE1BU2dCLFdBM0J0QjlmLEdBMkJmMVEsR0FUcUI4bUI7T0FBUitULFFBU1MsNkJBVFRIO01BQUFBLFFBQUFHO01BQUlGLFFBQUFDO01BQUk5VCxNQUFBMEo7O0lBU3dCO0lBUTdDLFlBdkRKMkosTUFvQmdCMW1CLE1Ba0JWK21CO2dCQWtCQTtRQUNEamlCLGVBQUx4WTtJQUFXO1lBQUs7Y0EzU2hCNHdCLFdBMlNLcFksSUFBTHhZLFlBQXlDQSxHQUFFQyxHQUFLLE9BQUEsV0FyQzdCMFEsR0FxQ3dCMVEsR0FBRkQsR0FBWTtHQUFFO1lBR3ZEKzZCLG9CQUFvQnJuQixHQUFHL0M7SUFDbkIsWUF6Q0o2cEIsZ0JBd0NvQjltQixHQUFHL0M7O0tBRWYsT0FBQTtRQUNIc087SUFBSyxPQUFMQTtHQUFNO1lBR1grYixPQUFPdG5CLEdBQUd1bkI7SUFFVjtLQURFQztPQW5FRmQ7U0FrRU8xbUI7O2tCQUVrQi9KLEdBQUV1ZixLQUFJbHBCO1VBQzdCLEtBRHlCa3BCLEtBRWpCLGVBRnFCbHBCO2NBR1ZxeUIsS0FITW5KLFFBR3ZCaVMsZ0JBSHVCalM7VUFJcEIsT0FBQSxXQU5HK1IsU0FFZXR4QixHQUlWLG1CQURYd3hCLGdCQUgyQm43Qjs0QkFBQUEsV0FHM0JtN0IsZUFBaUI5STs0QkFIVXJ5QixHQUczQm03QixnQkFBaUI5STtTQUdjO0lBR3JDLE9BVkk2SSxTQVlHLG9CQVpIQTtHQVltQjtZQUdyQkUsTUFBTTFuQixHQUFHdW5CO0lBQVEsT0FoQmpCRCxPQWdCTXRuQixtQkFBa0MxVCxHQUFFQyxHQUFLLE9BQUEsV0FBdENnN0IsU0FBK0JqN0IsR0FBRUMsR0FBYztHQUFDO1lBRXpEbzdCLGVBQWUzbkIsR0FBRzNNO0lBQ3BCLE9BSEVxMEI7cUNBRWUxbkIsR0FBRzNNO3NCQUMyQi9HLEdBQUVDLEdBQUssYUFBQSxXQURsQzhHLFNBQzJCL0csR0FBRUMsV0FBcUI7R0FBQztZQW1HNUNxN0IsV0FoR2Q1bkIsR0FBRy9DO0lBQ2hCLElBQVl1WSxpQkFEQ3hWOztpQkFFSCxPQUFBLGdCQURFd1Y7S0FFUTtNQUFWbUo7TUFBTkQ7TUFBZ0IsUUFBQSx1QkFBWSxXQUhoQnpoQixHQUdaeWhCLEtBRlFsSjtLQUFBQTthQUVGbUo7O0dBRUY7WUFHTmtKLFlBQVk3bkIsR0FBRy9DO0lBQ2pCLElBQVk2cUIsVUFBS3RTLGlCQURIeFY7O2lCQUVKLE9BQUEsZ0JBRE93VjtLQUVjO01BQXJCbUo7TUFBTkQ7TUFBMkIsUUFBQSx1QkFBWSxXQUgxQnpoQixHQUNMNnFCLE1BRVJwSixLQUZhbEo7TUFFRyxTQUFBLDRCQUZSc1M7S0FBQUE7S0FBS3RTO2FBRVBtSjs7R0FFQTtZQUdSb0osTUFDZTNvQixJQUFHQyxJQURMaE07SUFDZixJQUFhbWlCLFNBR1Q0UCxPQUhhaG1CLElBRVRpbUIsT0FGWWhtQjtJQUNsQjtVQUVFK2xCLE1BRFUsT0FBQSx1QkFGRDVQLEtBRUw2UDtVQUFBQSxNQUNNLE9BQUEsdUJBSEQ3UCxLQUdUNFA7U0FIZ0IvbUIsS0FFWmduQixTQUVNMkMsS0FGTjNDLFNBRlNqbkIsS0FHYmduQixTQUNBNkMsS0FEQTdDO0tBRUcsT0FBQSxXQU5RL3hCLFNBS1g0MEIsSUFBVUQ7TUFDa0QsSUFMbkRkLFlBSUNjLElBSkR4UztNQUFBQSxNQUFBMFI7TUFFTDdCLE9BRllobkI7O1VBS2dCLElBTHZCOG9CLFlBSVRjLElBSlN6UyxNQUFBQSxNQUFBMlIsT0FHVC9CLE9BSGFobkI7O0dBT0o7WUFTVDhwQixPQUFLOW5CLEdBQUVDLEdBQUdwRDtJQUFJLE9BK0RTMnFCO2FBL0RsQnhuQjtzQkFBOEI5VDtjQUFLLE9BK0RqQitRLElBL0RoQmdELFlBQStDOVQsR0FBSyxPQUFBLFdBQWpEMFEsR0FBeUIzUSxHQUFtQkMsR0FBVTthQUFDO0dBQUM7WUErRDNDNGQsU0E5RGhCN2QsR0FBSSxXQUFKQSxNQUFTO1lBOERPaWUsWUE1RGZ2TixHQUFFQyxHQUFJLE9BNERTMnFCLFdBNURmNXFCLEdBQUVDLEdBQWE7R0FPWDtJQUFOeU8sd0JBcURpQnJPOzsyQ0FBQThNLFVBL0R2QitkLFFBVU14YztJQVFBb0ksd0JBNkNpQnpXOzBDQUFBdXFCLFlBQUF6ZCxVQTdDakIySjtJQTZDaUI3TTtJQUFBMkQ7SUFBQUQ7SUFBQUQ7SUE5QnZCK0I7SUFDQXRCO0lBQ0FnZDtJQUNBcDdCO0lBQ0FvZjtJQUNBRTtJQUlFemE7SUFDQUM7SUFDQUM7SUFjbUI7SUFOSCxpQkFXS3FZLFVBQUF5ZCxZQUFBdnFCLEtBN0J2QjhOO0lBNkJHLG1CQUFvQmhCLFVBQUFJLGFBQUFDO0lBQXBCLGtCQUFvQkQsYUFBQUM7WUFHckI0ZCxTQUFTOW1CO0lBQ2YsSUFEZUMsU0FBQUQ7SUFDZjtVQURlQyxRQUlQLE9BQUE7U0FGSmpWLElBRldpVjtVQUFBQSxXQUVKLE9BQVBqVjtTQUZXOFUsU0FBQUc7S0FBQUEsU0FBQUg7O0dBSWdCO1lBSXpCaW5CLEtBQUsvbUI7SUFDWCxJQURXQyxTQUFBRDtJQUNYO1VBRFdDLFFBSUg7U0FGSmpWLElBRk9pVjtVQUFBQSxXQUVBLFdBQVBqVjtTQUZPOFUsU0FBQUc7S0FBQUEsU0FBQUg7O0dBSUM7WUFHTmtuQixVQUFVaG5CLE1BQU1pbkIsUUFBUWoxQjtJQUM5QixJQURnQmlPLFNBQUFELE1BQU1rbkIsV0FBQUQ7SUFDdEI7VUFEc0JDLFVBRWQ7U0FGY0MsV0FBQUQsYUFHcEI5SixLQUhvQjhKO0tBSXBCLEtBSmNqbkIsUUFLTDtLQUNRO01BTkhILFNBQUFHO01BTVhtbkIsT0FOV25uQjtNQU1HLE1BQUEsV0FOV2pPLE9BRzVCb3JCLElBR0dnSztLQUFjLFVBQUE7S0FOSG5uQixTQUFBSDtLQUFNb25CLFdBQUFDOztHQU02QztZQUdqRUUsMkJBQTJCM3JCLEdBQUcxSjtJQUNoQyxLQUQ2QjBKLEdBRXJCO1FBRVVrRyxNQUpXbEcsTUFJZDRyQixLQUpjNXJCLE1BSWQ2ckIsT0FBQUQsSUFBR3psQixNQUFBRDtJQUNkO1VBRGNDLEtBRU47U0FGTUMsTUFBQUQsUUFBSDJsQixLQUFHM2xCO0tBR0UsR0FBQSxXQVBZN1AsT0FJakJ1MUIsTUFBQUMsS0FHc0IsZUFIdEJELE1BQUFDO0tBQUFELE9BQUFDO0tBQUczbEIsTUFBQUM7O0dBS1A7WUFJVDJsQiw4QkFBZ0NsbUIsS0FBdUJ2QixNQUFNaE87SUFDL0QsR0FEa0N1UDtTQUFnQkMsTUFBaEJELFFBQUFtbUIsZ0JBQWdCbG1COztTQUFoQmttQjtTQUF1QjFuQixNQWVqRDs7S0FDQTJuQixPQWhCaUQzbkI7S0FnQnZENG5CLFlBaEJ1RDVuQjtLQUM1QzZuQixVQWVYRDtLQWZtQjlLO2FBZWI2Szs7aUJBQVUsT0FBQSxvQkFmTEUsU0FBUS9LO1NBRVhPLGVBQU55SztLQUNHLEdBQUEsV0FKd0Q5MUIsT0FHM0Q4MUIsV0FGU0Q7VUFLSEUseUJBTndCTCxnQkFHOUJJLFlBRlNEO01BQUFBLFVBS0hFO2NBSEExSzs7O01BU08sa0JBWEp3SyxTQUFRL0s7TUFBUitLLFVBRVRDO01BRmlCaEw7Y0FFWE87OztHQWF1QjtZQUkvQjJLLGVBQWVob0IsTUFBTWpPO0lBQ3ZCLEdBRGlCaU8sUUFBQUE7S0FLRjtNQURUaE87aUJBQU0rZixLQUFFL21CLEdBQUssYUFBQSxXQUpJK0csU0FJWGdnQixLQUFFL21CLFdBQXFCO01BQzdCaTlCLFNBQVMsaUJBTEVqb0IsTUFBTWpPO0tBTXJCLE9BMUJBMDFCLGlDQXlCSVEsUUFEQWoyQjs7SUFGVSxPQUZDZ087R0FNNEI7WUFHM0Nrb0IsV0FBV3hwQixHQUFHM007SUFDaEIsSUFDYWsyQixTQURBLGlCQURBdnBCLEdBQUczTSxVQUVIbzJCLE1BQUFGO0lBQ1g7UUFEV0U7VUFBQTlLLEtBQUE4SztTQUFBOUs7V0FHRCtLLE1BSEMvSyxPQUdUZ0wsTUFIU0Y7T0FHcUIsU0FBQSxXQUxsQnAyQixTQUtaczJCLEtBQVFELE1BQStDLFdBQXZEQztPQUhTRixNQUFBOUs7Ozs7S0FFSzs7R0FHUDtZQUdUaUwsYUFBYUMsS0FBS3gyQjtJQUNwQixPQVhFbTJCLFdBVWFLLEtBQUt4MkI7R0FHTDtZQUdieTJCLGNBQWM5cEIsR0FBRzNNO2FBSWZnQixVQUFRK0wsR0FBRUM7S0FBUyxVQUFBLFdBSkpoTixTQUlQK00sR0FBRUM7S0FBUyxPQUFBO0lBQVc7SUFDckIsSUFBVGtwQixTQUFTLGlCQUxHdnBCLEdBSVozTDtTQUNBazFCLFFBYUk7O0tBWEtRLFdBRlRSO0tBRWdCUyxTQUZoQlQ7S0FFU1UsV0FBQUY7S0FBT0csT0FBQUY7S0FBTUc7S0FBaUIzVTtJQUN6QztVQURXeVUsVUFFSCxPQUZpQ3pVO1NBQTlCNFUsV0FBQUgsYUFBT0ksU0FBUEo7S0FJTixTQVBINTFCLFVBR2dCNjFCLE1BQUFHO1NBQU1GO09BQWJGLFdBQUFHO09BQU9GLE9BQUFHO09BQU1GOzs7T0FRaUIsSUFSQWpELFlBQXZCbUQsUUFBdUI3VTtPQUE5QnlVLFdBQUFHO09BQU9GLE9BQUFHO09BQU1GO09BQWlCM1UsTUFBQTBSOztVQUE5QitDLFdBQUFHLFVBQU9GLE9BQUFHLFFBQU1GOztHQVl5QjtZQVNqREcsVUFBVXBuQixLQUFHNVA7SUFDZixLQURZNFAsS0FFSjtRQVJXcWdCLE9BTVByZ0IsUUFHVm1RLE1BSFVuUSxRQU5PbEcsSUFBQXVtQjtJQUNuQjtRQURtQnZtQjtNQUdOLElBSE04SCxLQUFBOUgsTUFHakIxUSxJQUhpQjBRLE1BR04sTUFBQSxXQUdFMUosT0FIYmhILEdBTUErbUI7TUFOVyxRQUhNclcsSUFBQThIOzs7OztLQVNILGlCQUFkdU87O0dBQTREO1lBRzVEK0IsTUFBTXBZLEdBQUdDO0lBQUksT0FBQSw4QkFqaUJiaWdCLFdBaWlCTWxnQixHQUFHQztHQUE4QjtZQUN2Q29ZLElBQUltQixHQUFFeFosR0FBR0M7SUFBSSxPQUFBLDhCQWxpQmJpZ0IsV0FraUJJMUcsR0FBRXhaLEdBQUdDO0dBQThCO1lBQ3ZDMlksUUFBUTVZLEdBQUczSjtJQUFVLE9BQUEsOEJBbmlCckI2cEIsV0FtaUJRbGdCLEdBQUczSjtHQUE0QztZQUN2RHlpQixRQUFROVksR0FBRzNKO0lBQVUsT0FBQSw4QkFwaUJyQjZwQixXQW9pQlFsZ0IsR0FBRzNKO0dBQTRDO1lBRXZEazNCLE9BQU92dEIsR0FBR0M7SUFDWixPQXJURXlwQjthQW9UTzFwQjs7c0JBQ2V3dEIsS0FBSXBWLE9BQU1oVjtjQUFLLE9BQUcsV0FEOUJuRCxHQUNZdXRCLEtBQVVwcUI7d0JBQXFCLDRCQUEzQmdWO3dCQUFBQTthQUErQztHQUFDO1lBRzFFMVksS0FFVzhTLEdBRkh2UztJQUNWLEdBQ2F1UyxPQURDLFdBejVCWjdVLG1CQTA1Qlc2VTtRQUFBdlosSUFBQXVaLEdBQUU0TztJQUNiO1lBRFdub0IsR0FDWCxNQUFBO2NBRFdBLEdBRUcsT0FGRG1vQjtLQUV5QjtNQUZ6QkcsY0FFMEIsV0FKL0J0aEIsR0FJaUMsNEJBRjlCaEgsUUFBRW1vQjtNQUFGdGMsTUFFbUIsNEJBRm5CN0w7S0FBQUEsSUFBQTZMO0tBQUVzYyxRQUFBRzs7R0FJTjtZQUdQa00sZUFDV3pxQixHQURPL0M7SUFDcEIsSUFBYXdzQixNQUFBenBCLEdBQUVvZTtJQUNiO1VBRFdxTCxLQUVILE9BRktyTDtLQUlKLElBSkVPLEtBQUE4SyxRQUdUL0ssS0FIUytLLFFBSUYsUUFBQSxXQUxTeHNCLEdBSWhCeWhCOztNQUVxQixJQUFicHlCLGNBTEdpeUIsY0FLSGp5QixHQUxHOHhCO01BQUZxTCxNQUFBOUs7TUFBRVAsUUFBQUc7OztNQUFGa0wsTUFBQTlLOztHQVFKO1lBR1ArTCxXQUFXMXFCLEdBQUcvQyxHQUFJLE9BQUksZ0JBWnRCd3RCLGVBWVd6cUIsR0FBRy9DLElBQTZCO1lBRTNDMHRCLGdCQUNhM3FCLEdBRE0vQztJQUNyQixJQUFhaEgsT0FBRXd6QixNQUFBenBCLEdBQUVvZTtJQUNmO1VBRGFxTCxLQUVMLE9BRk9yTDtLQUlOLElBSklPLEtBQUE4SyxRQUdYL0ssS0FIVytLLFFBSUosUUFBQSxXQUxVeHNCLEdBQ1JoSCxHQUdUeW9COztNQUU2QjtPQUFyQnB5QjtPQUxLaXlCLGNBS0xqeUIsR0FMSzh4QjtPQUFKdGMsTUFLUyw0QkFMVDdMO01BQUFBLElBQUE2TDtNQUFFMm5CLE1BQUE5SztNQUFFUCxRQUFBRzs7VUFNRyxJQU5QcU0sTUFNTyw0QkFOUDMwQixPQUFBQSxJQUFBMjBCLEtBQUVuQixNQUFBOUs7O0dBUUo7WUFHVGtNLFlBQVk3cUIsR0FBRy9DLEdBQUksT0FBSSxnQkFadkIwdEIsZ0JBWVkzcUIsR0FBRy9DLElBQThCO1lBQzdDNnRCLFdBQVc5cUIsR0FBSSxPQWZmMHFCLFdBZVcxcUIsaUJBQUksY0FBcUI7WUFFcEMrcUIsZUFDVy90QixHQURPQztJQUNwQixJQUFhaUcsTUFBQWxHLEdBQUVoRCxTQUFJRSxTQUFJOHdCO0lBQ3JCO1VBRFc5bkI7TUFFZSxJQUFBLE1BQUEsZ0JBRkw4bkIsTUFFSixNQUFBLGdCQUZBOXdCO01BRVQsV0FBQSxnQkFGS0Y7O0tBSUosSUFKRW1KLE1BQUFELFFBR1Q1VyxJQUhTNFcsUUFJRixRQUFBLFdBTFNqRyxHQUloQjNROztNQUd3QixJQUFoQkMsY0FOTzRrQixZQU1QNWtCLEdBTk8yTjtNQUFOZ0osTUFBQUM7TUFBTWpKLE1BQUFpWDs7O01BT2EsSUFBcEJELGdCQVBXK1osWUFPWC9aLEtBUFc4WjtNQUFWOW5CLE1BQUFDO01BQVU2bkIsTUFBQUM7O1VBS0MsSUFBWkMsZ0JBTEdqYSxZQUtIaWEsS0FMR2x4QixNQUFGa0osTUFBQUMsS0FBRW5KLE1BQUFpWDs7R0FTQTtZQUdia2EsYUFBYW51QixHQUFHQzthQUNkbXVCLElBQUU5K0IsR0FBaUIsT0FBRyxXQURSMlEsR0FDWjNRLFNBQUFBLFNBQUFBLEdBQWtEO0lBQ3hELE9BQUEsMEJBRmUwUSxHQUNYb3VCO0dBQ2M7WUFHaEJDLGlCQUFpQnJ1QjtJQUFJLE9BQUEsMEJBQUpBO0dBQXVDO0dBYXhELFNBUkVzdUIsWUFRRUMsVUFBWUMsVUFBWUM7SUFDMUIsT0FBQTs7c0JBTU1DO2NBTEosU0FLSUE7eUJBQUFBOzs7O2lCQUhpQjtrQkFEZ0JDO2tCQUFaQztrQkFDakJDLFdBQWEsV0FKckJOLFVBR3lCSztrQkFFakJFLFdBQWEsV0FMVE4sVUFHeUJHO2lCQUdqQyxXQUZJRSxVQUNBQzs7OztjQUdKLE9BQUE7b0RBVEo3TyxxQkFRSXlPO2FBSWE7YUFYT0Q7R0FZakI7WUFHVE0sWUFPRUMsVUFBWUMsVUFBWUM7SUFDMUIsT0FBQTs7O2NBQ0U7ZUFBa0JDO2VBQVpDO2VBQ0M1ZCxXQUFhLFdBSHBCd2QsVUFFTUk7ZUFFQ0MsV0FBYSxXQUpSSixVQUVNRTtjQUdmLGVBRkkzZCxjQUNBNmQ7YUFDMEM7YUFMekJIO0dBTWpCO1lBR1JJLGlCQUtDbmEsZ0JBQWlCQztJQUNuQixPQUVNOztxQkFISkQsb0JBQWlCQztHQUloQjtZQUtIbWEsY0FFQWpyQjtJQUZnQixLQUVoQkEsTUFETSxNQUFBO1FBQ0xrckIsSUFBRGxyQjtJQUF1QixXQUF0QmtyQixHQXBQc0JudkIsSUFvUHZCaUU7R0FBeUM7WUFHekNtckIsUUFBTUMsT0FBT3A1QjtJQUNmLE9BeFB5QitKO2FBdEd6QnFxQjtlQTZWUWdGOztnQkFDVyxJQUFhbmdDLFlBQVBEO2dCQUFvQixXQUFBLFdBRDlCZ0gsT0FDVWhILEdBQU9DO2VBQXlCO2FBTnZEZ2dDO0dBTStFO1lBRy9FSSxpQkFBZUQsT0FBT3I1QjtJQUN4QixPQTVQeUJnSzthQXBHekJzcUI7ZUErVmlCK0U7O2dCQUNhLElBQWFuZ0MsWUFBUEQ7Z0JBQWdCLE9BQUEsV0FENUIrRyxTQUNZL0csR0FBT0M7ZUFBcUI7YUFWOURnZ0M7R0FXcUI7WUFHckIxVixPQUFLN1osR0FBRzFKLE9BQU1zNUI7SUFDVjs7T0EzdkJONVc7U0EwdkJPaFo7O1VBQ1MsSUFBTTZ2QjtVQUFZLE9BQUEsV0FEeEJ2NUIsT0FBTXM1QixLQUNNQztTQUEyQjtnQkFDdkM7UUFDSHZnQztJQUFLLFdBQUssNkJBQVZBO0dBQWlCO0dBSVIsSUFBWndnQztZQURGQyxXQUVXL3ZCLEdBQUcxSixPQUFNczVCO0lBQ2QsWUFUTi9WLE9BUVc3WixHQUFHMUosT0FBTXM1QjtnQkFFVixNQUFBLDRCQUhSRTtRQUlLRTtJQUFTLE9BQVRBO0dBQWM7WUFNckJDLE1BQUlqd0IsR0FBRzFKLE9BQU1zNUIsS0FDZixPQWxCRS9WLE9BaUJJN1osR0FBRzFKLE9BQU1zNUIsYUFHQztZQUdkTSxPQUFPbHdCLEdBQUcxSixPQUFNczVCO0lBQU0sT0F6eUJ4QmhNO2FBeXlCUzVqQjs7Y0FBMkIsSUFBTTZ2QjtjQUFnQixXQUFBLFdBQTlDdjVCLE9BQU1zNUIsS0FBd0JDO2FBQWlDO0dBQUE7WUFFekVNLElBQUlud0IsR0FBRzFKLE9BQU1zNUIsS0FBSUk7SUFFbkIsZUFGZUosS0FBSUksUUFGakJFLE9BRUlsd0IsR0FBRzFKLE9BQU1zNUI7R0FFb0I7WUFHakNRLFFBQVFwd0I7SUFBSSxPQTlSV0s7YUE4UmZMOztjQUFhLElBQVN6USxjQUFIRDtjQUFTLFdBQU5DLEdBQUhEO2FBQWM7R0FBQTtZQUN6QytnQyxNQUFJcndCLEdBQUdDO0lBQUksT0EvUllJO2FBK1JuQkw7O2NBQWdCLElBQVdnd0Isa0JBQUxKO2NBQWUsV0FBZkEsS0FBb0IsV0FBdkMzdkIsR0FBd0IrdkI7YUFBdUI7R0FBQTtZQUd4RG53QixJQUFJbUQsR0FBRzBYLEtBQUt2YjtJQUdkLFVBSFN1Yjs7OztlQUFLdmI7Ozs7TUFHaUI7T0FBQSxNQUFBLG1CQUh6QjZEO2FBR3lCLGlDQUhqQjdELE9BQUx1Yjs7WUFHMEM7SUFFakQsT0FBQTs7YUEvZEFnUDtlQTBkSTFtQjs7d0JBS3NCL0osR0FBRXVmLEtBQUk4WDtnQkFDN0IsR0FOSTVWLE9BS21CemhCLEtBQUFBLElBQ0osNEJBTmZ5aEIsS0FBS3ZiO2lCQU15QixXQURMbXhCLElBQUo5WDtnQkFDd0IsT0FEeEJBO2VBQzJCO0dBQUU7WUFHekQrWCxRQUFRQyxRQUlLaGU7SUFIZixRQUdlQSxHQUZWLGNBRktnZTtRQUlLL2QsTUFBQUQsR0FBRXhTLElBSlB3d0IsUUFJU3BQO0lBQ2Y7Y0FEVzNPLEtBRU4sV0FBQSxnQkFGVTJPLFFBQUZwaEI7VUFBQUEsR0FLSCxXQVRKd3dCO0tBVTBCO01BTm5CN08sS0FBQTNoQjtNQU1UMGhCLEtBTlMxaEI7TUFBRXVoQixjQU1YRyxJQU5XTjtNQUFKMU8sTUFNVSw0QkFOVkQ7S0FBQUEsTUFBQUM7S0FBRTFTLElBQUEyaEI7S0FBRVAsUUFBQUc7O0dBUUE7WUFJakJrUCxLQUllRCxRQUFGaGU7SUFIZixRQUdlQSxHQUZWO1FBRVVDLE1BQUFELEdBQUV4UyxJQUFBd3dCLFFBQUVwUDtJQUNmO2NBRFczTyxLQUVOLE9BQUEsZ0JBRlUyTztVQUFGcGhCLEdBRFosT0FDWXd3QjtLQU1tQjtNQU5uQjdPLEtBQUEzaEI7TUFNVDBoQixLQU5TMWhCO01BQUV1aEIsY0FNWEcsSUFOV047TUFBSjFPLE1BTVUsNEJBTlZEO0tBQUFBLE1BQUFDO0tBQUUxUyxJQUFBMmhCO0tBQUVQLFFBQUFHOztHQVFBO1lBR2JtUCxLQUFLMXdCLEdBQUV3UztJQUNiLElBRUV0TSxNQUhTbEcsR0FBRXlTLE1BQUFEO0lBQ2I7UUFFRXRNO1VBSFN5YixLQUdUemI7TUFEYSxPQUZGdU07T0FFbUIsSUFGbkJDLE1BRW1CLDRCQUZuQkQ7T0FHWHZNLE1BSFN5YjtPQUFFbFAsTUFBQUM7Ozs7S0FHTixPQUFMeE07O0dBQU07WUFHTnlxQixVQUV3QjN0QixHQUZYbEI7SUFDZixHQURlQSxhQUNLLFdBem1DbEJuRSxtQkF3bUNhbUU7UUFFTzBXLFNBQUlpVSxNQUFBenBCO0lBQ3hCO1VBRHdCeXBCLEtBRWhCLE9BQUEsZ0JBRllqVTtLQUlEO01BQUEsUUEzQ25CK1gsUUF1Q3dCOUQsS0FGWDNxQjtNQUVXOHVCO01BSWxCQztNQUpjM0csWUFJZDJHLFNBSmNyWTtLQUFBQSxNQUFBMFI7S0FBSXVDLE1BQUFtRTs7R0FPWDtZQUdiRSxZQUFZaHBCLElBQUk3SDtJQUNsQixJQUFhdVksU0FFVHhZLElBSFU4SDs7UUFHVjlIO1VBRE0yaEIsS0FDTjNoQixNQURBMGhCLEtBQ0ExaEI7TUFEYyxHQUFBLFdBRkFDLEdBRWR5aEI7T0FBMkIsZ0JBQTNCQSxJQURTbEo7T0FBQUE7T0FFVHhZLElBRE0yaEI7Ozs7S0FDRCxXQUFBLGdCQUZJbkosTUFFVHhZOztHQUVNO1lBSVIrd0IsV0FBV2pwQixJQUFJN0g7SUFDakIsSUFBYXVZLGlCQURBMVE7OztVQUVINlosZUFBTkQ7TUFBYyxHQUFBLFdBRkR6aEIsR0FFYnloQjtPQUEyQixnQkFBM0JBLElBRFNsSjtPQUFBQTtlQUNIbUo7Ozs7S0FDRCxPQUFBLGdCQUZJbko7O0dBSUg7WUFHSndZLFdBQVdoeEIsR0FBR0M7SUFDcEIsSUFFRWlHLE1BSGVsRztJQUNqQjtRQUVFa0c7VUFIZXliLEtBR2Z6YixRQURBd2IsS0FDQXhiO01BRGMsR0FBQSxXQUZJakcsR0FFbEJ5aEIsS0FDQXhiLE1BSGV5Yjs7S0FHVixPQUFMemI7O0dBQU07WUFHTitxQixVQUFVanhCO0lBQ04sWUFBQSxnQkFETUE7Z0JBRUo7UUFDRDZzQjtJQUFPLFdBQUssZ0JBQVpBO0dBQXFCO1lBRzFCcUUsY0FBY2x4QjtJQUNWLFlBUEppeEIsVUFNY2p4Qjs7S0FFTixPQUFBO1FBQ0g2c0I7SUFBTyxPQUFQQTtHQUFVO1lBR2ZzRSxrQkFJYUMsT0FBR0M7SUFIbEIsR0FBRyxxQkFHZUEsUUFGYjtRQUVVanZCLEtBQUFndkIsT0FBTWhRO0lBQ2pCO1VBRFdoZixJQUtULE9BQUEsZ0JBTGVnZjtTQUFOTyxLQUFBdmYsT0FHVHNmLEtBSFN0ZjtTQUdUc3BCLE9BQUFoSztLQUF1QjtNQUhSSDtRQUdRO3NCQXRZRmxoQixJQW1ZVGd4QixnQkFHb0MvaEMsR0FBSyxXQUFyRG84QixNQUFnRHA4QixHQUFVLElBSDNDOHhCO0tBQU5oZixLQUFBdWY7S0FBTVAsUUFBQUc7O0dBS087WUFHMUJoaUIsT0FBT3lELEdBQUksT0FBQSx1QkFBSkEsR0Fqd0JQM0QsV0Fpd0IwQztZQUMxQ2l5QixnQkFBZ0J0dUI7SUFBSSxPQUFtQjthQXR6QnZDa2Q7YUFzekJnQmxkOztzQkFBNEJ3VixLQUFJeFYsR0FBSyxPQUFBLHVCQUFMQSxHQUFKd1YsS0FBeUI7R0FBQztZQUN0RStZLEtBQUtqaUMsR0FBRTBULEdBQUksV0FBTjFULEdBQUUwVCxHQUFVO1lBRWpCd3VCLFVBQ1d4dUIsR0FERTNNO0lBQ2YsSUFBYW8yQixNQUFBenBCO0lBQ1g7UUFEV3lwQjtVQUFBdHBCLE9BQUFzcEI7U0FBQXRwQjs7UUFHRnloQixLQUhFemhCO1FBR1R3aEIsS0FIUzhIO2NBR2tCLFdBSmhCcDJCLFNBSVhzdUIsSUFBT0M7O09BSEU2SCxNQUFBdHBCOzs7O0tBRUs7O0dBR1o7WUFHSnN1QixtQkFDV3p1QixHQURXM007SUFDeEIsSUFBYW8yQixNQUFBenBCO0lBQ1g7UUFEV3lwQjtVQUFBdHBCLE9BQUFzcEI7U0FBQXRwQjs7UUFHRnloQixLQUhFemhCO1FBR1R3aEIsS0FIUzhIO2NBR2tCLFdBSlBwMkIsU0FJcEJzdUIsSUFBT0M7O09BSEU2SCxNQUFBdHBCOzs7O0tBRUs7O0dBR1o7R0FHTyxnQkF2eEJYOUQ7WUEyeEJBNGYsUUFBVXBaLEtBQXFDdkI7SUFDakQsR0FEWXVCO1NBQWVDLE1BQWZELFFBQUFxWixlQUFlcFo7O1NBQWZvWjtJQUNaLEdBRGlENWE7ZUFBQUE7OztPQU1yQyxJQUFOb3RCLE1BQU0sNEJBTnFDcHRCO09BTy9DLHVDQVBVNGEscUJBTU53UztPQUNKLE9BQUEsNEJBRElBOztVQUZDbmlDLFlBQUhELElBSjZDZ1Y7TUFJaEMsT0FBQSxnQ0FKTDRhO29CQUlMM3ZCLE9BQUhEO2dCQUo2Q2dWOzs7SUFHakMsT0FIaUNBO0dBUTlCO1lBR2pCcXRCLG1CQUFxQjlyQixLQUFxQ3ZCO0lBQzVELEdBRHVCdUI7U0FBZUMsTUFBZkQsUUFBQXFaLGVBQWVwWjs7U0FBZm9aO0lBQ3BCLEdBQUEscUJBRHlENWE7S0FFdkQsT0FBQTtJQUM0QyxVQUFBLG1CQUhXQTtJQUcxQyxPQXBsQ2hCdWQsUUFpbEMwRHZkLE1BRzFDLCtCQUhLNGE7R0FHd0M7WUFHN0QwUyxlQUFpQi9yQixLQUFxQ3ZCO0lBQ3hELEdBRG1CdUI7U0FBZUMsTUFBZkQsUUFBQXFaLGVBQWVwWjs7U0FBZm9aO0lBQ25CO0tBQUksY0FQRnlTLHVCQU1pQnpTLGVBQXFDNWE7S0FDcEQ7O2VBQ0c7R0FBSTtZQUdMak4sVUFBUXc2QixLQUFJenVCLEdBQUVDO0lBQ3BCLElBRGtCc0UsTUFBQXZFLEdBQUV3RSxNQUFBdkU7SUFDcEI7VUFEa0JzRSxZQUFFQztVQUFBQSxLQUlUO0tBRUQ7TUFOVUMsS0FBQUQ7TUFLVHJZLElBTFNxWTtNQUFGRSxLQUFBSDtNQUtoQnJZLElBTGdCcVk7TUFNWjZLLElBQUksV0FOSXFmLEtBS1p2aUMsR0FBU0M7S0FFVCxTQURJaWpCLEdBQ2lDLE9BRGpDQTtLQU5ZN0ssTUFBQUc7S0FBRUYsTUFBQUM7O0dBT29CO09BR3RDbkM7WUFFQXBQLE1BQ1lBLE9BQU04SyxJQUFHQztJQUF2QixJQUFvQjZaLE9BQUE5WixJQUFHK1osT0FBQTlaO0lBQ3JCO1FBRGtCNlo7U0FBR0M7T0FHRztRQUhIMlcsT0FBQTNXO1FBR1R5SixLQUhTeko7UUFBSDRXLE9BQUE3VztRQUdoQnlKLEtBSGdCeko7UUFHTSxNQUFBLFdBSFo1a0IsT0FHVnF1QixJQUFVQztPQUFZLFVBQUE7T0FITjFKLE9BQUE2VztPQUFHNVcsT0FBQTJXOzs7O2VBQUEzVyxNQUVUO0tBRUw7O0dBRVE7WUFHZjZXLFVBbUJFQztJQUFLLElBWGtCQyxPQVd2QkQsUUFWY0UsYUFBUUM7SUFDeEI7U0FUNkJweUIsSUFPSmt5QixNQUl2QkcsZ0JBQVFDLGtCQUFjQztLQVZ4QjtXQUQ2QnZ5QjtrQkFBQUE7O09BS2lCO1FBTGpCMmhCLEtBQUEzaEI7UUFJckI4SDtRQUFMeFk7UUFKdUNrakMsY0FJbEMxcUIsSUFPRXdxQjtRQVhxQkcsbUJBSTVCbmpDLEdBT0QraUM7T0FYMkJyeUIsSUFBQTJoQjtPQVczQjBRLGFBWDZCSTtPQVdyQkgsZUFYZ0NFOztlQUFidkcsT0FBQWpzQixNQUFBQSxJQUFBaXNCLE1BV0xzRzs7VUFBdEJGLGdCQUFRQyxjQURLLFdBQUssZ0JBRkpIO0tBSWQsR0FEc0JJLGFBRWpCO0tBR0g7TUFESUcsU0FQZ0JOLFNBT1EsZ0JBSjlCQyxjQUFBQTtNQUhzQk0sZUFBQVA7TUFBUlEsZ0JBT1JGLFFBUFFQO0tBRFNELE9BSWZJO0tBSE1ILFVBQUFTO0tBQVFSLFNBQUFPOztHQVVIO0dBR3pCOzs7R0FHRTs7Ozs7O01BRUU7T0FPUyxNQUFBO01BTFk7T0FEd0JFO09BQ3JDQyxXQUFhLCtDQUR3QkQ7TUFFekMsd0JBRElDO0tBS2M7WUFLdEJDLGNBQWMvdkI7SUFDVixZQXhDSmd2QixVQXVDY2h2Qjs7S0FHTixNQUFBO2lEQTNmaUIzQyxJQXdmWDJDO1FBRVR5cEI7SUFBSyxPQUFMQTtHQUNxRTtZQUcxRXVHLFlBQVloekIsR0FBR3VTO0lBQ2pCLEtBRGN2UyxHQUVOO1FBQ0Q4SCxLQUhPOUgsTUFHWjFRLElBSFkwUTtJQUdEO1lBQVgxUTtZQUFnQjs7Y0FBWHdZO3VCQUEwQ3ZZLEdBQUVpcEIsS0FBTyxXQUh6Q2pHLFNBR2dDaGpCLEdBQUVpcEIsTUFBc0I7O0dBQUM7WUFHeEVELFlBQVl2WSxHQUFHTixNQUFNTztJQUFJLE9BQUEsOEJBOTZCekJpZ0IsV0E4NkJleGdCLE1BQU1PLEdBQVREO0dBQW1EO1lBQy9EMFksV0FBVzFZLEdBQUdOLE1BQU1PO0lBQUksd0NBLzZCeEJpZ0IsV0ErNkJjeGdCLE1BQU1PO0lBQUkscUIsNEJBQWJEO0dBQWtEO1lBRTdEaXpCLFVBQVUzdUIsTUFBTTR1QixRQUFjdnFCO0lBQ2hDO0tBQUl3cUIsV0FBVyxtQkFESDd1QjtLQUVSOHVCLGFBQWEsbUJBRkNGO1dBRWRFLGNBREFEOztjQWpFRjc4QjtlQWdFOEJxUztlQTdMMUIrbkIsS0E2TE1wc0IsTUFHeUMsNEJBRmpENnVCLFVBQ0FDO2VBRmNGOztHQUdrRTs7OztPQS9FOUU3N0I7T0FVSnFPO09BeHRDRWdMO09BQ0E1RztPQUVDRjtPQTRPSHlROzs7O09BMEhBNkY7T0E4NkJBM0g7T0FDQUc7OztPQTdZQUw7T0FsbkJBVztPQXRCQUQ7T0F5R0FqWjtPQURBbVo7T0FpaUJBTDtPQUNBRTtPQW4yQkFqUDs7UUE0c0JFc0U7UUFFQXBlO1FBRUFzZjtRQURBRjtRQUpBTTtRQWpDQXliO1FBbUNBQztZQU9FdjJCLFVBRUFFLFVBREFELFVBb0JxQjJZO1FBQUFEO1FBQUFDO1lBQUFELGFBQUFDO1FBQUFvZDtRQUFBemQ7UUFBQTlNO1FBQUFxTjtRQUFBQztRQUFBMUQ7UUFBQTJEO1lBQUFULFVBQUFJLGFBQUFDO09BQUFEO09BQUFDOztPQUFBb2Q7T0FBQXpkO09BQUFPO09BQUFDO09BQUExRDtPQUFBMkQ7OztPQXh1QnpCaE87T0EyREFnaUI7T0FZQUM7OztPQU1BQzs7T0FzRkFrQjtPQUZBRDtPQVNBRztPQUZBRDtPQVNBRztPQUZBRDtPQTRIQW9CO09BbkhBakI7T0FGQUQ7T0E4SEFtQjtPQXJIQWhCO09BRkFEO09BeUJBSztPQVJBRjtPQXNXQWlHOztPQTBWQW9FO09BYUFJO09BS0FFO09BbUhBa0M7OztPQTNYQXhGO09Bem1CQXJKO09BTUFDOzs7T0E0TUFzQztPQVNBRTtPQXBCQUg7T0FuQkFGO09BaURBTTtPQVlBRTtPQWtGQWpsQjtPQXNYeUJnQjtPQW5UekJ5bkI7T0FnR0EwQjtPQXhGQXhCO09BZ0dBeUI7T0EyTXlCbUI7T0F4RnpCQztPQXBNQTNDO09BRkFwWjtPQW1CQStaO09BRkFEO09BVUFHO09BRkE5WjtPQU9JK1o7O09BNUtKOUk7T0FrTEFqZTtPQVNBa25CO09BY0FHO09BTEFEO09BaUJBL29CO09BUkFpcEI7T0E2QkFucEI7T0FRQXNwQjtPQWNBRztPQU5BRDtPQVlBRTtPQXdDQU87T0FzQkFLO09BaEJBSjtPQWtCQUs7T0FvYkFnRztPQXJVSXRGO09BUkFEO09BZUFFO09BcWZKMkg7T0E1ZUF0SDtPQWFBSTtPQW9CQU87T0FTQUU7T0FVQUk7T0FNQUU7T0E0QkFRO09BTUFsVjtPQUtBbVY7T0ExekJBL0w7T0F4Q0FkO09BczJCQWhoQjtPQVNBK3RCO09BY0FFO09BRkFEO09BY0FHO09BQ0FDOztRQXlCRVE7UUF1QkFTO1FBZ0JDTztRQXFERGE7UUF6QkF0VztRQU1Ba1c7UUFXQUU7UUFNQUM7UUFRQUc7UUFEQUQ7UUF2Q0FYO1FBSUFFO09BdUNGOXZCO09BeUJBNHdCO09BZUlDO09BMkJKSztPQVFJQztPQWpCSkY7T0F1QkFHO09BTUFDO09Ba0JBM3hCO09BQ0EreEI7T0FDQUM7T0FkQUo7T0FzQ0FsUztPQWlCQTJTO09BTkFEO09BakNBSDtPQVNBQztPQStDQW43Qjs7T0FVQTA3QjtPQXVDQWU7T0FNQUM7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7OztJQ3hvQ0NwcEI7SUFpRkdTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBbk5FUDtJQUNMOztPQUVvQixJQURHVSxxQkFDaEI2b0IsV0FBYSx5QkFERzdvQjtPQUVwQix3QkFESTZvQjs7T0FHYTtRQURWQztRQUNIQyxXQUFhLDZCQURWRDtPQUVQLHdCQURJQzs7T0FHYTtRQURiM29CO1FBQ0E0b0IsV0FBYSw2QkFEYjVvQjtPQUVKLHdCQURJNG9COztPQUdhLElBRFpDLHFCQUNEQyxXQUFhLHlCQURaRDtPQUVMLHdCQURJQzs7T0FHYTtRQURpQkM7UUFBWkM7UUFBWkM7UUFDTnBULFdBQWEsNkJBRFBvVDtRQUVOQyxXQUFhLHlCQUZLRjtRQUdsQkc7VUFBYTs2REFIaUJKO09BSWxDLHdCQUhJbFQsY0FDQXFULGNBQ0FDOztPQUlhO1FBREVDO1FBQVpuZjtRQUNIekQsV0FBYSw2QkFEVnlEO1FBRUhvZixXQXRCRm5xQixVQW9CaUJrcUI7T0FHbkIsd0JBRkk1aUIsY0FDQTZpQjs7T0FHYTtRQURnQkM7UUFBWkM7UUFBWkM7UUFDTG5qQixXQUFhLDZCQURSbWpCO1FBRUxDLFdBQWEseUJBRklGO1FBR2pCRyxXQTNCRnhxQixVQXdCK0JvcUI7T0FJakMsd0JBSElqakIsY0FDQW9qQixjQUNBQzs7T0FJYTtRQURJQztRQUFaQztRQUNMQyxXQUFhLCtDQURSRDtRQUVMRSxXQUFhLDZCQWhDZjVxQixXQThCbUJ5cUI7T0FHckIsd0JBRklFLGNBQ0FDOztPQUdhO1FBRFdDO1FBQVpsakI7UUFDWm1qQixXQW5DRjlxQixVQWtDYzJIO1FBRVpvakIsV0FBYSw2QkFGV0Y7T0FHNUIsd0JBRklDLGNBQ0FDOztHQUM4RTtZQU1oRkMsZUFBZTkwQixHQUFFdW9CO0lBS3ZCLElBTHFCcmlCLE1BQUFsRyxHQUFFMm9CLE9BQUFKO0lBS3ZCO1lBTHFCcmlCOztZQU1DOEUsT0FORDlFO1FBT25COztvQkFBZ0MsMEJBRFo4RSxPQU5DMmQ7O1lBUWRvTSxTQVJZN3VCLFFBUUYsV0FBVjZ1QixRQVJjcE07O1FBU1UsSUFBM0J2ZCxNQVRlbEYsUUFTWSxNQUFBLHdCQUEzQmtGO1FBQU8sV0FBQSxnQ0FUVXVkOztZQVVoQnFNLFNBVmM5dUI7UUFVTixXQUFBLDBCQUFSOHVCLFNBVmdCck07O1lBV05zTSxTQVhJL3VCLFFBV1RndkIsTUFYU2h2QjtRQVdRO2dCQUFqQmd2Qjs2QkFBZ0MsMEJBQTNCRCxTQVhNdE07O1lBWVR4aUIsTUFaT0QsUUFZWml2QixRQVpZanZCO1FBWUQsV0FBWGl2QixrQkFaSEwsZUFZUTN1QixLQVpTd2lCOztRQWNrQjtTQURuQnZpQixNQWJERjtTQWFMa3ZCLFNBYktsdkI7U0FhVm12QixRQWJVbnZCO1NBY29CLGlCQWRuQzR1QixlQWFnQjF1QixLQWJDdWlCO1NBY2pCMk0sV0FBTywwQkFER0Y7cUJBRWQsc0JBRlNDO2tCQUNMQztzQkFES0Qsa0JBQ0xDOztZQUlrQmhuQixLQWxCSHBJLFFBa0JWcXZCLGNBbEJVcnZCO1FBbUJuQixHQURTcXZCO1NBS0csSUFESC9sQyxNQUpBK2xDLGdCQUtEL2lCLElBQUkseUJBTFVsRTtZQUtka0UsS0FEQ2hqQjtjQUphZ21DLE9BQUFsbkI7O1VBUWtEO1dBQUEsTUFBQSw0QkFIaEVrRSxHQURDaGpCO1dBSW1CLGNBQVM7V0FBNUIsTUFBQSwyQkFSYThlLElBSWI5ZTtXQUphZ21DLE9BUWI7YUFQTEMsT0FEa0JEOzs7YUFDbEJDLE9BRGtCbm5CO1FBVVosVUFBQSwwQkFUTm1uQjtRQVNnQyxPQUFBOzs7aUJBNUJmOU07MEJBNEJvQkosSUFBR3ZvQjtrQkFDckI7bUJBRGtCMm9CLE9BQ2xCLHlCQURrQkosTUFBQUEsZ0JBQUFBO2tCQUNZLE9BN0JqRHVNLGVBNEJ3QzkwQixHQUFIMm9CO2lCQUN1Qjs7UUFaL0M7U0FERXpkLFlBaEJBaEY7U0FBQUcsTUFBQUg7U0FBRXd2Qiw4QkFnQkZ4cUIsV0FoQkV5ZDtRQUFGemlCLE1BQUFHO1FBQUVzaUIsT0FBQStNOztHQTZCNEM7WUFLN0RDLGFBQWEzMUIsR0FBRXVvQjtJQUNyQixPQURtQnZvQjs7T0FFYSxXQS9FMUI4SixVQTZFYTlKLElBQUV1b0I7O1dBR1p3TSxTQUhVLzBCLE1BR0EsZUFBViswQixTQUhZeE07O1dBSWZuZCxNQUphcEwsTUFJTixXQUFBLHdCQUFQb0wsTUFKZW1kOztXQUtkdmQsT0FMWWhMLE1BS0osV0FBUmdMLE1BTGN1ZDs7V0FNRXFOLE9BTko1MUIsTUFNRmcxQixTQU5FaDFCLE1BTVBrMUIsTUFOT2wxQjtVQU1JNDFCOztTQU9WQyxTQVBVRDttQkFPQSwwQ0FBVkM7OztPQU5YLHVCQURVWCxVQUFLRixnQkFOSXpNOztXQWVQcmlCLE1BZktsRyxNQWVWbTFCLFFBZlVuMUI7T0FlQyx1QkFBWG0xQixRQWZIUSxhQWVRenZCLFdBZk9xaUI7O09BaUJSO1FBRFNwaUIsTUFoQkhuRztRQWdCSGkxQixTQWhCR2oxQjtRQWdCUnExQixRQWhCUXIxQjtRQWlCYnMxQixXQURVTCxRQWhCVlUsYUFnQmdCeHZCO29CQUVwQixzQkFGU2t2Qjt5QkFDTEMsT0FqQmUvTTtpQ0FnQlY4TSxRQUNMQyxRQWpCZS9NOztPQXNCVCxJQURFamEsS0FyQkt0TyxNQXNCUCxNQUFBLDBCQURFc087T0FDd0IsT0FBQTs7O2dCQXRCakJpYTt5QkFzQnNCQSxJQUFHdm9CLEdBQUssT0F0QjdDMjFCLGFBc0J3QzMxQixHQUFIdW9CLElBQXlCOztXQUgvQ3JkLFlBbkJGbEwsTUFtQkRvRyxNQW5CQ3BHO09Bb0JqQixtQkFJQTgxQixZQUxnQjF2QixjQUFHOEUsa0JBbkJBcWQ7O0dBc0JnRDtZQUVuRXVOLFlBQVk5MUI7SUFDUixJQUVKKzFCLFFBM0JJSixhQXdCUTMxQjtPQUdaKzFCLFdBQUFBLGNBREUvcUIsT0FDRitxQixVQURZLE9BQVYvcUI7SUFDTyxXQUFUK3FCO0dBQXdCO1lBS3hCOXBCLFFBQVFoTTtJQUNWLElBQUksVUFBQSxXQURNQSxPQUNOO1VBQ0ZxTDtTQUFBRiwwQkFBQUU7S0FBTyxXQUFvQix3QkFBM0JGOztHQUE4QztZQVloRDRxQixXQVRVQztJQUFPLE9BTGZocUI7O2NBS2tDLHVCQUExQmdxQjs7d0JBQUFBO3NDQUFPLGdDQUFQQSxRQUFBQTthQUF5QztHQUFDO1lBVXBEQyxXQVRVbDJCLEdBQUksYUFBSkEsR0FBVTtZQU9wQjZKLGlCQUFjLFNBQUU7WUFNaEIrQixZQUFVNUwsR0FBSSxPQTNCWjgxQixZQXNCRkUsV0FLVWgyQixJQUFzQztZQUNoRDBRLFVBQVUxRixNQUFPLDJCQUFLLFdBQVpBLFNBQStCO1lBRXpDM1UsUUFBUStLLElBQUdDO0lBQUssSUFBNEIsTUFINUN1SyxZQUdXdkssS0FBa0IsTUFIN0J1SyxZQUdReEs7SUFBb0MsT0FBQTtHQUFjO1lBQzFEOUssTUFBTThLLElBQUdDO0lBQUssSUFBMEIsTUFKeEN1SyxZQUlTdkssS0FBZ0IsTUFKekJ1SyxZQUlNeEs7SUFBa0MsT0FBQTtHQUFjO1lBQ3REc0UsWUFBWU8sT0FBTWpHO0lBQTJCLFVBTDdDNEwsWUFLa0I1TDtJQUEyQixPQUFBLHlCQUFqQ2lHO0dBQThDO1lBQzFEb0QsS0FBS3JKLEdBQUksT0FBQSw2QkFEVDBGLGFBQ0sxRixHQUEwQjtZQUUvQm0yQixjQUFjbjJCO0lBQ1YsSUFFSm8yQixVQWhCQUosV0FhY2gyQjthQUdkbzJCLGdCQURPMTRCLElBQ1AwNEIsWUFEWSxPQUFMMTRCO0lBQ3VCLFVBdEM1Qm80QixZQXNDRk07SUFBOEIsT0FBQTtHQUE2QjtZQUczREMseUJBQXlCcjJCO0lBQUksSUFuRUZrRyxNQWdEM0I4dkIsV0FtQnlCaDJCLElBbkVvQixNQWhDdkM4MEIsZUFnQ3FCNXVCO0lBQWtCLE9BQUE7R0FtRStCO1lBQzVFeUYsZUFBZTNMO0lBQXdCLFVBZnZDNEwsWUFlZTVMO0lBQXdCLE9BQUE7R0FBYTtZQUNwRHMyQixRQUFRdHpCO0lBQUk7O2FBQWMsT0FuQ3hCaUo7O3VCQW1DbUM7MkNBQTdCako7Ozs2QkFBQUE7MkVBQUFBLEtBQUFBO3VCQUE2QjtzQkFBcUI7O0dBQUU7WUFDNUR1ekIsYUFBYXZ6QjtJQUFJOzthQUFjLE9BcEM3QmlKOzt1QkFvQ3dDOzJDQUE3QmpKOzs7NkJBQUFBOzJFQUFBQSxLQUFBQTt1QkFBNkI7c0JBQW1COztHQUFFO1lBQy9Ed3pCLFVBQVVDLFFBQVMsT0FBQSwwQkFBVEEsUUFBeUI7WUFDbkNsMUIsVUFBVTYwQjtJQUFVLE9BQWMsOEJBQXhCQTtHQUF3QztZQUNsRE0sUUFBUWhyQjtJQUFTLE9BQUEsMkJBRGpCbkssV0FDUW1LO0dBQXlDO1lBQ2pEaXJCLFNBQVMxMkI7SUFBSTs7YUFBYyxPQXhDekJnTSx3QkF3Q29DLFdBQU8sV0FBcENoTSxPQUEwQzs7R0FBRTtZQUVyRGYsT0FBUTAyQixNQUFNZ0IsUUFBTzFCLEtBQUk1bEMsR0FBRXVuQztJQUM3QixLQURnQkQ7S0FFRDs7Y0FBUyxPQTVDcEIzcUI7O3dCQTRDK0IsV0FGWmlwQixLQUUyQixXQUZyQjJCLFdBQUZ2bkMsSUFBakJzbUM7dUJBRTBEOztJQUM1QyxJQXZDWjUxQixRQW9DV2sxQixLQUdpQixXQUhYMkIsV0FBRnZuQyxJQUFqQnNtQztJQXBDVyxhQUFUNTFCO0dBdUMrQztZQUd6RCtLLFNBQVNDLE1BQU8sT0FBYyw4QkFBckJBLE9BQWdDO1lBQ3pDa3FCLElBQUlsMUIsR0FBR2sxQjtJQUFNLDZCQUFLLFdBQVhBLEtBbkNQYyxXQW1DSWgyQjtHQUF5QztZQUU3QzgyQixXQUFXOTJCLEdBQUdrMUI7SUFDaEI7O2FBQWMsT0FwRFZqcEI7O3VCQW9EcUI7d0JBQTZCLE1BdENwRCtwQixXQXFDV2gyQjsyQ0FBR2sxQjs7OzZCQUFBQTsyRUFBQUEsT0FBQUE7dUJBQ1M7c0JBQTBDOztHQUFFO1lBR25FNkIsTUFBTS8yQixHQUFHazFCO0lBQU0sT0FKZjRCLFdBSU05MkIsR0FBMkIsMEJBQXhCazFCO0dBQTJDO1lBRXBEOEIsUUFBUWgzQixHQUFFazFCLEtBQUk1bEMsR0FBRXVuQztJQUNsQjs7YUFBYyxPQTFEVjVxQjs7dUJBMERnRCxVQTVDbEQrcEIsV0EyQ1FoMkI7dUJBQ2UsV0FEYmsxQixLQUMyQixXQURyQjJCLFdBQUZ2bkM7c0JBQ2lEOztHQUFFO1lBR2pFc1EsUUFBUzIxQixhQUFZam5CO0lBQUs7O2FBQUs7cUJBQXRCaW5CO3FCQUE2QywwQkFBakNqbkIsSUEvQ3JCMG5COztHQStDaUY7R0FFckY7SUFBQTs7R0FNRTs7Ozs7O01BQWtFO09BSTlELE1BQUE7VUFISWgyQjtNQUFLLE9BbkRYNEwsWUFtRE01TDtLQUdTO1lBR2ZpM0IsT0FBT2ozQjtJQUNULEtBQU8sMEJBREVBLElBRUosZ0JBRklBOzt3QkFBQUE7OztVQUFBQTt3REFBQUEsS0FBQUE7dUJBTUEsZ0JBTkFBO1FBS09vTDtJQUFPLE9BQVBBO0dBQ0Q7WUFHYjhyQixPQUFRaHNCLFdBQVVFO0lBQ3BCLEdBRFVGO2lCQUFBQTs7b0JBSVk7O1VBQ054Tix3QkFBQUE7U0FKWnk1Qjs7O1NBQUFBO09BRGdCL3JCO1NBUWRwTCxJQVJjb0w7VUFDaEIrckIsYUFPYSxPQUFYbjNCO1NBQ1FvM0IsY0FSVkQ7S0FRNEIsNkJBQUEsV0FoRjlCbkIsV0ErRUloMkIsSUFDUW8zQjs7U0FSVkQsYUFTdUIsT0FBQSw4QkFWUC9yQjtRQVdWaXNCLGNBVk5GO0lBVXdCOzthQUFBLGVBQXNCLHdCQVg5Qi9yQixPQVdWaXNCOztHQUF3RTtZQU81RWp0QixHQUFHK0IsS0FBSW5NO0lBQW9DLFVBNUUvQ20yQixjQTRFV24yQjtJQUFvQyxPQUFBLDhCQUF4Q21NO0dBQXlEOztxREFBNUQvQixJQURBQzs7OztPQWhGSmhVO09BQ0FDO09BQ0FvUDtPQUNBMkQ7T0FMQXFIO09BREE5RTtPQUVDaEM7T0FSREM7T0FjQXNzQjtPQU9BeHFCO09BREEwcUI7T0FLQTkwQjtPQUhBKzBCO09BQ0FDO09BSUFJO09BSEFIO09BS0F0M0I7T0FNQTZMO09BVEEyckI7T0FVQXhCO09BTUE2QjtPQUpBRDtPQU1BRTtPQUlBcDNCO09Bd0JBczNCO09BVEFEOztXQXpMTW50QixXQTJITmtzQixZQUNBRTs7O0U7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7SUMxSUF0c0I7SUFTSVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDQUQ7O1lBVEprdEIsTUFBTXQzQjtJQUFJLE1BQU0sNEJBQUEsbUJBQVZBO0dBQW9CO1lBQzFCdTNCLFFBQVF2c0IsTUFBTyxPQURmc3NCLE1BQ3FCLHFCQUFidHNCLE9BQTRCO1lBQ3BDd3NCLFFBQVF4M0IsR0FBSSxPQUFKQSxFQUFLO1lBQ2J5M0IsUUFBUXozQixHQUFJLE9BQUpBLEVBQUs7O3FEQU1Ub0ssSUFEQUM7Ozs7Ozs7Ozs7T0FUSlQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FDQTB0QjtPQUNBQztPQUNBQztPQUNBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7SUNSQUY7Ozs7OztZQUVBMXRCLFVBQVUrckIsTUFBSzUxQixHQUFFOEosV0FBVTdKO0lBQzdCLElBQUksVUFBQSxXQUR5QkEsT0FDekI7VUFDRnFMO0tBSUs7TUFKTEYsMEJBQUFFO3lCQU1XLFdBUk14QixXQUFGOUo7NkJBT0QsNkJBTGRvTDtNQUlLO3VCQUFNLDBDQU5Ed3FCO0tBSVIsT0FBQTtjQU5GMkIsU0FNRTs7R0FLSztZQUdQRyxZQUFZMTNCLEdBQUVDLEdBQUVrUztJQUNsQjtLQUFJLFVBQUEsV0FEWWxTLEdBQ1YsMEJBRFlrUyxPQUFKblM7S0FDVjs7VUFDRnNMO0tBSStCO01BSi9CRiwwQkFBQUU7K0JBSTBELDZCQUoxREY7TUFJK0IsTUFBQSwwQkFOZitHO01BTVgseUJBQVc7S0FGZCxPQUFBO2NBbEJGb2xCLFNBa0JFOztHQUUwRTs0QkFsQjVFMXRCLFdBWUE2dEI7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7O0lDYkEvcEI7SUFBQUQ7SUFpRElQO0lBakRKTTtJQUFBRjtZQVFBbFgsUUFDRWdmLE9BQVF0TSxPQUFRQztJQUFXLE9BQUEsMkJBQTNCcU0sc0JBQVF0TSxPQUFRQztHQUErRDtZQUdqRjFTLE1BQ0UrZSxPQUFRc2lCLE9BQVFDO0lBQVcsT0FBQSwyQkFBM0J2aUIsc0JBQVFzaUIsT0FBUUM7R0FBMkQ7WUFHN0VseUIsWUFPRXlRLGFBQWE3TSxLQUFJQztJQUFPLE9BQUEsMkJBQXhCNE0sNEJBQWE3TSxLQUFJQztHQUFnRTtZQUduRm1ILFVBQ0VtbkIsVUFBWUM7SUFBVyxPQUFBLDJCQUF2QkQseUJBQVlDO0dBQStEO1lBRzdFaHVCLFVBQ0VpdUIsVUFBWUM7SUFBVyxPQUFBLDJCQUF2QkQseUJBQVlDO0dBQStEO1lBRzVFcHVCLGVBQ0N1TDtJQUFvQixPQUFBLDJCQUFwQkE7R0FBK0U7WUFLakZ0TCxVQUFVb3VCLGFBQVlqNEI7SUFDeEIsU0FEd0JBLFVBRW5Cb0QsSUFGbUJwRCxNQUVkLE9BQUEsV0FGRWk0QixhQUVQNzBCO1FBQ0dxVCxRQUhnQnpXO0lBR1AsT0FBQSwwQkFBVHlXO0dBQThCO1lBUWhDaEgsTUFBTXhQLEdBQUUzUTtJQUNWLE9BQTZDOzthQURyQzJRO2FBQUUzUTtzQkFDa0IyUSxHQUFFM1EsR0FBSyxPQUFBLFdBQVAyUSxHQUFFM1EsR0FBUTtzQkFBWTRvQyxJQUFHQztjQUFNLE9BQWMsa0NBQXZCRCxRQUFHQzthQUE4QjtHQUFDO0dBRzVFO0lBQU45M0I7a0RBTkE4TSxVQUVBc0MsT0FJQXBQOzs7Ozs7Ozs7Ozs7Ozs7OztJQWVpQjtJQUlyQm1XO0lBQ0FRO0lBQ0FDOzs7O1lBRUFPLFNBQVczUixLQUFtQjVGO0lBQ2hDLEdBRGE0RixTQUFZQyxNQUFaRCxRQUFBcUYsWUFBWXBGLGNBQVpvRjtJQUNiLElBQUksY0FBRyxXQUR5QmpMLFFBQzVCO1VBQ0ZxTDtTQUFBRiwwQkFBQUUsY0FGV0o7S0FFSixXQUFNLGdDQUFiRTs7R0FBa0Y7WUFHbEZndEIsY0FBZWx0QixXQUFVakw7SUFBSSxPQUFLLFdBbkZsQ3lOLE1BOEVBOEosU0FLZXRNLFdBQVVqTDtHQUFnQztZQUV6RHdYO0lBQVMsdUJBQ05ub0IsY0FBSyxPQUFMQTtRQUNHc29CO0lBQU8sT0FBQSwyQkFBUEE7R0FBc0I7WUFHNUJzZixPQUFRaHNCLFdBQVVFO0lBQU0sV0FBTSwyQkFBdEJGLFdBQVVFO0dBQXlDO1lBRTNEaXRCLGNBQWVudEIsV0FDZmtlO0ksU0FBQUEsTUFBYSxPQUFiQTtRQUNNaGUsTUFETmdlO0lBQ2EsT0FKYjhOLE9BRWVoc0IsV0FFVEU7O1lBR05xTCxNQUFPbWYsTUFBTWdCLFFBQU9SLFNBQVFoekIsR0FBRW9YO0lBQ2hDO1lBQU0sMkJBREdvYixNQUFNZ0IsUUFBT1IsU0FBUWh6QixHQUFFb1g7R0FDc0I7WUFHcEQ4ZCxRQUFRdHRCLE1BQU8sV0FBTSwyQkFBYkEsT0FBa0M7WUFDMUN1dEIsYUFBYW5DO0lBQVUsV0FBTSwyQkFBaEJBO0dBQXlDO1lBQ3REb0MsT0FBTzlzQjtJQUFTLE9BQUEsMkJBRGhCNnNCLGNBQ083c0I7R0FBNEM7WUFDbkR3cEIsSUFBSWwxQixHQUFHazFCO0lBQU07SUFBc0IsT0FBQTs7YUFBL0JsMUI7MkJBQVMsT0FBQSxxQkFBTmsxQjtHQUE0QztZQUNuRDZCLE1BQU0vMkIsR0FBR2sxQjtJQUFNO0lBQXNCLE9BQUE7O2FBQS9CbDFCOzJCQUFTLE9BQUEscUJBQU5rMUI7R0FBOEM7WUFDdkQ0QixXQUFXOTJCLEdBQUdrMUI7SUFBTTtJQUFzQixPQUFBOzthQUEvQmwxQjsyQkFBUyxPQUFBLHFCQUFOazFCO0dBQW1EO1lBRWpFOEIsUUFBUWgzQixHQUFFbzJCLFNBQVFoekIsR0FBRW9YO0lBQ3RCLE9BQXNCOzthQURaeGE7c0JBQ2lCNkU7Y0FBSyxPQUFoQywyQkFBMkJBLEdBRGZ1eEIsU0FBUWh6QixHQUFFb1g7YUFDNkM7R0FBQztZQUdsRWllLGNBQWMvNkI7SUFBSSxPQWZsQitZLCtCQWVjL1k7R0FBMEM7WUFDeER1YSxlQUFlalY7SUFBSSxJQUFBLHNCQUFpQixNQUFBLDRCQUFyQkE7Ozs7MkI7R0FBK0Q7WUFDOUVtVixvQkFBb0JuVjtJQUFlLFVBRG5DaVYsZUFDb0JqVjtJQUFxQyxPQUFBLGlEQUF3QixTQUFFO0dBQUM7WUFFcEYwMUIsdUJBQXVCMTFCO0lBQ3pCO0tBQWUsUUFBQSwwQkFEVUE7S0FDakJrVjtLQUFKMUI7SUFDSixPQURJQSxTQUFBQSxVQUVVLDhCQUZOMEI7R0FHSTtZQUdWeWdCLFFBQVEzMUI7SUFDSixZQUFBLDBCQURJQTtrQkFFSDFULGNBQUssV0FBTEE7SUFJQTs7T0FBQTs7U0FORzBUOztVQU1ZO1dBQ0YsTUFBQTtjQUNGNFU7VUFBTyxPQUFQQTtTQUFXO0lBSjNCLFdBQ0U7R0FHMkI7WUFHN0JnaEIsWUFBWTUxQixHQUFHL0M7SUFDakIsT0FBd0I7O3NCQUFPcU47Y0FHeEI7O2lCQUFBOzttQkFKT3RLOzRCQUlhNlY7b0JBQ1gsSUFDSnZwQixJQURJLFdBTEMyUSxHQUlVNFk7NkJBRWZ2cEIsTUFBYSxPQUFBLFdBTE1nZSxPQUtuQmhlO3dCQUNNc29CLE1BRE50b0I7b0JBQ2EsT0FBUHNvQjttQkFBVTtjQUwxQixXQUNFO2FBSTRCO0dBQUE7O0lBRzlCZDtJQUNBM1c7SUFDQWdYOzs7T0ExSUE5Z0I7T0FJQUM7T0FJQW9QO09BVUFnTDtPQUlBNUc7T0FJQ0Y7Ozs7Ozs7OztPQU1EQztPQXhDQTBEOzs7T0FBQUU7O09BQUFDO09BQUFDOzs7Ozs7O3NCQUFBRjtPQTJFQXVKO09BQ0FDO09BRUFPO09BS0E0Z0I7T0FUQTVoQjtPQVdBaUI7T0FLQXlmO09BRUFtQjtPQUtBNWhCO09BSUE2aEI7T0FDQUM7T0FDQUM7T0FDQXREO09BQ0E2QjtPQUNBRDtPQUVBRTtPQUlBeUI7T0FnQ0EzaEI7T0FDQTNXO09BQ0FnWDtPQWpDQWM7T0FDQUU7T0FFQXVnQjtPQU9BQztPQVdBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUMvSEdDO0lBMkJGanZCOzs7Ozs7O0lBaUNESztJQWdDQUk7Ozs7Ozs7O0dBM0ZELFNBRkNxRyxVQWNDb29CO0lBWkY7O2NBWUVBO2dCQUFBQTs7Ozs7Ozs7OztRQVZ3Qzs7T0FDRjs7TUFGQTs7ZUFXdENBOztNQUNBLE9BQUE7NENBZEVELGtCQWFGQzs7O01BREEsT0FBQTs0Q0FaRUQsa0JBYUZDOzs7Ozs7Ozs7OztPQUxBLE9BQUE7NkNBUkVELGtCQWFGQzs7TUFIQSxPQUFBOzRDQVZFRCxrQkFhRkM7O0tBUEEsT0FBQTsyQ0FORUQsa0JBYUZDOztJQUVjLE9BQUEsd0NBZlpELGtCQWFGQztHQUVvRjtZQUlyRmh2QjtJQUNELHNCQUNVLG1CQUNDLG9CQUNEOztHQUF3QjtPQWlCakN6VDtZQUVDcVAsWUFDRTRELEtBQUlDO0lBQ04sT0FETUE7O09BRUcsT0FBQSx5QkFGUEQ7O09BR1EsT0FBQSx5QkFIUkE7ZUFJTyxPQUFBLHlCQUpQQTs7R0FJMkM7WUFrQjVDdlosT0FBT1QsR0FBT0MsR0FBSSxPQUFYRCxJQUFPQyxVQUFrQjtZQUNoQzRmLFNBQVE3ZixHQUFPQyxHQUFJLE9BQVhELEtBQU9DLFVBQW1CO1lBQ2xDOGYsU0FBUS9mLEdBQU9DLEdBQUksT0FBWEQsTUFBT0MsVUFBbUI7WUFDbENxRixTQUFPdEYsR0FBT0MsR0FBSSxPQUFYRCxNQUFPQyxVQUFrQjtZQUNoQ3NGLFNBQU92RixHQUFPQyxHQUFJLE9BQUpBLElBQVBELFVBQXlCO1lBQ2hDd0YsU0FBUXhGLEdBQU9DLEdBQUksT0FBSkEsS0FBUEQsVUFBMEI7WUFDbENnRyxVQUFXaEcsR0FBT0MsR0FBSSxPQUFBLDBCQUFYRCxHQUFPQyxHQUFzQjtZQUN4Q0YsV0FBWUMsR0FBT0MsR0FBSSxPQUFBLDBCQUFYRCxHQUFPQyxHQUF1QjtPQUMxQzhIO1lBQ0FmLE1BQU9oSCxHQUFPQyxHQUFJLE9BQVhELE1BQU9DLFVBQWtCO1lBQ2hDQyxJQUxRRixHQUFPQyxHQUtDLE9BTERBLEtBQVBELElBQUFBLElBQU9DLEVBS3dCO1lBQ3ZDRSxJQVZRSCxHQUFPQyxHQVVDLE9BVlJELEtBQU9DLElBQVBELElBQU9DLEVBVXdCO0dBWlI7OztPQUMvQlE7T0FDQW9mO09BQ0FFO09BQ0F6YTtPQUNBQztPQUNBQztPQUNBUTtPQUNBakc7T0FDQWdJO09BQ0FmO09BQ0E5RztPQUNBQztZQUdGOFIsVUFBVTdELEdBQUksT0FoRmRnVCxVQWdGd0IsNkJBQWRoVCxJQUFnQztZQUMxQzRELFVBQVV0QjtJQUFtQixVQTdEN0I4SixVQTZEVTlKO0lBQW1CLE9BQUE7R0FBYTtZQUUxQ2M7SUFBUyxzQkFDRixrQkFDQyxrQkFDRDs7R0FBQztZQVFSSSxPQUFPc1IsR0FBSSxZQUFKQSxVQUFBQSxjQUFzRDs7OztPQTlGN0Q5QjtPQW9CQTVHO09BUUNGO09BYUR2VDtPQUVDcVA7T0FrQkR1RTs7T0FtQkExSTtPQUNBRDtPQUVBUjtPQUFBQTtPQVVBdUo7T0FDQW5KOzs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNsQ0E2M0IsSUFBSWxILEtBQUl6dUIsR0FBRUMsR0FBSSxZQUFBLFdBQVZ3dUIsS0FBSXp1QixHQUFFQyxXQUFnQjtZQUMxQjIxQixJQUFJbkgsS0FBSXp1QixHQUFFQyxHQUFJLE9BQUEsV0FBVnd1QixLQUFJenVCLEdBQUVDLGdCQUFnQjtZQUMxQi9NLE1BQU11N0IsS0FBSXp1QixHQUFFQyxHQUFJLGFBQUEsV0FBVnd1QixLQUFJenVCLEdBQUVDLFdBQWU7WUFFM0I1VCxJQUFJb2lDLEtBQUkzckIsS0FBRWxHLEdBQUssT0FIZmc1QixJQUdJbkgsS0FBSTNyQixLQUFFbEcsS0FBRmtHLE1BQUVsRyxFQUFtQztZQUM3Q3hRLElBQUlxaUMsS0FBSTNyQixLQUFFbEcsR0FBSyxPQUxmKzRCLElBS0lsSCxLQUFJM3JCLEtBQUVsRyxLQUFGa0csTUFBRWxHLEVBQW1DOzthQVMzQ2pRLE9BQU1xVCxHQUFFQztLQUFJLElBaEJYd3VCO2dCQUFVLFdBQVZBLEtBZ0JLenVCLEdBQUVDO0lBQW9CO2FBQzVCOEwsU0FBTS9MLEdBQUVDO0tBQUksSUFoQlh3dUI7WUFBVSxXQUFWQSxLQWdCS3p1QixHQUFFQztJQUFvQjthQUM1QmdNLFNBQU9qTSxHQUFFQyxHQUFJLE9BaEJmMDFCLFVBZ0JTMzFCLEdBQUVDLEdBQXFCO2FBQzlCek8sU0FBT3dPLEdBQUVDLEdBQUksT0FoQmYyMUIsVUFnQlM1MUIsR0FBRUMsR0FBcUI7YUFDOUJ4TyxTQUFNdU8sR0FBRUMsR0FBSSxPQWhCZC9NLFlBZ0JROE0sR0FBRUMsR0FBdUI7YUFDL0J2TyxTQUFPc08sR0FBRUM7S0FBSSxJQWhCTHd1QjtrQkFBVSxXQUFWQSxLQWdCRHp1QixHQUFFQztJQUEyQjtJQU5OLFdBRzlCZ00sVUFDQXphLFVBQ0FDLFVBSkE5RSxRQUNBb2YsVUFJQXJhOzs7OztLQU5HL0U7S0FBQW9mO0tBQUFFO0tBQUF6YTtLQUFBQztLQUFBQztLQWtCSHVCO2FBRUFiLE1BQUkwUSxLQUFFbEcsR0FBSyxPQTdCYnZRLElBMkJFNEcsU0FFSTZQLEtBQUVsRyxHQUFxQjthQUMzQnpLLE1BQUkyUSxLQUFFbEcsR0FBSyxPQTdCYnhRLElBMEJFNkcsU0FHSTZQLEtBQUVsRyxHQUFxQjtJQU5pQjtZQWZ6Q2pRO1lBQUFvZjtZQUFBRTtZQUFBemE7WUFBQUM7WUFBQUM7WUFBQXVhO1lBa0JIaFo7WUFFQWI7WUFDQUQ7Ozs7S0FNRnVVO0tBSVFzRztLQUtKL1osVUFMSStaOzJEQUtKL1o7S0FyQkN0RztLQUFBb2Y7S0FBQUU7S0FBQXphO0tBQUFDO0tBQUFDO0tBQUF3QjtLQUFBZTtLQUFBNUg7S0FBQUQ7YUE2QkhILFdBQVc2VyxLQUFFbEcsR0FBSyxPQUFBLFdBN0JmM0ksV0E2QlUySSxHQUFGa0csS0FBbUI7YUFDOUIreUIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0tBQU8sVUFBQSxXQTlCcEJocUIsVUE4QlErcEIsS0FBSGw1QjtLQUFlLHdCQTlCcEJtUCxVQThCS25QLEdBQVFtNUI7SUFBNEI7YUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7S0FBTSxPQUFHLFdBL0I5QnFGLFVBK0JhbUwsR0FBR3ZRO2VBQUFBO2VBQXVDLFdBL0J2RDBmLFVBK0JhblAsR0FBUXhRLE9BQVJ3USxJQUFReFE7SUFBMEQ7YUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7S0FDcEIsR0FBTyxXQWxDRjJmLFVBaUNVMWYsS0FBS0QsTUFFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7S0FDcEIsTUFBQTtJQUMyQjthQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtLQUNoQixLQUFHLFdBdkNFb0YsVUFzQ01uRixLQUFLRDtNQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0tBTVQ7K0JBQWlDLFdBaEN4Q3NhLFdBMEJnQnRhO01BTVQseUJBQVMsV0FoQ2hCc2EsV0EwQldyYTtNQUlQLE1BQUE7S0FBQSxPQUFBO0lBR2lDO0lBNUIwQztZQWpCMUVNO1lBQUFvZjtZQUFBRTtZQUFBemE7WUFBQUM7WUFBQUM7WUFBQXdCO1lBQUFlO1lBQUE1SDtZQUFBRDtZQUFBNkg7WUE2QkhoSTtZQUNBNHBDO1lBR0FJO1lBS0FDO1lBdEJNbHBCOzs7O0tBc0NSdEc7OztJQUlxQixpQ0FKckJBOzs7UUEyQklBO2FBSUF6VCxRQUFRNlAsS0FBRWxHO0tBQUssSUFBMEIsTUFBQSxpQkFBL0JBLElBQWUsTUFBQSxpQkFBakJrRztLQUFpQyxPQUFBO0lBQWdCO0lBUHpELGdCQU9BN1AsU0FKQXlUOztZQVFKeXZCLGNBQWNDLE1BQUtscUMsR0FBRUM7SUFDdkIsWUFEZ0JpcUM7SUFDRDtpQkFJTDtLQUZJLElBREhDLG1CQUFQNUgsZ0JBQ0kzdUIsTUFBTSxXQURWMnVCLEtBRmlCdmlDLEdBQUVDO0tBSW5CLFNBREkyVCxLQUMyQixPQUQzQkE7YUFER3UyQjs7R0FLRjtZQUdQQyxLQUFLN0gsS0FBSzV4QixHQUFFM1EsR0FBRUM7SUFBYyxVQUFBLFdBQWxCMFEsR0FBSTFRO0lBQWMsT0FBQSxXQUF2QnNpQyxLQUFpQixXQUFaNXhCLEdBQUUzUTtHQUFxQjtZQUNqQ3FxQyxRQUFROUgsS0FBSXZpQyxHQUFFQyxHQUFJLE9BQUEsV0FBVnNpQyxLQUFNdGlDLEdBQUZELEdBQWE7Ozs7T0FYekJpcUM7T0FVQUc7T0FDQUM7T0E5SEFyakM7T0FHQTlHO09BREFDOzs7Ozs7OztTQXpDSXFhOzs7OztpQkFTRm12QixRQUFRajVCLEdBQUdrNUIsS0FBS0M7U0FBTztVQUFBLE1BQUEsZUFBWkQsS0FBSGw1QjtVQUFlLFlBQVksZUFBM0JBLEdBQVFtNUI7U0FBbUI7UUFBUztpQkFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7U0FBTSxPQUFHLGNBQWpCd1EsR0FBR3ZRLE9BQUFBLE1BQXVDLGVBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7UUFBMEQ7aUJBRWxGNnBDLFVBQVVyNUIsR0FBR3ZRLEtBQUtEO1NBQ3BCLEdBQU8sZUFEUUMsS0FBS0QsTUFFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7U0FDcEIsTUFBQTtRQUMyQjtpQkFHekI4cEMsTUFBTXQ1QixHQUFHdlEsS0FBS0Q7U0FDaEIsS0FBRyxpQkFEUUMsS0FBS0Q7VUFPWCxXQWRINHBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtTQU1UO2lDQUFpQyxpQkFOeEJBO1VBTVQsdUJBQVMsaUJBTkxDO1VBSVAsTUFBQTtTQUFBLE9BQUE7UUFHaUM7Ozs0REF4QmpDcWE7Ozs7Ozs7Ozs7Ozs7OztnQkFTRm12QjtnQkFHQUk7Z0JBS0FDOzs7OztpQkFuQ0FNLFlBQVk1NUIsR0FBSSxXQUFBLGdCQUFKQSxnQkFBc0I7aUJBQ2xDNjVCLGdCQUFnQjc1QjtTQUFJLFlBQUEsZ0JBQUpBO1FBQXVCO2lCQUN2Qzg1QixZQUFZOTVCLEdBQUksT0FBQSxnQkFBSkEsb0JBQXNCO2lCQUNsQys1QixnQkFBZ0IvNUI7U0FBSSxPQUFBLGdCQUFKQTtRQUF1QjtpQkFDdkNnNkIsS0FBS2g2QjtTQUFpQixVQUFBLGdCQUFqQkE7U0FBaUIsT0FBQTtRQUFnQjtRQVA1QztnQkFHTTQ1QjtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Ozs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7OztZQ3VCQTFqQyxNQUFNOE0sR0FBRUM7SUFDVixVQUFBLDZCQURRRCxHQUFFQztJQUNWOzs7S0FDSSxVQUFBLDZCQUZJRCxNQUFFQztLQUVOO01BQ0csVUFBQSw2QkFIQ0QsTUFBRUM7TUFHSCw0Q0FIQ0QsTUFBRUM7Ozs7OztJQUNWO0dBRzBDO0dBS2pDO0lBRlA0MkI7SUFDQTV3Qjs7SUFDQTZ3QixXQURBN3dCLDRDQUM2RCxXQUFhO1lBRTFFOHdCLE9BQXdCQyxLQUMxQixXQUQwQkEsUUFBQUEsUUFBQUE7WUFJeEJDO0lBQU8sSUFNSHZ3QixzQkFEQXpULG9CQURBZ1Q7SUFIRSxXQUlGaFQsU0FDQXlULFdBRkFUO0dBSVk7R0FoREo7SUFBQSxlQXlCWi9TLE9BT0EyakMsWUFDQTV3QixNQUNBNndCLE1BRUFDLFFBSUFFO0lBZkEvaUM7SUFPQWdqQztJQUNBN21CO0lBQ0E4bUI7SUFFQUM7SUFJQUM7O29CQWZBbmpDLFNBT0FnakMsY0FDQTdtQixRQUNBOG1CLFFBRUFDLFVBSUFDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7UUNqRDBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQUExQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQUFBOzs7UUFRMEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBQTFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFBQUE7Ozs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7O0lDWEF6d0I7SUF3QkFJOzs7SUF0QkMzRTtJQUlDbUg7R0FDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7O0lBR2JvaEI7SUFDQTVHO0lBQ0NGOztZQUlEdlQsb0JBQWMsU0FBQztZQUVma0w7SUFBWTtjQUVQOztHQUEyQztZQUdoREQsaUJBQWUsV0FBSTs7Ozs7O1NBUG5Cakw7U0FkQ3FQO1NBR0EyRDtTQUtEcUg7U0FDQTVHO1NBT0F2STtTQUtBRDtTQUNBK0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFNRlIsaUJBQWUsU0FBRTs7OztPQTlCZkk7T0FZQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkhDOzs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7O1lDaENBOHdCLFlBQWFqZ0IsS0FBS3ZiLFlBQVF3YjtJQUM1QjtLQUFJLGNBQVUsNEJBRENELEtBQUt2YixRQUFRd2I7S0FDeEI7Ozs7O1NBQ2VqZDtLQUFLLE9BQUEsOEJBQUxBOztHQUE0Qjs7O3VEQUY3Q2k5Qjs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7WUNzQ0FDLHNCQUF1QmxnQixLQUFLdmIsS0FBSWEsR0FBRytSLEtBQUtqUSxRQUFRKzRCO0lBQ2xEO0tBQ3VFLE1BQUEsV0FGN0IvNEIsUUFBUjlCO0tBRWhDLFFBQUEsOENBRnVCMGEsS0FBS3ZiO0tBQ3JCNGI7S0FqQnNDK2Y7S0FxQnRDLE1BQUEsNEJBckJzQ0EsT0FpQnRDL2Y7S0FqQjBDZ2dCLE9BcUIxQztLQXJDb0NDLE9BZ0JFRjtLQWhCRTFkLEtBZ0JFMmQ7SUFHbkQ7S0FBRyxRQUFBLDRCQW5COEMzZCxJQUFKNGQ7S0FzQjNCO01BQUEsTUFBQSw0QkF0QitCNWQsSUFBSjRkO01Bc0I1QixNQUFBO01BQVhDLE1BQU0sNEJBdEJpQ0Q7S0F1QnhDLEdBQUEsV0FTNkNILE1BVHhDLFdBUzJCOW9CLEtBQUgvUixHQVY1Qmk3QjtNQXRCMkM3ZCxLQXNCM0M2ZDtVQU82QyxJQWJKQyxPQWFJLDRCQVA3Q0QsU0F0QnVDRCxPQWdCRUU7O1FBaEJGL2QsS0FBQTZkO0lBQzdDO1FBRGlENWQsS0FBSkQsSUFFeEM7S0FDRyxHQUFBLFdBNkIwQzBkLE1BN0JyQyxXQTZCd0I5b0IsS0FBSC9SLEdBaENXbWQsTUFJeEMsV0FKd0NBO0tBS0UsSUFMRmdlLE9BS0UsNEJBTEZoZTtLQUFBQSxLQUFBZ2U7O0dBdUNNO1lBTWpEQyxxQkFBc0IxZ0IsS0FBS3ZiLEtBQUlhLEdBQUc2NkIsTUFBTTlvQixLQUFLalE7SUFDL0M7S0FDdUUsTUFBQSxXQUZ4QkEsUUFBZDlCO0tBRS9CLFFBQUEsOENBRnNCMGEsS0FBS3ZiO0tBQ3BCNGI7S0FBTCtmO0lBR0osU0FIUy9mLE9BSUo7SUFHRzs7T0FyQk42ZjthQWNFRSxZQUFLL2YsUUFEd0IvYSxHQUFTK1IsS0FBS2pRLFFBUWMsdUJBUnpCKzRCOztTQWEzQjVoQztZQUFBQSxNQVpMNmhDLGdCQVllLDRCQUFWN2hDOztJQUpTLFVBQUEsNEJBUmQ2aEMsT0FBSy9mO0lBUUcsV0FBSztHQUlVO1lBR3pCc2dCLGNBQWUzZ0IsS0FBS3ZiLEtBQUlhLEdBQUc4QixRQUFRaVEsS0FBSzFiLFNBQVFpbEMsS0FBSS9zQjtJQUN0RCxpQkFEa0Qrc0I7eUJBQUFBOztrQkFBQUE7aUJBN0JoRFY7a0JBNkJlbGdCO2tCQUFLdmI7a0JBQUlhO2tCQUFXK1I7a0JBQVJqUTsyQkFtQitCeFMsR0FBSyxZQUFBLFdBbkJ2QitHLFNBbUJrQi9HLEdBbkJOaWYsV0FtQjJCO2lCQW5DL0U2c0I7a0JBZ0JlMWdCO2tCQUFLdmI7a0JBQUlhOzJCQUdpQzFRLEdBQUssT0FBQSxXQUh0QitHLFNBR2lCL0csR0FITGlmLGVBR3lCO2tCQUgxQ3dEO2tCQUFSalE7O2tCQUFxQnc1QjtpQkFoQmhERjtrQkFnQmUxZ0I7a0JBQUt2YjtrQkFBSWE7MkJBS2lDMVEsR0FBSyxPQUFBLFdBTHRCK0csU0FLaUIvRyxHQUxMaWYsZ0JBSzBCO2tCQUwzQ3dEO2tCQUFSalE7aUJBN0IzQjg0QjtrQkE2QmVsZ0I7a0JBQUt2YjtrQkFBSWE7a0JBQVcrUjtrQkFBUmpROzJCQXFCK0J4UyxHQUFLLFdBQUEsV0FyQnZCK0csU0FxQmtCL0csR0FyQk5pZixXQXFCMEI7c0JBckI5QitzQjtLQWM3Qzs7UUE5QkhGO1VBZ0JlMWdCO1VBQUt2YjtVQUFJYTttQkFjb0MxUSxHQUFLLE9BQUEsV0FkekIrRyxTQWNvQi9HLEdBZFJpZixnQkFjNkI7VUFkOUN3RDtVQUFSalE7O1VBZ0JuQnhTO01BQU8sU0FBQSxXQWhCeUIrRyxTQWdCakIsV0FoQlkwYixLQUFYL1IsR0FnQmhCMVEsSUFoQjRDaWYsSUFnQlYsV0FBbENqZjs7S0FDWTs7SUFUakI7O09BckNIc3JDO1NBNkJlbGdCO1NBQUt2YjtTQUFJYTtTQUFXK1I7U0FBUmpRO2tCQVFrQ3hTLEdBQUssWUFBQSxXQVIxQitHLFNBUXFCL0csR0FSVGlmLFdBUThCOztTQUUxRThIO0tBQU8sU0FBQSxXQVZ5QmhnQixTQVVqQixXQVZZMGIsS0FBWC9SLEdBVWhCcVcsTUFWNEM5SDtNQVVWLFdBQWxDOEg7O0lBQ1k7R0FVMkQ7WUFHL0VrbEIsd0JBQXlCN2dCLEtBQUt2YixLQUFJYSxHQUFHOEIsUUFBUWlRLEtBQUt5cEIsWUFBV0Y7YUFDM0RHLFFBQVFuc0M7S0FDVixvQkFBTSxXQUY0Q2tzQyxZQUN4Q2xzQztJQUdPO0lBRW5CLFNBQUlvc0MsU0FBU3BzQyxHQUFJLFdBTGJtc0MsUUFLU25zQyxHQUFtQjtJQUNoQyxvQkFQK0Rnc0M7Y0F4QzdERixxQkF3Q3lCMWdCLEtBQUt2YixLQUFJYSxHQUNoQ3k3QixTQUQyQzFwQixLQUFSalE7Y0FyRHJDODRCLHNCQXFEeUJsZ0IsS0FBS3ZiLEtBQUlhLEdBQVcrUixLQUFSalEsUUFNbkM0NUI7R0FHOEU7Z0NBakNoRkwsZUF3QkFFOzs7RTs7Ozs7O0dDdkV5Qjs7SUFXdkJ0eEI7Ozs7OztJQXFCQTB4QjtJQWhDdUIsMEJBV3ZCMXhCO0lBYzJCLDhCQU8zQjB4Qjs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7O1FDM0NBNXBCLFlBQ0FqUTthQUVBdTVCLGNBQWUzZ0IsS0FBS3ZiLEtBQUlhLEdBQUczSixTQUFRaWxDLEtBQUkvc0I7S0FDekMsT0FBQTs7Y0FEaUJtTTtjQUFLdmI7Y0FBSWE7Y0FGeEI4QjtjQURBaVE7Y0FHMkIxYjtjQUFRaWxDO2NBQUkvc0I7SUFDMEI7YUFHakVndEIsd0JBQXlCN2dCLEtBQUt2YixLQUFJYSxHQUFHdzdCLFlBQVdGO0tBQ2xELE9BQUE7O2NBRDJCNWdCO2NBQUt2YjtjQUFJYTtjQU5sQzhCO2NBREFpUTtjQU9xQ3lwQjtjQUFXRjtJQUM0QjtJQVR0RCxlQUl0QkQsZUFJQUU7Ozs7OztRQUtrQywrQkFBQTs7OztRQU9FLElBSWxDeHBCLFlBQ0FqUSxlQUxrQyxtQkFJbENpUSxLQUNBalE7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztRQ25CRm1PO2FBRUEzUSxLQUFNczhCLEtBQUtDLFNBQVNDLEtBQUtDLFNBQVM1OEI7S0FJcEIsVUFBQSxtQkFKUnk4QjtLQUNSLDhDQURhQyxTQUF1QjE4QjtLQVFwQixVQUFBLG1CQVJNMjhCO0tBS3RCLDhDQUwyQkMsU0FBUzU4QjttQkFBQUE7O2VBU3BCLFdBWGQ4USxhQUVNMnJCLEtBQUtDLFNBQVNDLEtBQUtDLFNBQVM1OEI7O0lBU3dCO2FBRzFENjhCLE1BQ0dKLEtBQ0MvMUIsVUFFRGkyQjtLQUlMLEdBTk1qMkIsU0FBVUMsTUFBVkQsUUFBQWcyQixVQUFVLzFCLGNBQVYrMUI7S0FNTjtVQUxnQjFjLGdCQUFWOGMsVUFBVTljOztNQUFBO09BQUEsTUFBQSxtQkFGWHljO09BRUNLLFVBQVUsaUNBRFZKO0tBTU4sWUFIZ0JwYSxnQkFBVnNhLFVBQVV0YSxnQkFBVnNhO0tBR04sT0FwQkV6OEIsS0FhR3M4QixLQUNDQyxTQUVEQyxLQUNDQyxTQUZBRTtJQUt1QzthQU0zQ3A4QixJQUFJKzdCLEtBQUtsaEIsS0FBS3ZiO0tBQ29ELFVBQUEsbUJBRDlEeThCO0tBQ04sOENBRFdsaEIsS0FBS3ZiO0tBRU4sSUFBTjI4QixNQUFNLG1CQUZNMzhCLEtBQVZ5OEI7WUFBVXo4QixLQUdBLFdBL0JkOFEsYUE0QkkyckIsS0FBS2xoQixLQUVQb2hCLFFBRlkzOEI7S0FHQSxPQURaMjhCO0lBRUQ7YUFHREksS0FBT3IyQixLQUFVMUcsS0FBSXk4QjtLQUN2QixHQURTLzFCLFNBQU1DLE1BQU5ELFFBQUE2VSxNQUFNNVUsY0FBTjRVO0tBQ1QsR0FEbUJ2YjtVQU1QbEcsSUFOT2tHLFFBTVAyRixNQUFBN0w7O01BQ0c7T0FBQSxNQUFBLG1CQVBRMmlDO09BTVg5MkIsTUFDRyxpQ0FQTjRWO0tBT00sT0FkYjdhLElBT3FCKzdCLEtBQWRsaEIsS0FNRzVWO0lBQ3dCO0lBM0N4QyxXQUNNbUwsYUFFQTNRLE1BWUEwOEIsT0FjQW44QixLQU9BcThCOzs7YUF5RUFyOEIsSUFBSSs3QixLQUFLbGhCLEtBQUt2YjtLQUM0QyxVQUFBLHdCQUR0RHk4QixLQUFLbGhCLEtBQUt2YjtLQUM0QyxPQUFBO0lBQW1CO2FBRzdFKzhCLEtBQU14aEIsS0FBS3ZiLEtBQUl5OEI7S0FDMkMsVUFBQSx3QkFEcERsaEIsS0FBS3ZiLEtBQUl5OEI7S0FDMkMsT0FBQTtJQUFvQjtJQVJwRixXQUdNLzdCLEtBSUFxOEI7Ozs7OztpQkE1Q0VDLFlBQWFoOUIsWUFBUSxPQUFBLHdCQUFSQSxLQUFtQjs7U0FDaEMyQztTQUNBbU87O3dCQURBbk8sYUFBQUEsUUFEQXE2QixhQUVBbHNCO1NBdEVGbXNCO1NBRUE5OEI7U0FZQTA4QjtTQWNBbjhCO1NBT0FxOEI7bUJBakNBNThCLE1BWUEwOEIsT0FkQUksZUE0QkF2OEIsS0FPQXE4Qjs7O1lBNkRJcDZCO2lCQUNBcTZCLFlBQWFoOUIsWUFBUSxPQUFBLG1CQUFSQSxLQUFtQjs7U0FDaEM4UTtTQVRBbUo7NEJBQUFBLGVBT0F0WCxRQUNBcTZCLGFBQ0Fsc0I7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7OztJQ2hGQTVaO0lBQ0FxUDtJQUNBZ0w7SUFBQTVHOzs7WUFFUkYsZUFaTXVMO0lBQW9CLE9BQUEsNkJBQXBCQTtHQUF3RDtZQXFCNURrbkIsZUFBVSxxQkFFQTtZQUdWQyxlQUFVLHFCQUVBO1lBR1ZDLFVBQVVDLEdBQUduaEIsV0FBU3BiO0lBQ3hCLEtBRFl1OEIsR0FHRixPQUhLbmhCO1FBRVIvckIsSUFGS2t0QztJQUVBLE9BQUEsV0FGWXY4QixHQUVqQjNRO0dBQ1U7WUFHZjZRLEtBQUtxOEIsR0FBR3Y4QjtJQUNWLEtBRE91OEIsR0FFRztRQUNIcDVCLElBSEFvNUI7SUFHSyxPQUFBLFdBSEZ2OEIsR0FHSG1EO0dBQVE7WUFHYnlHLFVBQVU1SixHQUFFRCxHQUFJLE9BTmhCRyxLQU1ZSCxHQUFGQyxHQUFlO1lBRXpCdzhCLEtBQUtudEMsR0FBRzJRO0lBQ1YsS0FEVUEsR0FFQTtRQUNIbXVCLE1BSEdudUI7SUFHRSxPQUFBLFdBQUxtdUIsS0FIQTkrQjtHQUdRO1lBR2IwZ0MsTUFBTWh3QixHQUFHcWI7SUFDWCxLQURRcmIsR0FFRSxPQUZDcWI7UUFHSi9yQixJQUhDMFE7SUFHSSxPQUFMMVE7R0FBTTtZQUdYb3RDLFVBQVc5RyxNQUFNbmYsT0FBTzJmLFNBQVFwMkI7SUFDbEMsR0FEa0NBLE9BRTNCMVEsSUFGMkIwUSxNQUV0QixPQUFMMVE7T0FGTXNtQztTQVVGenJCLElBVkV5ckI7UUFBTW5mO01BaUJYO09BSlc1UixJQWJBNFI7T0FpQlg7U0FBQTs7T0FGQSxNQXJCTnVaLE1BTXdCb0c7YUFjcEIsMENBRGF2eEIsR0FIUnNGO2FBVmVpc0I7O09BWUQ1YyxJQVpDNGM7O1NBWUksaUNBQUw1YyxHQUZkclA7Ozs7U0FDTDs7Ozs7V0FES0E7O1NBTkx3eUI7O1lBSmFsbUI7U0FRRmlKLE1BUkVqSjtRQUFPMmY7VUFTRHdHLE1BVEN4RyxrQkFTSSwyQkFEYjFXLEtBQ1FrZDs7Z0JBRFJsZDtTQUpYaWQ7O1lBSm9Cdkc7U0FPSHlHLE1BUEd6RyxZQUlwQnVHLFVBR3NCLDJCQUFMRTs7U0FIakJGLFVBRW9CO0lBYXhCLE9BQUEsMkJBZklBO0dBZWE7WUFHakJHLGVBQWVOLEdBQUduaEI7SUFDcEIsS0FEaUJtaEIsR0FHUCxPQUFBLFdBSFVuaEI7UUFFYi9yQixJQUZVa3RDO0lBRUwsT0FBTGx0QztHQUNhO1lBR2xCMnBCLFNBQVNqWixHQUNYLEtBRFdBLEdBRUQsZ0JBQ0gxUSxJQUhJMFEsTUFHQyxXQUFMMVEsR0FBWTtZQUdqQndRLFFBQVFFLEdBQ1YsS0FEVUEsR0FFQSxjQUNIMVEsSUFIRzBRLE1BR0UsV0FBTDFRLE1BQVU7WUFHZnNwQixRQUFRNVksVUFBZSxPQUFmQSxFQUFnQjtZQUN4QjhZLFFBQVE5WSxVQUFlLE9BQWZBLEVBQWdCO1lBRXhCcVksSUFBcUJDLEcsZ0JBQXdDdFksR0FBR0MsR0FDbEUsT0F0RUVzOEIsVUFxRTZEdjhCLEdBQXhDc1ksTUFBMkNyWSxHQUNwQztZQUc1QnNDLFFBQVF2QyxHQUFHQztJQUNiLEtBRFVELEdBRUE7UUFDSDFRLElBSEcwUTtJQUdFLE9BQUEsV0FIQ0MsR0FHTjNRO0dBQVE7WUFHYjRTLE9BQU9sQyxHQUFHQztJQUNaLEtBRFNELEdBRUM7UUFDSDFRLElBSEUwUTtJQUdHLE9BQUEsV0FIQUMsR0FHTDNRO0dBQVE7WUFHYitxQixJQUFJcmEsR0FBRW9ELEdBQUc5TTtJQUNYLEtBRE0wSixHQUVJO1FBQ0gySCxNQUhEM0g7SUFHTyxPQUFBLFdBSEYxSixPQUFIOE0sR0FHRHVFO0dBQWdCO1lBR3JCN0YsT0FBTzlCLEdBQ1QsT0FEU0EsVUFHSTtZQUtYRCxLQUFLQyxHQUFHTixNQUFNTztJQUNoQixLQURPRCxHQUVHLE9BRkFOO1FBR0hwUSxJQUhBMFE7SUFHSyxPQUFBLFdBSElDLEdBQU5QLE1BR0hwUTtHQUFhO1lBR2xCOG9CLE1BQU1wWSxHQUFHQztJQUNYLEtBRFFELEdBRUU7UUFDSG9ELElBSENwRDtJQUdPLE9BQUEsV0FISkMsR0FHSm1EO0dBQXlCO1lBRzlCNFYsS0FBS2haLEdBQUdDO0lBQ1YsS0FET0QsR0FFRztRQUNIMVEsSUFIQTBRO0lBR1EsT0FBQSxXQUhMQyxHQUdIM1EsS0FIQTBRO0dBRzRCO1lBR2pDK1ksU0FBUy9ZLEdBQUdDO0lBQ2QsS0FEV0QsR0FFRDtRQUNIb0QsSUFISXBEO0lBR0MsT0FBQSxXQUhFQyxHQUdQbUQ7R0FBUTtZQUdiOU0sTUFBTTJKLEdBQUVpRyxLQUFFbEc7SUFDWixHQURVa0c7UUFBRWxHLE9BR0cxUSxJQUhIMFEsTUFHTHFXLE1BSEduUSxRQUdXLE9BQUEsV0FIYmpHLEdBR0RvVyxLQUFRL21COztjQUhIMFEsR0FFSTtJQUVUO0dBQUs7WUFHVis4QixLQUFLenRDLEdBQUksV0FBSkEsR0FBVTtZQUVmMHRDLFdBQVcxdEMsR0FBRUMsR0FDZixPQURhRCxJQUFBQSxJQUFFQyxFQUdKO1lBR1QwdEMsUUFBUUMsTUFBSzV0QyxHQUFJLE9BQVQ0dEMsV0FBSzV0QyxPQUFpQztZQUU5Q3k3QixNQUFNM25CLEdBQUVDLEdBQUdwRDtJQUNiLEdBRFFtRDtRQUFFQyxPQUdLdUUsTUFITHZFLE1BR0hzRSxNQUhDdkUsTUFHWSxXQUFLLFdBSFpuRCxHQUdOMEgsS0FBUUM7U0FEUHRZLElBRkE4VDs7O1NBRUE5VCxJQUZFK1Q7SUFFYSxPQUFmL1Q7R0FDd0I7WUFHOUJzMEIsT0FFQTVqQixHQUZVQztJQUNaLEdBQ0VELE9BQUt1TyxJQUFMdk8sTUFBaUIsR0FBQSxXQUZQQyxHQUVMc08sSUFBbUIsT0FBeEJ2TztJQUNLO0dBQUk7WUFHVHdYLFNBQVN2WDtJQUNYLElBQU0sSUFDSjNRLElBREksV0FESzJRLGtCQUdNO0lBRFYsV0FBTDNRO0dBQ21CO1lBR25COG9DLGNBQWNuNEI7SUFDaEIsSUFBTSxJQUNKM1EsSUFESSxXQURVMlEsT0FFVCxPQUFMM1EsY0FDZTtHQUFJO2dCQUdmMFEsR0FBR0M7SUFDVCxLQURNRCxHQUVJO1FBQ0hvRCxJQUhEcEQ7SUFHTSxXQUFLLFdBSFJDLEdBR0ZtRDtHQUFlO1lBYWxCcU0sTUFWSXhQLEdBQUUzUSxHQUNWLEtBRFEyUSxHQUVFLGNBQ0htdUIsTUFIQ251QixNQUdJLFdBSEYzUSxHQUdIOCtCLEtBQWE7WUFNaEJqaEIsU0FBTzdkLEdBQUksV0FBSkEsR0FBVTtHQUVYLElBQU4rUTtZQUVBb04sS0FBSyt1QixHQUFHdjhCO0lBQ1YsS0FET3U4QixHQUVHO1FBQ0hsdEMsSUFIQWt0QztJQUdLLE9BQUEsV0FIRnY4QixHQUdIM1E7R0FBUTs7d0NBSGJtZSxNQUpBTixVQUVBOU07Ozs7Ozs7a0RBRkE4TSxVQUNBc0MsT0FDQXBQOzs7Ozs7Ozs7Ozs7OztZQVlGa1ksWUFBWXZZLEdBQUdOLE1BQU1PO0lBQUksT0FBQSw4QkE5RnpCRixNQThGZUwsTUFBTU8sR0FBVEQ7R0FBbUQ7WUFDL0QwWSxXQUFXMVksR0FBR04sTUFBTU87SUFBSSx3Q0EvRnhCRixNQStGY0wsTUFBTU87SUFBSSxxQiw0QkFBYkQ7R0FBa0Q7Ozs7T0F6TnZEM0o7T0FDQXFQO09BR1JrRTtPQThJRXRUO09BL0dBdVQ7T0FqQ002RztPQUFBNUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUNOa21CO09BTUEwTTtPQTFCQUg7T0FnREFPO09BbURBLzhCO09BZEFzYTtPQU1Bdlk7T0FyRkEzQjtPQXlFQStCO09BTkFLO09Bc0NBeVc7T0FNQUQ7T0F6REFqWjtPQU5BbVo7T0F4Q0F3akI7T0E4SEExUjtPQU1Bbkg7T0FNQXBNO09BTUE0Z0I7T0E1QkEyRTtPQUVBQztPQU1BQztPQXBKQVo7T0FLQUM7T0FMQUQ7T0EyTUE5akI7T0FDQUc7T0FoSUFFO09BQ0FFO09Bc0NBVjtPQXBDQUM7OztFOzs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OzthQ3JIRTNILFVBQVUxRjtLQUNKLElBQUp0TixJQUFJLHdCQURJc047S0FFWixJQUFJLFVBQUEsaUJBREF0TixJQUNBO1dBQ0Y0TjtVQUFBRiwwQkFBQUU7TUFBTyxPQUFBLDZCQUFQRixLQUhVSjs7SUFHdUI7YUFHakNsQixVQUFVOUo7S0FBdUIsVUFBQSxpQkFBdkJBO0tBQXVCLE9BQUE7SUFBaUI7SUFQTixXQUM1QzBRLFdBTUE1Rzs7O2FBVUE0RyxVQUFVeXNCLFdBQVVueUI7S0FDZCxJQUFKdE4sSUFBSSx3QkFESXkvQixXQUFVbnlCO0tBRXRCLElBQUksVUFBQSxpQkFEQXROLElBQ0E7V0FDRjROO1VBQUFGLDBCQUFBRTtNQUFPLE9BQUEsNkJBQVBGLEtBSG9CSjs7SUFHYTthQUdqQ2xCLFVBQVUwUSxXQUFVeGE7S0FBaUMsVUFBQSxpQkFBakNBO0tBQWlDLE9BQUEsd0JBQTNDd2E7SUFBNEQ7SUFQbEIsV0FDcEQ5SixXQU1BNUc7OzthQVVBNEcsVUFBVXlzQixXQUFVQyxXQUFVcHlCO0tBQ3hCLElBQUp0TixJQUFJLHdCQURJeS9CLFdBQVVDLFdBQVVweUI7S0FFaEMsSUFBSSxVQUFBLGlCQURBdE4sSUFDQTtXQUNGNE47VUFBQUYsMEJBQUFFO01BQU8sT0FBQSw2QkFBUEYsS0FIOEJKOztJQUdHO2FBR2pDbEIsVUFBVTBRLFdBQVU2aUIsV0FBVXI5QjtLQUNPLFVBQUEsaUJBRFBBO0tBQ08sT0FBQSx3QkFEM0J3YSxXQUFVNmlCO0lBQ2tDO0lBUlUsV0FDaEUzc0IsV0FNQTVHOzs7YUFZQTRHLFVBQVV5c0IsV0FBVUMsV0FBVUUsV0FBVXR5QjtLQUNsQyxJQUFKdE4sSUFBSSx3QkFESXkvQixXQUFVQyxXQUFVRSxXQUFVdHlCO0tBRTFDLElBQUksVUFBQSxpQkFEQXROLElBQ0E7V0FDRjROO1VBQUFGLDBCQUFBRTtNQUFPLE9BQUEsNkJBQVBGLEtBSHdDSjs7SUFHUDthQUdqQ2xCLFVBQVUwUSxXQUFVNmlCLFdBQVVFLFdBQVV2OUI7S0FDTyxVQUFBLGlCQURQQTtLQUNPLE9BQUEsd0JBRHJDd2EsV0FBVTZpQixXQUFVRTtJQUNrQztJQVJRLFdBQ3hFN3NCLFdBTUE1Rzs7O2FBTUE0RyxVQUFVMUY7S0FDWixTQURZQTtNQU1WLE9BQUE7aUVBTlVBO1NBRUF0TixJQUZBc047S0FHVixJQUFLLFVBQUEsaUJBREt0TixJQUNMO1dBQ0Y0TjtVQUFBRiwwQkFBQUU7TUFBTyxPQUFBLDZCQUFQRixLQUpPSjs7SUFRSjthQUdObEIsVUFBVTlKLEdBQUksV0FBVSxpQkFBZEEsSUFBNkI7SUFab0IsV0FDM0QwUSxXQVdBNUc7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQzlFRnRKO0lBQU8sdUJBQ0RsUixjQUFLLFdBQUxBO1FBQ0MrbUI7SUFBSyxXQUFMQTtHQUFZO1lBR25CbW5CLGdCQUFXLDhCQUVNO1lBR2pCQyxpQkFBWSw4QkFFSTtZQUdoQnpOLGlCQUFhMWdDLGNBQWdCLE9BQWhCQTtZQUViaXRDLFVBQVV2OEIsR0FBRzA5QixPQUFPQztJQUN0QixTQURZMzlCLFVBRUoxUSxJQUZJMFEsTUFFQyxPQUFBLFdBRkUwOUIsT0FFUHB1QztRQUNDK21CLE1BSEdyVztJQUdFLE9BQUEsV0FIUTI5QixRQUdidG5CO0dBQWE7WUFLcEJoVyxJQUFJTCxHQUFHMDlCLE9BQU9DO0lBQ2hCLFNBRE0zOUIsVUFFRTFRLElBRkYwUSxNQUVPLFdBQU0sV0FGVjA5QixPQUVEcHVDO1FBQ0MrbUIsTUFISHJXO0lBR1EsV0FBTyxXQUhMMjlCLFFBR1B0bkI7R0FBc0I7WUFHN0JxbkIsTUFBTXB1QyxHQUFJLFdBQUpBLEdBQVc7WUFDakJxdUMsT0FBT3J1QyxHQUFJLFdBQUpBLEdBQVk7WUFFbkJnSCxNQUFNc25DLEtBQUlDLEtBQUl6OEIsSUFBR0M7SUFDbkIsU0FEZ0JEO1NBRVI5UixJQUZROFI7Y0FBR0MsV0FFRjlSLElBRkU4UixPQUVHLE9BQUEsV0FGZHU4QixLQUVBdHVDLEdBQVNDOzs7U0FDUjhtQixNQUhPalY7Y0FBR0MsV0FHQTZTLE1BSEE3UyxPQUdLLE9BQUEsV0FIWnc4QixLQUdIeG5CLEtBQVVuQzs7SUFDd0I7R0FBSztZQUc5Q3JLLFVBQVU1SixHQUFFdkM7SSx1QkFDTnBPLGNBQUssT0FBQSxXQUREMlEsR0FDSjNRO1FBQ0NDO0lBQUssT0FBQSxXQUZBbU8sR0FFTG5POzs7SUE4Qks7S0FGTjRkO0tBckJOMndCO0tBQ0FDO0tBRUFwbUI7S0FtQk1sSztLQUNBcE47OztpQkFQQUwsR0FBR0M7U0FBSSxPQUFVO2tCQU1qQndOO2tCQU5Bek47MkJBQXNCMVEsR0FBSyxPQUFPLFdBS2xDNmQsVUFMa0MsV0FBL0JsTixHQUFtQjNRLElBQWlCO1FBQUM7NkNBTXhDbWUsTUFDQXBOLEtBRkE4TTs7Ozs7S0FRQXNCOzs7YUFDQWdCLE1BQU1yTyxJQUFHQztLQUFLLE9BQVc7O2NBQW5CRDt1QkFBd0JuQjtlQUFLLE9BQVc7O3dCQUFyQ29CO2lDQUEwQy9SLEdBQUssT0FBTyxXQUQvRG1mLFVBQytELFdBQWpDeE8sR0FBcUIzUSxJQUFpQjtjQUFDO0lBQUM7SUFDaEU7S0FBTm9mOytDQUZBRCxVQUNBZ0IsT0FDQWY7Ozs7Ozs7Ozs7Ozs7O2FBTUVzdkIsV0FBVy85QixHQUFFdVk7SyxZQUNYLE9BQUEsV0F0Q1ZzbEIsT0FxQ3FCdGxCO1NBRVpsSyxlQUFMdE87S0FJUyxPQUFBO2NBMUNiKzlCO2NBc0NJLzlCOzhCQUdvQixPQUxoQmcrQixXQUFXLzlCLEdBQUV1WSxLQUVabEssSUFHa0M7dUJBQ3pCa3VCLEdBQUssT0FOZndCLFdBQVcvOUIsR0FNaUIsV0FOakJBLEdBQUV1WSxLQU1IZ2tCLElBSlRsdUIsSUFJdUM7O2FBRXhDMnZCLFlBQVloK0IsR0FBRXVZO0ssWUFDTCxPQUFBLHFCQUFBLDJCQURLQTtTQUVibEssZUFBTHRPO0tBSVMsT0FBQTtjQWxEYis5QjtjQThDSS85Qjt1QkFHZTFRLEdBQUssT0FMaEIydUMsWUFBWWgrQixPQUtEM1EsR0FMR2twQixNQUVibEssSUFHMEM7dUJBQ2pDa3VCLEdBQUssT0FkZndCLFdBUVkvOUIsR0FNRnU4QixHQUpUbHVCLElBSStCOzthQWZ0QzR2QixZQWlCRTV2QixJQUFJck8sR0FBSyxPQVJMZytCLFlBUUFoK0IsTUFBSnFPLElBQTRCO2FBSXhCNnZCLGFBQVdsK0IsR0FBRXVZO0ssWUFDWCxPQUFBLFdBMURWc2xCLE9BeURxQnRsQjtTQUVabEssZUFBTHRPO0tBSVMsT0FBQTtjQTlEYis5QjtjQTBESS85Qjs4QkFHcUIsT0FMakJtK0IsYUFBV2wrQixHQUFFdVksS0FFWmxLLElBR21DO3VCQUMxQmt1QixHQUFLLE9BTmYyQixhQUFXbCtCLEdBTWlCLFdBTmpCQSxHQUFFdVksS0FNSGdrQixJQUpUbHVCLElBSXVDOzthQUV4Qzh2QixjQUFZbitCO0ssWUFDVixPQUFBO1NBQ0RxTyxlQUFMdE87S0FDcUQsT0FBQTtjQW5FekQrOUI7Y0FrRUkvOUI7OEJBQzRCLE9BSHhCbytCLGNBQVluK0IsR0FFWHFPLElBQ3VDO3VCQUFja3VCLEdBQUssT0FYM0QyQixhQVFZbCtCLEdBRzBDdThCLEdBRHJEbHVCLElBQzJFOzthQVpsRit2QixpQkFjRS92QixJQUFJck8sR0FBSyxPQUxMbStCLGNBS0FuK0IsR0FBSnFPLElBQXlCO2FBRzNCZ3dCLFVBQVV0K0I7S0FBSSxPQUFvQyxXQXhFcEQrOUIsUUF3RVkvOUIsb0NBQWtELFNBQUk7SUFBQzthQUNqRWd3QixNQUFNaHdCLEdBQUdxYjtLQUFVLE9BQThCO2NBekVuRDBpQjtjQXlFUS85Qjs0Qjs4QkFBcUQsT0FBbERxYixVQUF5RDtJQUFDO2FBRW5FcE8sWUFBWWhOO0tBQ2QsT0FBWTs7dUJBQUt1SDtlQUFPLE9BQU07d0JBN0U5QnMyQjt3QkE2RThCOzBCQURoQjc5QixHQUNtQixnQ0FBaEJ1SDtjQUFvRDtJQUFDO0lBakUxRTs7O1lBVEltUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBaUNFdW1CO1lBb0JBRztZQWlCQUM7WUFDQXRPO1lBRUEvaUI7O1lBV0U4d0IsT0FBTy85QixHQUFHbU4sVUFBUTJ3QjtJQUNwQixTQURTOTlCLFVBRUQxUSxJQUZDMFEsTUFFSSxPQUFBLFdBRkRtTixVQUVKN2Q7UUFDQ0MsSUFIQXlRO0lBR0ssT0FBQSxXQUhNODlCLE9BR1h2dUM7R0FBWTtZQUduQm9vQixRQUFRdlcsSUFBR0MsSUFBSXBCLEdBQUc2OUI7SUFDcEIsU0FEVTE4QjtTQUVGOVIsSUFGRThSO2NBQUdDLFdBRUk5UixJQUZKOFIsT0FFUyxXQUFNLFdBRlhwQixHQUVUM1EsR0FBU0M7U0FFUjhtQixNQUpJaFY7OztTQUdKMGUsTUFIQzNlO2NBQUdDO1VBR002UyxNQUhON1M7TUFHVyxXQUFPLFdBSFh5OEIsT0FHWC9kLEtBQVU3TDs7U0FDVm1DLE1BREEwSjs7SUFDc0IsV0FBdEIxSjtHQUE4QjtZQUdyQzVJLEtBQUt6TixHQUFHQztJQUNWLFNBRE9ELE1BSVksT0FKWkE7UUFFQzFRLElBRkQwUTtJQUVNLE9BQUEsV0FGSEMsR0FFRjNRO0dBRVk7Z0NBM0h0Qm91QyxPQUNBQyxRQXlHSUksUUFNQXBtQixTQU9BbEs7WUFjQTh3QixTQUFPditCLEdBQUdtTixVQUFRMndCO0lBQ3BCLFNBRFM5OUIsVUFHRDFRLElBSEMwUSxNQUdJLE9BQUEsV0FITzg5QixPQUdaeHVDO1FBRENDLElBRkF5UTtJQUVLLE9BQUEsV0FGRm1OLFVBRUg1ZDtHQUNXO1lBR2xCaXZDLFVBQVFwOUIsSUFBR0MsSUFBSXBCLEdBQUc2OUI7SUFDcEIsU0FEVTE4QjtTQUdGOVIsSUFIRThSO2NBQUdDLFdBR0k5UixJQUhKOFIsT0FHUyxXQUFNLFdBSFJ5OEIsT0FHWnh1QyxHQUFTQztTQUNUOG1CLE1BREEvbUI7OztTQURDeXdCLE1BRkMzZTtjQUFHQyxXQUVNNlMsTUFGTjdTLE9BRVcsV0FBTyxXQUZkcEIsR0FFUjhmLEtBQVU3TDtTQUVYbUMsTUFKS2hWOztJQUlnQixXQUFyQmdWO0dBQTRCO1lBR2xDN0gsT0FBS3hPLEdBQUdDO0lBQ1YsU0FET0QsTUFJVyxPQUpYQTtRQUVFMVEsSUFGRjBRO0lBRU8sT0FBQSxXQUZKQyxHQUVEM1E7R0FFVTtHQUlUOzhCQXpKWnF1QyxRQURBRCxPQXFJSWEsVUFNQUMsV0FPQWh3QjtJQVFROzs7Ozs7OztPQWhKWjNFO09BekNBcko7T0FlQXd2QjtPQUVBdU07T0FBQUE7T0FRQWw4QjtPQVNBL0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BN0JBa25DO09BS0FDO09BcUJBQztPQUNBQzs7OztFOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUNuQ0Exd0I7WUFFQTdNLE1BQU9MLE1BQUtDLEdBQUdDO0lBRWQ7TUFGTUYsTUFBS0MsZUFFWS9HLEdBQUUzSixHQUN2QixXQUhZMlEsR0FFU2hILEdBQUUzSixJQUN2QixPQURxQjJKLFVBRWhCO0lBRlA7R0FHTTtZQUdQeXdCLE1BQU8zcEIsTUFBS0MsR0FBR04sTUFBTU87SUFDZixJQUFKaEg7SUFDWSxPQUFBO2FBRlA4RzthQUFLQzthQUFHTjtzQkFFSThZLEtBQUlqSztjQUNiLElBQU4yYixRQUFNLFdBSFdqcUIsR0FDbkJoSCxNQUNpQnVmLEtBQUlqSztjQURyQnRWLE9BQUFBO2NBSUYsT0FGSWl4QjthQUVEO0dBQUM7WUFHSnFELE9BQVE3RCxPQUFNMXBCLEdBQUdDO0lBQUksT0FBbUI7YUFBaEN5cEI7YUFBTTFwQjs7c0JBQStCL0csR0FBRXVaLEdBQUVwUCxHQUFLLE9BQUcsV0FBeENuRCxHQUE0QmhILEdBQUltSyxLQUFGb1AsWUFBQUEsRUFBaUM7R0FBQztZQUVqRmdTLFFBQVNwa0IsT0FBTW9QLEdBQUd2UDtJQUNwQixPQUFZO2FBckJWZ047c0JBcUJleEY7Y0FDZjtnQkFGU3JIO2dCQUFNb1A7eUJBRUN2VyxHQUFFM0o7aUJBQVEsVUFBQSxXQUZSMlEsR0FFRmhILEdBQUUzSjtpQkFBUSxhQUFXLFdBRHRCbVk7Z0JBQ21DO2NBQWxEO2FBQ0s7R0FBQztZQUdOOGMsU0FBVW5rQixPQUFNb1AsR0FBR3ZQO0lBQ3JCLE9BQVk7YUEzQlZnTjtzQkEyQmV4RjtjQUNmO2dCQUZVckg7Z0JBQU1vUDt5QkFFQXZXLEdBQUUzSjtpQkFBWSxjQUFBLFdBRlgyUSxHQUVIaEgsR0FBRTNKOzhCQUF5QixXQUQ1Qm1ZO2dCQUMwQztjQUF6RDthQUNJO0dBQUM7WUFHTDJjLFVBQVdoa0IsT0FBTUosR0FBR0M7SUFDdEIsT0FBWTthQWpDVmdOO3NCQWlDZXhGO2NBQ2Y7Z0JBRldySDtnQkFBTUo7eUJBRUQvRyxHQUFFM0o7aUJBQ1YsSUFFSjRULE1BRkksV0FIWWpELEdBRUpoSCxHQUFFM0o7d0JBR2Q0VCxNQUFpQixXQUpOdUUsR0FJWHZFO2dCQUE2QjtjQUhqQzthQUlJO0dBQUM7WUFHTCtnQixNQUFPN2pCLE9BQU1vUCxHQUFHdlA7SUFDbEIsT0FBWTthQTFDVmdOO3NCQTBDZXhGO2NBQ2Y7Z0JBRk9ySDtnQkFBTW9QO3lCQUVHdlcsR0FBRTNKO2lCQUFRLFVBQUEsV0FGVjJRLEdBRUFoSCxHQUFFM0o7aUJBQVEsYUFBb0IsV0FEL0JtWSxXQUNDeE8sR0FBRTNKO2dCQUF5QztjQUEzRDthQUNJO0dBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FXSG12QyxtQkFHMEJ6K0IsR0FBR0MsR0FBSyxPQXhEcENHLFlBd0Q0QkosR0FBR0MsR0FBcUI7O1NBRDFDeStCLG9CQUZSRCxVQUVRQzs7O1NBSVJDLG1CQUcwQjMrQixHQUFHTixNQUFNTyxHQUFLLE9BdEQxQ3lwQixZQXNENEIxcEIsR0FBR04sTUFBTU8sR0FBMkI7O1NBRHREMitCLHNCQUZSRCxVQUVRQzthQUlSQyxTQUFPNytCLEdBQUdDLEdBQUksT0FqRGhCc3RCLE9BMkNFb1IsU0FNTzMrQixHQUFHQyxHQUFzQjthQUNoQzYrQixVQUFROStCLEdBQUdDLEdBQUksT0FoRGpCdWtCLFFBbUNFaWEsU0FhUXorQixHQUFHQyxHQUF1QjthQUNsQzgrQixXQUFTLytCLEdBQUdDLEdBQUksT0EzQ2xCc2tCLFNBNkJFa2EsU0FjU3orQixHQUFHQyxHQUF3QjthQUNwQysrQixZQUFVaC9CLEdBQUdDLEdBQUksT0F0Q25CbWtCLFVBdUJFcWEsU0FlVXorQixHQUFHQyxHQUF5QjthQUN0Q2cvQixRQUFNai9CLEdBQUdDLEdBQUksT0E5QmZna0IsTUFjRXdhLFNBZ0JNeitCLEdBQUdDLEdBQXFCO0lBbkJxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFTbkUwK0I7WUFOQUY7WUFhQUs7WUFDQUM7WUFGQUY7WUFJQUk7WUFEQUQ7Ozs7O09BNURGdFY7T0FSQXRwQjtPQWdCQW10QjtPQUVBL0k7T0FNQUQ7T0FlQU47T0FUQUc7Ozs7U0E4Q0UvSjs7Ozs7OztTQTFCR2pCO1NBQUFyRjtTQUFBbUY7U0FBQWtCO1NBQUE3QjtTQUFBRztTQUFBeFc7U0FBQUs7U0FBQTZWO1NBQUFDO1NBQUFXO1NBQUFEO1NBQUFqWjtTQUFBbVo7U0FBQUw7U0FBQUU7U0FBQTZsQjtTQUFBRjtTQUFBamE7U0FBQUQ7U0FBQWdKO1NBQUF0SjtTQUFBRzs7Z0JBMEJIL0o7Z0JBMUJHakI7Z0JBQUFyRjtnQkFBQW1GO2dCQUFBa0I7Z0JBQUE3QjtnQkFBQUc7Z0JBQUF4VztnQkFBQUs7Z0JBQUE2VjtnQkFBQUM7Z0JBQUFXO2dCQUFBRDtnQkFBQWpaO2dCQUFBbVo7Z0JBQUFMO2dCQUFBRTtnQkFBQTZsQjtnQkFBQUY7Z0JBQUFqYTtnQkFBQUQ7Z0JBQUFnSjtnQkFBQXRKO2dCQUFBRzs7Ozs7U0F3Q0gvSjs7Ozs7OztTQXhDR2pCO1NBQUFyRjtTQUFBbUY7U0FBQWtCO1NBQUE3QjtTQUFBRztTQUFBeFc7U0FBQUs7U0FBQTZWO1NBQUFDO1NBQUFXO1NBQUFEO1NBQUFqWjtTQUFBbVo7U0FBQUw7U0FBQUU7U0FBQTZsQjtTQUFBRjtTQUFBamE7U0FBQUQ7U0FBQWdKO1NBQUF0SjtTQUFBRzs7Z0JBd0NIL0o7Z0JBeENHakI7Z0JBQUFyRjtnQkFBQW1GO2dCQUFBa0I7Z0JBQUE3QjtnQkFBQUc7Z0JBQUF4VztnQkFBQUs7Z0JBQUE2VjtnQkFBQUM7Z0JBQUFXO2dCQUFBRDtnQkFBQWpaO2dCQUFBbVo7Z0JBQUFMO2dCQUFBRTtnQkFBQTZsQjtnQkFBQUY7Z0JBQUFqYTtnQkFBQUQ7Z0JBQUFnSjtnQkFBQXRKO2dCQUFBRzs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ3NjQzhhOzs7Ozs7Ozs7Ozs7Ozs7O1lBOWVKcDFCLFVBVUl1SyxVQUFZOHFCO0lBSGxCLDhCQUljOztLQUVTLElBRFo3TCxxQkFDREMsV0FBYSxXQUhMNEwsVUFFUDdMO0tBRUwsd0JBRElDOztJQUdhO0tBREU1b0I7S0FBWkM7S0FDSEMsV0FBYSxXQU5qQndKLFVBS096SjtLQUVIRSxXQUFhLFdBUExxMEIsVUFLT3gwQjtJQUduQix3QkFGSUUsY0FDQUM7R0FDcUU7R0EzQnJFLGVBU1JoQjtZQWdDQXMxQjtJQUNJLElBRG9Cbi9CLGNBQUh2QyxjQUNqQixRQUFBLFdBRG9CdUMsR0FBSHZDO2tDQUViOzJCQUNIOEcsZ0JBQUssZUFBTEEsS0FIbUJ2RTtRQUlka0UsZ0JBQUhmO0lBQVMsV0FBVEEsT0FBR2UsS0FKY2xFOztZQU94Qm8vQixrQkFBa0IzaEMsR0FBR2dDLE1BQU1PLEdBQUcwWTtJQUNoQyxTQUFRdkssS0FBSzFRLEdBQUU0aEMsTUFBSzNtQixRQUFPMVksR0FBRXVZO0tBQ3JCLFlBQUEsV0FETzhtQixNQUFGNWhDO21DQUVELE9BQUEsV0FGUWliLFFBQVNIOztVQUdwQmhVO01BQW1CLE9BQUE7ZUFIRHZFO2VBQUV1WTs7NkIsT0FBckJwSyxLQUdDNUosS0FITTg2QixNQUFLM21CLFFBQU8xWTs7U0FJYmtFLGdCQUFIZjtLQUEyQixPQUFBO2NBSlhuRDtjQUFFdVk7a0JBSWxCcFY7NEIsT0FKSGdMLEtBSU1qSyxLQUpDbTdCLE1BQUszbUIsUUFBTzFZO0lBSWlDO1FBRzdDcS9CLE9BUks1aEMsTUFRUjhHLE1BUlE5RztJQVFJLE9BUGhCMFEsS0FPSTVKLEtBQUc4NkIsTUFSaUIzbUIsUUFBSDFZLEdBQU5QO0dBUTBCO0dBaEJyQztJQUFBLGFBQ1YwL0IsV0FPQUM7OztZQVlGRSxZQUFhNy9CLE1BQU1PLEdBQUksV0FBVlAsTUFBTU8sR0FBc0I7WUFFekN1L0IsT0FGYTkvQixNQUVDTzthQUZLbXVCLElBR0sxd0I7S0FDbEIsWUFBQSxXQUZRdUMsR0FDVXZDO2lCQUVkOzZCQUNDOEcsa0JBQUhwQjtLQUFTLFdBQVRBLEdBQUdvQjtJQUF1QjtJQU5YLFdBQVY5RSxNQUFNMHVCO0dBTWdCO1lBR25DcVIsWUFBWS9oQyxHQUFHZ0MsTUFBTU87SUFDdkIsSUFDZXEvQixPQUZENWhDLE1BRUY4RyxNQUZFOUc7SUFHWjtnQkFIZWdDLE1BRUw4RTs7YUFHTixJQUFXOUcsY0FBTjhILGlCQUNDLFFBQUEsV0FKRzg1QixNQUdFNWhDOzJDQUVEOztrQkFDSDhHO2NBQUssZUFIUGdCLE1BR0VoQjs7YUFFRTtjQURHTDtjQUFIZjtjQUNBLFVBQUEsV0FWUW5ELEdBS1p1RixNQUlJcEM7NkNBRUk7O2tCQUNIczhCO2NBQVEsZUFBUkEsUUFIRXY3Qjs7aUJBSUd3N0IscUJBQUhoNEI7YUFBWSxXQUFaQSxTQUFHZzRCLFFBSkh4N0I7WUFJaUM7R0FBRTtZQUduRHk3QjtJQUF1QmxpQyxHQUFHZ0MsTUFBTW1nQyxjQUFjQyxnQkFBZ0JDO0lBQ2hFLElBQ2VULE9BRlU1aEMsTUFFYjhHLE1BRmE5RztJQUd2QjtnQ0FIMEJnQyxNQUVoQjhFO3FCQUdGeUI7YUFDSixnQkFESUE7Y0FZSztlQURTKzVCLFVBWGQvNUI7ZUFZSyxRQUFBLFdBakJpRDg1QixnQkFnQnhDQzs0Q0FFTDs7bUJBQ0hDO2VBQVMsMEJBQVRBOztrQkFDS0Msb0JBQUgzd0M7Y0FBYSxXQUFiQSxrQkFBRzJ3Qzs7YUFaTjt3QkFITGo2QjtjQUVxQms2QjtjQUFQQztjQUNULFVBQUEsV0FOQWQsTUFLZ0JhOztjQUVaLDBCQUFzQixXQVRPTCxnQkFPeEJNOztrQkFHUkM7Y0FBZSwrQkFIUEQsU0FHUkM7O2FBRUU7Y0FER0M7Y0FBSGh4QztjQUNBLFVBQUEsV0FaZ0J1d0MsY0FPVk8sU0FJTjl3Qzs2Q0FFSTs7a0JBQ0hpeEM7Y0FBUywrQkFBVEEsU0FIRUQ7O2lCQUlHRSxzQkFBSHRzQjthQUFhLFdBQWJBLHlCQUFHc3NCLFNBSkhGO1lBUzJDO0dBQUU7WUFHaEUxZ0MsUUFoRGFGO0lBaURmLFNBakRxQk87S0FpREUsWUFDYjtTQUNEK0MsY0FBTDFUO0tBQVUsV0FBVkEsR0FBSzBUO0lBQWtCO0lBbkRGLFdBQVZ0RCxNQUFNTztHQW1ETTtZQUl6QkYsS0FBS0MsR0FDV04sTUFBT087SUFBekIsSUFBb0JxL0IsT0FEYnQvQixNQUNNeWdDLFNBRE56Z0MsTUFDTXdGLE9BQUFpN0IsUUFBS2x5QixJQUFBN087SUFDaEI7S0FBTSxZQUFBLFdBRFk0L0IsTUFBUDk1QjttQ0FFRCxPQUZNK0k7O1VBQUxteEI7TUFBQWw2QixPQUFBazZCOzs7TUFJYyxJQUpkQyxtQkFJRnY4QixjQUpPczlCLE1BSVMsV0FKRnpnQyxHQUFQc08sR0FJUG5MO01BSkVvQyxPQUFBbTZCO01BQUtweEIsSUFBQW15Qjs7O0dBTzhCO1lBRzlDQyxZQUFZM2dDO0lBQUksT0FYaEJELEtBV1lDLGVBQTRCZ0QsR0FBRTFULEdBQUssV0FBTEEsR0FBRjBULEdBQWE7R0FBQztZQUd0RGxEO1FBQXNCdy9CLGlCQUFINWhDO0lBRXJCLFNBQVFvQyxRQUFRcEMsR0FBRTRoQyxNQUFLcm1DO0tBQ3JCLElBRGN1TCxNQUFBOUc7S0FDZDtlQURxQnpFO09BRUgsSUFISCtHLFFBQ0R3RSxLQUFFODZCLE9BRFksTUFKNUJxQixZQUllM2dDO09BQWEsT0FBQTs7TUFLcEIsWUFBQSxXQUpRcy9CLE1BQUY5NkI7b0NBS0Y7O1dBRUVILGdCQUFIakI7T0FBUyxXQUFUQSxHQVBMdEQsUUFPUXVFLEtBUEVpN0IsTUFPd0IsNEJBUG5Ccm1DOztVQUFQa0w7TUFBQUssTUFBQUw7O0lBT2tDO0lBRWxELE9BVFFyRSxRQUZhcEMsR0FBRzRoQzs7WUFjdEIxekIsWUFBVTRPLFdBQVV4YTtJQUEyQixVQWQvQ0YsUUFjb0JFO0lBQTJCLE9BQUEsNkJBQXJDd2E7R0FBZ0Q7WUFFMURrRyxNQUFRN2EsZUFBdUQrNkIsU0FBUUM7SUFDekUsR0FEVWg3QixTQUFTQyxNQUFURCxRQUFBOGEsU0FBUzdhLGNBQVQ2YTtJQUNWLFlBRGdDeEIsZ0JBQVIyQixRQUFRM0IsZ0JBQVIyQjtJQUN4QixZQURxRFcsZ0JBQVA1RyxPQUFPNEcsZ0JBQVA1RztJQUM5QztLQXRGcUJpbUI7b0JBcUZ5QmptQjs7YUFBcEM4Rjs7WUFJRjFuQjtZQUFLLE9BSjRENG5DLFNBSWpFNW5DOzswQkFBQUEsR0FBNEMsNEJBQTVDQSxHQUpFMG5CO1dBSXFEOztZQUN6QzFuQjtZQUFLLE9BQUxBLElBTG1ENG5DOzswQkFLbkQ1bkMsR0FBNEMsNEJBQTVDQSxHQUxaMG5CO1dBS21FOzthQUxuRUE7O1lBT0YxbkI7WUFBSyxPQVA0RDRuQyxVQU9qRTVuQzs7MEJBQUFBLEdBQTZDLDRCQUE3Q0EsR0FQRTBuQjtXQU9zRDs7WUFDMUMxbkI7WUFBSyxPQUFMQSxLQVJtRDRuQzs7MEJBUW5ENW5DLEdBQTZDLDRCQUE3Q0EsR0FSWjBuQjtXQVFvRTtLQTdGL0RqaEI7b0JBcUZTb2hCO1VBQXlDOGY7VUFhL0MsNEJBYitDQSxTQUF2RGpnQjtJQXJGZSxXQUFWamhCLE1BQU1vaEM7R0FvR0k7WUFHdkJ4SyxRQXZHYXlLO0lBd0dmLFNBeEdxQjlnQyxFQXdHWThnQztLQUMvQjt5QkFEK0JBOzs7V0FBQUE7eURBQUFBLFVBQUFBO01BQ2J6QjtNQUFINWhDO01BQ1QsVUFBQSxXQURZNGhDLE1BQUg1aEM7cUNBRUw7O01BR0csSUFGTjhHLGtCQUVFK0osUUFGRi9KLEtBSFc4NkI7TUFJaEIsV0FDTy93Qjs7S0FLSyxJQUhGcEssa0JBQUg3VSxnQkFHQ294QyxVQUhFdjhCLEtBUE1tN0I7S0FRaEIsV0FET2h3QyxHQUdDb3hDO0lBQ0k7SUFwSFMsV0FBVkssUUFBTTlnQztHQW9ISjtnQkFHWEQsR0FBR0M7SUFDVCxJQUNrQnEvQixPQUZadC9CLE1BRU13RixPQUZOeEY7SUFHSjtZQURVd0Y7cUJBR0ZBO2FBQ0UsWUFBQSxXQUpNODVCLE1BR1I5NUI7MkNBRU07b0NBQ0g5SCxjQUFLLFdBQUxBO2lCQUNLOEcsZ0JBQUhwQjthQUFTLFdBQU8sV0FUdEJuRCxHQVNNbUQsSUFBR29CO1lBQW9CO0dBQUU7WUFHdENsRSxLQUFLTixHQUFHQztJQUNWLElBQ2VxL0IsT0FGUnQvQixNQUVLdEMsSUFGTHNDO0lBR0w7bUJBRFV0Qzs7YUFHTixJQUFRQSxjQUFIekUsY0FDQyxRQUFBLFdBSkdxbUMsTUFHRDVoQzsyQ0FFRTtvQ0FDSDhHLGdCQUFLLGVBSFB2TCxHQUdFdUw7YUFDeUI7Y0FBcEJMO2NBQUhmO2NBQXVCLFVBQUMsNEJBSjVCbkssT0FJT2tMO2FBQU0sV0FBTyxXQVRyQmxFLEdBS0NoSCxHQUlJbUs7WUFBa0M7R0FBRTtZQUdqRDBrQixZQUFZOW5CLEdBQUdOLE1BQU1PO0lBQ3ZCLE9BdklFdy9CO2FBc0lZei9CO2FBQUdOO3NCQUNXOFksS0FBSWxwQjtjQUM5QjtlQUFhLFFBQUEsV0FGUTJRLEdBQ0t1WSxLQUFJbHBCO2VBQ3JCK21CO2VBQUw2VDtjQUNKLFdBRFM3VCxLQUFMNlQ7YUFDVTtHQUFDO1lBR2ZWLGFBQWF4cEIsR0FBR04sTUFBTU87SUFDeEIsT0E3SUV3L0I7YUE0SWF6L0I7b0JBQUdOOzZCQUM2QnBRO2NBQWQ7ZUFBU2twQjtlQUFIdmY7ZUFDeEIsUUFBQSxXQUZTZ0gsR0FDZWhILEdBQUd1ZixLQUFLbHBCO2VBQ3BDK21CO2VBQUw2VDtjQUNKLFdBRFM3VCxTQUNFLDRCQUYwQnBkLE9BQ2pDaXhCO2FBQ29CO0dBQUE7WUFHeEJ0RyxPQUFPNWpCLEdBQUdDO0lBQ1osSUFDa0JxL0IsT0FGVHQvQixNQUVHd0YsT0FGSHhGO0lBR1A7WUFEVXdGO3FCQUdGQTthQUNFLFlBQUEsV0FKTTg1QixNQUdSOTVCOzJDQUVNO29DQUNIOUgsY0FBSyxXQUFMQTtpQkFDRTBGLGNBQUdvQjthQUFRLEdBQUEsV0FUZHZFLEdBU0dtRCxJQUFrQixXQUFsQkEsR0FBR29CO2lCQUNBTDthQUFNLFdBQU5BO1lBQVk7R0FBRTtZQUc5QndsQixRQUFRM3BCLEdBQUdDO0lBQ2I7SUFBQTthQWRFMmpCO2VBeEJBdGpCLEtBcUNRTixZQUN5Qi9HLEdBQUV5RSxHQUFLLFdBQVB6RSxHQUFFeUUsR0FBUzs7Z0JBQU0sSUFBU0EsY0FBSHpFO2dCQUFTLE9BQUEsV0FEdERnSCxHQUM2Q2hILEdBQUd5RTtlQUFZOztHQUFDO1lBR3hFb0UsT0FBTzlCO0lBQ1QsSUFBaUJzL0IsT0FEUnQvQixNQUNNd0YsT0FETnhGLE1BQ0kvRyxPQUFFeUUsSUFBQThIO0lBQ2I7S0FBTSxZQUFBLFdBRFM4NUIsTUFBRjVoQzttQ0FFSCxPQUZDekU7O1VBQUV1TDtNQUFBOUcsSUFBQThHOzs7TUFJVSxJQUpWTCxnQkFBRlcsTUFJWSw0QkFKWjdMO01BQUFBLElBQUE2TDtNQUFFcEgsSUFBQXlHOzs7R0FPNEI7WUFLekM4VSxTQUFTalo7SUFDWDtLQUhzRDtPQWhJcEREO1NBa0lTQzs7eUJBRnVEMVE7VUFBWixJQUFTMkosY0FBSCtKO1VBQVcsZUFBTDFULEdBQU4wVCxJQUFtQiw0QkFBaEIvSjtTQUFzQjtLQUc5RWtHO0tBQUg2RDtJQUNKLEtBRElBLEdBRUk7SUFFRTtLQUNPeXBCLE1BTGJ6cEI7S0FHRjFULElBSEUwVDtLQUlFSSxJQUFJLDJCQUpIakUsS0FHTDdQO0tBRWFzK0IsTUFPUiw0QkFaQXp1QjtLQUtRbEcsSUFBQTIwQjtLQUFFZ0QsTUFBQW5FO0lBQ2I7VUFEYW1FO2dCQUFGMzNCLEdBT2IsT0FSSW1LO01BR00sTUFBQTs7U0FGSzQ5QixNQUFBcFEsUUFHWHZhLE1BSFd1YTtLQUlYLHlCQUxBeHRCLEdBQ1NuSyxPQUFBQSxLQUdUb2Q7S0FFSyxJQUxJdlIsTUFLSiw0QkFMSTdMO0tBQUFBLElBQUE2TDtLQUFFOHJCLE1BQUFvUTs7R0FRZDtZQUdEaG9CLEtBQUtoWixHQUNhQztJQUFwQixJQUFlcS9CLE9BRFJ0L0IsTUFDTXdGLE9BRE54RixNQUNNdEMsSUFBQThIO0lBQ1g7S0FBTSxZQUFBLFdBRE84NUIsTUFBRjVoQzttQ0FFRDs7VUFGQzhHOztVQUdGcEI7TUFBVyxHQUFBLFdBSEZuRCxHQUdUbUQsSUFBa0IsV0FBbEJBO1VBSEVvQjs7S0FBQTlHLElBQUE4Rzs7R0FPOEI7WUFHekN1VSxTQUFTL1ksR0FDU0M7SUFBcEIsSUFBZXEvQixPQURKdC9CLE1BQ0V3RixPQURGeEYsTUFDRXRDLElBQUE4SDtJQUNYO0tBQU0sWUFBQSxXQURPODVCLE1BQUY1aEM7bUNBRUQ7O1VBRkM4RztNQUFBOUcsSUFBQThHOzs7TUFJRixJQUpFTCxnQkFHRmYsY0FHSjY5QixTQUZJLFdBSlNoaEMsR0FHVG1EO1NBR0o2OUIsUUFBVSxPQUFWQTtNQU5NdmpDLElBQUF5Rzs7O0dBVThCO1lBSXpDaWdCLFVBQVVwa0IsR0FDUUM7SUFBcEIsSUFBZXEvQixPQURIdC9CLE1BQ0N3RixPQUREeEYsTUFDQ3RDLElBQUE4SCxNQUFTdk07SUFDcEI7S0FBTSxZQUFBLFdBRE9xbUMsTUFBRjVoQzttQ0FFRDs7VUFGQzhHO01BQUE5RyxJQUFBOEc7OztNQUlGLElBSkVMLGdCQUdGZixjQUdKNjlCLFNBRkksV0FKU2hoQyxHQUFFaEgsR0FHWG1LO1NBR0o2OUIsUUFBVSxPQUFWQTtNQURzQixJQUxQbjhCLE1BS08sNEJBTFA3TDtNQUFUeUUsSUFBQXlHO01BQVNsTCxJQUFBNkw7OztHQVV1QjtZQUczQ3ZDLFFBQVF2QyxHQUNVQztJQUFwQixJQUFlcS9CLE9BREx0L0IsTUFDR3dGLE9BREh4RixNQUNHdEMsSUFBQThIO0lBQ1g7S0FBTSxZQUFBLFdBRE84NUIsTUFBRjVoQzttQ0FFRDs7VUFGQzhHOztVQUdGcEI7TUFBZSxLQUFBLFdBSE5uRCxHQUdUbUQsSUFBd0I7VUFIdEJvQjs7S0FBQTlHLElBQUE4Rzs7R0FPOEI7WUFHekMrZixTQUFTdmtCLEdBQ1NDO0lBQXBCLElBQWVxL0IsT0FESnQvQixNQUNFd0YsT0FERnhGLE1BQ0V0QyxJQUFBOEgsTUFBU3ZNO0lBQ3BCO0tBQU0sWUFBQSxXQURPcW1DLE1BQUY1aEM7bUNBRUQ7O1VBRkM4RztNQUFBOUcsSUFBQThHOzs7VUFHRnBCO01BQWUsS0FBQSxXQUhObkQsR0FBRWhILEdBR1htSyxJQUEwQjtNQUNILElBSnJCZSxnQkFBU1csTUFJWSw0QkFKWjdMO01BQVR5RSxJQUFBeUc7TUFBU2xMLElBQUE2TDs7O0dBUXVCO1lBRzNDNUMsT0FBT2xDLEdBQ1dDO0lBQXBCLElBQWVxL0IsT0FETnQvQixNQUNJd0YsT0FESnhGLE1BQ0l0QyxJQUFBOEg7SUFDWDtLQUFNLFlBQUEsV0FETzg1QixNQUFGNWhDO21DQUVEOztVQUZDOEc7Y0FHRnBCLGNBQVcsR0FBQSxXQUhGbkQsR0FHVG1ELElBQWtCLGNBSGhCb0I7O0tBQUE5RyxJQUFBOEc7O0dBTzhCO1lBR3pDZ2dCLFFBQVF4a0IsR0FDVUM7SUFBcEIsSUFBZXEvQixPQURMdC9CLE1BQ0d3RixPQURIeEYsTUFDR3RDLElBQUE4SCxNQUFTdk07SUFDcEI7S0FBTSxZQUFBLFdBRE9xbUMsTUFBRjVoQzttQ0FFRDs7VUFGQzhHO01BQUE5RyxJQUFBOEc7OztVQUdGcEI7TUFBVyxHQUFBLFdBSEZuRCxHQUFFaEgsR0FHWG1LLElBQW9CO01BQ0csSUFKckJlLGdCQUFTVyxNQUlZLDRCQUpaN0w7TUFBVHlFLElBQUF5RztNQUFTbEwsSUFBQTZMOzs7R0FRdUI7WUFHM0MzRSxLQUFLSCxHQUNnQkM7SUFBdkIsSUFBa0JxL0IsT0FEWHQvQixNQUNNeWdDLFNBRE56Z0MsTUFDTXdGLE9BQUFpN0I7SUFDWDtLQUFNLFlBQUEsV0FEVW5CLE1BQUw5NUI7bUNBRUQ7O1VBRkNrNkI7TUFBQWw2QixPQUFBazZCOzs7VUFBQUMsbUJBSUZ2OEI7TUFDUCxXQUxtQm5ELEdBSVptRDtNQUpFb0MsT0FBQW02Qjs7O0dBUzhCO1lBR3pDNXJCLFNBQVMvVDtJQUNYLElBQWVzL0IsT0FESnQvQixNQUNFd0YsT0FERnhGLE1BQ0V0QyxJQUFBOEg7SUFDWDtLQUFNLFlBQUEsV0FETzg1QixNQUFGNWhDO21DQUVEO3dCQUVHO1NBSkY4RztLQUFBOUcsSUFBQThHOztHQU80QjtZQUd2QzZWLElBQUlyYSxHQUNjb0QsR0FEVDlNO0lBQ1gsSUFBZWdwQyxPQURUdC9CLE1BQ093RixPQURQeEYsTUFDT3RDLElBQUE4SDtJQUNYO0tBQU0sWUFBQSxXQURPODVCLE1BQUY1aEM7bUNBRUQ7O1VBRkM4Rzs7VUFHRm5CO01BQVcsR0FBQSxXQUpYL00sT0FDUzhNLEdBR1RDLElBQXdCO1VBSHRCbUI7O0tBQUE5RyxJQUFBOEc7O0dBTzhCO0dBR2pDLElBQVIwOEIsK0JBQWdDLFNBQUk7WUE2QmhDenpCLEtBM0JDek4sR0FBR0M7YUFyVVdtdUI7S0F1VWhCO01BQ3dCanJCOztNQUFQbThCO01BQU45NUI7TUFDSCxVQUFBLFdBRFM4NUIsTUFBTjk1Qjs7TUFLRztPQURTMjdCLFNBSkNoK0I7T0FJUHU4QixTQUpPdjhCO09BS1YsVUFBQSxXQURTZytCLFFBQU56QjtzQ0FFQzs7V0FDSGhpQztPQUFLLGVBWnZCd2pDLFdBWWtCeGpDLEdBSFF5akM7O1VBSUgzOEIsa0JBQUhwQjtNQUFTLGVBQU0sV0FYM0JuRCxHQVdZbUQsUUFBR29CLEtBSkcyOEI7OztVQUtkaDlCO01BQUssbUJBQUxBLEtBVFFtN0IsT0FBT244Qjs7U0FVVmtCLGtCQUFIc0Q7S0FBUyxXQUFUQSxhQUFHdEQsS0FWR2k3QixPQUFPbjhCO0lBVW1DO0lBQ3hELElBblZPekQsV0FtVWJ3aEMsT0FFS2xoQztJQXJVa0IsV0FBVk4sTUFBTTB1QjtHQW1WSDtZQWNaamhCLFNBWEc3ZDtJQUNULFNBdlZxQjJRO0tBdVZTLFlBQ2xCO1NBQ0gzUTtLQUFLLFdBQUxBO0lBQXFCO0lBRlosSUF2VkhvUSxXQXNWTnBRO0lBdFZnQixXQUFWb1EsTUFBTU87R0F5VlM7R0FNbEI7SUFBTkk7NENBQ0FvTixNQUNBTixVQUZBOU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBS0p1aEIsSUFBSWxrQixHQUlTOFU7SUFIZixPQUdlQSxHQUZWO1FBRWM4c0IsT0FKYjVoQyxNQUlXMGpDLE1BSlgxakMsTUFJU3pFLElBQUF1WixHQUFFaE8sTUFBQTQ4QjtJQUNiO0tBQU0sWUFBQSxXQURTOUIsTUFBRjk2QjttQ0FFSDs7VUFGR0w7TUFBQUssTUFBQUw7OztVQUFBRSxnQkFJSmpCO01BQVksR0FBQSw2QkFKVm5LLE9BSThCLFdBQWhDbUs7TUFBaUQsSUFKL0MwQixNQUkrQyw0QkFKL0M3TDtNQUFBQSxJQUFBNkw7TUFBRU4sTUFBQUg7OztHQU91QjtZQUd0Q3dkLFFBQVFua0IsR0FBRThVO0lBQ1osT0FEWUEsR0FFUCxPQUFBO0lBRUcsWUFsQk5vUCxJQWNRbGtCLEdBQUU4VTtnQkFLQSxPQUFBO1FBQ0hsakI7SUFBSyxPQUFMQTtHQUFPO1lBVVorRyxRQUdFZ2YsT0FBUUMsT0FBUStyQixPQUFRQztJQUM1QixHQUFHLG9DQURpQkQsT0FBUUMsUUFFdkI7V0FGZUQ7O1dBS1hFLFFBTFdGO2dCQUFRQyxVQU1YO1dBRE9FLFFBTElGO09BS1EsT0FBQSxXQUxoQ2pzQixPQUtLa3NCLE9BQWVDOztXQUdkQyxRQVJVSjtjQUFRQzs7O2NBUUZJLFFBUkVKLFVBUVUsT0FBQSxXQVIxQmhzQixPQVFGbXNCLE9BQWdCQztrQkFDUjs7OztXQUVFQyxRQVhBTixVQVdWTyxRQVhVUDtjQUFRQzs7O1VBVVY7O1VBRVA7V0FEb0NPLFFBWG5CUDtXQVdTUSxRQVhUUjtXQWNyQjl1QixJQUZJLFdBWlA2QyxPQVdNdXNCLE9BQTJCRTt1QkFHOUJ0dkIsSUFESyxXQWJBOEMsT0FXUXFzQixPQUEyQkUsU0FHeENydkI7OztJQVBVO0dBT0Y7WUFHYjlNLFlBUUV5USxhQUFhQyxhQUFhOU0sS0FBSUM7SUFDaEMsT0FEZ0NBOztPQUdwQixJQURMQyxLQUZ5QkQsUUFJMUJFLFFBRE0seUJBSGdCSDtPQUsxQixPQUFBLFdBTEE2TSxhQUlJMU0sT0FGQ0Q7O09BS0ssSUFESkUsT0FOd0JILFFBUTFCSSxRQURNLHlCQVBnQkw7T0FTMUIsT0FBQSxXQVRhOE0sYUFRVHpNLE9BRkVEOztPQUtJO1FBRENraUIsS0FWbUJyaUI7UUFVeEJ3NEIsT0FWd0J4NEI7UUFheEJvSixRQUZJLHlCQVhnQnJKO1FBWXRCMDRCLFFBRUYsV0FkRjdyQixhQWFNeEQsT0FIQW92QjtPQU1OLE9BQUEsV0FoQmEzckIsYUFZVDRyQixPQUZPcFc7O0dBTVM7R0FjdEIsU0FYQWxiLFVBV0l1eEIsVUFBWUMsVUE4Q1pDO0lBOUNKOztjQThDSUE7Z0JBQUFBOzs7Ozs7Ozs7O1FBTEEsT0FBQTs4Q0ExQ0FqRCxrQkErQ0FpRDs7T0FQQSxPQUFBOzZDQXhDQWpELGtCQStDQWlEOztNQUhBLE9BQUE7NENBNUNBakQsa0JBK0NBaUQ7O2VBQUFBOztNQUNBLE9BQUE7NENBaERBakQsa0JBK0NBaUQ7OztNQURBLE9BQUE7NENBOUNBakQsa0JBK0NBaUQ7U0FwQnNCQzs7UUFBQUE7O1NBQUFBO1VBQUFBO1dBQUFBO1dBQUFBO1dBQUFBOztXQVp1Q0M7VUFBQUEsbUJBQUFBO1FBSXpDO1NBRGZDLFdBSHdERDtTQUl0REUsV0FBYSxXQWxCUkwsVUFpQlBJO1FBRUYsV0FESUM7O09BR0osT0FBQTs7Z0JBdEJIckQ7Z0JBMkJzQmtEO2dCQW9CdEJEOztVQTVDMkRLO1NBQUFBLG1CQUFBQTtPQUl2QztRQURmQyxXQUhzREQ7UUFJcEQ1TixXQUFhLFdBTnBCcU4sVUFLS1E7T0FFRixXQURJN047O01BR0osT0FBQTs7ZUFWSHNLO2VBMkJzQmtEO2VBb0J0QkQ7O1NBcEIyRE87S0FFM0QsR0FGMkRBO2dCQUFBQTs7T0FJdkM7UUFESEM7UUFBWkMsV0FIc0RGO1FBSXBERyxXQUFhLFdBOUJwQlosVUE2QktXO1FBRUVFLFdBQWEsV0EvQlJaLFVBNkJLUztPQUdkLFdBRklFLFVBQ0FDOzs7S0FHSixPQUFBOztjQW5DSDVEO2NBMkJzQmtEO2NBb0J0QkQ7O0lBR0EsT0FBQSx3Q0FsREFqRCxrQkErQ0FpRDtHQUdzRTtZQUcxRXBULFlBVUlnVSxVQUFZQztJQUhsQjs7T0FLdUIsSUFEWkMscUJBQ0RDLFdBQWEsV0FGakJILFVBQ0tFO09BRUwsd0JBRElDOztPQUdhLElBRFhDLHFCQUNGQyxXQUFhLFdBTExKLFVBSU5HO09BRU4sd0JBRElDOztPQUdhO1FBRENDO1FBQVpDO1FBQ0ZDLFdBQWEsV0FSakJSLFVBT01PO1FBRUZFLFdBQWEsV0FUTFIsVUFPTUs7T0FHbEIsd0JBRklFLGNBQ0FDOztHQUNvRTtZQUczRTU1QixlQUtDdUwsZ0JBQWlCQztJQUNuQjs7Ozt3Q0FERUQ7OzBDQUFpQkM7Ozs7OzBCQUFqQkQsb0JBQWlCQzs7R0EyQmxCO0dBNUtnQztJQUFBO1VBT2pDL2UsU0FvQkFxUCxhQTJCQWdMLFdBK0RBcWUsYUF1QkNubEI7Ozs7Ozs7OztZQXNDSDY1QixrQ0FBcUVwdEM7UUFBVHF0QyxnQkFBSkMsYUFBbkJDLGtCQUFKQzthQUcvQnZFO0tBQU8sSUFHUHVFO2VBQUFBOztvQ0FPYzs7V0FFRUMsaUJBQUh6Z0M7T0FBVSxlQUFWQSxlQUFHeWdDOzs7O2VBVGhCRDtXQUZTRSxpQkFBSkMsT0FFTEg7T0FGZSxlQUFNLFdBSmNELE9BSTlCSSxPQUFJRDs7VUFFZUUsaUJBQWJDLE9BQVhMLE9BQVF6Z0MsSUFBUnlnQztnQkFBd0JJLG1CQVFELGVBUmY3Z0MsWUFBRzhnQztlQUFhRDtPQUNQO1FBRGtCRSxPQUFYRjtRQUFRcjhCLE1BQVJxOEI7UUFDcEJHLGFBQWEsV0FQa0QvdEMsU0FNM0QrTSxHQUF3QndFO09BRWhDLFlBREl3OEI7O3FCQUFBQTsyQkFESWhoQyxHQUF3QndFLGNBQXJCczhCLFdBQXdCQzsyQkFBSHY4QixVQUFoQ2k4QixRQUFtQ007eUJBQTNCL2dDLFlBQUc4Z0MsT0FBYUQ7OztTQURmTjtLQUFNLGVBQ2ZFLElBRHlCLFdBTGlDSCxPQUtqREM7SUFVOEM7SUFFM0QsbUJBakJtQ0UsU0FBdUJGLE1BR3REckU7O1lBaUJGK0UseUJBQXlCUixJQUFHRixJQUFJdHRDO0lBQ2xDLE9BQThDOzthQXJCNUNvdEMsc0JBb0J5QkksSUFBR0YsSUFBSXR0Qzs2QkFDWSxJQUNyQy9HLGNBQTZCLE9BQTdCQSxFQUErQjtHQUFBO1lBV3RDZzFDLHlCQUE0RGp1QztRQUFUcXRDLGdCQUFKQyxhQUFuQkMsa0JBQUpDO2FBQ3RCdkU7S0FBTyxJQUdQdUU7ZUFBQUE7O29DQUdjOztXQUVFQyxpQkFBSHpnQztPQUFVLFdBQVZBLGNBQUd5Z0M7Ozs7ZUFMaEJEO1dBRlNFLGlCQUFKQyxPQUVMSDtPQUZlLGVBQU0sV0FGS0QsT0FFckJJLE9BQUlEOztVQUVlRSxpQkFBYkMsT0FBWEwsT0FBUXpnQyxJQUFSeWdDO2dCQUF3QkksbUJBSUQsV0FKZjdnQyxXQUFHOGdDO2VBQWFEO09BQ1A7UUFEa0JFLE9BQVhGO1FBQVFyOEIsTUFBUnE4QjtRQUNwQkcsYUFBYSxXQUx5Qy90QyxTQUlsRCtNLEdBQXdCd0U7T0FFaEMsV0FESXc4QjtxQkFENEJ4OEIsU0FBaENpOEIsUUFBbUNNO3FCQUEzQi9nQyxXQUFHOGdDLE9BQWFEOzs7U0FEZk47S0FBTSxlQUNmRSxJQUR5QixXQUh3QkgsT0FHeENDO0lBTXdDO0lBRXJELG1CQVgwQkUsU0FBdUJGLE1BQzdDckU7O1lBYUY1ZCxHQUFHaGtCO0lBQ0wsSUFBZTRoQyxPQURWNWhDLE1BQ1EyRyxNQURSM0csTUFDUThHLE1BQUFIO0lBQ1g7S0FBTSxZQUFBLFdBRE9pN0IsTUFBRjk2QjttQ0FFRDs0QkFFRHBCLGNBQVMsV0FBVEE7U0FKRWU7S0FBQUssTUFBQUw7O0dBT3NCO1lBR2pDdEMsT0FBT25FO0lBQ0gsWUFaSmdrQixHQVdPaGtCO2dCQUVDLE9BQUE7UUFDSDBGO0lBQUssT0FBTEE7R0FBTTtZQUdYdWUsR0FBR2prQjtJQUNMLElBT2U0aEMsT0FSVjVoQyxNQUNRMkcsTUFEUjNHLE1BQ1E4RyxNQUFBSDtJQUNYO0tBQU0sWUFBQSxXQU1PaTdCLE1BUEY5NkI7Ozs7NkJBQUFMLGdCQUFBSyxNQUFBTDtVQUlDZiw0QkFBQUE7O21CQUtEO1NBQ0hnK0I7S0FBSyxlQUFMQSxLQUhLOUI7O0dBRzBCO1lBR3ZDaUYsZUFBZTdtQztJQUNYLFlBZkppa0IsR0FjZWprQjtnQkFFUCxPQUFBO1FBQ0g4RztJQUFLLE9BQUxBO0dBQU07WUFHWGdnQyxjQUFjbEYsTUFBSzVoQztJQUNmLFlBQUEsV0FEVTRoQyxNQUFLNWhDO2tDQUVYOzJCQUNIOEcsZ0JBQUssMEJBQUxBO1FBQ0tMLGdCQUFIZjtJQUFTLFdBQVRBLGtCQUFHZTtHQUE0QjtZQUd0Q203QixLQUFLNWhDO0lBQ1AsSUFBZTRoQyxPQURSNWhDLE1BQ00wakMsTUFETjFqQyxNQUNNOEcsTUFBQTQ4QjtJQUNYO0tBQU0sWUFBQSxXQURPOUIsTUFBRjk2QjttQ0FFRDs7VUFFRUgsZ0JBQUhqQjtNQUFTLGVBQVRBLE9BQUdpQixLQUpDaTdCOztTQUFGbjdCO0tBQUFLLE1BQUFMOztHQU9zQjtZQUdqQzJwQixXQUFXcHdCO0lBQ2IsSUFDZTRoQyxPQUZGNWhDLE1BRUQ4RyxNQUZDOUc7SUFHWDtZQURVOEc7cUJBR0Y5RzthQUNFLFlBQUEsV0FKRzRoQyxNQUdMNWhDOzJDQUVNO29DQUNIOEcsZ0JBQUssV0FBTEE7OztrQkFFVUwsZ0JBQUhmO2NBQVMsV0FBVEEsR0FBR2U7O2lCQURGRTthQUFNLFdBQU5BO1lBQ29CO0dBQUU7WUFHekNxcEIsV0FBV2h3QixHQUFHdUMsR0FBSSxPQWJsQjZ0QixXQWE2QixrQkFBbEJwd0IsR0FBR3VDLElBQXlCO1lBQ3ZDNHRCLFlBQVlud0IsR0FBR3VDO0lBQUksT0FEbkJ5dEI7YUE3aEJBcHRCLEtBOGhCWTVDLFlBQWtDekUsR0FBRXlFLEdBQUssV0FBUHpFLEdBQUV5RSxHQUFTOztjQUFNLElBQVNBLGNBQUh6RTtjQUFTLE9BQUEsV0FBL0RnSCxHQUFzRGhILEdBQUd5RTthQUFZO0dBQUE7WUFFcEY2eUIsUUFBUTd5QixHQUNLOFU7SUFBZixJQUF1QjhzQixPQURiNWhDLE1BQ0cwakMsTUFESDFqQyxNQUNHOEcsTUFBQTQ4QixLQUFFbm9DLElBQUF1WixHQUFFNE87SUFDZjthQURhbm9CLEdBRVIsV0FBQSwyQkFGVW1vQixZQUFKNWMsS0FBVTg2QjtLQUliLFlBQUEsV0FKYUEsTUFBVjk2Qjs7TUFLQyxXQUFBLDJCQUxHNGMsUUFqV2Y4Zjs7VUFpV1cvOEI7TUFBQUssTUFBQUw7OztNQU93QjtPQVB4QkU7T0FPQWpCO09BUEltZSxjQU9KbmUsR0FQSWdlO09BQUZ0YyxNQU9jLDRCQVBkN0w7TUFBRnVMLE1BQUFIO01BQUVwTCxJQUFBNkw7TUFBRXNjLFFBQUFHOzs7R0FVdUI7WUFHdENrakIsV0FqckJhL2tDLE1BaXJCQThTO0lBQ2YsUUFEZUEsR0FFVixPQUFBO2FBbnJCZ0J2UyxFQXFyQlNEO0tBQzFCLElBQU0sUUFuQlJ1d0IsUUFrQjRCdndCLEdBSmZ3UyxJQU9UMUs7VUFBQUEsSUFEYztTQUNFNUI7S0FBSyxXQUFyQjRCLElBQWdCNUI7SUFBa0I7SUF4ckJmLFdBQVZ4RyxNQUFNTztHQXdyQm9CO1lBR3ZDZ2tCLE1BQU12bUIsR0FBR3VDO0lBQUksT0FqZmIrWTthQXZFQTFZLEtBd2pCTTVDLFlBQTRCekUsR0FBRXlFLEdBQUssV0FBUHpFLEdBQUV5RSxHQUFTOztjQUFNLElBQVNBLGNBQUh6RTtjQUFTLE9BQUEsV0FBekRnSCxHQUFnRGhILEdBQUd5RTthQUFZO0dBQUE7WUFFeEVzbUIsU0FBU3RtQixHQUFHdUM7SUFDUixZQXBmSitZLEtBbWZTdGIsR0FBR3VDO2dCQUVKLE9BQUE7UUFDSDNRO0lBQUssT0FBTEE7R0FBTTtZQUdYK1AsT0FBT3drQyxJQUFHRjtJQUNaLElBQ3NDRCxRQUYxQkMsT0FFc0JHLE9BRnRCSCxPQUVJQyxRQUZQQyxPQUVHRyxPQUZISDtJQUdQOzJCQURVRzs7YUFHTjtjQUVTLElBREtILGVBQ0wsUUFBQSxXQUxDRCxPQUlJQzs0Q0FFRCwyQkFOZUM7O21CQU9sQkU7ZUFBTSwwQkFBTkE7O2tCQUNLRSxpQkFBSDlnQztjQUFVLFdBQVZBLGtCQUFHOGdDOzthQUVOLElBRE1QLGVBQ04sVUFBQSxXQVZ1QkQsT0FTakJDOzZDQUVGOztrQkFDSEk7Y0FBTSwyQkFBTkE7O2lCQUNLRSxtQkFBSHQ4QjthQUFVLFdBQVZBLHFCQUFHczhCO1lBQWtDO0dBQUU7WUFHdkRyWixXQUFXbHRCLEdBQUd1QyxHQUFJLE9BQUEsbUJBQVB2QyxHQUFHdUMsR0FBYTtZQUMzQlYsT0FEVzdCO0lBQ0EsU0FER3VDLE9BQ0g7SUFETyxPQUFBLG1CQUFQdkMsR0FBR3VDO0dBQ2tCO1lBQ2hDNHFCLFlBQVludEIsR0FBR3VDO2FBRkRtdUI7S0FFaUQsSUFBUzF3QixjQUFIekU7S0FBUyxPQUFBLFdBQS9EZ0gsR0FBc0RoSCxHQUFHeUU7SUFBWTtJQUF0RCxJQUZuQjhHLE1BbGxCWGxFLEtBb2xCWTVDLFlBQWtDekUsR0FBRXlFLEdBQUssV0FBUHpFLEdBQUV5RSxHQUFTO0lBRnZDLE9BQUEsbUJBQVA4RyxLQUFHNHBCO0dBRXNFO1lBRXBGOUU7UUFBMENvYSxnQkFBSkMsYUFBbkJDLGtCQUFKQzthQUNidkU7S0FBTzs7OzZCQUNHMEUsZUFBSDVnQzs7O2FBR0UwZ0M7U0FBTSxvQkFBVSxXQUxlSixPQUsvQkk7O1lBSGdCQyxpQkFBSDFnQztRQUFVLGVBQXpCRCxHQUFlQyxZQUFaMmdDLFdBQWVEOzs7O1dBRWhCSixlQUFKRTtPQUFVLGVBQU0sV0FKSkQsT0FJWkMsS0FBSUY7OztLQURZO0lBRWE7SUFFdEMsbUJBUGlCRSxTQUF1QkYsTUFDcENyRTs7WUFTRm9GO1FBQStDaEIsZ0JBQUpDLGFBQW5CQyxrQkFBSkM7YUFDbEJ2RTtLQUFPLElBSVB1RTtlQUFBQTs7b0NBRmM7O1dBR0VDLGlCQUFIemdDO09BQVUsMEJBQVZBLFdBQWtDLFdBTkZxZ0MsT0FNN0JJOzs7O2VBRGhCRDtXQURTRSxpQkFBSkMsT0FDTEg7T0FEZSxlQUFNLFdBSkNELE9BSWpCSSxPQUFJRDs7OEJBRkNHLE9BR1ZMLE9BSE96Z0MsSUFHUHlnQzs7T0FFdUIsMEJBTGhCemdDLFFBS2lDLFdBUGxCd2dDLE9BRVpNOztXQUFlRCxtQkFBSHI4QjtPQUFVLDhCQUF6QnhFLEdBQWV3RSxlQUFaczhCLFdBQWVEOzs7U0FHaEJOO0tBQU0sZUFBZkUsSUFBeUIsV0FMb0JILE9BS3BDQztJQUUrQztJQUU1RCxtQkFUc0JFLFNBQXVCRixNQUN6Q3JFOztZQVdGcUYsc0JBQXdDQztRQUN0QnRGLGlCQUFMOTVCLGlCQUFGdk0sT0FBRXltQyxTQUFBbDZCO0lBQ2I7UUFGd0NvL0IsVUFDN0IzckMsR0FFTjtLQUVHLFlBQUEsV0FKVXFtQyxNQUFMSTttQ0FLRCxrQkFMRHptQzs7VUFBRTBtQztNQUFBRCxTQUFBQzs7O01BT2UsSUFQZmMsbUJBQUYzN0IsTUFPaUIsNEJBUGpCN0w7TUFBQUEsSUFBQTZMO01BQUU0NkIsU0FBQWU7Ozs7WUFZYm9FLHFCQUF1QmgvQixLQUFXclcsS0FBSXdRO0lBQ3hDLEdBRHlCNkYsU0FBTUMsTUFBTkQsUUFBQXBXLE1BQU1xVyxjQUFOclc7SUFhekIsR0Fib0NEO0tBZ0IzQixJQURGK0YsUUFmNkIvRixRQWdCM0IsVUE3QlBtMUMsZUFhc0Mza0MsR0FlakN6SztpRUFFRTRKLHFCQWpCZ0IxUCxPQWlCaEIwUCxLQUF1QjtLQUN0Qjs7UUFqQjJCbWdDLE9BREd0L0IsTUFFekJ0QyxJQUZ5QnNDLE1BRXpCd0UsTUFBQTlHLEdBQUU4YTtJQUNiO1FBSHFCL29CLE9BRVIrb0IsS0FFUjtLQUVHLFlBQUEsV0FMeUI4bUIsTUFDdEI5NkI7bUNBS0M7O1VBTERMO01BQUFLLE1BQUFMOzs7TUFPZ0IsSUFQaEJFLGdCQUFFNmxCLFFBT2MsNEJBUGQxUjtNQUFGaFUsTUFBQUg7TUFBRW1VLE1BQUEwUjs7O0dBZ0JEO1lBR2Q5cEIsTUFBTTFDLEdBQUd1QztJQUFJLE9BamZiRTthQTdKQUcsS0E4b0JNNUMsWUFBNEJ6RSxHQUFFeUUsR0FBSyxXQUFQekUsR0FBRXlFLEdBQVM7O2NBQU0sSUFBU0EsY0FBSHpFO2NBQVMsT0FBQSxXQUF6RGdILEdBQWdEaEgsR0FBR3lFO2FBQVk7R0FBQTtZQUV4RWdzQixNQUFNaHNCLEdBQUdnQyxNQUFNTztJQUNqQixPQTd0QkVGO2FBNEVBTyxLQWdwQk01QyxZQUNtQnpFLEdBQUV5RSxHQUFLLFdBQVB6RSxHQUFFeUUsR0FBUzthQUQzQmdDO3NCQUNzQzhZO2NBQUwsSUFBYTlhLGNBQUh6RTtjQUFTLE9BQUEsV0FEOUNnSCxHQUNxQ2hILEdBQUx1ZixLQUFROWE7YUFBZ0I7R0FBQTtZQUd2RWtzQixPQUFPbHNCLEdBQUd1QztJQUNOLFlBaEpKcS9CLEtBK0lPNWhDO2dCQUVDOzRCQUNDOEcsa0JBQUhwQjtJQUFTLFdBbnVCZnJELEtBbXVCU3lFLEtBQUhwQixHQUhJbkQ7R0FHNkI7WUFHdkM0cEIsV0FBV25zQixHQUFHdUM7SUFDVixZQVBKMnBCLE9BTVdsc0IsR0FBR3VDO2dCQUVOLE9BQUE7UUFDSGlEO0lBQU8sT0FBUEE7R0FBVTtZQUdmd25CLGFBQTRCSDtRQUFSK1UsaUJBQUg1aEM7YUFueUJFdUM7S0FzeUJoQixZQUNTO0tBRUk7O01BRER2QztNQUFMOGE7TUFDTSxVQUFBLFdBTkk4bUIsTUFLTDVoQzs7VUFFQTJHO01BQUssbUJBRlZtVSxLQUVLblU7O1FBRkxtVTs7T0FJVSxXQUFPLDJCQUpqQkE7VUFNNkJoVSxrQkFBTHNnQyxrQkFBMUI1WCxPQU5FMVU7TUFPQSxPQUFBLFdBWmtCK1IsU0FXcEIyQyxNQUEwQjRYOztnQkFFZiwyQkFSVHRzQjs0QkFNd0Jzc0IsU0FBS3RnQztnQ0FBTHNnQyxLQU54QnRzQixNQU02QmhVOztxQ0FIcEI7U0FFSUwsa0JBQUw0Z0M7S0FBVyx1QkFBWEEsV0FBSzVnQztJQUlrQjtJQVpuQyxJQXJ5Qk96RSxrQkFteUJJaEM7SUFueUJNLFdBQVZnQyxNQUFNTzs7WUFvekJuQjByQixrQ0FBaURyMUI7UUFBUmdwQyxpQkFDckI1aEMsY0FBVHNuQyxjQUFTeGdDLE1BQUE5RztJQUNwQjtLQUFNLFlBQUEsV0FGbUM0aEMsTUFDckI5NkI7bUNBRVY7O1VBRlVMO01BQUFLLE1BQUFMOzs7VUFBQUUsZ0JBSVhqQjtNQUNQLEdBTFM0aEM7V0FNRDNoQyxJQU5DMmhDO09BTU0sR0FBQSxXQVBnQzF1QyxPQUt4QzhNLEdBRUNDLElBQW9CLGVBQXBCQSxHQUZERDs7TUFHa0IsSUFQaEI2aEMsaUJBSUY3aEM7TUFKRTRoQyxXQUFBQztNQUFTemdDLE1BQUFIOzs7O1lBWXBCMG5CLDhCQUE4QnJ1QixHQUFHcEg7SUFDbkMsT0F6ekJFbXBDO2FBd3pCOEIvaEM7O3NCQUNDd3ZCLE1BQUs5cEI7Y0FDcEMsR0FEK0I4cEI7bUJBRXhCN3BCLElBRndCNnBCO2VBRWpCLEdBQUEsV0FIbUI1MkIsT0FDRzhNLEdBRTdCQyxJQUFvQixlQUZTRDs7Y0FHakIsV0FIaUJBLE9BQUFBO2FBR0E7R0FBQztZQUdyQ2dWLE1BQU0xYSxHQUFHdUMsR0FBSSxPQTVwQmI2QixPQWpCQThoQixPQTZxQk1sbUIsR0FBR3VDLElBQXdCO1lBQ2pDc3RCLE9BQU92dEIsR0FBR0MsR0FBSSxPQTdwQmQ2QixPQUpBNm5CLFFBaXFCTzNwQixHQUFHQyxJQUF5QjtZQUNuQ29ZLElBQUltQixHQUFFeFosR0FBR0MsR0FBSSxPQUFBLDhCQW54QmJGLE1BbXhCSXlaLEdBQUV4WixHQUFHQyxHQUE4QjtZQUN2QzJZLFFBQVE1WSxHQUFHM0o7SUFBVSxPQUFBLDhCQXB4QnJCMEosTUFveEJRQyxHQUFHM0o7R0FBNEM7WUFDdkR5aUIsUUFBUTlZLEdBQUczSjtJQUFVLE9BQUEsOEJBcnhCckIwSixNQXF4QlFDLEdBQUczSjtHQUE0QztZQUV2RHFKLEtBQUs4UyxHQUFHdlM7YUE5MEJXbXVCLElBKzBCT24xQjtLQUFLLEdBRDFCdVosS0FDcUJ2WixHQUFvQjtLQUFzQixVQUFBLDRCQUExQ0E7S0FBOEIsV0FBTyxXQUR2RGdILEdBQ2tCaEg7SUFBZ0Q7SUEvMEJuRCxjQUFKbTFCO0dBKzBCd0Q7WUFHM0V2dUIsSUFBSW5DLEdBQUdnZCxLQUFLdmI7SUFDZCxVQURTdWIsK0JBQUt2YjtZQUNhO1FBRVptZ0MsT0FIVDVoQyxNQUdNOEcsTUFITjlHO0lBSUo7bUJBRFU4Rzs7YUFHTixJQUFROUcsY0FBSHpFO2dCQU5Ha0csT0FPTCw0QkFERWxHLEdBTkZ5aEIsTUFRRTthQUVHLFlBQUEsV0FQQzRrQixNQUdENWhDOzJDQUtJO29DQUNIOEcsZ0JBQUssZUFOVHZMLEdBTUl1TDtpQkFDRXBCLGNBQUdlO2dCQWJYdVcsT0FNRXpoQjtjQU82QixXQUF2Qm1LLE9BQWtDLDRCQVB4Q25LLE9BT1NrTDtpQkFDQUU7YUFBTSxlQUFNLDRCQVJyQnBMLE9BUVNvTDtZQUFzQjtHQUFFO1lBRzFDb3NCLEtBQUsveUIsR0FBRXlCO0lBQ1QsR0FEU0EsU0FDTztRQUVEbWdDLE9BSFI1aEMsTUFHSzhHLE1BSEw5RztJQUlMO21CQURVOEc7O2FBR04sSUFBUTlHLGNBQUh6RTtnQkFORmtHLE9BTUVsRyxHQUVBO2FBRUcsWUFBQSxXQVBDcW1DLE1BR0Q1aEM7MkNBS0k7b0NBQ0g4RyxnQkFBSyxlQU5UdkwsR0FNSXVMO2lCQUNLTCxnQkFBSGY7YUFBUyxXQUFUQSxPQUFvQiw0QkFQMUJuSyxPQU9Ta0w7WUFBNEI7R0FBRTtZQUdoRHVzQixLQUFLaHpCLEdBQUV5QjtJQUNULEdBRFNBLFNBQ087UUFFRG1nQyxPQUhSNWhDLE1BR0s4RyxNQUhMOUc7SUFJTDttQkFEVThHOzthQUdOLElBQVE5RyxjQUFIekUsY0FDQyxRQUFBLFdBSkdxbUMsTUFHRDVoQzsyQ0FFRTtvQ0FDSDhHLGdCQUFLLGVBSFB2TCxHQUdFdUw7aUJBQ0VwQixjQUFHZTtnQkFWVGhGLE9BTUVsRztjQUkyQixXQUF2Qm1LLE9BQWtDLDRCQUp0Q25LLE9BSU9rTDtpQkFDQUU7YUFBTSxlQUFNLDRCQUxuQnBMLE9BS09vTDtZQUFxQjtHQUFFO1lBR3ZDMHNCLFdBQVdyekIsR0FBR3VDO0lBQ2hCLElBQ2VxL0IsT0FGRjVoQyxNQUVEOEcsTUFGQzlHO0lBR1g7WUFEVThHO3FCQUdGOUc7YUFDRSxZQUFBLFdBSkc0aEMsTUFHTDVoQzsyQ0FFTTtvQ0FDSDhHLGdCQUFLLFdBQUxBO2lCQUNFcEIsY0FBR2U7YUFBUSxPQUFBLFdBVFZsRSxHQVNEbUQsU0FBQUEsR0FBR2U7WUFDVTtHQUFFO1lBRzVCNnNCLFdBQVd0ekIsR0FBR3VDO0lBQ2hCLElBQ2VxL0IsT0FGRjVoQyxNQUVEOEcsTUFGQzlHO0lBR1g7NEJBRFU4Rzs7YUFHTjtrQkFPWTlHO2NBQUssT0F6UnJCOG1DLGNBK1FhbEYsTUFVRzVoQzs7YUFMSCxJQURHOEcsZ0JBQ0gsUUFBQSxXQUxBODZCLE1BSUc5NkI7MkNBRUM7O2tCQUNITDtjQUFLLDJCQUFMQTs7aUJBRUVmLGNBREdpQjthQUFRLEdBQUEsV0FWYnBFLEdBV0VtRCxJQURrQiwyQkFBZmlCO2lCQUNBKzhCO2FBQU0sV0FBVGgrQixrQkFBR2crQjtZQUNzQjtHQUFFO1lBRzNDOEQsWUFBWXhuQyxHQUFFcE87SUFDaEIsSUFDa0Jnd0MsT0FGSjVoQyxNQUVGOEgsT0FGRTlIO0lBR1o7Z0NBRFU4SCxNQUZJbFc7O2FBS1Y7a0JBRVlvTztjQUFLLE9BblNyQjhtQyxjQThSZ0JsRixNQUtBNWhDOzttQ0FETXBPLGNBQU5rVzthQUFZLFdBQU5sVyxrQkFBTmtXO1lBQ3lCO0dBQUU7WUFHM0MyL0Isc0JBQXNCem5DLEdBQUVzRixHQUFJLE9BcE81QjNELE9BbnBCQU8sUUF1M0J3Qm9ELElBQUZ0RixHQUEwQjtHQUdyQztJQUFBLFlBdk9YMkI7O1lBMk9BMnpCLFlBQVl0MUIsR0FBRzZVO0lBQ2pCLElBQ2Urc0IsT0FGRDVoQyxNQUVGOEcsTUFGRTlHO0lBR1o7MkJBRFU4Rzs7YUFHTjs7Y0FFUyxJQUREOUcsY0FDQyxRQUFBLFdBTEE0aEMsTUFJRDVoQzs0Q0FFSzs7bUJBQ0g4RztlQUFLLDBCQUFMQTs7a0JBQ0tMLGdCQUFIZjtjQUFTLFdBQVRBLGtCQUFHZTs7O3NDQU1BaWhDLGtCQUFIQztjQUFTLFdBQVRBLG9CQUFHRDs7YUFKTixJQURFL2dDLGdCQUNGLFVBQUEsV0FWQWk3QixNQVNFajdCOzZDQUVFOztrQkFDSCs4QjtjQUFLLDBCQUFMQTs7aUJBQ0trRSxrQkFBSDM5QjthQUFTLFdBZlY0Syx5QkFlQzVLLEtBQUcyOUI7WUFDMkI7R0FBRTtZQUdoREMsT0FqOEJhN2xDO0lBaThCRixTQWo4QlFPLEVBaThCb0IzUSxHQUFLLFdBQUxBLEdBQUFBLEdBQWlCO0lBajhCakMsV0FBVm9RLE1BQU1PO0dBaThCc0M7WUFFekR1bEMsZUFBZTE5QjtJQUNqQixHQUFHLDJCQURjQTtLQUNRO0lBQ2pCLElBQUpwSyxJQXI1QkZrQyxRQW01QmVrSTtJQUdqQixTQWpQZ0I3SCxTQWlQUyxPQURyQnZDLEVBQ3NCO0lBQUUsSUFqUGY4RyxNQTRPWCtnQztJQTVPa0IsT0FBQSxtQkFBUC9nQyxLQUFHdkU7R0FpUHVCO1lBR3JDa3hCLGtCQXBQV3NVLElBb1BVQzthQXBQUHpsQyxFQW9Qa0NtRCxHQUFLLE9BaFByRGttQixJQXdPQWljLE9BUWdEbmlDLElBQTNCc2lDLElBQWlEO0lBcFBwRCxPQUFBLG1CQUFQRCxJQUFHeGxDO0dBb1B5RDtZQUN2RTBsQyxVQUFVcjJDLEdBQUksT0FBQSxxQkFBSkEsR0FBWTtZQUV0QnMyQyxhQUFhbG9DLEdBQUdnQyxNQUFNTyxHQUFHMFk7SUFDM0IsT0FBQTs7YUFEZWpiO2FBQUdnQztzQkFDK0I4WSxLQUFJcXRCLFFBQVFyVztjQUMzRCxLQURtRHFXLFFBRXpDLE9BQUEsV0FGaURyVyxHQUFaaFg7a0JBR3hDcFYsSUFINEN5aUM7Y0FHdkMsT0FBQSxXQUpVNWxDLEdBQ3lCdVksS0FHeENwVixHQUhvRG9zQjthQUdyQzthQUpHN1c7R0FJRjtZQUd2Qm10QixPQUFRcjRCLE1BQU1OLFVBQU9uTixHQUFHTixNQUFNTztJQUNoQyxPQUFBOzthQUR1QkQ7YUFBR047c0JBSWhCOFksS0FBSXF0QixRQUFRclc7Y0FDbEIsS0FEVXFXO2VBRUEsT0FBQSxXQU5KcDRCLE1BTVMsV0FOSE4sVUFJTnFMLE1BQVlnWDtrQkFHWHBzQixJQUhHeWlDO2NBR0UsT0FBQSxXQVBOcDRCLE1BT1csV0FQV3hOLEdBSXRCdVksS0FHQ3BWLElBSFdvc0I7YUFHYTthQVBuQnJpQjtHQVFBO1lBR2Q0NEIsT0FBUXQ0QixNQUFNTixVQUFPbk4sR0FBR0M7SUFDMUIsT0FBQTs7YUFEdUJEOzs2QkFJVjZsQyxRQUFRclc7Y0FDakIsS0FEU3FXO2VBRUMsT0FBQSxXQU5KcDRCLE1BTVMsV0FOSE4sY0FJS3FpQjtrQkFHVnBzQixJQUhFeWlDO2NBR0csT0FBQSxXQVBOcDRCLE1BT1csV0FQS3hOLEdBT2ZtRCxJQUhVb3NCO2FBR1U7YUFQZnJpQjtHQVFBO1lBR2R1TCxXQUFXaGIsR0FDU2dDLE1BQUZPLEdBREswWTtJQUN6QixJQUFlMm1CLE9BREY1aEMsTUFDQTBqQyxNQURBMWpDLE1BQ0E4RyxNQUFBNDhCLEtBQVM1b0IsTUFBQTlZO0lBQ3BCO0tBQU0sWUFBQSxXQURPNC9CLE1BQUY5NkI7bUNBRUQsT0FBQSxXQUhhbVUsUUFDSEg7O1VBQVRyVTtNQUFBSyxNQUFBTDs7O01BS0QsSUFMQ0UsZ0JBSUZqQixjQUNDLFVBQUEsV0FMUW5ELEdBQUV1WSxLQUlYcFY7K0JBRUM5VCxnQkFBSyxPQUFMQTtVQU5VNDZCO01BQVQxbEIsTUFBQUg7TUFBU21VLE1BQUEwUjs7O0dBVW9CO1lBR3hDM1IsWUFBWTdhLEdBQ1FnQyxNQUFGTztJQUFwQixJQUFlcS9CLE9BREQ1aEMsTUFDRDBqQyxNQURDMWpDLE1BQ0Q4RyxNQUFBNDhCLEtBQVM1b0IsTUFBQTlZO0lBQ3BCO0tBQU0sWUFBQSxXQURPNC9CLE1BQUY5NkI7bUNBRUQsT0FBQSw0QkFGVWdVOztVQUFUclU7TUFBQUssTUFBQUw7OztNQUtELElBTENFLGdCQUlGakIsY0FFSnlCLElBREssV0FMUTVFLEdBQUV1WSxLQUlYcFY7ZUFFSnlCLE1BQWdCLE9BQWhCQTtVQU5lcWxCLFFBTWZybEI7TUFOTUwsTUFBQUg7TUFBU21VLE1BQUEwUjs7O0dBVW9CO1lBR3hDOGIsY0FBY2htQyxHQUFJLE9BcjlCbEJKLFFBcUJBRSxRQWc4QmNFLElBQXVCO1lBRXJDaW1DO0lBQVEsSUFBdUIzRyxpQkFBSDVoQzthQUt0QnVvQyxRQUNNdm9DO0tBRE07OzttQkFDTjhHLE1BQUE5RztlQUNaO2dCQUFNLFlBQUEsV0FQeUI0aEMsTUFNbkI5NkI7OENBRUY7O3FCQUVFSCxnQkFBSGpCO2lCQUFTLFdBQVRBLEdBTEg2aUMsUUFLTTVoQzs7b0JBSkFGO2dCQUFBSyxNQUFBTDs7O0lBRDhCO0lBTzVDO1lBUFE4aEMsUUFMc0J2b0M7O2FBWVQsSUFBU3NGLGlDQUFBQTs7dUJBQUFBO3FDQUFNLGdDQUFOQSxLQUFBQTtZQUFrQjtHQUFDO1lBRy9Da2pDLGFBQWF4b0MsR0FDQ3lCO0lBQWhCLElBQXNCbWdDLE9BRFA1aEMsTUFDSzBqQyxNQURMMWpDLE1BQ0Z6RSxPQUFPdUwsTUFBQTQ4QjtJQUNsQjtRQURjamlDLE9BQUhsRyxHQUVOLFdBRmF1TCxLQUFFODZCO0tBSVosWUFBQSxXQUpZQSxNQUFGOTZCO21DQWhCVixPQXBzQlIwOEI7O1VBb3RCa0IvOEI7TUFBQUssTUFBQUw7OztNQU9PLElBUFBFLGdCQUFQUyxNQU9jLDRCQVBkN0w7TUFBQUEsSUFBQTZMO01BQU9OLE1BQUFIOzs7R0FVc0I7WUFHeEM4aEMseUJBQXdDbG1DO1FBQVJxL0IsaUJBQ3JCNWhDLGNBQUE4RyxNQUFBOUc7SUFDWDtLQUFNLFlBQUEsV0FGMEI0aEMsTUFDckI5NkI7bUNBRUQ7O1VBRkNMO01BQUFLLE1BQUFMOzs7VUFJQ0UsZ0JBQUgvVTtNQUFZLEtBQUEsV0FMbUIyUSxHQUsvQjNRLElBQWlDLGVBQWpDQSxPQUFHK1UsS0FMb0JpN0I7TUFDckI5NkIsTUFJQ0g7Ozs7WUFLWmhOLFVBQVFpakIsV0FBVWxaLElBQUdDO0lBQ3ZCLE9BQXdCOztzQkFBS29HO2NBL3dCM0J0SDtnQkFtY0F1a0MsU0EyVWtCdGpDLElBQUdDOztpQkFFSTs7OzRCQUNWLFdBRllvRzs0QkFHWCxXQUhXQTtpQkFLZjs7a0JBREcyK0I7a0JBQUpDO2tCQUNINzJCLElBQUksV0FOSjhLLFdBS0crckIsSUFBSUQ7OEJBQ1A1MkI7OEJBQ1csV0FOUS9ILEdBS25CK0g7Z0JBQ3NCO2NBTDlCO2FBTUM7R0FBQztZQUdGbFosTUFBTWlrQixTQUFRblosSUFBR0M7SUFDbkIsT0F4MEJFa0I7YUFpZkFtaUMsU0FzVmN0akMsSUFBR0M7O2NBQ1MsMkJBRUY7b0NBRFh5cUIsZUFBSkY7Y0FBVyxPQUFBLFdBRmRyUixTQUVHcVIsSUFBSUU7YUFDaUI7R0FBQTtZQUc5QndhLFlBQVloaUM7SUFDZCxTQUFJZzdCO1NBQWtCaUgsdUJBQVpDO0tBQ1IsS0FEUUE7TUFPRyxPQUFBLDJCQVBTRDs7d0JBT3FDLDJCQVByQ0E7S0FHWDtNQURZRSxlQUZiRDtjQUFBQTtNQUVPdm1DO01BQUh2QztNQUNILFVBQUEsV0FETXVDLEdBQUh2Qzs7TUFJQyxlQUpRK29DLGNBRkRGOztVQUtWL2hDO01BQUssdUJBQUxBLEtBSEt2RSxJQUFNd21DLGVBRkRGOztTQUlMcGlDLGtCQUFIN1U7S0FBUyxXQUFUQSxPQUZTbTNDLHNCQUVOdGlDLEtBRkFsRSxJQUZLc21DOztJQVNWLElBQVJ0Z0MsWUFWVTNCO0lBV2QsV0FESTJCLE9BVEFxNUI7R0FVa0I7WUFHcEJvSDtRQUEwQnpnQixlQUFKNGQ7SUFDeEIsU0FBSXZFO1NBQThCdUUsZUFBWjBDLHVCQUFaQztLQUNSLEdBRFFBO01BR0M7T0FEY0MsZUFGZkQ7ZUFBQUE7T0FFUXRnQjtPQUFKeWQ7T0FDSCxVQUFBLFdBRE96ZCxJQUFKeWQ7O09BSUMsZUFKVThDLGNBRkhGLFlBQVkxQzs7V0FLdEJDO09BQU0sZUFITzJDLHNCQUdiM0MsTUFITTVkLEtBRklxZ0IsYUFBWTFDOztVQUlqQkUsbUJBQUh6MEM7TUFBVSxXQUFWQSxPQUZXbTNDLHNCQUVSMUMsTUFGQzdkLEtBRklxZ0IsYUFBWTFDOztLQVF2QixjQUFBLFdBVGlCNWQsSUFDTTRkOzthQUFaMEM7d0JBV08sMkJBWFBBLGdCQUFZMUM7OztVQVV0Qkc7TUFBUyxlQUFNLDJCQVZMdUMsZ0JBVVZ2Qzs7U0FES0UsbUJBQUhsa0M7S0FBYSxlQUFNLCtCQUFuQkEsR0FUUXVtQyxpQkFTTHJDOztJQUtMLElBQVJqK0Isa0JBZm9CNDlCO0lBZ0J4QixXQURJNTlCLE9BZEFxNUI7O1lBa0JGcUgsOEJBQThCOUMsSUFBR0Y7SUFDbkMsT0FwQkUrQzthQW9CRjs7ZUFEZ0M3Qzt3QkFDakJsZjtnQkFBTSxPQUFVO2dDQURJZ2YsYUFDQy9lLElBQU0sV0FBM0JELElBQXFCQyxJQUFZO2VBQUM7R0FBZTtZQUc5RGdpQixPQXBtQ2FsbkM7SUFxbUNmLFNBcm1DcUJPLEVBcW1DUzRtQztLQUN0QixZQUFBLFdBRHNCQTtpQkFFbkI7U0FDR2xsQixlQUFKRDtLQUFXLFdBQVhBLElBQUlDO0lBQXFCO0lBeG1DVixXQUFWamlCLE1BQU1PO0dBd21DZTtZQUdsQzZtQztRQUF5QnhILGlCQUFQcjVCO0lBQ3BCLFNBQVFtSSxLQUFLbkk7S0FDWCxJQURXKzVCLFVBQUEvNUI7S0FDWDtNQUFNLFlBQUEsV0FGbUJxNUIsTUFDZFU7b0NBRUQ7O1dBRUdFLG9CQUFKeGU7T0FBYyxXQUFkQSxvQkFBMkMsT0FKOUN0VCxLQUlPOHhCLFNBQWlEOztVQUpuREQ7TUFBQUQsVUFBQUM7O0lBSW9EO0lBRWpFLHVCQUFVLE9BTkY3eEIsS0FEWW5JLE9BT0E7O1lBV2Q4USxTQUFPem5CLEdBQUVrZ0MsR0FBSSxPQUFBLFdBQUpBLEdBQUZsZ0MsR0FBUztZQUVoQnVuQixPQUFLMkMsR0FBR3ZaLEdBQUV1dkI7SUFDWixPQUFFO2FBREtoVztzQkFDQXBXLEdBQ0ksSUFBTG9XLElBQUssV0FGRHZaLEdBQ0htRCxJQUVMLE9BQUEsV0FESW9XLEdBRk1nVyxHQUdOO0dBQUM7R0FJQztJQUFOMVk7OztnQkFESTBDLEdBQUd2WixHQUFFdXZCO1FBQUksT0FBRTtpQkFBWGhXLFlBQWdCcFcsR0FBSyxPQUFFLFdBQWxCb3NCLEdBQWtCLFdBQXBCdnZCLEdBQWFtRCxJQUFZO09BQUM7OENBTmpDeVQsUUFPQUMsT0FUQUM7Ozs7Ozs7Ozs7Ozs7WUFlRmd3QixRQUFNbGlDLEdBQUUycUIsR0FBSSxlQUFOM3FCLEdBQUUycUIsSUFBdUI7WUFHL0J3WCxZQUFZQztJQUNkLE9BcE1BckI7YUFtTWNxQjs7NkJBSUQzM0MsR0FBR2tnQyxHQUFFdnZCO2NBQUssZUFBVjNRLG1CQUFvQyxPQUExQixXQUFQa2dDLE1BQUV2dkIsR0FBcUM7YUFBRTs7R0FDekM7WUFHZDBGLElBQUkzRjthQXZwQ09OLFlBd3BDQyxPQVhHLFdBVVhNLG1CQVZzQixXQUFTLEdBV2I7SUFDeEIsU0F6cENtQkMsRUF5cENiaW5DLE9BQVEsSUFqQ0NwRyxPQWlDTSxXQUFmb0csY0FqQ2lCLE9BQVJwRyxLQWlDZ0I7SUF6cENSLFdBQVZwaEMsTUFBTU87R0EwcENDOzs7O09BdmtDcEIyTDtPQXMrQkF0VjtPQVhBZTtPQXR2QkFnakI7T0E1SUF2WTtPQWlJQWlTO09BYkE1VDtPQXpPQUo7T0FnOEJBd1k7T0FkQUc7T0FodUJBeFc7T0F2QkFLO09Bc2xCQTZWO09BRUFDO09BaG9CQVc7T0FXQUQ7T0FoSkFqWjtPQW9IQW1aO09Ba3BCQUw7T0FDQUU7T0F6REE0UTtPQUZBdHBCO09BN2ZBb2tCO09BcWpCQStJO09BOUlBdEo7T0F2ZEFHOzs7Ozs7Ozs7Ozs7T0ErRkE4YztPQXFVQTVCOztPQXhvQkFDO09BRUFDO09BT0FDO09BZ0JBRztPQTJVQWhlO09BY0FDO09Bbk9BaUc7T0FNQTBCO09BbEJBbHBCO09BcUNBcXBCO09BYkEvRjtPQXNhQXlnQjtPQUFBQTtPQWFBQzs7T0FqQ0FiO09BK0NBL2hCO09BV0E3ZjtPQU1BOGY7T0FjQTRpQjtPQWtFQXZnQjtPQWhjQU87T0FzY0FsbEI7T0FtQkFFO09BREFxckI7T0FFQUM7T0FzWEE2YjtPQWRBSjtPQXRXQWhkO09BVUFvYjtPQTBEQTdhO09BTkFEO09BWUFjO09BaUJBaUI7T0FhQUk7T0E1dUJBckw7T0F5dkJBaGhCO09BOUtBZ3VCO09BQ0FHO09BZEFDO09BK0xBanVCO09BaUJBNHdCO09BZ0JBQztPQW1LQXdWO09BckpBblY7T0FhQUM7T0FzSkFtVjtPQWpZQTVWO09BY0FrVTtPQTRPQVM7T0FVQUM7T0FwREF6VTs7T0FzRkFTO09BdUpBd1Y7T0FsTEEzVDtPQXFCQXdTO09BRkFEO09BU0FJO09BRUFDO09BT0FFO09BV0FDO09BNTVCQXBGO09BbEJBL2dDO09BdURBMDJCO09BZzZCQTJQO09BRkFEO09BdFJBckI7T0FhQUU7T0F3V0ErQjtPQU9BRTs7Ozs7Ozs7Ozs7OztRQWlDRUM7UUFHQUM7UUFRQXJoQzs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDbnRDRnRQO0lBQ0FxYTtJQUNBNUc7WUFFQ0YsZUFDQ3VMO0lBQW9CLE9BQUEsNkJBQXBCQTtHQUF1RDtZQW9DdkRwRCxnQjtZQUNBbzFCO0k7OztZQUVBQyxPQUFLMVYsS0FBSXo0QixHQUFFd0g7SUFDSCxJQUFONG1DLE1BSkZ0MUIsSUFHSzJmLEtBQUl6NEI7SUFGVGt1QyxJQUVLelYsS0FBSXo0QixHQUhUOFksSUFHSzJmLEtBQU1qeEI7SUFFYixPQUpFMG1DLElBRUt6VixLQUFNanhCLEdBQ1Q0bUM7R0FFUztZQWNUdGtDLEtBV2EydUIsS0FBV3I3QixTQUFOaXhDLE1BWE9DO0lBR2pCLFdBQUEsNEJBUVVEO09BWE9DO1NBV083c0I7O01BUXhCLElBUjBCbk0sSUEvQnBDd0QsSUErQmUyZixLQUFtQmhYLE1BUzVCOHNCLFlBVDRCOXNCO01BQzlCO09BQWEsSUFBVCtzQixTQUFTLDRCQVFYRDtVQVRjRixPQUNaRztPQUNpQixRQUFBLFdBRkNweEMsU0EvQjFCMGIsSUErQmUyZixLQUNQK1YsU0FENEJsNUI7T0E5QnBDNDRCLElBOEJlelYsS0FTVDhWLFdBeENOejFCLElBK0JlMmYsS0FDUCtWO09BUUZELFlBUkVDOztNQS9CUk4sSUE4QmV6VixLQVNUOFYsV0FUOEJqNUI7TUFSMUIsV0FRd0JtTTtTQVhQNnNCLFVBV083c0I7TUFBQUE7Ozs7R0FXOUI7R0F2QnVCLHlCQUN6QjNYO1lBOEJJMmtDLFFBQVFoVyxLQUFLcjdCLFNBQVFzeEMsTUFBTUwsTUFBTUM7SUFDdkMsSUFEMkJLLFNBQUFEO0lBQzNCO0tBQW9CO01BQWhCRSxnQkFBZ0IsNEJBRE9ELFFBQU1OO01BRWhCLE9BQUEsK0JBRGJPO01BQ2EsT0FBQSxrQ0FGZ0JQO01BRTdCUSxhQUFhO01BQ0MsT0FBQSwrQkFGZEQ7TUFFYyxPQUFBLGtDQUhlUDtNQUc3QlMsY0FBYzs7O1NBRGRELGNBRm1DUDtPQUtrQixXQXZEekR4MUIsSUFrRGMyZixLQUFha1c7T0FLQyxPQUFBLFdBTFR2eEMsU0FsRG5CMGIsSUFrRGMyZixLQUVWb1csd0JBRUFFLFVBRkFGOztVQUVBRSxVQUp1Qko7Ozs7U0FHdkJHLGVBSG1DUjtPQVVvQixXQTVEM0R4MUIsSUFrRGMyZixLQUlWc1c7T0FNeUIsT0FBQSxXQVZWM3hDLFNBbERuQjBiLElBa0RjMmYsS0FHVnFXLHlCQUh1QkUsWUFHdkJGOztVQUh1QkUsWUFJdkJEOztnQkFKdUJDLGNBQUFMOztLQS9DM0JSLE9BK0NjMVYsS0FBYWtXLFFBQUFLO0tBQUFMLFNBQUFLOztHQWlCaUI7WUFZMUNDLE9BQUt4VyxLQUFLcjdCLFNBQVNpeEMsTUFBTUM7SUFDM0I7S0FOUSxPQUFBLDRCQUthRCxNQUFNQztLQUxuQixPQUFBO2VBS2FEO1NBTHJCcnVDOztNQXhCTXl1QyxRQTZCQ2hXLEtBQUtyN0IsU0FMWjRDLEdBS3FCcXVDLE1BQU1DO01BSnpCLFdBREZ0dUM7U0FLcUJxdUMsU0FMckJydUM7TUFBQUE7OztJQVdxQixXQUFBLDRCQU5BcXVDO09BQU1DO1NBTTNCemlDLE1BTjJCeWlDOztNQTVFM0JILE9BNEVPMVYsS0FBYzRWLE1BTXJCeGlDO01BbkNNNGlDLFFBNkJDaFcsS0FBS3I3QixTQUFTaXhDLE1BQUFBLE1BUW9CLDRCQUZ6Q3hpQztNQUVFLFdBRkZBO2tCQUFBQTtNQUFBQTs7OztHQUdJO0dBekNrQixvQkFnQ3BCb2pDO1lBMkJBQyxrQkFBa0J6VyxLQUFLcjdCLFNBQVEreEMsSUFBR0MsSUFBR0MsSUFBR0MsSUFBR0M7YUFDekNDLGlCQUFpQnh2QyxHQUFFd0g7S0FDckI7TUFBdUIsT0E1R3pCc1IsSUEwR29CMmYsS0FDR2p4QjtpQkFDbEIsV0FGb0JwSyxTQTFHekIwYixJQTBHb0IyZixLQUNDejRCO21CQXhHckJtdUMsT0F1R29CMVYsS0FDQ3o0QixHQUFFd0g7SUFDbUM7SUFEdERnb0MsaUJBRDZCTCxJQUFHQztJQUNoQ0ksaUJBRHNDRixJQUFHQztJQUN6Q0MsaUJBRDZCTCxJQUFNRTtJQUNuQ0csaUJBRGdDSixJQUFHQztJQUNuQ0csaUJBRDZCTCxJQUFTRztJQUN0Q0UsaUJBRG1DSCxJQUFHQztJQUN0Q0UsaUJBRGdDSixJQUFTRztJQUN6Q0MsaUJBRGdDSixJQUFHQztJQXdCdkMsT0F2QklHLGlCQURzQ0YsSUFBR0M7R0F5QnZCO1lBMkRoQkUsV0FBV2hYLEtBQUtpWCxXQUFXdHlDLFNBQVNpeEMsTUFMN0JDO0lBTWIsSUFEc0JxQixjQUFBRCxXQUxiRSxTQUtpQ3ZCO0lBQzFDO0tBQVU7TUFBQSxPQUFBLDRCQU5HQyxPQUFKc0I7TUFNTDFwQyxNQUFNO0tBSVYsU0FKSUE7TUFLQyxPQUFBLDhCQU5ZdXlCLEtBQWdCcjdCLFNBTHhCd3lDLFFBQUl0QjtZQUtTcUI7TUFRakIsT0FBQSx5QkFSWWxYLEtBQWdCcjdCLFNBTHhCd3lDLFFBQUl0QjtLQWVLO01BVkl1QixjQVVKLDRCQVZJRjtNQS9DVixPQUFBLDRCQTBDQ3JCLE9BQUpzQjtNQTFDTEUsUUFBUTtNQUNSWCxLQUFLLDRCQXlDQVMsUUExQ0xFO01BRUFWLEtBQUssNEJBRExELElBREFXO01BR0FULEtBQUssNEJBRExELElBRkFVO01BSUFSLEtBQUssNEJBRExELElBSEFTO01BS0FQLEtBQUssNEJBRExELElBSkFRO0tBckNGWixrQkFvRmV6VyxLQUFnQnI3QixTQTlDN0IreEMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUM7S0FFUztNQUFUUSxTQXRKSmozQixJQThMaUIyZixLQTdDYjJXO01BTUFZLFNBdkpKbDNCLElBOExpQjJmLEtBNUNiNFc7TUFNQVksU0F4SkpuM0IsSUE4TGlCMmYsS0EzQ2I2VztNQU1EO2NBQUEsV0FxQzhCbHlDLFNBeEM3QjJ5QyxRQUNBQztlQURBRCxRQUNBQzs7ZUFJSSxXQW1DeUI1eUMsU0F2QzdCNHlDLFFBQ0FDO2lCQURBRCxRQUNBQztpQkFGQUYsUUFFQUU7TUFpRFFDO01BeENBQztNQUFSQztNQXdDRTVjLE1BaEJHb2M7TUFBRVMsTUFBRlQ7TUFnQkFVLE1BaEJJaEM7S0FBSTtTQWdCUmdDLE1BaEJFRDtNQWZBLElBQUxFLEtBMUtOejNCLElBOExpQjJmLEtBTE40WDtNQWROLFFBQUEsV0FtQjRCanpDLFNBcEIzQm16QyxJQVRGSDtPQWNNLE9BQUEsV0FldUJoekMsU0FwQjNCbXpDLElBVE1KO1lBb0JKM2hDLElBb0JDOGhDO1FBdEJIO1lBTUtELE9BSkg3aEM7U0FGVSxRQUFBLFdBV2VwUixTQTlMakMwYixJQThMaUIyZixLQVRUanFCLElBcEJJMmhDO1NBa0J5RCxJQUQxQ0ssTUFDMEMsNEJBRTdEaGlDO1NBQUFBLElBSG1CZ2lDOztRQS9LM0JyQyxPQTJMaUIxVixLQVRUanFCLEdBSUc2aEM7UUFGRSxJQUVBSSxNQUZBLDRCQUZMamlDO1FBb0JDOGhDLE1BaEJJRzs7WUFEQyxJQUNIdi9CLElBREcsNEJBQ0htL0IsU0FBQUEsTUFBQW4vQjs7T0F0TFhpOUIsT0EyTGlCMVYsS0FMTjRYLEtBZ0JMN2M7T0EzQlc7UUFXTmtkLE1BWE0sNEJBV05MO1FBQUZ0bUMsSUFYQSw0QkEyQkh5cEI7T0FBQUEsTUFoQkd6cEI7T0FBRXNtQyxNQUFBSzs7O0tBS0xqQjtPQUFXaFgsS0FBS29YLGFBQVd6eUMsU0FMeEJ3eUMsUUFpQnlDLDRCQUQ1Q3BjO1lBQU0wYyxlQVhOVCxXQUFXaFgsS0FBS29YLGFBQVd6eUMsU0FXM0JvMkIsS0FBRzhjO0tBR2tDLElBZERLLFNBY0MsNEJBSGxDTDtLQVhhWCxjQUFBRTtLQUxiRCxTQUtpQ2U7O0dBY2dCO1lBR3hEQyxPQUFLblksS0FBS3I3QixTQUFTaXhDLE1BQU1DO0lBQzNCLE9BbEJNbUIsV0FpQkNoWCxTQUFLcjdCLFNBQVNpeEMsTUFBTUM7R0FtQjJDO0dBekhwRTtJQUFBLGlCQXNHQXNDLFFBckdBMUI7Ozs7Ozs7Ozs7Ozs7OztZQTZISjJCLE9BQU1wdkIsS0FBS3ZiLEtBQUl1eUIsS0FBS3I3QjtJQUN0QjtLQUNFO09BQUE7NENBRk1xa0IsS0FBS3ZiLFFBQUl1eUI7S0FDUjNXO0tBQUwrZjtLQUdnRCxPQUFBLDRCQUhoREEsT0FBSy9mO0tBRzBDLE9BQUE7SUFBQSxPQUFBLDBCQUpsQzJXLEtBQUtyN0IsU0FDbEJ5a0M7R0FHOEQ7WUFHaEU3aEIsU0FBU2paLEdBQUksT0FBSkEsRUFBSztZQUNkK1QsU0FBUy9ULEdBQUksYUFBSkEscUJBQWdCO1lBRXpCd3hCLFVBQVV4eEIsR0FBRzNKO0lBQ2Y7S0FBSTRDLFFBQVEsNEJBREErRztLQUVSNmQ7O1lBREE1a0IsUUFDQTRrQjtNQUVVO09BQVJuZCxRQUpNVixNQUNSL0c7T0FJRTh3QyxnQkFMTS9wQyxNQUt1Qiw0QkFKL0IvRzthQUtDLFdBTlU1QyxTQUtUMHpDLGVBREFycEMsUUFGRm1kO01BS0YsNkJBTkU1a0I7OztZQUNBNGtCOztHQU9HO1lBR0w0VCxtQkFBbUJ6eEIsR0FBRzNKO0lBQ3hCO0tBQUk0QyxRQUFRLDRCQURTK0c7S0FFakI2ZDs7WUFEQTVrQixRQUNBNGtCO01BRVU7T0FBUm5kLFFBSmVWLE1BQ2pCL0c7T0FJRTh3QyxnQkFMZS9wQyxNQUtjLDRCQUovQi9HO2NBS0MsV0FObUI1QyxTQUtsQjB6QyxlQURBcnBDLFFBRkZtZDtNQUtGLDZCQU5FNWtCOzs7WUFDQTRrQjs7R0FPRztZQUdMa04sTUFBTWEsSUFBR0UsSUFBSXoxQjtJQUNmLElBQUkrTCxLQURJd3BCLGVBRUp2cEIsS0FGT3lwQjtJQUdYLFNBRkkxcEIsSUFHQyxPQUFBLGlCQUpNMHBCO2FBRVB6cEIsSUFJQyxPQUFBLGlCQU5HdXBCO0lBTzBCLFdBUDFCQSxPQU95Qyw0QkFON0N4cEI7SUFNSSxRQUFBLFdBUE8vTCxTQUFKeTFCO0tBUU4sT0FBQSxtQkFSR0YsSUFBR0U7SUFTdUIsV0FUdkJBLE9BU3NDLDRCQVA3Q3pwQjtJQU9JLE9BQUEsV0FUT2hNLFNBQVB1MUI7S0FVSCxPQUFBLG1CQVZNRSxJQUFIRjtJQVlJO0tBQU56c0IsTUFBTSw0QkFYUmlELElBQ0FDO0tBV0UybkMsU0FBUyxtQkFEVDdxQyxLQVpFeXNCO0tBY0ZxZTtLQUNBQztLQUNTLE9BQUEsNEJBSlQvcUM7S0FHVzs7U0FDZmxHOzs7T0FDTWt4QztTQWhCSi9uQyxPQWFFNm5DOztZQVpGNW5DO2dCQWFFNm5DOztjQU9LO2dCQXRCSTd6QyxTQUFQdTFCLE9BY0ZxZSxjQWRLbmUsT0FlTG9lOzs7O01BU0YsR0FQSUM7T0FKRkgsV0FHSi93QyxLQWhCTTJ5QixPQWNGcWU7T0FBQUEsY0FhWSw0QkFiWkE7OztPQURBRCxXQUdKL3dDLEtBaEJTNnlCLE9BZUxvZTtPQUFBQSxjQWVZLDRCQWZaQTs7TUFDSixXQUFBanhDO2tCQUFBQTtNQUFBQTs7O0lBZ0JBLE9BbkJJK3dDO0dBbUJHO1lBR1BJLGlCO1lBRUF0aUIsWUFBWTluQixHQUFHTixNQUFNTztJQUNiLElBQU51WSxVQURhOVk7SUFFUixPQUFBOzthQUZLTTtzQkFFQTFRO2NBQ1o7ZUFBaUIsUUFBQSxXQUhJMlEsR0FDbkJ1WSxRQUNVbHBCO2VBQ0NDO2VBQVR3NEI7Y0FGRnZQLFNBRUV1UDtjQUVKLE9BRmF4NEI7YUFFWjtHQUFDO1lBR0Z5NEIsU0FBU2hvQixHQUFHTixNQUFNTztJQUNwQjtLQUFJdVksVUFEVTlZO0tBRVZtZTtPQUNGOztTQUhTN2Q7a0JBR0sxUTtVQUNaO1dBQWlCLFFBQUEsV0FKRDJRLEdBQ2hCdVksUUFFWWxwQjtXQUNDQztXQUFUdzRCO1VBSEp2UCxTQUdJdVA7VUFFSixPQUZheDRCO1NBRVo7SUFFTCxXQVBJaXBCLFFBQ0FxRjtHQU1RO1lBR1Z0RixZQUFZdlksR0FBR04sTUFBTU87SUFBSSxPQUFBLG9DQUFWUCxNQUFNTyxHQUFURDtHQUFtRDtZQUMvRDBZLFdBQVcxWSxHQUFHTixNQUFNTztJQUFJLDhDQUFWUCxNQUFNTztJQUFJLHFCLDRCQUFiRDtHQUFrRDtZQUM3RG9ZLE1BQU1wWSxHQUFHQyxHQUFJLE9BQUEsb0NBQVBELEdBQUdDLEdBQThCO1lBQ3ZDb1ksSUFBSW1CLEdBQUV4WixHQUFHQyxHQUFJLE9BQUEsb0NBQVR1WixHQUFFeFosR0FBR0MsR0FBOEI7WUFDdkMyWSxRQUFRNVksR0FBRzNKO0lBQVUsT0FBQSxvQ0FBYjJKLEdBQUczSjtHQUE0QztZQUN2RHlpQixRQUFROVksR0FBRzNKO0lBQVUsT0FBQSxvQ0FBYjJKLEdBQUczSjtHQUE0QztZQUV2RHF6QixNQUFNMXBCLEdBQUdOLE1BQU1PO0lBQ2pCO0tBQUl1WSxVQURPOVk7S0FFRSxNQUFBLDRCQUZMTTtLQUNFOztTQUNWL0c7O01BREl1ZixTQUVLLFdBSFF2WSxHQUVqQmhILEdBREl1ZixRQURJeFksTUFFUi9HO01BQUEsVUFBQUE7aUJBQUFBO01BQUFBOzs7V0FESXVmO0dBSUE7WUFHRmdSLGFBQWF4cEIsR0FBR04sTUFBTU87SUFDZCxJQUFOdVksVUFEYzlZO0lBRVIsT0FBQTs7YUFGS007c0JBRUEvRyxHQUFFM0o7Y0FDZjtlQUFpQixRQUFBLFdBSEsyUSxHQUVUaEgsR0FEWHVmLFFBQ2FscEI7ZUFDRkM7ZUFBVHc0QjtjQUZGdlAsU0FFRXVQO2NBRUosT0FGYXg0QjthQUVaO0dBQUM7WUFHRms2QixVQUFVenBCLEdBQUdOLE1BQU1PO0lBQ3JCO0tBQUl1WSxVQURXOVk7S0FFWG1lO09BQ0Y7O1NBSFU3ZDtrQkFHSy9HLEdBQUUzSjtVQUNmO1dBQWlCLFFBQUEsV0FKQTJRLEdBR0poSCxHQUZidWYsUUFFZWxwQjtXQUNGQztXQUFUdzRCO1VBSEp2UCxTQUdJdVA7VUFFSixPQUZheDRCO1NBRVo7SUFFTCxXQVBJaXBCLFFBQ0FxRjtHQU1RO1lBR1YwUCxPQUFPdnRCLEdBQUdDO0lBQ1osT0E1QkV5cEI7YUEyQk8xcEI7O3NCQUNld3RCLEtBQUlwVixPQUFNaFY7Y0FBSyxPQUFHLFdBRDlCbkQsR0FDWXV0QixLQUFVcHFCO3dCQUFxQiw0QkFBM0JnVjt3QkFBQUE7YUFBK0M7R0FBQztZQUcxRXdTLFdBQVc1cUIsR0FBR0M7SUFBSSxPQUFPLG1CQUFBLG9CQUFTLGdCQUF2QkQsR0FBR0M7R0FBK0I7WUFDN0M0cUIsWUFBWTdxQixHQUFHQztJQUFJLE9BQU8sbUJBQUEsb0JBQVMsaUJBQXZCRCxHQUFHQztHQUFnQztZQUUvQ29xQyxZQUFZcnFDO0lBQ2QsSUFBSS9HLFlBQ0F3SCxRQUFRLDRCQUZFVDtJQU1aO1FBTEUvRyxRQUNBd0g7S0FFRixpQkFKWVQsR0FDVi9HLE1BQ0F3SDtLQUdGLDZCQUpFeEg7S0FLRiw2QkFKRXdIOztHQUtBO1lBR0Z3QyxJQUFJakQ7SUFDRSxJQUFKa0csTUFBSSxpQkFERmxHO0lBVkpxcUMsWUFXRW5rQztJQUNKLE9BRElBO0dBRUg7WUFHQ29rQyxZQUFZdG5DO0lBQ2QsS0FEY0EsR0FFTjtJQUVRO0tBRFR5cEIsTUFIT3pwQjtLQUdaSSxJQUhZSjtLQUlFLE1BQUEseUJBRFR5cEI7S0FDRHR0QixNQUFNO0tBQ05hLElBQUksbUJBREpiLEtBREppRTtLQUdJcUUsUUFIQ2dsQjtLQUtHLE1BQUEsNEJBSkp0dEI7O1NBSUpsRzs7a0JBRkl3Tzs7T0FJTSxNQUFBO1VBQ0RtcEIsZ0JBQUxqcEI7TUFDQSxpQkFQQTNILEdBR0ovRyxPQUFBQSxLQUdJME87TUFMQUYsT0FLS21wQjtNQUhELFVBQVIzM0I7ZUFBQUE7TUFBQUE7OztJQU9BLE9BVkkrRztHQVVIO1lBTUR1cUMsWUFBWXppQyxJQUFJN0g7SUFDbEIsS0FEYzZILElBRU47SUFFbUM7S0FEbkM2WixLQUhNN1o7S0FHWjRaLEtBSFk1WjtLQUk2QixNQUFBLFdBSnpCN0gsR0FHaEJ5aEI7S0FDeUIsTUFBQSx5QkFEbkJDO0tBQ0Z2ZSxJQUFJLG1CQUFZO0tBQ1BuSzthQUZQMG9COztpQkFFTixPQURJdmU7U0FHTTZvQixpQkFBTlA7S0FIQXRvQixNQUNTbkssS0FHTSxXQVJIZ0gsR0FPWnlyQjtLQUVLLFVBQUEsNEJBSkl6eUI7S0FBQUE7YUFFSGd6Qjs7R0FJRDtZQUdUdWUsYUFBYTFpQyxJQUFJN0g7SUFDbkIsS0FEZTZILElBRVA7SUFFbUM7S0FEbkM2WixLQUhPN1o7S0FHYjRaLEtBSGE1WjtLQUk0QixNQUFBLFdBSnhCN0gsTUFHakJ5aEI7S0FDeUIsTUFBQSx5QkFEbkJDO0tBRU92ZSxJQURMLG1CQUFZO0tBQ0xuSzthQUZUMG9COztpQkFHSSxPQURHdmU7U0FFSDZvQixpQkFBTlA7S0FGU3RvQixNQUFFbkssS0FHSSxXQVJGZ0gsR0FLRmhILEdBRVh5eUI7S0FFTyxVQUFBLDRCQUpJenlCO0tBQUFBO2FBRUxnekI7O0dBSUM7WUFHWHdlLGdCQUFnQjNpQyxJQUFJN0g7SUFDZCxJQUFKRCxJQTdCRnVxQyxZQTRCZ0J6aUMsSUFBSTdIO0lBakVwQm9xQyxZQWtFRXJxQztJQUNKLE9BRElBO0dBRUg7WUFHQzBxQyxpQkFBaUI1aUMsSUFBSTdIO0lBQ2YsSUFBSkQsSUFyQkZ3cUMsYUFvQmlCMWlDLElBQUk3SDtJQXZFckJvcUMsWUF3RUVycUM7SUFDSixPQURJQTtHQUVIO1lBR0M2dEIsWUFBWTd0QixHQUFHQztJQUNqQjtLQUFJd0g7S0FDQStuQjtLQUNTLE1BQUEsNEJBSEN4dkI7S0FFTjs7U0FDUi9HOztNQUNRLFlBQUEsV0FKU2dILEdBR2pCaEgsR0FIYytHLE1BR2QvRzs7V0FHU21LO2dCQUpMb3NCLE1BREEvbkIsT0FNb0IsbUJBUFZ6SCxjQU1Mb0Q7T0FMTHFFLFNBQ0ErbkIsUUFJS3BzQjtPQUdMLDZCQVBBb3NCOztNQUNKLFVBQUF2MkI7aUJBQUFBO01BQUFBOzs7V0FESXUyQixTQUZVeHZCO2NBQ1Z5SDtrQkFDQStuQix1QkFEQS9uQixTQUNBK25CO0dBU3dFO1lBRzFFOUIsV0FBVzF0QixHQUFHQztJQUFJLE9BZGxCNHRCLFlBY1c3dEIsWUFBNkIvRyxHQUFHbUssR0FBSyxPQUFBLFdBQWxDbkQsR0FBNkJtRCxHQUFRO0dBQUM7WUFDcEQwcUIsV0FBVzl0QixHQUFJLE9BRGYwdEIsV0FDVzF0QixpQkFBSSxjQUFxQjtZQU9wQ2tpQixrQkFBa0JwUSxNQUFLMVEsSUFBR0M7SUFDNUIsSUFONkJzaEIsS0FLSnZoQixlQUxPd2hCLEtBS0p2aEIscUJBTENzaEIsT0FBR0M7aUJBQ2hDLDhCQUlvQjlRLE1BTFM2USxJQUFHQztHQVFpQjtZQUcvQ0ksVUFBVTVoQixJQUFHQyxJQUFJcEI7SUFOakJpaUIsdUNBTVU5Z0IsSUFBR0M7SUFFSCxPQUFBO29CQUZBRCxhQUVLbkksR0FBRTByQixJQUFNLE9BQUssV0FGWDFrQixHQUVBMGtCLElBRkp0akIsT0FFRXBJLElBQThCO0dBQUM7WUFHOUNpdkIsU0FBUzltQixJQUFHQyxJQUFJcEI7SUFYaEJpaUIsc0NBV1M5Z0IsSUFBR0M7SUFFTSxPQUFBOzthQUZURDtzQkFFY25JLEdBQUssT0FBb0IsV0FGaENnSCxHQUFQbUIsT0FFY25JLElBRlhvSSxPQUVXcEksSUFBMEM7R0FBQztZQUdsRW1xQixVQUFVaGlCLElBQUdDLElBQUkzQixNQUFNTztJQWhCdkJpaUIsdUNBZ0JVOWdCLElBQUdDO0lBRUcsT0F2SmhCcW9CO2FBcUpVdG9CO2FBQU8xQjtzQkFFSXpHLEdBQUVzdkIsSUFBR2o1QixHQUFLLE9BQU8sV0FGZjJRLEdBRUFzb0IsSUFBR2o1QixHQUZiK1IsT0FFUXBJLElBQWtDO0dBQUM7WUFHeEQycUIsT0FBTzVqQixHQUFHQztJQUFJLE9BN0JkeXRCLFdBNkJPMXRCLFlBQTRCMVEsR0FBSyxPQUFHLFdBQWpDMlEsR0FBeUIzUSxTQUFBQSxPQUFpQztHQUFDO1lBQ3JFcTZCLFFBQVEzcEIsR0FBR0M7SUFBSSxPQTVDZjR0QjthQTRDUTd0QixZQUE2Qi9HLEdBQUUzSixHQUFLLE9BQUcsV0FBcEMyUSxHQUEwQmhILEdBQUUzSixTQUFBQSxPQUFtQztHQUFDO1lBRzNFNFMsT0FBT2xDLEdBQUdDO0lBQ1o7S0FBSWhILFFBQVEsNEJBREgrRztLQUVMNmQ7SUFFOEM7YUFIOUM1a0IsVUFDQTRrQjtNQUVDLEdBQUEsV0FKTzVkLEdBQUhELE1BQ0wvRyxRQUNBNGtCO01BRThDLDZCQUg5QzVrQjs7O1lBQ0E0a0I7O0dBSUc7WUFHTDJHLFFBQVF4a0IsR0FBR0M7SUFDYjtLQUFJaEgsUUFBUSw0QkFERitHO0tBRU42ZDtJQUVpRDthQUhqRDVrQixVQUNBNGtCO01BRUMsR0FBQSxXQUpRNWQsR0FDVGhILE1BRE0rRyxNQUNOL0csUUFDQTRrQjtNQUVpRCw2QkFIakQ1a0I7OztZQUNBNGtCOztHQUlHO1lBR0x4RCxJQUFJcmEsR0FBRW9ELEdBQUc5TSxPQUFRLE9BbEJqQjRMLE9Ba0JJbEMsR0FBeUIsV0FBcEIxSixPQUFIOE0sSUFBZ0M7WUFFdENiLFFBQVF2QyxHQUFHQztJQUNiO0tBQUloSCxRQUFRLDRCQURGK0c7S0FFTjZkO0lBRXFEO2FBSHJENWtCLFFBQ0E0a0I7TUFFSyxHQUFBLFdBSkk1ZCxHQUFIRCxNQUNOL0c7T0FHcUQsNkJBSHJEQTs7O01BQ0E0a0I7OztZQUFBQTs7R0FJRztZQUdMMEcsU0FBU3ZrQixHQUFHQztJQUNkO0tBQUk2QixTQURPOUI7S0FFUC9HLFFBQVEsNEJBRFI2STtLQUVBK2I7SUFFd0Q7YUFIeEQ1a0IsUUFDQTRrQjtNQUVLLEdBQUEsV0FMSzVkLEdBRVZoSCxNQUZPK0csTUFFUC9HO09BR3dELDZCQUh4REE7OztNQUNBNGtCOzs7WUFBQUE7O0dBSUc7WUFHTDJGLFlBQVlwaUIsSUFBR0MsSUFBSXBCO0lBaEVuQmlpQix5Q0FnRVk5Z0IsSUFBR0M7SUFFVDtLQUFKcEksUUFBUSw0QkFGRW1JO0tBR1Z5YztJQUVrRTthQUhsRTVrQixVQUNBNGtCO01BRUMsR0FBQSxXQUxnQjVkLEdBQVBtQixPQUVWbkksT0FGYW9JLE9BRWJwSSxRQUNBNGtCO01BRWtFLDZCQUhsRTVrQjs7O1lBQ0E0a0I7O0dBSUc7WUFHTHlGLGFBQWFsaUIsSUFBR0MsSUFBSXBCO0lBMUVwQmlpQiwwQ0EwRWE5Z0IsSUFBR0M7SUFFVjtLQUFKcEksUUFBUSw0QkFGR21JO0tBR1h5YztJQUV5RTthQUh6RTVrQixRQUNBNGtCO01BRUssR0FBQSxXQUxhNWQsR0FBUG1CLE9BRVhuSSxPQUZjb0ksT0FFZHBJLFFBR3lFLDZCQUh6RUE7TUFDQTRrQjs7O1lBQUFBOztHQUlHO1lBR0x2bkIsTUFBTUEsT0FBTThLLElBQUdDO0lBQUssVUFBUkQsa0JBQUdDO2lCQVZmaWlCLGFBVVlsaUIsSUFBR0MsSUFBVC9LO0dBQWtFO1lBR3hFcTBDLFlBQVkzcUMsR0FBR0M7SUFDakIsSUFBYSxNQUFBLDRCQURDRCxrQkFDZDs7U0FBQS9HOztNQURjK0csTUFDZC9HLEtBQ2lCLFdBRkFnSCxHQUFIRCxNQUNkL0c7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7Ozs7R0FFSTtZQUdjMnhDLGVBQWU1cUMsR0FBR0MsR0FBRzRxQyxVQUFVQztJQUNqRCxJQUFJaHBDLFNBRDZCOUI7SUFFakMsU0FESThCLFFBRUMsT0FBQSxXQUg0Q2dwQztJQUt2QyxJQUFKN3hDLFlBQ0E4eEMsZ0JBQ0FDLGtCQVAyQmhyQzs7VUFNM0IrcUMsWUFEQTl4QyxPQUpGNkk7TUFRWSxJQUFSa3VCLFFBVHlCaHdCLE1BSzNCL0c7TUFLQyxHQUFBLFdBVjZCZ0gsR0FLOUJoSCxNQUlFKzJCO09BRkZnYixpQkFFRWhiO09BSEYrYTs7O09BUUcsNkJBVEg5eEM7OztZQUNBOHhDOzBCQU5pQ0YsVUFLakM1eEMsTUFFQSt4QztlQVNtRCxXQWhCUkY7O0dBZ0J3QjtZQUd2RTdtQixNQUFNamtCLEdBQUdDO0lBQ1gsT0FwQmtCMnFDO2FBbUJWNXFDO2FBQUdDO3NCQUlPaEgsR0FBRysyQixPQUFTLGVBQVovMkIsR0FBRysyQixRQUF3Qjs2QkFDbEIsU0FBSTtHQUFDO1lBRzlCN0wsVUFBVW5rQixHQUFHQztJQUNmLE9BNUJrQjJxQzthQTJCTjVxQzthQUFHQztzQkFJR2hILEdBQUcrMkIsT0FBUyxXQUFaLzJCLEdBQUcrMkIsT0FBaUI7O2NBQ1gsTUFBQTthQUF1RDtHQUFDO1lBR2pGaE0sU0FBU2hrQixHQUFHQztJQUNkLE9BcENrQjJxQzthQW1DUDVxQztzQkFHRC9HLEdBQUczSixHQUFLLE9BQUEsV0FISjJRLEdBR0QzUSxHQUFROzZCQUNFMGdDLE9BQVMsT0FBVEEsTUFBYzs7Y0FDVixNQUFBO2FBQXNEO0dBQUM7WUFHaEZoWCxLQUFLaFosR0FBR0M7SUFBZSxVQXhCdkJna0IsTUF3Qktqa0IsWUFBbUMvRyxHQUFHM0osR0FBSyxPQUFBLFdBQXhDMlEsR0FBbUMzUSxHQUFRO0lBQU0sT0FBQTs7OzZCQUFBLElBQVVBLGNBQU0sT0FBTkEsRUFBUTtHQUFBO1lBRTNFeXBCLFNBQVMvWSxHQUFHQztJQUNkLElBQUk2QixTQURPOUI7SUFFWCxTQURJOEIsUUFFQztJQUVLLElBQUo3SSxZQUNBK3hDOztRQUNFLDRCQURGQSxtQkFEQS94QyxPQUpGNkk7TUFPWSxJQUFSa3VCLFFBUkdod0IsTUFLTC9HO01BQ0EreEMsaUJBR2EsV0FUTC9xQyxHQVFOK3ZCO01BRUosNkJBTEUvMkI7OztZQUNBK3hDOztHQU1TO0dBSUM7SUFBWm5uQjtZQURGQyxhQUVlOWpCLEdBQUdDO0lBQ1osWUFsQk44WSxTQWlCZS9ZLEdBQUdDO2dCQUVSLE1BQUEsNEJBSFI0akI7UUFJS3YwQjtJQUFLLE9BQUxBO0dBQU07WUFNYjgwQixVQUFVcGtCLEdBQUdDO0lBQ2YsSUFBSTZCLFNBRFE5QjtJQUVaLFNBREk4QixRQUVDO0lBRUssSUFBSjdJLFlBQ0EreEM7O1FBQ0UsNEJBREZBLG1CQURBL3hDLE9BSkY2STtNQU9ZLElBQVJrdUIsUUFSSWh3QixNQUtOL0c7TUFDQSt4QyxpQkFHYSxXQVRKL3FDLEdBS1RoSCxNQUdFKzJCO01BRUosNkJBTEUvMkI7OztZQUNBK3hDOztHQU1TO0dBSUM7SUFBWmpuQjs7WUFERk8sY0FFZ0J0a0IsR0FBR0M7SUFDYixZQWxCTm1rQixVQWlCZ0Jwa0IsR0FBR0M7Z0JBRVQsTUFBQSw0QkFIUjhqQjtRQUlLejBCO0lBQUssT0FBTEE7R0FBTTtZQU1icThCLDJCQUEyQjNyQixHQUFHMUo7SUFDaEMsSUFBSWtjLElBRHlCeFM7SUFFN0IsUUFESXdTLEdBRUM7SUFFVSxJQUFUcUwsaUJBQ0E1a0IsWUFDQWkwQixXQVB1Qmx0Qjs7UUFNdkIvRyxRQUxGdVosVUFJRXFMO0tBSVEsSUFBTmluQixNQVRxQjlrQyxNQU12Qi9HO0tBSUMsR0FBQSxXQVZ5QjNDLE9BU3hCd3VDLEtBRkY1WDtNQUZBclAsb0JBRUFxUCxTQUVFNFg7TUFIRjdyQyxPQUxGdVo7O1VBTUUwYSxVQUVFNFgsS0FPRiw2QkFWQTdyQzs7R0FZSTtZQUdSMndCLE9BQU81cEIsR0FBR0M7SUFDWixTQURTRCxjQUVKO0lBRUs7S0FBSnlILFFBSkd6SDtLQUtNLE1BQUEsNEJBTE5BO0tBSUM7O1NBQ1IvRzs7TUFESXdPLE9BRUcsV0FOR3hILEdBSU53SCxNQUpHekgsTUFLUC9HO01BQUEsVUFBQUE7aUJBQUFBO01BQUFBOzs7SUFHQSxXQUpJd087R0FJSTtZQUdSb2lCLFdBQVc3cEIsR0FBR0M7SUFDVixZQVpKMnBCLE9BV1c1cEIsR0FBR0M7Z0JBRU4sT0FBQTtRQUNIc087SUFBSyxPQUFMQTtHQUFNOztJQUdYMFE7Ozs7WUFFQTBTLG1CQUFxQjlyQixLQUFxQzdGO0lBQzVELEdBRHVCNkY7U0FBZUMsTUFBZkQsUUFBQXFaLGVBQWVwWjs7U0FBZm9aO0lBQ3BCLEdBcmNEbkwsU0FvYzBEL1Q7S0FFdkQsT0FBQTtJQUNHLFVBQUEsK0JBSGVrZixjQUFxQ2xmO0lBR3ZELHdCQUh1REE7R0FHWDtZQUcvQzR4QixlQUFpQi9yQixLQUFxQzdGO0lBQ3hELEdBRG1CNkY7U0FBZUMsTUFBZkQsUUFBQXFaLGVBQWVwWjs7U0FBZm9aO0lBQ25CLElBQUksY0FQRnlTLHVCQU1pQnpTLGVBQXFDbGYsS0FDcEQ7ZUFDRztHQUFJO1lBR1RzcEIsSUFBSWxvQixJQUFHQztJQUNULE9BRE1ELGtCQUFHQzs7a0JBdE9QNm1CLFNBc09JOW1CLElBQUdDLGFBQzZEc2pCLElBQUdDLElBQU0sV0FBVEQsSUFBR0MsSUFBWTtHQUFFO1lBR3JGeUUsUUFBUWpvQixJQUFHQztJQUNiLE9BRFVELGtCQUFHQztjQUVSO2NBNU9INm1CLFNBME9ROW1CLElBQUdDLGFBR2VzakIsSUFBR0MsSUFBTSxXQUFURCxJQUFHQyxJQUFZO0dBQUM7WUFHMUMzaUIsTUFBTWpDO0lBQ1IsSUFBSXdTLElBREl4UztJQUVSLFNBREl3UyxHQUVDO0lBRVE7S0FBQSx5QkFMTHhTO0tBS0N6UTtLQUFIRDtLQUNBMjdDLE9BQU8sbUJBTFR6NEIsR0FJRWxqQjtLQUVBNDdDLE9BQU8sbUJBTlQxNEIsR0FJS2pqQjtLQUdNLE1BQUEsNEJBUFhpakI7S0FNUzs7U0FDWHZaOztNQUNhO09BQUEsMkJBVFArRyxHQVFOL0csT0FBQUE7T0FDU2liO09BQUhtQztNQUNKLGlCQUpFNDBCLE1BRUpoeUMsT0FBQUEsS0FDTW9kO01BRUosaUJBSkU2MEIsTUFDSmp5QyxPQUFBQSxLQUNTaWI7TUFEVCxVQUFBamI7aUJBQUFBO01BQUFBOzs7SUFLQSxXQVBJZ3lDLE1BQ0FDO0dBTU87WUFHWEMsWUFBWW5yQyxHQUFHM0o7SUFDUixJQUFMK0ssS0FBSyxpQkFES3BCO0lBamZaOHBDLGFBa2ZFMW9DLElBRGEvSztJQUVqQixPQURJK0s7R0FFRjtZQUdBZ3FDLGNBQWNwckMsR0FBR0M7SUFDbkI7S0FBSWtPO09BQU87O1NBREtuTztrQkFDVS9HLEdBQUUzSixHQUFLLE9BQUcsV0FEakIyUSxHQUNPaEgsR0FBRTNKLFNBQUFBLFNBQUFBLEdBQXNEO0tBQzlFKzdDO09BM1JGM2Q7U0EwUkV2Zjs7VUFFaUIsbUJBRUg7Y0FETjdlO1VBQUssV0FBTEE7U0FDVztLQUVuQmc4QztPQWhTRjVkO1NBMFJFdmY7O1VBT2lCLG1CQUNKO2NBQ0o3ZTtVQUFLLFdBQUxBO1NBQVk7SUFFekIsV0FWSSs3QyxPQUtBQztHQUtTO1lBR1huZCxhQUFhbnVCLEdBQUdDO0lBQUksT0FmcEJtckMsY0FlYXByQyxZQUErQi9HLEdBQUczSixHQUFLLE9BQUEsV0FBcEMyUSxHQUErQjNRLEdBQVE7R0FBQztZQUN4RCs3QixLQUFLcnJCO0lBQU8sVUFBQSw0QkFBUEE7SUFBSSx3QkFBSkE7R0FBb0I7WUFJekJ1ckMsb0JBQW9CdnJDO0lBQ3RCLE9BQWdDOzs7c0JBQUsvRztjQUNuQyxHQUZvQitHLGdCQUNlL0csR0FDYjtjQUFvRCxVQUFBLDRCQUR2Q0E7Y0FDVyw0QkFGMUIrRyxHQUNlL0csT0FBQUE7YUFDNkM7R0FBQztZQUdqRnV5QyxZQUFZeHJDLEdBQUksT0FMaEJ1ckMsb0JBS29DLGlCQUF4QnZyQyxJQUFnQztZQUU1Q214QixrQkFBa0IvdkIsSUFBR0M7SUFDdkIsS0EzZ0JFMFMsU0EwZ0JrQjNTLFNBMWdCbEIyUyxTQTBnQnFCMVM7S0FLckI7TUFESXNoQixLQUpjdmhCO01BS2R3aEIsS0FMaUJ2aEI7TUFNa0IsdUJBTmxCQTtNQU1TLDJCQU5aRDtNQU1kcEIsSUFBSSxtQkFBWSw0QkFGaEIyaUIsSUFDQUM7TUFFQW5iO01BQ1UsTUFBQSw0QkFKVmtiO01BR0k7O1VBQ1I4b0I7O09BQ2dCLElBQUEsTUFBQSw0QkFKWjdvQixRQUlGOztZQUFBOG9COztTQUNxQjtVQUFBLHVCQVZGcnFDLElBU25CcXFDLFFBQUFBO1VBQ1ksMkJBVkl0cUMsSUFRbEJxcUMsUUFBQUE7Z0JBREloa0M7U0FHQSxpQkFKQXpIO1NBS0EsNkJBSkF5SDtTQUlBLFVBRkZpa0M7b0JBQUFBO1NBQUFBOzs7T0FERixVQUFBRDtrQkFBQUE7T0FBQUE7OztLQU1BLE9BUkl6ckM7O0lBSkQ7R0FZRDtZQUdGZ3lCLFVBQVUyWjtJQUNaLFNBRFlBLGVBRVA7SUFHZ0IsSUFEZkMsUUFKTUQsZUFLTkUseUJBTE1GO0lBTVAsT0ExU0h6cEMsT0FvU1V5cEMsYUFNVzNyQyxHQUFLLE9BQUxBLGlCQURqQjZyQyxjQUN1Qzs7O2NBRWpDOztnQkFITkE7eUJBRzBCQztpQkFBSyxPQUFjOzswQkFKN0NGO21DQUlrREc7MkJBQUsseUNBUmpESixJQVE0Q0ksT0FBQUEsSUFBeEJEO3dDQUFBQTswQkFBdUM7Z0JBQUM7R0FBRztZQUd6RS9ZLGNBQWM0WTtJQUNWLFlBWkozWixVQVdjMlo7Z0JBRU4sT0FBQTtRQUNISztJQUFPLE9BQVBBO0dBQVU7WUFNWEMsZ0I7WUFDQW5xQyxZOzt3REFEQW1xQyxPQUNBbnFDOzs7O1lBTUFzWCxjO1lBRUEraUIsWUFBYWg5QixLQUFJYTtJQUNuQixTQURlYixLQUVWO0lBRUssT0FKU2E7S0FLTCxPQUFBLG1CQUxDYixzQkFBSWE7SUFJakIsTUFBQTtHQUNrQjs7SUFHbEJpUTs7bUNBUkFrc0IsYUFGQS9pQixVQVVBbko7Ozs7OztZQUdKcEcsVUFBVW91QixhQUFZajRCO0lBQUksT0FBQSxpQkFBSkEsR0FBWmk0QjtHQUFxQzs7OztPQTMxQi9DNWhDO09BQ0FxYTtPQUNBNUc7T0FFQ0Y7OztPQTZoQkR5UTtPQXpRQXRHOzs7T0FrRkF3RTtPQUNBRztPQW9LQXhXO09Bb0JBSztPQXZMQTZWO09BQ0FDO09BaVJBVztPQUVBRDs7T0F6V0FFO09BdUZBTDtPQUNBRTtPQTRlQWpQOzs7Ozs7T0F0Z0JBdWdDOzs7Ozs7Ozs7Ozs7T0FFQXRpQjtPQWtDQTBCO09BMUJBeEI7T0FrQ0F5Qjs7O09BaEJBQzs7T0FqR0FvZ0I7O09BVUF0WTtPQVlBQztPQVlBMUc7T0E4RkFIO09BQ0FDO09BcVlBc0Q7T0FmQWlkO09BMkJBamE7T0FpQkFhO09BV0FlO09BL1VBakY7T0FEQUo7T0FkQUc7T0E0RUF0SjtPQXBCQUM7T0E1SUErSTtPQWdIQXZLO09BS0FrRjtPQUtBOUU7T0EwREFFO09BVkFFO09BM0NBSTtPQUNBK0Y7O09BekhBMGdCO09BVUFwbkM7T0FNQXFuQztPQXFCQUM7T0FjQUM7T0FjQUM7T0FNQUM7T0FtSEFDO09BeUNBM21CO09BeUJBRjtPQXpDQUc7T0FRQUU7T0E0Q0FDO09BZUFFO09BV0FxSDtPQXFCQS9CO09BV0FDO09BTUE1SztPQVFBMlM7T0FOQUQ7T0FXQXJJO09BSUFEO09BTUFwbkI7T0FnQkFrcEM7T0FzQkE5ZjtPQTdNQS8wQjtPQXNOQWsxQztPQUxBRDs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ3R4QkExaEMsVUFBVTdKO0lBQUk7T0FBUSxhQUFaQTtJQUFJLE1BQUE7R0FBb0U7WUFDbEY4QixZO1lBRUFnSSxVQUFVOUo7SUFFYTs7OztZQUE2Qix5QkFGMUNBO0lBQ1osV0FDRTtHQUFvRjtPQUdwRmtzQztZQUlBQyxZQUFhaHRDO0lBQU0sa0NBQU5BLEtBSmIrc0M7R0FJNkM7T0FDN0NoTDtZQVNBbnZCLElBQUkvUixHQUFFL0csR0FLUix3QkFMTStHLEdBQUUvRyxPQUFBQSxHQUtzRTtZQUc1RG16QyxXQUFXcHNDLEdBQUUvRyxHQUcvQixPQUg2QitHLE1BQUUvRyxHQUlrRDtZQUcvRG96Qyw0QkFBNEJyc0MsR0FBRS9HLEdBQUVxekMsS0FBSnRzQyxNQUFFL0csS0FBRXF6QyxjQVNNO1lBR3RDQyxxQkFBcUJ2c0MsR0FBRS9HLEdBQUVxekM7SUFFM0MsaUJBRnVDdHNDLEdBQUUvRyxPQUFBQSxLQUFFcXpDO0lBRTNDO0dBQ3lEO1lBR3ZDRSwrQkFBc0N4c0MsR0FBRS9HLEdBQUV5aUIsT0FBSjFiLE1BQUUvRyxLQUFFeWlCO0dBRXFCO1lBUy9FeXJCLElBQUlubkMsR0FBRS9HLEdBQUVxekM7SUFHSSxJQUFWRyxVQS9DRjE2QixJQTRDSS9SLEdBQUUvRztjQUdKd3pDLCtCQUhNSDtLQUtMLE9BaEJhRSwrQkFXWnhzQyxHQUFFL0csR0FBRXF6QztJQU1FLGNBQUEsNkJBSFJHLFNBSE1IO2lCQTdCUUQsNEJBNkJacnNDLEdBQUUvRyxHQUFFcXpDO0dBTzhCO1lBR3RCSSxXQTlDVzFzQyxHQUFFL0csR0E4Q0VxekM7SUFDakMsSUFBSUcsVUEvQ3lCenNDLE1BQUUvRztjQStDM0J3ekMsK0JBRDZCSDtLQUc1QixPQXhCYUUsK0JBekJXeHNDLEdBQUUvRyxHQThDRXF6QztJQUlyQixjQUFBLDZCQUhSRyxTQUQ2Qkg7aUJBdkNmRCw0QkFQV3JzQyxHQUFFL0csR0E4Q0VxekM7R0FLTztZQUd0QkssK0JBdERXM3NDLEdBQUUvRyxHQXNEd0JxekM7SUFDdkQsSUFBSUcsVUF2RHlCenNDLE1BQUUvRztjQXVEM0J3ekMsK0JBRG1ESDtLQUdsRCxPQWhDYUUsK0JBekJXeHNDLEdBQUUvRyxHQXNEd0JxekM7SUFJbEQsT0FuRGFELDRCQVBXcnNDLEdBQUUvRyxHQXNEd0JxekM7R0FJZjtZQUd0QzlyQyxLQUFLUixHQUFFL0csR0FBRXdIO0lBQ1gsSUFBSTJDLElBdEVGMk8sSUFxRUsvUixHQUFFL0csSUFFTG9LLElBdkVGME8sSUFxRUsvUixHQUFJUztJQWZPaXNDLFdBZVgxc0MsR0FBRS9HLEdBRUxvSztJQUNKLE9BbEJrQnFwQyxXQWVYMXNDLEdBQUlTLEdBQ1AyQztHQUdZO1lBR2RsRSxPQUFRQyxLQU9KN1A7SUFMTjtPQUFHLGFBS0dBLFlBSkQsT0FBQSwyQkFISzZQLEtBT0o3UDtJQURJO0tBQUowUSxJQTVGSm1zQyxZQXNGUWh0QztLQVFLLE1BQUEsNEJBUkxBO0tBT1I7O1NBQ0FsRzs7TUFyRWdCb3pDLDRCQW1FWnJzQyxHQUVKL0csR0FESTNKO01BRUYsVUFERjJKO2lCQUFBQTtNQUFBQTs7O0lBR0EsT0FMSStHO0dBS0Y7WUFHRjJsQyxVQUFVMkcsS0FBTSxPQWRoQnB0QyxVQWNVb3RDLEtBQXVCO1lBR2pDTSwrQkFBa0M1c0MsR0FBRS9HLEdBQUVxekM7SUFDeEMsY0FEd0NBO2NBNUR0QkUsK0JBNERrQnhzQyxHQUFFL0csR0FBRXF6QztjQTlFdEJELDRCQThFa0Jyc0MsR0FBRS9HLEdBQUVxekM7R0FNSDtZQUduQ08sZUE5RjJCN3NDLEdBQUUvRyxHQThGVnlpQjtJQUNyQixJQUFJK3dCLFVBL0Z5QnpzQyxNQUFFL0c7a0JBK0YzQnd6QztjQXRFY0QsK0JBekJXeHNDLEdBQUUvRyxHQThGVnlpQjtjQXZGSDJ3Qiw0QkFQV3JzQyxHQUFFL0csR0E4RlZ5aUI7R0FJbUM7WUFHdERveEIsd0JBckcyQjlzQyxHQUFFL0c7SUFzRy9CLElBQUl3ekMsVUF0R3lCenNDLE1BQUUvRyxzQkFzRzNCd3pDO2lCQS9GY0osNEJBUFdyc0MsR0FBRS9HO0dBdUd3RDtZQTZCakZnWCxZQXBJdUIyckIsS0E0R1RDLFNBQVNDLEtBQUtDLFNBQVM1OEI7SUFRM0MsR0FSa0M0OEIsVUFBZEY7S0FVTCxJQUFBLE1BQUEsNEJBVjRCMThCLFNBVXpDOztVQUFBbEc7O09BQytDLElBdkhsQjZMLE1BdUhrQiw0QkFYN0IrMkIsU0FVbEI1aUMsVUF0SDJCMmlDLFFBQUU5MkI7T0E4Q2I0bkMsV0E4RFc1USxLQVdWLDRCQVhlQyxTQVVoQzlpQztPQUNFLFVBREZBO2tCQUFBQTtPQUFBQTs7Ozs7SUFJUSxVQUFBLDRCQWRpQ2tHOztTQWN6Q3l1Qjs7TUFDK0MsSUEzSGxCbWYsTUEySGtCLDRCQWY3QmxSLFNBY2xCak8sWUExSDJCZ08sUUFBRW1SO01BOENiTCxXQThEVzVRLEtBZVYsNEJBZmVDLFNBY2hDbk87TUFDRSxVQURGQTtlQUFBQTtNQUFBQTs7OztHQUVJOzsyQ0F6Sko5ckIsUUFXQXFxQyxhQXNKSWw4Qjs7Ozs7O1lBR0p6USxLQUFLbzhCO0lBQ0csSUFBTkUsTUExSkZxUSxZQXlKS3ZRO0lBRVAsa0JBRk9BLFdBQ0hFO0lBQ0osT0FESUE7R0FFRDs7OztPQXJLRGh5Qjs7Ozs7O09BSEFEO09Ba0dBM0s7T0F0RkFpdEM7T0F5SkEzc0M7T0FyREFtbUM7T0FuR0F6RTtPQVpBcC9CO09BcUJBaVE7T0FRZ0JxNkI7T0FvQ2hCakY7T0FVZ0J1RjtPQWVoQmxzQztPQTFDZ0IrckM7T0FrRWhCSztPQTVEZ0JKO09BcUVoQks7T0F4Q2dCRjtPQS9DQU47T0E4RmhCUzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7OztJQ3BJRjVMO1lBQ0E4TCw0QkF1QmlDN3RDO0lBQU0sT0FBQSw4QkFBTkE7R0FBZ0M7WUF0QmpFOHRDLGlCQXVCc0I5dEMsS0FBTSxPQUFBLDhCQUFOQSxLQUFnQztZQXRCdERELE9BdUJZQyxLQUFJN1AsR0FBSSxPQUFBLDhCQUFSNlAsS0FBSTdQLEdBQTJDO1lBdEIzRHEyQyxVQXVCY3IyQyxHQUFJLE9BQUEsK0JBQUpBLEdBQXlDO1lBcEJ2RGtSLEtBcUJTUixHQUFFL0csR0FBRXdILEdBQUksT0FBQSwrQkFBUlQsR0FBRS9HLEdBQUV3SCxHQUF3QjtZQXZCckNzUixJQXdCUTJmLEtBQUl6NEIsR0FBSSxPQUFBLCtCQUFSeTRCLEtBQUl6NEIsR0FBc0M7WUF2QmxEa3VDLElBd0JRelYsS0FBSXo0QixHQUFFM0osR0FBSSxPQUFBLCtCQUFWb2lDLEtBQUl6NEIsR0FBRTNKLEdBQXlDO1lBdEJ2RDg4QyxXQXVCZTFhLEtBQUl6NEIsR0FBSSxPQUFBLCtCQUFSeTRCLEtBQUl6NEIsR0FBNkM7WUF0QmhFeXpDLFdBdUJlaGIsS0FBSXo0QixHQUFFM0o7SUFBSSxPQUFBLCtCQUFWb2lDLEtBQUl6NEIsR0FBRTNKO0dBQWdEO1lBckJyRXU5QyxlQXNCbUJuYixLQUFJejRCLEdBQUUzSjtJQUFJLE9BQUEsK0JBQVZvaUMsS0FBSXo0QixHQUFFM0o7R0FBb0M7WUFyQjdEazlDLCtCQXVCMEM5YSxLQUFJejRCLEdBQUUzSixHQUM5QyxPQUFBLCtCQUR3Q29pQyxLQUFJejRCLEdBQUUzSjtHQUNTO1lBdkJ6RHM5QywrQkEwQnNDbGIsS0FBSXo0QixHQUFFM0osR0FDMUMsT0FBQSwrQkFEb0NvaUMsS0FBSXo0QixHQUFFM0o7R0FDeUI7O0lBeEJyRXdTO0lBOElNbU87SUE1SU56UTtZQVJBbXRDLCtCQXFDcUMzc0MsR0FBRS9HLEdBQUUzSixHQUN2QyxPQUFBLCtCQURtQzBRLEdBQUUvRyxHQUFFM0o7R0FDeUI7WUFsQ2xFKzhDLDRCQXFDZ0Nyc0MsR0FBRS9HLEdBQUUzSjtJQUNsQyxPQUFBLCtCQUQ4QjBRLEdBQUUvRyxHQUFFM0o7R0FDeUI7WUFyQzdEaTlDLHFCQXdDeUJ2c0MsR0FBRS9HLEdBQUUzSjtJQUFJLE9BQUEsK0JBQVIwUSxHQUFFL0csR0FBRTNKO0dBQXdEOztJQXBDckZ3OUM7Ozs7WUEwQ0VqakMsVUFBVTdKO0lBQUk7T0FBUSxxQkFBWkE7SUFBSSxNQUFBO0dBQW9FO1lBRWxGTixLQUFLc0QsR0FBRy9DO0lBQ1YsT0FETytDLEdBRUYsT0FBQTtJQUVPO0tBQU5FLE1BbEVOOHBDLDRCQThET2hxQztLQUtRLE1BQUEsNEJBTFJBO0tBSUs7O1NBQ1YvSjs7TUEzREZ5ekMsV0EwRE14cEMsS0FDSmpLLEdBQ21CLFdBTlhnSCxHQUtSaEg7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7OztJQUdBLE9BSklpSztHQUlBO1lBR0pncUMsU0FBU3hiO0lBQU0sT0FYZmh5QixLQVdTZ3lCLDhCLE9BQUFBO0dBQXVEO1lBQ2hFcnhCLElBQUkrQyxHQUFHbkQ7SUFBSSxPQVpYUDthQVlpRCxXQTNEbkRvQyxRQTJETXNCO3NCQUFvQm5LLEdBQUssT0FBRSxXQUF4QmdILEdBbkVUbXNDLFdBbUVNaHBDLEdBQW9CbkssSUFBdUI7R0FBWTtZQUMzRHFILEtBQUs4QyxHQUFHbkQ7SUFBSSxPQWJaUDthQWFvRCxXQTVEdERvQyxRQTRET3NCO3NCQUFvQm5LLEdBQUssT0FBSSxXQUExQmdILEdBQWlCaEgsR0FwRTNCbXpDLFdBb0VPaHBDLEdBQW9CbkssSUFBeUI7R0FBWTtZQUU5RGtILEtBQUtpRCxHQUFHbkQ7SUFDVjtLQUFhLE1BQUEsV0EvRGI2QixRQThET3NCO0tBQ00sTUFBQTtLQUFiOztTQUFBbks7O01BQ0UsV0FGUWdILEdBdEVWbXNDLFdBc0VPaHBDLEdBQ1BuSztNQUNFLFVBREZBO2lCQUFBQTtNQUFBQTs7OztHQUVJO1lBR0ZtSCxNQUFNZ0QsR0FBR25EO0lBQ1g7S0FBYSxNQUFBLFdBckViNkIsUUFvRVFzQjtLQUNLLE1BQUE7S0FBYjs7U0FBQW5LOztNQUNFLFdBRlNnSCxHQUNYaEgsR0E3RUFtekMsV0E0RVFocEMsR0FDUm5LO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7O0dBRUk7WUFHRnl3QixNQUFNdG1CLEdBQUcxRCxNQUFNTztJQUNqQjtLQUFJdVksVUFETzlZO0tBRUUsTUFBQSxXQTVFYm9DLFFBMEVRc0I7S0FFSyxNQUFBO0tBREg7O1NBQ1ZuSzs7TUFDa0IsVUFyRmxCbXpDLFdBa0ZRaHBDLEdBRVJuSztNQURJdWYsU0FFSyxXQUhRdlksR0FFakJoSCxHQURJdWY7TUFDSixVQUFBdmY7aUJBQUFBO01BQUFBOzs7V0FESXVmO0dBSUE7WUFHRjFZLFFBQVFFO0lBQXlCLFVBQUEsV0FsRm5DOEIsUUFrRlU5QjtJQUFpQixPQUFBLDhDLE9BN0YzQitSLElBNkZVL1I7R0FBbUM7WUFFM0NKLFFBQVFvRDtJQUNWO0tBQUk3RCxNQUFNLHlCQURBNkQ7S0FFTkUsTUFyR0o4cEMsNEJBb0dJN3RDO0lBRUosMEJBSFU2RCxZQUdXL0osR0FBRTNKLEdBQUssT0FqRzVCNjNDLElBZ0dJamtDLEtBQ2lCakssR0FBRTNKLEdBQWdCO0lBQXZDLE9BREk0VDtHQUVEO1lBS0QrVixTQUFTalo7SUFBZSxVQUFBLFdBN0YxQjhCLFFBNkZXOUI7SUFBNkIsT0FBQTsyQ0FBSy9HLEdBQUssT0FyR2xEbXpDLFdBcUdXcHNDLEdBQWtDL0csR0FBbUI7R0FBQztZQUUvRGlKLE9BQ1dsQyxHQUFHQztJQUFoQjtLQUdXLE1BQUEsV0FuR1g2QixRQWdHYTlCO0tBQUs0dEIsTUFHUjtLQUhRMzBCLElBQUEyMEI7SUFDaEI7WUFEZ0IzMEIsR0FDRjtLQUFXLFVBQUEsV0FEWGdILEdBeEdoQm1zQyxXQXdHYXBzQyxHQUFLL0c7S0FDUyxRQUFBO0tBQWdDLElBRHpDNkwsTUFDeUMsNEJBRHpDN0w7S0FBQUEsSUFBQTZMOztHQUdNO1lBR3RCdkMsUUFDV3ZDLEdBQUdDO0lBQWhCO0tBQ1csTUFBQSxXQXhHWDZCLFFBdUdhOUI7S0FBSzR0QixNQUNSO0tBRFEzMEIsSUFBQTIwQjtJQUFJO1lBQUozMEIsR0FBa0I7S0FBVSxVQUFBLFdBQTlCZ0gsR0EvR2hCbXNDLFdBK0dhcHNDLEdBQUsvRztLQUE0QixVQUFBO0tBQWdDLElBQTVENkwsTUFBNEQsNEJBQTVEN0w7S0FBQUEsSUFBQTZMOztHQUNNO1lBR3RCb2pCLFNBQVM5bUIsSUFBR0MsSUFBSXBCO0lBQ1IsSUFBTmQsTUFBTSxXQTVHVjJDLFFBMkdXVjtPQUVSLFdBN0dIVSxRQTJHY1QsUUFDVmxDO0tBQ3FCO0lBQ2IsT0EvRFZPO2FBNkRFUDtzQkFFYWxHO2NBQXlCLFVBdEgxQ216QyxXQW1IYy9xQyxJQUdHcEk7Y0FBeUIsT0FBQSxXQUh4QmdILEdBbkhsQm1zQyxXQW1IV2hyQyxJQUdNbkk7YUFBMEM7R0FBQztZQUcxRDJRLGVBQTJCdWpDO0lBR0EsVUFBQSwwQkFIQUE7SUFHQSxPQUFBO0dBQThCOzs7OztZQXZCekRsMEIsVUFuQ0FpMEI7Ozs7WUE0RUkvUSxZQUFhaDlCLEtBQUlhO0lBQ25CLFNBRGViLFlBdEpuQitoQztJQTBKYyxPQUFBLFdBMUlkcC9CLFFBc0l1QjlCLElBS0wsT0F4SmxCZCxPQW1KbUJDLEtBakpuQjRTLElBaUp1Qi9SO0lBSWpCLE1BQUE7R0FDc0I7OzttQ0FMdEJtOEIsYUF0SU5yNkIsUUE4SU1tTzs7Ozs7O1lBR0psUSxLQUFLQyxHQUFHTixNQUFNTztJQUNoQjtLQUFJd0gsUUFETS9IO0tBRUcsTUFBQSxXQW5KYm9DLFFBaUpPOUI7S0FFTSxNQUFBO0tBREw7O1NBQ1IvRzs7TUFDWSxVQTVKWm16QyxXQXlKT3BzQyxHQUVQL0c7TUFESXdPLE9BRUcsV0FIU3hILEdBQ1p3SDtNQUNKLFVBQUF4TztpQkFBQUE7TUFBQUE7OztXQURJd087R0FJRjtZQUdBbVIsUUFBUTVZLEdBQUczSjtJQUFVLE9BQUEsOEJBUnJCMEosTUFRUUMsR0FBRzNKO0dBQTRDO1lBQ3ZEeWlCLFFBQVE5WSxHQUFHM0o7SUFBVSxPQUFBLDhCQVRyQjBKLE1BU1FDLEdBQUczSjtHQUE0QztZQUd2REEsUUFBUWdSLGFBQVlqRSxHQUFFQztJQUN4QixHQUFHLDZCQURtQkQsR0FBRUMsSUFFbkI7SUFFUztLQUFSaUUsUUFBUSxXQWpLZHhGLFFBNkpzQnNCO0tBS2hCbUUsUUFBUSxXQWxLZHpGLFFBNkp3QnVCO0tBTWxCbUUsK0JBRkFGLE9BQ0FDO0lBRUosU0FESUMsS0FFQyxPQUZEQTtRQUlXdk87SUFDWDtRQURXQSxNQU5YcU8sT0FRSztLQUVLO01BQUp0RSxJQW5MWm9wQyxXQXFLc0JocEMsR0FVTG5LO01BS0x3TyxJQXBMWjJrQyxXQXFLd0Ivb0MsR0FVUHBLO01BTUxpSyxNQUFNLFdBaEJSbUUsYUFjRXJFLEdBQ0F5RTtLQUVKLFNBREl2RSxLQUNhLE9BRGJBO0tBQzJCLElBUHRCNEIsTUFPc0IsNEJBUHRCN0w7S0FBQUEsSUFBQTZMOztHQVNMOzs7Ozs7T0EvRFY4RTtPQTRDQXZUO09BaEhBd1Q7T0E3REZxM0I7T0FHQWhpQztPQUNBeW1DO09BMkRFam1DO09BL0NGb0M7T0FYQWlRO09BR0FxNkI7T0FGQWpGO09BR0F1RjtPQUZBbHNDO09BR0Ftc0M7T0FJQU47T0FDQUU7T0E0REVsc0M7T0FDQUM7T0FFQUg7T0FNQUM7T0FNQXNwQjtPQWhCQXdqQjtPQW1DQWowQjtPQVRBclo7T0FGQUU7Ozs7OztPQWhGRk47T0FqQkF3dEM7T0FDQUM7T0FXQUw7T0FEQUo7T0FEQUs7T0FRQUM7T0E0RkU1cUM7T0FPQUs7T0FLQTJsQjtPQThDQXRQO09BQ0FFOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7O1lDNUtBczBCLFU7WUFDQUMsVztZQUNBQyxvQjs7SUFDQUM7SUFDQWp3QztJQUNBaEo7SUFDQUU7SUFDQUQ7SUFDQWk1QztJQUNBcjVDO0lBQ0FzNUM7WUFDQUMsZTtHQUFZO0lBQ1pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBQ0E1OUMsaUI7WUFFQW9mLFNBQU8vTCxHQUFFQztJQUVYLEdBQUcsZ0NBRlFBO0tBR04sZ0NBSElELEdBQUVDO0lBSUgsSUFBSm1XLElBSktwVyxJQUFFQztJQU1SLE9BQUEsZ0NBRkNtVztjQUVXLDRCQUZYQSxHQUpPblc7Y0FJUG1XO0dBRXdCOztJQWtEMUJvMEI7SUFDQUM7Ozs7Ozs7WUFDQUMsT0FBT3grQyxHQUFJLE9BQUEsZ0NBQUpBLEdBQUFBLEdBQW9CO1lBYTNCeStDLHdCQUF3Qi90QztJQUMxQixPQWRFOHRDLE9BYXdCOXRDOztjQUdsQjtxQ0FIa0JBOztnQkFNbEI7dUNBTmtCQTtzQkFPaEIseUJBUGdCQTs7a0JBUWhCO29CQUFnQix5QkFBMEIsNkJBUjFCQTtHQVFpQztZQUd6RGd1Qyw0QkFBNEIxK0M7SUFBcUIsVUFYakR5K0Msd0JBVzRCeitDO0lBQXFCLE9BQUE7R0FBMkI7WUFFNUUyK0Msd0JBQXdCMytDO0lBQzFCLE9BQUcsMEJBRHVCQTtjQUVyQix5QkFGcUJBO2NBR2xCO2lDQUFBLHlCQUEwQixlQUhSQTtHQUcyQjtZQUduRDQrQyxRQUFRQyxLQUFJbnVDO0lBQ1IsWUFwQkordEMsd0JBbUJZL3RDOztJQUlaLElBREsxUSxjQUNMLG1CQUpRNitDO0lBS04sT0FYRkYsd0JBV0UsdUJBRkczK0M7R0FNaUI7WUF3QnRCOCtDLG9CQUFvQnJrQztJQUNNLElBQXhCc2tDLE1BQXdCLDRCQUROdGtDO0lBRVIsT0FuQ1pta0MsZ0NBa0NFRztHQUNxQjtZQUd2QkMscUJBQXFCaC9DO0lBT3ZCOztZQUNJO2NBQUMseUJBUmtCQTtjQVFXLHlCQUF5Qiw0QkFScENBO0dBUThDO1lBR25FaS9DLG9CQUFvQnhrQztJQUN0QjtLQUFJc2tDLE1BQXdCLDRCQUROdGtDO0tBRWxCeWtDLG1CQUFtQiwwQ0FEbkJIO0lBR0QsU0FBQSw0QkFKbUJ0a0M7S0FZUixHQXZCWnVrQyxxQkFhRUU7TUFVRixNQUFBO0tBQ0EsT0FYRUE7O0lBTUssR0FuQlBGLHFCQWFFRTtLQU9VLE9BMURaTixlQTBEWSw0QkFQVk07SUFNRixNQUFBO0dBS2lCO1lBT2pCcFYsZ0JBQWlCcDVCLEdBQVl2USxLQUFLRDtJQUNwQyxPQUFHLGdDQURnQndRLEdBQVl2UTtjQUFBQTtjQUNILGdDQURRRCxLQUFqQndRLEtBQWlCeFEsTUFBakJ3UTtHQUNnQztPQUsvQzFRO0dBQ0osU0FIRW0vQyxJQUdFeHVDLEdBQUssT0FBVCw0QkFBSUEsR0FEQTNRLEdBQ1c7Ozs7Ozs7Ozs7Ozs7Ozs7O09BckxiODlDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0Fqd0M7T0FDQWhKO09BQ0FFO09BQ0FEO09BQ0FpNUM7T0FDQXI1QztPQUNBczVDO09BQ0FDO09BQ0FDO09BQ0E1OUM7T0FFQW9mO09Bd0RBeStCO09BQ0FDO09BQ0FDO09BYUFDO09BV0FDO09BRUFDO09BTUFDO09BaUNBRTtPQUtBRTtPQVdBQztPQW9CQW5WO09BSUFxVjs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDbkpJcGtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE5QkZoVTtJQUVDcVA7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXOztJQUdib2hCO0lBQ0E1RztJQUNDRjs7WUFJRHRJLFVBQVV0QixHQUFJLE9BQUEsK0JBQUpBLEdBQW1CO1lBRTdCdUIsVUFBVTdEO0lBQ1osMkNBRFlBO2NBRUwsd0JBRktBO2NBR0wsMkJBSEtBO0dBRzhCOzs7Ozs7U0FyQnhDckg7U0FFQ3FQO1NBR0EyRDtTQUtEcUg7U0FDQTVHO1NBT0F2STtTQUZBRDtTQWNFK0k7Ozs7Ozs7Ozs7Ozs7WUFHSkQsR0FBRzNNLEtBQUkrUixHQUFJLE9BQUEsK0JBQVIvUixVQUFJK1IsR0FBa0M7WUFPekMzRixpQkFBb0IsU0FBRTtHQUNoQjtJQUFBLE1BQUE7SUFBTkksTUFBTTs7Ozs7Ozs7WUFFTnlrQyxvQkFBZSxxQ0FFTDtZQUdWQyxvQkFBZSxxQ0FFTDtZQUdWQyxnQkFBVyxxQ0FFRDtZQUdWQztJQUFnQjs7O0tBRVg7O0lBRDRFO0dBQ3ZFO1lBR1ZDLGdCQUFXLG9DQUVEO1lBR1ZDO0lBQVc7Ozs7OztLQUNnQjs7SUFDdEI7R0FBSztZQUtWQztJQUFjOzs7Ozs7O0tBQzBCOztJQUNuQztHQUFLO1lBR1ZDLGlCQUFpQmp2QztJQUFJLElBQVcsTUFBQSx3QkFBWCxNQUFBLG1CQUFKQTtJQUFlLE9BQUE7R0FBVTtZQUUxQ2t2QyxjQUFjbHZDO0lBQ2hCLE9BcEJFOHVDLFNBbUJjOXVDO2NBRmRpdkMsaUJBRWNqdkM7Y0FHWCwyQkFIV0E7R0FHd0M7WUFHdERtdkMsVUFBVW52QyxHQUFJLE9BekJkOHVDLFNBeUJVOXVDLFNBUlZpdkMsaUJBUVVqdkMsUUFBMEQ7WUFFcEVvdkM7SUFBZTs7Ozs7OztLQUN5Qjs7SUFDbkM7R0FBSztZQUdWQztJQUFxQjs7Ozs7O0tBQ007O0lBQ3RCO0dBQUs7WUFHVkM7SUFBcUI7Ozs7OztLQUNNOztJQUN0QjtHQUFLO1lBR1ZDLGtCQUNBdnZDO0lBRG9CLFNBQ3BCQTtjQUFBQTtlQUFBQTtPQUM4QjtRQUFBLE1BQUE7UUFBWCxNQUFBLG1CQURuQkE7UUFDbUIsTUFBQTtPQUFBLE9BQUE7OztrQkFEbkJBO01BRThCO09BQUEsTUFBQTtPQUFYLE1BQUEsbUJBRm5CQTtPQUVtQixNQUFBO01BQUEsT0FBQTs7O2lCQUZuQkE7S0FBOEIsSUFBQSxNQUFBLHdCQUFYLE1BQUEsbUJBQW5CQTtLQUE4QixPQUFBOztJQU96QjtLQUFBLHdCQUFVLHdCQVBmQTtLQUtFLE1BQUE7SUFBQSxPQUFBO0dBRTJCO1lBRzdCd3ZDLGNBQWN4dkM7SUFBSSxPQTFCbEJvdkMsYUEwQmNwdkMsU0FYZHV2QyxrQkFXY3Z2QztHQUErRDtHQUV0RTtJQUNMalE7SUFDQW9mO0lBQ0FFO0lBQ0F6YTtJQUNBQztJQUNBQztJQU5LLFFBQ0wvRSxRQUNBb2YsVUFDQUUsVUFDQXphLFVBQ0FDLFVBQ0FDO0lBT0UyNkM7SUFDQTFnQjtJQUNDTztZQUlEajRCLFVBQVFxNEMsSUFBR0M7SUFBSyxJQUF1QixNQUFBLHNCQUE1QkEsS0FBYSxNQUFBLHNCQUFoQkQ7SUFBK0IsT0FBQTtHQUFjO1lBQ3JERSxjQUFZM3BDLE9BQU1qRztJQUF5QixVQUFBLHNCQUF6QkE7SUFBeUIsT0FBQSw2QkFBL0JpRztHQUE0QztZQUN4RDRwQyxPQUFLN3ZDLEdBQUksT0FBQSw2QkFEVDR2QyxlQUNLNXZDLEdBQTBCOztvREFGL0IzSSxXQUxBMDNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTNGSjlrQjtPQTdCR0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJIUTs7T0FPQVA7Ozs7Ozs7OztPQXVCQWlsQztPQXBCQUo7T0FLQUM7T0FvQkFJO09BT0FDO09BdEJBSjtPQUtBQztPQThCQU07T0FOQUQ7T0FRQUU7T0FLQUM7T0FLQUM7T0FnQkFFO09BWEFEOzs7O1FBaUNJSztRQUNBQztRQVJBSjtRQUNBMWdCO1FBQ0NPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7OztHQzNJVzs7SUFBQTs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7OztZQ1NoQndnQixjQUFlQyxRQUFRQztJQUN6QixJQWUyQkMsU0FmZCxpQ0FDYkM7OzJCQWMyQkQsUUFkM0JDLEtBQzRCLDBCQUQ1QkE7S0FBQSxVQUFBQTtnQkFBQUE7S0FBQUE7O0lBR2E7S0FBQTtPQUFBOzsrQkFMSUg7K0JBQVFDOzs7S0FLekI7O1NBQUFqRDs7TUFDYztPQUFSb0Q7U0FBUSxpREFOR0osUUFLakJoRDs7UUFXMkJrRCxRQVZyQkUsZ0NBTm1CSCxhQUt6QmpEO01BQUEsVUFBQUE7aUJBQUFBO01BQUFBOzs7SUFNTTtLQUZGcUQ7O1NBVHFCSixtQ0FBQUE7S0FXbkI7T0FBQTs7K0JBWFdEO1NBVWpCLHNCQVZ5QkM7aUNBQVJEOztTQVVqQm5pQjs7TUFHYztPQUFSeWlCLFFBQVEsaURBYkdOLFFBVWpCbmlCOzRCQU0yQnFpQixRQUhyQkksT0FKRkQ7TUFFRSxVQUROeGlCO2lCQUFBQTtNQUFBQTs7O0lBY21CO0tBQWYwaUIsZUFBZSx3QkF4QkZQOzs2QkFnQlVFLFFBU2MsMEJBRHJDSztJQUNELEtBQUEsK0JBRENBO1NBUjhCcjNDO0tBQ2hDO2lCQURnQ0E7OztPQUdpQixVQUFBLDBCQUhqQkE7T0FHeEIsS0FBQSxnREFIaUJnM0MsUUFBT2gzQyxVQUszQixJQUwyQjZMLE1BQUE3TCxXQUFBQSxJQUFBNkw7OztNQVUvQjtNQUVFOzs7SUFEQSxXQUFLLDRCQVhpQm1yQztHQVlsQjsyQkE1QlBIOzs7RTs7Ozs7OztZQ1BBUyxXO1lBQ0FDLGE7eUJBREFELE9BQ0FDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNFQTd5QztJQUNBNDVCO0lBQ0FnWjtJQUtHN3FDO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsZUFNRFM7MERBQUFBOztZQWNGRCxpQkFBb0IsU0FBRTtZQU10QmhLLElBQUkrN0IsS0FBS2xoQixLQUFLdmI7SUFDaEIsU0FEV3ViLE9BQUt2Yiw4QkFBVnk4QixNQUVELE9BRkNBO0lBSUo7eUNBSlNsaEIsS0FBS3ZiLDJCQUFWeThCO2FBQVV6OEIsS0FNVDtJQUVPLElBQU4yOEIsTUFBTSwyQkFSRTM4QjtJQVNaLHlCQVRFeThCLEtBQUtsaEIsS0FRSG9oQixRQVJRMzhCO0lBU1osT0FBQSw0QkFESTI4QjtHQUU0RDtZQUdsRUksS0FBT3IyQixLQUFVMUcsS0FBSXk4QjtJQUN2QixHQURTLzFCLFNBQU1DLE1BQU5ELFFBQUE2VSxNQUFNNVUsY0FBTjRVO0lBQ1QsR0FEbUJ2YjtTQU1QbEcsSUFOT2tHLFFBTVAyRixNQUFBN0w7O1NBQUE2TCxNQUNHLGtEQVBRODJCLE1BQWRsaEI7SUFPTSxPQXBCYjdhLElBYXFCKzdCLEtBQWRsaEIsS0FNRzVWO0dBQ29CO1lBUTlCMnJDLFNBQVc1cUMsS0FBVTFHLEtBQUlhLEdBQUU4YjtJQUM3QixHQURhalcsU0FBTUMsTUFBTkQsUUFMWTZxQyxRQUtONXFDLGNBTE00cUM7SUFNekI7S0FBSS8xQixlQUFKLHNCQUQyQjNhO0tBRVMsT0FBQSw0QkFEaEMyYSxjQU5xQisxQjtLQU9yQjMxQixRQUFNLDRCQUZhNWI7SUFHdkIsOENBUnlCdXhDLE9BT3JCMzFCLE9BREFKO0lBR3lCLElBVENnMkIsTUFTRCw0QkFUSkQsT0FPckIzMUIsUUFQcUJMLE1BQUFnMkI7SUFDekI7Z0JBRHlCaDJCLE1BQUtpMkI7O01BRTFCOztTQUFBLGlEQUd1QjN3QyxHQUxGMGEsTUFLSW9CO01BSHpCO09BQTZELElBRnhDZ2YsUUFFd0MsNEJBRnhDcGdCO09BQUFBLE1BQUFvZ0I7Ozs7Ozs7S0FFckI7O0dBT3lDO1lBRzNDL21CLFNBQVMvVCxHQUFJLG1DQUFKQSxXQUFnQjtZQUVyQjR3Qyx3QkFBd0I3YixRQUFRcmEsS0FBS3ZiLEtBQUswa0IsV0FBVS9IO0lBQzFELElBRHNDZ2YsUUFBQXBnQjtJQUN0QztRQUQyQ3ZiLE9BQUwyN0IsT0FFakMsTUFBQSw0QkFGMkNqWDtLQUd4QztPQUFBOytDQUhzQmtSLFFBQVErRixRQUFvQmhmO01BSXJELE9BSmlDZ2Y7S0FLRyxJQUxINFYsUUFLRyw0QkFMSDVWO0tBQUFBLFFBQUE0Vjs7R0FLaUM7WUFHckVHLG1CQUFtQjd3QyxHQUFHNmpCLFdBQVUvSDtJQUNsQyxPQVRNODBCO2FBUWU1d0MsNEJBQUFBLElBQUc2akIsV0FBVS9IO0dBQzhCO0dBSWhELElBQVorSDtZQURGaXRCLFVBRVk5d0MsR0FBRThiO0lBQU8sT0FOckIrMEIsbUJBTVk3d0MsR0FEVjZqQixXQUNZL0g7R0FBMkM7R0FNM0M7SUFBWmlJOzs7WUFERmd0QixlQUVpQi93QyxHQUFFMGEsS0FBSW9CO0lBQ3ZCLElBQUkzYyw0QkFEYWE7WUFBRTBhLE9BQ2Z2YixPQURldWI7S0FJZCxPQXpCRGsyQix3QkFxQmE1d0MsR0FBRTBhLEtBQ2Z2YixLQUZGNGtCLGFBQ3FCakk7SUFHbEIsT0FBQTtHQUNtRDtZQU1wRGsxQix5QkFBeUJqYyxRQUFRcmEsS0FBS3ZiLEtBQUswa0IsV0FBVS9IO0lBQzNELElBRHVDZ2YsUUFBQXBnQjtJQUN2QztZQUR1Q29nQixPQUVsQyxNQUFBLDRCQUY0Q2pYO0tBR3pDO09BQUE7K0NBSHVCa1IsUUFBUStGLFFBQW9CaGY7TUFJdEQsT0FKa0NnZjtLQUtHLElBTEg0VixRQUtHLDRCQUxINVY7S0FBQUEsUUFBQTRWOztHQUtpQztZQUd0RU8sb0JBQW9CanhDLEdBQUc2akIsV0FBVS9IO0lBQ25DLElBQUkzYyw0QkFEa0JhO0lBRXRCLE9BVk1neEM7YUFRZ0JoeEMsR0FFVSw0QkFENUJiLFNBQUFBLEtBRHFCMGtCLFdBQVUvSDtHQUUyQjtHQUk5QztJQUFab0k7WUFERmd0QixXQUVhbHhDLEdBQUU4YjtJQUFPLE9BUHRCbTFCLG9CQU9hanhDLEdBRFhra0IsYUFDYXBJO0dBQTRDO0dBTTdDO0lBQVp1STs7Ozs7Ozs7OztZQURGOHNCLGdCQUVrQm54QyxHQUFFMGEsS0FBSW9CO0lBQ3hCLElBQUkzYyw0QkFEY2E7YUFBRTBhLE9BQ2hCdmIsTUFEZ0J1YjtLQUlmLE9BMUJEczJCLHlCQXNCY2h4QyxHQUFFMGEsS0FDaEJ2YixLQUZGa2xCLGFBQ3NCdkk7SUFHbkIsT0FBQTtHQUNvRDtZQU16RHUwQixNQWpEWXJ3QyxHQUFFOGI7SUFrRGhCLElBQUksZUF4REYrMEIsbUJBTVk3d0MsR0FEVjZqQixXQUNZL0gsVUFrRFo7Ozs7OztLQUNnQzs7R0FBSTtZQUd0Q3MxQixPQXRCYXB4QyxHQUFFOGI7SUF1QmpCO0tBQUksZUE5QkZtMUIsb0JBT2FqeEMsR0FEWGtrQixhQUNhcEk7S0F1QmI7Ozs7OztLQUNnQzs7R0FBSTtZQUd0Q3UxQixXQUFXcnhDLEdBQUUwYSxLQUFJb0I7SUFDbkIsSUFBSSxlQXZERmkxQixlQXNEVy93QyxHQUFFMGEsS0FBSW9CLFVBQ2Y7Ozs7O0tBQ2dDOztHQUFJO1lBR3RDdzFCLFlBQVl0eEMsR0FBRTBhLEtBQUlvQjtJQUNwQixJQUFJLGVBNUJGcTFCLGdCQTJCWW54QyxHQUFFMGEsS0FBSW9CLFVBQ2hCOzs7OztLQUNnQzs7R0FBSTtZQVVwQ2xROztLQUFxQjJsQztLQUFUQzs7O3lCQUdvQiw2QkFIWEQ7O0lBQ3ZCOzs4QkFDMkIsNkJBRmJDOzs7WUFPWkEsUUFBUXh4QyxHQUFJLE9BQUpBLEtBQWE7WUFDckJ1eEMsZUFBZXZ4QyxHQUFJLE9BQUpBLEtBQW9CO1lBS25DeXhDO0lBQW1CQyxlQUFlQyxnQkFBZ0JILFNBQVNJLFdBQVdDO0lBQ3BELElBQWhCQyxzQkFEaUJKOztLQUlaO1dBSExJOzs7UUFHSztVQUorREQ7VUFBcENGO2lDQUFnQkgsU0FDaERNO01BQUFBO09BRHlERixjQU1mLDRCQUwxQ0U7OztLQU9EO09BQUE7U0FScUVEO1NBQXBDRjtnQ0FBZ0JILFNBQ2hETTtNQUFBQSxxQkFRa0IsNEJBUmxCQTtZQUFBQTs7R0FTVTtZQUdaQyxlQUFnQlI7SUFDbEIsT0FEa0JBO0dBR1k7WUFNNUJyeUMsT0FBT3N5QyxTQUFTRDtJQUNsQjtLQUFJLytCLDBCQURLZy9CO0tBRUxJLFlBQVksMkJBRFpwL0I7V0FBQUE7S0FJZSxJQUFicS9CLGFBZEpFLGVBU2dCUjtLQUVkSztLQUtrQjtNQUFoQkY7TUFDUyxPQUFBLDRCQVBYbC9CO01BTWtCOztVQUNwQnZaOztPQURJeTRDO1FBN0JKRDtVQTZCSUM7aUNBUEdGLFNBUVB2NEM7VUFST3U0QztVQUVMSTtVQUdFQztPQUhGRCxjQU1GMzRDLEtBREl5NEM7T0FDSixXQUFBejRDO21CQUFBQTtPQUFBQTs7OztJQVVGLFdBbEJTdTRDLFNBQVNELGdCQUVkSztHQWdCa0M7WUFLcENJLGVBQWlCbnNDO0ksR0FBQUEsU0FBTUMsTUFBTkQsUUFBQTZVLE1BQU01VSxjQUFONFU7UUFBb0NrM0Isc0JBQWhCTCwyQkFBVEM7b0JBQTBDUztLQUN4RTtZQURtQnYzQjs7UUFDQzs7Z0NBRG9EdTNCO2dDQUExQ1Q7V0FBWDkyQjtNQUlBO09BQWJtM0IsYUFwQ0pFLGVBZ0NxQ1I7T0FLakM5d0MsUUFMYWlhO09BTWJnM0I7T0FDQWxpQixJQUFKLHNCQVA0QmdpQjtPQVF4QmgvQixJQUFKLHNCQVJzRXkvQjs7VUFLbEV4eEMsT0FHQStSLEtBRkFrL0IsbUJBQ0FsaUI7WUFHRW1pQix3Q0FWZ0VNLE1BS2xFeHhDO1FBQ0FpeEM7U0FuREpEO1dBbURJQyxrQkFJRUMsZ0JBVnNCSCxTQUF5QkksV0FJakRDO1FBQ0FweEMsT0FhRyw0QkFiSEE7OztjQUNBaXhDLHFCQUNBbGlCO2lCQWF1Qiw0QkFmdkIvdUIsTUFFQSt1Qjs7OztLQUxELFVBa0J1Qzs7WUFHMUMwaUIsUUFBUWx5QyxHQUFFcUwsS0FBTSxZQXZCaEIybUMsa0JBdUJRaHlDLEdBQUVxTCxhQUFvQztZQUU5QzhrQyxRQUFPejFCLEtBQUkxYSxHQUFHbXlDO0lBQ1IsSUFBSmhvQyxJQTFCRjZuQyxlQXlCT3QzQixLQUFJMWEsR0FBR215QztJQUVoQixZQURJaG9DLFFBQUFBO0dBQzBCO1lBRzVCaW9DLFlBQVcxM0IsS0FBSTFhLEdBQUdteUM7SUFDWixJQUFKaG9DLElBL0JGNm5DLGVBOEJXdDNCLEtBQUkxYSxHQUFHbXlDO0lBRXBCLFFBRElob0MsR0FFQyxPQUZEQTtJQUtvQyxrQ0FBZSw2QkFOdENuSztJQU1iLE9BQUE7YUFoUUp1M0IsU0FnUUk7R0FBOEU7WUFHaEY4YSxpQkFBa0RDLGFBQWlCTDtRQUE5Qkwsc0JBQWhCTCwyQkFBVEM7YUFDZCxzQkFEY0E7S0FFQyxXQUFBLHFEQUZzRFM7S0FFakMsT0FBQSxnREFBL0I7O0lBRWM7S0FBYkosYUEzRUpFLGVBdUVxQlI7S0FLakJHO0tBQ0FsaUIsSUFBSixzQkFOWWdpQjtLQU9SaC9CLElBQUosc0JBUG1FeS9CO0tBUS9EbEg7S0FBUTtPQURSdjRCO1NBRUovUjs7U0FKSWl4QyxxQkFDQWxpQjtrQkFFQXViO09BQUFBLGVBSVMsNEJBSGJ0cUMsR0FISSt1QjtPQURBa2lCO1FBTDhDWSxjQUFiVixjQWVxQiw0QkFUdERwaUI7O1NBR0ovdUIsSUFGSStSO1dBWUltL0Isd0NBbkIyRE0sTUFTbkV4eEM7T0FKSWl4QztRQXpGSkQ7VUF5RklDLGtCQWNJQyxnQkFuQklILFNBQXlCSSxXQUlqQ0M7O01BS0osV0FBQXB4QztTQUZJK1IsTUFFSi9SO01BQUFBOzs7cUNBRElzcUM7O1lBdUJKd0gsY0FBZTczQixLQUFJMWEsR0FBT3RDLEdBQUc4MEM7SUFDekIsWUE5Q0pyQyxRQTZDZXoxQixLQUFJMWEsR0FBT3RDO2dCQUVsQixPQUZrQkE7SUFJMUI7S0FES3pFO0tBQ0R3NUMsUUFBSixzQkFKMEIvMEM7S0FLdEJnMUMsOEJBTGUxeUM7S0FNZjJ5QyxXQUFKLHNCQU42Qkg7S0FPTCxPQUFBLDRCQUhwQkMsT0FFQUU7S0FDbUIsT0FBQSxrQ0FGbkJEO0tBRUE1VyxNQUFNO0lBQ1YsMkJBUjBCcCtCLE1BT3RCbytCLFFBSkM3aUM7SUFNTCwyQkFUNkJ1NUMsV0FPekIxVyxLQUpDN2lDLEdBR0QwNUM7SUFTSTtLQUFBLE9BQUEsNEJBWEpGLE9BREN4NUM7S0FZRSxPQUFBLGtDQVZIeTVDO0tBU08sT0FBQSw0QkFYTno1QyxHQUdEMDVDO0tBTU8sT0FBQSw0QkFUTjE1QyxHQUVEeTVDO0lBS0osMkJBVjBCaDFDLFNBT3RCbytCO0lBR0osT0FBQSw0QkFISUE7R0FTMEQ7WUFJOUQ4VyxZQUFZNXlDLEdBQU90QyxHQUFHODBDO0lBQ1YsSUFBVk4sVUFwREZHLFVBbURZcnlDLE1BQU90QztJQUVyQixLQURJdzBDLFNBRUksT0FIYXgwQztJQU9uQjtLQUZJKzBDLDhCQUxlLzBDO0tBTWZnMUMsOEJBTlExeUM7S0FPUjJ5QyxXQUFKLHNCQVBzQkg7S0FRbEJLLGNBQWMseUJBUGhCWDtLQVErQixPQUFBLDRCQUY3QlMsVUFEQUQ7S0FHNEIsT0FBQSxrQ0FENUJHO0tBQ21CLE9BQUEsNEJBSm5CSjtLQUlBM1csTUFBTTtLQUNOZ1g7S0FDQUM7SUFDSjs7TUFYRWI7ZUFXd0JqNUM7T0FDZCxJQUFOa0csTUFBTSw0QkFEY2xHLEdBRHRCODVDO09BR0Y7eUJBZGlCcjFDLEdBV2ZxMUMsaUJBRkFqWCxLQUNBZ1gsaUJBR0UzekM7T0FNTyxXQUFBLDRCQVRUMnpDLGlCQUdFM3pDO09BRUosMkJBZm9CcXpDLFdBU2xCMVcsV0FGQTZXO09BY2MsV0FBQSw0QkFYZEcsaUJBR0UzekM7T0FIRjJ6QyxrQkFXYyxrQ0FkZEg7T0FlYyxXQUFBLDRCQVhkSSxpQkFFRTV6QztPQUZGNHpDLGtCQVdjLGtDQWhCZEw7O01BZ0J5QztJQU10QyxXQUFBLDRCQXZCSEQsT0FNQU07SUFZSiwyQkF2Qm1CcjFDLEdBV2ZxMUMsaUJBRkFqWCxLQUNBZ1g7SUFhSixPQUFBLDRCQWRJaFg7R0FvQjBEO1lBRzlEa1gsU0FBU2h6QyxHQUFFdEM7SUFDYjtLQUFJdTFDLG9DQURPanpDO0tBRVBreUMsVUFyRkZHLFVBbUZTcnlDLE1BQUV0QztLQUtYO09BQUEsNkJBSEV3MEMsbUNBRlN4MEM7S0FJWCxXQUFDLDZCQUhDdTFDLGNBQ0FmO0lBSUMsT0FBQTs7OztzQkFBS2o1QyxHQUFFd0g7Y0FBSztlQUFtQyxPQUFBLDRCQUF4Q0EsR0FBRnhIO2VBQXlDLE9BQUEsa0NBTC9DZzZDO2NBSytDLE9BelRuRHB6QyxJQW1UYW5DLEdBTWUsNEJBQWxCekUsR0FMTmc2QzthQUtvRTtHQUFDO1lBYXJFMzhDLE1BQ0c0OEMsT0FBUUM7SUFDVixHQUFHLG9DQURERCxPQUFRQyxRQUVMO0lBR0QsV0FBQSw2QkFMRkQsVUFBUUM7SUFLTjtLQUVHLFdBQUEsNkJBUExELFVBQVFDO0tBT0g7O21EQVBMRCxVQUFRQzs7Ozs7SUFPSDtHQUM0RDtZQUlwRXBrQjtJQUNEO0tBRWtCcWtCO0tBREtDO0tBRFBDO0tBTVRDLFVBQVksK0NBSkRIO0tBR2JJLGdDQUNFRDtLQUlBRSxVQUFZLDZCQVRJSjtLQVFsQkssa0NBQ0VELGVBTEZEO0tBVUVHLFVBQVksNkJBZkhMO0tBY1hNLGtDQUNFRCxlQU5GRDtJQVNKLFdBSklFO0dBSXlCO1lBTTdCQyxxQjtHQWhEVyxrQkFVWHY5QyxPQWFBeTRCLGFBeUJBOGtCO1lBVUpDLGlCQUFrQnZDLGdCQUFnQjcyQixLQUFJMWEsR0FBR3d4QyxTQUMzQyxPQXJLSXJCLFFBb0tnQ3oxQixLQXBOaEN4YixPQW9OdUNzeUMsU0FBdkJELGlCQUFvQnZ4QztHQUN3QztZQUc5RSt6QyxxQkFBc0J4QyxnQkFBZ0I3MkIsS0FBSTFhLEdBQUd3eEMsU0FDL0MsT0FwS0lZLFlBbUtvQzEzQixLQXhOcEN4YixPQXdOMkNzeUMsU0FBdkJELGlCQUFvQnZ4QztHQUN3QztZQUdsRmcwQyxxQkFBc0J6QyxnQkFBZXZ4QyxHQUFHc3lDLGFBQWFkLFNBQ3ZELE9BL0pJYSxVQTlEQW56QyxPQTRObURzeUMsU0FBL0JELGlCQUFrQmUsYUFBSHR5QztHQUkvQjtZQUdOaTBDLHlCQUEwQjFDLGdCQUFnQjcyQixLQUFJMWEsR0FBR3d4QztJQUNqQixXQXBPOUJ0eUMsT0FtTytDc3lDLFNBQXZCRDtJQUM1QixzQixPQXZJSWdCLGNBc0l3QzczQixXQUFJMWE7R0FDd0M7WUFHdEZrMEMsdUJBQXdCM0MsZ0JBQWV2eEMsR0FBR3d4QztJQUNqQixXQXhPdkJ0eUMsT0F1T3dDc3lDLFNBQWxCRDtJQUMxQixzQixPQXZISXFCLGtCQXNIcUM1eUM7R0FDd0M7WUFHL0VtMEMsaUJBQWtCNUMsZ0JBQWV2eEMsR0FBR28wQztJQUN2QixXQXhCYk4saUJBdUJrQnZDLG1CQUFldnhDLEdBQUdvMEM7SUFDdkIsT0FBQTtHQUF1RDs7R0FHckQsU0FBZkM7SSxPQTNCQVA7O0dBMkJlO0dBQ0ksU0FBbkJRO0ksT0F4QkFQOztHQXdCbUI7R0FDQSxTQUFuQlE7SSxPQXJCQVA7O0dBcUJtQjtHQUNJLFNBQXZCUTtJLE9BZkFQOztHQWV1QjtHQUNGLFNBQXJCUTtJLE9BWkFQOzs7SUFZcUI7Ozs7Ozs7R0FDTixTQUFmUTtJLE9BVEFQOztZQVdBUSxvQkFRRXRwQyxLQUFTdXBDLFdBQW1CLzBDLEtBQUtneUM7SUFDbkM7S0FBSWdELGdDQURGeHBDO0tBUHNDeXBDLFVBU3hDLHNCQUY4QmoxQztZQUFuQiswQztxQkFDUEMsVUFET0Q7YUFLVCxXQXpjRmozQyxtQkFvY1dpM0MsV0FDUEM7SUFTSjtZQUFBLDRCQVZXRCxXQVA2QkUsWUFRcENEO2VBU0o7UUFqQmlCRSxVQU9OSCxXQVBvQkk7SUFDL0I7UUFEK0JBLFlBQVNGLFNBRW5DO0tBQ0c7O09BQUE7U0FJMkJqRDtnQ0FBakN4bUMsS0FQZTBwQztnQ0FPYWwxQyxLQVBDbTFDO01BSzFCO0tBRCtDO01BSnJCQyxZQUlxQiw0QkFKckJEO01BQWRFLFlBSU8sNEJBSlBIO0tBQUFBLFVBQUFHO0tBQWNGLFVBQUFDOztHQWtCMkI7WUFHMURFLGNBQWNwZ0IsUUFBUTdCLFFBQVEyZTtJQUNoQztLQUFJdUQsbUNBRFlyZ0I7S0FFWjNCLGFBQUosc0JBRndCRjtZQUVwQkUsY0FEQWdpQjs7Y0F2QkZUO2VBc0JjNWY7ZUFNTiw0QkFMTnFnQixZQUNBaGlCO2VBRm9CRjtlQUFRMmU7O0dBUWhCO1lBR2R3RCxjQUFjdGdCLFFBQVF4SixRQUFRc21CO0lBQ2hDO0tBQUl1RCxtQ0FEWXJnQjtLQUVadWdCLGFBQUosc0JBRndCL3BCO1lBRXBCK3BCLGNBREFGO2tCQWxDRlQsb0JBaUNjNWYsV0FBUXhKLFFBQVFzbUI7R0FJa0M7O0lBTzVEdmpCO0lBQ0FpbkI7SUFDQ2ptQjtZQWtCRGo0QixVQVp1Qm0rQyxTQUFlQztJQWF4QyxHQUFHLDZCQWJzQkQsU0FBZUMsVUFjbkM7O0tBZDRDQyw2QkFBVEQ7S0FBTkUsNkJBQVRIO0tBQUw5NkI7SUFDcEI7UUFEb0JBLFFBQWNpN0IsYUFBZGo3QixRQUE2Qmc3QjtRQUE3Qmg3QixRQUE2Qmc3QixNQUk1QztLQU40RDtNQUF0Qy9GLDRCQUVhOEYsU0FBcEIvNkI7TUFGSWcxQiw0QkFFQzhGLFNBQUw5NkI7TUFGNkMsT0FBQSwwQkFBdENpMUI7TUFBa0IsT0FBQSwwQkFBckJEO01BUWxCbGdDLElBUjJEO0tBUy9ELFNBRElBLEdBR0csT0FISEE7S0FFcUIsSUFSUHNyQixRQVFPLDRCQVJQcGdCO0tBQUFBLE1BQUFvZ0I7O0dBcUJhO1lBRy9CdG5CLGNBQVl2TixPQUFNakc7SUFDcEI7S0FBSWIsNEJBRGdCYTtLQUVoQmdnQyxjQUFZLDZCQUZGLzVCLE9BQ1Y5RztLQUVXLE9BQUEsNEJBRlhBO0tBQ1E7O1NBQ1p1Yjs7TUFDaUMsV0FBQSxpREFKYjFhLEdBR3BCMGE7TUFESXNsQixhQUVPLDZCQUZQQTtNQUNKLFdBQUF0bEI7a0JBQUFBO01BQUFBOzs7V0FESXNsQjtHQUlFO1lBR0p2c0IsT0FBS3pULEdBQUksT0FBQSw2QkFUVHdULGVBU0t4VCxHQUEwQjtZQUMvQml6QixVQUFVdjFCLEdBQUd3MUI7SUFBUyxPQWhFMUJpaUIsY0FnRWN6M0MsR0FBR3cxQjtHQUFnRTtZQUM3RTVILFVBQVU1dEIsR0FBRzZ0QjtJQUFTLE9BdEQxQjhwQixjQXNEYzMzQyxHQUFHNnRCO0dBQWdFOztHQUM5RCxTQUFmcXFCO0ksT0ExSEo5Qjs7R0EwSG1CO0dBQ0ksU0FBbkIrQjtJLE9BdkhKOUI7O0dBdUh1QjtHQUNBLFNBQW5CK0I7SSxPQXBISjlCOztHQW9IdUI7R0FDSSxTQUF2QitCO0ksT0E5R0o5Qjs7R0E4RzJCO0dBQ0YsU0FBckIrQjtJLE9BM0dKOUI7O0dBMkd5QjtHQUNOLFNBQWYrQjtJLE9BeEdKOUI7OztZQXlHSStCO0lBQWtCO0tBQUE7TSxPQTlGdEJ2Qjs7O29EQWdFSXQ5QyxXQW5CQWsrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBd0RKaDBDLGdCO1lBQ0FELGdCO1lBRUE1QixLQUFLOFMsR0FBR3ZTO0lBQ1YsR0FET3VTLE9BQ08sV0FyaUJaN1UsbUJBb2lCSzZVO0lBRUM7S0FBSnhTLElBQUksMkJBRkR3UztLQUdNLE9BQUEsNEJBSE5BO0tBRUM7O1NBQ1J2Wjs7TUFDRSxlQUZFK0csR0FDSi9HLEdBQ2dCLFdBSk5nSCxHQUdWaEg7TUFDRSxXQURGQTtrQkFBQUE7TUFBQUE7OztJQUdBLE9BQUEsNEJBSkkrRztHQUl3RDtZQUcxREYsUUFBUXBDO0lBQ1Y7S0FBaUJrd0IsTUFDVCxrREFGRWx3QjtLQUNHOGE7S0FBSXZmLElBQUEyMEI7SUFBSTtZQUFKMzBCLEdBQWtCLE9BQXRCdWY7S0FBbUQ7TUFBL0MxVCxNQUErQyw0QkFBL0M3TDtNQUFKaXhCLFlBQXFDLGdCQUR4Q3hzQixHQUNPekUsSUFBSnVmO0tBQUFBLE1BQUEwUjtLQUFJanhCLElBQUE2TDs7R0FDSztZQUdwQjY3QixZQUFZampDO0lBQ2QsSUFBSXlCLDRCQURVekIsSUFFRDhhLFNBQUl2ZjtJQUFJO1FBQUpBLE1BRGJrRyxLQUNpQyxPQUF4QnFaO0tBQXFEO01BQWpEMVQsTUFBaUQsNEJBQWpEN0w7TUFBSml4QixZQUF1QyxnQkFGdEN4c0IsR0FFR3pFLElBQUp1ZjtLQUFBQSxNQUFBMFI7S0FBSWp4QixJQUFBNkw7O0dBQ1I7WUFHUDdCLElBQUlqRDtJQUNOO0tBQUliLDRCQURFYTtLQUVGa0QsTUFBTSwyQkFETi9EO0tBRVMsT0FBQSw0QkFGVEE7S0FDTTs7U0FDVmxHOztNQUNrQyxXQUFBLDRCQUg5QmtHOztRQUNBK0Q7UUFDSmpLOytCQUhNK0csR0FJMkIsa0NBRGpDL0c7TUFBQSxXQUFBQTtrQkFBQUE7TUFBQUE7OztJQUdBLE9BQUEsNEJBSklpSztHQUkwRDtHQU05QztJQUFaNHNCO1lBREZxbUIsWUFFY0MsTUFBU0M7SUFDdkI7S0FBSTM3QixNQXJmSm0yQixtQkFvZmN1RixNQURadG1CLGFBQ3FCdW1CO0tBRWlDLE9BQUEsa0RBRjFDRCxPQUNWMTdCO0tBQ21ELE9BQUE7S0FBN0IsT0FuaUIxQjdhLElBaWlCY3UyQyxNQUUwQiw0QkFEcEMxN0I7SUFDSixXQW5pQkE3YSxJQWlpQmN1MkMsU0FDVjE3QjtHQUMwRTtHQU9oRTtJQUFaNDdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFERkMsWUFFY0gsTUFBU0M7SUFDdkI7S0FBSTM3QixNQWhlSnUyQixvQkErZGNtRixNQURaRSxhQUNxQkQ7S0FFaUMsT0FBQSxrREFGMUNELE9BQ1YxN0I7S0FDbUQsT0FBQTtLQUE3QixPQTdpQjFCN2EsSUEyaUJjdTJDLE1BRTBCLDRCQURwQzE3QjtJQUNKLFdBN2lCQTdhLElBMmlCY3UyQyxTQUNWMTdCO0dBQzBFO1lBTTlFODdCLFFBQVFKLE1BQU1LO0lBQ2hCLElBQUksZUFyQkZOLFlBb0JRQyxNQUFNSyxNQUNaOzs7OztLQUNnQzs7R0FBSTtZQUd0Q0MsUUFBUU4sTUFBTUs7SUFDaEIsSUFBSSxlQWhCRkYsWUFlUUgsTUFBTUssTUFDWjs7Ozs7S0FDZ0M7O0dBQUk7WUFHbENFLGNBQWMzekMsR0FBR3dNO0lBQ3ZCLElBRG9CaWQsTUFBQXpwQjtJQUNwQjtVQURvQnlwQixLQUVaO0tBQ00sSUFITTlLLEtBQUE4SyxRQUdsQi9LLEtBSGtCK0ssUUFHTixPQUFBLDBCQUFaL0ssSUFIcUJsUztLQUdULFNBQUE7S0FITWlkLE1BQUE5Szs7R0FHK0I7WUFHakRpMUIsVUFBVXZyQyxLQUFLb3JDO0lBQ2pCLGdCQURpQkE7U0FJRnp6QyxJQUpFeXpDLE9BQ2JJLG9CQUdvQnJuQyxHQUFLLE9BVnZCbW5DLGNBVVMzekMsR0FBU3dNLEdBQXNCOzs7TUFEcENBLElBSE9pbkM7TUFDYkksb0JBRWdCcjBCLEtBQUssT0FBVCwwQkFBSUEsS0FBVmhULEdBQThCO0lBR3hDO0tBQ2lCc25DLFdBRGpCLHNCQU5ZenJDO0tBT2NxbEMsUUFVZCw0QkFWS29HO0tBQUp0K0I7S0FBSXUrQixhQUFBRDtLQUFTRSxhQUFBdEc7SUFDeEI7ZUFEd0JzRyxZQUVuQixXQTVrQkxuM0MsSUFta0JVd0wsUUFPSzByQyxhQUFKditCO0tBR0gsR0FUTnErQixTQVNlLGdCQVZQeHJDLEtBT2MyckM7TUFLWDtPQUFQQyxPQUFPLDRCQUxXRDtPQU1sQkUsVUFobEJOcjNDLElBbWtCVXdMLEtBWUo0ckMsTUFDaUMsNEJBTnhCRixZQUtURTtPQUxrQnY4QixNQU9JLDRCQVBKczhCO09BQWI5c0IsWUFNTGd0QixTQU5LMStCO01BQUFBLE1BQUEwUjtNQUFJNnNCLGFBQVNDO01BQUFBLGFBQUF0OEI7OztNQVFELElBUkNvZ0IsUUFRRCw0QkFSQ2tjO01BQUFBLGFBQUFsYzs7O0dBVUw7WUFHbkJxYyxNQUFNOXJDLEtBQUtvckMsSUFBSyxPQXBCaEJHLFVBb0JNdnJDLHNCQUFLb3JDLEtBQWlDO1lBQzVDVyxlQUFlL3JDLEtBQVFnc0M7SUFBUSxPQXJCL0JULFVBcUJldnJDLG9CQUFRZ3NDO0dBQTRDO1lBR2pFQyxtQkFBb0J0M0MsR0FBRzBhLEtBQUs2OEI7SUFDOUI7O1lBRHlCNzhCO01BQ2UsV0FBQSxnQkFEbEIxYSxHQUNxQiw0QkFEbEIwYTtNQUNJLEdBQUE7Ozs7SUFESkEsU0FDbEIsNEJBRGtCQTtJQUFLNjhCLFNBRXZCLDRCQUZrQjc4Qjs7R0FFVjtZQUhmODhCLFlBS0V4M0M7SUFDRixJQUFJd1MsMEJBREZ4UztJQUVGLFNBREl3UyxHQUVDO0lBR087S0FBTmtJLFVBQVUsNEJBTFpsSTtLQU1FK2tDLFVBTkYva0M7S0FPRStWO0tBR1UsT0FBQSxnQkFYZHZvQixHQU1JMGE7SUFLRCxHQUFBLHFDQWZINDhCLG1CQUlBdDNDLEdBTUkwYSxLQUNBNjhCOztZQURBNzhCLG1CQUVBNk4sT0FhSixXQXBuQkYxb0IsSUErbEJFRyxNQU9JdTNDO0tBTWEsV0FBQSxnQkFiakJ2M0MsR0FNSTBhO0tBT0MsR0FBQTtNQUNFLDZCQVJIQTs7TUFXWSxJQUFSb0csUUFBUSw0QkFYWnBHLFlBWUEsT0FWQTZOO01BQUFBO1dBdm1CTjFvQixJQStsQkVHLEdBaUJROGdCLE9BQ3dCLDRCQVg1QnkyQixRQVVJejJCO01BckJSdzJCLG1CQUlBdDNDLEdBTUkwYSxLQUNBNjhCOzs7R0FjMEI7WUFHaENFLFlBQVUvNUMsR0FBR3cxQjtJQUFTLE9Bek10QmlpQixjQXlNVXozQyxHQUFHdzFCO0dBQXVEO1lBQ3BFd2tCLFlBQVVoNkMsR0FBRzZ0QjtJQUFTLE9BL0x0QjhwQixjQStMVTMzQyxHQUFHNnRCO0dBQXVEO1lBRXBFb3NCLGtCQUFnQmo2QyxHQUFHZ2QsS0FBSzA1QjtJQUMxQixPQW5PRU8sb0JBa09nQmozQyxHQUFHZ2QsS0FBSzA1QjtHQUNrQztZQUcxRHdELFdBQVc1M0MsR0FBRXdTLEdBQUdWLE1BQU00SSxLQUFLdmIsS0FBSzA0QztJQUNsQyxRQURlcmxDO0tBR1YsSUFDQyxXQWxvQkozUyxJQThuQldHLEdBQVcwYSxLQUFLdmIsTUFJdkI7aUJBQ0csT0FMeUIwNEM7SUFFakI7WUFBQSwwQkFGQy9sQztJQUVELE9BQUE7R0FHQztZQUdoQmdtQyxZQUFZOTNDLEdBQUV3UztJQUNoQixPQVRFb2xDO2FBUVk1M0M7YUFBRXdTOzthQUFBQTthQUMrQixrREFEakN4UyxJQUFFd1M7O0dBQzBEO1lBR3hFdWxDLFlBQVkvM0MsR0FBRXdTO0lBQ2hCLE9BYkVvbEM7YUFZWTUzQzthQUFFd1M7OzthQUMrQixrREFEakN4UyxJQUFFd1M7O0dBQzBEO1lBR3hFK1ksT0FBT3ZyQixHQUFFd1MsR0FBSSxPQWhCYm9sQyxXQWdCTzUzQyxHQUFFd1Msa0JBQUFBLEdBQUZ4UyxHQUE2RDtZQUNwRWt6QixPQUFPbHpCLEdBQUV3UztJQUFJLE9BakJib2xDO2FBaUJPNTNDO2FBQUV3Uzs7YUFBdUMsa0RBQXpDeFMsSUFBRXdTO2FBQUFBO2FBQUZ4UztHQUEwRTtZQUVqRmc0QyxPQUFTbnlDLEtBQVM3RixHQUFHQztJQUN2QixHQURXNEYsU0FBTUMsTUFBTkQsUUFFRTZVLE1BRkk1VSxjQUVKNFU7SUFEYixJQUFJbEksSUFBSixzQkFEb0J4UyxJQUVQL0csSUFBQXloQjtJQUFJO1FBQUp6aEIsTUFEVHVaLEdBQzJCO0tBQWEsR0FBQSxXQUZyQnZTLEdBRVZoSCxHQUFtQyxnQkFGNUIrRyxHQUVQL0csS0FBOEMsV0FBOUNBO0tBQStELElBQS9ENkwsTUFBK0QsNEJBQS9EN0w7S0FBQUEsSUFBQTZMOztHQUNMO1lBR05rVSxLQUFLaFosR0FBR0M7SUFDSixZQVBKKzNDLFVBTUtoNEMsbUJBQ2tCd1AsR0FBSyxPQUFBLFdBRHBCdlAsR0FDZXVQLEdBQVE7Z0JBQ3ZCO1FBQ0h2VztJQUFLLFdBQUssZ0JBSFYrRyxHQUdBL0c7R0FBZTtZQUdwQjhmLFNBQVMvWSxHQUFHQztJQUNkLElBQUl1UywwQkFET3hTLElBRUUvRztJQUNYO1FBRFdBLE1BRFR1WixHQUdHO0tBRUcsSUFFSnRQLE1BRkksV0FOSWpELEdBTUYsZ0JBTkRELEdBRUUvRztRQU1QaUssS0FBaUIsT0FBakJBO0tBRGEsSUFMTjRCLE1BS00sNEJBTE43TDtLQUFBQSxJQUFBNkw7O0dBUVA7WUFHSm16QyxPQUFRdjlCLEtBQUkxYSxHQUFHQztJQUNqQixHQURVeWE7U0FJRG9nQixRQUpDcGdCLFFBQ0dnMkIsUUFHSjVWOztTQUhJNFYsUUFJRCxrREFMRTF3QztRQUNEL0csSUFBQXkzQztJQUFJO1lBQUp6M0MsR0FBa0I7S0FBYSxHQUFBLFdBRDNCZ0gsR0FDSmhILEdBQW1DLGdCQURsQytHLEdBQ0QvRyxLQUE4QyxXQUE5Q0E7S0FBK0QsSUFBL0Q2TCxNQUErRCw0QkFBL0Q3TDtLQUFBQSxJQUFBNkw7O0dBTUw7WUFHTm96QyxjQUFleG5CLE1BQUsxd0I7SUFBSSxPQVZ4Qmk0QyxVQVVvQmo0QyxtQkFBdUJ3UCxHQUFLLFdBQUksV0FBckNraEIsTUFBNEJsaEIsR0FBaUI7R0FBQztZQUU3RDJvQyxPQUFTdHlDLEtBQTJCN0Y7SUFDdEMsR0FEVzZGLFNBQU9DLE1BQVBELFFBQUE2cUIsT0FBTzVxQixjQUFQNHFCO0lBQ0wsWUFISnduQixjQUVTeG5CLE1BQTJCMXdCO2dCQUU1QjtRQUNIL0c7V0FBQUEsTUFBWSxrREFIbUIrRztjQUFBQTtjQXhDcEN1ckIsT0F3Q29DdnJCLEdBR2UsNEJBQTlDL0c7R0FBcUQ7WUFHMURtL0MsZUFBZ0IxbkIsTUFBSzF3QjtJQUFJLE9BM0N6Qmc0QyxVQTJDcUJoNEMsbUJBQXVCd1AsR0FBSyxXQUFJLFdBQXJDa2hCLE1BQTRCbGhCLEdBQWlCO0dBQUM7WUFFOUQ2b0MsT0FBU3h5QyxLQUEyQjdGO0lBQ3RDLEdBRFc2RixTQUFPQyxNQUFQRCxRQUFBNnFCLE9BQU81cUIsY0FBUDRxQjtJQUNMLFlBSEowbkIsZUFFUzFuQixNQUEyQjF3QjtnQkFFNUI7UUFFSHdTO2lCQUFBQSxJQUorQnhTLElBeERwQzgzQyxZQXdEb0M5M0MsR0FJL0J3UztHQUFvQjtZQU16QjhsQyxNQUFRenlDLEtBQTJCN0Y7SUFDckMsR0FEVTZGLFNBQU9DLE1BQVBELFFBQUE2cUIsT0FBTzVxQixjQUFQNHFCO0lBQ1YsSUFBSTV1QixTQUFKLHNCQURxQzlCOzthQUNqQzhCO0tBQ2dDOztPQUFkLFdBRlo0dUIsTUFFaUIsZ0JBRlUxd0I7OztRQUVEO1VBRjFCMHdCLE1BRStCLGdCQUZKMXdCLEdBRU8sNEJBRHhDOEI7O0tBSUksWUFqQk5zMkMsZUFZUTFuQixNQUEyQjF3QjtpQkFNekI7S0FFRCxJQURGMDlCLGtCQUNFLFVBNUJUd2EsY0FvQlF4bkIsTUFBMkIxd0I7O01BU3RCLE1BQUE7S0FDNEIsSUFBL0JxckIsbUJBQStCLE9BQUEsNEJBQS9CQSxNQUhIcVM7S0FHaUMsT0FsdEJ4Qzc5QixJQXdzQm1DRyxHQU81QjA5QixPQUdpQzs7SUFQckMsT0FIZ0MxOUI7R0FVeUI7WUFHNURNLEtBQUtOLEdBQUdDO0lBQ1Y7S0FBSStDLDBCQURHaEQ7S0FFSGtHLE1BQUssMkJBRExsRDtLQUVTLE9BQUEsNEJBRlRBO0tBQ0s7O1NBQ1QvSjs7NEJBRElpTixLQUNKak4sR0FDd0IsV0FKZGdILEdBR1ZoSCxHQUM2QixnQkFKdEIrRyxHQUdQL0c7TUFBQSxXQUFBQTtrQkFBQUE7TUFBQUE7OztJQUdBLE9BQUEsNEJBSklpTjtHQUl5RDtZQUkzRDdGLElBQUlMLEdBQUdDO0lBQ1Q7S0FBSStDLDBCQURFaEQ7S0FFRmtHLE1BQUssMkJBRExsRDtLQUVTLE9BQUEsNEJBRlRBO0tBQ0s7O1NBQ1QvSjs7NEJBRElpTixLQUNKak4sR0FDd0IsV0FKZmdILEdBSWtCLGdCQUpyQkQsR0FHTi9HO01BQUEsV0FBQUE7a0JBQUFBO01BQUFBOzs7SUFHQSxPQUFBLDRCQUpJaU47R0FJeUQ7WUFHM0QrUyxTQUFTdmI7SUFBSSxPQUF5Qjs7bUNBQTdCQTtzQkFBa0N6RSxHQUFLLE9BQUEsZ0JBQXZDeUUsR0FBa0N6RSxHQUFVO0dBQUM7WUFFdERpSixPQUVFeEUsR0FBR3VDO0lBQUssSUFETWQsNEJBQ2R6QixJQURXekU7SUFBWTtnQkFBWkEsSUFBR2tHOztNQUFxQixXQUFBLFdBQ2hDYyxHQURrQyxnQkFDckN2QyxHQURXekU7TUFBd0I7T0FBa0IsSUFBMUM2TCxNQUEwQyw0QkFBMUM3TDtPQUFBQSxJQUFBNkw7Ozs7Ozs7S0FBd0I7O0dBQ0E7WUFHckN2QyxRQUVFN0UsR0FBR3VDO0lBQUssSUFETWQsNEJBQ2R6QixJQURXekU7SUFBWTtnQkFBWkEsTUFBR2tHOzs7O01BQXFCLFdBQUEsV0FDaENjLEdBRGtDLGdCQUNyQ3ZDLEdBRFd6RTtNQUF3QjtPQUFrQixJQUExQzZMLE1BQTBDLDRCQUExQzdMO09BQUFBLElBQUE2TDs7Ozs7OztHQUN3QjtZQUdyQy9FLEtBSUVDLEdBQUdOLE1BQU1PO0lBQUssSUFITWQsNEJBR3BCYSxJQUhXL0csT0FBRXN2QixLQUdWN29CO0lBRkw7UUFEYXpHLE1BQVNrRyxLQUNOLE9BRERvcEI7S0FDd0I7TUFEeEJJLE9BQ3dCLFdBRTVCMW9CLEdBSElzb0IsSUFDOEIsZ0JBRTNDdm9CLEdBSFcvRztNQUFBNkwsTUFDa0IsNEJBRGxCN0w7S0FBQUEsSUFBQTZMO0tBQUV5akIsS0FBQUk7O0dBR2lDO1lBR2hEZSxNQUlFMXBCLEdBQUdOLE1BQU1PO0lBQUssSUFITWQsNEJBR3BCYSxJQUhXL0csT0FBRXN2QixLQUdWN29CO0lBRkw7UUFEYXpHLE1BQVNrRyxLQUNOLE9BRERvcEI7S0FDd0I7TUFEeEJJLE9BQ3dCLFdBRTVCMW9CLEdBSEVoSCxHQUFFc3ZCLElBQ2dDLGdCQUU3Q3ZvQixHQUhXL0c7TUFBQTZMLE1BQ2tCLDRCQURsQjdMO0tBQUFBLElBQUE2TDtLQUFFeWpCLEtBQUFJOztHQUdpQztZQUdoRHZvQixNQUFNSixHQUFHQztJQUNYO0tBQWEsT0FBQSxrREFETEQ7S0FDUjs7U0FBQS9HOztNQUNFLFdBRlNnSCxHQUNYaEgsMEJBRFErRyxHQUNSL0c7TUFDRSxXQURGQTtrQkFBQUE7TUFBQUE7Ozs7R0FFSTtZQUdGbWYsTUFBTXBZLEdBQUdDLEdBQUksT0FBQSw4QkFwQmJGLE1Bb0JNQyxHQUFHQyxHQUE4QjtZQUN2Q29ZLElBQUltQixHQUFFeFosR0FBR0MsR0FBSSxPQUFBLDhCQXJCYkYsTUFxQkl5WixHQUFFeFosR0FBR0MsR0FBOEI7WUFDdkMyWSxRQUFRNVksR0FBSSxPQUFBLDhCQXRCWkQsTUFzQlFDLEdBQTZCO1lBQ3JDOFksUUFBUTlZLEdBQUksT0FBQSw4QkF2QlpELE1BdUJRQyxHQUE2QjtZQUNyQ3VZLFlBQVl2WSxHQUFHTixNQUFNTztJQUFJLE9BQUEsOEJBeEJ6QkYsTUF3QmVMLE1BQU1PLEdBQVREO0dBQW1EO1lBQy9EMFksV0FBVzFZLEdBQUdOLE1BQU1PO0lBQUkseUNBekJ4QkYsTUF5QmNMLE1BQU1PO0lBQUksc0IsOEJBQWJEO0dBQWtEO1lBQzdEb2tCLFVBQVVwa0IsR0FBR0M7SUFBSSxPQUFBLHNDQVpqQkcsT0FZVUosR0FBR0M7R0FBMkM7WUFDeERna0IsTUFBTWprQixHQUFHQztJQUFJLE9BQUEsc0NBYmJHLE9BYU1KLEdBQUdDO0dBQXVDO1lBQ2hEc3RCLE9BQU92dEIsR0FBR0M7SUFBSSxPQUFBLHNDQXJCZHlwQixPQXFCTzFwQixHQUFHQztHQUF3QztZQUNsRHNrQixTQUFTdmtCLEdBQUdDO0lBQUksT0FBQSxzQ0FmaEJHLE9BZVNKLEdBQUdDO0dBQTBDO1lBQ3REdWtCLFFBQVF4a0IsR0FBR0M7SUFBSSxPQUFBLHNDQWhCZkcsT0FnQlFKLEdBQUdDO0dBQXlDO1lBRXBEb2EsSUFJRXJhLEdBQUV3UDtJQUFLLElBSGNyUSw0QkFHckJhLElBSGtCL0c7SUFDcEI7Z0JBRG9CQSxJQUFHa0c7O01BQ1gsV0FBQSwwQkFFUnFRLDBCQUFGeFAsR0FIa0IvRztNQUNSO09BQStDLElBRHZDNkwsTUFDdUMsNEJBRHZDN0w7T0FBQUEsSUFBQTZMOzs7Ozs7O0tBQ1I7O0dBRTRCO1lBR3hDeXpDLEdBQUl4SSxRQUFRQyxhQUFZdHlDO0lBQzFCLE9BQUcsMEJBREdxeUMsUUFBUUM7Y0FBWXR5QztjQVB4QjJjO2dCQU93QjNjLEdBQXBCcXlDO2dCQTVESjF2QztpQkE0RHdCM0M7MEJBSVA4UjtrQkFBSyxPQUFHLDBCQUFSQSxHQUpidWdDOzRCQUFRQzs0QkFJS3hnQztpQkFBbUQ7Z0JBSjVDOVI7R0FLcEI7WUFHSjg2QyxTQUFVekksUUFBUUM7SUFDcEIsR0Fqd0JFajhCLFNBZ3dCVWc4QjtLQUVELE9BQUEsV0F2MEJUUSxzQkF1MEJHO0lBQ0csR0Fud0JOeDhCLFNBZ3dCa0JpOEI7S0FJZixPQUFBO0lBRUcsWUFBQSw2QkFOSUQsUUFBUUM7Z0JBT0YsT0FBQSxXQTUwQmhCTyxzQkE0MEJVO1FBQ0hOO0lBQ0MsT0FBQTthQTkwQlJNO3NCQTgwQmE3eUM7Y0FDVCxPQW5FSndFO3dCQWtFYXhFO2lDQUNXOFI7eUJBQUs7O21EQUZ0QnlnQyxRQUV1RCwwQkFBdEN6Z0M7MERBQUFBO3dCQUFzRDt3QkE5RTlFblA7eUJBNkVhM0M7a0NBRVU4UjswQkFBSzttQ0FIckJ5Z0MsUUFHdUMsMEJBQXZCemdDO3lCQUFzQzt3QkFGaEQ5UjthQUdIO0dBQUU7WUErQlorNkMsYUFBY2xtQyxLQUFJbW1DO0lBQUssT0FBWSxtQkFBckJubUMsS0FBcUIsNEJBQWpCbW1DO0dBQW1DO1lBQ3JEOXRCLFdBQVlyWSxLQUFJN1UsR0FBR3VDO0lBQWlDLFdBdkdwRGdaLFNBdUdnQnZiO0lBQXlCLE9BRHpDKzZDLGFBQ1lsbUMsS0FBNkIsa0NBQXRCdFM7R0FBaUQ7WUF3QnBFMmpCLE9BQU81akIsR0FBR0M7SUFDWixJQUFJdVMsMEJBREt4UyxJQUVML0c7SUFFRjtRQUZFQSxRQURBdVo7S0FFWSxLQUFBLFdBSEp2UyxHQUdNLGdCQUhURCxHQUVML0c7S0FFRiw2QkFGRUE7O09BQUFBLFNBREF1WixHQU1DLE9BUEl4UztJQVNnQjtLQUFBLE9BQUEsNEJBUnJCd1M7S0FRRW1tQyxNQUFNO0lBQ1YsMkJBVk8zNEMsTUFTSDI0QyxRQVBGMS9DO0lBU1ksSUFBVjIvQyxjQVRGMy9DO0lBVUYsNkJBVkVBOztRQUFBQSxRQURBdVo7TUFvQlE7T0FBTnFtQyxRQUFNLDRCQVpORjtPQWFVLE9BQUEsNEJBckJabm1DO2FBVUVvbUMsc0JBVUFDLFFBNTNCSmg1QyxJQTQzQklnNUMsVUFWQUQ7O0tBR00sSUFBSnBwQyxJQUFJLGdCQWRIeFAsR0FFTC9HO0tBYUcsR0FBQSxXQWZLZ0gsR0FjSnVQO01BR0YsZUFSQW1wQyxLQUVBQyxZQUdFcHBDO01BSUYsNkJBUEFvcEM7O0tBUUYsNkJBakJBMy9DOztHQW9CNkQ7WUFJL0Qwd0IsUUFBUTNwQixHQUFHQztJQUNiLElBQUl1UywwQkFETXhTLElBRU4vRztJQUVGO1FBRkVBLFFBREF1WjtLQUVpQixXQUFBLGdCQUhYeFMsR0FFTi9HO0tBQ1ksS0FBQSxXQUhIZ0gsR0FFVGhIO0tBRUYsNkJBRkVBOztPQUFBQSxTQURBdVosR0FNQyxPQVBLeFM7SUFTZTtLQUFBLE9BQUEsNEJBUnJCd1M7S0FRRW1tQyxNQUFNO0lBQ1YsMkJBVlEzNEMsTUFTSjI0QyxRQVBGMS9DO0lBU1ksSUFBVjIvQyxjQVRGMy9DO0lBVUYsNkJBVkVBOztRQUFBQSxRQURBdVo7TUFvQlE7T0FBTnFtQyxRQUFNLDRCQVpORjtPQWFVLE9BQUEsNEJBckJabm1DO2FBVUVvbUMsc0JBVUFDLFFBdDVCSmg1QyxJQXM1QklnNUMsVUFWQUQ7O0tBR00sSUFBSnBwQyxJQUFJLGdCQWRGeFAsR0FFTi9HO0tBYUcsR0FBQSxXQWZNZ0gsR0FFVGhILE1BWUl1VztNQUdGLGVBUkFtcEMsS0FFQUMsWUFHRXBwQztNQUlGLDZCQVBBb3BDOztLQVFGLDZCQWpCQTMvQzs7R0FvQjZEO1lBRy9ENi9DLFlBQVlwN0MsR0FBRzZ0QjtJQUNqQixPQW5TRW1zQixZQWtTWWg2QyxHQUFHNnRCO2tCQXBSZnVzQixZQW9SWXA2Qyx5QkFBRzZ0Qjs7R0FDeUQ7WUFHeEV3dEIsc0JBQXNCcjdDLEdBQUc2dEI7SUFDM0IsT0F2U0Vtc0IsWUFzU3NCaDZDLEdBQUc2dEI7Y0F4UnpCdXNCLFlBd1JzQnA2Qyx5QkFBRzZ0QjtjQUFIN3RCO0dBQ3dDO1lBRzlEczdDLGdCQUFnQnQ3QyxHQUFHNnRCO0lBQ2YsWUFUSnV0QixZQVFnQnA3QyxHQUFHNnRCO2dCQUdYLE9BQUEsV0F6OEJSNXRCLG1CQXM4QmdCRCxHQUFHNnRCO1FBRWRsZ0I7SUFBTyxPQUFQQTtHQUMwRDtZQUcvRDR0QyxZQUFZdjdDLEdBQUd3MUI7SUFDakIsT0FsVEV1a0IsWUFpVFkvNUMsR0FBR3cxQjtrQkE5UmY2a0IsWUE4UllyNkMseUJBQUd3MUI7O0dBQ3lEO1lBR3hFZ21CLHNCQUFzQng3QyxHQUFHdzFCO0lBQzNCLE9BdFRFdWtCLFlBcVRzQi81QyxHQUFHdzFCO2NBbFN6QjZrQixZQWtTc0JyNkMseUJBQUd3MUI7Y0FBSHgxQjtHQUN3QztZQUc5RHk3QyxnQkFBZ0J6N0MsR0FBR3cxQjtJQUNmLFlBVEorbEIsWUFRZ0J2N0MsR0FBR3cxQjtnQkFHWCxPQUFBLFdBdjlCUnYxQixtQkFvOUJnQkQsR0FBR3cxQjtRQUVkN25CO0lBQU8sT0FBUEE7R0FDMEQ7WUFPN0QrdEMsUUFBUWgyQyxHQUFFQztJQUFJLDZCQUFORCw0QkFBRUMsS0FBRkQsSUFBRUM7R0FBeUM7WUFFbkRnMkMsU0FBUy8wQztJQUNYLEtBRFdBLE1BRUg7UUFDR25CLE9BSEFtQixTQUdUbzVCLFFBSFNwNUI7SUFHUSxPQUFBLDBCQUFSbkIsTUFBVHU2QixPQUxBMGI7R0FLc0Q7WUFNdERFLHFCQUF1QnJnRCxHQUFXLE9BQVhBLEVBQVk7WUFDbkNzZ0QsZUFBZXY1QyxHQUFFL0c7SUFBSSxXQUFBLGtEQUFOK0csSUFBRS9HO0lBQUksT0FBQTtHQUFnQjtZQUVqQ3VnRCw0QkFBNEJwMkMsR0FBRUMsR0FBR28yQyxTQUFTQyxTQUFTQztJQUN6RCxJQUR5REMsZUFBQUQ7SUFDekQ7UUFEZ0RELFdBQVNFLGNBRXBELE9BRjJDRjs7b0NBQVpyMkMsR0FLWixXQUxlbzJDLFNBQUhwMkMsR0FBcUJ1MkM7b0NBQXZCeDJDLEdBSVYsV0FKZXEyQyxTQUFMcjJDLEdBQXVCdzJDO0tBR2pELEtBQUEsdUNBSUgsT0FQb0RBO0tBTVUsSUFOVkMsZUFNVSw0QkFOVkQ7S0FBQUEsZUFBQUM7O0dBTzFDO1lBR2JDLHVCQUF1QjEyQyxHQUFFQyxHQUFHbzJDO0lBQ2hCO0tBQVZDO09BQVU7aURBRFd0MkMsMEJBQUVDO0lBRTNCLE9BWk1tMkMsNEJBVW1CcDJDLEdBQUVDLEdBQUdvMkMsU0FDMUJDO0dBQzJEO1lBR3pESywyQkFBMkJyYyxPQUFNcDVCLE1BQU1tMUMsU0FBU0M7SUFDdEQsSUFEaUNNLFVBQUF0YyxPQUFNbjVCLFNBQUFELE1BQWUyMUMsWUFBQVA7SUFDdEQ7VUFEdUNuMUMsUUFFL0IsT0FGOEMwMUM7S0FPbEQ7TUFQbUM5MkMsT0FBQW9CO01BQU5vNUIsU0FBTXA1QjtNQUFlMjFDO1FBZmhEViw0QkFlMkJRLFNBQUFyYyxRQUFZOGIsU0FBU1E7S0FBckJELFVBQUFyYztLQUFNcDVCLFNBQUFwQjtLQUFlODJDLFlBQUFDOztHQVNJO1lBR3hEQyxzQkFBc0I3MUMsTUFBTW0xQztJQUM5QixLQUR3Qm4xQyxNQUVoQjtJQWNlO0tBYlpuQixPQUhhbUI7S0FHdEJvNUIsUUFIc0JwNUI7S0FnQmxCbzFDLFVBQWlCLHNCQXZEckJMLFNBdUNzQi8wQztJQWlCdEIsT0E3Qkl5MUMsMkJBZUpyYyxPQUFTdjZCLE1BSG1CczJDLFNBZ0J4QkM7R0FDbUQ7WUFNdkRVLGdCQUFnQmgzQyxHQUFFQyxHQUFHbzJDLFNBQVNocEI7SUFDdEIsSUFBTnR4QixNQXpDRjI2Qyx1QkF3Q2dCMTJDLEdBQUVDLEdBQUdvMkM7SUFJdkIsT0FBQSxXQUpnQ2hwQixNQWhFOUIyb0IsUUFnRWdCaDJDLEdBQUVDLElBQ2hCbEU7R0FHa0I7WUFHcEJrN0MsZUFBZS8xQyxNQUFNbTFDLFNBQVNocEI7SUFDaEMsS0FEaUJuc0IsTUFFVDtJQUlFO0tBSENuQixPQUhNbUI7S0FHZm81QixRQUhlcDVCO0tBTVg1RyxJQTNFSjI3QyxTQXFFZS8wQztLQU9YbzFDLFVBQUosc0JBREloOEM7SUFFSixTQURJZzhDLFNBRUM7SUFLRCxJQUhFdjZDLE1BckRGNDZDLDJCQTZDSnJjLE9BQVN2NkIsTUFIWXMyQyxTQU9qQkM7SUFTRixPQUFBLFdBaEI0QmpwQixNQU0xQi95QixHQUtFeUI7R0FLTztZQU9ibTdDLGNBQWNoMkM7SUFBTyxPQXZCckIrMUMsZUF1QmMvMUMsTUFuRmRnMUMsZUF2VEYvdEI7R0EwWThFO1lBQzVFZ3ZCLGNBQWNqMkM7SUFBTyxPQXhCckIrMUMsZUF3QmMvMUMsTUFuRmRpMUMsZ0JBdlRGcm1CO0dBMFkrRTtZQUM3RXNuQixlQUFlcDNDLEdBQUVDO0lBQUksT0FoQ3JCKzJDLGdCQWdDZWgzQyxHQUFFQyxHQXJGakJpMkMsZUF2VEYvdEI7R0E0WThFO1lBQzVFa3ZCLGVBQWVyM0MsR0FBRUM7SUFBSSxPQWpDckIrMkMsZ0JBaUNlaDNDLEdBQUVDLEdBckZqQmsyQyxnQkF2VEZybUI7R0E0WStFO1lBQzdFd25CLHFCQUFxQnAyQztJQUFPLE9BekQ1QjYxQyxzQkF5RHFCNzFDLE1BdkZyQmcxQztHQXVGNkU7WUFDN0VxQixxQkFBcUJyMkM7SUFBTyxPQTFENUI2MUMsc0JBMERxQjcxQyxNQXZGckJpMUM7R0F1RjhFO1lBQzlFcUIsc0JBQXNCeDNDLEdBQUVDO0lBQUksT0E1RTVCeTJDLHVCQTRFc0IxMkMsR0FBRUMsR0F6RnhCaTJDO0dBeUY2RTtZQUM3RXVCLHNCQUFzQnozQyxHQUFFQztJQUFJLE9BN0U1QnkyQyx1QkE2RXNCMTJDLEdBQUVDLEdBekZ4QmsyQztHQXlGOEU7WUF3QmhGbnZDLEdBQUcrQixLQUFJNG9CO0lBQVMsT0FBQSwrQkFBYjVvQixVQUFJNG9CO0dBQTRDO1lBQ25EK2xCLFFBQVF0ckMsR0FBSSxPQUFBLG9CQUFKQSxHQUFZO1lBRXBCdXJDLGFBQWEvM0M7SUFDZjtLQUFxQixPQUFBLHlCQUROQTtLQUNYaEQsSUFBSTtJQUNSO3FCQUZlZ0QsWUFFTS9KLEdBQUV1VyxHQUFLLE9BQUEsZUFEeEJ4UCxHQUNpQi9HLEdBQUV1VyxHQUFvQjtJQUEzQyxPQUFBLDRCQURJeFA7R0FFd0Q7WUFNeERnN0M7SUFBb0NDLGtCQUFpQkMsYUFBWXJ1QztJQUNuRTtLQUFJc3VDO09BQ0M7NkJBRmlDRixpQ0FBaUJDO1VBQWpCRDtrQkFBaUJDLGFBQUFBLGNBQWpCRDtLQU1sQ3ZwQixNQUFNO0tBQ04wcEIsT0FBTzthQU5QRDtJQU9XO2lCQUNMLFdBSE56cEI7U0FJa0IxdUIsZ0NBQVRxNEMsaUJBQVJDO3FCQVY4RHp1QztVQVd4RDBCLElBRE4rc0MsUUFDRzlyQixJQUdhLDBCQUpSNnJCOztNQUdNLElBRlhFLE1BRVcsMEJBSGRELFNBQ00vc0MsSUFERThzQyxNQUNMN3JCLElBQUErckI7S0FLRCwyQkFWSDdwQixLQUtJbEMsT0FBQUE7S0FLc0IsV0FBQSwwQkFMbkJqaEI7S0FLYSxvQkFUcEI2c0M7S0FxQmEsV0FBQSwwQkFqQk43c0M7S0FpQkwsaUJBdEJGbWpCLEtBS0lsQyxPQUFBQTtLQWtCSSxXQUFBLDBCQWxCRGpoQjtLQWtCTCxpQkF0QkY2c0M7YUFHa0JwNEM7O0lBY007S0FBQSxPQUFBOzs7OztTQUFiLG1DQXZCWG00Qzs7OEJBcUJpQiw2QkFaUkU7S0FXRiwyQkFBWSw2QkFYbEJDO0tBU0csT0FBQTtJQUFBLE9BQUE7R0FhYTtZQUduQkUsV0FBWVAsa0JBQWtCQztJQUMxQjtLQUNKNXJEO09BckNBMHJEO1NBbUNZQyxrQkFBa0JDO2FBRTlCNXJELE1BQWdCLE9BQWhCQTtRQUNHbXNELGVBREhuc0Q7SUFFQTtxQkFDT3NzQzthQUdGO2NBQUk4ZjtjQUNBQztnQkFwWFhqeUI7a0JBZ1hTa1M7OzJCQUsyQjNpQyxHQUFFdWYsS0FBSWhKO21CQUMvQjtvQkFBb0IsT0FBQSwwQkFEV0E7b0JBRzdCZ0QscUJBVlJpcEM7aUNBVVFqcEM7NkJBSHlCZ0c7OEJBS3pCO2lEQVBGa2pDO3FDQUV5QnppRCxHQU1uQiwwQkFISnVaLEtBSHlCZ0c7a0JBTU87YUFFdEMsS0FUSW1qQyxXQVVJLE9BZE4vZjthQXVDYztjQURWZ2dCLGlDQXRDSmhnQjtjQXVDSWlnQjtnQkFBVSw0QkFEVkQsVUFuQ0ZGO2NBcUNFNWYsTUFBTSwyQkFETitmO2NBRVNDLGFBSFRGO2NBR2tCRyxpQkFGbEJGO3NCQW5DRkY7OztlQXdDRSwyQkE1Q0ovZixRQXdDSUUsUUFDU2dnQjtlQW9CYixPQUFBLDRCQXJCSWhnQjs7Y0FTVTtlQUpha2dCOztlQUFqQkM7ZUFBTEM7ZUFJUyxPQUFBLDRCQVJESixZQUlSSTtlQUlHLzhDLE1BQU07ZUFFTjQ4QixVQUFVLDRCQVZJZ2dCLGdCQVFkNThDO2VBSTRCLE9BQUEsNEJBUi9CKzhDO2NBUUQsMkJBckRKdGdCLFdBd0NJRSxLQVdJQyxTQUZBNThCO2NBTVUsSUFBVmc5QyxpQkFBVSw0QkFKVnBnQjtjQUtKLGVBaEJBRCxLQWVJcWdCLGdCQTVEZWpCO2NBOERuQjtnQkFqQkFwZjtnQkFpQmMsNEJBRlZxZ0I7Z0JBVkVGO2NBSkdILGFBSVJJO2NBSmlCSCxpQkFjZEk7c0JBVm1CSDs7WUFpQm1DO0dBQUM7WUFHdEVJLGVBQWdCbkIsa0JBQWtCQztJQUNwQixXQXZFZE0sV0FzRWdCUCxrQkFBa0JDO0lBQ3BDLE9BQUEsV0Evc0NBM0ssT0Erc0NBO0dBQW9FO1lBR2xFOEwsT0FBUVosY0FBY1A7SUFLeEI7dUNBTFVPO0tBS05SO09BR2EseUNBQUt6ckMsR0FBSyxXQUFMQSxHQUFBQSxHQUFTO0lBRS9CLE9BZEU0c0MsZUFTRW5CLGtCQUxvQkM7R0FVcUI7WUFvQjNDb0IsYUFBY3JCLGtCQUFrQkM7SUFDNUI7S0FDSjVyRDtPQTdJQTByRDtTQTJJY0Msa0JBQWtCQzthQUVoQzVyRCxNQUFnQixPQUFoQkE7UUFDR21zRCxlQURIbnNEO0lBRUE7cUJBQ09zc0M7YUFlRixJQUNlM2lDLE9BQUVzakQscUJBRGJDO2FBRUE7dUNBakJGNWdCLFFBZ0JhM2lDOytCQUFFc2pEO2VBeEJSO2dCQUFBLE9BQUEsZ0JBUVAzZ0IsS0FnQmEzaUM7Z0JBSUx3akQ7a0JBNUJaLGdDQUc2QnZCOzs7O21CQXlCakJ1QjtjQUNKO2VBTGtCamtDOytCQUlkaWtDLFdBTE5ELGtCQUNXdmpELEdBRFh1akQ7ZUFDVzEzQyxNQU1QLDRCQU5PN0w7Y0FBQUEsSUFBQTZMO2NBQUV5M0MsU0FJUEU7Y0FMTkQsY0FDb0Joa0M7O2FBY3hCLEtBZklna0MsYUFnQkksT0EvQk41Z0I7YUFpQ3FDO2NBRDlCOGdCLGdCQWpCTEY7Y0FpQkZodkIsTUFqQkVndkI7Y0FrQm1DLE9BQUEseUJBbEJuQ0E7Y0FrQnFCO2dCQUFBLGtEQWpDdkI1Z0I7Y0FpQ0lFLE1BQU07c0JBQ0YxdEI7O2VBQUswdEM7ZUFBU0M7Ozs7Z0JBR2xCLE9BQUEsMkJBckNKbmdCLFFBaUNJRSxRQUNTZ2dCO2VBUUM7Z0JBSkhVO2dCQUFQTjtnQkFJVSxPQUFBLDRCQVJESixZQUlUSTtnQkFJSS84QyxNQUFNO2dCQUVONDhCLFVBQVUsNEJBVklnZ0IsZ0JBUWQ1OEM7Z0JBSTRCLE9BQUEsNEJBUmhDKzhDO2VBUUEsMkJBOUNKdGdCLFdBaUNJRSxLQVdJQyxTQUZBNThCO2VBTVU7Z0JBQVZnOUMsaUJBQVUsNEJBSlZwZ0I7Z0JBUStCO2tCQUFBO29CQXBEdkNILEtBb0Q0Qyw0QkFkeENzZ0I7Z0JBY3VCLE9BQUE7Z0JBRWxCMXBDLHFCQXhEYmlwQzs7eUJBd0RhanBDO3FCQURNO3NCQXJEZm9wQixLQXFEb0IsNEJBZmhCc2dCO3FCQWdCVSwwQkFBTDFwQztlQUxMLGVBaEJBc3BCLEtBZUlxZ0I7ZUFkS0wsYUFJVEk7ZUFKa0JILGlCQWNkSTt5QkFWR0s7Ozs7ZUFOWGh2QjtpQkEwQlMsa0RBMURUb087Y0FrQ1F4dEI7c0NBbENSd3RCO3FDQWlDSUU7Z0JBbEJGMGdCOztjQW1CTXB1QztnQkErQkQsa0RBakVQd3RCO3FDQWlDSUU7Z0JBREc0Z0I7YUFpQ0wsT0FBQSw0QkFoQ0U1Z0I7WUFpQzBEO0dBQUM7WUFHdEU2Z0IsaUJBQWtCMUIsa0JBQWtCQztJQUN0QixXQTNFZG9CLGFBMEVrQnJCLGtCQUFrQkM7SUFDdEMsT0FBQSxXQTN6Q0EzSyxPQTJ6Q0E7R0FBc0U7WUFHcEVxTSxTQUFVMUIsYUFBYyxPQUp4QnlCLG9CQUlVekIsYUFBZ0U7WUFFMUUyQix1QkFBdUJ4eEMsS0FBSzZ2QyxhQUFZeGdDO0lBQzFDLElBQWE0dUIsTUFHUiw0QkFKcUM1dUIsU0FDN0J2USxJQUFBbS9CLEtBQUV3VDtJQUNiO2FBRFczeUM7TUFDYSxXQUFBLGdCQUZEa0IsS0FDWmxCO01BQ0MsS0FBQSxnQ0FGZ0Ird0M7T0FFMkM7UUFEMUQ2QixRQUMwRCw0QkFEMUREO1FBQUZuVCxNQUNvRCw0QkFEcER4L0I7T0FBQUEsSUFBQXcvQjtPQUFFbVQsTUFBQUM7Ozs7S0FDb0MsT0FEcENEOztHQUdDO1lBY2RFLHFCQUFxQjN4QyxLQUFLNnZDLGFBQVlqaUQ7SSx1QkFDekI7SUFFQyxXQUFBLGdCQUhPb1MsS0FBaUJwUztJQUduQyxPQUFBLGdDQUh1QmlpRDs7OztZQU0xQitCLGNBQWM1eEMsS0FBSzZ2QyxhQUFZeGdDO0lBQ2pDO0tBQVUsT0F6QlJtaUMsdUJBd0JjeHhDLEtBQUs2dkMsYUFBWXhnQztLQUM3QndpQyxZQUFNO0tBQ1ksT0FBQSxnQkFGTjd4QyxLQUFpQnFQO0tBRXRCLFFBQUEsZ0NBRlV3Z0M7V0FDakJnQztHQUlzQjtZQUd4QkMsWUFBWTl4QyxLQUFJcVAsS0FBSTBpQztJQUN0QjtrQ0FEYy94QyxRQUFJcVA7cUJBQUFBO2tCQUNtQixXQW4yQ3JDL2MsbUJBazJDc0J5L0M7R0FDZ0U7WUFHcEZDLGlCQUFpQmh5QyxLQUFLNnZDLGFBQVl4Z0M7SUFKbEN5aUMsWUFJaUI5eEMsS0FBaUJxUDt5QkFabEN1aUMsY0FZaUI1eEMsS0FBSzZ2QyxhQUFZeGdDO0dBSU47WUFHNUI0aUMsZ0JBQWdCanlDLEtBQUs2dkMsYUFBWXhnQztJQVhqQ3lpQyxZQVdnQjl4QyxLQUFpQnFQO3lCQW5CakN1aUMsY0FtQmdCNXhDLEtBQUs2dkMsYUFBWXhnQztHQUlKO1lBRzdCNmlDLGdCQUFnQmx5QyxLQUFLNnZDLGFBQVl4Z0M7SUFsQmpDeWlDLFlBa0JnQjl4QyxLQUFpQnFQOzBCQTFCakN1aUMsY0EwQmdCNXhDLEtBQUs2dkMsYUFBWXhnQztHQUlKO1lBRzdCOGlDLGFBQVdueUMsS0FBSzZ2QyxhQUVMeGdDLEtBRnFCb0I7SUF6QmhDcWhDLFlBeUJXOXhDLEtBRUFxUDtJQWFKO0tBYk0raUMsV0FuQ2JSLGNBaUNXNXhDLEtBQUs2dkMsYUFFTHhnQztLQUFBemhCLElBQUF5aEI7S0FBRTZoQyxTQUFBa0I7SUFDYjtRQURXL2lDLE9BQUF6aEI7Z0NBQUVzakQ7O09BS0MsV0FBQSxnQkFQSGx4QyxLQUVBcFM7T0FLUixHQUFBLGdDQVA2QjZpQixTQVEzQixXQU5NN2lCOzs7S0FRRCxJQVJDNkwsTUFRRCw0QkFSQzdMO1FBU1Qsc0JBWFNvUyxRQUVBdkcsS0FVSjtLQUNPLElBWEQyM0MsV0F6Q2JPLHFCQXVDVzN4QyxLQUFLNnZDLGFBRUxwMkMsS0FBRXkzQztLQUFGdGpELElBQUE2TDtLQUFFeTNDLFNBQUFFOztHQWE4QjtZQUczQ2lCLGlCQUFlcnlDLEtBQUs2dkMsYUFBWXhnQyxLQUFJb0I7SUFDaEMsWUFuQkowaEMsYUFrQmVueUMsS0FBSzZ2QyxhQUFZeGdDLEtBQUlvQjtrQkFXL0JnZixrQkFBTyxPQUFQQTtJQUxBOzhCQUdVLDZCQVRxQmhmOzZCQVF0Qiw2QkFSa0JwQjs7OzZCQU9WLDZCQVBGd2dDOztLQU1mLHdCQUFTLFdBbjRDZHB4QyxXQTYzQ2V1QjtJQUliLE9BQUE7YUFoNUNKa3NCO2FBZzVDSTtHQU9hO1lBR2ZvbUIsUUFBTXR5QyxLQUFLNnZDLGFBQVlwL0I7SUFBTyxPQWhDOUIwaEMsYUFnQ01ueUMsS0FBSzZ2QyxnQkFBWXAvQjtHQUF5QztZQUNoRThoQyxZQUFVdnlDLEtBQUs2dkMsYUFBWXAvQjtJQUFPLE9BZmxDNGhDLGlCQWVVcnlDLEtBQUs2dkMsZ0JBQVlwL0I7R0FBNkM7WUFFeEUraEMsY0FBWXh5QyxLQUFLNnZDLGFBT0p4Z0MsS0FQb0JvQjtJQTVEakNxaEMsWUE0RFk5eEMsS0FPQ3FQO0lBSFosR0FBQSwwQkFKZ0NvQixRQUFoQm8vQixjQUtkO1FBRVVwZ0IsUUFBQXBnQjtJQUNYO1lBRFdvZ0IsT0FFTjtLQUVnQixJQUFmZ2pCLGVBdkdSakIsdUJBNEZZeHhDLEtBQUs2dkMsYUFPSnBnQjtLQUtOLFNBQUEsNkJBRENnakI7TUFDb0MsVUFBQSxnQkFaaEN6eUMsS0FPQ3l2QjtNQUtvQixHQUFBLCtCQVpBaGYsU0FheEIsV0FOSWdmOztLQU9FO01BQUEsT0FBQSw0QkFQRkEsT0FJTGdqQjtNQUpLcE4sUUFPQztLQVBENVYsUUFBQTRWOztHQVNKO1lBR1RxTixrQkFBZ0IxeUMsS0FBSzZ2QyxhQUFZeGdDLEtBQUlvQjtJQUNqQyxZQXBCSitoQyxjQW1CZ0J4eUMsS0FBSzZ2QyxhQUFZeGdDLEtBQUlvQjtrQkFXaENnZixrQkFBTyxPQUFQQTtJQUxBOytCQUdVLDZCQVRzQmhmOzhCQVF2Qiw2QkFSbUJwQjs7OytCQU9YLDZCQVBEd2dDOztLQU1oQix5QkFBUyxXQXY2Q2RweEMsV0FpNkNnQnVCO0lBSWQsT0FBQTthQXA3Q0prc0I7YUFvN0NJO0dBT2E7WUFHZnltQixTQUFPM3lDLEtBQUs2dkMsYUFBWXAvQjtJQUMxQixPQXozQ0EvSCxTQXczQ1MxSTs7Y0FqQ1B3eUM7ZUFpQ094eUM7ZUFBSzZ2QztlQUM4QyxrREFEbkQ3dkM7ZUFBaUJ5UTtHQUN1RDtZQUcvRW1pQyxhQUFXNXlDLEtBQUs2dkMsYUFBWXAvQjtJQUM5QixPQW5CRWlpQzthQWtCVzF5QzthQUFLNnZDO2FBQ2Usa0RBRHBCN3ZDO2FBQWlCeVE7R0FDd0I7WUFLcERvaUMsWUFBVTd5QyxLQUFLNnZDLGFBQWF6RTtJQUM5QixnQkFEOEJBO1NBSWZ6ekMsSUFKZXl6QyxPQUMxQkksb0JBR29Ccm5DLEdBQUssT0E1MkJ6Qm1uQyxjQTQyQlczekMsR0FBU3dNLEdBQXNCOzs7TUFEcENBLElBSG9CaW5DO01BQzFCSSxvQkFFZ0JyMEIsS0FBSyxPQUFULDBCQUFJQSxLQUFWaFQsR0FBOEI7SUFHeEM7S0FBSXJRLE1BQUosc0JBTllrTTtLQU9DbU47S0FBSStqQztLQUFPekY7S0FBU3A4QjtJQUMvQjtRQUQrQkEsUUFEN0J2YjtNQUdZOzs7VUE5NkNoQlUsSUFxNkNZd0wsS0FPWXlyQyxVQUVvQiw0QkFIeEMzM0MsS0FDb0IyM0M7VUFBWHQrQjtNQUVHLE9BQUE7O0tBRUM7TUFBVGlrQyxXQWhJTk8scUJBcUhVM3hDLEtBQUs2dkMsYUFPZ0J4Z0MsS0FBaEI2aEM7TUFLYixxQkFESUU7S0FJRCxVQWRINUYsU0FjWSxnQkFmSnhyQyxLQU9xQnFQO01BVWI7T0FBVnc4QjtTQXQ3Q1ZyM0MsSUFxNkNZd0wsS0FPWXlyQyxVQVV1Qiw0QkFWZHA4QixLQUFUbzhCO09BQVNoYyxRQVdZLDRCQVhacGdCO09BQVRzOEIsYUFXVyw0QkFYRnQ4QjtPQUFwQndQLFlBVUhndEIsU0FWRzErQjtNQUFBQSxNQUFBMFI7TUFBSXF5QixTQUlURTtNQUpnQjNGLFdBQUFFO01BQVN0OEIsTUFBQW9nQjs7O0tBWUMsSUFaRDRWLFFBWUMsNEJBWkRoMkI7S0FBaEI2aEMsU0FJVEU7S0FKeUIvaEMsTUFBQWcyQjs7R0FjYjtZQUdsQnlOLFFBQU05eUMsS0FBS29yQztJQUF1QiwyQkFBdkJBO0lBQUsscUIsT0F4QmhCeUgsWUF3Qk03eUM7R0FBc0M7WUFDNUMreUMsaUJBQWUveUMsS0FBUWdzQztJQUEwQix5QkFBMUJBO0lBQVEscUIsT0F6Qi9CNkcsWUF5QmU3eUM7R0FBb0Q7WUFFbkVnekMsU0FBU2h6QyxLQUFJcVA7SUFDZjtLQUFzRCxNQUFBLGtEQUQzQ3JQLE1BQUlxUDtLQUNzQyxNQUFBO0tBQTVCLE1BajhDekI3YSxJQWc4Q1d3TCxLQUMyQiw0QkFEdkJxUDtJQUNmLFdBajhDQTdhLElBZzhDV3dMLFFBQUlxUDtHQUM0RDtZQUd6RTRqQyxVQUFRanpDLEtBQUtvckMsSUFBSXlFO0lBQ1IsVUE5RVR5QyxRQTZFUXR5QyxLQUFTNnZDLGFBQUp6RTtJQUMyQixPQUFBOzRDQUFLbm5ELEdBQUssT0FMbEQrdUQsU0FJUWh6QyxLQUNxQy9iLEdBQW1CO0dBQUM7WUFHakVpdkQsVUFBUWx6QyxLQUFLb3JDLElBQUl5RTtJQUNSLFVBOUNUOEMsU0E2Q1EzeUMsS0FBUzZ2QyxhQUFKekU7SUFDNEIsT0FBQTs0Q0FBS25uRCxHQUFLLE9BVG5EK3VELFNBUVFoekMsS0FDc0MvYixHQUFtQjtHQUFDO1lBR2xFa3ZELGNBQVluekMsS0FBS29yQyxJQUFJeUU7SUFBYyxPQVpuQ21ELFNBWVloekMsS0FwRlp1eUMsWUFvRll2eUMsS0FBUzZ2QyxhQUFKekU7R0FBOEQ7WUFDL0VnSSxjQUFZcHpDLEtBQUtvckMsSUFBSXlFO0lBQWMsT0FibkNtRCxTQWFZaHpDLEtBOUNaNHlDLGFBOENZNXlDLEtBQVM2dkMsYUFBSnpFO0dBQStEO1lBSWhGaUksc0JBQXVCaHVCLE1BQU13cUIsYUFBWWw3QztJQUMzQyxPQXh5QkFpNEM7O2FBdXlCMkNqNEM7c0JBQzFCL0csR0FBRXVXO2NBQ1osY0FBQSxXQUZrQmtoQixNQUNObGhCO2NBQ1o7OztlQUNGLFVBbEpINnRDLGlCQStJeUNyOUMsR0FBWms3QyxhQUNkamlEO2VBRVosVUFGTCxPQXpJRXFrRCxnQkF3SXlDdDlDLEdBQVprN0MsYUFDZGppRDs7O2NBQ1Y7YUFFOEI7R0FBQztZQUdwQzBsRCx1QkFBd0JqdUIsTUFBTXdxQixhQUFZbDdDO0lBQzVDLE9BeDBCQWc0Qzs7YUF1MEI0Q2g0QztzQkFDM0IvRyxHQUFFdVc7Y0FDWixjQUFBLFdBRm1Ca2hCLE1BQ1BsaEI7Y0FDWjs7O2VBQ0YsVUF6Skg2dEMsaUJBc0owQ3I5QyxHQUFaazdDLGFBQ2ZqaUQ7ZUFFWixVQUZMLE9BaEpFcWtELGdCQStJMEN0OUMsR0FBWms3QyxhQUNmamlEOzs7Y0FDVjthQUU4QjtHQUFDO1lBR3BDMmxELGVBQWlCLzRDLEtBQTJCN0YsR0FBR2s3QztJQUNqRCxHQURtQnIxQyxTQUFPQyxNQUFQRCxRQUFBNnFCLE9BQU81cUIsY0FBUDRxQjtJQUNiLFlBZkpndUIsc0JBY2lCaHVCLE1BQThCd3FCLGFBQUhsN0M7Z0JBRXBDO1FBQ0gvRztXQUFBQSxNQUFZLGtEQUgyQitHO2NBQUFBO2NBajFCOUN1ckIsT0FpMUI4Q3ZyQixHQUdPLDRCQUE5Qy9HO0dBQXFEO1lBRzFENGxELGVBQWlCaDVDLEtBQTJCN0YsR0FBR2s3QztJQUNqRCxHQURtQnIxQyxTQUFPQyxNQUFQRCxRQUFBNnFCLE9BQU81cUIsY0FBUDRxQjtJQUNiLFlBZEppdUIsdUJBYWlCanVCLE1BQThCd3FCLGFBQUhsN0M7Z0JBRXBDO1FBRUh3UztpQkFBQUEsSUFKdUN4UyxJQS8xQjlDODNDLFlBKzFCOEM5M0MsR0FJdkN3UztHQUFvQjtZQU16QnNzQyxjQUFnQmo1QyxLQUEyQjdGLEdBQUdrN0M7SUFDaEQsR0FEa0JyMUMsU0FBT0MsTUFBUEQsUUFBQTZxQixPQUFPNXFCLGNBQVA0cUI7SUFDbEIsSUFBSTV1QixTQUFKLHNCQUQ2QzlCOzthQUN6QzhCO0tBRWdDOztPQUFkLFdBSEo0dUIsTUFHUyxnQkFIa0Ixd0I7OztRQUdUO1VBSGxCMHdCLE1BR3VCLGdCQUhJMXdCLEdBR0QsNEJBRnhDOEI7O0tBS0ksWUE3Qk42OEMsdUJBdUJnQmp1QixNQUE4QndxQixhQUFIbDdDO2lCQU9qQztLQUVEO01BREYwOUI7TUFDRSxVQXZDVGdoQixzQkE4QmdCaHVCLE1BQThCd3FCLGFBQUhsN0M7O01BVTlCLE1BQUE7S0FDNEIsSUFBL0JxckIsbUJBQStCLE1BQUEsNEJBQS9CQSxNQUhIcVM7S0FHaUMsT0ExL0MxQzc5QixJQSsrQzZDRyxHQVFwQzA5QixPQUdpQzs7SUFQckMsT0FKd0MxOUI7R0FXaUI7WUFTOUQrK0MsVUFBUS8rQyxHQUFHazVCLEtBQUtDO0lBQU8sVUFBQSxnQ0FBWkQsS0FBSGw1QjtJQUFlLDZDQUFmQSxHQUFRbTVCO0dBQTRCO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBRyxnQ0FBakJ3USxHQUFHdlE7Y0FBQUE7Y0FBdUMsZ0NBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEZ3dkQsWUFBVWgvQyxHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxnQ0FEUUMsS0FBS0Q7S0FFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6Qnl2RCxRQUFNai9DLEdBQUd2USxLQUFLRDtJQUNoQixLQUFHLGdDQURRQyxLQUFLRDtLQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NEJBQWlDLFdBcmlEcENzYSxXQStoRFl0YTtLQU1ULHVCQUFTLFdBcmlEWnNhLFdBK2hET3JhO0tBSVAsTUFBQTtJQUFBLE9BQUE7R0FHaUM7WUFRakN5dkQsU0FBU3I1QyxLQUF1QjJyQztJQUFVLEdBQWpDM3JDO1NBQWlCQyxNQUFqQkQsUUFBQTByQyxpQkFBaUJ6ckM7O1NBQWpCeXJDO0lBQWlDLE9BeDNDMUNyeUMsT0F3M0NnQ3N5QyxTQUF2QkQ7R0FBK0Q7Ozs7Ozs7Ozs7Ozs7Ozs7O09BN2lEdkUzbkM7T0FtQkgvSjtPQWFBcThCO09BdXdCQTdoQjtPQWp2QkF0Rzs7T0FpdEJBaFU7T0F3QkF3WTtPQUNBRztPQW5DQXhXO09BS0FLO09BeUJBNlY7T0FDQUM7T0FsSEFXO09BTUFEO09BcEpBalo7T0ErTkFtWjtPQWtDQUw7T0FDQUU7T0FUQTFZO09BZ0JBb2tCO09BREFEO09BREFnSjtPQURBdEo7T0FEQUc7T0EzeUJHMWU7T0FRRGdMO09BQ0E1RztPQWloQkZ2STtPQUNBRDs7Ozs7Ozs7Ozs7O09BcWdDQXk5QztPQUdBQztPQUtBQzs7T0FwZEE3MEM7T0F0a0NFc3dCO09BU0Y3d0I7Ozs7T0FzZ0JBbks7Ozs7T0FwZUErd0M7Ozs7OztRQXdjSWo5QjtRQVNBQztRQXpDQTZhO1FBQ0FpbkI7UUFDQ2ptQjs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF3Q0QyRDtRQUNBM0g7UUFNQTJxQjtRQUNBQztRQU5BTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztPQWhaSjNGO09BbkRBUztPQTZEQU87T0F0REFOO09BaURBSztPQXhCQUY7T0FrQ0FJO09BM0JBSDs7UUF1Q0V2bEM7UUEyNUNBc3pDO1FBcDVDQTFOO1FBQ0FEO1FBeUVBVztRQUVBL0I7UUFLQWlDO1FBU0FDO1FBK0JBRTtRQW9CQUs7UUFnQ0FJOztPQThGRnFCO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09Bb09BaUQ7T0E1R0FoWDtPQU1BMTlCO09BbUdBdzBDO09BQ0FDO09BekZBdkI7T0FVQUk7T0FVQUM7T0FLQUU7T0ErQkFTO09BQ0FDO09BRUFJO09BdURBUTtPQXlCQUM7T0FvQkFJO09BUkFGO09Ba0JBRztPQXVCQWo0QztPQVZBQztPQXNDQW9wQjtPQW9GQWtCO09Bd0JBaEg7T0EwQkErRjtPQXRHQTR1QjtPQVFBQztPQTZJQVc7T0FkQUg7T0FNQUM7T0FkQUg7T0FrQkFJO09BZEFIO09BL1FBN2xCO09BREEzSDtPQUpBd3NCO09BSkFEO09BbVpFeUM7T0FEQUQ7T0FLQUs7T0FEQUQ7T0FEQUQ7T0FEQUQ7T0FLQUs7T0FEQUQ7T0FoTkZuQzs7T0EwT0FxQztPQUVBQzs7UUFrSEVxQjtRQXRFQVo7UUEwRUFhO1FBd0dBTTtRQTFFQUw7UUE4RUFNO1FBc0NBUztRQU9BQztRQU9BQztRQXVDQUk7UUFDQUM7UUFtQ0FJO1FBSUFDO1FBeEVBVDtRQWtCQUU7UUFpQkFHO1FBbUJBRTtRQWdEQUk7UUFDQUM7UUFNQUU7UUFRQUU7UUFKQUQ7UUFLQUU7UUF3QkFJO1FBTkFEO1FBZ0JBRTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUMxZ0RBejBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFiRmttQztJQUtFNy9CO0lBQ0E1RztJQUNDRjtJOUNpQ0gzSztJQUdBNUk7SUFDQW1KO0lBQ0FOO0lBQ0FPO0lBQ0F1UTtJQUNBM1A7SUFDQUM7SUFFQTJQO0lBQ0EzTztJQUNBQztJQUNBMk87SUFDQUM7O1k4Q3pDRS9GLEdBQUczTSxLQUFJdUM7SUFBaUMsVUFBQSxXOUNzQzFDc0IsVzhDdENTdEI7SUFBaUMsT0FBQSwrQkFBckN2QztHQUFrRDtZQVFuRHloRCxTQUFRLy9DLEtBQU0sT0FBQSxXOUN1QmxCRCxROEN2QllDLEtBQWdCOzs7O2dEQUF4QisvQyxVOUM2QkpqdkM7Ozs7OztvREFSQTVaLFM4Q3JDRXlUO3FEQVFBTSxJQURBQzs7O1lBZ0NJODBDLFNBQVFoZ0QsS0FBTSxPQUFBLFc5Q0FwQkQsUThDQWNDLEtBQWdCOztJQUN4QjJDO0lBQ0FzOUM7SUFQQWhtQzs7O3FDQUFBQTtZQU1BdFgsUUFEQXE5QyxVQUVBQzs7Ozs7Ozs7WUFHTnYxQyxpQkFBb0IsU0FBRTtZQUV0Qm5LLEtBQUs4UyxHQUFHdlM7SUFDVixHQURPdVMsT0FFRixnQ0FGRUE7SUFHQztLQUFKeFMsSUFBSSxXOUNWTmQsUThDT0tzVDtLQUlNLE1BQUEsNEJBSk5BO0tBR0M7O1NBQ1J2Wjs7NEJBREkrRyxHQUNKL0csR0FDaUIsV0FMUGdILEdBSVZoSDtNQUFBLFVBQUFBO2lCQUFBQTtNQUFBQTs7O0lBR0EsT0FKSStHO0dBSUg7WUFHQys2QyxhQUFhLzNDO0lBQ1AsSUFBSmhELElBQUksVzlDbEJOZCxROENrQmEseUJBREE4RDtJQUVmO3FCQUZlQSxZQUVNL0osR0FBRXVXLEdBQUssT0FBQSxlQUR4QnhQLEdBQ2lCL0csR0FBRXVXLEdBQWM7SUFBckMsT0FESXhQO0dBRUg7WUFHQ0YsUUFDV0U7SUFBYjtLQUFlNHRCLE1BS1IsaURBTE01dEI7S0FBRS9HLElBQUEyMEI7S0FBRXBWO0lBQ2Y7WUFEYXZmLEdBRVIsT0FGVXVmO0tBR0s7TUFITDBSLGtDQUFKbHFCLEdBQUUvRyxJQUFFdWY7TUFBRjFULE1BR0QsNEJBSEM3TDtLQUFBQSxJQUFBNkw7S0FBRTBULE1BQUEwUjs7R0FLTztZQUd0QmpSLFNBQVNqWjtJQUFJLE9BQXlCOztrQ0FBN0JBO3NCQUFrQy9HLEdBQUssNkJBQXZDK0csR0FBa0MvRyxHQUFtQjtHQUFDO1lBQy9EeVYsTUFBSTFPLEdBQUdDLEdBQUksT0FBQSxXOUM5QlhJLEs4QzhCT0osR0FBSEQsR0FBZTtZQUNuQnEvQyxPQUFLci9DLEdBQUdDLEdBQUksT0FBQSxXOUM5QlpLLE04QzhCUUwsR0FBSEQsR0FBZ0I7WUFFckJELEtBTUVDLEdBQUdOLE1BQU1PO0lBQUssSUFMQ2QsMkJBS2ZhLElBTG9CMGEsU0FBSWxDLE1BS3JCOVk7SUFKTDtRQURzQmdiLFFBQUx2YixLQUVaLE9BRnFCcVo7S0FHUztNQUhUMFIsUUFHUyxXQUV4QmpxQixHQUxldVksMkJBS3hCeFksR0FMb0IwYTtNQUFBb2dCLFFBR0csNEJBSEhwZ0I7S0FBQUEsTUFBQW9nQjtLQUFJdGlCLE1BQUEwUjs7R0FLMkI7WUFHckRSLE1BTUUxcEIsR0FBR04sTUFBTU87SUFBSyxJQUxDZCwyQkFLZmEsSUFMb0IwYSxTQUFJbEMsTUFLckI5WTtJQUpMO1FBRHNCZ2IsUUFBTHZiLEtBRVosT0FGcUJxWjtLQUdTO01BSFQwUixRQUdTLFdBRXhCanFCLEdBTFd5YSxLQUFJbEMsMkJBS3hCeFksR0FMb0IwYTtNQUFBb2dCLFFBR0csNEJBSEhwZ0I7S0FBQUEsTUFBQW9nQjtLQUFJdGlCLE1BQUEwUjs7R0FLMkI7WUFHckRxdUIsR0FBSXhJLFFBQVFDLGFBQVl0eUM7SUFDMUI7S0FBYSxNQUFBLGlEQURhQTtLQUMxQjs7U0FBQXpFOztNQUNLLEdBQUEsZ0RBRnFCeUUsR0FDMUJ6RSxJQURNODJDOzZCQUFvQnJ5QyxHQUMxQnpFLEdBRGMrMkM7TUFDZCxVQUFBLzJDO2lCQUFBQTtNQUFBQTs7OztHQUVJO1lBR0Z1L0MsU0FBVXpJLFFBQVFDO0lBQ3BCLCtCQURZRDtLQUVELE9BQUEsV0EzR1RRLHFCO21DQXlHa0JQO0tBSWYsT0FBQTtJQUVHLFlBQUEsNkJBTklELFFBQVFDO2dCQU9GLE9BQUEsV0FoSGhCTyxxQjtRQWlIT047SUFDQyxPQUFBO2FBbEhSTTtzQkFrSGE3eUM7Y0FDVDtlQUFhLE1BQUEsaURBREpBO2VBQ1Q7O21CQUFBekU7OztrQkFEU3lFO2tCQUNUekU7O29CQUZHZzNDO29CQUd3QyxnREFGbEN2eUMsR0FDVHpFO2dCQUFBLFVBQUFBOzJCQUFBQTtnQkFBQUE7Ozs7YUFFSTtHQUFFO1lBR1ZnZ0MsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU8sVUFBQSxnQ0FBWkQsS0FBSGw1QjtJQUFlLDZDQUFmQSxHQUFRbTVCO0dBQTRCO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBRyxnQ0FBakJ3USxHQUFHdlE7Y0FBQUE7Y0FBdUMsZ0NBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxnQ0FEUUMsS0FBS0Q7S0FFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtJQUNoQixLQUFHLGdDQURRQyxLQUFLRDtLQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NEJBQWlDLFdBaElwQ3NhLFdBMEhZdGE7S0FNVCx1QkFBUyxXQWhJWnNhLFdBMEhPcmE7S0FJUCxNQUFBO0lBQUEsT0FBQTtHQUdpQztZQUduQ2doRCxTQUFVLzFCLEtBQUt2YixLQUFJYSxHQUFFOGI7SUFDdkI7S0FDRTtPQUFBOztTQUZVcEI7U0FBS3ZiOzs4QkFBSWE7S0FDWithO0tBSUkrZjtLQURUelAsT0FBTyw0QkFDRXlQLE9BSkovZjtLQUlJOWhCLElBQUE2aEM7SUFDWDtlQURXN2hDLElBRFRveUI7O01BR2E7T0FBQSxNQUFBLGVBUElyckIsR0FLUi9HO09BRVAsTUFBQSwrQkFQaUI2aUI7TUFPakI7T0FBa0MsSUFGM0JoWCxNQUUyQiw0QkFGM0I3TDtPQUFBQSxJQUFBNkw7Ozs7Ozs7S0FFUDs7R0FFRTs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E5SUo0TDtPQUNBNUc7T0FDQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWlISHF2QjtPQUdBSTtPQUtBQzs7TzlDM0VBLzNCO09BREFEOztPOENGQXVJOzs7TzlDTEEzSztPQUVBOFE7TzhDK0JBdEI7T0FDQTJ3QztPOUNuQ0E3L0M7TzhDUUFFO09BVUFxN0M7OztPOUNoQkF0N0M7TzhDcURBODRDO09BTUFDO09BckNBMTRDO09BU0FtWjtPQUlBbFo7T0FTQTJwQjtPQWdEQSttQjtPOUNsR0F4eEM7T0FjQWlSO09BQ0FDOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SStDbkRBbXZDOzs7Ozs7Ozs7Ozs7OztZQXNISUMsVUFFc0JDO0lBRDNCLElBQ2tDQztJQUNuQztLQUFNO01BRDZCQztRQUM3Qjs2QkF6SEpKLGtCQXdIaUNHLGlCQUFQRDtjQUFPRTtNQU9uQzs7U0FBQSw4QkFQNEJGLFFBQUFBLG1CQUFBQTtNOztjQUFPRTtNQWlCbkM7O1NBQUEsOEJBakI0QkYsUUFBQUEsbUJBQUFBO007O0tBc0JMLFdBdEJLQSxXQUFBQTtLQUFPQyxrQkFBQUM7O0dBREE7NEJBRDdCSDs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDekhKSSxnQkFBZ0Jyd0QsR0FBRThULEdBQUVDLEdBQUUvQjtJQUt0QixVQUFBLFdBTHNCQSxXQUFOaFM7SUFDbEIsT0FBQSxnQ0FEb0I4VCxHQUFFQztHQU1sQjtHQU9tQjtJQUhyQnU4QztJQUdBQyxxQkFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFGckJDO0lBQ0FDO2FBRkFILHVCQUFBQSx1QkFBQUE7SUFJSyxNQUFBOztJQXVCREk7SUFDQUM7SUFyQkpDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBR0FDO0lBQ0FDO1lBTUFDLHdCO1lBQ0FDLHdCOzs7O0lBRUFDO01BdkJBZDt5QkF5QlksU0FBSTs7U0FJWnR3RDtTQUFLO2dCQUFBLDZCQUZMMHdELFdBRUExd0Q7OztlQUErQiw2QkFBL0JBLEdBREEyd0Q7OztRQUNxRDtZQTdCekRMOzhCQWtDWSxTQUFJOztJQUNiO0tBQ0NocUQ7S0FDQUQ7O2dCQUNBckc7UUFBSztlQUFBLDZCQUZMc0csT0FFQXRHO3FCQUFpQyw2QkFBakNBLEdBREFxRzs7T0FDeUQ7WUFHN0RnckQsYUFBYXJ4RDtJQUNmLE9BbkJFb3hELDhCQWtCYXB4RCxTQUFBQTtHQUM4RDtZQUczRXN4RCxhQUFhdHhELEdBQ2YsV0FEZUEsU0FBQUEsT0FDOEQ7WUFHM0V1eEQsaUJBQWlCdnhEO0lBQ25CLE9BM0JFb3hELDhCQTBCaUJweEQ7Y0FBQUE7Y0EzRGpCcXdELGdCQTJEaUJyd0Q7R0FDcUU7WUFHdEZ3eEQsaUJBQWlCeHhEO0lBQ25CLFdBRG1CQSxLQUFBQSxJQS9EakJxd0QsZ0JBK0RpQnJ3RDtHQUNxRTtNQXREdEZzd0Q7SUE0REssTUFBQTs7SUFDTG1CO0lBQ0FDO0lBR0V4cEQ7SUFDQUQ7WUFGRjBwRCw4QkFHRTN4RDtJQUFLO1dBQUEsNkJBRkxrSSxPQUVBbEk7aUJBQWlDLDZCQUFqQ0EsR0FEQWlJOztHQUN5RDtZQUczRDJwRCxhQUFhNXhEO0lBQ2YsT0FQRTJ4RCw4QkFNYTN4RCw2QkFBQUE7R0FDOEQ7WUFHM0U2eEQsaUJBQWlCN3hEO0lBQ25CLE9BWEUyeEQsOEJBVWlCM3hEO2tDQUFBQTtjQXBGakJxd0QsZ0JBb0ZpQnJ3RCx5QkE3RGpCZ3hEO0dBOERzRjtNQTNFdEZWLGVBR0FDO0lBOEVLLE1BQUE7WUFDTHVCLHNCO1lBQ0FDLDRCO01BaEZBeEIsc0JBSEFEOzhCQXVGWSxTQUFJOztJQUNiO0tBQ0NwcUQ7S0FDQUQ7O2dCQUNBakc7UUFBSztlQUFBLDZCQUZMa0csT0FFQWxHO3FCQUFxQyw2QkFBckNBLEdBREFpRzs7T0FDaUU7WUFHckUrckQsaUJBQWlCaHlELEdBQ25CLFdBRG1CQSxTQUFBQSxPQUNrRTtZQUduRml5RCxxQkFBcUJqeUQ7SUFDdkIsV0FEdUJBO2NBQUFBO2NBNUdyQnF3RDtlQTRHcUJyd0QsNkJBcEZyQml4RDtHQXVGNkI7O0lBTzdCaUI7SUFDQUM7SUFHRTdxRCw0QkFyRkVvcEQ7SUFzRkZycEQsNEJBckZFc3BEO1lBbUZKeUIsK0JBR0VweUQ7SUFBSztXQUFBLDZCQUZMc0gsT0FFQXRIO2lCQUFpQyw2QkFBakNBLEdBREFxSDs7R0FDeUQ7WUFHM0RnckQsZUFBZXJ5RDtJQUNqQixPQVBFb3lELCtCQU1lcHlELDZCQUFBQTtHQUNnRTtZQUcvRXN5RCxtQkFBbUJ0eUQ7SUFDckIsT0FYRW95RCwrQkFVbUJweUQ7a0NBQUFBO2NBbkluQnF3RCxnQkFtSW1CcndELDZCQTVHbkJneEQ7R0ErRzJCO1dBekgzQlQ7SUFrSUssTUFBQTtZQUNMZ0Msd0I7WUFDQUMsOEI7OztNQXBJQWpDO3lCQXdJWSxTQUFJOztTQUladndEO1NBQUs7Z0JBQUEsNkJBcEhMMHdELFdBb0hBMXdEOzs7ZUFBcUMsNkJBQXJDQSxHQW5IQTJ3RDs7O1FBbUhpRTtZQUdyRThCLG1CQUFtQnp5RCxHQUNyQixXQURxQkEsU0FBQUEsT0FHWjtZQUdQMHlELHVCQUF1QjF5RDtJQUN6QixXQUR5QkE7Y0FBQUE7Y0FsS3ZCcXdEO2VBa0t1QnJ3RCxpQ0ExSXZCaXhEO0dBNkkrQjtNQXhKL0JWO0lBOEpLLE1BQUE7O0lBQ0xvQztJQUNBQztZQWhLQXJDO1FBa0tBc0MsaURBRVksU0FBSTs7O0tBRVozckQsNEJBaEtKNHBEO0tBaUtJN3BELDRCQWhLSjhwRDtLQTJKQThCO2dCQU1JN3lEO1FBQUs7ZUFBQSw2QkFGTGtILE9BRUFsSDtxQkFBaUMsNkJBQWpDQSxHQURBaUg7O09BQ3lEO1lBRzdENnJELG1CQUFtQjl5RDtJQUNyQixPQVZFNnlELCtCQVNtQjd5RCw2QkFBQUE7R0FHWjtZQUdQK3lELHVCQUF1Qi95RDtJQUN6QixPQWhCRTZ5RCwrQkFldUI3eUQ7a0NBQUFBO2NBOUx2QnF3RDtlQThMdUJyd0QsaUNBdkt2Qmd4RDtHQTBLK0I7R0FRdkI7SUFBTjd3RCxNQUFNLHVCQXhMUnl3RDtJQXlMRTF3RCxNQUFNLHVCQXhMUjJ3RDtZQXNMQW1DLCtCQUdFaHpEO0lBQUs7V0FBQSw2QkFGTEcsS0FFQUg7aUJBQWlDLDZCQUFqQ0EsR0FEQUU7O0dBQ3lEO1lBRzNEK3lELHVCQUF1Qmp6RDtJQUN6QixPQVBFZ3pELCtCQU11Qmh6RDs7Y0E5TXZCcXdELGdCQThNdUJyd0QsMkJBdkx2Qmd4RDtHQXdMd0U7WUFLeEVrQyx1QkFBdUI1eEQsT0FBTzZ4RCxXQUFXQztJQUMzQyxJQUFJQyw2Q0FEcUIveEQ7T0FDckIreEQsZ0JBRHVDRCxxQkFHdEMsT0FIb0I5eEQ7SUFNZixZQUFBLGdCQU5lQTs7OzBDQUtuQmd5RDtTQUFBQTs7SUFLSjtLQUFJQztPQUxBRCxXQUs4Qiw0QkFUaENELG1CQUFBQTtLQVVtQixNQUFBLDRCQURqQkU7S0FDQUMsaUJBQWlCLGlDQVhvQko7S0FZckNLLGdCQUFnQiw0QkFYbEJKLGNBVUVHO0tBRUFseEQsU0FBUywyQkFEVG14RDtLQUVBQyxnQkFBZ0IsNEJBYmxCTDtLQWNFTSxpQkFBaUIsNEJBSGpCRjtLQUlBRyxnQ0FoQnFDUjtLQWlCckNTLGtCQVpBUDtJQXNCRjtRQVZFTyxrQkFIQUg7U0FUQUo7T0F3QmdDLFVBQUEsZ0JBN0JiaHlEO09BNkJOLDJCQWhCYmdCOztNQWdCYSxPQUFBLDJCQWhCYkE7O2NBR0FzeEQ7TUFLQSwyQkFSQXR4RCxRQUVBcXhELGVBZjBCUjtNQXNCMUIsNkJBUEFRO01BQ0FDLCtCQWhCcUNSOztLQXdCVixVQUFBLGdCQXhCUjl4RCxPQWNuQm95RDtLQVVGLDJCQVhFcHhELFFBRUFxeEQ7S0FVRiw2QkFYRUQ7S0FZRiw2QkFYRUM7S0FZRiw2QkFYRUM7O0dBYzhEO1lBR2xFRSxpQkFBaUJ4eUQsT0FBTzZ4RDtJQUMxQixPQWxDRUQsdUJBaUNpQjV4RCxPQUFPNnhEO0dBQ29DO1lBRzVEWSxtQkFBbUJ6eUQsT0FBUSxPQUozQnd5RCxpQkFJbUJ4eUQsV0FBNkM7O0lBQ2hFMHlEOzs7T0F2TUEzQztPQVFBRTtPQTVCQUo7T0F3Q0FNO09BcUJBSztPQXJDQVI7T0FRQUU7T0FqQ0FOO09Bd0ZBZ0I7T0EwQkFLO09BaEVBWDtPQUlBQztPQVpBSDtPQXVEQVc7T0FJQUM7T0FaQUg7T0FpRUFXO09BTUFDO09BbEJBSjtPQWtDQU07T0FOQUQ7T0FoR0FoQjtPQUlBQztPQWZBRjtPQStEQVU7T0FNQUM7T0FqQkFGO09BNEJBSTtPQW5LQXRDO09BQ0FFO09BQ0FDO09BQ0FGOztZQXVQRTZDO2lCQUVBdnNCLGNBQWdCdHdCLEtBQWlCN0Y7U0FDbkMsR0FEa0I2RixTQUFZQyxNQUFaRCxRQUFBNDhDLFlBQVkzOEMsY0FBWjI4QztTQUNsQixPQW5EQUQ7a0JBbUR1QixpQkFEWXhpRCxJQUFqQnlpRCxXQUZoQkM7UUFHa0U7aUJBR2xFNTRDLFVBQVU5SjtTQUNaO1VBQUl0QyxJQUFJLGlCQURJc0M7VUFDUndFOzBCQWpCSjgrQztlQWlCSTVsRDtlQXZESjhrRCx1QkF1REk5a0QsT0FQRmdsRDtTQVFGLFdBRElsK0M7UUFJc0I7bUJBVHhCMnhCLGVBSUFyc0I7OztZQTRCRXpULGdCQUVDcVAsb0JBSUNtSDtRQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztZQUtib3pEO2lCQUVBcGhELFVBQVltaEQsV0FBVXppRDtTQUN4QixHQURjeWlEOztXQUlMYyxjQUpLZDtXQUNWZTtzQkFJSXhqRDtjQUFLLE9Bckdmd2lEO3VCQXFHc0MsaUJBQTVCeGlELElBREN1akQsYUFOUGI7YUFPaUY7O2NBSi9FYztTQU1ELEdBQUEsaUJBUHFCeGpEO1VBT1MsVUFBQSxXQU43QndqRCxhQU15QyxpQkFQckJ4akQ7VUFPUyxPQUFBOztTQUFrQyxVQUFBLFdBTi9Ed2pELGFBRG9CeGpEO1NBTzJDLE9BQUE7UUFBYTtpQkFHOUV5akQsWUFBVXpqRCxHQUFJLE9BVmRzQixhQVVVdEIsR0FBZ0M7aUJBQzFDbTJCLGNBQWdCdHdCLEtBQWlCN0Y7U0FBSSxHQUFyQjZGLFNBQVlDLE1BQVpELFFBQUE0OEMsWUFBWTM4QyxjQUFaMjhDO1NBQXFCLE9BWHJDbmhELGNBV2dCbWhELFlBQWlCemlEO1FBQTJCO2lCQUU1RDBqRCxRQUFRcjRDO1NBQ1YsT0FBQSxzQ0FEVUE7UUFDNEQ7aUJBR3BFczRDLHlCQUF5QnQ0QztTQUNmOztZQUFBOztjQURlQTt1QkFDWW1FLEdBQUssT0FBQSwwQkFBTEEsT0FBc0I7U0FBakQsT0FBQTtRQUFtRDtpQkFHN0RqTyxVQUFVOEo7U0FDWjtVQUNJdTRDLE1BQU0sZ0NBRkV2NEM7VUFHUndTO1lBQVM7OzhCQUEyQixPQUF4Qyw4QkFESStsQyxLQUNtRDtZQURuREEsV0FBQUEsUUFRQyxPQWxCSEYsUUFRVXI0QztjQUdSd1MsUUFJUSxPQWZWNmxDLFFBUVVyNEM7cUJBR1J3Uzs7VUFLeUIsSUFBZnlYLGlCQUFlLE1BWjNCcXVCLHlCQVlZcnVCO1VBQWUsT0FBQTs7YUFDZnV1QjtTQUFTLE9BYnJCRix5QkFhWUU7UUFDRTtRQUloQjtTQURHajZDLGlCQUNIO29EQWRFckksV0FYQWtpRDs7Ozs7OztpQkF3QkM3NUM7aUJBaEREdlQ7aUJBRUNxUDtpQkFHQTJEO2lCQThCRDlIO2lCQVhBa2lEO2lCQUNBdHRCOztPQXJFSm10QjtPQXRDQWQ7T0FpQ0FZO09BSUFDOzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0dDN0tGOztJQTJJRVM7O0lBc0VBQzs7Ozs7O0lBclJBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW1FQUMsK0JBQ0Y7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF2RUVDOzs7S0FnTkssTUFBQTs7S0F2SUxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FBQUE7O1VBRU07O1dBeEVOSDt5QkF3RU07OztJQTBJTkk7SUFzRUFDO0lBbUVBQzs7O09BOVZBSjtPQUdBRjtPQW1FQUM7T0FHQUU7T0F5SUFMO09BR0FNO09BbUVBTDtPQUdBTTtPQW1FQUM7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OztJQ3JXQTNtRDs7Ozs7OztZQUNBNG1EO0lBQXVCLE9BQUE7R0FBcUQ7WUFDNUVDLGdCQUFjLE9BQUEsbUNBQWdEO1lBTTlEQyxRQUFRQyxNQUFLQztJQUNmLEdBRGVBLGNBUGJKO2tCQVNDLDZCQUZPRzs7b0JBQUtDOzs7O01BSUc7T0FBQTt1REFKSEEsY0FBQUE7bUJBSVIsNkJBSkdEOzs7O1lBTlJGO0lBWUYsT0FBQSxtQ0FOVUUsTUFBS0M7R0FNZTs7Ozs7Ozs7Ozs7O1lBWTVCQyxVQUFVRixNQUFLQztJQUNqQixHQUNHLGNBRmNBLGdCQXpCZko7SUE0QkU7S0FBQSxNQUFBLGlCQUhRRztLQUdSLGFBQWEsY0FITEE7SUFHSztLQUNiLFVBQUEsaUJBSmFDO0tBSWI7OztNQUNJLFVBQUEsMEJBTElEO01BS0o7O2tDQUxTQzs7VUFNTjtZQU5DRDs7O01BTUQ7OztPQUVILFVBQUEsY0FSSUE7T0FRSjs7bUNBUlNDOztXQVNOO2FBVENEOzs7Ozs7Ozs7SUFTRCxRQWpDVEY7SUFvQ0YsT0FBQSxxQ0FaWUUsTUFBS0M7R0FZZTtZQUc5QkUsbUJBQW1CSCxNQUFLQztJQUMxQixHQUNHLGNBRnVCQSxnQkF4Q3hCSjtJQTJDQyxVQUFBLGlCQUFBLGdCQUhrQkc7SUFHbEI7S0FDQyxVQUFBLGlCQUpzQkM7S0FJdEI7OztNQUVLO2lDQU5pQkE7T0FNakI7YUFERixpQkFBQSxnQkFMY0Q7Ozs7SUFLZCxRQTVDTEY7SUFnREYsT0FBQSxxQ0FUcUJFLE1BQUtDO0dBU007R0F1RmpCO0lBQUEsY0FqSWJGLFNBa0JBRyxXQWVBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFvQ0U5MEQsT0FBTVQsR0FBRUM7U0FDVixHQUFHLGtCQURPQTtVQU1OLFVBQUEsaUJBTk1BO1VBR1IsV0FoRkZvTyxtQkFrRkksaUJBTElyTzs7U0FRRyxJQUFQdzFELE9BQU8sa0JBUkh4MUQsR0FBRUM7U0FTUCxPQUFBLGtCQURDdTFEO21CQUNnQixpQkFEaEJBLE1BUk12MUQ7bUJBUU51MUQ7UUFDa0M7UUFHOUIsSUFBTkMsTUFBTTtpQkFFTjUxQyxTQUFPN2YsR0FBRUM7U0FDWCxHQUFHLGtCQURRQTtVQU1QLFVBQUEsaUJBTk9BO1VBR1QsV0E5RkZvTyxtQkFnR0ksaUJBTEtyTzs7U0FRTixLQUFBLGtCQVJNQSxXQVFtQyxPQUFBLGlCQVJuQ0EsR0FBRUM7U0FRTyxJQUFBLE1BQUEsaUJBUlRELEdBRlB5MUQsTUFVZSxNQUFBLHNCQVJOeDFEO1NBRkgsT0FBQSxzQkFBTncxRDtRQVUrQztpQkFJL0MxMUMsU0FBTy9mLEdBQUVDO1NBQUksSUFBYyxNQUFBLGlCQUFsQkEsSUFBSSxNQUFBLGlCQUFORDtTQUFvQixPQUFBO1FBQVU7aUJBRXJDMDFELFdBQVcvckQsR0FBa0Jnc0Q7U0FBYyxVQTVCM0NsMUQsT0E0QldrSixHQUFrQmdzRDtTQUFjLE9BQUEsaUJBQWhDaHNEO1FBQTZDO2lCQUV4RGlzRCxTQUFTanNELEdBQWtCZ3NEO1NBQ2IsSUFBWkUsWUEvQkZwMUQsT0E4QlNrSixHQUFrQmdzRDtTQUUxQixHQUFBLGtCQURDRSxtQkFDcUIsT0FGZGxzRDtTQUVxQixVQUFBLGlCQUZyQkEsR0FBa0Jnc0Q7U0FFRyxPQUFBLHNCQUQ1QkU7UUFDbUQ7aUJBR3JEQyxtQkFBbUJuc0QsR0FBR29zRDtTQUN4QixPQUFHLGtCQURrQnBzRDs7bUJBR2I7NEJBSGFBO3FCQVBuQityRCxXQU9tQi9yRCxHQUFHb3NEO3FCQUx0QkgsU0FLbUJqc0QsR0FBR29zRDtRQUtPO2lCQUc3QkMsY0FBY3JzRCxHQUFrQmdzRDtTQUNsQztVQUFJRSxZQTVDRnAxRCxPQTJDY2tKLEdBQWtCZ3NEO1VBRTlCTSwwQkFBMEIsaUJBRklOLFNBQzlCRTtTQUVELE9BQUEsa0JBRENJLHlCQURBSjttQkFHQyxpQkFKV2xzRCxHQUVac3NEO21CQUdDLGlCQUxXdHNELEdBQ1prc0Q7UUFJYztpQkFHaEJLLE1BQVEzL0MsS0FBZ0I1TSxHQUFHb3NEO1NBQzdCLEdBRFV4L0MsU0FBTUMsTUFBTkQsUUFBQXNvQyxNQUFNcm9DLGNBQU5xb0M7U0FDVixvQkFEVUE7O3NCQUFBQTtxQkFoQlJpWCxtQkFnQndCbnNELEdBQUdvc0Q7cUJBUjNCQyxjQVF3QnJzRCxHQUFHb3NEOztzQkFBbkJsWDtxQkF2QlI2VyxXQXVCd0IvckQsR0FBR29zRDtxQkFyQjNCSCxTQXFCd0Jqc0QsR0FBR29zRDtRQUtrQjs7Z0JBeEQ3Q3QxRDtnQkFjQW9mO2dCQVlBRTtnQkF5QkFtMkM7Z0JBaEJBSjtnQkFQQUo7Z0JBRUFFO2dCQWFBSTs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7OztJQzNHQWxkO0lBRUFDO0lBRUFFO0lBRUFrZDtJQWVBQzs7O1lBNUJGQyxlQWVZNWxDO0lBRVo7S0FBSTFKOztTQUZRMEosbURBQUFBLFNBUlZxb0I7S0FZRTk0Qzs7d0JBRkErbUIsS0FSRmd5Qjt1REFRRWh5QixTQVJGZ3lCO0tBWUV1ZDs7d0JBRkF0MkQsa0NBQUFBLFFBUkZpNUM7SUFZSyxPQUFBOztzQ0FGSHFkLEtBUkZIO0dBVXVCO1lBR3pCSSxlQUdZdjJEO0lBQUssT0E3QmpCcTJELGVBNkJnQyxlQUFtQixvQkFBdkNyMkQsSUFEVm8yRDtHQUM4RTs7O1FBR2hGSSw4QkFFb0J4MkQsR0FBSyxPQVJ6QnUyRCxlQVFvQnYyRCxHQUErQzs7O0tBRTlELE1BQUE7O0tBSkx3MkQ7Z0JBR29CeDJELEdBQUssT0FuQ3pCcTJELGVBbUN3QyxvQkFBcEJyMkQsSUFBK0M7Ozs7O3FCO09BVG5FdTJEO09BMUJBRjtPQWdDQUc7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDL0JBdGtEO0lBQVcsc0JBQ0osbUJBQ0MsbUJBQ0Q7O0dBQUU7WUFHVHFlO0lBQU8sc0JBQ0EsaUJBQ0Msa0JBQ0Q7O0dBQUc7WUFHVjl2QixPQUFNbVcsS0FBRWxHO0lBQUssSUFBbUIsTUFBQSxtQkFBeEJBLElBQWEsTUFBQSxtQkFBZmtHO0lBQWMsT0FBQSxtQkFBQTtHQUFzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FaMUMxRTtPQU1BcWU7T0FNQTl2Qjs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDa0VJc2E7SUFPQTA3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpTEV6a0Q7O0lBeFFIb0U7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXO0dBU2E7SUFOMUJvaEI7SUFDQTVHO0lBQ0NGO0lBSUQ4d0IsZUFYQ3J4Qix3QkFNRFM7SUFNQXpUOztZQXdQSTJ2RCxZQXRQTXRvRDtJQUNaLElBQUksV0FBQSxzQkFEUUEsSUFDUjtnQkFDRyxPQUFBLGdDQUZLQTtHQUVvQztHQU81QjtJQURwQnFNO0lBQ0FrOEMsb0JBQW9CLDRCQURwQmw4QztJQUVBbThDLG9CQUFvQiw0QkFGcEJuOEM7Ozs7Ozs7WUFHQXZJLGU7WUFDQTJrRCx5QjtZQUVBMWtELFNBQVN4QjtJQUNYO01BQUcsZ0NBRFFBLEdBTFRnbUQ7U0FPQyxnQ0FGUWhtRCxHQUpUaW1EO1lBSVNqbUQ7SUFPUCxXQUFBLDRCQVBPQTtJQUtULE9BQUE7R0FHSTs7SUFpTkZtbUQ7b0RBek9BL3ZELFNBTkF5VDs4Q0FNQXpULFNBTkF5VCxXQStPQXM4Qzs7Ozs7dURBZ0JJOWtEOzs7SUF6TUZqSztJQUVDbWM7SUFJQzZ5QztHQUNKLFNBRkc1eUMsT0FFQ25rQixHQUFLLE9BQUEsV0FETCsyRCxRQUNBLzJELEdBQVc7O0lBTWJnM0Q7OztZQUNBdjJELG1CO1lBQ0EwekQsWUFBVXhxRCxHQUFJLE9BQUEsZ0NBQUpBLEdBQXlCO1lBQ25Dc3RELFlBQVU3b0Q7SUFBSSxPQUF5Qiw0QkFBN0JBLHVCQUFJO0dBQThCOzs7Ozs7U0FoQjVDckc7U0FFQ21jO1NBR0FDO1NBVURnd0M7U0FDQThDO1NBeUtGSDtTQTNLRXIyRDtTQURBdTJEO1NBSUFqOEM7Ozs2Q0FPQTA3QyxlQWlMRXprRDs7Ozs7O1lBektOdUksaUJBQW9CLFNBQUU7WUFDdEJvdkIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU8sV0FBWkQsT0FBSGw1Qix5QkFBQUEsS0FBUW01Qjs7R0FBNEI7WUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7SUFBTSxPQUFkd1EsSUFBR3ZRLE1BQUFBLE1BQUh1USxLQUFReFEsTUFBUndRLElBQVF4UTtHQUEwRDtZQUVsRjZwQyxVQUFVcjVCLEdBQUd2USxLQUFLRDtJQUNwQixHQURlQyxPQUFLRCxLQUVwQixPQUpFNHBDLGdCQUVVcDVCLEdBQUd2USxLQUFLRDtJQUNwQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBQ2hCLEdBRGdCQSxPQUFMQyxLQU9OLFdBZEgycEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NkJBQWlDLFdBckdwQ3NhLFdBK0ZZdGE7S0FNVCx3QkFBUyxXQXJHWnNhLFdBK0ZPcmE7S0FJUCxPQUFBO0lBQUEsT0FBQTtHQUdpQztZQVFuQ29yQyxLQUFLNWhDLEdBQUksT0FBQSw0QkFBSkEsTUFBUztZQUNkMkksS0FBSzNJLEdBQUksT0FBQSw0QkFBSkEsTUFBUztZQUNkNkgsT0FBTzdILEdBQUksT0FBSkEsRUFBSztZQWdJVmtJLFdBOUhLbEksR0FBSSxPQUFKQSxFQUFLOztJQUVaeUk7SUFDQUM7SUFFQTZrRDtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQTJHRUMsSUF6R0U1M0QsR0FBSSxPQUFBLDZCQUFKQSxHQUFTO1lBR2I2M0QsSUFBSS9qRCxHQUFFQyxHQUFJLE9BQUEsNkJBQU5ELEdBQUVDLEdBQVc7WUFDakJoRyxXO1lBQ0FELFc7WUFDQThuQyxZQUFZOWhDLEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBVztZQUN6QitqRCxvQkFBb0Joa0QsR0FBRUM7SUFBSSxPQUFBLDZCQUFORCxHQUFFQztHQUFXO1lBQ2pDZ2tELFdBQVdqa0QsR0FBRUMsR0FBSSxPQUFBLDZCQUFORCxHQUFFQyxHQUFXO1lBQ3hCaWtELFFBQVFsa0QsR0FBSSxPQUFBLDZCQUFKQSxHQUFVO1lBQ2xCbWtELE9BQU9ua0QsR0FBRUMsR0FBSSxPQUFBLDZCQUFORCxHQUFFQyxHQUFXO1lBQ3BCbWtELFFBQVFwa0QsR0FBRUMsR0FBSSxPQUFBLDZCQUFORCxHQUFFQyxHQUFZO1lBQ3RCb2tELFFBQVFya0QsR0FBRUMsR0FBSSxPQUFBLDZCQUFORCxHQUFFQyxHQUFZO09BQ3RCcWtEO1lBd0ZFdjRDLFNBdkZLOUwsR0FBRXdCLEdBQUksT0FBQSxXQURiNmlELEtBQ09ya0QsR0FBRXdCLEdBQVc7O0lBS2xCMHlCOzs7Ozs7O1lBRUFvd0I7SUFDRixPQUFBO0dBQTJEO1lBS3pEQyxVQUFVdDREO0lBQ1osR0FEWUEsUUFOVnE0RDtJQVFNO0tBQUp0eEMsTUFBSSw0QkFGSS9tQjtLQUdFLE1BQUEsNkJBRFYrbUI7S0FDQTBKLE1BQUksNkJBREoxSjtLQUVVLE1BQUEsNkJBRFYwSjtLQUNBNmxDLE1BQUksNkJBREo3bEM7S0FFVSxNQUFBLDZCQURWNmxDO0tBQ0FpQyxNQUFJLDZCQURKakM7S0FFVSxNQUFBLDZCQURWaUM7S0FDQUMsTUFBSSw2QkFESkQ7S0FFVSxNQUFBLDZCQURWQztLQUNBQyxNQUFJLDZCQURKRDtLQUlVLE1BQUEsNkJBSFZDO0tBR0FDLE1BQUksNkJBSEpEO0lBSUosT0FBQSw0QkFESUM7R0FDQztZQUlIQyxXQUFXMzREO0lBQ2IsR0FEYUEsUUFyQlhxNEQ7SUF1Qlk7S0FBQSxNQUFBLDZCQUZEcjREO0tBRVQrbUIsTUFBSSw2QkFGSy9tQjtLQUdDLE1BQUEsNkJBRFYrbUI7S0FDQTBKLE1BQUksNkJBREoxSjtLQUVVLE1BQUEsNkJBRFYwSjtLQUNBNmxDLE1BQUksNkJBREo3bEM7S0FFVSxNQUFBLDZCQURWNmxDO0tBQ0FpQyxNQUFJLDZCQURKakM7S0FFVSxNQUFBLDZCQURWaUM7S0FDQUMsTUFBSSw2QkFESkQ7S0FJVSxNQUFBLDZCQUhWQztLQUdBQyxNQUFJLDZCQUhKRDtLQUlBLE1BQUEsNkJBREFDO0lBQ0EsT0FBQSw0QkFEQUE7R0FDUztZQUdYRyxRQUFRNTREO0lBQ1YsR0FEVUEsUUFsQ1JxNEQ7SUFvQ0ssVUFBQSw0QkFGR3I0RDtpQkFFViw2QkFGVUE7R0FFUTtZQW1CaEI2NEQsV0FBV2x2RDtJQUNiLEdBRGFBO0tBRW1ELHVCQUFNLDZCQUZ6REE7S0FFUjtPQTNESHMrQixTQTJEVzs7SUFDRTtLQUFBLE1BQUEsOEJBSEZ0K0I7S0FHYixNQUFBLDRCQWpNQThRO0lBaU1lLE9BQUE7R0FBSztZQUdsQnErQyxVQUFVbnZEO0lBQ1osR0FEWUE7S0FFbUQseUJBQU0sNkJBRnpEQTtLQUVQO09BakVIcytCLFNBaUVXOzthQUZEdCtCLEdBR0U7SUFBa0I7V0FBQSw4QkFBSSw0QkFIeEJBO0lBR29CLE9BQUEsNEJBdk1oQzhRO0dBdU0yQzs7SUFNM0Npd0I7SUFDQXF1Qjs7Ozs7U0F4TUE1bUQ7U0FIQUQ7U0EyT013a0Q7U0FDQTFrRDs0Qjs0Qjs7O3VCOzRCOzRCOzRCOzRCOzRCOzRCO1NBcEJKNGxEO3VCO1NBSUFkO1NBQ0FqbEQ7U0EzR0ZnbUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTJJRTkzQyxTQUFNL2YsR0FBRUM7SUFDVixHQURVQTtLQU1OLElBQUEsTUFBQSxXQXZCRStSLFdBaUJJL1IsSUFLTixNQUFBLFdBdEJFK1IsV0FpQkVoUztLQUdOOztJQUtTLElBQVB3MUQsT0FuSkpxQyxJQTJJUTczRCxHQUFFQztXQVFOdTFELFdBQUFBLE9BUk12MUQsUUFRTnUxRDtHQUNrQztZQUdwQ2x3RCxTQUFPdEYsR0FBRUM7SUFDWCxHQURXQTtLQU1QLElBQUEsTUFBQSxXQW5DRStSLFdBNkJLL1IsSUFLUCxNQUFBLFdBbENFK1IsV0E2QkdoUztLQUdQOztXQUhPQSxpQkFBQUEsV0FBRUMsc0JBQUZELEdBQUVDO0dBUXNDO1lBRy9Dc0YsU0FBT3ZGLEdBQUVDLEdBQUksT0FBYyw0QkFBcEJELEdBQUVDLEdBQTRCOztJQU1yQys0RDs7SXZFMUpBaHpEO0lBQ0FqRztJQUNBRztJQUNBQzs7O091RXJKQ21hO09BcUJIbkk7T0FIQUQ7T0E2TkVMO09BaElGTDtPQXpIRzRFO09BR0EyRDtPQUtEcUg7O09BK1BJczFDO09BQ0Exa0Q7MEI7O092RXpHSjdSO09BREFEO09BRkE4RjtPQUNBakc7T3VFN0RGNHBDO09BR0FJO09BS0FDOzs7T0ExRkVvQjs7Ozs7T0F3TkZWO09BdklBbndCOzs7OztPQStDQXM5Qzs7Ozs7O09BdEJBdmxEO09BREFpNUI7T0FpQ0E2c0I7T0FGQUY7T0FEQUQ7T0FFQUU7T0FIQUg7T0FtRkFlO09BcEZBaEI7T0FGQW5pQjtPQURBOW5DO09BREFDO09BZEFvcEQ7T0FFQUU7T0FFQUU7T0FDQUM7T0FFQUU7T0FDQUM7T0E1R0FkO09BSkFwOEM7T0FvR0FySTtPQUNBQztPQW9CQXlsRDtPQW9CRVE7T0FlQUs7T0F3Q0FHO09BTkFEO09BckJBRDtxQjtxQjtXQThDQS80QyxVQXNFQW01QyxNQWxFQXBCLEtBSUFkLE1BaUNBLzJDLFVBWUF6YSxVQVdBQztPQWhFQXNhO09Bc0VBbTVDO09BbEVBcEI7T0FJQWQ7T0FpQ0EvMkM7T0FZQXphO09BV0FDOztPQXZEQXNNO09BaElGTDtPQU9BMGxEO09BRUFFO09BRUFFO09BR0FHO09BRUFFOzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ3pJRTU4Qzs7Ozs7Ozs7Ozs7SUFMRjdNOzs7Ozs7Ozs7Ozs7Ozs7WUFNRWtJLFlBQVlPLE9BQU1qRztJQUF3QixVQUFBLG1CQUF4QkE7SUFBd0IsT0FBQSx5QkFBOUJpRztHQUF3QztZQUNwRG9ELEtBQUtySixHQUFJLE9BQUEsNkJBRFQwRixhQUNLMUYsR0FBMEI7WUFDL0JzQixVQUFVdEI7SUFBNEIsVUFBQSxtQkFBNUJBO0lBQTRCLE9BQUE7R0FBVTtZQUloRDhKLFVBQVU5SixHQUFJLFdBSmRzQixVQUlVdEIsSUFBMkI7WUFFckMwUSxVQUFVMUY7SUFDWixTQURZQTtLQUVLLE9BQUEsNkRBRkxBO1FBR0F0TixJQUhBc047SUFJVjtLQUFLOztRQUFBOztVQURLdE47O21CQUMyQnpFLEdBQUssT0FBQSwyQkFBTEEsR0FBb0I7S0FBcEQ7OztLQUNHLE9BQUEsNkRBTEUrUjs7R0FLbUU7R0FJL0U7SUFERXBCLGlCQUNGO2dEQWxCRVMsYUFHQS9JO3VEQUlBd0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF3QkZELGlCQUFvQixTQUFFO1lBR3RCMCtDLFNBQVMvNEM7SUFDWCxJQUFJLFVBQUEsMkJBRE9BLElBQ1A7Ozs7U0FDZWc1QztLQUFPLE9BQUEsV0F6Q3hCaHJELGdCQXlDaUJnckQ7O0dBQTRDO1lBRzdENW1ELEtBQUs0TjtJQUNQLElBQUksY0FBSywyQkFERkEsS0FDSDs7OzhCQUNvQjs7O0dBQUk7WUFHMUJpNUMsU0FBU2o1QztJQUNYLElBQUksVUFBQSwyQkFET0EsSUFDUDs7OztTQUNlZzVDO0tBQU8sT0FBQSxXQW5EeEJockQsZ0JBbURpQmdyRDs7R0FBNEM7WUFHN0QzdEIsS0FBS3JyQjtJQUNQLElBQUksY0FBSywyQkFERkEsS0FDSDs7OzhCQUNvQjs7O0dBQUk7WUFHMUJrNUMsVUFBVXp2RDtJQUFJLE9BQUcscUJBQVBBLFNBQWlDLDBCQUFqQ0E7R0FBNEQ7WUFFdEUwdkQsY0FBYzF2RDtJQUNoQixPQUFHLHFCQURhQTtjQUVYLDBCQUZXQTtjQUdYLFdBaEVIdUUsZ0JBNkRjdkU7R0FHK0Q7WUFHN0UydkQsVUFBVTVvRCxHQUFJLE9BQUEsMkJBQUpBLEdBQW1CO1lBQzdCNm9ELFFBQVFyNUM7SUFBSSxPQUFHLG9CQUFQQSxTQUEyQiwyQkFBM0JBO0dBQXVEO1lBRS9EczVDLFlBQVl0NUM7SUFDZCxPQUFHLG9CQURXQTtjQUVULDJCQUZTQTtjQUdULFdBekVIaFMsZ0JBeUVxRSxtQkFIekRnUztHQUdzRTtZQUdsRnU1QyxpQkFBaUJDO0lBQ0gsSUFBWkMsWUFWRkwsVUFTaUJJO0lBRW5CLGNBRElDO3NCQUFBQSxxQkFBQUE7O0dBT0U7Ozs7Ozs7Ozs7Ozs7Ozs7O09BOUVGdmpEO09BQ0EyRDtPQU9BcUg7T0FGQTVHO09BVUFGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FjRkM7T0FRQWpJO09BTEEybUQ7T0FlQTF0QjtPQUxBNHRCOztPQW1CQUk7T0FFQUM7OztPQVhBSjtPQUVBQztPQU1BQztPQVNBRzs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDaURJRzs7Ozs7Ozs7WUEzSEpwL0MsVUFPSXVLLFVBQVlDLGlCQUFpQixXQUFzQjs7Ozs7Ozs7O1lBUXZENjBDLFdBQTJDLFNBQUM7WUFDNUNDLGtCQUE4RCxTQUFDO1lBQy9EQyxZQUFnQ2ptRCxHQUFhLE9BQWJBLEVBQWM7NkJBTTVDczJCLFlBQW9ELFNBQUMsRUFEM0QsV0FDTUE7OEJBT0FBLGlCQUdGLFNBQUMsRUFKTCxXQUNNQTs7YUFXQUEsc0JBR0YsU0FBQztJQUpMLFdBQ01BOztZQU9GNHZCLGdCQUNGLFdBQUk7WUFHRkMsbUJBQXFGLFNBQUM7O2FBaUJwRmpSLE1BQU16ekM7S0FBYSxVQUFBLGtCQUFiQTtLQUFhLE9BQUE7SUFBWTtJQUh3QyxXQUd2RXl6Qzs7WUF3RUExc0M7UUFBdUJrRyxlQUFUMDNDO0lBQ2hCLHFCQUNLLFdBRm9CMTNDO0lBbkRnQjtLQUZkOVIsSUFxRFh3cEQ7S0FuRHlCLE1BQUEsOEJBRmR4cEQ7S0FQSHlwRCxRQVNsQjtJQXVESjs7a0NBSnVCMzNDOzs7Ozs7a0NBM0RzQyw2QkFEdkMyM0M7Ozs7WUFzRXRCQyxRQUFRMXBELEdBQUksT0FBSkEsS0FBYTtZQUNyQjhSLEtBQUs5UixHQUFJLE9BQUpBLEtBQVU7WUFDZmQsT0FBUTRTLE1BQUs0M0M7SUE1Q0s7SUE0Q0sscUJBQWY1M0MsTUFBSzQzQztHQUF3RDtZQUNyRUMsSUFBSTNwRDtJQUFJLElBdkNlc1ksSUF1Q25CdFksTUF0QzhCLE1BQUEsOEJBRFhzWTtJQUNXLE9BQUE7R0FzQ0w7WUFDN0JqUCxLQUFLckosR0FBSSxPQURUMnBELElBQ0szcEQsR0FBUztZQUNkMEYsWUFBWWhJLEdBQUVzQztJQUFvQixVQUZsQzJwRCxJQUVjM3BEO0lBQW9CLE9BQUEsNkJBQXRCdEM7R0FBNkI7WUFDekNrc0QsYUFBYXhvRCxJQUFHQztJQUFLLElBaENRZ0MsSUFnQ2JoQyxPQWhDRytCLElBZ0NOaEM7V0FoQ01nQyxTQUFVQyxPQUYzQjZsRDtHQWtDcUQ7WUFDdkRXLEtBQUt6b0QsSUFBR0M7SUFBb0IsVUFENUJ1b0QsYUFDS3hvRCxJQUFHQztJQUFvQixPQUFBO0dBQW9CO1lBRWhEeW9ELGlCQUFpQjFvRCxJQUFHQztJQUNoQixZQUpKdW9ELGFBR2lCeG9ELElBQUdDO2tCQUVmMHFDLGNBQUssT0FBTEE7SUFLQTtLQUN1RTtLQUEzQjtLQUQ1Qzs7OztTQUNJOzt5QixPQTNCVG5nQzt5QixPQUFBQTtlQW1CaUJ4SyxJQUFHQzs7S0FLbEIsTUFBQTtJQUFBLE9BQUE7R0FLSzs7OztPQTFLVHlJOztPQWVBcS9DO09BQ0FDO09BQ0FDOzs7O09BK0JBQztPQUlBQzs7O1FBeUZFMzlDOzs7Ozs7NEI7NEI7NEI7NEI7NEI7NEI7Ozs7Ozs7Ozs7O1FBYUErOUM7UUFEQXpxRDtRQUVBbUs7UUFIQXlJO1FBREE0M0M7UUFLQWhrRDtRQUVBbWtEO1FBREFEO1FBR0FFOzs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0N4SHVDOzs7Ozs7Ozs7OztJQUFyQ0Msa0JBQXFDO0lBeEJUQzs7O1lBT2hDM3RCLFFBa0NZL3NDLEdBQUksT0FqQnlCLDZCQWlCN0JBLEdBekNvQjA2RCxNQXlDQztZQWpDakMxdEIsUUFrQ1lodEMsR0FBSSxXQUFJLDZCQUFSQSxHQTFDb0IwNkQsTUEwQ087WUFwQ3ZDanRCLEtBc0NtQnp0QztJQUNqQixPQTdDdUMsNkJBNEN0QkEsR0E1Q2EwNkQsUUF3QjVCRCxrQkFvQmV6NkQ7R0FDNkM7WUFuQ2hFMjZELGFBc0MyQjM2RDtJQUN6QixPQUFHLDZCQURzQkEsR0F4QnZCeTZELG1CQXhCNEJDLE9BZ0RMMTZEO0dBQ3FEO1lBeENoRm90QyxVQTJDY3B0QztJQUNaLE9BN0NGZ3RDLFFBNENjaHRDO2NBMUNkMjZELGFBMENjMzZEO2NBR1A7R0FBMkQ7WUFnQjlENDZEO0lBUFksbUJBaEVnQkY7UUFrRXZCMTZEO0lBQUssT0E1RGR5dEMsS0E0RFN6dEM7R0FBVztZQUloQjY2RCxZQURtQjc2RCxHQUFJLE9BN0QzQmd0QyxRQTZEdUJodEMsU0EzRHZCMjZELGFBMkR1QjM2RCxRQUFxRDs7Ozs7WUFDeEU2NkQsYUFDQUQ7OztZQWVKNTdCLFlBQ0VqYSxVQUFZKzFDO0lBQ1EsVUFBQSxzQkFEcEIvMUM7SUFDSixPQUFBLHVDQURnQisxQztHQUNvRDtZQUdsRXgrQyxZQUNFeStDLFVBQVlDO0lBQ1EsVUFBQSxzQkFEcEJEO0lBQ0osT0FBQSx1Q0FEZ0JDO0dBQ29EO1lBR2pFMWdELGVBQ0N1TDtJQUNKO0tBdEJpQyxNQUFBLDJCQXFCN0JBO0tBckI2QixNQUFBO0lBc0JKLE9BQUE7R0FBOEM7R0FEM0UsSUFNRStyQjtZQUNBaGlDLE9BQVFDLEtBQU0seUNBQU5BLEtBeEd3QjZxRCxNQXdHeUI7WUFDekR0cUQsS0FBSzhTLEdBQUd2UztJQUFJLE9BQXdCOzthQUEvQnVTO3NCQUFvQ3ZaLEdBQUssT0FsQzFDaXhELFlBa0NpRSxXQUE3RGpxRCxHQUFpQ2hILElBQWlDO0dBQUM7WUFDM0VzeEQsVUFBVS8zQyxHQUFHdlM7SUFBSSxPQUF3Qjs7YUFBL0J1UztzQkFBb0N2WixHQUFLLE9BcEduRDhqQyxLQW9HcUUsV0FBeEQ5OEIsR0FBaUNoSCxJQUE0QjtHQUFDOztZQUVsRThZLElBQUkvUixHQUFFL0c7SUFBSSxPQXRDZmt4RCxZQXNDc0MsbUNBQTdCbnFELEdBQUUvRztHQUFrRDtZQUNqRXV4RCxhQUFheHFELEdBQUUvRztJQUFJLE9BcEduQnlqQyxVQW9HMEMsbUNBQTdCMThCLEdBQUUvRztHQUFrRDtZQUNqRXd4RCxVQUFRenFELEdBQUUvRztJQUFJLE9Bdkdkb2pDLFFBdUdtQyxtQ0FBM0JyOEIsR0FBRS9HO0dBQWdEO1lBQzFEeXhELFVBQVExcUQsR0FBRS9HO0lBQUksT0F2R2RxakMsUUF1R21DLG1DQUEzQnQ4QixHQUFFL0c7R0FBZ0Q7WUFDMURrdUMsSUFBSW5uQyxHQUFFL0csR0FBRTNKO0lBQTBCLFVBekM5QjQ2RCxZQXlDSTU2RDtJQUEwQixPQUFBLG1DQUE5QjBRLEdBQUUvRztHQUFzRDtZQUM1RDB4RCxTQUFTM3FELEdBQUUvRyxHQUFFM0o7SUFBMEIsVUEzR3ZDeXRDLEtBMkdhenRDO0lBQTBCLE9BQUEsbUNBQTlCMFEsR0FBRS9HO0dBQWlEO1lBQzVEMnhELFNBQVM1cUQsR0FBRS9HO0lBQUksMENBQU4rRyxHQUFFL0csR0FsSHFCK3dEO0dBa0hzQjtZQUN0RHhwRCxLQUFLUixHQUFFL0csR0FBRXdILEdBQUksT0FBQSxtQ0FBUlQsR0FBRS9HLEdBQUV3SCxHQUE0QjtZQUNyQzJyQyxXQUFXcHNDLEdBQUUvRztJQUFJLE9BOUNia3hELFlBOENvQyxtQ0FBN0JucUQsR0FBRS9HO0dBQXlEO1lBQ3RFNHhELG9CQUFvQjdxRCxHQUFFL0c7SUFBSSxPQTVHMUJ5akMsVUE0R2lELG1DQUE3QjE4QixHQUFFL0c7R0FBeUQ7WUFFL0U2eEQsOEJBQThCOXFELEdBQUUvRztJQUNsQyxPQTlHRWd4RCxhQThHd0IsbUNBRE1qcUQsR0FBRS9HO0dBQ3NCO1lBR3REOHhELGVBQWUvcUQsR0FBRS9HO0lBQUksT0FuSHJCcWpDLFFBbUgwQyxtQ0FBM0J0OEIsR0FBRS9HO0dBQXVEO1lBQ3hFeXpDLFdBQVcxc0MsR0FBRS9HLEdBQUUzSjtJQUFpQyxVQXJENUM0NkQsWUFxRFc1NkQ7SUFBaUMsT0FBQSxtQ0FBckMwUSxHQUFFL0c7R0FBNkQ7WUFDMUUreEQsZ0JBQWdCaHJELEdBQUUvRyxHQUFFM0o7SUFBaUMsVUF2SHJEeXRDLEtBdUhvQnp0QztJQUFpQyxPQUFBLG1DQUFyQzBRLEdBQUUvRztHQUF3RDtZQUMxRWd5RCxnQkFBZ0JqckQsR0FBRS9HO0lBQUksMENBQU4rRyxHQUFFL0csR0E5SGMrd0Q7R0E4SG9DO1lBRXBFa0IsTUFBTWxyRDtJQUNSO0tBQWEsTUFBQSxnQkFETEE7S0FDSyxNQUFBO0tBQWI7O1NBQUEvRzs7TUFIRWd5RCxnQkFFTWpyRCxHQUNSL0c7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7Ozs7R0FFSTtnQkFHSXJJLE9BQU9xUDtJQUNmO0tBQWEsTUFBQSxnQkFETHJQO0tBQ0ssTUFBQTtLQUFiOztTQUFBcUk7O01BQ0UsV0FGYWdILEdBQ2ZoSCxHQW5CRW16QyxXQWtCTXg3QyxPQUNScUk7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7Ozs7R0FFSTtnQkFLSXJJLE9BQU84TyxNQUFNTztJQUNYLElBQU51WSxVQURXOVk7SUFFZjtNQUZROU87ZUFFWXFJLEdBQUVreUQsTUFEbEIzeUMsU0FDaUMsV0FGaEJ2WSxHQUVEaEgsR0FEaEJ1ZixRQUNrQjJ5QyxnQkFBNEI7V0FEOUMzeUM7R0FFQTtZQVNFelksS0FOQ25QLE9BQU84TyxNQUFNTztJQUFJO2FBQWpCclA7YUFBTzhPOzZCQUE4QzhZLEtBQUlscEIsR0FBSyxPQUFBLFdBQWpEMlEsR0FBd0N1WSxLQUFJbHBCLEdBQVk7R0FBQztHQU8vRDtJQUFSbzZCO0lBQ0F2cEI7OztnQkFoQkN2UCxPQUFPcVA7UUFBSSxXQUFYclAsdUJBQXlDdEIsR0FBSyxPQUFBLFdBQXZDMlEsR0FBa0MzUSxHQUFRO09BQUM7SUFpQm5EOFE7SUFDQTBCOzs7d0NBSkEvQixNQUVBSSxNQUVBMkIsUUFEQTFCLE9BRkFzcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBWUpycEIsSUFBSXpQLE9BQU9xUDtJQUxBLElBQVRyTyxTQTFERnNOLE9BMER1QixxQkFLbkJ0TztJQUpOOztNQUlNQTtlQUpjcUksR0FJMEJreUQsTUFKaEIsT0F2QzVCemUsV0FzQ0U5NkMsUUFDZ0JxSCxHQUlrQyxXQUF6Q2dILEdBQWlDa3JELE9BSmM7SUFBNUQsT0FESXY1RDtHQUt5RDtZQUUzRHc1RCxTQUFTeDZELE9BQU9xUDtJQUNsQjtLQUFJZCxNQUFNLHFCQURDdk87S0FFUGdCLFNBbkVGc04sT0FrRUVDO0tBR1csTUFBQSw0QkFIWEE7S0FDUzs7U0FFWGxHOztNQUNZLElBcEhFNE0sTUFvSEYsbUNBTEhqVixPQUlUcUk7TUFuSHdCLEdBbER4QnFqQyxRQWtEY3oyQjtPQUEyQixJQXFISnZXLElBcktyQzI2RCxhQWdEY3BrRDtPQW1FZG1sRCxnQkE4Q0VwNUQsUUFFRnFILEdBRW1FLFdBTm5EZ0gsR0FNcUIzUTs7TUFIdkMsVUFDRTJKO2lCQUFBQTtNQUFBQTs7O0lBS0YsT0FQSXJIO0dBT0U7WUFHSnM3QyxTQUFTdG9DO0lBQVEsT0E1RWpCbEYsS0E0RVNrRiwyQkFBMEMzTCxHQUFLLE9BQS9DMkwsVUFBMEMzTCxHQUE2QjtHQUFDO1lBRWpGb3lELGNBQWN6bUQ7SUFDaEIsT0E5RUUybEQsVUE2RWMzbEQsMkJBQ3VCM0wsR0FBSyxPQUQ1QjJMLFVBQ3VCM0wsR0FBNkI7R0FBQztZQUduRWdnQixTQUFTalo7SUFBZSxVQUFBLHFCQUFmQTtJQUE2QixPQUFBOzJDQUFLL0csR0FBSyxPQXZFaERtekMsV0F1RVNwc0MsR0FBa0MvRyxHQUFtQjtHQUFDO1lBTTNEa2pDLFlBQWFoOUIsWUFBUSxPQXpGekJELE9BeUZpQkMsS0FBbUI7O0lBQ2hDOFE7O21DQURBa3NCLHVCQUNBbHNCOzs7Ozs7SUFHSnpROzs7T0EvR0E4dUI7T0FLQTFpQjtPQUtDaEM7T0FPRHMzQjtPQUNBaGlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUVBcXJEO09BREE3cUQ7T0E0RUF3dEM7T0FFQW1lO09BSUFweUM7T0EvRVNsSDtPQUNUeTRDO09BQ0FDO09BQ0FDO09BS0F0ZTtPQUNBeWU7T0FFQUM7T0FJQUM7T0FYQTVqQjtPQUNBd2pCO09BQ0FDO09BQ0FwcUQ7T0FhQTBxRDtPQXVDQTdxRDtPQUVBK3FEO09BN0NBMWU7T0FDQXNlO09BQ0FDOzs7Ozs7T0F1RUF6ckQ7Ozs7O1NBck1nQ3dxRDtTQU1oQ2p0QjtTQUNBVjtTQUNBQztTQUNBSTtTQUNBdXRCO1NBNERJRTtTQUNBRDs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7OztJQ3hGSjN5Qjs7Ozs7Ozs7WUErQkErekIsU0FBU3RyRCxHQUFJLHdDQUFKQSxNQUE4QjtZQUV2QzZKLFVBQVVvdUIsYUFBWWo0QjtRQUFHOEIsU0FBSDlCLE1BQVd1ckQsT0FBWHZyRDtJQUN4QjthQUQyQjhCLFVBQUFBLFVBRVEsaUNBRkF5cEQ7TUFHcEIsSUFBQSxNQUFBLDRCQUhZenBELFlBR3pCOztXQUFBZ0Q7O1FBQ0UsV0FKUW16QixhQUlJLGtDQUptQnN6QixNQUdqQ3ptRDtRQUNFLFVBREZBO21CQUFBQTtRQUFBQTs7O01BS2tCO09BQUEsTUFBQSxpQ0FSZXltRDtPQVFmLE1BQUE7Z0JBUk96cEQ7V0FRekI3SSxJQVJ5QjZJOztRQVNYLEdBQUEsa0NBVG1CeXBELE1BUWpDdHlEO1NBQ0UsTUFBQTtRQURGLFVBQUFBO21CQUFBQTtRQUFBQTs7Ozs7O0tBTkEsTUFBQTs7VUFVQXFTO0tBN0JnQjtNQTZCaEJGLDBCQUFBRTtNQWhDRStJO01BQXVCbTNDLGFBb0JIeHJEO01BcEJ3QnlyRCxXQW9CeEJ6ckQ7TUFqQmxCMHJELFVBQVksaUNBSGRyM0MsVUFBNENvM0M7TUFFNUNFLGdDQUNFRDtNQUlBRSxVQUFZLDZCQVBTSjtNQU12Qkssa0NBQ0VELGVBTEZEO01Ba0NHOztzQkFBUyx3QkFKZHZnRDtnQ0ExQkV5Z0Q7S0E0QkEsT0FBQTtjQS9DRnQwQjtjQStDRTs7O1lBS0ZyNEIsY0FBMkIsb0NBQXlDO1lBQ3BFNEMsT0FBTzlCLEdBQUksT0FBSkEsS0FBWTtZQUNuQitULFNBRE8vVCxHQUNNLGFBRE5BLGFBQ2tCO1lBSXpCRCxLQUFLQyxHQUFHTixNQUFNTztJQUNoQixJQUFJd0gsUUFETS9ILE9BRUYsTUFBQSw0QkFGRE07O1NBRVAvRzs7TUFDWSxVQUFBLGtDQUhMK0csTUFFUC9HO01BREl3TyxPQUVHLFdBSFN4SCxHQUNad0g7TUFDSSxVQUFSeE87ZUFBQUE7TUFBQUE7OztXQURJd087R0FJRjtZQUdBdEgsS0FBS0gsR0FBR0M7SUFDRixVQUFBLDRCQURERDs7U0FDUC9HOztNQUNFLFdBRlFnSCxHQUVOLGtDQUZHRCxNQUNQL0c7TUFDRSxVQURGQTtlQUFBQTtNQUFBQTs7OztHQUVJO0dBT1M7SUFBUGlnQix5QkFWSi9ZO0lBV0lpWiwyQkF4Qkp0WDsyQ0FLQS9CLE1Ba0JJbVosUUFDQUU7SUFHSmlCO0lBQ0FuWTtJQUNBSztJQUNBNlY7SUFDQUM7SUFDQVc7SUFDQUQ7SUFDQWpaO0lBQ0FtWjtJQUNBTDtJQUNBRTtJQUNBUDtJQUNBRzs7WUFFQTlZLFFBQWtCb0Q7SUFDcEIsR0FBRyx5QkFEaUJBLElBRWYsT0E1Q0g5RDtJQThDYTtLQUFUNEMsU0FBUyx5QkFKS2tCO0tBS2tCLE1BQUEsK0JBRGhDbEI7S0FDQXlwRCxPQUFPO0tBQ1A5akQsUUFOY3pFO0tBT1YsTUFBQSw0QkFISmxCOztTQUdKN0k7O2tCQURJd087O09BR00sTUFBQTtVQUNEZ2xCLGdCQUFMcnBCO01BQ0Esa0NBTkFtb0QsTUFFSnR5RCxHQUdJbUs7TUFKQXFFLE9BSUtnbEI7TUFIRCxVQUFSeHpCO2VBQUFBO01BQUFBOzs7SUFPQSxXQVZJNkksUUFDQXlwRDtHQVNhO1lBR2pCemhELFVBQVUwUSxXQUFVeGE7SUFBNkIsVUFBQSxXQXhCakRGLFNBd0JvQkU7SUFBNkIsT0FBQSx5QkFBdkN3YTtHQUFrRDtZQUM1RDlKLFVBQVV5c0IsV0FBVW55QjtJQUFPLE9BbEIzQnBMLFFBa0JtQyx5QkFBekJ1OUIsV0FBVW55QjtHQUE4QztZQUVsRXBCLGVBQXlCdWpDO0lBR0UsVUFBQSx5QkFIRkE7SUFHRSxPQUFBO0dBQTZCO1lBR3hEMmUsT0FBTzlyRCxHQUFFK3JEO0lBQ0QsSUFBTnI2QixNQUFNLGlDQURDcTZCO0lBRVgsa0NBRlMvckQsU0FDTDB4QixRQURLMXhCO0lBQUFBLE9BQ0wweEI7O0dBRVM7WUFHWHM2QixhQXpFT2hzRCxHQXlFUWlzRDtJQUNqQjtLQUFJQyxpQkFBZSw0QkFERkQsY0F6RVJqc0Q7V0EwRUxrc0QsbUJBaEdGWixTQXNCT3RyRDtpQkFtRVA4ckQsT0FuRU85ckQsR0EwRUxrc0Q7R0FDb0Q7WUFHdERDLEtBQUtuc0QsR0FBRW9EO0lBQ0ssVUFBQSxpQ0FEUHBEO09BQUFBO0tBQ3FELFVBQUEsNEJBRHJEQTtLQVhMOHJELE9BV0s5ckQsR0FDZ0Q7O0lBQ3ZELGtDQUZPQSxNQUFBQSxNQUFFb0Q7SUFBRnBELE9BR0ssNEJBSExBOztHQUdpQjtZQUd0Qm9zRCxhQUFhcHNEO0lBQ2Y7S0FBSS9HLElBQUksNEJBRE8rRztLQUVYNmQsU0FBUyxrQ0FGRTdkLE1BQ1gvRztJQUVKLGtDQUhlK0csTUFDWC9HO0lBRFcrRyxPQUNYL0c7SUFJSixPQUhJNGtCO0dBR0U7R0FHUSxJQUFad3VDLFlBQVk7WUFDWkMsSUFBSXRzRCxHQUFJLE9BNUZSK1QsU0E0RkkvVCxhQVRKb3NELGFBU0lwc0QsSUFBc0Q7WUFDMUR1c0QsUUFBUXZzRDtJQUFJLE9BN0ZaK1QsU0E2RlEvVDt5Q0FGUnFzRDtjQVJBRCxhQVVRcHNEO0dBQWdFO1lBQ3hFd3NELGFBQWF4c0Q7SUFBcUMsVUFBQSw0QkFBckNBO0lBQXFDLE9BQUEsa0NBQXJDQTtHQUFtRDtHQUNwRCxJQUFaeXNELFlBQVk7WUFDWkMsSUFBSTFzRCxHQUFJLE9BaEdSK1QsU0FnR0kvVCxhQUZKd3NELGFBRUl4c0QsSUFBc0Q7WUFDMUQyc0QsUUFBUTNzRDtJQUFJLE9BakdaK1QsU0FpR1EvVDt5Q0FGUnlzRDtjQURBRCxhQUdReHNEO0dBQWdFO1lBQ3hFUjtRQUFPc0MsbUJBQVF5cEQ7SUFBUyxXQUFqQnpwRCxRQUFrQyxrQ0FBMUJ5cEQ7O1lBRWZMLE1BQU1sckQ7SUFDUixjQURRQTs7S0FHTyxJQUFBLE1BQUEsNEJBSFBBLFVBRUg7O1VBQ0gvRzs7T0FDRSxrQ0FKSStHLE1BR04vRztPQUNFLFVBREZBO2tCQUFBQTtPQUFBQTs7O0tBSE0rRzs7Ozs7O0dBTVE7WUFHZDRzRCxZQUFZNXNELEdBQUVDO0lBQ2hCO21CQURjRDs7S0FJVixXQUpZQyxHQTFCZG1zRCxhQTBCWXBzRDs7R0FPUDtZQUdMMmxDLFVBQVVyMkMsR0FDSixJQUFKMFEsSUExSEZkLFdBK0VBaXRELEtBMkNFbnNELEdBRFExUSxJQUVaLE9BREkwUSxFQUVIOzs7O09BaEVDMFE7T0FEQTVHO09BR0FGO09BakZBQztPQStDQXdRO09BM0JBdlk7T0FDQWlTO09BWUE1VDtPQVJBSjtPQWlDQXdZO09BQ0FHO09BWEF4VztPQUNBSztPQUNBNlY7T0FDQUM7T0FDQVc7T0FDQUQ7T0FDQWpaO09BQ0FtWjtPQUNBTDtPQUNBRTtPQUlBbFo7T0ExQ0FWO09BeUhBeW1DO09BMUNBd21CO09BZUFHO09BQ0FDO09BR0FHO09BQ0FDO09BR0F6QjtPQUZBMXJEO09BV0FvdEQ7T0FwSUF0QjtPQStGQVU7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7WUNuSEVhO0lBTkM7S0FKdURoNUM7S0FBVEM7S0FBVkY7S0FBdkJEO0tBSWIsTUFBQSx3QkFKdURFO0tBR3ZELE1BQUEsd0JBSDhDQztLQUU5QyxNQUFBLHdCQUZvQ0Y7S0FDekMsTUFBQSx5QkFEa0JEO0tBQ2xCLE1BQUE7S0FBQSxNQUFBO0lBR0ssT0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBWUhtNUM7UUFBNkJqNUMscUJBQVZELHFCQUFYRDtJQUNWLFdBRFVBLFdBQVdDLGFBQVVDOzs7Ozs7T0FOM0JnNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FNRkM7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDVEtqMEI7SUFnQ0ZqdkI7Ozs7Ozs7OztJQW1DREs7SUFNQUk7Ozs7Ozs7Ozs7O0dBeEVELFNBRkNxRyxVQWlCQ29vQjtJQWZGOztjQWVFQTtnQkFBQUE7Ozs7Ozs7Ozs7Ozs7U0Fid0M7O1FBQ0Y7O09BRkE7O01BR0E7O2VBV3RDQTs7TUFDQSxPQUFBOzRDQWpCRUQsa0JBZ0JGQzs7O01BREEsT0FBQTs0Q0FmRUQsa0JBZ0JGQzs7Ozs7Ozs7Ozs7Ozs7UUFQQSxPQUFBOzhDQVRFRCxrQkFnQkZDOztPQUxBLE9BQUE7NkNBWEVELGtCQWdCRkM7O01BVEEsT0FBQTs0Q0FQRUQsa0JBZ0JGQzs7S0FIQSxPQUFBOzJDQWJFRCxrQkFnQkZDOztJQUdBLE9BQUEsd0NBbkJFRCxrQkFnQkZDO0dBR3NFO1lBSXZFaHZCO0lBQ0Q7O09BQ1U7O09BQ0M7O09BQ0Q7ZUFDQTs7R0FBd0I7T0FrQmpDelQ7WUFFQ3FQLFlBQ0U0RCxLQUFJQztJQUNOLE9BRE1BOztPQUVHLE9BQUEseUJBRlBEOztPQUdRLE9BQUEseUJBSFJBOztPQUlPLE9BQUEseUJBSlBBO2VBS08sT0FBQSx5QkFMUEE7O0dBSzJDO0dBVWhELFNBTkdELEtBTUNFO0lBQUssSUFIQUQsTUFBTSxpQ0FDVixNQWRGNUQsWUFhTTRELEtBR0xDO0lBRkMsT0FBQTtHQUVVO1lBT2JoSSxVQUFVN0QsR0FBSSxPQXhFZGdULFVBd0V3Qiw2QkFBZGhULElBQWdDO1lBQzFDNEQsVUFBVXRCO0lBQW1CLFVBakQ3QjhKLFVBaURVOUo7SUFBbUIsT0FBQTtHQUFhO1lBSzFDalEsT0FBT1QsR0FBU0MsR0FBSSxPQUFiRCxJQUFTQyxVQUFrQjtZQUNsQzRmLFNBQVE3ZixHQUFTQyxHQUFJLE9BQWJELEtBQVNDLFVBQW1CO1lBQ3BDOGYsU0FBUS9mLEdBQVNDLEdBQUksT0FBYkQsTUFBU0MsVUFBbUI7WUFDcENxRixTQUFPdEYsR0FBU0MsR0FBSSxPQUFiRCxNQUFTQyxVQUFrQjtZQUNsQ3NGLFNBQU92RixHQUFTQyxHQUFJLE9BQUpBLElBQVRELFVBQTJCO1lBQ2xDd0YsU0FBUXhGLEdBQVNDLEdBQUksT0FBSkEsS0FBVEQsVUFBNEI7WUFDcENnRyxVQUFXaEcsR0FBU0MsR0FBSSxPQUFBLDBCQUFiRCxHQUFTQyxHQUFzQjtZQUMxQ0YsV0FBWUMsR0FBU0MsR0FBSSxPQUFBLDBCQUFiRCxHQUFTQyxHQUF1QjtPQUM1QzhIO1lBQ0FmLE1BQU9oSCxHQUFTQyxHQUFJLE9BQWJELE1BQVNDLFVBQWtCO1lBQ2xDQyxJQUxRRixHQUFTQyxHQUtDLE9BTERBLEtBQVRELElBQUFBLElBQVNDLEVBS3dCO1lBQ3pDRSxJQVZRSCxHQUFTQyxHQVVDLE9BVlZELEtBQVNDLElBQVRELElBQVNDLEVBVXdCOzs7Ozs7U0ExQ3pDOEc7U0FFQ3FQO1NBVUEyRDtTQTNERHFIO1NBd0JBNUc7U0FnREF2STtTQUNBRDtTQUNBK0k7Ozs7Ozs7Ozs7Ozs7O1lBMEJGMGlEO0lBQVUsc0JBQ0UsaUJBQ0Msa0JBQ0Q7O0dBQUc7WUFHZkM7SUFBYzs7T0FDUDs7T0FDQzs7T0FDRDs7T0FDQSxPQUFBOztHQUErQztZQUd0RDlyRCxPQUFPc1IsR0FBSSxPQWJYdTZDLFFBYW1CLDBCQUFadjZDLElBQTJCO1lBQ2xDeTZDLFdBQVdqdEQ7SUFBZ0IsVUFSM0JndEQsWUFRV2h0RDtJQUFnQixPQUFBO0dBQWU7WUFFMUM2ZjtJQUFPOztPQUNBOztPQUNDOztPQUNEO2VBQ0E7O0dBQUc7WUFHVjlxQixTQUFNbVIsS0FBRWxHO0lBQ1YsT0FEUWtHLFdBQUVsRztLQUdpQyxJQUFBLE1BcEJ6Q2d0RCxZQWlCUWh0RCxJQUdpQixNQXBCekJndEQsWUFpQk05bUQ7S0FHTyxPQTFCYjZtRCxRQTBCYTs7SUFETTtHQUN1Qzs7OztPQTFEeEQ5aUQ7T0FuQ0NMOzs7Ozs7O09Ba0REOVU7T0FKQXFhO09BRUF2YTtPQUNBQztPQUpBOUU7T0FFQXNmO09BT0EvWTtPQURBZTtPQUdBNUg7T0FEQUQ7T0FKQThGO09BQ0FqRzs7Ozs7OztPQTRCRjZSO09BQ0ErckQ7T0FkQUY7T0FNQUM7T0FVQW50QztPQU9BOXFCOzs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDeEdFbTREO0lBb0ZDQztJQTZCRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBdElEbmpELElBR2FvakQ7SUFEZixJQVFrQnJxRCxJQVBIcXFELFVBT0s3MEM7SUFDWjtVQURVeFY7S0FHc0I7TUFIdEJ5cEIsTUFBQXpwQjtNQUdSc3FELGdCQUhRdHFEO01BQUVrbkIsZ0JBR1ZvakMsZ0JBSFU5MEM7S0FBRnhWLElBQUF5cEI7S0FBRWpVLE1BQUEwUjs7SUFFSjtLQUFBLE1BQUEsMEJBRkkxUjtLQVBMb1ksTUFBQXk4QjtLQUFFbGpDO0tBTWYsTUFBQTtJQUxHO1VBRFV5RztNQUVGLFVBQUEsMEJBRkl6RztNQU1mLE9BQUE7O0tBSG1DO01BSHRCNlcsTUFBQXBRO01BR1IyOEIsZ0JBSFEzOEI7TUFBRTQ4QixnQkFHVkQsZ0JBSFVwakM7S0FBRnlHLE1BQUFvUTtLQUFFN1csUUFBQXFqQzs7R0FhRTtHQU1uQixTQUhFOThDLFVBR0UrOEMsVUFrQ0FDO0lBbENKOztjQWtDSUE7Z0JBQUFBOzs7Ozs7Ozs7O1FBVGtEOztPQUVsRCxPQUFBOzZDQTVCQVIsa0JBbUNBUTs7TUFMQSxPQUFBOzRDQTlCQVIsa0JBbUNBUTs7ZUFBQUE7O01BQ0EsT0FBQTs0Q0FwQ0FSLGtCQW1DQVE7OztNQURBLE9BQUE7NENBbENBUixrQkFtQ0FRO1NBcEJzQkM7O1FBQUFBOztTQUFBQTtVQUFBQTtXQUFBQTtXQUFBQTtXQUFBQTs7T0FpQlIsT0FBQTs2Q0FoQ2RULGtCQW1DQVE7O1VBaEMyREU7U0FBQUEsbUJBQUFBO09BSXZDO1FBRGZwdEMsV0FIc0RvdEM7UUFJcERudEMsV0FBYSxXQU5wQmd0QyxVQUtLanRDO09BRUYsV0FESUM7O01BR0osT0FBQTs7ZUFWSHlzQztlQWVzQlM7ZUFvQnRCRDs7U0FwQjJEeDhDO1FBQUFBLG1CQUFBQTtNQUl2QztPQURmQyxXQUhzREQ7T0FJcERFLFdBQWEsV0FsQnBCcThDLFVBaUJLdDhDO01BRUYsV0FESUM7O0tBR0osT0FBQTs7Y0F0Qkg4N0M7Y0Flc0JTO2NBb0J0QkQ7O0lBR0EsT0FBQSx3Q0F0Q0FSLGtCQW1DQVE7R0FHc0U7WUFHeEU1akQsVUFFRWlMO0lBREosOEJBUWlCOztLQUxJLElBRFo4NEMscUJBQ0RDLFdBQWEsV0FGakIvNEMsVUFDSzg0QztLQUVMLHdCQURJQzs7SUFHYSxJQURaQyxxQkFDREMsV0FBYSxXQUxqQmo1QyxVQUlLZzVDO0lBRUwsd0JBRElDO0dBRXVDO1lBRzVDcGtELGVBQ0N1TDtJQUNKOzs7O3dDQURJQTs0Q0FBQUE7R0FrQkg7R0FhQSxTQUZDODRDLDRCQWdCQ0M7SUFkRjs7Y0FjRUE7Z0JBQUFBOzs7Ozs7Ozs7O1FBWmdEOztPQURrQjs7TUFFQTs7ZUFXbEVBOztNQUNBLE9BQUE7NENBaEJFZixrQkFlRmU7OztNQURBLE9BQUE7NENBZEVmLGtCQWVGZTs7Ozs7Ozs7Ozs7T0FORyxPQUFBOzZDQVREZixrQkFlRmU7O01BUkcsT0FBQTs0Q0FQRGYsa0JBZUZlOztLQUhHLE9BQUE7MkNBWkRmLGtCQWVGZTs7SUFFYyxPQUFBLHdDQWpCWmYsa0JBZUZlO0dBRW9GO1lBSXJGQztJQUNELHNCQUN3QixtQkFDVCxvQkFDUzs7R0FBc0M7O0lBaUI3REM7OztZQUtDQyw4QkFHRS9rRCxLQUFJQztJQUNOLE9BRE1BOztPQUVpQixPQUFBLHlCQUZyQkQ7O09BR1ksT0FBQSx5QkFIWkE7ZUFJcUIsT0FBQSx5QkFKckJBOztHQUl5RDtHQVU5RCxTQU5HZ2xELHlCQU1DL2tEO0lBQUs7S0FIQUQsTUFBTTtLQUNWLE1BZkYra0QsOEJBY00va0QsS0FHTEM7SUFGQyxPQUFBO0dBRVU7WUFLYmxKLElBQUlMLEdBQUdDO0lBQ1QsVUFETUQsZ0JBSVM7YUFKVEEsVUFFQ3V1RCxPQUZEdnVELE1BRVMsV0FBSyxXQUZYQyxHQUVGc3VEO1FBQ0FDLE9BSER4dUQ7SUFHUyxXQUFLLFdBSFhDLEdBR0Z1dUQ7R0FDaUI7WUFHdEJDLGVBQWV6dUQsR0FBT29ELEdBQUcvTTtJQUMzQixVQURpQjJKLGdCQUlGO2FBSkVBO1NBRVZ1dUQsT0FGVXZ1RDtZQUVGLFdBRlkzSixTQUVwQms0RCxNQUZpQm5yRDs7UUFHakJvckQsT0FIVXh1RDtXQUdGLFdBSFkzSixTQUdwQm00RCxNQUhpQnByRDtHQUlMO1lBR2pCc3JELGVBQWUxdUQsR0FBT29ELEdBQUcvTTtJQUMzQixVQURpQjJKLGdCQUlGO2FBSkVBO1NBRVZ1dUQsT0FGVXZ1RDtZQUVGLFdBRlkzSixTQUFIK00sR0FFakJtckQ7O1FBQ0FDLE9BSFV4dUQ7V0FHRixXQUhZM0osU0FBSCtNLEdBR2pCb3JEO0dBQ1k7WUFHakJHLGVBQWdCQyxPQUFPQyxPQUFPeDREO0lBQ2hDLFVBRGtCdTRELG9CQUVIO1FBQ1JFLFVBSFdGO2NBQU9DLG9CQUtQO1FBQ1JFLFVBTmVGO2VBTU8sV0FOQXg0RCxTQUd6Qnk0RCxTQUdHQztHQUE4QztZQVF0REMsd0JBQXlCSixPQUFPQyxPQUFNenJELEdBQUcvTTtJQUMzQyxHQWZFczRELGVBY3lCQyxPQUFPQyxPQUFTeDREO0tBSHRDO0lBS0UsT0E5QkxvNEQsZUE0QnlCRyxPQUFheHJELEdBQUcvTTtjQXJCekNxNEQsZUFxQmdDRyxPQUFNenJELEdBQUcvTTs7R0FNOUI7WUFHWDQ0RCxzQkFBdUJMLE9BQU9DLE9BQU16ckQsR0FBRy9NO0lBQ3pDLGFBVkUyNEQsd0JBU3VCSixPQUFPQyxPQUFNenJELEdBQUcvTTtHQUdPOzs7O09BN045QzRUO09BbUJBeUc7T0EyQ0E1RztPQVlDRjtPQW9HRHZKO09BT0FvdUQ7T0FPQUM7T0E4QkFPO09BdkJBTjtPQXJFQVI7T0F0QkFGO09BOEJDYjtPQWFEZ0I7T0FLQ0M7T0FXQUM7T0E4Q0RVOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUMzR0lFO0lBb1BGamxEO0lBcUJBMHhCOzs7OztZQTdXQXRsQyxRQUNFZ2YsT0FBUXRNLE9BQVFDO0lBQ3BCLEdBQUcsb0NBRFNELE9BQVFDLFFBRWY7Y0FGT0Q7d0JBQVFDLE9BTVU7O21CQU5WQSxnQ0FBQUE7U0FLS21tRCxZQUxMbm1ELFVBS1pvbUQsV0FMSXJtRDtLQUs2QixPQUFBLFdBTHJDc00sT0FLSSs1QyxVQUFpQkQ7O0lBRWIsT0FBQSxhQVBBcG1ELE9BQVFDO0dBT2dDO1lBR2xEMVMsTUFDRStlLE9BQVFsTSxPQUFRQztJQUNsQixHQUFHLG9DQURPRCxPQUFRQyxRQUViO2NBRktEO3dCQUFRQyxPQU1ZOzttQkFOWkEsZ0NBQUFBO1NBS09pbUQsWUFMUGptRCxVQUtWa21ELFdBTEVubUQ7S0FLK0IsT0FBQSxXQUx2Q2tNLE9BS01pNkMsVUFBaUJEOztJQUViLE9BQUEsV0FQRmxtRCxPQUFRQztHQU9nQztZQUdsRFUsVUFDRXlsRDtJQUFKLDhCQUVrQjtRQURWQztJQUFXLHdCQUE4QyxXQUQ3REQsVUFDSUM7R0FDd0M7R0FoQzlCO0lBQUEsbUJBT2hCbjVELFNBV0FDLE9BV0F3VDtJQVNzQjtJQUlIO0lBSVE7Ozs7Ozs7WUFRM0J6UyxVQUdFbzRELE9BQVFDLE9BQVFydUIsT0FBUUM7SUFDNUI7S0FBYXF1QixRQURPdHVCO0tBQ2hCdXVCLFFBRGdCdnVCO0tBRVB3dUIsUUFGZXZ1QjtLQUV4Qnd1QixRQUZ3Qnh1QjtLQWtCMUI5dUIsSUFmSSxXQUhGaTlDLE9BQ0FHLE9BQ0FFO2FBZ0JGdDlDLEdBQUssT0FBTEE7SUFiRyxHQUFBLG9DQUpRbTlDLE9BQ0FFLFFBSU47Y0FMTUY7O2VBQ0FFLG9DQUFBQTtVQU9rQkUsWUFQbEJGLFVBT0RHLFdBUkNMO01BUWtDLE9BQUEsV0FUbkNELE9BU0FNLFVBQW1CRDs7Ozs7Z0JBUGxCRixxQ0FBQUE7T0FVUDtRQUQrQkksWUFUeEJKO1FBU0VLLFdBVkZQO1FBV01RLFFBREpEO1FBQ0xFLFFBREtGO1FBRUlHLFFBRmtCSjtRQUUzQkssUUFGMkJMO1FBSzVCeDlDLE1BRkksV0FkRGk5QyxPQVlGVSxPQUNBRTtvQkFHRDc5QyxNQURLLFdBZkZpOUMsT0FZT1MsT0FDQUUsU0FHVjU5Qzs7O29CQWRJbzlDLG9DQUFBQTtVQVFvQlUsWUFScEJWLFVBUUFXLFdBVEFiO01BU29DLE9BQUEsV0FWckNELE9BVUNjLFVBQW9CRDs7SUFPbkIsT0FBQSxhQWhCRFosT0FDQUU7R0FnQkw7WUFHTnY0RCxRQUlFbTRELE9BQVFDLE9BQVFuNkMsT0FBUUM7SUFDMUI7S0FBYWk3QyxRQURLbDdDO0tBQ2RtN0MsUUFEY243QztLQUVMbzdDLFFBRmFuN0M7S0FFdEJvN0MsUUFGc0JwN0M7S0FJeEIsTUFBQSxXQUpBaTZDLE9BQ0VpQixPQUNBRTtJQUVGO0tBQ0ksR0FBQSxvQ0FKT0gsT0FDQUUsUUFJTDtlQUxLRjs7Z0JBQ0FFLG9DQUFBQTtXQU9tQkUsWUFQbkJGLFVBT0FHLFdBUkFMO09BUW1DLE9BQUEsV0FUdENmLE9BU0dvQixVQUFtQkQ7Ozs7O2lCQVBuQkYscUNBQUFBO1FBVU47U0FEK0JJLFlBVHpCSjtTQVNHSyxXQVZIUDtTQVdPUSxRQURKRDtTQUNMRSxRQURLRjtTQUVJRyxRQUZrQko7U0FFM0JLLFFBRjJCTDtTQUdSLE1BQUEsV0FkcEJyQixPQVlDd0IsT0FDQUU7UUFDbUIsYUFEdkIsV0FiRzFCLE9BWVV1QixPQUNBRTs7O3FCQVhQUixvQ0FBQUE7V0FRcUJVLFlBUnJCVixVQVFDVyxXQVREYjtPQVNxQyxPQUFBLFdBVnhDZixPQVVJNEIsVUFBb0JEOztlQUtuQixXQWRGWixPQUNBRTs7OztJQWFFO0dBQXVDO0dBV3hELFNBUkVqZ0QsVUFRRTZnRCxVQUFZQyxVQTRFWkM7SUE1RUosU0E0RUlBO2VBQUFBOzs7O09BMUVpQjtRQUVYQztRQUhlQztRQUNqQkMsV0FBYSxXQUZqQkwsVUFDcUJJO09BSW5CO2lCQURJRDs7VUFHbUJHLFdBSG5CSDs7WUFHbUJHO2VBQUFBOztpQkFBQUE7O21CQVFYO21CQURMO2tEQWZUM0Msa0JBS013QztpQkFRRztnREFiVHhDLGtCQUtNd0M7ZUFNRzs4Q0FYVHhDLGtCQUtNd0M7OzttQkFBQUE7Ozs7ZUFZcURJLHdCQUdsREM7Y0FBQUE7ZUFBQUE7Z0JBQUFBO3dCQXlDSzs7OztrQkE1QzZDRCxtQkFBQUE7b0JBeUI3Q0UsV0F6QjZDRjs7O2lCQTBCL0MsU0FERUU7NEJBQUFBOzs7O29CQUltQjtxQkFEZ0IzdUI7cUJBQVpDO3FCQUNqQkMsV0FBYSxXQTdDckJpdUIsVUE0Q3lCbHVCO3FCQUVqQkUsV0FBYSxXQTlDckJndUIsVUE0Q3FDbnVCO3FCQUZqQzR1QixlQUdJMXVCLFVBQ0FDOzs7Ozs7a0JBSkp5dUI7b0JBT0E7bURBbERoQi9DLHFCQTBDYzhDOzswQ0FDRUM7Ozs7O2tCQWNKOztvQkF6RFovQztvQkFvQlM2QztvQkFmSEw7Ozs7Ozs7aUJBWXFESSxtQkFBQUE7ZUFnQjlCO2dCQURmSSxXQWY2Q0o7Z0JBZ0IzQ0ssV0FBYSxXQWhDakJYLFVBK0JFVTtxQ0FDRUM7Ozs7O2lCQUdKOzttQkFwQ1pqRDttQkFvQlM2QzttQkFmSEw7Ozs7Ozs7Z0JBWXFESSxtQkFBQUE7Y0FNOUI7ZUFEZk0sV0FMNkNOO2VBTTNDTyxXQUFhLFdBdEJqQmIsVUFxQkVZO29DQUNFQzs7Ozs7Z0JBR0o7O2tCQTFCWm5EO2tCQW9CUzZDO2tCQWZITDs7Ozs7Ozs7O2NBMERBOzhDQS9ETnhDLGtCQUtNd0M7Ozs7OzthQThEQTs2Q0FuRU54QyxrQkFLTXdDOzs7WUFERlk7Ozs7Ozs7U0FBQUE7V0FvRUE7MkNBeEVKcEQsa0JBS013Qzs7T0F1RU4sV0F6RUlFLFVBQ0FVOzs7O0lBMEVKLE9BQUE7MENBOUVBcEQscUJBNkVBdUM7R0FDaUY7WUFHbkY3bEQsWUFPRTJtRCxVQUFZQztJQUFoQjtLQUF5Q0M7S0FBWkM7S0FDdkJDLFdBQWEsV0FEZkosVUFBeUJHO1dBQVlEOzs7TUFJN0JHLFFBSjZCSDtNQUVuQ0ksNEJBR2dELFdBTHRDTCxVQUlKSTs7S0FRZ0I7TUFKYkUsUUFSMEJMO01BV2RNLFdBSFpEO01BR0FFLFdBSEFGO01BSUFHLFdBQWEsV0FaWlQsVUFXRFE7TUFFQUUsV0FBYSxXQWJaVixVQVdXTztNQVRyQkYsb0NBVVNJLGNBQ0FDOzs7TUFQRkMsUUFONEJWO01BRW5DSSw0QkFLaUQsV0FQdkNMLFVBTUhXO0lBV1gsZUFoQklSLGNBQ0FFO0dBZXlDO1lBRzVDanBELGVBS0N3cEQsZ0JBQWlCQztJQUNuQjs7YUFERUQ7Ozs7OzsyQ0FBaUJDOzs2Q0FBQUE7Ozs7OztrQ0FBQUEsb0JBQUFBOzs7R0FzQ2xCO0dBaE55QjtJQUFBO1VBSTFCaDhELFdBd0JBQyxTQXNCQW9aLFdBd0ZBOUUsYUEyQkNoQzs7OztZQXlERDNSLFVBUUVxN0QsVUFBV0MsV0FBWUMsT0FBUUM7SUFDbkMsR0FBRyxvQ0FEd0JELE9BQVFDLFFBRTlCO2NBRnNCRDs7ZUFBUUMsb0NBQUFBO01BUS9CO09BRHlCQyxZQVBNRDtPQU96QkUsV0FQaUJIO09BUVZJLFFBRFBEO09BQ0ZFLFFBREVGO09BRU9HLFFBRllKO09BRXJCSyxRQUZxQkw7T0FLdEJsaEQsSUFGSSxXQVZQOGdELFVBUUlPLE9BQ0FFO21CQUdEdmhELElBREssV0FYRytnRCxXQVFFSyxPQUNBRSxTQUdWdGhEOzs7OztnQkFaNEJpaEQsb0NBQUFBO1dBS05PLFlBTE1QLFVBS3pCUSxXQUxpQlQ7T0FLa0IsT0FBQSxXQUx6Q0YsVUFLTVcsVUFBbUJEOzs7b0JBTE1QLG9DQUFBQTtVQU1KUyxZQU5JVCxVQU14QlUsV0FOZ0JYO01BTW9CLE9BQUEsV0FOaENELFdBTUpZLFVBQW9CRDs7SUFPbkIsT0FBQSxhQWJlVixPQUFRQztHQWFpQjtZQUdsRHY3RCxRQVFFbzdELFVBQVdDLFdBQVlhLE9BQVFDO0lBQ2pDLEdBQUcsb0NBRHNCRCxPQUFRQyxRQUU1QjtjQUZvQkQ7O2VBQVFDLG9DQUFBQTtNQVE3QjtPQUR5QkMsWUFQSUQ7T0FPdkJFLFdBUGVIO09BUVJJLFFBRFBEO09BQ0ZFLFFBREVGO09BRU9HLFFBRllKO09BRXJCSyxRQUZxQkw7T0FHRixNQUFBLFdBVnpCaEIsVUFRTW1CLE9BQ0FFO01BQ21CLGFBRHZCLFdBVFNwQixXQVFJaUIsT0FDQUU7Ozs7O2dCQVRnQkwsb0NBQUFBO1dBS0pPLFlBTElQLFVBS3ZCUSxXQUxlVDtPQUtvQixPQUFBLFdBTDNDZCxVQUtRdUIsVUFBbUJEOzs7b0JBTElQLG9DQUFBQTtVQU1GUyxZQU5FVCxVQU10QlUsV0FOY1g7TUFNc0IsT0FBQSxXQU5sQ2IsV0FNRndCLFVBQW9CRDs7SUFLbkIsT0FBQSxXQVhhVixPQUFRQztHQVdpQjtZQUdsRHRsQyxZQU9FaW1DLGFBQWVDO0lBQW5COztLQVMwQjtNQUpoQkM7TUFHZUMsV0FIZkQ7TUFHR0UsV0FISEY7TUFJR0csV0FBYSxXQVR0QkwsYUFRU0k7TUFFQUUsV0FBYSxXQVZQTCxjQVFNRTtLQUZyQixnQ0FHU0UsY0FDQUM7OztTQVRIQztLQUNOLHdCQUFnRCxXQUZoRFAsYUFDTU87O1FBRUNDO0lBQ1Asd0JBQWlELFdBSmxDUCxjQUdSTztHQVNKO0dBekVZO0lBQUEsb0JBUWpCdjlELFdBd0JBQyxTQXNCQTYyQjtJQWdDQWwyQjs7O1lBRUFDLGtCO1lBRUF5OEMsbUJBQ0QseUJBRW9DO0dBYmY7SUFBQSx1QkFNcEIxOEMsV0FDQW9SLEtBQ0FuUixTQUVBeThDO0lBaUJBNzdDOzs7WUFFQUMsa0I7WUFFQTg3RCxtQkFDRCx5QkFFZ0Q7R0FickIsaUNBTTFCLzdELFdBQ0FpaUMsT0FDQWhpQyxTQUVBODdEO2dFQW1wQ04sV0FBVTtnQ0FBVjtnQ0FBQTtnQ0FBQTs4Q0FBQTsrREFtWUEsV0FBVTsrQkFBVjsrQkFBQTs4Q0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O3VFQ3IwQ0E7R0FBVTtnQ0FBVjtnQ0FBQTtnQ0FBQTs4Q0FBQTsrREFpUEEsV0FBVTsrQkFBVjsrQkFBQTsrQkFBQTs4Q0FBQTs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzF5Qkl4b0Q7Ozs7Ozs7Ozs7Ozs7WUFlRXlvRDtJQUFTLDhCQUNBO3VCQUNDO1FBQ0t6c0M7SUFBUyxPQUFUQTtHQUFVO1lBR3pCbm5CO0lBQVMsOEJBQ0E7dUJBQ0M7UUFDUXBFO0lBQU0sT0FBTkE7R0FBTztZQUl2Qmk0RCxTQUFTL0csT0FBTUMsT0FBTXhuRCxhQUFZa0g7SUFDbkMsR0FEV3FnRDs7TUFHSEUsVUFIR0Y7YUFHTSxXQUhNdm5ELGFBR2Z5bkQsU0FIMkJ2Z0Q7Ozs7UUFBbEJzZ0Q7VUFPVkUsVUFQVUY7YUFPRCxXQVBPeG5ELGFBQVlrSCxHQU81QndnRDs7Ozs7O0lBREc7R0FDNkI7WUFFakMzZ0QsS0FBS3dnRCxPQUFNQyxPQUFNeG5ELGFBQVlySDtJQUNuQyxJQURXOHVELFVBQUFGLE9BQXdCMW9ELE1BQUFsRztJQUNuQztlQURtQ2tHLGtCQUV4QjtjQUZ3QkE7VUFHNUJxSSxJQUg0QnJJO01BR3ZCLE9BWlZ5dkQsU0FTUzdHLFNBQU1ELE9BQU14bkQsYUFHaEJrSDs7S0FFSTtNQURTaUUsSUFKZXRNO01BSWxCK2lCLElBSmtCL2lCO01BQUF1QixJQUFBdkI7TUFJeEJ3NkIsTUFKd0J4NkI7TUFJM0JsRCxJQUoyQmtEO01BSzdCMHZELEtBM0JORixPQTBCUTF5RDtNQUVGNnlELEtBNUJOSCxPQXNCbUNqdUQ7TUFPN0IsT0FBQSw0QkFGQW11RCxJQUNBQzthQUNKOztNQUNPO09BQUEsT0FBQSw0QkFISEQsSUFDQUM7Y0FGVzVzQyxNQUlSOztPQUNXO1FBQUEsT0F6QnBCbm5CLE9BZ0JtQzJGO1FBUzFCLE9BekJUM0YsT0FvQlFrQjtRQUtDLE9BQUE7ZUFMV3dQLE1BS1g7O1FBQ0osV0FuQkhtakQsU0FTUzdHLFNBQU1ELE9BQU14bkQsYUFJWnE1QjtRQU1OO1NBQ0EsV0FYQ3R5QixLQUFLMGdELGFBSUFwdUIsTUFKWXI1QixhQUlmckU7U0FPSDtVQUNLLElBWkM4eUQsY0FJQXAxQjtVQUpBb3VCLFVBQUFnSDtVQUF3QjV2RCxNQUFBdUI7Ozs7Ozs7Ozs7Ozs7Ozs7S0FXOUI7O0dBQ2lDO1lBdEJ0Q3N1RCxXQXdCRS8xRCxHQUFHcUgsYUFBZSxPQWRkK0csV0FjRC9HLGFBQUhySCxHQUE4QztZQUdoRCtULGdCQUFXLHlDQUVhO1lBUXhCN1UsT0FBTzhELEdBQUV1TCxHQUFFOUc7SUFDYixVQURTekU7U0FDTDR5RDtrQkFESzV5RCxVQUNMNHlELGlCQUllSSxNQUxWaHpELE1BQ0w0eUQsS0FJZUk7SUFFbkIsVUFQYXZ1RDtTQU9Ub3VEO2tCQVBTcHVELFVBT1RvdUQsaUJBSWVJLE1BWE54dUQsTUFPVG91RCxLQUllSTs7S0FFZmh0QztPQU5BNHNDLE1BTkFEO1VBWXFCLDRCQVpyQkE7VUFZaUMsNEJBTmpDQztJQU9KLFNBREk1c0MsR0FFQyxXQWZNMWE7Y0FBRnZMO1NBaUJIa3pEO2tCQWpCR2x6RCxVQWlCSGt6RCxpQkFJa0IxeEQsTUFyQmZ4QixNQWlCSGt6RCxLQUlrQjF4RDtJQUV0QixVQXZCV2lEO1NBdUJQMHVEO2tCQXZCTzF1RCxVQXVCUDB1RCxpQkFJa0J6NEQsSUEzQlgrSixNQXVCUDB1RCxLQUlrQno0RDtJQUVKLFdBQUEsNEJBWmR3NEQsSUFNQUM7SUFNSixXQTdCT256RCxHQUFFdUwsR0FBRTlHLEdBYVR3aEIsR0FnQmdCO0dBQWE7WUFLL0JtdEMsK0JBQWtDajNELEtBQUtjO2FBQ2pDbU8sS0FBS29FLEdBQUd2UyxHQUFFaEg7S0FDaEIsUUFEV3VaO2FBQUFBOztTQUVKOztTQUVHLElBQUorb0MsTUFBSSxXQUpJdDdDLEdBQUVoSCxJQUtkLFdBRElzaUQ7O1NBR0s7VUFBTDhhLEtBQUssV0FQR3AyRCxHQUFFaEg7VUFRVnE5RCxNQUFJLFdBUklyMkQsR0FRRiw0QkFSSWhIO1NBU2QsT0E1Q0ZpRyxXQTBDTW0zRCxLQUNBQzs7U0FHSztVQUFMQyxPQUFLLFdBWEd0MkQsR0FBRWhIO1VBWVZ1OUQsTUFBSSxXQVpJdjJELEdBWUYsNEJBWkloSDtVQWFWdzlELEtBQUssV0FiR3gyRCxHQWFELDRCQWJHaEg7U0FjSyxPQWpEckJpRyxXQThDTXEzRCxPQUNBQyxTQUNBQzs7S0FHYztNQUFkQyxjQUFjLDZCQWhCVGxrRDtNQWlCVSxPQUFBLDRCQWpCVkEsR0FnQkxra0Q7TUFDQUMsZUFBZTtNQUNmcnZCLE9BbEJBbDVCLEtBZ0JBc29ELGFBaEJRejJELEdBQUVoSDtNQW1CVnUyQixJQUFJLFdBbkJJdnZCLEdBbUJGLDRCQW5CSWhILEdBZ0JWeTlEO01BSThCLE9BQUEsNEJBcEJwQno5RCxHQWdCVnk5RDtNQUlBbnZCLFFBcEJBbjVCLEtBaUJBdW9ELGNBakJRMTJELEdBb0JxQjtLQUNqQyxPQXhERmYsT0FxRE1vb0MsTUFDQTlYLEdBQ0ErWDtJQUNlO0lBRXZCLE9BdkJRbjVCLEtBRDRCalAsS0FBS2M7R0F3QjVCO1lBR1gyMkQsMEJBQTBCaHlELE9BQU95QztJQUNuQyxJQUFJd3ZELGVBRHdCanlEOzs7S0FFNUIsUUFESWl5RDtNQUkyQyw0QkFMbkJqeUQ7TUFLSCxRQUFBLFdBTFV5Qyw4QkFBUHpDOztRQUV4QjA2QjttQkFLT3JtQztXQUFLO1lBQU8sT0FBQSw0QkFObkI0OUQ7WUFNbUIsT0FBQSxrQ0FBWjU5RDtXQUFLLHdCQVBZMkw7VUFPZ0I7Ozs7U0FMeEMwNkIsZ0JBSU9ybUMsR0FBSyx3QkFOWTJMLE9BTWpCM0wsT0FBQUEsR0FBYzs7SUFHekIsT0FwQ0VtOUQsK0JBNEJFUyxjQUNBdjNCO0dBT3NEO1lBR3hEdzNCLGdCQUFnQmx5RCxPQUFPeUM7SUFDekIsVUFEa0J6Qzs7S0FJSixPQUFBO2NBN0lkcUk7dUJBNkltQnhGO2VBQ2Y7Z0JBQzhCLHdCQU5oQjdDO2dCQVFWM0w7a0JBRkksV0FOYW9PLDhCQUFQekM7Z0JBS1ZteUQ7d0JBR0E5OUQ7cUJBREs7c0JBSE13TztzQkFHRzs7cUJBQ2R4TztnQkFFUyxPQUFBLDRCQVZDMkw7OztvQkFVZEU7O2lCQUNxQztrQkFBQSxPQUFBLDRCQURyQ0E7a0JBQzhCLHdCQVhoQkY7a0JBYVZncEI7b0JBRkk7c0JBWGF2bUIsOEJBQVB6QyxPQVVkRSxTQUFBQTswQkFHSThvQjtrQkFESztvQkFSTW5tQjtvQkFRRzs7MEJBQ2RtbUIscUJBUkFtcEM7a0JBV0U7b0JBWlN0dkQ7b0JBYVA7O2lCQVBSLFdBQUEzQzs2QkFBQUE7aUJBQUFBOzs7ZUFTQSxXQS9CRjh4RCwwQkFZZ0JoeUQsT0FBT3lDO2NBbUJtQztJQWpCeEMsV0FkbEJ1dkQsMEJBWWdCaHlELE9BQU95QztHQW1Cb0M7WUFRM0QydkQsSUFBSWgwRCxHQUFFdUwsR0FBRTlHO0lBQ1YsVUFETXpFO1NBQ0Y0eUQ7a0JBREU1eUQsVUFDRjR5RCxpQkFJZUksTUFMYmh6RCxNQUNGNHlELEtBSWVJO0lBRW5CLFVBUFV2dUQ7U0FPTm91RDtrQkFQTXB1RCxVQU9Ob3VELGlCQUllSSxNQVhUeHVELE1BT05vdUQsS0FJZUk7T0FFWCw0QkFOSkosU0FOQUQ7ZUFERTV5RDtNQWdCTyxNQUFBO2NBaEJQQTtNQWlCUSxNQUFBO0tBRU0sSUFERmkwRCxLQWxCWmowRCxNQWtCUWswRCxLQWxCUmwwRCxNQWtCSW0wRCxLQWxCSm4wRCxNQW1CYyxPQXhLbEIweUQsT0F1S2dCdUI7Z0JBdktoQnZCLE9BdUtReUIsS0FFWSxPQXhIcEJqNEQsT0FzSFFpNEQsSUFBSUQsSUF0SFpoNEQsT0FzSGdCKzNELElBbEJWMW9ELEdBQUU5RztlQWtCUXd2RDtNQUtELE1BQUE7Y0FMQ0E7TUFTa0QsSUFBNUNHLE1BVE5ILE9BU0NJLFFBVERKLE9BU0pLLE1BVElMLE9BU2tELE9BL0hsRS8zRCxPQStIc0JrNEQsS0EzQmhCN29ELEdBQUU5RztNQTJCMEQsT0EvSGxFdkksT0FBQUEsT0FzSFFpNEQsSUFBSUQsSUFTQUksTUFBS0Q7O1NBSE5FLE1BTktOO0tBT0gsS0F2SWJsakQsU0FnSVFvakQ7TUFPRixNQUFBO0tBQ2dDLFdBOUh0Q2o0RCxVQW9HTXFQLEdBQUU5RztLQTBCOEIsT0E5SHRDdkksT0FBQUEsT0FzSFFpNEQsSUFBSUQsUUFNREs7O09BSUEsNEJBM0JUM0IsU0FNQUM7ZUFQTXB1RDtNQStCRyxNQUFBO2NBL0JIQTtNQWdDSSxNQUFBO0tBRU0sSUFERit2RCxLQWpDUi92RCxNQWlDSWd3RCxLQWpDSmh3RCxNQWlDQWl3RCxLQWpDQWp3RCxNQWtDVSxPQXZMbEJpdUQsT0FzTFFnQztnQkF0TFJoQyxPQXNMZ0I4QixLQUVULE9BdklQdDRELE9BQUFBLE9Bb0dJOEQsR0FBRXVMLEdBaUNFbXBELEtBQUlELElBQUlEO2VBQVJFO01BS08sTUFBQTtjQUxQQTtNQVN3RCxJQUExQ0MsTUFUZEQsT0FTU0UsUUFUVEYsT0FTSUcsTUFUSkgsT0FTd0QsT0E5SWhFeDRELE9BOElzQnk0RCxLQVRWRixJQUFJRDtNQVNnRCxPQTlJaEV0NEQsT0FBQUEsT0FvR0k4RCxHQUFFdUwsR0EwQ01zcEQsTUFBS0Q7O1NBSE5FLE1BTkhKO0tBT0ssS0F0SmIzakQsU0ErSWdCeWpEO01BT1YsTUFBQTtLQUM4QixXQTdJcEN0NEQsVUFxSVl1NEQsSUFBSUQ7S0FRb0IsT0E3SXBDdDRELE9BQUFBLE9Bb0dJOEQsR0FBRXVMLE9BdUNLdXBEOzs7S0FLUDd1QztPQXJDRjRzQyxNQU5BRDtVQTJDdUIsNEJBM0N2QkE7VUEyQ21DLDRCQXJDbkNDO0lBc0NGLFVBN0NJN3lEO1NBNkNBa3pEO2tCQTdDQWx6RCxVQTZDQWt6RCxpQkFJa0IxeEQsTUFqRGxCeEIsTUE2Q0FrekQsS0FJa0IxeEQ7SUFFdEIsVUFuRFFpRDtTQW1ESjB1RDtrQkFuREkxdUQsVUFtREowdUQsaUJBSWtCejRELElBdkRkK0osTUFtREowdUQsS0FJa0J6NEQ7SUFFdEIsU0FiSXVyQixHQWFVLFdBekRSMWE7SUF5RHNDLFdBQUEsNEJBWnhDMm5ELElBTUFDO0lBTXNCLFdBekR0Qm56RCxHQUFFdUwsR0FBRTlHLEdBNENKd2hCLEdBYXdDO0dBQWE7R0FLN0Q7WUFFSWtILElBQUlud0IsR0FBRTFRLEdBQUcrWDthQUNIMHdEO0tBQU0sOEJBQ0QsV0FGTHpvRTs7TUFJSSxJQURIaWYsY0FDRGlCLElBQUksV0FKRG5JLGFBQUgvWCxHQUdDaWY7TUFFTCxTQURJaUIsR0FFQyxNQUFBO2tCQUZEQSxJQXhLTnRRLFVBdUtPcVAsT0FIRGpmLE1BcEtONFAsV0FvS001UCxJQUdDaWY7O0tBUUc7TUFESTlHO01BQUhpNUI7TUFBSDE5QjtNQUNGd2YsTUFBSSxXQVhEbmIsYUFBSC9YLEdBVUtveEM7S0FFVCxTQURJbGUsS0FDVSxNQUFBO2lCQURWQSxNQTNFTncwQyxJQTBFUWgwRCxHQUFHMDlCLEtBVExxM0IsSUFTUXR3RCxNQTFFZHV2RCxJQWlFTWUsSUFTRS8wRCxJQUFHMDlCLEtBQUdqNUI7SUFFb0U7SUFFcEYsSUFBSSxXQWJJc3dELElBREYvM0QsSUFjRjs7O3VCQUNNLE9BZkpBOzs7R0FlSztZQUtMME4sS0FBSzFLLEdBQUV1TCxHQUFFOUcsR0FBR0o7SUFDbEIsVUFEV3JFLGdCQUVHLE9BdEJabXRCLElBb0JhMW9CLEdBQUY4RyxHQUFLbEg7YUFBUHJFO1NBTVNnMUQsS0FOVGgxRCxNQU1LaTBELEtBTkxqMEQsTUFNQ2kxRCxPQU5EajFELE1BTUhtMEQsS0FOR24wRDtlQUFJeUU7ZUFBQUE7V0FLTGd3RCxLQUxLaHdEO09BS0MsT0F6QmQwb0IsSUFBQUEsSUFvQlNudEIsR0FBRXVMLEdBQUtsSCxjQUtSb3dELElBTFFwd0Q7O1VBTTRCNndELEtBTi9CendELE1BTTJCK3ZELEtBTjNCL3ZELE1BTXVCMHdELE9BTnZCMXdELE1BTW1CaXdELEtBTm5CandEO2FBT0wsNEJBRG9DeXdELFNBQTFCRjtnQkExRmxCaEIsSUEwRk1HLElBQUljLE1BTk52cUQsS0FNVXVwRCxJQU5IMW9ELEdBQUU5RyxHQUFHSjtnQkFTSDttQ0FISzJ3RDtrQkFBMEJFO2tCQTFGNUNsQixJQW9GSXRwRCxLQUFLMUssR0FBRXVMLEdBTXFCbXBELElBTmhCcndELGNBTW9COHdELE1BQUlYO2tCQTlMeEN0NEQsT0F3TFM4RCxHQUFFdUwsR0FBRTlHOzs7Y0FBQUEsZ0JBR0QsT0F2Qlowb0IsSUFvQlNudEIsR0FBRXVMLEdBQUtsSDtRQUlYNnZELEtBSklsMEQ7SUFJSyxPQXhCZG10QixJQUFBQSxJQW9CYTFvQixHQUFGOEcsR0FBS2xILGNBSVg2dkQsSUFKVzd2RDtHQVdDO1lBSWJ1UjtJQUFVO0lBQUE7cUNBQ0w7O1VBQ0pySzs7VUFDQ3ZMO2dCQUFBQSwwQkFBQUE7VUFERHVMOztLQUFnQyxXQUFoQ0E7O0dBQzRCO0dBR3JDO0lBQUE7Ozs7OztHQUdFOzs7Ozs7TUFFRSwyQ0FFSTtNQUNLLE1BQUE7S0FBYTtHQUsxQjtJQUFBOzs7Ozs7R0FHRTs7Ozs7O01BRUUsMkNBRUk7TUFDSyxNQUFBO0tBQWE7O1lBS3RCNnBELFlBQVlwNEQ7SUFDUixZQWpDQTRZLFFBZ0NRNVk7O0tBRUosTUFBQTtRQUNIdU87SUFBSyxPQUFMQTtHQUFNO1lBR1htSyxXQUFXMVksR0FBR04sTUFBTU8sR0FBRzBZO0lBQ3pCLFNBQVEwL0Msa0JBQW1CcDRELEdBQUVELEdBQUV3WTtLQUM3QixJQUQyQnRTLE1BQUFsRyxHQUFFa3FCLFFBQUExUjtLQUM3QjtnQkFEMkJ0UyxrQkFFaEIsV0FGa0Jna0I7ZUFBRmhrQjtXQUdwQjhwQixRQUhvQjlwQjtPQUdYLE9BQUEsV0FIU2pHLEdBQUlpcUIsT0FHdEI4Rjs7TUFFRTtPQUxrQnVYLFFBQUFyaEM7T0FJYm95RCxVQUphcHlEO09BSW5Cb2hDLE9BSm1CcGhDO09BTXRCNVcsSUFOQytvRSxrQkFBbUJwNEQsR0FJakJxbkMsTUFKcUJwZDtlQU14QjU2QixNQUFnQixPQUFoQkE7TUFFTyxJQURFNjZCLFFBRFQ3NkIsTUFHRyttQixNQURJLFdBUmFwVyxHQU9Ya3FCLE9BSEFtdUM7ZUFLTmppRCxRQUFnQixPQUFoQkE7VUFUcUJtM0MsUUFTckJuM0M7TUFUbUJuUSxNQUFBcWhDO01BQUVyZCxRQUFBc2pDOztJQVV1QjtJQUVoRCxZQVpFNkssa0JBRGNwNEQsR0FBVEQsR0FBR047MkJBY0xwUSxjQUFLLE9BQUEsV0FkU3FwQixRQWNkcnBCO1FBQ0orbUI7SUFBSyxPQUFMQTtHQUFNO1lBR1B5QztJQUFVO0lBQUE7cUNBQ0w7O1VBQ0p2Szs7O1dBQ085RztpQkFBQUE7OztVQURQOEc7O0tBQWdDLFdBQWhDQTs7R0FDNEI7WUFHakNncUQsWUFBWXY0RDtJQUNSLFlBUEE4WSxRQU1ROVk7O0tBRUosTUFBQTtRQUNIdU87SUFBSyxPQUFMQTtHQUFNO1lBS1BpcUQ7SUFBaUI7S0FDWixPQUFBO3VCQUNDO1FBRUp4MUQ7Y0FBQUEsb0JBRFV5RSxjQUFZLE9BQVpBO1FBQ0pnaUMsZ0JBQUhsN0I7SUFBZSxPQTdLeEJ5b0QsSUF5S0l3QixlQUlFeDFELElBQUd1TCxHQUFHazdCO0dBQXNDO1lBS2xEMWUsTUFBTTNwQixJQUFHQztJQUNYLFVBRFFELGlCQUVNLE9BRkhDO2NBQUFBLGlCQUdHLE9BSE5EO0lBSTBCLFdBYjVCbzNELGVBU0tuM0Q7SUFJdUIsT0F0TGhDMjFELElBa0xNNTFELElBL0NOZzNELFlBK0NTLzJEO0dBSTBDO1lBS25EOUIsT0FBTzZCLElBQUdDLElBQUlnRztJQUNoQixVQURTakc7U0FFQXBCLElBRkdxQjs7ZUFBQUE7TUFHdUIsV0FyQjdCbTNELGVBa0JNbjNEO01BR0YsT0ExR0pxTSxLQXVHR3RNLElBeERQZzNELFlBd0RVLzJELFdBQUlnRzs7U0FFUHJILElBRkFvQjs7SUFFZ0IsT0FBaEJwQjtHQUMwRDtZQUdqRW0zQyxNQUFNbjNDLEdBQUUxUSxHQUFHK1g7YUFDTDh2QyxNQUFNbjNDO0tBQ1osVUFEWUEsZ0JBRUQ7Y0FGQ0E7TUFJRixJQURIdU8sSUFIS3ZPLE1BSU53UCxJQUFJLFdBTENuSSxhQUFIL1gsR0FJRGlmO01BRUwsYUFESWlCOzJCQURDakI7cUJBQ0RpQixZQURDakIsMEJBQUFBOztLQVFHO01BREk5RyxJQVZGekg7TUFVRDBnQyxNQVZDMWdDO01BVUpnRCxJQVZJaEQ7TUFXTndpQixNQUFJLFdBWkNuYixhQUFIL1gsR0FXR294QztLQUVULFNBRElsZSxLQUVDLFdBSEN4ZixPQUFHMDlCLE1BQUdqNUI7YUFDUithO01BUXNCO09BQUEsUUFuQnRCMjBCLE1BVVExdkM7T0FTUyt2RDtPQUFYaUI7T0FBSnhCO01BQ0osV0FsSUF2cEQsS0F3SEkxSyxHQUFHMDlCLEtBU0h1MkIsSUFwQkc1dkQsY0FvQkNveEQsV0FBV2pCOztLQUhLO01BQUEsVUFoQnRCcmdCLE1BVUVuMEM7TUFNZTAwRDtNQUFYZ0I7TUFBSnZCO0tBQ0osV0FESUEsSUFBSXVCLGFBOUhSaHJELEtBOEhtQmdxRCxJQU5aaDNCLEtBQUdqNUIsR0FYSEo7SUFxQmlDO0lBRTlDLE9BdEJROHZDLE1BREFuM0M7R0F1QkQ7T0FnbkJtQjI0RDtZQXptQnBCdCtDLElBQUlyYSxHQUFFMVEsR0FBRytYO0lBQ2YsSUFEVW5CLE1BQUFsRztJQUNWO2VBRFVrRyxrQkFFQztjQUZEQTtNQUlBLElBREhxSSxJQUhHckksUUFJSnNKLElBQUksV0FKS25JLGFBQUgvWCxHQUdMaWY7bUJBQ0RpQjs7S0FHSTtNQURJL0gsSUFOSnZCO01BTUN3NkIsTUFORHg2QjtNQU1GbEQsSUFORWtEO01BT0pzYyxNQUFJLFdBUEtuYixhQUFIL1gsR0FNRG94QzttQkFDTGxlOztTQVBJaW5CLFdBT0pqbkIsTUFEUS9hLElBQU56RTtLQU5Fa0QsTUFBQXVqQzs7R0FRNEM7WUFLcER2WixPQUFPbHdCLEdBQUUxUSxHQUFHK1g7YUFDTjB3RCxJQUFJLzNEO0tBQ1YsVUFEVUEsZ0JBRUMsTUFBQTtjQUZEQTtNQUtBLElBREl5SCxJQUpKekgsTUFJQzBnQyxNQUpEMWdDLE1BSUZnRCxJQUpFaEQsTUFLSndQLElBQUksV0FORW5JLGFBQUgvWCxHQUtFb3hDO01BRVQsYUFESWx4QjtnQkFoRU51YixNQStEUS9uQixHQUFNeUU7cUJBQ1IrSCxJQWxQTnduRCxJQWlQUWgwRCxHQUFHMDlCLEtBSkxxM0IsSUFJUXR3RCxNQWpQZHV2RCxJQTZPTWUsSUFJRS8wRCxJQUFHMDlCLEtBQUdqNUI7O1NBRFA4RyxJQUhHdk87S0FHSyxTQUFBLFdBSkhxSCxhQUFIL1gsR0FJRmlmLElBQWlDO0tBQVcsTUFBQTtJQUc4QjtJQUVuRixJQUFJLFdBUkl3cEQsSUFEQy8zRCxJQVNMOzs7dUJBQ00sT0FWREE7OztHQVVFO1lBR1Q0NEQsYUFBYTU0RCxHQUFFL0c7YUFDVDgrRCxJQUFJLzNELEdBQUUvRztLQUNaLFVBRFUrRyxnQkFFQyxNQUFBO2NBRkRBO2VBQUUvRyxHQUdjO01BQVcsTUFBQTs7S0FFdEI7TUFERHdPLElBSkp6SDtNQUlDdU8sSUFKRHZPO01BSUZnRCxJQUpFaEQ7TUFLSjY0RCxTQTlZTi8yRCxPQTZZUWtCO01BRUZ3TSxxQkFOTXZXLEdBS040L0Q7S0FFSixTQURJcnBELEdBRUMsT0FoRlB1YixNQTRFUS9uQixHQUFNeUU7WUFFUitILEdBSUMsT0FwUVB3bkQsSUEwUE1lLElBSUUvMEQsR0FKSS9KLElBSURzVixHQUFHOUc7S0FPUyxXQUFBLDRCQVhYeE8sR0FLTjQvRDtLQU1TLE9BclFmN0IsSUE4UFFoMEQsR0FBR3VMLEdBSkx3cEQsSUFJUXR3RCxHQU9RO0lBQWlCO0lBRXpDLElBQUksV0FiSXN3RCxJQURPLzNELEdBQUUvRyxJQWNiOzs7dUJBQ00sT0FmSytHOzs7R0FlSjtZQUdUODRELE1BQU1qMUIsSUFBR0YsSUFBSXQ4QjthQUNQeXhELE1BQU1qMUIsSUFBR0Y7S0FDZixJQURZSyxPQUFBSCxJQUFHQyxPQUFBSDtLQUNmO01BQUcsR0FBQSw2QkFEU0ssTUFBR0YsT0FFVixPQUZPRTtnQkFBQUE7V0FLRGhrQyxJQUxJOGpDOztnQkFBSEU7WUFRVS9ZLEtBUlYrWSxTQVFNcm1CLEtBUk5xbUIsU0FRRSswQixPQVJGLzBCLFNBUUY1aEMsS0FSRTRoQztrQkFBR0Y7a0JBQUFBO1VBT1ksSUFBZnNDLEtBUEd0QyxTQUFBQyxjQU9IcUM7VUFQR3RDLE9BQUFDOzs7YUFRaUMvWSxLQVJqQzhZLFNBUTZCbG1CLEtBUjdCa21CLFNBUXlCazFCLE9BUnpCbDFCLFNBUXFCemhDLEtBUnJCeWhDO1lBUWlDOVksTUFBMUJDO21CQUEwQkQsSUFSbEQsT0E1TUVtRixJQTRNWTZULE1BUTRCZzFCLE1BVDNCM3hEO1VBZVc7V0FBQSxRQXpGeEI4dkMsTUEyRWVyVCxNQVFEaTFCLE1BVEQxeEQ7V0FlTTR4RDtXQUFQNXdDO1dBQ2tCLE9BZnhCeXdDLE1BUVluN0MsSUFNQ3M3QztVQUNYLE9Bdk1KdnJELEtBd0xFb3JELE1BUUkxMkQsSUFNRWltQixPQU5FMHdDLFlBVEQxeEQ7O2tCQVNTNGpCLElBUnhCLE9BNU1Fa0YsSUE0TWUyVCxNQVFEaTFCLE1BVEQxeEQ7U0FvQlM7VUFBQSxVQTlGdEI4dkMsTUEyRVluVCxNQVE0QmcxQixNQVQzQjN4RDtVQW9CSTZ4RDtVQUFQOXdDO1VBQ2tCLE9BcEJ0QjB3QyxNQW1CV0ksTUFYMkJ0N0M7U0FZdEMsT0E1TUZsUSxLQXdMRW9yRCxNQW1CSTF3QyxNQVgwQi9sQixLQUFJMjJELFlBVDNCM3hEOzs7aUJBQ0V5OEI7UUFNUyxJQUFmdUMsS0FOR3JDLFNBQUFFLGNBTUhtQztRQU5HckMsT0FBQUU7OztXQUtEbGtDLElBTENna0M7O01BS2UsT0FBaEJoa0M7O0lBZTZDO0lBRTFELE9BdEJRODRELE1BREFqMUIsSUFBR0Y7R0F1QkE7WUFHVHcxQixXQUFZL29ELFlBQVlncEQsU0FBUXR4RDtJQUNsQyxJQUFJVCxjQURVK0k7SUFFYyxPQUFBOzthQUZNdEk7YUFtaUJSNndEO3NCQWppQk9wd0MsSUFBR2o1QjtjQUFLLE9BNUJ2Q3dwRSxNQTRCK0J2d0MsSUFBaUIsV0FGeEI2d0MsU0FFVTlwRSxJQURoQytYO2FBQ3NFO0dBQUM7WUFHekVneUQsTUFBTXgxQixJQUFHRixJQUFJdDhCO2FBQ1BneUQsTUFBTXgxQixJQUFHRjtLQUNmLEdBQUcsNkJBRFNFLElBQUdGLEtBRVYsT0FGT0U7ZUFBQUEsMEJBQUdGOzs7aUJBQUhFLHlCQUFBQTtrQkFBR0YseUJBQUFBO1NBU0o7VUFET2htQixLQVJOa21CO1VBUUV3QyxLQVJGeEM7VUFRRnpoQyxLQVJFeWhDO1VBU0QsT0FuSFhzVCxNQTBHZXhULElBUUQwQyxJQVREaC9COztVQVdOaEY7O1VBQ3lDLElBQTVCdWIsY0FBSm03QyxpQkFBZ0MsT0FYMUNNLE1BUVkxN0MsSUFHRUM7VUFBTSxPQWxPdEJsUSxLQXVORTJyRCxNQVFJajNELElBRUhDLEtBQ1MwMkQsWUFaSDF4RDs7U0FXK0IsSUFBM0I0eEQsZ0JBQTJCLE9BVnRDSSxNQVFZMTdDLElBRURzN0M7U0FBTSxPQTFIdkIxNUQsT0FnSE04NUQsTUFRSWozRCxJQUVIQyxXQVhNZ0Y7O1lBT2dCaXlELFlBTmpCejFCLElBTVI4QixZQU5XaEMsSUFNTDlxQixNQU5LOHFCOzs7V0FNYzIxQixZQU5kMzFCLElBTVhnQyxZQU5ROUIsSUFNRmhyQixNQU5FZ3JCOztNQU9MLE9BbkZIeHBCLElBa0Z5QmkvQyxXQUFuQnpnRCxLQVBHeFIsZUFPVHMrQjs7S0FEdUI7SUFNaUQ7SUFFOUUsT0FiUTB6QixNQURBeDFCLElBQUdGO0dBY0E7WUFHVHRtQixLQUFLd21CLElBQUdGLElBQUl0OEI7YUFDTmdXLEtBQUt3bUIsSUFBR0Y7S0FDZCxJQURXSyxPQUFBSDtLQUNYO01BQUcsR0FBQSw2QkFEUUcsTUFBR0wsS0FFVDtnQkFGTUssbUJBS0s7Z0JBTEZMLGlCQU1HLE9BTk5LO2dCQUFBQSwyQkFBQUE7T0FTQTtRQURPcm1CLEtBUlBxbUI7UUFRRyswQixPQVJILzBCO1FBUUQ1aEMsS0FSQzRoQztRQVNBLE9BcElYbVQsTUEySGN4VCxJQVFBbzFCLE1BVEYxeEQ7UUFXTGhGOztRQUNzQyxJQUExQnViLGNBQTBCLE9BWHZDUCxLQVFZTSxJQUdDQztRQUFNLE9BNUl6QnJlLE9BaUlNOGQsS0FRSWpiLElBRUhDLFdBWEtnRjs7T0FXZ0MsSUFBM0I0eEQsZ0JBQTJCLE9BVnRDNTdDLEtBUVlNLElBRURzN0M7T0FBTSxPQWxQbkJ2ckQsS0F3T0UyUCxLQVFJamIsSUFFSEMsS0FGTzAyRCxZQVRGMXhEOztNQVFZLElBQWZnL0IsS0FQRXJDLFNBQUFFLGNBT0ZtQztNQVBFckMsT0FBQUU7O0lBVzZEO0lBRTFFLE9BYlE3bUIsS0FERHdtQixJQUFHRjtHQWNBO1lBV0ZwUyxLQUFLN3pCLEdBQUdtSDtJQUNkLElBRFdMLE1BQUE5RyxHQUFHZ2lCLE1BQUE3YTtJQUNkO2VBRFdMLGtCQUVBLE9BRkdrYjtjQUFIbGIsWUFHSitKLElBSEkvSixRQUdDLFdBQUwrSixNQUhPbVI7S0FJbUIsSUFBbkJqWSxJQUpIakQsUUFJQWs4QixNQUpBbDhCLFFBQUF4QixJQUFBd0IsUUFBRyswRCxVQUlINzRCLEtBQUdqNUIsR0FKQWlZO0tBQUhsYixNQUFBeEI7S0FBRzBjLE1BQUE2NUM7O0dBSW1DO1lBRzNDQyxXQUFXOTdELEdBQUdtSDtJQUNwQixJQURpQkwsTUFBQTlHLEdBQUdnaUIsTUFBQTdhO0lBQ3BCO2VBRGlCTCxrQkFFTixPQUZTa2I7Y0FBSGxiLFlBR1YrSixJQUhVL0osUUFHTCxXQUFMK0osTUFIYW1SO0tBSW1CLElBSnRCalksSUFBQWpELFFBSU5rOEIsTUFKTWw4QixRQUlUeEIsSUFKU3dCLFFBQUcrMEQsVUFJVDc0QixLQUFIMTlCLEdBSlkwYztLQUFIbGIsTUFBQWlEO0tBQUdpWSxNQUFBNjVDOztHQUltQztZQUdyREUsT0FBTy83RCxHQUF3QixPQWQzQjZ6QixLQWNHN3pCLE1BQWtDO1lBMENyQ3lDLEtBQU1GOzs7bUJBQ0g7U0FDUXk1RCxxQkFBTkMsbUJBQUh2MkQ7S0FDTixXQUhVbkQsR0FFSm1EO2VBMURGbXVCLEtBMERLb29DLE1BQU1EOzs7WUE2T2pCRSxlQWpOaUJ4NEQsSUFBR0MsSUFBSWdHO2FBQ3BCeTVCLEtBQUs3NkI7S0FDUCxJQUlFcWhDLE9BTEtyaEM7VUFLTHFoQztrQkFMS3JoQztrQkFFTztVQUNVeXpELG1CQUFOQyxpQkFBTEU7TUFBb0IsZUFBcEJBLGVBMUZUdG9DLEtBMEZjb29DLE1BQU1EOztTQUVhbnlCLFFBTDlCdGhDLFVBSVk2ekQsUUFDakJ4eUIsU0FEV3l5QixRQUNYenlCLFNBRE16dUIsTUFDTnl1QjtVQUFtQ0MsT0FESixlQUF6QjF1QixVQTNGSjBZLEtBMkZTd29DLE9BQU1EO0tBRUk7TUFEZ0NFLFFBQWxCenlCO01BQVcweUIsUUFBWDF5QjtNQUFPemIsS0FBUHliO01BQy9CMnlCLGlCQUFpQixXQVBEN3lELGFBS2R3UixLQUNvQ2lUO0tBRTFDLFNBRElvdUM7a0JBQUFBO3dCQURzQ3B1QyxTQUExQ3diLE1BNUZFL1YsS0E0RjRDMG9DLE9BQU9EO3dCQUQvQ25oRCxVQTNGSjBZLEtBMkZTd29DLE9BQU1ELFFBQ2tCdnlCO0tBSzVCLEdBQUEsNkJBTkl3eUIsT0FDbUNFO1VBSXhDRSxpQkFMV0wsT0FDb0NFOztNQU8xQjtPQUFBLE9Bbkd6QnpvQyxLQTRGNEMwb0MsT0FBT0Q7T0FJL0NHLGlCQWhHSjVvQyxLQTJGU3dvQyxPQUFNRDtLQVVmLFdBTElLO0lBUTBDO0lBRWIsSUFBQSxPQTVGckNWLE9Bd0VrQnA0RCxLQW9CTyxXQTVGekJvNEQsT0F3RWVyNEQ7SUFvQmpCLE9BQUEsb0NBbkJJMC9CO0dBbUJxRDtZQWdDekQwSztJQUNFcDdCLFlBQ0V2SyxLQUNEdTBELHFCQUNBQyxrQkFDRGgwRDtJQUVKLEdBTE1SLFNBQVFDLE1BQVJELFFBQUFtYixRQUFRbGIsY0FBUmtiO2FBS0ZzNUMsZ0JBQWdCQyxNQUFLdjZELEdBQUVrYztLQUN6QjtNQUFJN1UsY0FQRitJO01BUWdCLFFBdFNsQittQyxNQW9TdUJuM0MsR0FBRWtjLE9BQ3JCN1U7TUFDVUk7TUFBUCt5RDtNQUFIeDNEO01BQ0FrRCxNQUFJLFdBSFVxMEQsVUFFZHYzRCxHQUFVeUU7S0FFZCxLQUZPK3lELE9BR0csT0FGTnQwRDtTQUdHMlMsTUFKQTJoRDtLQUlPLE9BM2FkcnFDLElBd2FJanFCLEtBR0cyUyxLQUxIeFI7SUFLZ0M7SUFFdEMsZ0JBYk0yWjtLQWVJO01BQVI7TUE3QzRDMWE7UUE2Q3BDOztVQWJMK3pEO1VBQ0RoMEQ7K0IsT0FFQWkwRDtNQWxDQWg3QjtpQkFBS282QjtTQUNQLEtBRE9BLFFBRU87YUFDSzcwRCxJQUhaNjBELFdBR1MxNUQsSUFIVDA1RCxXQUdNbHFDLElBSE5rcUM7U0FHa0IsV0FBWmxxQyxHQWxIUCtCLEtBa0hVdnhCLEdBQUc2RTtRQUE0QztLQUVqRSxHQXlCS3UxRDtNQXRCVztPQXRHYXhxQyxNQTRIeEJ3cUM7T0E1SDRCL2pFLFVBMEg3QitaO09BekhXcFEsSUE0RitCc0c7T0E1RjdCekI7TUFDYjtpQkFEVzdFLG9CQWtHWE4sT0FsR2FtRjtnQkFBRjdFO1FBR00sSUFBVnVPLElBSEl2TyxNQUFBa0csYUFHSnFJO1FBSEl2TyxJQUFBa0c7OztZQUFBbEQsSUFBQWhELE1BQUF5SCxJQUFBekgsTUFJQTBnQyxNQUpBMWdDO1FBSWlCLFFBQUEsV0FMQzNKLFNBS2xCcXFDLEtBTGM5UTtTQU1RLElBQW5CNlosTUFMSHpwQyxNQUtBeTZELE1BTEF6NkQsTUFBRTBmLFVBS0YrNkMsS0FBR2h4QixLQUxENWtDO1NBQUY3RSxJQUFBZ0Q7U0FBRTZCLElBQUE2YTs7O1NBQUYxZixJQUFBeUg7Ozs7O1VBa0dYL0gsT0F0R0ErNUQsT0FnRzBDbnpEO0tBVzlDLE9BQUEsOEJBTEk1RyxNQUxBNC9COztJQStDTTtLQUFSO0tBbEM0Qy80QjtPQWtDcEM7O1NBakJMNnpEO1NBRUQvekQ7OEIsT0FFQWkwRDthQXBCQW41QixPQUFLdTRCO0tBQ1AsS0FET0EsUUFFTztTQUNLNzBELElBSFo2MEQsV0FHUzE1RCxJQUhUMDVELFdBR01scUMsSUFITmtxQztLQUdrQixXQUFabHFDLEdBekhQZ3FDLFdBeUhVeDVELEdBQUc2RTtJQUFrRDtJQUV2RSxHQVlLdzFEO0tBVFc7TUF6R2F4cUMsUUFrSHhCd3FDO01BbEg0QmhqRSxZQStHN0IrWTtNQTlHV2pLLE1BK0YrQkk7TUEvRjdCZ3pEO0tBQ2I7Z0JBRFdwekQsc0JBcUdYdTBELFNBckdhbkI7ZUFBRnB6RDtPQUdNLElBQVZ3MEQsTUFISXgwRCxRQUFBQyxhQUdKdTBEO09BSEl4MEQsTUFBQUM7OztXQUtIcW1CLE1BTEd0bUIsUUFJQXkwRCxNQUpBejBEO09BSWlCLE9BQUEsV0FMQzlPLFdBS2xCdWpFLEtBTGMvcUM7UUFDZDFwQixNQUtIc21COztRQUF5QixJQUx0QmlkLE1BQUF2akMsUUFLQTAwRCxNQUxBMTBELFFBQUUyMEQsVUFLRkQsS0FBSHB1QyxLQUxLOHNDO1FBQUZwekQsTUFBQXVqQztRQUFFNnZCLE1BQUF1Qjs7Ozs7O1NBcUdiSixTQTNISWxCLFdBcUhzQ2p6RDtJQVc5QyxPQUFBLDhCQUxJbTBELFFBTEF2NUI7R0FrQzREO1lBSTFEdkcsc0JBQXNCNTZCLEdBQUdDO0lBQy9CLElBRDRCaUcsTUFBQWxHO0lBQzVCO2VBRDRCa0csa0JBRWpCO2NBRmlCQSxZQUdyQnFJLElBSHFCckksUUFHYixPQUFBLFdBSGdCakcsR0FHeEJzTyxTQUFBQTtTQUhxQjlHLElBQUF2QixRQUlqQnc2QixNQUppQng2QixRQUlwQmxELElBSm9Ca0Q7S0FLdkIsR0FBQSxXQUwwQmpHLEdBSXBCeWdDO01BR0QsSUFFSnB4QyxJQVRBc3JDLHNCQUlFNTNCLEdBSnVCL0M7YUFTekIzUSxJQUFBQSxRQUxLb3hDOztLQUppQng2QixNQUFBdUI7O0dBVUs7WUFHM0IyekIscUJBQXFCcDdCLEdBQUdDO0lBQzlCLElBRDJCaUcsTUFBQWxHO0lBQzNCO2VBRDJCa0csa0JBRWhCO2NBRmdCQSxZQUdwQnFJLElBSG9CckksUUFHWixPQUFBLFdBSGVqRyxHQUd2QnNPLFNBQUFBO1NBQ085RyxJQUphdkIsUUFJaEJ3NkIsTUFKZ0J4NkIsUUFBQWxELElBQUFrRDtLQUt0QixHQUFBLFdBTHlCakcsR0FJbkJ5Z0M7TUFHRCxJQUVKcHhDLElBVEE4ckMscUJBSVEzekIsR0FKZ0J4SDthQVN4QjNRLElBQUFBLFFBTEtveEM7O0tBSmdCeDZCLE1BQUFsRDs7R0FVSztZQUc5QnE0QixjQUFjcjdCLEdBQUczSixTQUFRaWxDLEtBQUkvc0I7SUFDL0IsaUJBRDJCK3NCO3lCQUFBQTs7a0JBQUFBO2lCQTFCckJWO2tCQTBCVTU2QjsyQkFha0IxUSxHQUFLLFlBQUEsV0FicEIrRyxTQWFlL0csR0FiSGlmLFdBYXdCO2lCQTFCakQ2c0I7a0JBYVVwN0I7MkJBRTZDMVEsR0FBSyxPQUFBLFdBRi9DK0csU0FFMEMvRyxHQUY5QmlmLGVBRWtEOztrQkFGdEQrc0I7aUJBYnJCRjtrQkFhVXA3QjsyQkFHZ0QxUSxHQUFLLE9BQUEsV0FIbEQrRyxTQUc2Qy9HLEdBSGpDaWYsZ0JBR3NEO2lCQTdCL0Vxc0I7a0JBMEJVNTZCOzJCQWVrQjFRLEdBQUssV0FBQSxXQWZwQitHLFNBZWUvRyxHQWZIaWYsV0FldUI7c0JBZjNCK3NCO0tBU2xCO01BQ0p6aUI7UUF2QkN1aUI7VUFhVXA3QixZQVN3QjFRLEdBQUssT0FBQSxXQVQxQitHLFNBU3FCL0csR0FUVGlmLGdCQVM4QjtRQUN4RHNLLFNBQUt2cEIsSUFBTHVwQixRQUFtQixTQUFBLFdBVkx4aUIsU0FVVC9HLEdBVnFCaWYsSUFVWSxPQUF0Q3NLO0tBQ2lCOztJQU5iO0tBQ0pnaEQ7T0FoQ0NqL0I7U0EwQlU1NkIsWUFLeUIxUSxHQUFLLFlBQUEsV0FMM0IrRyxTQUtzQi9HLEdBTFZpZixXQUsrQjtPQUN6RHNyRDtTQUFLeGpELE1BQUx3akQ7S0FBbUIsU0FBQSxXQU5MeGpFLFNBTVRnZ0IsS0FOcUI5SCxJQU1ZLE9BQXRDc3JEOztJQUNpQjtHQVFpQztZQUdyRHQrQix3QkFBd0J2N0IsR0FBR3c3QixZQUFXRjthQUNwQ0csUUFBUW5zQztLQUNWLG9CQUFNLFdBRnFCa3NDLFlBQ2pCbHNDO0lBR087SUFFbkIsU0FBSW9zQyxTQUFTcHNDLEdBQUksV0FMYm1zQyxRQUtTbnNDLEdBQW1CO0lBQ2hDLG9CQVB3Q2dzQztjQS9CbENGLHFCQStCb0JwN0IsR0FDdEJ5N0I7Y0E3Q0ViLHNCQTRDb0I1NkIsR0FNdEIwN0I7R0FHb0Q7WUFHdERxL0I7SUFDRTNxRCxZQUNFdkssS0FDRHUwRCxxQkFDQUMsa0JBQ0RuMEQsS0FDQWxHO0lBRUosR0FOTTZGLFNBQVFDLE1BQVJELFFBQUFtYixRQUFRbGIsY0FBUmtiO0lBTU47S0FBQTtvQkFOTUE7VUFERjVRO1VBYWtCLHVCQWJsQkE7S0FTRjtPQTNGQW83QjtTQWtGRXA3QixnQkFDRTRRLFFBQ0RvNUMscUJBQ0FDLGtCQUVEcjZEO0tBR0Y7T0ExRkF3ckM7U0FrRkVwN0IsZ0JBQ0U0USxRQUNEbzVDLHFCQUNBQyxrQkFDRG4wRDtJQVNrQixPQUFBO0dBQTJCO1lBRy9DN1AsUUFBUWdSLGFBQVl3OEIsSUFBR0Y7SUFDekIsSUFyTWtCcTNCLE9BMUJkdkIsT0E4TnFCOTFCLEtBcE1WczNCLE9BMUJYeEIsT0E4TmtCNTFCLEtBcE1QM0wsS0FBQStpQyxNQUFHOWlDLEtBQUE2aUM7SUFDZDtVQURXOWlDLFdBQUdDO1VBQUFBLElBSUY7S0FFRjtNQUR5QitpQyxPQUxyQi9pQztNQUtpQnZhLEtBTGpCdWE7TUFLYWlPLEtBTGJqTztNQUtFZ2pDLE9BTExqakM7TUFLQ3ZhLEtBTER1YTtNQUtIbU8sS0FMR25PO01BTUwxb0IsSUFBSSxXQThMSm5JLGFBL0xFZy9CLElBQW1CRDtLQUV6QixTQURJNTJCLEdBRUMsT0FGREE7S0FHSSxHQUFBLDZCQUpFbU8sSUFBbUJDLEtBTHBCc2EsS0FLS2lqQyxNQUxGaGpDLEtBS3FCK2lDOztNQU1WLElBWFhFLE9BeENWN3BDLEtBNkMyQjNULElBQUlzOUMsT0FMeEJHLE9BeENQOXBDLEtBNkNRNVQsSUFBSXc5QztNQUxMampDLEtBQUFtakM7TUFBR2xqQyxLQUFBaWpDOzs7R0FxTXdDO1lBR3hEcjRDLE1BQU04Z0IsSUFBR0YsSUFBSXQ4QjtJQUFjLElBaExYaEcsS0FsRGRvNEQsT0FrT085MUIsS0FoTEl2aUMsS0FsRFhxNEQsT0FrT0k1MUI7SUFBNkQsZ0JBakx4QzVqQztLOztVQUNkaWIsT0FBQTlaLElBQUcrWixPQUFBOVo7TUFDZDtZQURXNlo7WUFBR0M7T0FNUztRQURxQjYrQyxRQUw5QjcrQztRQUt1QjgrQyxRQUx2QjkrQztRQUttQjJRLEtBTG5CM1E7UUFLSzIrQyxRQUxSNStDO1FBS0M2K0MsUUFMRDcrQztRQUtIMFEsS0FMRzFRO1FBTUxnL0MsaUJBQWlCLFdBMEtaN3lELGFBM0tIdWtCLElBQXlCRTtPQUUvQixTQURJb3VDO1FBR0YsV0FWcUJqNkQsc0JBTWpCMnJCLElBQXlCRTtRQUtMLElBVmRnRyxPQWhFVlAsS0FxRWlDMG9DLE9BQU9ELFFBTGpDam9DLE9BaEVQUixLQXFFUXdvQyxPQUFPRDtRQUxSNStDLE9BQUE2VztRQUFHNVcsT0FBQTJXOztvQkFNUm9vQztRQVVGLFdBakJxQmo2RCxrQkFNUTZyQjtRQVlyQixJQWpCRXd2QyxPQWhFVi9wQyxLQXFFaUMwb0MsT0FBT0Q7UUFMOUI3K0MsT0FBQW1nRDs7O1FBYVYsV0FkcUJyN0Qsa0JBTWpCMnJCO1FBU0MsSUFkRTJ2QyxPQWhFUGhxQyxLQXFFUXdvQyxPQUFPRDtRQUxSNStDLE9BQUFxZ0Q7OzthQUFHcGdEO2dCQVJWaGI7MEJBV3dCaUQsR0FBSyxPQUFFLFdBSlZuRCxrQkFJR21ELElBQWlCLEdBSC9CK1g7OztLQUlGLE9BWlJoYixjQVl3QmlELEdBQUssT0FBRSxXQUxWbkQsa0JBS0dtRCxJQUFnQixHQUpqQzhYO0dBZ0xzRTtZQUNuRjVrQixNQUFNdXRDLElBQUdGLElBQUl0OEI7SUFBYyxhQUwzQmhSLFFBS2FnUixhQUFQdzhCLElBQUdGO0dBQStDO1lBRXhENjNCLFVBQVUzM0IsSUFBUUYsSUFBSXQ4QjthQUNoQm0wRCxVQUFVMzNCLElBQVFGO0tBQ3hCLElBRGdCSyxPQUFBSCxJQUFRQyxPQUFBSDtLQUN4QjtnQkFEZ0JLLG1CQUVGO2VBRkVBO1dBQUFybUIsS0FBQXFtQixTQVlKKzBCLE9BWkkvMEIsU0FZUjVoQyxLQVpRNGhDO2lCQUFRRjtpQkFBQUE7YUFLUXNDLEtBTFJ0QzttQkFZaEIxaEMsMEJBWlF1Yjt1QkFVWCxXQVhpQnRXLGFBYVYweEQsTUFQb0IzeUI7U0FNbkI7O1FBRUg7U0FEZ0N4b0IsS0FabEJrbUI7U0FZY2sxQixPQVpkbDFCO1NBWVV6aEMsS0FaVnloQztTQWFsQnQwQixJQUFJLFdBZFluSSxhQWFWMHhELE1BQTBCQztRQUVwQyxTQURJeHBEO2lCQUFBQTtVQU9DLFdBcEJEZ3NELGlCQVlNekMsTUFaSXA3QyxXQVkwQkM7VUFRbkMsV0FBQTtVQXBCU29tQixPQVlSNWhDOzs7U0FPRCxXQW5CRG81RCxjQVlFcDVELElBQUkyMkQsZ0JBQXNCMTJEO1NBTzNCLFdBQUE7U0FuQlMyaEMsT0FBQXJtQjs7O1FBZ0JaLFdBQUEsNkJBaEJZcW1CLE1BQVFGO1FBZ0JwQjs7O1NBQXFCLFdBaEJuQjAzQixVQVlFcDVELElBQTBCQztTQUlULFNBaEJUMmhDLE9BQUFybUIsSUFBUW1tQixPQVlrQmxtQjs7O1FBSXRDOzs7Z0JBaEJvQmttQixtQkFHVjtVQUNQdUMsS0FKU3JDO01BSUMsT0E3V2IzcEIsSUF5V29CeXBCLE1BSWpCdUMsSUFMZWgvQjs7SUFxQnVEO0lBRS9FLE9BdEJRbTBELFVBREkzM0IsSUFBUUY7R0F1QkE7WUFHZDgzQixhQUFhNTNCLElBQUdGLElBQUl0OEI7SUFDMUIsSUFEbUIyOEIsT0FBQUgsSUFBR0MsT0FBQUg7SUFDdEI7ZUFEbUJLLDRCQUFHRjs7O2lCQUFIRSwyQkFBQUE7a0JBQUdGLDJCQUFBQTthQUFIbm1CLEtBQUFxbUIsU0FJUHFDLEtBSk9yQyxTQUlYNWhDLEtBSlc0aEM7U0FLZCxHQUFBLDZCQUxjQSxNQUFHRixPQU1mO1NBRUcsSUFBQSxPQXhhUnFULE1BZ2FvQnJULE1BSVZ1QyxJQUpjaC9CLGNBU3BCaEY7cUJBRWdCO1NBRGhCLElBVmdCdWIsY0FVaEIsT0FWQTY5QyxhQUlFcjVELElBS0ZDLElBVG9CZ0Y7U0FVcEIsV0FBQTtTQVZhMjhCLE9BQUFybUI7U0FBR21tQixPQUFBbG1COzs7WUFHVjA3QyxZQUhPdDFCLE1BR1puckIsTUFIZWlyQjs7O1dBR1Z3MUIsWUFIVXgxQixNQUdmanJCLE1BSFltckI7O01BR2dDLFdBclk3QzNwQixJQXFZTWkvQyxXQUFMemdELEtBSG1CeFI7O0tBRUQ7O0dBU0c7WUFHMUI2UixPQUFLbFosR0FBR0M7YUFDRkU7S0FBTztLQUFBO3NDQUNGOytCQUNKb08sZ0JBQUssT0FBQSxXQUhKdE8sR0FHRHNPO1VBQ085RyxnQkFBSGk1QixrQkFBSDE5QjtNQUhGN0MsS0FHRTZDO01BRU4sV0FOTS9DLEdBSUd5Z0M7Z0JBQUdqNUI7O0lBR047SUFFVixPQVJRdEgsS0FEREg7R0FTRDtZQUtBRCxLQUFLckMsR0FBUWltQixNQUFNMWpCO0lBQ3pCLElBRFd1RSxNQUFBOUcsR0FBUWcrRCxTQUFBLzNDO0lBQ25CO2VBRFduZixrQkFFQSxPQUZRazNEO2NBQVJsM0QsWUFHSitKLElBSEkvSixRQUdDLE9BQUEsV0FIYXZFLEdBQU55N0QsUUFHWm50RDtLQUNtQztNQUovQjlHLElBQUFqRDtNQUlBazhCLE1BSkFsOEI7TUFJSHhCLElBSkd3QjtNQUFRbTNELFNBSXVCLFdBSmpCMTdELEdBQW5CRixLQUlFaUQsR0FKVzA0RCxRQUFNejdELElBSWR5Z0M7S0FKQWw4QixNQUFBaUQ7S0FBUWkwRCxTQUFBQzs7R0FJbUQ7WUFPcEV2akQsTUFBTXBZLEdBQUdDLEdBQUksT0FBQSw4QkFYVEYsTUFXRUMsR0FBR0MsR0FBOEI7WUFDdkNvWSxJQUFJbUIsR0FBRXhaLEdBQUdDLEdBQUksT0FBQSw4QkFaVEYsTUFZQXlaLEdBQUV4WixHQUFHQyxHQUE4QjtZQUVuQ0MsV0FBV3hDLEdBQVFpbUIsTUFBTTFqQjtJQUMvQixJQURpQnVFLE1BQUE5RyxHQUFRZytELFNBQUEvM0M7SUFDekI7ZUFEaUJuZixrQkFFTixPQUZjazNEO2NBQVJsM0QsWUFHVitKLElBSFUvSixRQUdMLE9BQUEsV0FIbUJ2RSxHQUd4QnNPLEdBSGtCbXREO0tBSXVCO01BQWxDajBELElBSkdqRDtNQUlOazhCLE1BSk1sOEI7TUFBQXhCLElBQUF3QjtNQUFRbTNELFNBSXVCLFdBSmpCMTdELEdBSXBCeWdDLEtBSkx4Z0MsV0FJUXVILEdBSldpMEQsUUFBTXo3RDtLQUFkdUUsTUFBQXhCO0tBQVEwNEQsU0FBQUM7O0dBSXlEO1lBRzVFcDVELFFBQVF2QyxHQUFLbUs7SUFDbkIsSUFEY2pFLE1BQUFsRztJQUNkO2VBRGNrRyxrQkFFSDtjQUZHQSxZQUdQcUksSUFIT3JJLFFBR0YsT0FBQSxXQUhPaUUsR0FHWm9FO0tBQ21CLElBSlo5RyxJQUFBdkIsUUFJSHc2QixNQUpHeDZCLFFBSU5sRCxJQUpNa0QsUUFJWSxPQUFBLFdBSlBpRSxHQUlSdTJCO0tBQWU7TUFBTyxXQUozQm4rQixRQUlFUyxHQUpXbUg7TUFJYyxTQUpuQmpFLE1BQUF1Qjs7Ozs7S0FJbUI7O0dBQWdDO1lBRzNEdkYsT0FBT2xDLEdBQUttSztJQUNsQixJQURhakUsTUFBQWxHO0lBQ2I7ZUFEYWtHLGtCQUVGO2NBRkVBLFlBR05xSSxJQUhNckksUUFHRCxPQUFBLFdBSE1pRSxHQUdYb0U7S0FDbUIsSUFKYjlHLElBQUF2QixRQUlGdzZCLE1BSkV4NkIsUUFJTGxELElBSktrRCxRQUlhLE9BQUEsV0FKUmlFLEdBSVB1MkI7S0FBZTs7O01BQU8sV0FKM0J4K0IsT0FJRWMsR0FKVW1IO01BSWUsV0FKcEJqRSxNQUFBdUI7OztLQUlhOztHQUFxQztZQUc3RG1jLE9BQU9sbUIsR0FBS3lNLEdBQUc5QzthQUNUdTBEO1NBQUtGOztzQ0FDQSxPQURBQTs7V0FFSm50RDtPQUFRLE9BQUEsV0FISHBFLEdBR0xvRSxLQW5tQlA0aEIsSUFpbUJXdXJDLFFBRUpudEQsR0FIUWxILGVBQ0pxMEQ7O01BSU07T0FESGowRDtPQUFIaTVCO09BQUgxOUI7T0FDUyxPQUFBLFdBTExtSCxHQUlEdTJCLE9BcG1CWHZRLElBaW1CV3VyQyxRQUdBaDdCLEtBSklyNUIsZUFDSnEwRDtPQUlKLFNBSkRFLFdBR0U1NEQ7TUFIRzA0RDtnQkFHR2owRDs7O0lBR2hCLE9BTlFtMEQsUUFEQ2wrRDtHQU9HO1lBR1Znd0IsV0FBV2h3QixHQUFLeU0sR0FBRzlDO2FBQ2J1MEQ7U0FBS0Y7O3NDQUNBLE9BREFBOztPQUdGLElBREZudEQsZ0JBQ0UsUUFBQSxXQUpPcEUsR0FHVG9FO21CQUVNLE9BSkZtdEQ7V0FLRGg3QjtPQUFLLE9BaG5CZnZRLElBMm1CV3VyQyxRQUtEaDdCLEtBTlNyNUI7O01BVUw7T0FIQUk7T0FBSGd6RDtPQUFIejNEO09BR00sVUFBQSxXQVZFbUgsR0FPTHN3RDs7V0FLSUUseUJBdG5CZnhxQyxJQTJtQld1ckMsUUFXSWYsS0FaSXR6RDs7a0JBQ1JxMEQ7TUFRUCxhQVJFRSxXQU1FNTREO01BTkcwNEQ7Z0JBTUdqMEQ7OztJQVNoQixPQWZRbTBELFFBREtsK0Q7R0FnQkQ7WUFHVnl3QixhQUFhendCLEdBQUt5TSxHQUFHOUM7YUFDZncwRDtTQUFLSDs7VUFBS3o3RCxJQUFMeTdELFdBQUUxN0QsSUFBRjA3RDtzQ0FDQSxPQURBQTs7V0FFSm50RDtPQUFRLE9BQUEsV0FIR3BFLEdBR1hvRTtxQkFob0JQNGhCLElBOG5CYW53QixHQUVOdU8sR0FIY2xILGNBQ0xwSDtxQkFBSEQsR0E5bkJibXdCLElBOG5CZ0Jsd0IsR0FFVHNPLEdBSGNsSDs7TUFLSjtPQURISTtPQUFIaTVCO09BQUgxOUI7T0FDUztTQUFBLFdBTENtSCxHQUlQdTJCO2dCQWpvQlh2USxJQThuQmFud0IsR0FHRjBnQyxLQUpVcjVCLGNBQ0xwSDtnQkFBSEQsR0E5bkJibXdCLElBOG5CZ0Jsd0IsR0FHTHlnQyxLQUpVcjVCO09BS2QsU0FKRHcwRCxXQUdFNzREO01BSEcwNEQ7Z0JBR0dqMEQ7OztJQUdoQixPQU5RbzBELFVBRE9uK0Q7R0FPTTtZQUdmbytEO1FBQWFKOztxQ0FDUixPQURRQTs4QkFFWm50RCxnQkFBSyxXQUFMQSxHQUZZbXREO0tBR29CO01BQXpCajBEO01BQUhpNUI7TUFBSDE5QjtNQUErQixhQUE1QjA5QixLQUhMbzdCLGFBQWFKLFFBR0xqMEQ7S0FIS2kwRDtlQUdYMTREOzs7WUFHTis0RCxTQUFTcitELEdBQUksT0FOVG8rRCxnQkFNS3ArRCxHQUFxQjtZQUU5QnMrRCxPQUFPaDhEO0lBQ1QsVUFEU0EsZ0JBRUU7YUFGRkEsVUFHRnVPLElBSEV2TyxNQUdHLFdBQUx1TztRQUNJbXlCLE1BSkYxZ0M7SUFJaUIsV0FBZjBnQztHQUFxQjtHQUloQjtJQUFaN2M7Ozs7Ozs7OztZQURGbzRDLFdBRWFqOEQ7SUFDUCxZQVZOZzhELE9BU2FoOEQ7Z0JBRUgsTUFBQSw0QkFIUjZqQjtRQUlLdFY7SUFBSyxPQUFMQTtHQUFNO1lBTWIzTyxRQUFRaXRCLEtBQUt4bEI7SUFDZixPQUE2Qjs7YUFEbkJ3bEI7YUF1R2dCOHJDO3NCQXRHUTM0RCxHQUFFMVEsR0FBSyxPQWxxQnZDNmdDLElBa3FCZ0Nud0IsR0FBRTFRLEdBRHJCK1gsYUFDOEM7R0FBQztZQUc1RDIvQixZQUFZQyxVQUFVNS9CO0lBQ3hCLE9BQXNDOzthQUR4QjQvQjthQW1HWTB4QjtzQkFsR2lCMzRELEdBQUUxUSxHQUFLLE9BdHFCaEQ2Z0MsSUFzcUJ5Q253QixHQUFFMVEsR0FEckIrWCxhQUM4QztHQUFDO1lBS3JFNmxDLFNBQVM5cEMsR0FBR2lFO0lBQ2QsT0FBNEI7O2FBRGpCakU7YUE2RmV1MUQ7c0JBNUZPMzRELEdBQUUxUSxHQUFLLE9BNXFCdEM2Z0MsSUE0cUIrQm53QixHQUFFMVEsR0FEckIrWCxhQUM4QztHQUFDO1lBSTNENFI7SUFBVyw4QkFDRjsyQkFDSjFLLGNBQUssV0FBTEE7SUFFSztLQURRN1E7S0FBTitKO0tBQUhpNUI7S0FBSDE5QjtLQUNGRSxNQUFNLDJCQURReEYsR0FBVGdqQztLQUVMdzdCO2FBQ0k5dEQ7S0FBTztLQUFBO3NDQUdGOztXQUNKRyx1QkFMTDJ0RDtPQU1BLGlCQVBBaDVELHVCQU1LcUw7T0FKVCxPQUFBLDZCQURJMnREOztVQVFZejBELGdCQUFIaTVCLGtCQUFIMTlCO01BUEZvTCxLQU9FcEw7aUJBUk5rNUQ7TUFVQSxpQkFYQWg1RCx1QkFTU3c5QjtNQUdULDZCQVhBdzdCO2dCQVFZejBEOztJQUlOO0lBWEYyRyxLQUhGcEw7SUFrQk4sNkJBaEJJazVEO0lBQ0k5dEQsS0FISTNHO0lBbUJaLE9BbEJJdkU7R0FtQkQ7WUFHSDdDLElBQUlMLEdBQUdDLEdBQUdvSDtJQUFjLE9BN0lwQnRIO2FBNklBQzthQThEb0IyNEQ7c0JBOUQyQjM0RCxHQUFFMVEsR0FBSyxPQTFzQjFENmdDLElBMHNCbURud0IsR0FBYSxXQUF6REMsR0FBOEMzUSxJQUEzQytYLGFBQXdFO0dBQUM7WUFFbkY4MEQsU0FDV2gxQixLQURHaTFCLE9BQU8vMEQ7SUFDdkIsSUFBYWcxRCxRQUFBbDFCLEtBQUltMUI7SUFDZjtLQUFHLEdBNTNCSHZvRCxTQTIzQldzb0QsUUFFTixPQUZVQztLQUlMLElBQUpodEUsSUEzRE4yc0UsV0F1RFdJO1NBSUxobUQsTUFBQS9tQjtLQUVGO01BQUE7UUF0Rko2K0I7VUFnRldrdUM7bUJBTWtCeGpEO1dBQU8sV0FBQSw2QkFGOUJ4QyxLQUV1QndDO1dBQU8scUJBRGxDLFdBTll1akQsT0FLUi9sRCxLQUV1QndDO1VBQXNDO1VBUDlDeFI7TUFDVmsxRDtNQUtMQztNQUxTQyxzQkFLVEQsU0FMU0Y7S0FBSkQsUUFBQUU7S0FBSUQsZ0JBQUFHOztHQVVOO1lBR0x6akQsS0FBS2haLEdBQUdDO0lBQ2QsSUFEV2lHLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQSxZQUdKcUksSUFISXJJLFFBR0ksT0FBQSxXQUhEakcsR0FHUHNPLFNBQUFBO1NBSEk5RyxJQUFBdkIsUUFJQXc2QixNQUpBeDZCLFFBSUhsRCxJQUpHa0Q7S0FLTixHQUFBLFdBTFNqRyxHQUlIeWdDLE1BRUosV0FGSUE7S0FJRCxJQUVKK0ksTUFWQXp3QixLQUlFaFcsR0FKTS9DO1FBVVJ3cEMsS0FBZSxPQUFmQTtLQVZLdmpDLE1BQUF1Qjs7R0FVWTtZQUdqQnNSLFNBQVMvWSxHQUFHQztJQUNsQixJQURlaUcsTUFBQWxHO0lBQ2Y7ZUFEZWtHLGtCQUVKO2NBRklBLFlBR1JxSSxJQUhRckksUUFHSCxPQUFBLFdBSE1qRyxHQUdYc087S0FFRSxJQUxNOUcsSUFBQXZCLFFBSUp3NkIsTUFKSXg2QixRQUlQbEQsSUFKT2tELFFBTVZ1akMsTUFESSxXQUxTeHBDLEdBSVB5Z0M7UUFFTitJLEtBQWUsT0FBZkE7S0FFTyxJQUVKQyxNQVZGM3dCLFNBSUUvVixHQUpVL0M7UUFVVnlwQyxLQUFlLE9BQWZBO0tBVk94akMsTUFBQXVCOztHQVVXO1lBR3hCdWMsU0FBU2hrQixHQUFHQztJQUNSLFlBM0JBK1ksS0EwQktoWixHQUFHQzs7S0FFSixPQUFBO1FBQ0g0RTtJQUFLLE9BQUxBO0dBQU07WUFHUCtjLElBQUk1aEIsR0FBRS9HO0lBQ1osSUFEVWlOLE1BQUFsRyxHQUFFOEUsTUFBQTdMO0lBQ1o7ZUFEVWlOLGtCQUVDO2NBRkRBLFlBR0hxSSxJQUhHckksUUFHRSxhQUhBcEIsVUFHTHlKO1NBQ2E3USxJQUpWd0ksUUFBQXVCLElBQUF2QixRQUlDdzZCLE1BSkR4NkIsUUFBQWxELElBQUFrRDtRQUlVeEksS0FKUm9ILEtBTUw7S0FFVSxJQUFUK3pELFNBajlCTi8yRCxPQXk4QlFrQixJQVNGd00scUJBVEkxSyxLQVFKK3pEO0tBRUosUUFESXJwRDtlQUFBQSxHQUNxQyxXQU5sQ2t4QjtNQU1xRDtPQUFBLE9BQUEsNEJBVnBENTdCLEtBUUorekQ7T0FSSWpyQyxNQVVtRDtNQVZyRDFuQixNQUFBdUI7TUFBRTNDLE1BQUE4b0I7OztNQUFGMW5CLE1BQUFsRDs7R0FVc0U7WUFHOUUwNUQsa0JBQ1c1MEQsSUFEV1Q7SUFDeEI7S0FBYWtmLE9BQUF6ZTtLQUFHNjBEO0tBQVVDLGVBQUFqRTtJQUN4QjtVQURXcHlDLE1BRUgsT0FBQSwwQkFGTW8yQztTQUFIaDdDLEtBQUE0RSxTQUdUN0UsS0FIUzZFO0tBSU4sR0E3bUJEbE0sSUF5bUJvQnVpRCxjQUd0Qmw3QyxJQUpvQnJhO01BQ1hrZixPQUFBNUU7O01BTXNCO09BTlRrN0MsaUJBeHdCeEIxc0MsSUF3d0J3QnlzQyxjQUd0Qmw3QyxJQUpvQnJhO09BQ1J5MUQsa0JBR1pwN0MsSUFIWWk3QztNQUFIcDJDLE9BQUE1RTtNQUFHZzdDLFlBQUFHO01BQVVGLGVBQUFDOzs7R0FRVjtZQUdkRSxpQkFBaUI1L0IsV0FBVW55QixNQUFNM0Q7SUFDbkMsU0FENkIyRDtLQWNuQixPQUFBLDREQWRtQkE7SUFHYjtLQURKNmhCLE1BRmlCN2hCO0tBR3ZCZ3lELFVBQVUsMEJBREpud0MsS0FGT3NRO0tBSWJnSyxNQXRISnZuQyxRQXFISW85RCxTQUg2QjMxRDtLQUtqQixPQUFBLHlCQUhOd2xCO09BcCtCVi9xQixPQXMrQklxbEMsZUFFQyxPQUZEQTtJQUlRLElBQU5rMUIsWUFuQmtCMUQ7SUFvQnRCOztNQVBROXJDO01BQ05td0M7ZUFNaUNDLFNBQVEzc0M7T0FDekMsT0E5bkJBalcsSUE0bkJFZ2lELFVBQ3VDL3JDLElBVFpqcEI7aUJBV3hCO29FQUY0QjQxRDtrQkFEL0JaLFdBM3hCTmxzQyxJQTJ4Qk1rc0MsVUFDdUMvckMsSUFUWmpwQjtNQVlPO0lBQ3RDLE1BQUE7R0FDcUQ7WUFHdkR5QyxVQUFVMFEsV0FBVXhhO0lBQ3RCO1lBMU5NRTtjQXlOZ0JGOzt1QkFDbUJzd0IsSUFBRzlYLEtBQU8sV0FBQSxXQUR2Q2dDLFdBQzZCOFYsS0FBRzlYLEtBQTBCO0dBQUU7WUFTcEUwa0QsWUFBV0MsUUFBb0JDLFVBQWlCQyxhQUFhaDJEO0lBQ3hDLElBQW5CaTJELG1CQXBqQkpqZ0QsS0FtakJhOC9DLFdBQW9CQyxhQUE4Qi8xRDtJQUU1RCxHQTk5QkgwTSxTQTY5Qkl1cEQsbUJBRUM7SUFFeUI7S0FBeEJDLHdCQWZOenpELFVBVWtEdXpELGFBQzlDQztLQU9rQixPQUFBLHFEQVJXRjtLQVExQixPQUFBLDZCQVJNRDtLQU9UO09BQUE7Ozt1Q0FGRUk7SUFFRixPQUFBO0dBRWtEO1lBdUJ4REMsWUFBOEI3RDtRQUFidnBEO0lBQW9CLFdBQXBCQSxZQUFhdXBEOztZQUM5QnR5RCxZQUFZckgsR0FBSSxPQUFKQSxRQUFtQztZQUc3Q29RLFdBQVdwUSxHQUFJLE9BQUpBLEtBQWdCO1lBQzNCeTlELGFBQVd6OUQ7SUFBeUMsV0FKdERxSCxZQUlhckg7SUFBeUMsT0E1aENwRCsxRCxXQTRoQ1cvMUQ7R0FBd0Q7WUFDbkVvWixTQUFPcFosR0FBSSxPQW5pQ1g4QixPQW1pQ085QixNQUF1QjtZQUM5QnNaLFdBQVN0WixHQUFJLE9BbmdDYitULFNBbWdDUy9ULE1BQXlCO1lBQ2xDMDlELFdBQVMxOUQsR0FBSSxPQXpNYis3RCxTQXlNUy83RCxNQUF5QjtZQUNsQ2dhLFVBQVFoYSxHQUFJLE9BcHpCUjRZLFFBb3pCSTVZLE1BQXdCO1lBQ2hDMjlELGNBQVkzOUQsR0FBSSxPQXJ4QmhCbzRELFlBcXhCWXA0RCxNQUE0QjtZQUN4Q2lhLFVBQVFqYSxHQUFJLE9BOXZCUjhZLFFBOHZCSTlZLE1BQXdCO1lBQ2hDNDlELGNBQVk1OUQsR0FBSSxPQXp2QmhCdTRELFlBeXZCWXY0RCxNQUE0QjtZQUN4QzY5RCxTQUFPNzlELEdBQUksT0E1TVhnOEQsT0E0TU9oOEQsTUFBdUI7WUFDOUI4OUQsYUFBVzk5RCxHQUFJLE9BdE1maThELFdBc01XajhELE1BQTJCO1lBQ3RDRixRQUFRRSxHQUFJLElBcExKdEMsSUFvTEFzQyxNQXBMSSxPQTVCWis3RCxTQTRCUXIrRCxHQW9Md0I7WUFDaENxYyxXQUFTL1osR0FBSSxPQTlLYmlaLFNBOEtTalosTUFBeUI7WUFDbENvYSxPQUFLcGEsR0FBR04sTUFBTU8sR0FBSSxPQWxTZEYsS0FrU0NDLE1BQUdOLE1BQU1PLEdBQThCO1lBQzVDa2EsYUFBV25hLEdBQUdOLE1BQU1PO0lBQUksV0FBYkQ7SUFBYSxzQixPQXZ4QnhCMFksaUJBdXhCY2haLE1BQU1PO0dBQW9DO1lBQ3hEODlELGFBQVcvOUQsR0FBR04sTUFBTU8sR0FBSSxPQXRScEJDLFdBc1JPRixNQUFHTixNQUFNTyxHQUFvQztZQUN4RHNZLFlBQVl2WSxHQUFHTixNQUFNTztJQUFJLE9BQUEsOEJBSHpCbWEsUUFHZTFhLE1BQU1PLEdBQVREO0dBQW1EO1lBQy9EbVosT0FBS25aLEdBQUdDLEdBQUksT0FwVFppWixPQW9US2xaLE1BQUdDLEdBQXdCO1lBQ2hDKzlELFFBQU01NkQsR0FBRUMsR0FBR3BEO0lBQThDLFdBckIzRG9ILFlBcUJRakU7SUFBUyxPQWhXZjJmLE1BZ1dNM2YsTUFBRUMsWUFBR3BEO0dBQTZEO1lBQ3hFeVosU0FBTzFaLEdBQUdDLEdBQUksT0E1UVZpQyxPQTRRR2xDLE1BQUdDLEdBQTBCO1lBQ3BDMFosVUFBUTNaLEdBQUdDLEdBQUksT0FwUlhzQyxRQW9SSXZDLE1BQUdDLEdBQTJCO1lBQ3RDd1osUUFBTXpaLEdBQUdDLEdBQUksT0EvUmJtWSxNQStSTXBZLE1BQUdDLEdBQXlCO1lBQ2xDc1osTUFBSUMsR0FBRXhaLEdBQUdDLEdBQUksT0EvUmJvWSxJQStSSW1CLEdBQUV4WixNQUFHQyxHQUF5QjtZQUNsQzRaLE9BQUs3WixHQUFHQyxHQUFJLE9BL0lSK1ksS0ErSUNoWixNQUFHQyxHQUF3QjtZQUNoQzh2QixXQUFTL3ZCLEdBQUdDLEdBQUksT0F0SGhCK2pCLFNBc0hTaGtCLE1BQUdDLEdBQTRCO1lBQ3hDMlosV0FBUzVaLEdBQUdDLEdBQUksT0FwSVo4WSxTQW9JSy9ZLE1BQUdDLEdBQTRCO1lBQ3hDZ3dCLE1BQUlqd0IsR0FBRW9ELEdBQW9DLFdBN0I1Q2lFLFlBNkJNckgsSUFBc0MsT0E3c0J0Q3FhLElBNnNCQXJhLE1BQUVvRCxTQUFtRDtZQUN6RDY2RCxTQUFPaitELEdBQUdDO0lBQWdELFVBOUI1RG9ILFlBOEJTckg7SUFBYyxPQS9CdkJ3OUQsS0ErQlN4OUQsR0E3UVA0akIsT0E2UU81akIsTUFBR0M7R0FBZ0U7WUFDMUVpK0QsTUFBSWwrRCxHQUFFb0Q7SUFBNEMsVUEvQnBEaUUsWUErQk1ySDtJQUFhLE9BaENuQnc5RCxLQWdDTXg5RCxHQTkyQkptd0IsSUE4MkJJbndCLE1BQUVvRDtHQUE0RDtZQUNsRSs2RCxTQUFPbitELEdBQUVvRDtJQUErQyxVQWhDMURpRSxZQWdDU3JIO0lBQWEsT0FqQ3RCdzlELEtBaUNTeDlELEdBbnNCUGt3QixPQW1zQk9sd0IsTUFBRW9EO0dBQStEO1lBQ3hFZzdELFFBQU1oOUQsSUFBR0M7SUFBdUQsVUFqQ2xFZ0csWUFpQ1FqRztJQUFnQixPQWxDeEJvOEQsS0FrQ1FwOEQsSUFycUJOMDNELE1BcXFCTTEzRCxPQUFHQztHQUF3RTtZQUNqRmc5RCxRQUFNajlELElBQUdDO0lBQXVELFVBbENsRWdHLFlBa0NRakc7SUFBZ0IsT0FuQ3hCbzhELEtBbUNRcDhELElBdm9CTmk0RCxNQXVvQk1qNEQsT0FBR0M7R0FBd0U7WUFDakZpOUQsT0FBS2w5RCxJQUFHQztJQUFzRCxVQW5DaEVnRyxZQW1DT2pHO0lBQWdCLE9BcEN2Qm84RCxLQW9DT3A4RCxJQXZuQkxpYyxLQXVuQktqYyxPQUFHQztHQUF1RTtZQUUvRWs5RCxpQkFBZW45RCxJQUFHQztJQUM4QixVQXRDbERnRyxZQXFDaUJqRztJQUNpQyxPQTFUaER3NEQsZUF5VGV4NEQsT0FBR0M7R0FDOEM7WUFHaEVtOUQsZUFBZXA5RCxJQUFHQztJQUFLLFVBQUxBLGFBQUhEO0lBQXNCLE9BeFhyQy9LLFFBK1VGZ1IsWUF5Q2lCakc7R0FBc0Q7WUFDckU5SixRQUFNOEosSUFBR0M7SUFBOEMsVUExQ3pEZ0csWUEwQ1FqRztJQUFpRCxPQXBYdkQ5SyxNQW9YTThLLE9BQUdDO0dBQThEO1lBQ3ZFbzlELFlBQVV6K0QsR0FBRzArRDtJQUF3RCxVQTNDdkVyM0QsWUEyQ1lySDtJQUEyRCxPQW5YckV3N0QsVUFtWFV4N0QsTUFBRzArRDtHQUF1RTtZQUVwRkMsZUFBYXY5RCxJQUFHQztJQUM4QixVQTlDaERnRyxZQTZDZWpHO0lBQ2lDLE9BNVYxQ3E2RCxhQTJWU3I2RCxPQUFHQztHQUM4QztZQVM1RHU5RDtRQUFxQjlzRCxpQkFBTHExQjtJQUFjLFdBQWRBLFFBQUtyMUI7O1lBRXJCK3NELFlBQVcxQixRQUF5QkM7SUFDdEM7S0FHZSxNQTdEakIvMUQsWUF5RGU4MUQ7V0FBQUE7S0FHTixNQUxMeUIsY0FFb0N4QjtJQUl2QixPQTlGYkYsWUF3RkEwQixjQUVXekI7R0FLaUM7WUFHNUNqbEUsUUFBTWtKLElBQUdDO0lBQ1g7ZUFURXc5RCxZQVFTeDlELElBQUhEO0tBQ3FCLFVBVDNCeTlELFlBUU16OUQsSUFBR0M7SUFDa0IsT0FBQTtHQUE4QztZQUkzRXk5RCxlQUFhOStELEdBQUdDO0lBQ2xCO0tBQStELE1BdkUvRG9ILFlBc0Vlckg7S0FDTSxRQXpSbkJtdUIsYUF3UmFudUIsTUFBR0M7S0FDTjgrRDtLQUFSQztLQUNXLE1BekVmeEIsS0F1RWV4OUQsR0FDSCsrRDtJQUNaLFdBekVBdkIsS0F1RWV4OUQsR0FDWGcvRDtHQUN3QjtZQUcxQjdnQixRQUFNbitDLEdBQUVvRDtJQUNWO0tBQXdELE1BNUV4RGlFLFlBMkVRckg7S0FDYyxRQTF4QnBCbTNDLE1BeXhCTW4zQyxNQUFFb0Q7S0FDSTYyRDtLQUFINTJEO0tBQVAwMkQ7S0FDYSxNQTlFakJ5RCxLQTRFUXg5RCxHQUNNaTZEO0lBQ2QsV0E5RUF1RCxLQTRFUXg5RCxHQUNKKzVELFFBQU8xMkQ7R0FDa0I7WUFHM0I0N0QsV0FBU2ovRCxHQUFHbzhEO0lBQ2QsSUFBb0QsTUFqRnBELzBELFlBZ0ZXckgsSUFDRixNQXBOUG04RCxTQW1OU244RCxNQUFHbzhEO0lBQzBELE9BQUEsNkMsT0FsRnhFb0IsS0FpRld4OUQ7R0FDcUU7WUFHOUVrL0QsTUFBSWwvRCxHQUFFL0csR0FBSSxPQXpLTjJvQixJQXlLQTVoQixNQUFFL0csR0FBc0I7WUFDNUJrbUUsZUFBYW4vRCxHQUFFL0c7SUFBcUQsVUFyRnRFb08sWUFxRmVySDtJQUFhLE9BdEY1Qnc5RCxLQXNGZXg5RCxHQTN1QmI0NEQsYUEydUJhNTRELE1BQUUvRztHQUFxRTtZQUNwRjJTLFlBQVU0TyxrQkFBWXhhLEdBQUksT0FqSTFCOEosVUFpSVUwUSxXQUFZeGE7R0FBb0M7WUFFMURvL0QsY0FBYXArQyxPQUFPbzVDLHFCQUFxQkMsa0JBQWlCcjZEO0lBQzVELE9BMWdCRXdyQzthQXlnQjBEeHJDLE1BQTdDZ2hCLE9BQU9vNUMscUJBQXFCQyxrQkFBaUJyNkQ7R0FDdUI7WUFHakZxL0QsZ0JBQWNyL0QsR0FBRzNKLFNBQVFpbEMsS0FBSS9zQjtJQUFJLE9BMWRqQzhzQixjQTBkY3I3QixNQUFHM0osU0FBUWlsQyxLQUFJL3NCO0dBQTZDO1lBRTFFK3dELDBCQUF3QnQvRCxHQUFHdzdCLFlBQVdGO0lBQ3hDLE9BM2NFQyx3QkEwY3dCdjdCLE1BQUd3N0IsWUFBV0Y7R0FDWTtZQUdsRGlrQztJQUFtQnYrQyxPQUFPbzVDLHFCQUFxQkMsa0JBQWlCbjBELEtBQUVsRztJQUNwRSxPQW5jRSs2RDthQWtjZ0U3MEQ7YUFBN0M4YTthQUFPbzVDO2FBQXFCQzthQUFpQm4wRDthQUFFbEc7R0FPM0Q7WUFHUHcvRCxpQkFBaUJ2N0QsZ0JBQWNnQyxPQUFNakc7SUFDdkMsSUF4WHNEa0csTUF1WGZsRyxNQXRYTCxNQXB4QmhDOEIsT0FteEJvRG9FO0lBQ3RELE9BUk1uRyxLQU9nRG1HLEtBQ3pDLDZCQXNYb0JELGFBQWRoQztHQUM0QztZQU0vRDVNLHNCQUFZK0osSUFBR0MsSUFBSyxPQTFFbEJtOUQsZUEwRVVwOUQsSUFBR0MsSUFBeUI7WUFPdENvK0QsbUJBRkdydkQsWUFFMEIrc0IsV0FBVW55QjtJQUN6QyxPQXZMRSt4RCxpQkFzTDZCNS9CLFdBQVVueUIsTUFGcENvRjtHQUc2RDtZQUloRTh3QixhQUFzQixPQXRNRXkzQiwrQkFzTTZCO1lBQ3JEaHpCLGlCQXJ5QlU5Z0MsR0FxeUJrQixXQXJ5QmxCQSxHQXF5Qm1DO1lBQzdDd1UsU0FBT3JaLEdBQUksT0EvcENYOEIsT0ErcENPOUIsR0FBa0I7WUFDekIwL0QsYUFWR3R2RCxZQVVvQnBRLEdBQUksT0ExcEMzQisxRCxXQTBwQ3VCLzFELEdBVnBCb1EsZUFVdUU7WUFDMUV1dkQsV0FBUzMvRCxHQUFJLE9BaG9DYitULFNBZ29DUy9ULEdBQW9CO1lBQzdCNC9ELFdBQVM1L0QsR0FBSSxPQXRVYis3RCxTQXNVUy83RCxHQUFvQjtZQUM3QjYvRCxVQUFRNy9ELEdBQUksT0FqN0JSNFksUUFpN0JJNVksR0FBbUI7WUFDM0I4L0QsY0FBWTkvRCxHQUFJLE9BbDVCaEJvNEQsWUFrNUJZcDRELEdBQXVCO1lBQ25DKy9ELFVBQVEvL0QsR0FBSSxPQTMzQlI4WSxRQTIzQkk5WSxHQUFtQjtZQUMzQmdnRSxjQUFZaGdFLEdBQUksT0F0M0JoQnU0RCxZQXMzQll2NEQsR0FBdUI7WUFDbkNpZ0UsU0FBT2pnRSxHQUFJLE9BelVYZzhELE9BeVVPaDhELEdBQWtCO1lBQ3pCa2dFLGFBQVdsZ0UsR0FBSSxPQW5VZmk4RCxXQW1VV2o4RCxHQUFzQjtZQUNqQzhaLFVBQVE5WixHQUFJLE9BN1VaKzdELFNBNlVRLzdELEdBQW1CO1lBQzNCbWdFLFdBQVNuZ0UsR0FBSSxPQTNTYmlaLFNBMlNTalosR0FBb0I7WUFDN0JvZ0UsT0FBS3BnRSxHQUFHQyxHQUFJLE9BN2FaaVosT0E2YUtsWixHQUFHQyxHQUFtQjtZQUMzQm9nRSxTQUFPcmdFLEdBQUdDLEdBQUksT0FwWVZpQyxPQW9ZR2xDLEdBQUdDLEdBQXFCO1lBQy9CcWdFLFVBQVF0Z0UsR0FBR0MsR0FBSSxPQTVZWHNDLFFBNFlJdkMsR0FBR0MsR0FBc0I7WUFDakNzZ0UsUUFBTXZnRSxHQUFHQyxHQUFJLE9BdlpibVksTUF1Wk1wWSxHQUFHQyxHQUFvQjtZQUM3QnVnRSxNQUFJaG5ELEdBQUV4WixHQUFHQyxHQUFJLE9Bdlpib1ksSUF1WkltQixHQUFFeFosR0FBR0MsR0FBb0I7WUFDN0J3Z0UsT0FBS3pnRSxHQUFHQyxHQUFJLE9BdlFSK1ksS0F1UUNoWixHQUFHQyxHQUFtQjtZQUMzQnlnRSxXQUFTMWdFLEdBQUdDLEdBQUksT0E5T2hCK2pCLFNBOE9TaGtCLEdBQUdDLEdBQXVCO1lBQ25DMGdFLFdBQVMzZ0UsR0FBR0MsR0FBSSxPQTVQWjhZLFNBNFBLL1ksR0FBR0MsR0FBdUI7WUFDbkMyZ0UsT0FBSzVnRSxHQUFHTixNQUFNTyxHQUFJLE9BdmFkRixLQXVhQ0MsR0FBR04sTUFBTU8sR0FBeUI7WUFDdkM0Z0UsYUFBVzdnRSxHQUFHTixNQUFNTztJQUFJLHFCLE9BNTVCeEJ5WSxXQTQ1QlcxWSxHQUFHTixNQUFNTztHQUErQjtZQUNuRDZnRSxhQUFXOWdFLEdBQUdOLE1BQU1PLEdBQUksT0EzWnBCQyxXQTJaT0YsR0FBR04sTUFBTU8sR0FBK0I7WUFDbkR5TyxNQWhDRzBCLFlBZ0NhcFEsR0FBR0MsR0FBSSxPQTdSdkJJLElBNlJnQkwsR0FBR0MsR0FoQ2hCbVEsZUFnQytEO1lBQ2xFMndELFNBakNHM3dELFlBaUNnQnBRLEdBQUdDLEdBQUksT0F4WTFCMmpCLE9Bd1ltQjVqQixHQUFHQyxHQWpDbkJtUSxlQWlDcUU7WUFDeEU0d0QsYUFsQ0c1d0QsWUFrQ29CcFEsR0FBR0M7SUFBSSxPQS9YOUJ5dEIsV0ErWHVCMXRCLEdBQUdDLEdBbEN2Qm1RO0dBa0M2RTtZQUNoRjZ3RCxlQW5DRzd3RCxZQW1Dc0JwUSxHQUFHQztJQUFJLE9BN1doQ2t1QixhQTZXeUJudUIsR0FBR0MsR0FuQ3pCbVE7R0FtQ2lGO1lBQ3BGOHdELFFBcENHOXdELFlBb0NlaE4sR0FBRUMsR0FBR3BEO0lBQUksT0F2ZTNCOGlCLE1BdWVrQjNmLEdBQUVDLEdBcENqQitNLGVBb0NvQm5RO0dBQW1EO1lBQzFFa2hFLE1BckNHL3dELFlBcUNhcFEsR0FBRW9ELEdBQUksT0E3MEJsQmlYLElBNjBCWXJhLEdBQUVvRCxHQXJDZmdOLGVBcUM2RDtZQUNoRWd4RCxNQXRDR2h4RCxZQXNDYXBRLEdBQUVvRCxHQUFJLE9BNytCdEIrc0IsSUE2K0JnQm53QixHQUFFb0QsR0F0Q2ZnTixlQXNDNkQ7WUFDaEVpeEQsU0F2Q0dqeEQsWUF1Q2dCcFEsR0FBRW9ELEdBQUksT0FsMEJ6QjhzQixPQWswQm1CbHdCLEdBQUVvRCxHQXZDbEJnTixlQXVDbUU7WUFDdEVreEQsUUF4Q0dseEQsWUF3Q2VoUCxJQUFHQyxJQUFLLE9BcHlCMUJ5M0QsTUFveUJrQjEzRCxJQUFHQyxJQXhDbEIrTyxlQXdDcUU7WUFDeEVteEQsUUF6Q0dueEQsWUF5Q2VoUCxJQUFHQyxJQUFLLE9BdHdCMUJnNEQsTUFzd0JrQmo0RCxJQUFHQyxJQXpDbEIrTyxlQXlDcUU7WUFDeEVveEQsT0ExQ0dweEQsWUEwQ2NoUCxJQUFHQyxJQUFLLE9BdHZCekJnYyxLQXN2QmlCamMsSUFBR0MsSUExQ2pCK08sZUEwQ21FO1lBRXRFcXhELGlCQTVDR3J4RCxZQTRDd0JoUCxJQUFHQztJQUNoQyxPQXpiRXU0RCxlQXdiMkJ4NEQsSUFBR0MsSUE1QzNCK087R0E2Q2tEO1lBR3JEc3hELGlCQWhER3R4RCxZQWdEd0JoUCxJQUFHQyxJQUFLLE9BdmZuQ2hMLFFBdWNHK1osZUFnRHdCaFAsSUFBR0M7R0FBd0M7WUFDdEV2SSxRQWpER3NYLFlBaURlaFAsSUFBR0MsSUFBSyxPQW5mMUIvSyxNQW1ma0I4SyxJQUFHQyxJQWpEbEIrTyxlQWlEcUU7WUFDeEV1eEQsWUFsREd2eEQsWUFrRG1CcFEsR0FBRzArRDtJQUFNLE9BbGYvQmxELFVBa2ZzQng3RCxHQUFHMCtELElBbER0QnR1RDtHQWtEK0U7WUFFbEZ3eEQsZUFwREd4eEQsWUFvRHNCaFAsSUFBR0M7SUFDOUIsT0EzZE1vNkQsYUEwZHFCcjZELElBQUdDLElBcER6QitPO0dBcURnRDtZQUduRHl4RCxVQXhER3p4RCxZQXdEaUJwTixHQUFJLE9BOVZ4QnBELFFBOFZvQm9ELEdBeERqQm9OLGVBd0RpRTtZQUNwRTB4RCxjQXpERzF4RCxZQXlEcUIxUztJQUFJLE9BM1Y1QnNwQyxZQTJWd0J0cEMsR0F6RHJCMFM7R0F5RHlFO1lBQzVFMnhELFdBMURHM3hELFlBMERrQmhOLEdBQUksT0F0VnpCOHBDLFNBc1ZxQjlwQyxHQTFEbEJnTixlQTBEbUU7WUFFdEU0eEQsNEJBNURHNXhELFlBNERtQ2hOO0lBQ3hDLE9BM21DRXd6RCwwQkEwbUNzQ3h6RCxHQTVEbkNnTjtHQTZEeUQ7WUFHNUQ2eEQsd0NBQWdEOWlFLEtBQUtjLEdBQ3ZELE9BMW9DRW0yRCwrQkF5b0NnRGozRCxLQUFLYztHQUNUO1lBRzVDaWlFLGtCQXBFRzl4RCxZQW9FeUJoTjtJQUFJLE9BdG1DaEMwekQsZ0JBc21DNEIxekQsR0FwRXpCZ047R0FvRWlGO1lBQ3BGK3hELGFBQVkveEQsWUFBV3BOO0lBQUksT0F2eUIzQm0yRCxXQXV5Qlkvb0QsMEIsY0FBV3BOO0dBQWlEO1lBRXhFby9ELG9CQXZFR2h5RCxZQXVFMkJ0STtJQUNoQyxPQXhRRTQwRCxrQkF1UThCNTBELElBdkUzQnNJO0dBd0VrRDtZQUdyRGl5RCxXQTNFR2p5RCxZQTJFa0JwUSxHQUFHbzhEO0lBQVEsT0F0VWhDRCxTQXNVcUJuOEQsR0FBR284RCxPQTNFckJoc0Q7R0EyRWlGO1lBQ3BGa3lELFFBNUVHbHlELFlBNEVlcFEsR0FBRW9ELEdBQUksT0FsNUJ4Qit6QyxNQWs1QmtCbjNDLEdBQUVvRCxHQTVFakJnTixlQTRFaUU7WUFDcEVteUQsTUFBSXZpRSxHQUFFL0csR0FBSSxPQTFSTjJvQixJQTBSQTVoQixHQUFFL0csR0FBaUI7WUFDdkJ1cEUsZUE5RUdweUQsWUE4RXNCcFEsR0FBRS9HO0lBQUksT0E1MUIvQjIvRCxhQTQxQnlCNTRELEdBQUUvRyxHQTlFeEJtWDtHQThFK0U7WUFDbEYyZSxZQUFVdlUsa0JBQVl4YSxHQUFJLE9BbFAxQjhKLFVBa1BVMFEsV0FBWXhhLEdBQStCO1lBQ3JEbzVELFFBQVFwNUQsR0FBSSxPQUFKQSxFQUFLO1lBQ2J5aUUsZUFBc0J6aUUsR0FBSSxPQUFKQSxFQUFLO1lBRTNCMGlFO0lBQWF0eUQsWUFBWTRRLE9BQU9vNUMscUJBQXFCQyxrQkFBaUJyNkQ7SUFDeEUsT0E3bkJFd3JDO2FBNG5CYXA3QixZQUFZNFEsT0FBT281QyxxQkFBcUJDLGtCQUFpQnI2RDtHQUNJO1lBRzFFMmlFLHVCQUE0QjNpRSxHQUFHM0osU0FBUWlsQyxLQUFJL3NCLEdBQUksT0E3a0IvQzhzQixjQTZrQjRCcjdCLEdBQUczSixTQUFRaWxDLEtBQUkvc0I7R0FBd0M7WUFFbkZxMEQsaUNBQXNDNWlFLEdBQUd3N0IsWUFBV0YsS0FDdEQsT0E5akJFQyx3QkE2akJzQ3Y3QixHQUFHdzdCLFlBQVdGO0dBQ1A7WUFHN0N1bkM7SUFBbUJ6eUQsWUFBWTRRLE9BQU9vNUMscUJBQXFCQyxrQkFBaUJuMEQsS0FBRWxHO0lBQ2hGLE9BdGpCRSs2RDthQXFqQm1CM3FELFlBQVk0USxPQUFPbzVDLHFCQUFxQkMsa0JBQWlCbjBELEtBQUVsRztHQUNLO1lBR25Ga2EsY0FBWWxhLEdBQUdOLE1BQU1PO0lBQUksT0FBQSw4QkFwRXpCMmdFLFFBb0VlbGhFLE1BQU1PLEdBQVREO0dBQW1EO1lBSzdEOGlFLFlBdEdDMXlELFlBc0dxQmhQLElBQVFDO0lBQ2hDLE9BaFFFNjdELFlBK1BzQjk3RCxJQUFRQyxJQXRHN0IrTyxlQUFBQTtHQTJHMkM7WUFHNUN6VyxRQUFPeVcsWUFBV2hQLElBQUdDO0lBQ3ZCO0tBNVA0QmdHLGNBMlBuQitJO0tBM1BNaXRELGNBMlBOanREO2VBdlFQOHNELFlBdVFxQjc3RCxJQUFIRCxJQTNQTGk4RCxhQUFhaDJEO0tBRTFCLFVBZEE2MUQsWUF1UWtCOTdELElBQUdDLElBM1BSZzhELGFBQWFoMkQ7SUFFMUIsT0FBQTtHQThQNEM7R0FoQm5DLElBQUEsWUFHVHk3RCxhQVFBbnBFO1lBZUZvcEUsVUFBUS9pRSxHQUFJLE9BQUpBLEtBQVU7WUFDbEJnakUsVUFBUzV5RCxZQUFXdXBELE1BQU8sV0FBbEJ2cEQsWUFBV3VwRCxNQUEyQjtZQUUvQ3NKLG1CQUZTN3lELFlBRW9CK3NCLFdBQVVueUI7SUFHdkMsSUFMb0IydUQsT0FsVHBCb0QsaUJBb1Q2QjUvQixXQUFVbnlCLE1BRjlCb0Y7SUFBa0IsV0FBbEJBLFlBQVd1cEQ7R0FLbUQ7WUFHdkV1SixRQUFPOXlEO0lBQWEsV0FBYkEsWUFyVWlCdW9EO0dBcVU4Qjs7SUFHNUMsSUFBUnozQixvQkF4VXNCeTNCO0lBdVVtQyxXQUN6RHozQjs7WUFHRmlpQyxZQUFXL3lELFlBQVd2TCxHQUFJLFdBQWZ1TCxnQkFBV3ZMLElBQTRDO1lBRWxFdStELGFBaEJTaHpELFlBZ0JjcE47SUFDTCxJQWpCRTIyRCxPQWgyQnBCUixXQWcyQlMvb0QsWUFEVDJ5RCxXQWlCdUIvL0Q7SUFoQkksV0FBbEJvTixZQUFXdXBEO0dBaUJ1QztZQUczRDBKLDRCQUEyQmp6RCxZQUFXeEw7SUFFdEMsSUFERSswRCxPQWpzQ0YvQywwQkFnc0NzQ2h5RCxPQUFYd0w7SUFJN0IsV0FKNkJBLFlBQ3pCdXBEO0dBR2dCO1lBR2xCMkosaUNBM0JTbHpELFlBMkJxQ2pSLEtBQUtjO0lBQ2pDLElBNUJFMDVELE9BdnNDcEJ2RCwrQkFrdUM4Q2ozRCxLQUFLYztJQTNCeEIsV0FBbEJtUSxZQUFXdXBEO0dBNEI4QztZQUdsRTRKLGtCQUFpQm56RCxZQUFXeEw7SUFFNUIsVUFqc0NBa3lELGdCQStyQzRCbHlELE9BQVh3TDtJQUdiLE9BQUE7OztzQkFBSXVwRCxNQUFRLFdBSEN2cEQsWUFHVHVwRCxNQUE0QjtHQUFDO1lBR3JDNkosVUFBU3B6RCxZQUFXcE47SUFDdEIsV0FEV29OLFlBemNUeFEsUUF5Y29Cb0QsR0FBWG9OO0dBQ3NFO1lBRy9FcXpELGNBQWFyekQsWUFBVzFTO0lBQzFCLFdBRGUwUyxZQXpjYjQyQixZQXljd0J0cEMsR0FBWDBTO0dBQ3NFO1lBR25Gc3pELFdBQVV0ekQsWUFBV2hOO0lBQ3ZCLFdBRFlnTixZQXZjVjg4QixTQXVjcUI5cEMsR0FBWGdOO0dBQ3NFO1lBR2hGdXpELG9CQUFtQnZ6RCxZQUFXdEk7SUFDaEMsT0FoWEU0MEQsa0JBK1c4QjUwRCxJQUFYc0k7R0FDZ0Q7WUFHbkUwRyxNQUFLMUcsWUFBV3BRLEdBQUdDO0lBQ3JCLFdBRE9tUSxZQWhiTC9QLElBZ2JnQkwsTUFBR0MsR0FBZG1RO0dBQzhFO1lBR25Gd3pELGFBQVl4ekQsWUFBV3BRLEdBQUdDO0lBQzVCLFdBRGNtUSxZQXBoQlpzZCxXQW9oQnVCMXRCLE1BQUdDLEdBQWRtUTtHQUdiO1lBU0R5ekQsYUFBMEI3akUsR0FDNUIsSUFJTW9RLGFBTHNCcFEsTUFDcEIsV0FJRm9RLFlBQ0Y7WUFJRjB6RCxRQUQ4QnRxRDtJQUNwQixJQXZFRHBKLGFBc0VxQm9KO0lBdEVSLFdBQWJwSixZQXJVaUJ1b0Q7R0E0WW9DO1lBQzlEb0wsWUFGOEJ2cUQsR0FFbEJwVyxHQUFJLE9BbEVkKy9ELFlBZ0U0QjNwRCxNQUVsQnBXLEdBQThEO1lBQzFFNGdFLGFBSDhCeHFELEdBR2pCcFcsR0FBSSxPQWpFZmdnRSxhQThENEI1cEQsTUFHakJwVyxHQUErRDtZQUU1RTZnRSw0QkFMOEJ6cUQsR0FLRnBXO0lBQzlCLE9BaEVJaWdFLDRCQTBENEI3cEQsTUFLRnBXO0dBQzRDO1lBR3hFOGdFLGlDQVQ4QjFxRCxHQVNNcmEsS0FBS2M7SUFDM0MsT0E3RElxakUsaUNBbUQ0QjlwRCxNQVNNcmEsS0FBS2M7R0FDNEM7WUFHckZra0Usa0JBYjhCM3FELEdBYVpwVyxHQUFJLE9BNURwQm1nRSxrQkErQzRCL3BELE1BYVpwVyxHQUFvRTtZQUN0RmdoRSxVQWQ4QjVxRCxHQWNwQnBXLEdBQUksT0F2RFpvZ0UsVUF5QzRCaHFELE1BY3BCcFcsR0FBNEQ7WUFDdEVpaEUsY0FmOEI3cUQsR0FlaEJwVyxHQUFJLE9BcERoQnFnRSxjQXFDNEJqcUQsTUFlaEJwVyxHQUFnRTtZQUM5RWtoRSxXQWhCOEI5cUQsR0FnQm5CcFcsR0FBSSxPQWpEYnNnRSxXQWlDNEJscUQsTUFnQm5CcFcsR0FBNkQ7WUFFeEVtaEUsb0JBbEI4Qi9xRCxHQWtCVnBXLEdBQ3RCLE9BaERJdWdFLG9CQTZCNEJucUQsTUFrQlZwVyxHQUM0QztZQUdoRWl0QixNQXRCOEI3VyxHQXNCeEJwVyxHQUFHbkQsR0FBSSxPQS9DWDZXLE1BeUI0QjBDLE1Bc0J4QnBXLEdBQUduRCxHQUEyRDtZQUNwRXVrRSxhQUFXaHJELEdBQUVwVyxHQUFHbkQsR0FBSSxPQTVDbEIyakUsYUE0Q1NwcUQsTUFBRXBXLEdBQUduRCxHQUFrRTttQkFNdEYsV0FFRztZQWdDQ3drRSxZQUFnQ0M7SSxnQkFBbUMxa0U7S0FDckUsT0E5U0k0TCxZQTZTOEI4NEQsd0JBQ0EsV0FBYSxHQURzQjFrRSxHQUNuQjs7WUFHaEQya0UsWUFFVUQ7SSxnQkFDUjE1RCxNQUVKLE9BcEpJaTRELG1CQWlKUXlCLFFBQUFBLFFBQ1IxNUQsTUFFMkU7O1lBRzdFNDVELGlCQUFxQ0Y7SUFHVixVQUFBLDZCQUhVQTtJQUdWLE9BQUE7O1lBRzNCRyxtQkFBb0N6akUsSUFBR0MsSUFBSyxPQTVXMUNtOUQsZUE0V2tDcDlELElBQUdDLElBQXlCO1lBQ2hFeWpFLGlCQUFnQzFqRSxJQUFHQyxJQUFLLE9BNVd0Qy9KLFFBNFc4QjhKLElBQUdDLElBQWdCO1lBRW5EMGpFLGNBQWtDTDtJLGdCQUFxQ3orRDtLQUN6RSxVQURvQ3krRDtLQUNwQyxxQixPQTdTSWxGLHNCQTRTcUV2NUQsY0FDbkM7O1lBR3BDKytELFNBQVVwL0QsUUFBTzVGO0lBQ25CO0tBQWtDLE1BQUE7S0FBOUJpRyxRQUFRLFdBTFY4K0QsY0FJVW4vRCxjQUFPNUY7SUFFbkIsT0FBQSx5QkFESWlHO0dBQ3FCOztJQVlyQmcvRDs7SUF6S0VDO1lBNktGQyxZQUFVL2hFLEdBQUksT0ExS2QrL0QsWUFzS0E4QixjQUlVN2hFLEdBQTRDO1lBQ3REZ2lFLGFBQVdoaUUsR0FBSSxPQXpLZmdnRSxhQW9LQTZCLGNBS1c3aEUsR0FBNkM7WUFFeERpaUUsNEJBQTBCamlFO0lBQzVCLE9BeEtFaWdFLDRCQWdLQTRCLGNBTzBCN2hFO0dBQzRCO1lBR3REa2lFLGlDQUFrQ25tRSxLQUFLYztJQUN6QyxPQXJLRXFqRSxpQ0F5SkEyQixjQVdrQzlsRSxLQUFLYztHQUM0QjtZQUduRXNsRSxrQkFBZ0JuaUUsR0FBSSxPQXBLcEJtZ0Usa0JBcUpBMEIsY0FlZ0I3aEUsR0FBa0Q7WUFDbEVvaUUsVUFBUXBpRSxHQUFJLE9BL0pab2dFLFVBK0lBeUIsY0FnQlE3aEUsR0FBMEM7WUFDbERxaUUsY0FBWXJpRSxHQUFJLE9BNUpoQnFnRSxjQTJJQXdCLGNBaUJZN2hFLEdBQThDO1lBQzFEc2lFLFdBQVN0aUUsR0FBSSxPQXpKYnNnRSxXQXVJQXVCLGNBa0JTN2hFLEdBQTJDO1lBQ3BEdWlFLG9CQUFrQnZpRTtJQUFJLE9BdEp0QnVnRSxvQkFtSUFzQixjQW1Ca0I3aEU7R0FBb0Q7WUFDdEV3aUUsTUFBSXhpRSxHQUFHbkQsR0FBSSxPQW5KWDZXLE1BK0hBbXVELGNBb0JJN2hFLEdBQUduRCxHQUF5QztZQUNoRDRsRSxhQUFXemlFLEdBQUduRCxHQUFJLE9BaEpsQjJqRSxhQTJIQXFCLGNBcUJXN2hFLEdBQUduRCxHQUFnRDtZQUM5RDZsRSxVQUFRbk0sTUFBTyxXQXRCZnNMLGNBc0JRdEwsTUFBMkI7WUFDbkNvTSxVQUFRL2xFLEdBQUksT0FBSkEsS0FBVTs7Ozs7T0E5VXBCM0k7T0EvR0VvbUU7T0F1VEZvRztPQXhURXp6RDtPQWtVRjB6RDtPQUNBQztPQWpVRTNxRDtPQUNBRTtPQXVCQTJXO09BRUFpdUM7T0FDQUM7T0FDQUM7T0FzU0Y0RjtPQXJTRTNGO09BQ0FDO09BRUFDO09BSUFDO09BbUVBZ0I7T0FsRUFsb0U7T0FwQkFvaUI7T0FDQUM7T0FDQUY7T0FDQUY7T0FDQU07T0FFQUQ7T0FEQW1XO09BeURBbXZDO09BQ0FDO09BMUNBVjtPQUVBRTtXQVlFRSxhQVFBM21FO09BaVJKa3NFO09BQ0FDO09BQ0FDO09BdFVFeGtFO09BQ0FpYTtPQWtVRm9xRDtPQVJBRjtPQUlBQztPQVNBSztPQUlBbDBDO09BQ0FtMEM7T0E3VEV2RztPQWRBN2pEO09BR0E3QjtPQUZBNEI7T0FDQTRqRDtPQUVBNWtEO09BQ0E2a0Q7T0FpREFjO09BL0RBcEI7T0FDQTFqRDtPQUNBMmpEO09BQ0ExakQ7T0FDQTJqRDtPQUNBQztPQUNBQztPQThEQTNmO09BS0E4Z0I7T0FRQUc7T0FJQUM7T0FFQUM7O09BSUFDOztPQWlTRmtGO09BSUFFO09BUUFDO09BTUFDO09BQ0FDO09BRUFDO09BSUFDOztRQXZaRTVyRDtRQUNBRTtRQWNBSDtRQUpBaUI7UUFHQTdCO1FBR0FtQjtRQUNBQztRQUNBRjtRQUNBRjtRQUNBTTtRQUVBRDtRQWRBOVo7UUFDQWlhO1FBWEEwakQ7UUF5QkF4dEM7UUFFQWl1QztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUlBQztRQUNBbG5FO1FBQ0FtbkU7UUFFQUU7WUFZRUUsYUFRQTNtRTtRQWhERmlpQjtRQUNBNGpEO1FBR0FDO1FBU0FDO1FBd0NBYTtRQS9EQXBCO1FBQ0ExakQ7UUFDQTJqRDtRQUNBMWpEO1FBQ0EyakQ7UUFDQUM7UUFDQUM7UUE4REEzZjtRQUtBOGdCO1FBckRBbHZDO1FBeURBbXZDO1FBQ0FDO1FBNFdBNEc7UUF6V0EzRztRQUlBQztRQUVBQztRQUlBQztRQStKRTJGO1FBNktGQztRQUNBQztRQVdBSTtRQUNBQztRQUNBQztRQUhBSDtRQVJBRjtRQUlBQztRQVFBSztRQUNBQztRQUNBQztRQUNBQzs7UUExV0FsNkQ7UUFrS0FxM0Q7O1NBakRBbDBDO1NBN0VBMHdDOztTQU9BcG1EO1NBRUFzbUQ7U0FVQVM7U0FRQVE7U0FvRUExbUQ7U0EzRUFtbUQ7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FFQUU7U0FUQTdtRDtTQUNBcW1EO1NBVkFUO1NBMkJBeUI7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FFQUM7U0FJQUM7U0FDQTVvRTtTQUNBNm9FO1NBRUFDO1NBdEJBZjtTQUNBQztTQUtBSTtTQUhBSDtTQUVBRTtTQXZCQXJCO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBMERBb0M7U0FEQUQ7U0FoREEzQjtTQWtEQTZCO1NBQ0FDO1NBRUFwSjtTQUdBc0o7U0FJQUM7U0FFQUM7U0FJQUM7U0F0RkEzaEM7U0FDQXlFO1NBNkRBdzhCO1NBYkFOO1NBQ0FDO1NBQ0FDO1NBVUFHO1NBUkFGO1NBSUFDO1NBT0FHO1NBdkNBMXpEO1NBRUFzeUQ7U0ErQ0F5QjtTQWhSd0I5SjtRQTRFeEJ2L0M7UUFDQUU7UUFjQUg7UUFKQWlCO1FBR0E3QjtRQUdBbUI7UUFDQUM7UUFDQUY7UUFDQUY7UUFDQU07UUFFQUQ7UUFkQTlaO1FBQ0FpYTtRQVhBMGpEO1FBeUJBeHRDO1FBRUFpdUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFFQUM7UUFJQUM7UUFDQWxuRTtRQUNBbW5FO1FBRUFFO1lBWUVFLGFBUUEzbUU7UUFoREZpaUI7UUFDQTRqRDtRQUdBQztRQVNBQztRQXdDQWE7UUEvREFwQjtRQUNBMWpEO1FBQ0EyakQ7UUFDQTFqRDtRQUNBMmpEO1FBQ0FDO1FBQ0FDO1FBOERBM2Y7UUFLQThnQjtRQXJEQWx2QztRQXlEQW12QztRQUNBQztRQWdLQTREO1FBN0pBM0Q7UUFJQUM7UUFFQUM7UUFJQUM7UUE0SkEyRDtRQU1BQztRQUVBQztRQXFCQUk7UUFJQUM7UUFJQUM7UUFkQUg7UUFYQUY7UUFPQUM7UUFzQkFLO1FBSUE3c0Q7UUFJQThzRDtRQXpEQVo7UUFuUEE1eUQ7UUF5R0FvdkQ7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7SUM3cENJbnBFO0lBQ0FDO0lBQ0FvYTtJQUFBNUc7WUFFUkYsZUFaTXVMO0lBQW9CLE9BQUEsNkJBQXBCQTtHQUFxRDtZQTJCekQzVSxLQUFLWSxJQUFHQztJQUNWLElBQUlnbUMsTUFER2ptQztJQUFBQSxRQUFHQztJQUFBQSxRQUNOZ21DOztHQUVLO1lBR1AyK0IsUUFBUWhtRSxHQUFFQyxHQUFGRCxPQUFXLFdBQVRDLEdBQUZELGdCQUFlO1lBRXZCaW1FLGdCQUFnQmptRSxHQUFFb0QsR0FBR25EO0lBQ3ZCLElBQUlpbUUsYUFEY2xtRTtJQUFBQSxPQUFFb0Q7SUFHSSxPQUFBOzJCQUhEbkQsbUJBQUxELE9BQ2RrbUUscUJBRThDO0dBQUM7WUFNL0MvK0IsZUFBVy9qQyxjQUFIcUUsY0FBQUEsT0FBR3JFO1lBQ1graUUsS0FBSzczRCxJQUFLLGdDQUFMQSxJQURMNjRCLEtBQzZCO1lBQzdCaS9CLG9CQUFhMytELGNBQVMsV0FBVEEsR0FBQUE7WUFJZjQrRCxpQkFBaUJDLFlBQVlybUU7SUFDL0IsSUFBSWltRSx1Q0FEZUksWUFKZkY7SUFEQUQsS0FLZUc7SUFHSyxPQUFBOzJCQUhPcm1FLG1CQUdJLE9BUi9Ca21FLEtBTUFELFlBRXdEO0dBQUM7Ozs7T0E3Q3JEN3ZFO09BQ0FDO09BQ0FvYTtPQUFBNUc7T0FFUkY7T0FlRXBKO09BTUF3bEU7T0FFQUM7V0FTRTkrQixLQUNBZy9CLE1BQ0FDO09BSUZDOzs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNQQUUsa0JBQWtCdm1FO0lBQUFBLE9BQXVCLDRCQUF2QkE7O0dBQTBDO1lBQzVEc3JELFNBQVN0ckQsR0FBSSxPQUFBLDRCQUFKQSxTQUFjO1lBQ3ZCd21FLFdBQVd4bUUsR0FBRS9HO0lBQUksV0FBTitHLE1BQU0sT0FBQSw0QkFBTkEsTUFBRS9HO0lBQUksT0FBQTtHQUF5QjtZQUMxQ216QyxXQUFXcHNDLEdBQUUvRztJQUE0QyxXQUR6RHV0RSxXQUNXeG1FLEdBQUUvRztJQUE0QyxPQUFBLGtDQUE5QytHO0dBQThEO1lBRXpFMHNDLFdBQVcxc0MsR0FBRS9HLEdBQUVtSztJQUF3QyxXQUh2RG9qRSxXQUdXeG1FLEdBQUUvRztJQUFNLE9BQUEsa0NBQVIrRyxZQUFJb0Q7R0FBMEQ7WUFHekVxakUsZ0JBQWdCem1FLEdBQUUvRztJQUNwQixXQURvQkEsK0JBQUYrRyxRQUFFL0c7O0lBTWI7Z0NBQXlDLHdCQU45QitHO0tBTVgsMEJBQVcsd0JBTkUvRztLQUloQixPQUFBO0lBQUEsT0FBQTtHQUV3RTtZQUcxRThZLElBQUkvUixHQUFFL0csR0FUTnd0RSxnQkFTSXptRSxHQUFFL0csSUFDUixPQWZFbXpDLFdBY0lwc0MsR0FBRS9HLEdBRU07WUFHWmt1QyxJQUFJbm5DLEdBQUUvRyxHQUFFbUs7SUFkUnFqRSxnQkFjSXptRSxHQUFFL0c7SUF0Qk5zdEUsa0JBc0JJdm1FO0lBRU4sT0FuQkUwc0MsV0FpQkkxc0MsR0FBRS9HLEdBQUVtSztHQUdNO1lBR2QyUSxTQUFTL1QsR0FBSSxhQUFKQSxhQUFnQjtZQUN6QjhCLGtCQUFTQSxtQkFBYyxPQUFkQTtZQUVUNGtFLG1CQUFtQjFtRSxHQUFFMm1FO0lBQ3ZCLFdBRHFCM21FLFNBQUUybUU7O2FBbEVuQnR5RCxnQkF3RWtDLFdBQWE7SUEvRC9CO0tBUkF1eUQsb0JBaUVDNW1FO0tBaEVUNm1FLFlBZ0VTN21FO0tBL0RWOG1FLFdBK0RVOW1FO0tBOURSK21FLGFBOERRL21FO0tBN0RWZ25FLFdBNkRVaG5FO0tBekRidXpDLFVBQVksaUNBVGhCbC9CLFVBS08yeUQ7S0FHTHJiLGdDQUNFcFk7S0FJQUUsVUFBWSw2QkFUUHN6QjtLQVFQbGIsa0NBQ0VwWSxlQUxGa1k7S0FTRWhZLFVBQVksNkJBZFRtekI7S0FhTEcsa0NBQ0V0ekIsZUFMRmtZO0tBU0VILFVBQVksNkJBbkJSbWI7S0FrQk5LLGtDQUNFeGIsZUFMRnViO0tBU0VyYixVQUFZLDZCQXhCQWdiO0tBdUJkTyxrQ0FDRXZiLGVBTEZzYjtLQWtERjtPQUFBOzs7MEJBOUNFQztJQThDRixPQUFBO0dBRW1EO1lBR3JEOXdFLFFBY0VnUixhQUFZakcsSUFBR0M7SUFDakIsR0FBRyw2QkFEV0QsSUFBR0MsS0FFWjtRQWZnRStsRSxPQWFwRC9sRSxPQWI4Q2dtRSxPQWFqRGptRSxPQWIyQ3MwQyxPQWF4Q3IwQyxPQWJrQ3MwQyxPQWFyQ3YwQyxPQWJ3QnNaO0lBQ3RDO2lCQURzQ0EsUUFBbUJnN0I7UUFBbkJoN0IsUUFBYWk3QjtlQUlsQztLQUV5QjtNQUFBLE9BNUMxQ3ZKLFdBbURpQi9xQyxJQWJxQnFaO01BTWhDcHJCLElBQUksV0FPUitYLGFBbkRGK2tDLFdBbURjaHJDLElBYndCc1o7S0FWdENnc0QsbUJBdUJjdGxFLElBYmlEaW1FO0tBVi9EWCxtQkF1QmlCcmxFLElBYm9EK2xFO2NBTS9EOTNFLEdBS0ksT0FMSkE7S0FJb0MsSUFWSndyQyxRQVVJLDRCQVZKcGdCO0tBQUFBLE1BQUFvZ0I7O0dBeUJaO1lBRzFCeGtDLE1BU0VxUyxXQUFVdkgsSUFBR0M7SUFDZixXQUFBLDZCQURZRCxJQUFHQztJQUNmOzs7S0FHQSxJQURJczBDLE9BSFF2MEMsT0FJUnMwQyxPQUpXcjBDLGNBR1hzMEMsU0FDQUQ7O1VBWmlEMHhCLE9BUXRDL2xFLE9BUmdDZ21FLE9BUW5Dam1FLE9BUnNCc1o7TUFDbEM7a0JBRGtDQSxRQVc5Qmk3Qjs7OztRQVJrQztTQUFBLE9BdEV0Q3ZKLFdBMkVlL3FDLElBUm1CcVo7U0FHOUJyWCxJQUFJLFdBS05zRixXQTNFRnlqQyxXQTJFWWhyQyxJQVJzQnNaO1FBdkNsQ2dzRCxtQkErQ1l0bEUsSUFSbUNpbUU7UUF2Qy9DWCxtQkErQ2VybEUsSUFSc0MrbEU7V0FHakQvakU7U0FHNkIsSUFOQ3kzQixRQU1ELDRCQU5DcGdCO1NBQUFBLE1BQUFvZ0I7OzttQkFHOUJ6M0I7Ozs7Ozs7SUFNSjtHQVkyQjtZQUczQndHLFVBQVVvdUIsYUFBWWo0QjtJQUN4QixJQUFNMm1FLGdCQURrQjNtRSxNQUNhc25FLFFBRGJ0bkUsTUFDb0I4QixTQURwQjlCLE1BQ091ckQsT0FEUHZyRDtJQUV4QixPQURxQ3NuRTtLQUNyQyxNQUFBO09BRHFDQSxTQTlGbkNoYyxTQTZGc0J0ckQ7S0FHeEIsTUFBQTtJQUNlLElBQVh1bkUsYUFqR0ZqYyxTQTZGc0J0ckQ7T0FJcEJ1bkUsZUFDZSxpQ0FKWWhjO0tBSS9CLE1BQUE7V0FESWdjO0tBRUosTUFBQTtJQUNPLEtBQUEseUJBSEhBO0tBR0osTUFBQTtXQU40Q3psRTtLQU81QyxNQUFBO09BUDRDQSxTQUd4Q3lsRTtLQUtKLE1BQUE7SUFDYSxJQUFBLE9BQUEsNEJBTlRBLGdCQU1KOztTQUFBdHVFOztTQUFBQSxJQVZ3QitHO09BYXBCLFdBYlFpNEIsYUEzRlZtVSxXQTJGc0Jwc0MsR0FVeEIvRztPQXpFRXl0RSxtQkErRHNCMW1FLEdBQ2xCMm1FOzs7T0EzRm1ELFdBRnZESCxXQTRGc0J4bUUsR0FVeEIvRztPQUttQixHQXpHc0Msa0NBMEZqQytHO1FBZWpCLE1BQUE7O01BTFAsV0FBQS9HO2tCQUFBQTtNQUFBQTs7OztHQU1JO1lBR0ZpRyxPQUFpQm9zRDtJQUNuQixHQURtQkE7U0FJVmljLGFBSlVqYztLQUtmLFFBREtpYzt1QkFBQUEsaUJBU0EseUJBVEFBOztNQU1FO09BQUEsNkJBQWMsd0JBTmhCQTtPQUlELE9BQUE7Y0FERjtTQU5GQzs7O1NBQUFBO0lBa0JLLFdBQUEsaUNBbEJMQTtJQWNKLGlCQUVTLDRCQWhCTEE7R0FtQkg7WUFHQ0MsY0FBZTdyQyxLQUFJRTtJQUNDLFdBQUEsaUNBRERBO09BQUpGO0tBQ2pCLE1BQUE7SUFDb0M7WUFGbkJBO0tBRW1CLE9BeklsQzB2QixTQXVJZTF2QjtLQUVrQixPQUFBO0tBQS9COHJDLFlBQVkseUJBRkM5ckM7S0FHYityQyxXQUFXLDRCQUhFL3JDLFFBRWI4ckM7SUFFSixrQ0FKaUI5ckMsUUFBQUEsUUFBSUUsUUFFakI0ckM7SUFFSixPQUFBO29DQUppQjlyQyxXQUFJRSxLQUVqQjRyQyxXQUNBQztHQUU0RTtZQUc5RTNiLGFBQWFoc0QsR0FBRTRuRTtJQWhKZnJCLGtCQWdKYXZtRTtJQUl5QjtLQUFBLE9BQUEsNEJBSnZCNG5FLGtCQUFGNW5FO0tBSWtCLE9BQUE7S0FBN0Jpc0QsZUFBZTtZQUFmQSxpQkFuSkZYLFNBK0lhdHJEOztLQU9ILElBQU44N0IsTUFBTSxpQ0FIUm13QjtLQVpGd2IsY0FRYXpuRSxHQU9UODdCO0tBUFM5N0I7S0FBQUEsT0FVSCw0QkFOUmlzRDtLQUpXanNELE9BT1Q4N0I7Ozs7OztHQUlVO1lBR2QrckMsUUFBUTduRSxHQUFFb0Q7SUE5SlZtakUsa0JBOEpRdm1FO0lBRUksV0EvSlpzckQsU0E2SlF0ckQ7T0FBQUEsZUFkUmdzRCxhQWNRaHNELEdBRW1DLCtCQUZuQ0E7SUF6SlIwc0MsV0F5SlExc0MsR0FBQUEsTUFBRW9EO0lBQUZwRCxPQUlFLDRCQUpGQTs7R0FJYztZQUd0QjhuRSxpQkFBaUI5bkU7SUFyS2pCdW1FLGtCQXFLaUJ2bUU7SUFHbkI7S0FESXVyRCxPQUZldnJEO0tBR2ZzbkUsUUFIZXRuRTtLQUlma0QsTUFBTSxrQ0FGTnFvRCxNQUNBK2I7SUFFSixrQ0FISS9iLE1BQ0ErYjtJQUhldG5FLE9BbktqQndtRSxXQW1LaUJ4bUU7SUFBQUEsT0FPUCw0QkFQT0E7SUFRbkIsT0FKSWtEO0dBSUQ7WUFHRDZrRSxZQUFZL25FO0lBQUksR0FwSmhCK1QsU0FvSlkvVCxJQUF1QixNQUFBO0lBQTRCLE9BWC9EOG5FLGlCQVdZOW5FO0dBQXFFO1lBQ2pGZ29FLFFBQVFob0UsR0FBSSxPQXJKWitULFNBcUpRL1QsYUFaUjhuRSxpQkFZUTluRSxJQUEwRDtZQUNsRWlvRSxlQUFlam9FO0lBQUkseUNBQUpBLE1BQUFBO0dBQW1EO1lBQ2xFa29FLGNBQWNsb0U7SUFBSSxPQWhMbEJvc0MsV0FnTGNwc0MsR0FBaUIsNEJBQWpCQTtHQUErQjtZQUM3Q21vRSxLQUFLbm9FLEdBQUksT0F4SlQrVCxTQXdKSy9ULGFBRkxpb0UsZUFFS2pvRSxJQUF3RDtZQUM3RG9vRSxTQUFTcG9FO0lBQUksR0F6SmIrVCxTQXlKUy9ULElBQXVCLE1BQUE7SUFBNEIsT0FINURpb0UsZUFHU2pvRTtHQUFtRTtZQUM1RXFyQixLQUFLcnJCLEdBQUksT0ExSlQrVCxTQTBKSy9ULGFBSExrb0UsY0FHS2xvRSxJQUF1RDtZQUM1RG9yQixTQUFTcHJCO0lBQUksR0EzSmIrVCxTQTJKUy9ULElBQXVCLE1BQUE7SUFBNEIsT0FKNURrb0UsY0FJU2xvRTtHQUFrRTtZQUUzRWtyRCxNQUFNbHJEO0lBekxOdW1FLGtCQXlMTXZtRTttQkFBQUE7O0tBSU8sSUFBQSxPQUFBLDRCQUpQQSxVQUdIOztVQXRMWS9HOztPQUF3QyxXQUp2RHV0RSxXQXVMTXhtRSxHQW5MUy9HO09BQXdDLGtDQW1MakQrRztPQUtKLFdBeExhL0c7bUJBQUFBO09BQUFBOzs7S0FtTFQrRztLQUFBQTs7Ozs7O0dBUU87WUFHYnFvRSxjQUFlenNDLEtBQUtFLEtBQUszOEI7SUFwTXpCb25FLGtCQW9NZTNxQztJQXBNZjJxQyxrQkFvTW9CenFDO09BQUszOEI7U0FNbEI0YixRQU5rQjViO1FBTWxCNGI7TUFNRTtPQUFBLDRCQUFZLHdCQU5kQTtPQUlELE1BQUE7TUFERjs7U0FORnV0RCxRQVVBLDZCQVBLdnRELE9BTlE2Z0I7OztTQUdiMHNDLFFBSGExc0M7a0JBR2Iwc0M7O0tBY21DO01BQUEsTUFBQSw0QkFqQmpCeHNDLFFBR2xCd3NDO01BY29CLE1BcE50QmhkLFNBbU1vQnh2QjtLQXBEcEJrd0IsYUFvRG9CbHdCLEtBaUJIO0tBQ0Q7TUFBWnlzQyxZQUFZLDRCQWxCSXpzQyxRQUFBQTtNQW1CUCxPQUFBLDRCQWhCWHdzQztNQWVjOztVQUNoQnJ2RTs7T0FFYztlQXJCQzJpQztRQXFCRCxPQUFBLDRCQXJCQ0EsUUFtQmYzaUM7UUFFTXV2RSxRQUFRO1FBQ1osT0F0QmtCMXNDO1FBc0JOLE9BQUEsNEJBSlZ5c0MsV0FDSnR2RTtRQUdNd3ZFLFFBQVE7UUFJVixPQUFBLGtDQTFCVzdzQyxRQXFCVDRzQztPQUVKLGtDQXZCa0Ixc0MsUUFzQmQyc0M7T0FLSixrQ0EzQmE3c0MsUUFxQlQ0c0M7T0FGTixXQUFBdnZFO21CQUFBQTtPQUFBQTs7O0tBbkJvQjZpQyxTQTZCTiw0QkE3Qk1BLFFBR2xCd3NDO0tBMkJXLFdBOUJFMXNDLFFBOEJGLE9BQUEsNEJBOUJFQSxRQUdiMHNDO0tBSGExc0MsU0E4QkY7S0E5QkVBLFNBK0JELDRCQS9CQ0EsUUFHYjBzQzs7Ozs7O0dBNEI2QjtZQUcvQkksWUFBWTFvRSxHQUFFZ0Q7SUFHaEI7S0FBaUQsTUFBQSx5QkFIakNBO0tBR3FCLE1BQUEsNEJBSHZCaEQ7S0FHVSxNQXhPdEJzckQsU0FxT1l0ckQ7SUF0Rlpnc0QsYUFzRlloc0QsR0FHQztJQUNBLE9BQUEseUJBSkNnRCxZQUlJMVQsR0FBSyxPQTVFdkJ1NEUsUUF3RVk3bkUsR0FJTTFRLEdBQWdCO0dBQUM7WUFHbkN5USxLQUFLQyxHQUFHTixNQUFNTztJQUNoQixTQURPRCxNQUVGLE9BRktOO0lBS0E7S0FESmluRSxnQkFKQzNtRTtLQUtEeUgsUUFMSS9IO0tBTUssTUFBQSw0QkFOUk07S0FLRzs7U0FDUi9HOztNQUNZLFVBalBabXpDLFdBME9LcHNDLEdBTUwvRztNQURJd08sT0FFRyxXQVBPeEgsR0FLVndIO01Bbk5KaS9ELG1CQThNSzFtRSxHQUlEMm1FO01BSUYsVUFGRjF0RTtpQkFBQUE7TUFBQUE7OztXQURJd087R0FLRDtZQUdIaWlCLE1BQU0xcEIsR0FBR04sTUFBTU87SUFDVCxJQUFKaEg7SUFDWSxPQWZkOEc7YUFhTUM7YUFBR047c0JBRVU4WSxLQUFJcFY7Y0FDYixJQUFOOG1CLFFBQU0sV0FIS2pxQixHQUNiaEgsTUFDaUJ1ZixLQUFJcFY7Y0FEckJuSyxPQUdHLDRCQUhIQTtjQUlGLE9BRklpeEI7YUFFRDtHQUFDO1lBTUovcEIsS0FBS0gsR0FBR0M7SUFDVjtLQUFJMG1FLGdCQURHM21FO0tBRU0sTUFBQSw0QkFGTkE7OztTQUVQL0c7O01BQ0UsV0FIUWdILEdBbFFSbXNDLFdBa1FLcHNDLEdBRVAvRztNQXhPRXl0RSxtQkFzT0sxbUUsR0FDSDJtRTtNQUdGLFVBRkYxdEU7aUJBQUFBO01BQUFBOzs7O0dBR0k7WUFHRm1ILE1BQU1KLEdBQUdDO0lBQ1g7S0FBSTBtRSxnQkFESTNtRTtLQUVLLE1BQUEsNEJBRkxBOzs7U0FFUi9HOztNQUNFLFdBSFNnSCxHQUVYaEgsR0E1UUVtekMsV0EwUU1wc0MsR0FFUi9HO01BaFBFeXRFLG1CQThPTTFtRSxHQUNKMm1FO01BR0YsVUFGRjF0RTtpQkFBQUE7TUFBQUE7Ozs7R0FHSTtZQUdGNkcsUUFBUUU7SUFDVixJQUFJNmQsaUJBQ0ksTUFBQSw0QkFGRTdkOztTQUVWL0c7O2dCQURJNGtCO01BQUFBLGdCQW5SRnV1QixXQWtSUXBzQyxHQUVWL0c7TUFBUSxVQUFSQTtlQUFBQTtNQUFBQTs7O1dBREk0a0I7R0FJRztHQU9NO0lBQVAzRSx5QkE1QkovWTtJQTZCSWlaLDJCQXJRSnRYO0lBc1FJNjhCLDBCQXpDSmpWO0lBMENJK1UsMEJBdkJKcitCOzs7O1lBaENBTCxNQW9ESW1aLFFBQ0FFLFVBRUFxbEIsU0FEQUU7SUFJSnZtQjtJQUNBbFc7SUFDQThXO0lBQ0FEO0lBQ0FSO0lBQ0FHO0lBQ0FuVztJQUNBdVc7SUFDQXVCO0lBQ0F6QjtJQUNBUDtJQUNBa1Y7SUFDQS9JO0lBQ0FKO0lBQ0FIO0lBQ0FNOzs7O1lBS0FxRyxXQUFXNXFCLEdBQUdDO0lBQ0QsSUFBWDBvRSxXQTNNRnpwRTtJQW9KQWlCO01Bc0RXSDtlQUVFb0Q7T0FBZSxVQUFBLFdBRmRuRCxHQUVEbUQ7T0FBd0IsT0FBQTs0Q0FBS0MsR0FBSyxPQS9KL0N3a0UsUUE4SkVjLFVBQ3dDdGxFLEdBQXVCO01BQUM7SUFBcEUsT0FESXNsRTtHQUVJO1lBR045OUMsWUFBWTdxQixHQUFHQztJQUNGLElBQVgwb0UsV0FqTkZ6cEU7SUE0SkFrQjtNQW9EWUo7ZUFFRS9HLEdBQUVtSztPQUFlLFVBQUEsV0FGaEJuRCxHQUVEaEgsR0FBRW1LO09BQTBCLE9BQUE7NENBQUtDLEdBQUssT0FyS3BEd2tFLFFBb0tFYyxVQUM2Q3RsRSxHQUF1QjtNQUFDO0lBQXpFLE9BRElzbEU7R0FFSTtZQUdOajdDLFdBQVcxdEIsR0FBR0M7SUFDRCxJQUFYMG9FLFdBdk5GenBFO0lBb0pBaUI7TUFrRVdIO2VBRUVvRDtPQUNQLFlBQUEsV0FIUW5ELEdBRURtRDttQkFFSDtXQUNIQztPQUFLLE9BOUtad2tFLFFBMEtFYyxVQUlLdGxFO01BQXVCO0lBSGhDLE9BRElzbEU7R0FLSTtZQUdOOTZDLFlBQVk3dEIsR0FBR0M7SUFDRixJQUFYMG9FLFdBaE9GenBFO0lBNEpBa0I7TUFtRVlKO2VBRUUvRyxHQUFFbUs7T0FDVixZQUFBLFdBSFNuRCxHQUVEaEgsR0FBRW1LO21CQUVOO1dBQ0hDO09BQUssT0F2TFp3a0UsUUFtTEVjLFVBSUt0bEU7TUFBdUI7SUFIaEMsT0FESXNsRTtHQUtJO1lBR04va0QsT0FBTzVqQixHQUFHQztJQUNHLElBQVgwb0UsV0F6T0Z6cEU7SUFvSkFpQjtNQW9GT0g7ZUFFTW9EO09BQVEsVUFBQSxXQUZYbkQsR0FFR21EO09BQVEsYUE3THJCeWtFLFFBNExFYyxVQUNXdmxFO01BQW1DO0lBQWxELE9BREl1bEU7R0FFSTtZQUdOaC9DLFFBQVEzcEIsR0FBR0M7SUFDRSxJQUFYMG9FLFdBL09GenBFO0lBNEpBa0I7TUFrRlFKO2VBRU0vRyxHQUFFbUs7T0FBUSxVQUFBLFdBRmJuRCxHQUVHaEgsR0FBRW1LO09BQVEsYUFuTXhCeWtFLFFBa01FYyxVQUNjdmxFO01BQXFDO0lBQXZELE9BREl1bEU7R0FFSTtZQUdOQyxlQUFlNW9FLEdBQUdDO0lBQ1gsSUFBTG9CLEtBYkZ1aUIsT0FZZTVqQixHQUFHQztJQTVLbEJpckQsTUE0S2VsckQ7SUFFakIsT0FuS0Vxb0UsY0FrS0VobkUsSUFEYXJCO0dBR2M7WUFHN0I2b0UsZ0JBQWdCN29FLEdBQUdDO0lBQ1osSUFBTG9CLEtBYkZzb0IsUUFZZ0IzcEIsR0FBR0M7SUFsTG5CaXJELE1Ba0xnQmxyRDtJQUVsQixPQXpLRXFvRSxjQXdLRWhuRSxJQURjckI7R0FHYTtZQUc3QlIsS0FBS284QjtJQUNHLElBQU5FLE1BalFGNThCLFdBZ1FLMDhCO0lBek9MNnJDLGNBeU9LN3JDLEtBQ0hFO0lBQUFBLFNBREdGO0lBSVAsT0FISUU7R0FHRDtZQUdEbDhCLFFBQVFvRDtJQUdGLElBQUpoRCxJQTFRRmQsV0EwUXVCLHlCQUhmOEQ7SUFJVix5QkFKVUEsWUFJVTFULEdBQUssT0E5TnZCdTRFLFFBNk5FN25FLEdBQ2dCMVEsR0FBZ0I7SUFBcEMsT0FESTBRO0dBRUg7WUFRQ04sS0FBS1AsS0FBS2M7SUFDWixHQURPZDtLQUl5QztNQUFBLDRCQUFZLHdCQUpyREE7TUFJSCxNQUFBO0tBREY7O0lBRU0sSUFBSmEsSUF6UkZkLFdBb1JLQztPQUFBQSxNQU1DLGlDQURKYTtLQUNKLE1BQUE7SUFDYSxJQUFBLE1BQUEsNEJBUE5iLFNBT1A7O1NBQUFsRzs7TUFDd0MsVUFBQSxXQVI1QmdILEdBT1poSDtNQUNFLGtDQUhFK0csTUFFSi9HO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7SUFGSStHLE9BTEdiO0lBV1AsT0FOSWE7R0FNSDtZQUdDa3RDLFNBQVM5cEM7SUFBSSxPQWRiMUQsS0FjUzBELDRCLE9BQUFBO0dBQWlEO1lBQzFENlYsU0FBU2paO0lBQUksT0FBdUI7NkJBQTNCQSxlQUFnQy9HLEdBQUssT0FqWjlDbXpDLFdBaVpTcHNDLEdBQWdDL0csR0FBbUI7R0FBQztZQUU3RG9ILElBQUkwTyxJQUFJOU87SUFDVixJQUFJMG1FLGdCQURFNTNELE9BRUZDLEtBdlNGOVAsV0FxU0k2UDtJQUVGQyxRQUZFRDtJQUlPLElBQUEsTUFBQSw0QkFKUEEsV0FJTjs7U0FBQTlWOztNQUNVLElBQUpvSyxJQUFJLFdBTEFwRCxHQW5aUm1zQyxXQW1aSXI5QixJQUlOOVY7TUEzWEV5dEUsbUJBdVhJMzNELElBQ0Y0M0Q7TUFNRixrQ0FMRTMzRCxPQUVKL1YsR0FDTW9LO01BRE4sVUFBQXBLO2lCQUFBQTtNQUFBQTs7O0lBS0EsT0FQSStWO0dBT0Y7WUFHQTFPLEtBQUtOLEdBQUdDO0lBQ0YsSUFBSmhIO0lBQ0ssT0FkUG9IO2FBWUtMO3NCQUVPb0Q7Y0FDQyxJQUFUeWEsU0FBUyxXQUhMNWQsR0FDTmhILE1BQ1VtSztjQURWbkssT0FHRyw0QkFISEE7Y0FJRixPQUZJNGtCO2FBRUU7R0FBQztZQUdQOG5CLFVBQVVyMkMsR0FDSixJQUFKMFEsSUExVEZkLGNBNkNBMm9FLFFBNlFFN25FLEdBRFExUSxJQUVaLE9BREkwUSxFQUVIO1lBR0M4SixVQUFVMFEsV0FBVXhhO0lBQUksVUEzSnhCRixRQTJKb0JFO0lBQUksT0FBQSxXQUFhLHlCQUEzQndhO0dBQW1EO1lBQzdEOUosVUFBVXlzQixXQUFVbnlCO0lBQU8sT0F6RDNCcEwsUUF5RDJCLHlCQUFqQnU5QixXQUFVbnlCO0dBQStDO1lBRW5FcEIsZUFBeUJ1akM7SUFHRSxVQUFBLHlCQUhGQTtJQUdFLE9BQUE7R0FBNkI7Ozs7T0E5WXhEOTJDO09BeVlBcWE7T0FEQTVHO09BR0FGO09BcElBeVE7T0FsUkF2WTtPQURBaVM7T0F5T0E1VDtPQXhCQUo7T0E4REF3WTtPQUNBRztPQUpBeFc7T0FLQUs7T0FOQTZWO09BVUFDO09BUkFXO09BQ0FEO09BckJBalo7T0ErSEFtWjtPQXBHQUw7T0FGQUU7T0FwREE0UTtPQW1CQXRwQjtPQXNDQW9rQjtPQUdBRDtPQUpBZ0o7T0FHQXRKO09BREFHO09Bc0hBdWhCO09BbERBL2xDO09BMkJBc3RDO09BZEF4dEM7T0F2T0Ftb0U7T0F3RUFhO09BckRBVjtPQURBRDtPQUlBSTtPQUNBQztPQUlBbGQ7T0F3TEExckQ7T0FxQ0FhO09BWUFDO09BdkdBc3FCO09BTUFDO09BTUE2QztPQVNBRztPQVNBaks7T0FNQStGO09BTUFpL0M7T0FNQUM7T0F0U0F2eUU7T0F5QkF1VDtPQW1CQTNLO09BcUVBbXNCO09BQ0FEO09BYUFpOUM7T0FuTEF0MkQ7T0FLQW8xQjtPQXJCQW1rQjtPQStJQVU7OztFOzs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDeExHcGlEO0lBVUNTOzs7Ozs7WUFURnkrRDtJQVhtQixNQUFBO0dBQ1A7Ozs7WUFJWnBqRSxtQkFBYzFGLEdBQUksT0FNbEI4b0UsaUJBTmM5b0UsR0FBc0I7WUFFcEMzSixRQUFRK00sVUFBTSxPQUlkMGxFLGlCQUpRMWxFLEdBQXdCO1lBRWhDc04sVUFBVTFGO0lBQU8sT0FBQSw2REFBUEE7R0FBZ0U7WUFHMUV6SjtJQUF5QixPQUFBO0dBQWdEOzs7Ozs7U0FMekVsTDtTQUZBcVA7U0FNQW9qRTtTQUZBcDREO1NBRUFvNEQ7U0FDQXZuRTtTQURBdW5FO1NBU0V6K0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FWRFQ7T0FDRGsvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUM2Q0V6K0Q7SUFPQTA3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTdERHJnRDtJQUlDbUg7R0FDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7R0FTYTtJQU4xQm9oQjtJQUNBNUc7SUFDQ0Y7SUFJRDh3QixlQVhDcnhCLGVBTURTO0lBTUF6UztJQTBQSWlLO0lBREFDO29EQXpQSmxLLFdBTkF5UztJQWlCRXM4Qzs4Q0FYRi91RCxXQU5BeVMsV0FpQkVzOEM7Ozs7Ozt5REErT0U5a0Q7OztJQXBPRnJKO0lBRUN1YjtJQUlDNnlDO0dBQ0osU0FGRzV5QyxPQUVDbmtCLEdBQUssT0FBQSxXQURMKzJELFFBQ0EvMkQsR0FBVztPQUtieTVFO1lBQ0F6aUIsUzs7SUFDQXYyRDs7O1lBQ0EwekQsWUFBVXhxRCxHQUFJLE9BQUEsZ0NBQUpBLEdBQTBCO1lBQ3BDK3NELFlBQVV0b0Q7SUFBSSxPQUEwQiw0QkFBOUJBLHNCQUFJO0dBQStCOzs7Ozs7U0FoQjdDekY7U0FFQ3ViO1NBR0FDO1NBVURnd0M7U0FDQXVDO1NBSkEraUI7U0FFQWg1RTtTQURBdTJEO1NBSUFqOEM7Ozs2Q0FPQTA3QyxlQTRNRXprRDs7WUFwTU51SSxpQkFBb0IsU0FBRTtHQUNYO0lBQVhFLFdBQVc7SUFDWGs4QyxvQkFBb0IsNEJBRHBCbDhDO0lBRUFtOEMsb0JBQW9CLDRCQUZwQm44QztZQTRNRXE5Qyw4QjtZQURBbGlCLHNCO1lBREFtaUIscUI7R0FyTVcsSUFvTVhDO1lBREFHLGtCO1lBREFGLGlCO1lBREFDLGtCO0dBN0xRO0lBQ1Y3bEQ7SUFDQUQ7SUFzS0V3bEQ7SUFwS0Zyc0I7SUFDQWo1QjtJQUNBdWxEO1lBbUtFaDRDLGM7R0FsS0k7SUFDTjY1RDtJQUNBamtCO0lBaUtFa2tCOzs7Ozs7O1lBL0pGem5FLGM7WUFDQTJrRCx3QjtZQUVBMWtELFNBQVN4QjtJQUNYO01BQUcsZ0NBRFFBLEdBdEJUZ21EO1NBd0JDLGdDQUZRaG1ELEdBckJUaW1EO0tBd0JHLE9BSE1qbUQ7SUFPUCxVQUFBLDRCQVBPQTtJQUtULE9BQUE7R0FHSTs7SUFPRnMzQjs7Ozs7Ozs7Ozs7O1lBRUFvd0I7SUFDRixPQUFBO0dBQTJEO1lBUXpEQyxVQUFXdDREO0lBQ2IsR0FBRyxnQ0FEVUEsT0FUWHE0RDtJQVdNO0tBQUp0eEMsTUFBSSxnQ0FGSy9tQjtLQUdUMDRELE1BREEzeEMsTUFBQUE7S0FFQTB4QyxNQURBQyxNQUFBQTtLQUVBRixNQURBQyxNQUFBQTtLQUVBRixNQURBQyxNQUFBQTtLQUVBbEMsTUFEQWlDLE1BQUFBO0tBSUE5bkMsTUFIQTZsQyxNQUFBQTtJQUlKLE9BQUEsZ0NBREk3bEM7R0FDaUI7WUFJbkJrb0MsV0FBVzV4QztJQUNiLEdBQUcsZ0NBRFVBLFNBeEJYc3hDOztLQTBCRXI0RCxJQUZTK21CLE1BQUFBO0tBR1QweEMsTUFEQXo0RCxJQUFBQTtLQUVBdzRELE1BREFDLE1BQUFBO0tBRUFGLE1BREFDLE1BQUFBO0tBRUFsQyxNQURBaUMsTUFBQUE7S0FFQTluQyxNQURBNmxDLE1BQUFBO0lBRUosT0FESTdsQyxPQUFBQTtHQUMwQjtZQUc1Qm1vQyxRQUFRNTREO0lBQ1YsR0FBRyxnQ0FET0EsT0FuQ1JxNEQ7Y0FtQ1FyNEQsSUFFSCxnQ0FGR0E7SUFDTSxPQUFBO0dBQ2lCO1lBaUIvQjY0RCxXQUFXbHZEO0lBQ2IsR0FBRyxlQURVQTtLQU1OLHVCQUFNLDZCQU5BQTtLQUdYO09BM0RBcytCLFNBNERFOztJQUdXO0tBQUEsTUFBQSxvQ0FQRnQrQjtLQU9iLE1BQUEsNEJBckdBOFE7SUFxR2UsT0FBQTtHQUFLO1lBSWxCcStDLFVBQVVudkQ7SUFDWixHQUFHLGVBRFNBO0tBTUwseUJBQU0sNkJBTkRBO0tBR1Y7T0F0RUFzK0IsU0F1RUU7O0lBR0QsR0FBQSxpQ0FQU3QrQix5QkFRUDtJQUNXOztPQUFBLG9DQUFJLGdDQVRSQTtJQVNJLE9BQUEsNEJBbEhoQjhRO0dBa0gyQztZQU0zQ2t2QixRQUFRajVCLEdBQUdrNUIsS0FBS0M7SUFBTyxVQUFBLGdDQUFaRCxLQUFIbDVCO0lBQWUsNkNBQWZBLEdBQVFtNUI7R0FBNEI7WUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7SUFBTSxPQUFHLGdDQUFqQndRLEdBQUd2UTtjQUFBQTtjQUF1QyxnQ0FBMUN1USxHQUFReFEsT0FBUndRLElBQVF4UTtHQUEwRDtZQUVsRjZwQyxVQUFVcjVCLEdBQUd2USxLQUFLRDtJQUNwQixHQUFPLGdDQURRQyxLQUFLRDtLQUVwQixPQUpFNHBDLGdCQUVVcDVCLEdBQUd2USxLQUFLRDtJQUNwQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBQ2hCLEtBQUcsZ0NBRFFDLEtBQUtEO0tBT1gsV0FkSDRwQyxnQkFPTXA1QixHQUFHdlEsS0FBS0Q7SUFNVDs0QkFBaUMsV0FuTXBDc2EsV0E2TFl0YTtLQU1ULHVCQUFTLFdBbk1ac2EsV0E2TE9yYTtLQUlQLE1BQUE7SUFBQSxPQUFBO0dBR2lDO09Bb0NqQzRmLDZCQURBemE7WUFEQUMsbUI7WUFEQUMsbUI7WUF6QkZ1SSxLQUFLb0ssR0FBQUEsT0FBQUEsT0E3SExzOUMsa0JBNkhzQjtZQUN0QjNuRCxLQUFLcUssR0FBQUEsT0FBQUEsT0E5SExzOUMsa0JBOEhzQjtZQUN0QmdDLGFBQWEvbUQsR0FBSSxPQUFKQSxFQUFLO1lBRWxCaW5ELGFBQWFqbkQsR0FBSSxPQUFKQSxFQUFLOztJQUVsQnFvRDtJQStCRWxuRDtJQTVCRkw7SUFDQW1zRDtJQUNBaWM7SUFDQTFpQjtJQUVBRTtJQUNBQztJQUNBd2lCO0lBQ0F2aUI7SUFDQUM7SUFDQXVpQjtJQUNBdGlCO1lBQ0FZLElBQUlya0QsR0FBRXdCO0lBQUksSUFBb0QsTUFBQSxXQVg5RG9vRCxZQVdNcG9ELElBQXlDLE1BQUEsV0FYL0Nvb0QsWUFXSTVwRDtJQUFpQixPQUFBLFdBZ0JuQmxDLFlBaEJtQjtHQUF3RDtZQVMzRXBNLFNBUktzTyxHQUFFd0IsR0FBSSxPQURiNmlELElBQ09ya0QsR0FBRXdCLEdBQVc7OztJQVUyQjdQO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOzs7OztTQXhKL0NvTTtTQUhBRDtTQThLTUQ7U0FDQUQ7U0EzQkp4TTtTQUNBRDtTQUNBRDtTQUNBeWE7U0FPQUY7U0FINkM5WjtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUU3Q2t5RDtTQUNBLzNDO1NBQ0E4NUQ7U0FDQTluRTtTQXJLRmdtRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BM0VHdjlDO09BbUZIbkk7T0FIQUQ7T0FnS0VMO09BM0JGOHJEO09BL05Hdm5EO09BR0EyRDtPQUtEcUg7O09BZ1FJblA7T0FDQUQ7Ozs7Ozs7Ozs7Ozs7T0EzRU4yM0I7T0FHQUk7T0FLQUM7OztPQXhMRW9COzs7Ozs7T0F1REY3d0I7OztPQW9MRW8vRDtPQWpLRmxrQjtPQURBaWtCO09BdUpFbDBFO09BQ0FEO09BQ0FEO09BR0FHO09BS0FvYTtPQUFBQTs7O09BUEFFO09BNUpGODNDOztPQXVMRUs7T0FDQUQ7T0FDQUU7T0FDQUg7T0FDQUQ7T0FDQW5pQjs7Ozs7O09BMUJBZ2lCO09BbktGdGxEO09BREFpNUI7T0F1SkE2c0I7T0FrQ0VGO09BQ0FEO09BQ0FFO09BQ0FIO09BcERGZTtPQXFERWhCO09BQ0FuaUI7T0EzREY5bkM7T0FEQUM7T0FZQW1wRDtPQUdBRztPQUdBRTtPQUVBQztPQWxCQUM7T0FFQUU7T0E5SEFkO09BckJBcDhDO09BV0FySTtPQURBQztPQWtNRXlsRDtPQUFBQTtPQTNKQVE7T0FlQUs7T0F5Q0FHO09BWEFEO09BbkJBRDtxQjtxQjs7UUE2RkFwekQ7UUFDQUQ7UUFDQUQ7UUFDQXlhO1FBT0FGO1FBTEFwYTtRQUU2Q007UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFFN0NreUQ7UUFDQS8zQztRQUNBODVEOzs7O1FBbUJBemhCO1FBQ0FEO1FBQ0FFO1FBQ0FIO1FBQ0FEO1FBQ0FuaUI7UUFDQWtpQjtPQXhCQWptRDtPQTVCRkw7T0FHQTBsRDtPQUVBRTtPQVpBSztPQUVBRTtPQWFBTDtPQU5Bc2lCO09BS0FDO09BR0FDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQzZpRUlsb0M7SUFuaUNFcHZCO0lBMEJBdTNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTd2Q0pDLDBCO1lBQ0FDLDBCO0dBTjBCO0lBQUE7Ozs7OztPQUsxQkQ7T0FDQUM7Ozs7O1lBTUFqaUM7SUFBTzs7U0FFREE7OEJBRE0sY0FDTkE7SUFBMEIsV0FBMUJBO0dBQW1DO1lBR3pDQztJQUFROztTQUVEQTsrQkFESSxjQUNKQTtJQUE0QixXQUE1QkE7R0FBc0M7WUFHN0NpaUMsV0FBV3hwRSxHQUFHcWI7SUFDaEIsV0FEYXJiOztTQUdMc25DLE9BSEt0bkM7OEJBRUMsT0FGRXFiLGVBR1Jpc0IsT0FIS3RuQztJQUdxQixPQUExQnNuQztHQUE4QjtZQUdwQ21pQyxZQUFZenBFLEdBQUdxYjtJQUNqQixXQURjcmI7O1NBR0x1bkMsUUFIS3ZuQzsrQkFFRCxPQUZJcWIsZUFHUmtzQixRQUhLdm5DO0lBR3VCLE9BQTVCdW5DO0dBQWlDO1lBR3hDbWlDLE9BQU8xcEUsR0FBRzJwRSxjQUFjQztJQUMxQixXQURTNXBFOztpQkFBQUEsTUFJTXVuQyxrQkFBTkQ7S0FBZ0IsV0FBaEJBLE1BQU1DOzs7U0FGUHNCLFNBRkM3b0M7S0FFTyxXQUFSNm9DLFFBRmtCK2dDOztRQUdqQkMsVUFIQTdwRTtJQUdTLFdBSE4ycEUsY0FHSEU7R0FDMkI7R0E3QmpCO0lBQUE7Ozs7O09BR2pCdmlDO09BS0FDO09BS0FpaUM7T0FNQUM7T0FNQUM7SUFRRno4RDtJQUVKOzs7R0FHRTs7Ozs7O01BQXdFLHdCQUN2RDtNQUNSLE1BQUE7S0FBYTs7Ozs7Ozs7Ozs7O1lBYWxCeW9EO0lBQVMsOEJBQ0E7dUJBQ0M7UUFDUXpzQztJQUFNLE9BQU5BO0dBQU87WUFJdkIwc0MsU0FBUy9HLE9BQU1DLE9BQU1pYixhQUFZdDZDO0lBQ25DLEdBRFdvL0I7O01BR0hFLFVBSEdGO2FBR00sV0FITWtiLGFBR2ZoYixTQUgyQnQvQjs7OztRQUFsQnEvQjtVQU9WRSxVQVBVRjthQU9ELFdBUE9pYixhQUFZdDZDLEdBTzVCdS9COzs7Ozs7SUFERztHQUM2QjtZQUVqQzNnRCxLQUFLd2dELE9BQU1DLE9BQU1pYixhQUFZOXBFO0lBQ25DLElBRFc4dUQsVUFBQUYsT0FBd0Ixb0QsTUFBQWxHO0lBQ25DO2VBRG1Da0csa0JBRXhCO2NBRndCQTtVQUczQnNwQixJQUgyQnRwQjtNQUdsQixPQVpmeXZELFNBU1M3RyxTQUFNRCxPQUFNaWIsYUFHZnQ2Qzs7S0FFRztNQURTdkcsSUFKZS9pQjtNQUFBdUIsSUFBQXZCO01BSXhCcTFDLE1BSndCcjFDO01BSTNCbEQsSUFKMkJrRDtNQUs3QjB2RCxLQXJCTkYsT0FvQlExeUQ7TUFFRjZ5RCxLQXRCTkgsT0FnQm1DanVEO01BTzdCLE9BQUEsNEJBRkFtdUQsSUFDQUM7YUFDSjs7TUFDTztPQUFBLE9BQUEsNEJBSEhELElBQ0FDO2NBRmM1c0MsTUFJWDs7T0FDSixXQWxCSDBzQyxTQVNTN0csU0FBTUQsT0FBTWliLGFBSVp2dUI7T0FLTjtRQUNBLFdBVkNudEMsS0FBSzBnRCxhQUlBdlQsTUFKWXV1QixhQUlmOW1FO1FBTUg7U0FDSyxJQVhDOHlELGNBSUF2YTtTQUpBdVQsVUFBQWdIO1NBQXdCNXZELE1BQUF1Qjs7Ozs7Ozs7Ozs7OztLQVU5Qjs7R0FDaUM7WUFyQnRDc3VELFdBdUJFLzFELEdBQUc4cEUsYUFBZSxPQWJkMTdELFdBYUQwN0QsYUFBSDlwRSxHQUE4QztZQUloRGQsT0FBTzhELEdBQUUxVCxHQUFFdzhDLEdBQUVya0M7SUFDZixJQUFJbXVELEtBbENGRixPQWlDTzF5RCxJQUVMNnlELEtBbkNGSCxPQWlDYWp1RDthQUNYbXVELFlBQ0FDLElBRUMsV0FKTXZtRSxHQUFFdzhDOzs7T0FFVCtwQixNQURBRDtVQUlvQyw0QkFKcENBO1VBSWdELDRCQUhoREM7SUFHQyxXQUxJN3lELEdBQUUxVCxHQUFFdzhDLEdBQUVya0M7R0FLNEM7WUFPekQydUQsK0JBQWtDajNELEtBQUtjO2FBQ2pDbU8sS0FBS29FLEdBQUd2UyxHQUFFaEg7S0FDaEIsUUFEV3VaO2FBQUFBOztTQUVKOztTQUVNLElBQUEsVUFBQSxXQUpDdlMsR0FBRWhILElBSVB5bkMsa0JBQUg2YTtTQUNKLFdBRElBLEtBQUc3YTs7U0FHTTtVQUFBLFVBQUEsV0FQRHpnQyxHQUFFaEg7VUFPTjh3RTtVQUFKMVQ7VUFDTyxVQUFBLFdBUkNwMkQsR0FRQyw0QkFSQ2hIO1VBUVB3aEU7VUFBSG5FO1NBQ0osZUFGSUQsSUFBSTBULEtBQ0p6VCxLQUFHbUU7O1NBR007VUFBQSxVQUFBLFdBWER4NkQsR0FBRWhIO1VBV04rd0U7VUFBSnpUO1VBQ08sVUFBQSxXQVpDdDJELEdBWUMsNEJBWkNoSDtVQVlQMGhFO1VBQUhuRTtVQUNTLFVBQUEsV0FiRHYyRCxHQWFHLDRCQWJEaEg7VUFhTmd4RTtVQUFKeFQ7U0FDSixlQUhJRixNQUFJeVQsT0FDSnhULEtBQUdtRSxTQUNIbEUsSUFBSXdUOztLQUdVO01BQWR2VCxjQUFjLDZCQWhCVGxrRDtNQWlCVSxPQUFBLDRCQWpCVkEsR0FnQkxra0Q7TUFDQUMsZUFBZTtNQUNmcnZCLE9BbEJBbDVCLEtBZ0JBc29ELGFBaEJRejJELEdBQUVoSDtNQW1CSCxRQUFBLFdBbkJDZ0gsR0FtQkMsNEJBbkJDaEgsR0FnQlZ5OUQ7TUFHR25vRDtNQUFIaWhCO01BQzhCLE9BQUEsNEJBcEJwQnYyQixHQWdCVnk5RDtNQUlBbnZCLFFBcEJBbjVCLEtBaUJBdW9ELGNBakJRMTJELEdBb0JxQjtLQUNqQyxPQWxDRmYsT0ErQk1vb0MsTUFDQTlYLEdBQUdqaEIsR0FDSGc1QjtJQUNpQjtJQUV6QixPQXZCUW41QixLQUQ0QmpQLEtBQUtjO0dBd0I1QjtZQUdYMjJELDBCQUEwQmh5RCxPQUFPa2xFO0lBQ25DLElBQUlqVCxlQUR3Qmp5RDs7O0tBRTVCLFFBRElpeUQ7O09BSUtxVCxzQkFMbUJ0bEU7T0FNbkJ1bEUsc0JBTm1CdmxFO1NBT3ZCLFdBUDhCa2xFLGFBSzFCSSxJQUNBQzs7UUFKTDdxQzttQkFPT3JtQztXQUFLO1lBQU8sT0FBQSw0QkFSbkI0OUQ7WUFRbUIsT0FBQSxrQ0FBWjU5RDtXQUFLLHdCQVRZMkw7VUFTZ0I7Ozs7U0FQeEMwNkIsZ0JBTU9ybUMsR0FBSyx3QkFSWTJMLE9BUWpCM0wsT0FBQUEsR0FBYzs7SUFHekI7WUF0Q0VtOUQsK0JBNEJFUyxjQUNBdjNCO1lBREF1M0I7R0FVb0U7WUFHdEVDLGdCQUFnQmx5RCxPQUFPa2xFO0lBQ3pCLFVBRGtCbGxFOztLQUlKLE9BQUE7Y0E5R2RxSTt1QkE4R21CeEY7ZUFDZjtnQkFDeUMsd0JBTjNCN0M7Z0JBTXNCLE9BQUE7Z0JBQVgsd0JBTlhBO2dCQVFWM0w7a0JBRkk7b0JBTmE2d0UsYUFNRDtnQkFEaEIvUzt3QkFHQTk5RDtxQkFESztzQkFITXdPO3NCQUdHOztxQkFDZHhPO2dCQUVTLE9BQUEsNEJBVkMyTDs7O29CQVVkRTs7aUJBQ2dEO2tCQUFBLE9BQUEsNEJBRGhEQTtrQkFDeUMsd0JBWDNCRjtrQkFXc0IsT0FBQTtrQkFBWCx3QkFYWEEsT0FVZEUsU0FBQUE7a0JBR0k4b0I7b0JBRkk7c0JBWGFrOEMsYUFXRDswQkFFaEJsOEM7a0JBREs7b0JBUk1ubUI7b0JBUUc7OzBCQUNkbW1CLHFCQVJBbXBDO2tCQVdFO29CQVpTdHZEO29CQWFQOztpQkFQUixXQUFBM0M7NkJBQUFBO2lCQUFBQTs7O2VBU0EsV0FqQ0Y4eEQsMEJBY2dCaHlELE9BQU9rbEU7Y0FtQm1DO0lBakJ4QyxXQWhCbEJsVCwwQkFjZ0JoeUQsT0FBT2tsRTtHQW1Cb0M7WUFJM0Q5UyxJQUFJaDBELEdBQUUxVCxHQUFFdzhDLEdBQUVya0M7SUFDWixJQUFJbXVELEtBOUdGRixPQTZHSTF5RCxJQUVGNnlELEtBL0dGSCxPQTZHVWp1RDtPQUdKLDRCQURKb3VELFNBREFEO2VBREU1eUQ7TUFNTyxPQUFBO2NBTlBBO01BT1EsTUFBQTtLQUVNLElBREVpMEQsS0FSaEJqMEQsTUFRWW9uRSxLQVJacG5FLE1BUVFrMEQsS0FSUmwwRCxNQVFJbTBELEtBUkpuMEQsTUFTYyxPQXRIbEIweUQsT0FxSG9CdUI7Z0JBckhwQnZCLE9BcUhReUIsS0FFZSxPQXRGdkJqNEQsT0FvRlFpNEQsSUFBSUQsSUFBSWtULElBcEZoQmxyRSxPQW9Gb0IrM0QsSUFSZDNuRSxHQUFFdzhDLEdBQUVya0M7ZUFRVXd2RDtNQUtMLE9BQUE7Y0FMS0E7TUFNNEMsSUFBL0NvVCxNQU5HcFQsT0FNUk0sTUFOUU4sT0FNNEMsT0ExRmhFLzNELFVBNEVNNVAsR0FBRXc4QyxHQUFFcmtDO01BY3NELE9BMUZoRXZJLE9BQUFBLE9Bb0ZRaTRELElBQUlELElBQUlrVCxRQU1KN1MsS0FBSzhTOztLQUUwQjtNQURoQmpULE1BUFBIO01BT0VxVCxRQVBGclQ7TUFPSEksUUFQR0o7TUFPUkssTUFQUUw7TUFRdUIsT0E1RjNDLzNELE9BMkYyQms0RCxLQWZyQjluRSxHQUFFdzhDLEdBQUVya0M7S0FnQmlDLE9BNUYzQ3ZJLE9BQUFBLE9Bb0ZRaTRELElBQUlELElBQUlrVCxJQU9KOVMsTUFBS0QsT0FBS2lUOztPQUVYLDRCQWhCVDFVLFVBQ0FDLElBNkJDLE9BM0dIMzJELE9BNEVJOEQsR0FBRTFULEdBQUV3OEMsR0FBRXJrQztjQUFBQTtLQW9CQyxPQUFBO2FBcEJEQTtLQXFCRSxNQUFBO0lBRU0sSUFERSt2RCxLQXRCVi92RCxNQXNCTThpRSxLQXRCTjlpRSxNQXNCRWd3RCxLQXRCRmh3RCxNQXNCRml3RCxLQXRCRWp3RCxNQXVCUSxPQXBJbEJpdUQsT0FtSVFnQztlQW5JUmhDLE9BbUlvQjhCLEtBRWIsT0FwR1B0NEQsT0FBQUEsT0E0RUk4RCxHQUFFMVQsR0FBRXc4QyxHQXNCQTRyQixLQUFJRCxJQUFJOFMsSUFBSS9TO2NBQVpFO0tBS08sT0FBQTthQUxQQTtLQU1xRCxJQUE1QzhTLE1BTlQ5UyxPQU1JSSxNQU5KSixPQU1xRCxPQXhHN0R4NEQsVUFrR1l1NEQsSUFBSThTLElBQUkvUztLQU15QyxPQXhHN0R0NEQsT0FBQUEsT0E0RUk4RCxHQUFFMVQsR0FBRXc4QyxPQTRCSWdzQixLQUFLMFM7O0lBRXVCO0tBRGI3UyxNQVBuQkQ7S0FPYytTLFFBUGQvUztLQU9TRSxRQVBURjtLQU9JRyxNQVBKSDtLQVFnQyxPQTFHeEN4NEQsT0F5RzJCeTRELEtBUGZGLElBQUk4UyxJQUFJL1M7SUFRb0IsT0ExR3hDdDRELE9BQUFBLE9BNEVJOEQsR0FBRTFULEdBQUV3OEMsR0E2QkkrckIsTUFBS0QsT0FBSzZTO0dBRUw7O0lBd3VEakI5Ujs7Ozs7Ozs7OztZQW51REE1a0QsZ0JBQVcseUNBRUQ7WUFHVjIyRCwwQkFBMkI5NkMsS0FBSys2QztJQUNsQztLQUN3RCx3QkFBUyxXQUYvQkEsYUFBTC82QztLQUUzQixPQUFBO0lBQUEsT0FBQTtHQUFvRjtZQVdoRmc3QztJQUNFNXFFLEdBQ0M4QixRQUNJeFMsR0FDSnU3RSxNQUNBZixhQUNBYSxhQUNDRztJQUVWLFVBUlE5cUU7S0FTRyxlQVBFMVEsR0FDSnU3RSxPQU1rQiw0QkFSbEIvb0U7YUFERDlCO0tBV0UsSUFEQzhyQyxJQVZIOXJDLE1BVUF1TyxJQVZBdk8sTUFXRndQLElBQUksV0FQRHM2RCxhQUZJeDZFLEdBUUxpZjtLQUVOLFNBRElpQjthQUxJczdEOztTQTVMZCxPQUFBOztTQXNNcUIsT0E5QmZKLDBCQWdCV3A3RSxHQUdKcTdFO2lCQVlJLGVBZkFyN0UsR0FDSnU3RSxPQUZBL29FOztpQkFVSDBOOztzQkFERWpCLEdBQUd1OUIsT0FSRXg4QyxHQUNKdTdFO2VBaUJxQyw0QkFuQnJDL29FOzt1QkFDSXhTLEdBQ0p1N0UsT0FPRHQ4RCxHQUFHdTlCO2VBU21DLDRCQWxCckNocUM7O0lBcUJDO0tBRFVtbkIsSUFyQlpqcEI7S0FxQlN5SCxJQXJCVHpIO0tBcUJNK3FFLE1BckJOL3FFO0tBcUJHMGdDLE1BckJIMWdDO0tBcUJBZ0QsSUFyQkFoRDtLQXNCRndpQixNQUFJLFdBbEJEc25ELGFBRkl4NkUsR0FtQkZveEM7SUFFVCxTQURJbGU7WUFoQklzb0Q7O1FBNUxkLE9BQUE7O1FBaU5xQixPQXpDZkosMEJBZ0JXcDdFLEdBR0pxN0U7Z0JBdUJJLGVBUEwzbkUsR0FuQksxVCxHQUNKdTdFLE1Ba0JRcGpFLEdBQUd3aEIsSUFwQlhubkI7O1lBcUJIMGdCO0tBZUE7TUFBQTtRQXRDQW9vRDtVQXNCV25qRSxHQXBCUjNGLFFBQ0l4UyxHQUNKdTdFLE1BQ0FmLGFBQ0FhLGFBQ0NHO01BOEJDMXhEO01BQUhxd0I7S0FHSixXQTlGRnV0QixJQTRFTWgwRCxHQUFHMDlCLEtBQUdxcUMsS0FlTnRoQyxNQUFHcndCOztJQUpMO0tBQUE7T0FqQ0F3eEQ7U0FzQkU1bkUsR0FwQkNsQixRQUNJeFMsR0FDSnU3RSxNQUNBZixhQUNBYSxhQUNDRztLQXlCQ3p4RDtLQUFIb1Q7SUFHSixXQXpGRnVxQyxJQXNGTXZxQyxLQVZHaVUsS0FBR3FxQyxLQUFHdGpFLElBVU40UjtHQVFhO1lBR3RCMnhELFFBQVFockUsR0FBRzhCLFFBQVE4dEIsS0FBS2k3QyxNQUFNZixhQUFhYTtJQUM3QyxPQTVDTUM7YUEyQ0k1cUUsR0FBRzhCLFFBQVE4dEIsS0FBS2k3QyxNQUFNZixhQUFhYTtHQUN5QztZQUdwRk0saUJBQWlCanJFLEdBQUc4QixRQUFROHRCLEtBQUtpN0MsTUFBTWYsYUFBYWE7SUFDdEQsT0FoRE1DO2FBK0NhNXFFLEdBQUc4QixRQUFROHRCLEtBQUtpN0MsTUFBTWYsYUFBYWE7R0FReEI7WUFHNUJ4akMsSUFBSW5uQyxHQUFHOEIsUUFBUTh0QixLQUFLaTdDLE1BQU1mO0lBQzVCLE9BM0RNYzthQTBEQTVxRTthQUFHOEI7YUFBUTh0QjthQUFLaTdDO2FBQU1mOzZCQU9ILFdBQU87O0dBQ2Y7WUFHZnpOLE1BQUtyOEQsR0FBRTR2QixLQUFJaTdDLE1BQU1mO0lBQWtCLFdBWG5DM2lDLElBV0tubkMsTUFBRTR2QixLQUFJaTdDLE1BQU1mO0lBQWtCLE9BQUE7R0FBeUM7WUFVeEVvQjtJQUF3QjtLQUVuQixPQUFBO1FBM01LTCxpQkFBSmo3QztJQUFXLFdBQVhBLEtBQUlpN0M7R0EyTWdEO1lBUTFETSxTQUFTbm9FLEdBQUV5RSxHQUFJLE9BM05uQnZJLE9BMk5hOEQsTUFBQUEsTUFBQUEsTUFBRXlFLEdBQXdDO1lBS25EaUcsS0FBSzFLLEdBQUV5RTtJQUFJLFdBQUpBLGFBQUFBO0lBQUksV0FMWDBqRSxTQUtLbm9FLEdBQUV5RTtHQUF1RDtZQWlCMUQyakUsR0FBR3ByRSxHQUFFMVE7SUFDWCxPQURTMFE7O09BRUksV0FGSkEsR0FBRTFROztXQUdEQyxJQUhEeVEsTUFHRmtHLE1BSEVsRyxNQUdPLFdBQVRrRyxLQUFHM1csR0FIQ0Q7O1dBSUU0a0IsTUFKSmxVLE1BSUNvcEIsSUFKRHBwQixNQUlGbUcsTUFKRW5HO09BSVUsV0FKYm9yRSxHQUlDamxFLEtBckJMdUgsS0FxQlEwYixHQUFHbFYsT0FKRjVrQjs7R0FJeUM7WUFMcEQrN0UsY0FPRXJyRSxHQUFHNHZCLEtBQUtpN0MsTUFBUSxPQU5aTyxHQU1KcHJFLFVBQUc0dkIsS0FBS2k3QyxPQUE0QztZQUloRFMsS0FBR3RyRSxHQUFFeUg7SUFDWCxJQURTdkIsTUFBQWxHLEdBQUV5cEMsTUFBQWhpQztJQUNYO1lBRFN2Qjs7UUFFSSxPQUZGdWpDOztRQUdVLElBQVh6bUMsSUFIRGtELFFBQUFDLE1BQUFELFFBQUV3akMsTUFoQ1R5aEMsU0FtQ1Fub0UsR0FIQ3ltQztRQUFGdmpDLE1BQUFDO1FBQUVzakMsTUFBQUM7OztRQUljO1NBQVhqZCxNQUpMdm1CO1NBSUNpeEQsS0FKRGp4RDtTQUFBRSxNQUFBRjtTQUFFcWpDLE1BaENUNGhDLFNBS0F6OUQsS0ErQlF5cEQsSUFBSTFxQyxNQUpIZ2Q7UUFBRnZqQyxNQUFBRTtRQUFFcWpDLE1BQUFGOztHQUl3RDtZQUxuRWdpQztJQU9GOztPQUNhOztXQUNIOWpFLGNBQUh6SDtPQUFjLE9BUmJzckUsS0FRRHRyRSxHQWxESGtyRSxzQkFrRE16akU7O1dBQ0dnaUMsZ0JBQUh6bUMsY0FBSGtEO09BQTRCLE9BVDNCb2xFLFNBU0RwbEUsS0FBR2xELElBbkROa29FLHNCQW1EU3poQzs7R0FBd0Q7WUFHbkUraEM7SUFBVTs7T0FDQzs7V0F2Q0QvakU7bUJBQUFBOztJQXdDb0IsV0F4Q3BCQTtHQXdDNkM7WUFJekRna0UsdUJBQXVCNWtDLEtBQUtpakM7SUFDOUIsT0FBWTthQW5VWjc4RDtzQkFtVW1CSztjQUFQO2VBRVI7aUJBQUE7O21CQUhxQnU1Qjt1QkErNURyQjNGOztvQkF6NURLO3FCQUE2QjJwQztxQkFBTGo3QztxQkFBVDl0QjtxQkFBVDRwRTtxQkFDRCxRQWJWRixRQVlXRTs7eUJBRUFDO3FCQUFjLFFBQUEsV0FSQzdCLGFBUWY2QixVQUZrQi83QztzQkFJckIsT0FBQTsrQkFUT3RpQjsrQkFTUDs7O29CQUNzRCxXQUFBLDRCQUwxQ3hMO29CQUtULFdBeENYdXBFLGNBbUNXSyxTQUFrQjk3QyxLQUFLaTdDO21CQUt1QztlQVQ5RC9vRTtlQUFUNHBFO2NBV0osZUFoQ0VILGtCQXFCRUcsVUFBUzVwRTthQVcyQztHQUFBO1lBTXBEOHBFLE9BQUs1b0UsR0FBRXdzQixHQUFFc2MsR0FBRXJrQyxHQUFHcWlFO0lBQ3BCLFVBRFc5bUUsZ0JBRUcsT0EzRlpxNUQsTUF5RmU1MEQsR0FBSituQixHQUFFc2MsR0FBS2crQjthQUFUOW1FO1NBTWFnMUQsS0FOYmgxRCxNQU1TaTBELEtBTlRqMEQsTUFNSzZvRSxPQU5MN29FLE1BTUM4b0UsT0FORDlvRSxNQU1IbTBELEtBTkduMEQ7ZUFBTXlFO2VBQUFBO1dBS0Y4aUUsS0FMRTlpRSxNQUtOc2tFLEtBTE10a0U7T0FLSyxPQTlGcEI0MEQsTUFBQUEsTUF5RlNyNUQsR0FBRXdzQixHQUFFc2MsR0FBS2crQixjQUtUaUMsSUFBSXhCLElBTEtUOztVQU0rQjVSLEtBTmxDendELE1BTThCK3ZELEtBTjlCL3ZELE1BTTBCdWtFLE9BTjFCdmtFLE1BTXNCd2tFLE9BTnRCeGtFLE1BTWtCaXdELEtBTmxCandEO2FBUVAsNEJBRnlDeXdELFNBQTNCRjtnQkExTnRCaEIsSUEwTk1HLElBQUkyVSxNQUFJRCxNQU5WRCxPQU1jM1UsSUFOUHpuQyxHQUFFc2MsR0FBRXJrQyxHQUFHcWlFO2dCQWFMO21DQVBTOVI7a0JBQTJCRTtrQkExTmpEbEIsSUFvTkk0VSxPQUFLNW9FLEdBQUV3c0IsR0FBRXNjLEdBTW9CNHJCLElBTmZvUyxjQU1tQm1DLE1BQUlELE1BQUl4VTtrQkExTjdDUixJQW9OU2gwRCxHQUFFd3NCLEdBQUVzYyxHQUFFcmtDOzs7Y0FBQUEsZ0JBR0gsT0E1Rlo0MEQsTUF5RlNyNUQsR0FBRXdzQixHQUFFc2MsR0FBS2crQjtRQUlSTSxLQUpEcG5FLE1BSUhrcEUsS0FKR2xwRTtJQUlXLE9BN0ZwQnE1RCxNQUFBQSxNQXlGZTUwRCxHQUFKK25CLEdBQUVzYyxHQUFLZytCLGNBSVpvQyxJQUFJOUIsSUFKUU47R0FlRjtZQUdaM3lCLE1BQU1uM0MsR0FBRTFRLEdBQUd3NkU7SUFDakIsVUFEWTlwRSxnQkFFRDthQUZDQTtLQUlBLElBREQ4ckMsSUFIQzlyQyxNQUdKd3ZCLElBSEl4dkIsTUFJTjZ4QixNQUFNLFdBSktpNEMsYUFBSHg2RSxHQUdOa2dDO0tBRU4sYUFESXFDOzhCQURFckMsR0FBR3NjO29CQUNMamEsVUFKTTd4QixxQkFBQUE7O0lBV0E7S0FES3lILElBVkx6SDtLQVVFK3FFLE1BVkYvcUU7S0FVRHU3QyxNQVZDdjdDO0tBVUpnRCxJQVZJaEQ7S0FXTm1zRSxRQUFNLFdBWEtyQyxhQUFIeDZFLEdBVUhpc0Q7SUFFVCxTQURJNHdCLE9BRUMsV0FIQ25wRSxXQUFHdTRDLEtBQUd3dkIsT0FBR3RqRTtZQUNYMGtFO0tBUWtCO01BQUEsUUFuQmxCaDFCLE1BVVcxdkMsR0FWSG5ZLEdBQUd3NkU7TUFtQkV0UztNQUFQZ0Q7TUFBSjlDO0tBQ0osV0F0Q0VrVSxPQTRCRTVvRSxHQUFHdTRDLEtBQUd3dkIsS0FTTnJULElBbkJTb1MsY0FtQkx0UCxPQUFPaEQ7O0lBSEs7S0FBQSxVQWhCbEJyZ0IsTUFVRW4wQyxHQVZNMVQsR0FBR3c2RTtLQWdCRTdTO0tBQVBtVjtLQUFKalY7SUFDSixXQURJQSxJQUFJaVYsU0FsQ05SLE9Ba0NhM1UsSUFOUjFiLEtBQUd3dkIsS0FBR3RqRSxHQVZBcWlFO0dBb0J5QjtZQUd4Q3VDLDRCQUE0QnJzRSxHQUFHc3NFLE1BQUtoOUUsR0FBR3c2RTtJQUN6QztLQUFnQyxRQXhCMUIzeUIsTUF1QndCbjNDLEdBQVExUSxHQUFHdzZFO0tBQ2pCdmlDO0tBQWRnbEM7S0FBTmpsQztJQUNKLEtBRFVpbEMsY0FFQSxXQUZOamxDLE1BQW9CQztrQkFBZGdsQyxpQkFHRzFCLG1CQUFMajdDO2FBQ0Y0OEMsWUFBWTdTO0tBQVcsV0FsSjNCeHlCLElBa0pnQnd5QixTQURWL3BDLEtBQUtpN0MsTUFKNEJmO0tBS1osT0FBQTtJQUE0QztJQUN2RSxvQkFOK0J3QztrQkFLM0JFLFlBSkZsbEMsT0FBb0JDO2tCQUFwQkQsTUFJRWtsQyxZQUprQmpsQztHQU9lO1lBR3JDa2xDLFlBQ0V6c0UsR0FDRStjLGFBQ0FDLGFBQ0Q4c0Q7SUFFTCxHQUFHLGdDQUpHL3NELGFBQ0FDLGFBQ0Q4c0Q7S0FNQTthQXEvQ0huUjthQUFBQTthQUFBQTtjQTcvQ0k1N0M7U0FVTTJ2RCxnQkFYUjFzRSxHQVdFc25DLE9BbS9DSnF4QjtrQkE3L0NJNTdDOztNQWFLNHZELE9BYkw1dkQ7YUFiSnN2RCw0QkFZRXJzRSxjQWNPMnNFLE1BWE43QztNQVFPNEM7TUFBTnBsQzs7O01BSUtzbEMsT0FkTDd2RDthQWJKc3ZELDRCQVlFcnNFLGNBZU80c0UsTUFaTjlDO01BUU8rQztNQUFOaGtDO01BQU02akMsZ0JBQUFHO01BQU52bEMsT0FBQXVCO2NBVEE3ckI7U0FlS3VxQixRQTYrQ1RveEIsZ0NBNytDSTE5QixNQU5NeXhDO2tCQVROMXZEOztNQWtCSzh2RCxLQWxCTDl2RDs7UUFkSnF2RCw0QkF1QlVLLDBCQVNESSxJQWpCTmhEO01BY012aUM7TUFBTHRNOzs7TUFJSzh4QyxPQW5CTC92RDs7UUFkSnF2RDtVQXVCVUssMEJBVURLLE1BbEJOakQ7TUFjTUQ7TUFBTG1EO01BQUt6bEMsUUFBQXNpQztNQUFMNXVDLE1BQUEreEM7SUFPSixXQWJJMWxDLE1BTUFyTSxLQUFLc007R0FPUTtZQUdidnVCLEtBQUtoWixHQUFFMVEsR0FBR3c2RTtJQUNoQixJQURXNWpFLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQTtVQUdBNGxDLElBSEE1bEMsUUFHSHFJLElBSEdySTtNQUdTLGFBQUEsV0FISjRqRSxhQUFIeDZFLEdBR0xpZixTQUFHdTlCOztLQUVEO01BRE9ya0MsSUFKTnZCO01BSUc2a0UsTUFKSDdrRTtNQUlBdzZCLE1BSkF4NkI7TUFJSGxELElBSkdrRDtNQUtMc0osSUFBSSxXQUxNczZELGFBQUh4NkUsR0FJRm94QztLQUVULFNBRElseEIsR0FDVSxXQUZGdTdEO1NBSkh0aEMsV0FLTGo2QixJQURXL0gsSUFBVHpFO0tBSkdrRCxNQUFBdWpDOztHQU02RDtZQUd0RXdqQyxVQUFVanRFLEdBQUc4QixRQUFROHRCLEtBQUtpN0MsTUFBTWY7SUFDbEM7S0FBZ0MsT0FWMUI5d0QsS0FTTWhaLEdBQVc0dkIsS0FBV2s2QztLQUM5Qm9ELGFBRHdCckMsTUFDVDtJQUNuQixPQS9MRTFqQyxJQTZMVW5uQyxHQUFHOEIsUUFBUTh0QixLQUNuQnM5QyxRQUQ4QnBEO0dBRUc7WUFHbkNxRCxXQUFXbnRFLEdBQUUxUSxHQUFHdzZFO0lBQ1osWUFmQTl3RCxLQWNPaFosR0FBRTFRLEdBQUd3NkU7Z0JBRVI7UUFDSDltRTtJQUFLLE9BQUxBO0dBQU07WUFJVDhuQyxhQUFhbGIsS0FBSys2QztJQUNELDRCQUF3QyxXQUR2Q0EsYUFBTC82QztJQUNmLE1BQUE7R0FBOEU7R0FFaEYsU0FKRTVMLFNBSWVoa0IsR0FBRTFRLEdBQUd3NkUsYUFBYWE7SUFDakMsSUFEZXprRSxNQUFBbEc7SUFDZjtlQURla0csa0JBRUosT0FMVDRrQyxhQUdleDdDLEdBQWdCcTdFO2NBQWxCemtFO1VBR0o0bEMsSUFISTVsQyxRQUdQcUksSUFIT3JJO01BR0ssYUFBQSxXQUhBNGpFLGFBQUh4NkUsR0FHVGlmO2dCQUFHdTlCO2dCQU5UaEIsYUFHZXg3QyxHQUFnQnE3RTs7S0FLdkI7TUFET2xqRSxJQUpGdkI7TUFJRDZrRSxNQUpDN2tFO01BSUp3NkIsTUFKSXg2QjtNQUlQbEQsSUFKT2tEO01BS1RzSixJQUFJLFdBTFVzNkQsYUFBSHg2RSxHQUlOb3hDO0tBRVQsU0FESWx4QixHQUNVLE9BRkZ1N0Q7U0FKQ3RoQyxXQUtUajZCLElBRFcvSCxJQUFUekU7S0FKT2tELE1BQUF1akM7O0dBTXFFO1lBTXBGcHZCLElBQUlyYSxHQUFFMVEsR0FBR3c2RTtJQUE2QixXQXBDbEM5d0QsS0FvQ0FoWixHQUFFMVEsR0FBR3c2RTtJQUE2QixPQUFBO0dBQXVCO1lBRXpEbHhEO0lBQVU7SUFBQTtxQ0FDTDs7VUFDQWt6QixnQkFBSHRjO01BQVMsZUFBVEEsR0FBR3NjOztTQUVIOW9DO2VBQUFBO1VBRFUrbkUsa0JBQUh4dkI7TUFBZSxlQUFmQSxLQUFHd3ZCOztlQUNWL25FOztHQUEyQjtHQUdyQztJQUFBOzs7Ozs7R0FHRTs7Ozs7O01BRUUsMkNBRUk7TUFDSyxNQUFBO0tBQWE7R0FLMUI7SUFBQTs7Ozs7O0dBR0U7Ozs7OztNQUVFLDJDQUVJO01BQ0ssTUFBQTtLQUFhOztZQUt0Qm8xRCxZQUFZcDREO0lBQ1IsWUFsQ0E0WSxRQWlDUTVZOztLQUVKLE1BQUE7UUFDSHVPO0lBQUssT0FBTEE7R0FBTTtZQUdQdUs7SUFBVTtJQUFBO3FDQUNMOztVQUNBZ3pCLGdCQUFIdGM7TUFBUyxlQUFUQSxHQUFHc2M7OztVQUNHaS9CLGtCQUFIeHZCO01BQW1CLGVBQW5CQSxLQUFHd3ZCOztTQUNHdGpFO2VBQUFBOztHQUFrQjtZQUdqQzh3RCxZQUFZdjREO0lBQ1IsWUFSQThZLFFBT1E5WTs7S0FFSixNQUFBO1FBQ0h1TztJQUFLLE9BQUxBO0dBQU07WUFHUGlxRCxlQUFleDREO0lBQ3JCLFVBRHFCQTtLQUVWLE9BQUE7YUFGVUEsTUFHVDtRQUVKZ0QsSUFMYWhEO2NBS2JnRCxvQkFEYXlFLElBSkF6SCxNQUlTLE9BQVR5SDtRQUNKZ2lDLE1BTEl6cEMsTUFLUDhyQyxJQUxPOXJDLE1BS1YxUSxJQUxVMFE7SUFLSyxPQW5ZeEJnM0QsSUE4WEl3QixlQUtFeDFELElBQUcxVCxHQUFHdzhDLEdBQUdyQztHQUFxQztZQUdwRHBxQyxPQUFRK3RFLFlBQVlDLFlBQVl2RDtJQUNsQyxJQUFNLFFBdEJBaHhELFFBcUJJczBELGFBQ2dCLFVBN0RwQngwRCxRQTREZ0J5MEQ7Z0JBRVQsa0JBRlNBO2tCQUdULGtCQUhIRDs7O0tBSThCNytEO0tBQVgrK0Q7S0FBckJDO0lBQXdDLFFBQUEsV0FKZHpELGFBSTFCeUQsV0FBcUJELFlBR3RCO0lBRndCLElBQXpCRSx5QkFiQWhWLGVBUWdCNlU7SUFNcEI7O1lBeExJekI7Y0FrTEl3QixZQUltQkUsV0FBVy8rRCxHQUNsQ2kvRCx3QkFMNEIxRDtHQU9KO1lBS3RCMkQsS0FBR3p0RSxHQUFHdlEsS0FBS0QsS0FBS2tRLE1BQU1PLEdBQUc2cEU7SUFDL0IsSUFEUzVqRSxNQUFBbEcsR0FBYTA2RCxTQUFBaDdEO0lBQ3RCO2VBRFN3RyxrQkFFRSxPQUZXdzBEO2NBQWJ4MEQ7VUFHRTRsQyxJQUhGNWxDLFFBR0RzcEIsSUFIQ3RwQjtNQUlxQjthQUF6QixXQUowQjRqRSxhQUd2QnQ2QyxHQUhJLy9CO2dCQUlrQixXQUpDcTZFLGFBR3ZCdDZDLEdBSFNoZ0M7T0FPVixPQUFBLFdBUHFCeVEsR0FHcEJ1dkIsR0FBR3NjLEdBSFc0dUI7TUFNbEIsT0FOa0JBOztLQVNSO01BVExqekQsSUFBQXZCO01BUUs2a0UsTUFSTDdrRTtNQVFFcTFDLE1BUkZyMUM7TUFRRGxELElBUkNrRDtNQVNId25FLFFBQVEsV0FUaUI1RCxhQVFwQnZ1QixLQVJDOXJEO0tBVVYsUUFESWkrRTtlQUFBQTtPQVFtQixJQWpCSEMsU0FpQkcsV0FqQkcxdEUsR0FRakJzN0MsS0FBR3d2QixLQVJRclE7T0FBYngwRCxNQUFBdUI7T0FBYWl6RCxTQUFBaVQ7OztPQW9CVjtRQUFKdmtELElBcEJGcWtELEtBUUV6cUUsR0FSSXZULEtBQUtELEtBQUtrckUsUUFBTXo2RCxHQUFHNnBFO1FBcUJ2QjhELFFBQVEsV0FyQmU5RCxhQVFwQnZ1QixLQVJNL3JEO09BdUJiLE9BRklvK0UsT0FHQyxPQUpEeGtEO09BTU0sSUExQlF5a0QsU0EwQlIsV0ExQmM1dEUsR0FRakJzN0MsS0FBR3d2QixLQVlOM2hEO09BUUYsU0FQRXdrRCxPQU9nQixPQTVCRkM7T0FBYjNuRSxNQUFBdUI7T0FBYWl6RCxTQUFBbVQ7OztNQUFiM25FLE1BQUF1Qjs7R0E0QjhEO1lBOUJ2RXFtRSxxQkFnQ0U5dEUsR0FBR3ZRLEtBQUtELEtBQUtrUSxNQUFNTyxHQUFHNnBFO0lBQ3hCLFdBQUcsV0FEcUJBLGFBQW5CcjZFLEtBQUtEO2NBQUtrUTtjQTlCVCt0RSxLQThCSnp0RSxHQUFHdlEsS0FBS0QsS0FBS2tRLE1BQU1PLEdBQUc2cEU7R0FDdUQ7WUFHL0VpRSxlQUFlL3RFLEdBQUd2USxLQUFLRCxLQUFLczZFO0lBRTVCOztPQXRDQWdFO1NBb0NlOXRFO1NBQUd2UTtTQUFLRDs7a0JBT1hvZ0MsS0FBS2k3QyxNQUFLN25FLEdBQUssZUFBZjRzQixLQUFLaTdDLE9BQUs3bkUsR0FBcUI7U0FQZjhtRTtJQUU1QixPQUFBO0dBTWdCO1lBR2hCa0UsaUJBQWlCNXNFLElBQUdDO0lBQ3RCLFVBRG1CRCxpQkFFTCxPQUZRQztjQUFBQSxpQkFHUixPQUhLRDtJQUtOLElBQUEsUUF6RlhnM0QsWUFvRm9CLzJELEtBS2J5cUMsY0FBSHg4QztJQUNPLE9BcmNYMG5FLElBK2JpQjUxRCxJQUtiOVIsR0FBR3c4QyxHQXRFSDBzQixlQWlFZ0JuM0Q7R0FNVTtHQUdsQzs7WUFFSTZ1QixPQUFPbHdCLEdBQUUxUSxHQUFHd1MsUUFBUWdvRTthQUNkbUUsWUFBWWp1RSxHQUFFMVEsR0FBR3dTLFFBQVFnb0U7S0FDL0IsVUFEa0I5cEUsZ0JBSHRCLE9BQUE7Y0FHc0JBO1VBR1Z1TyxJQUhVdk87TUFJYixhQUFBLFdBSjBCOHBFLGFBQVh4NkUsR0FHWmlmO3VCQUVNLDRCQUxTek07Z0JBSDNCOztLQVdjO01BRE8yRixJQVBDekg7TUFPSjhyQyxJQVBJOXJDO01BT1AwZ0MsTUFQTzFnQztNQU9WZ0QsSUFQVWhEO01BUVp3UCxJQUFJLFdBUnFCczZELGFBQVh4NkUsR0FPVG94QztLQUVULFNBRElseEI7TUFFdUIsV0FBQSw0QkFWTjFOO01BVWhCLFdBdEJQa3NFLGlCQW1CUWhyRSxHQUFTeUU7O2FBQ1grSDtNQVFjO09BQUEsUUFoQmR5K0QsWUFPV3htRSxHQVBHblksR0FBR3dTLFFBQVFnb0U7T0FnQnBCMXdEO09BQUhxd0I7TUFDSixXQTVkSnV0QixJQWtkUWgwRCxHQUFHMDlCLEtBQUdvTCxHQVNOckMsTUFBR3J3Qjs7S0FIUztNQUFBLFVBYmQ2MEQsWUFPRWpyRSxHQVBZMVQsR0FBR3dTLFFBQVFnb0U7TUFhcEJ6d0Q7TUFBSG9UO0tBQ0osV0F6ZEp1cUMsSUF3ZFF2cUMsS0FOR2lVLEtBQUdvTCxHQUFHcmtDLElBTU40UjtJQUlhO0lBRTFCLElBQUksV0FuQkk0MEQsWUFEQ2p1RSxHQUFFMVEsR0FBR3dTLFFBQVFnb0UsY0FvQmxCOzs7K0JBQ2MsV0FyQlQ5cEUsR0FBSzhCOzs7R0FxQmE7R0FJN0I7SUFBQTs7Ozs7Ozs7Ozs7WUFFSW9zRSxPQUFPbHVFLEdBQUU0dkIsS0FBSzN2QixHQUFHNkIsUUFBUWdvRTthQUNuQnFFLFlBQVludUUsR0FBRTR2QixLQUFJM3ZCO0tBQ3hCLFVBRGtCRDtNQUdULFlBQUEsV0FIZUM7a0JBSVgsTUFBQTtVQUNINHFFO01BQVEsZUFMRWo3QyxLQUtWaTdDLE9BQTBCLDRCQU5uQi9vRTs7Y0FDQzlCO01BT1IsSUFEQzhyQyxJQU5POXJDLE1BTVZ1TyxJQU5Vdk8sTUFPWndQLElBQUksV0FSZXM2RCxhQUNMbDZDLEtBTVpyaEI7TUFFTixTQURJaUI7T0FHSSxjQUFBLFdBVmN2UCxPQU1iNnJDO3FCQUtHLGNBQU8sNEJBWkpocUM7V0FhTmlwRTtPQUFNLGVBTlR4OEQsR0FNR3c4RCxNQWJNanBFOztjQVFYME47T0FXYztRQUFBLFVBbEJkMitELGVBQWN2K0MsS0FBSTN2QjtRQWtCYm1aO1FBQUgzUjtPQUNKLFdBemZKdXZELE9BNGVRem9ELEdBQUd1OUIsR0FZSHJrQyxJQUFHMlI7O01BSFM7T0FBQSxVQWZkKzBELGVBQWN2K0MsS0FBSTN2QjtPQWVib1o7T0FBSHJXO01BQ0osV0F0ZkpnMEQsSUFxZlFoMEQsR0FUQXVMLEdBQUd1OUIsT0FTQXp5Qjs7S0FNRDtNQURVNFAsSUFwQkZqcEI7TUFvQkR5cEMsTUFwQkN6cEM7TUFvQkpvdUUsTUFwQklwdUU7TUFvQlAwZ0MsTUFwQk8xZ0M7TUFvQlZ5c0IsTUFwQlV6c0I7TUFxQlp3aUIsTUFBSSxXQXRCZXNuRCxhQUNMbDZDLEtBb0JUOFE7S0FFVCxTQURJbGU7TUFHSSxjQUFBLFdBeEJjdmlCLE9Bb0JWbXVFOztXQU1IbEI7T0FBUSxlQU5YemdELEtBcEJZbUQsS0EwQlRzOUMsUUFOTXpqQyxLQUFHeGdCLElBckJIbm5COztNQTBCbUIsV0FBQSw0QkExQm5CQTtNQTBCSCxXQWhFZGtzRSxpQkEyRFF2aEQsS0FBU2dkOzthQUNYam5CO01BV2M7T0FBQSxVQWhDZDJyRCxZQW9CVzFrQyxLQXBCRzdaLEtBQUkzdkI7T0FnQ2JvdUU7T0FBSDNrQztNQUNKLFdBdmdCSnN0QixJQTBmUXZxQyxLQUFHaVUsS0FBRzB0QyxLQVlOMWtDLE1BQUcya0M7O0tBSFM7TUFBQSxVQTdCZEYsWUFvQkUxaEQsS0FwQlltRCxLQUFJM3ZCO01BNkJicXVFO01BQUgxOUM7S0FDSixXQXBnQkpvbUMsSUFtZ0JRcG1DLEtBVEc4UCxLQUFHMHRDLEtBQUcza0MsTUFTTjZrQztJQUlhO0lBRTFCLElBQUksV0FuQ0lILFlBRENudUUsR0FBRTR2QixLQUFLM3ZCLElBb0NaOzs7K0JBQ2MsV0FyQ1RELEdBQVU4Qjs7O0dBcUNRO1lBR3pCeXNFLE9BQU92dUUsR0FBRTR2QixLQUFLM3ZCLEdBQUc2QixRQUFRZ29FO2FBQ25CMEUsWUFBWXh1RSxHQUFFNHZCLEtBQUkzdkI7S0FDeEIsVUFEa0JEO01BR0wsSUFBUDZxRSxPQUFPLFdBSFc1cUU7TUFJdEIsZUFKa0IydkIsS0FHZGk3QyxPQUNjLDRCQUxIL29FOztjQUNDOUI7TUFNUixJQURDOHJDLElBTE85ckMsTUFLVnVPLElBTFV2TyxNQU1ad1AsSUFBSSxXQVBlczZELGFBQ0xsNkMsS0FLWnJoQjtNQUVOLFNBRElpQjtPQUdPLElBQUx1N0QsTUFBSyxXQVRXOXFFLE9BS2I2ckM7T0FLUCxlQUxJdjlCLEdBSUF3OEQsTUFWU2pwRTs7Y0FPWDBOO09BVWMsSUFBQSxRQWhCZGcvRCxlQUFjNStDLEtBQUkzdkIsSUFnQmJtWixxQkFBSDNSO09BQ0osV0EvaEJKdXZELE9BbWhCUXpvRCxHQUFHdTlCLEdBV0hya0MsSUFBRzJSOztNQUhTO09BQUEsVUFiZG8xRCxlQUFjNStDLEtBQUkzdkI7T0FhYm9aO09BQUhyVztNQUNKLFdBNWhCSmcwRCxJQTJoQlFoMEQsR0FSQXVMLEdBQUd1OUIsT0FRQXp5Qjs7S0FNRDtNQURVNFAsSUFsQkZqcEI7TUFrQkR5cEMsTUFsQkN6cEM7TUFrQkpvdUUsTUFsQklwdUU7TUFrQlAwZ0MsTUFsQk8xZ0M7TUFrQlZ5c0IsTUFsQlV6c0I7TUFtQlp3aUIsTUFBSSxXQXBCZXNuRCxhQUNMbDZDLEtBa0JUOFE7S0FFVCxTQURJbGU7TUFHUyxJQUFQMHFELFNBQU8sV0F0QlNqdEUsT0FrQlZtdUU7TUFLVixlQUxJM2hELEtBbEJZbUQsS0FzQlpzOUMsUUFKU3pqQyxLQUFHeGdCLElBbkJIbm5COzthQW9CWDBnQjtNQVVjO09BQUEsVUE3QmRnc0QsWUFrQlcva0MsS0FsQkc3WixLQUFJM3ZCO09BNkJib3VFO09BQUgza0M7TUFDSixXQTVpQkpzdEIsSUFnaUJRdnFDLEtBQUdpVSxLQUFHMHRDLEtBV04xa0MsTUFBRzJrQzs7S0FIUztNQUFBLFVBMUJkRyxZQWtCRS9oRCxLQWxCWW1ELEtBQUkzdkI7TUEwQmJxdUU7TUFBSDE5QztLQUNKLFdBemlCSm9tQyxJQXdpQlFwbUMsS0FSRzhQLEtBQUcwdEMsS0FBRzNrQyxNQVFONmtDO0lBSWE7SUFFMUIsT0FoQ1FFLFlBREN4dUUsR0FBRTR2QixLQUFLM3ZCO0dBaUNHO1lBR2pCd3VFLGFBQWF6dUUsR0FBRTR2QixLQUFLOXRCLFFBQVFnb0U7SUFDOUIsT0E3RUVvRTthQTRFYWx1RTthQUFFNHZCOztjQUNvQjs7O29CQUV0QjgrQzttQkFBQUEsZ0JBQStCLFdBQS9CQTs7O2NBRGlCO2FBQ2tDO2FBSDVDNXNFO2FBQVFnb0U7R0FHb0M7WUFHNUQ2RSxVQUFVM3VFLEdBQUdDO0lBQ25CLElBRGdCaUcsTUFBQWxHO0lBQ2hCO2VBRGdCa0csa0JBRUw7Y0FGS0EsWUFHUnFJLElBSFFySSxRQUdDLE9BQUEsV0FIRWpHLEdBR1hzTztTQUhROUcsSUFBQXZCLFFBSUx3NkIsTUFKS3g2QixRQUlSbEQsSUFKUWtEO0tBQVZ5b0UsVUFJRTNyRSxHQUpXL0M7S0FNakIsV0FOaUJBLEdBSVJ5Z0M7S0FKS3g2QixNQUFBdUI7O0dBT0E7WUFHVnRILEtBQUtILEdBQUdDO0lBQ2QsSUFEV2lHLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQSxZQUdBNGxDLElBSEE1bEMsUUFHTSxPQUFBLFdBSEhqRyxHQUdINnJDO1NBSEFya0MsSUFBQXZCLFFBSUc2a0UsTUFKSDdrRSxRQUlIbEQsSUFKR2tEO0tBQUwvRixLQUlFNkMsR0FKTS9DO0tBTVosV0FOWUEsR0FJQThxRTtLQUpIN2tFLE1BQUF1Qjs7R0FPQTtZQUdMckgsTUFBTUosR0FBR0M7SUFDZixJQURZaUcsTUFBQWxHO0lBQ1o7ZUFEWWtHLGtCQUVEO2NBRkNBLFlBR0Q0bEMsSUFIQzVsQyxRQUdKcUksSUFISXJJLFFBR0ssT0FBQSxXQUhGakcsR0FHUHNPLEdBQUd1OUI7U0FIQ3JrQyxJQUFBdkIsUUFJRTZrRSxNQUpGN2tFLFFBSUR3NkIsTUFKQ3g2QixRQUlKbEQsSUFKSWtEO0tBQU45RixNQUlFNEMsR0FKTy9DO0tBTWIsV0FOYUEsR0FJSnlnQyxLQUFHcXFDO0tBSkY3a0UsTUFBQXVCOztHQU9BO1lBSUptbkUsaUJBQWlCNXVFLEdBQUdDO0lBQzFCLElBRHVCaUcsTUFBQWxHO0lBQ3ZCO2VBRHVCa0csa0JBRVo7Y0FGWUEsWUFHWjRsQyxJQUhZNWxDLFFBR2ZxSSxJQUhlckksUUFHTixPQUFBLFdBSFNqRyxHQUdsQnNPLEdBQUd1OUI7U0FIWXJrQyxJQUFBdkIsUUFJVDZrRSxNQUpTN2tFLFFBSVp3NkIsTUFKWXg2QixRQUlmbEQsSUFKZWtEO1FBQWpCMG9FLGlCQUlFNXJFLEdBSmtCL0MsSUFNYjtRQUVELFdBUmNBLEdBSWZ5Z0MsS0FBR3FxQyxNQUtFO0tBVE83a0UsTUFBQXVCOztHQVVvQjtZQVgzQ29uRSxZQWFFN3VFLEdBQUdDO0lBQWdELFdBWi9DMnVFLGlCQVlKNXVFLEdBQUdDO0lBQWdELE9BQUE7R0FBdUI7WUFHeEVJLElBQUlMLEdBQUdDO0lBQ2IsVUFEVUQsZ0JBRUM7YUFGREEsVUFHQzhyQyxJQUhEOXJDLE1BR0Z1TyxJQUhFdk8sTUFHTyxXQUFUdU8sR0FBa0IsV0FIYnRPLEdBR0Y2ckM7SUFFQTtLQURTN2lCLElBSlZqcEI7S0FJT3lILElBSlB6SDtLQUlJK3FFLE1BSkovcUU7S0FJQzBnQyxNQUpEMWdDO0tBSUZnRCxJQUpFaEQ7S0FLSnlzQixNQUxBcHNCLElBSUUyQyxHQUpLL0M7S0FNUG11RSxNQUFLLFdBTkVudUUsR0FJQzhxRTtLQUdSdGhDLE1BUEFwcEMsSUFJV29ILEdBSkp4SDtJQVFYLFdBSEl3c0IsS0FES2lVLEtBRUwwdEMsS0FDQTNrQyxLQUhjeGdCO0dBSUs7WUFHbkIzb0IsS0FBS04sR0FBR0M7SUFDZCxVQURXRCxnQkFFQTthQUZBQTtTQUdBOHJDLElBSEE5ckMsTUFHSHVPLElBSEd2TztLQUdNLFdBQVR1TyxHQUFrQixXQUhadE8sR0FHTnNPLEdBQUd1OUI7O0lBRUE7S0FEUzdpQixJQUpUanBCO0tBSU15SCxJQUpOekg7S0FJRytxRSxNQUpIL3FFO0tBSUEwZ0MsTUFKQTFnQztLQUlIZ0QsSUFKR2hEO0tBS0x5c0IsTUFMQW5zQixLQUlFMEMsR0FKTS9DO0tBTVJtdUUsTUFBSyxXQU5HbnVFLEdBSUh5Z0MsS0FBR3FxQztLQUdSdGhDLE1BUEFucEMsS0FJV21ILEdBSkh4SDtJQVFaLFdBSEl3c0IsS0FES2lVLEtBRUwwdEMsS0FDQTNrQyxLQUhjeGdCO0dBSUs7WUFHbkJscEIsS0FBS0MsR0FBUTJqQixNQUFNMWpCO0lBQ3pCLElBRFdpRyxNQUFBbEcsR0FBUTA3RCxTQUFBLzNDO0lBQ25CO2VBRFd6ZCxrQkFFQSxPQUZRdzFEO2NBQVJ4MUQ7VUFHQTRsQyxJQUhBNWxDLFFBR0hxSSxJQUhHckk7TUFHTSxPQUFBLFdBSFFqRyxHQUdqQnNPLEdBQUd1OUIsR0FIUTR2Qjs7S0FJdUI7TUFKL0JqMEQsSUFBQXZCO01BSUc2a0UsTUFKSDdrRTtNQUlBdzZCLE1BSkF4NkI7TUFJSGxELElBSkdrRDtNQUFReTFELFNBSXVCLFdBSmpCMTdELEdBSWR5Z0MsS0FBR3FxQyxLQUpSaHJFLEtBSUVpRCxHQUpXMDRELFFBQU16N0Q7S0FBZGlHLE1BQUF1QjtLQUFRaTBELFNBQUFDOztHQUlnRTtZQUdqRmpqRCxXQUFXMVksR0FBR04sTUFBTU8sR0FBRzBZO0lBQ3pCLFNBQVFtMkQsZ0JBQWdCOXVFLEdBQUd3WSxLQUFLdlk7S0FDOUIsSUFEc0JpRyxNQUFBbEcsR0FBR2txQixRQUFBMVI7S0FDekI7Z0JBRHNCdFMsa0JBRVgsV0FGY2drQjtlQUFIaGtCO1dBR1g0bEMsSUFIVzVsQyxRQUdkcUksSUFIY3JJO09BR0wsT0FBQSxXQUhhakcsR0FHdEJzTyxHQUFHdTlCLEdBSGM1aEI7O01BS2hCO09BTGF6aUIsSUFBQXZCO09BSVI2a0UsTUFKUTdrRTtPQUlYdzZCLE1BSld4NkI7T0FJZGxELElBSmNrRDtPQUtiLFFBTEg0b0UsZ0JBSUU5ckUsR0FKaUJrbkIsT0FBS2pxQjs2QkFNcEI4dUUsb0JBQVMsV0FBVEE7TUFFRSxJQURFNWtELGtCQUNGLFVBQUEsV0FSa0JscUIsR0FJbkJ5Z0MsS0FBR3FxQyxLQUdBNWdEOytCQUVENmtELHNCQUFTLFdBQVRBO1VBVFl4aEI7TUFBSHRuRCxNQUFBdUI7TUFBR3lpQixRQUFBc2pDOztJQVUwQjtJQUUvQyxZQVpFc2hCLGdCQURLOXVFLEdBQUdOLE1BQU1POzJCQWNYdVksZ0JBQU8sT0FBQSxXQWRPRyxRQWNkSDtRQUNKcUM7SUFBUSxPQUFSQTtHQUFZO1lBR2IzYSxXQUFXRixHQUFRMmpCLE1BQU0xakI7SUFDL0IsSUFEaUJpRyxNQUFBbEcsR0FBUTA3RCxTQUFBLzNDO0lBQ3pCO2VBRGlCemQsa0JBRU4sT0FGY3cxRDtjQUFSeDFEO1VBR040bEMsSUFITTVsQyxRQUdUcUksSUFIU3JJO01BR0EsT0FBQSxXQUhjakcsR0FHdkJzTyxHQUFHdTlCLEdBSGM0dkI7O0tBS0Q7TUFEUGowRCxJQUpBdkI7TUFJSDZrRSxNQUpHN2tFO01BSU53NkIsTUFKTXg2QjtNQUFBbEQsSUFBQWtEO01BQVF5MUQsU0FLRCxXQUxPMTdELEdBSXBCeWdDLEtBQUdxcUMsS0FKUjdxRSxXQUlXdUgsR0FKUWkwRCxRQUFNejdEO0tBQWRpRyxNQUFBbEQ7S0FBUTA0RCxTQUFBQzs7R0FLOEM7WUFHckVzVCxZQUFZanZFLEdBQUdDLEdBQUc2cEU7SUFDcEIsT0FsQ00vcEU7YUFpQ1FDOztzQkFDbUI0dkIsS0FBS2k3QztjQUFYLElBQXVCL29FLG1CQUFONmhCO2NBQ3ZDLE9BQUEsV0FGWTFqQixHQUNnQjJ2Qjt3QkE3aUIvQnVYLElBNmlCMEN4akIsTUFBTTdoQixRQUFqQjh0QixLQUFLaTdDLE1BRGxCZjs0QkFDd0JubUQsTUFBTTdoQjthQUN5QjtHQUFBO1lBSXpFOGhCLE9BQU81akIsR0FBR0MsR0FBRzZwRTtJQUNmLE9BeENNL3BFO2FBdUNHQzs7c0JBQ3dCNHZCLEtBQUtpN0M7Y0FBWCxJQUF1Qi9vRSxtQkFBTjZoQjtjQUN2QyxPQUFBLFdBRk8xakIsR0FDMEI0cUU7d0JBbmpCcEMxakMsSUFtakIwQ3hqQixNQUFNN2hCLFFBQWpCOHRCLEtBQUtpN0MsTUFEdkJmOzRCQUM2Qm5tRCxNQUFNN2hCO2FBQzBCO0dBQUE7WUFHMUU2bkIsUUFBUTNwQixHQUFHQyxHQUFHNnBFO0lBQ2hCLE9BN0NNL3BFO2FBNENJQzs7c0JBQ3VCNHZCLEtBQUtpN0M7Y0FBWCxJQUF1Qi9vRSxtQkFBTjZoQjtjQUN2QyxPQUFBLFdBRlExakIsR0FDb0IydkIsS0FBS2k3Qzt3QkF4akJwQzFqQyxJQXdqQjBDeGpCLE1BQU03aEIsUUFBakI4dEIsS0FBS2k3QyxNQUR0QmY7NEJBQzRCbm1ELE1BQU03aEI7YUFDZ0M7R0FBQTtZQUdoRjRyQixXQUFXMXRCLEdBQUdDLEdBQUc2cEU7SUFDbkIsT0FsRE0vcEU7YUFpRE9DOztzQkFDb0I0dkIsS0FBS2k3QztjQUFYO2VBQXVCL29FO2VBQU42aEI7ZUFDcEMsUUFBQSxXQUZRMWpCLEdBQ3NCNHFFOzBCQUUxQixXQUZnQ2xuRCxNQUFNN2hCO2tCQUd6Q3VCO2NBQUssT0Foa0JaOGpDLElBNmpCMEN4akIsTUFBTTdoQixRQUFqQjh0QixLQUd4QnZzQixHQUpVeW1FO2FBSXNDO0dBQUE7WUFHdkRqOEMsWUFBWTd0QixHQUFHQyxHQUFHNnBFO0lBQ3BCLE9BekRNL3BFO2FBd0RRQzs7c0JBQ21CNHZCLEtBQUtpN0M7Y0FBWDtlQUF1Qi9vRTtlQUFONmhCO2VBQ3BDLFFBQUEsV0FGUzFqQixHQUNnQjJ2QixLQUFLaTdDOzBCQUUxQixXQUZnQ2xuRCxNQUFNN2hCO2tCQUd6Q3VCO2NBQUssT0F2a0JaOGpDLElBb2tCMEN4akIsTUFBTTdoQixRQUFqQjh0QixLQUd4QnZzQixHQUpXeW1FO2FBSXFDO0dBQUE7WUFHdkRvRixlQUFlbHZFLEdBQUdDLEdBQUc2cEU7SUFDdkIsT0FoRU0vcEU7YUErRFdDOztzQkFJTjR2QixLQUFLaTdDO2NBQVg7ZUFBd0JzRTtlQUFQQztlQUNYLFFBQUEsV0FMU252RSxHQUlUMnZCLEtBQUtpN0M7O2VBR1YsSUFETXY3RSxjQUNDd1MsU0FIU3N0RSxVQUdacHZFLElBSFlvdkU7ZUFJaEIsV0FsbEJKam9DLElBaWxCUW5uQyxHQUFHOEIsUUFIRjh0QixLQUVDdGdDLEdBTld3NkUsY0FJTXFGOztjQU12QixJQURPNS9FLGNBQ0E2cEIsV0FOZ0IrMUQsVUFNbkJqcEUsTUFObUJpcEU7Y0FPdkIsV0FQZ0JDLE9BOWtCcEJqb0MsSUFvbEJRamhDLEtBQUdrVCxVQU5Gd1csS0FLRXJnQyxHQVRVdTZFO2FBVzhCO0dBQUE7WUFHbkQ5MUQsY0FBY2hVLEdBQUdDLEdBQUc2cEU7SUFDdEIsT0FmRW9GO2FBY2NsdkU7NkJBQzhCNnFFLE1BQVEsT0FBQSxXQURuQzVxRSxHQUMyQjRxRSxNQUFjO2FBRHRDZjtHQUN1QztZQUczRDErQixjQUFjcHJDLEdBQUdDLEdBQUc2cEU7SUFDdEIsT0FuQkVvRjthQWtCY2x2RTtzQkFDdUI0dkIsS0FBS2k3QztjQUMxQyxPQUFHLFdBRmM1cUUsR0FDb0IydkIsS0FBS2k3QyxZQUFBQSxZQUFBQTthQUNNO2FBRjVCZjtHQUU2QjtZQUdqRDM3QyxhQUFhbnVCLEdBQUdDLEdBQUc2cEU7SUFDckIsT0F4QkVvRjthQXVCYWx2RTs2QkFDK0I2cUU7Y0FDNUMsT0FBRyxXQUZhNXFFLEdBQzRCNHFFLFlBQUFBLFlBQUFBO2FBQ0Y7YUFGdkJmO0dBRXdCO1lBV3JDdjRDLEtBQUt2eEIsR0FBRzZFO0lBQ2QsSUFEV3FCLE1BQUFsRyxHQUFHMGYsTUFBQTdhO0lBQ2Q7ZUFEV3FCLGtCQUVBLE9BRkd3WjtjQUFIeFosWUFHQTRsQyxJQUhBNWxDLFFBR0hxSSxJQUhHckksUUFHTSxXQUFUcUksR0FBR3U5QixNQUhHcHNCO0tBSW1CO01BQWhCalksSUFKTnZCO01BSUc2a0UsTUFKSDdrRTtNQUlBdzZCLE1BSkF4NkI7TUFBQWxELElBQUFrRDtNQUFHcXpELFVBSUg3NEIsS0FBR3FxQyxLQUFHdGpFLEdBSkhpWTtLQUFIeFosTUFBQWxEO0tBQUcwYyxNQUFBNjVDOztHQUlzQztZQUc5Q0MsV0FBV3g1RCxHQUFHNkU7SUFDcEIsSUFEaUJxQixNQUFBbEcsR0FBRzBmLE1BQUE3YTtJQUNwQjtlQURpQnFCLGtCQUVOLE9BRlN3WjtjQUFIeFosWUFHTjRsQyxJQUhNNWxDLFFBR1RxSSxJQUhTckksUUFHQSxXQUFUcUksR0FBR3U5QixNQUhTcHNCO0tBSW1CO01BSnRCalksSUFBQXZCO01BSUg2a0UsTUFKRzdrRTtNQUlOdzZCLE1BSk14NkI7TUFJVGxELElBSlNrRDtNQUFHcXpELFVBSVQ3NEIsS0FBR3FxQyxLQUFOL25FLEdBSlkwYztLQUFIeFosTUFBQXVCO0tBQUdpWSxNQUFBNjVDOztHQUlzQztZQUd4RGtKLFFBQVE5SSxNQUE4QixPQWRsQ3BvQyxLQWNJb29DLFNBQTJDO1lBMkQvQ3YvQyxhQUFZbmE7UUFBTnk2RDs7bUJBQ0gsT0FER0E7S0FHQztNQURZaEI7TUFBTkM7TUFBTmtSO01BQUxqN0M7TUFDRjBQLE9BQU8sV0FIS3IvQixHQUVWMnZCLEtBQUtpN0MsTUFGRG5RO0tBQUFBLFNBR05wN0I7ZUE1RUEvTixLQTJFYW9vQyxNQUFNRDs7O1lBS3ZCdjJDLE1BQU0ybUQsYUFDSzFvRSxJQUFHQyxJQUFHM0IsTUFEY087SUFDakM7O1NBQWFpYixPQUFBOVosSUFBRytaLE9BQUE5WixJQUFHZ3VFLE9BQUEzdkU7S0FDakI7V0FEV3diO1dBQUdDO01BUVM7T0FENkI2K0MsUUFQdEM3K0M7T0FPK0I4K0MsUUFQL0I5K0M7T0FPMkJpckIsS0FQM0JqckI7T0FPdUJtMEQsS0FQdkJuMEQ7T0FPUzIrQyxRQVBaNStDO09BT0s2K0MsUUFQTDcrQztPQU9DbXJCLEtBUERuckI7T0FPSGl2RCxLQVBHanZEO09BUUxnL0MsaUJBQWlCLFdBVGpCNFAsYUFRRUssSUFBNkJtRjtNQUVuQyxTQURJcFY7T0FHUztRQVhFNTZCLE9BV0YsV0FaZ0JyL0IsR0FRdkJrcUUsdUJBQUk5akMsSUFBNkJELE1BUHhCaXBDO1FBQUh2OUMsT0FqRlZQLEtBd0Z5QzBvQyxPQUFPRDtRQVB6Q2pvQyxPQWpGUFIsS0F3Rll3b0MsT0FBT0Q7T0FQWjUrQyxPQUFBNlc7T0FBRzVXLE9BQUEyVztPQUFHdTlDLE9BQUEvdkM7O21CQVFYNDZCO09BVVM7UUFsQkUvNEIsU0FrQkYsV0FuQmdCbGhDLEdBUU1xdkUsbUJBQUlscEMsS0FQeEJpcEM7UUFBSC9ULE9BakZWL3BDLEtBd0Z5QzBvQyxPQUFPRDtPQVB0QzcrQyxPQUFBbWdEO09BQUcrVCxPQUFBbHVDOzs7T0FlRjtRQWZFb3VDLFNBZUYsV0FoQmdCdHZFLEdBUXZCa3FFLG1CQUFJOWpDLEtBUEtncEM7UUFBTjlULE9BakZQaHFDLEtBd0ZZd29DLE9BQU9EO09BUFo1K0MsT0FBQXFnRDtPQUFNOFQsT0FBQUU7OztZQUFIcDBEO2VBUlZmO2dCQVFhaTFEO3lCQUlhei9DLEtBQUtpN0MsTUFBS3J5RDtpQkFBTyxPQUFBLFdBTGhCdlksR0FLRDJ2QixvQkFBS2k3QyxPQUFLcnlEO2dCQUFxQztnQkFKL0QyQztlQUFHazBEOztJQU1mLE9BZEVqMUQ7YUFRYWkxRDtzQkFNYXovQyxLQUFLaTdDLE1BQUtyeUQ7Y0FBTyxPQUFBLFdBUGhCdlksR0FPRDJ2QixvQkFBS2k3QyxPQUFLcnlEO2FBQW9DO2FBTmpFMEM7R0FxQkU7WUFrSWYwK0MsZUEvSGlCeDRELElBQUdDLElBQUl5b0UsYUFBYTBGO2FBQ2pDMXVDLEtBQUs3NkI7S0FDUCxJQU1FcWhDLE9BUEtyaEM7VUFPTHFoQztrQkFQS3JoQztrQkFFTzs7T0FDZ0J5ekQ7T0FBTkM7T0FBTnVUO09BQUxyOUM7TUFDWDtrQkFEV0Esc0JBQUtxOUM7cUJBN0dkMzdDLEtBNkdvQm9vQyxNQUFNRDs7O01BSVdueUIsUUFQbEN0aEM7TUFLa0I2ekQsUUFFdkJ4eUI7TUFGaUJ5eUIsUUFFakJ6eUI7TUFGV3VqQyxPQUVYdmpDO01BRk0xWCxNQUVOMFg7VUFBdUNDO01BRHZDLGVBRE0zWCxvQkFBS2k3QyxZQS9HVHQ1QyxLQStHZXdvQyxPQUFNRDtLQUdGO01BRHdDRSxRQUF0Qnp5QjtNQUFlMHlCLFFBQWYxeUI7TUFBV25CLEtBQVhtQjtNQUFPK25DLEtBQVAvbkM7TUFDbkMyeUIsaUJBQWlCLFdBVEQ0UCxhQU1kbDZDLEtBRXdDMC9DO0tBRTlDLFNBRElwVjtrQkFBQUE7O29CQUQwQ29WLG1CQUFJbHBDO29CQUFsRGtCLE1BakhFL1YsS0FpSG9EMG9DLE9BQU9EOztvQkFGdkRwcUMsb0JBQUtpN0M7b0JBL0dUdDVDLEtBK0dld29DLE9BQU1ELFFBRWdCdnlCO0tBS2hDLEdBQUEsNkJBUFV3eUIsT0FFcUNFO1VBSWhERSxpQkFOaUJMLE9BRXNDRTs7TUFPbEM7T0FBQSxPQXhIekJ6b0MsS0FpSG9EMG9DLE9BQU9EO09BSXZERyxpQkFySEo1b0MsS0ErR2V3b0MsT0FBTUQ7S0FXbEIsT0FBQSxXQWpCNEIwVixZQU10QjNFLE1BRXVDemtDO21CQUk1Qyt6Qjt1QkFOQXZxQyx5QkFBS2k3QyxNQUV1Q3prQyxPQUk1Qyt6QjtJQVU4RDtJQUVoQyxJQUFBLE9Bbkh0Q3NJLFFBMkZrQnBoRSxLQXdCTyxXQW5IekJvaEUsUUEyRmVyaEU7SUF3QmpCLE9BQUEsb0NBdkJJMC9CO0dBdUJ1RDtZQTBEM0QwSztJQUNFcDdCLFlBQ0V2SyxLQUNENHBFLDBCQUNBQyx1QkFDRHJwRTtJQUVKLEdBTE1SLFNBQVFDLE1BQVJELFFBQUFtYixRQUFRbGIsY0FBUmtiO2FBS0ZzNUMsZ0JBQWdCQyxNQUFLdjZELEdBQUVrYztLQUN6QjtNQUFJNHRELGNBUEYxNUQ7TUFRZ0IsUUE1ckJkK21DLE1BMHJCbUJuM0MsR0FBRWtjLE9BQ3JCNHREO01BQ1VyaUU7TUFBUCt5RDtNQUFIeDNEO01BQ0FrRCxNQUFJLFdBSFVxMEQsVUFFZHYzRCxHQUFVeUU7S0FFZCxLQUZPK3lELE9BR0csT0FGTnQwRDttQkFER3MwRCxVQUlNcVEsbUJBQUxqN0M7S0FBYyxPQTN5QnRCeXNDLE1Bd3lCSW4yRCxLQUdJMHBCLEtBQUtpN0MsTUFMVGY7SUFLOEM7SUFFcEQsZ0JBYk05b0Q7S0FrQkk7TUFBUjtNQWxDNEMyNEM7UUFrQ3BDOztVQWpCTDhWO1VBRURwcEU7K0IsT0FFQWkwRDtNQXBCQW41QjtpQkFBS3U0QjtTQUNQLEtBRE9BLFFBRU87YUFDUTcwRCxJQUhmNjBELFdBR1kxNUQsSUFIWjA1RCxXQUdTbnJELElBSFRtckQsV0FHTWxxQyxJQUhOa3FDO1NBR3FCLGVBQWZscUMsR0FBR2poQixJQTFLVmlyRCxXQTBLYXg1RCxHQUFHNkU7UUFBdUQ7S0FFL0UsR0FZSzZxRTtNQVRXO09BMUphNy9DLFFBbUt4QjYvQztPQW5LNEJyNEUsWUFnSzdCK1k7T0EvSldqSyxNQWdKK0J3ekQ7T0FoSjdCSjtNQUNiO2lCQURXcHpELHNCQXNKWHUwRCxTQXRKYW5CO2dCQUFGcHpEO1FBR1csSUFBWGlvRSxNQUhBam9FLFFBR0h3MEQsTUFIR3gwRCxRQUFBQyxhQUdIdTBELEtBQUd5VDtRQUhBam9FLE1BQUFDOzs7WUFLSHFtQixNQUxHdG1CLFFBSUF5MEQsTUFKQXowRDtRQUlpQixPQUFBLFdBTEM5TyxXQUtsQnVqRSxLQUxjL3FDO1NBQ2QxcEIsTUFLSHNtQjs7U0FBeUI7VUFMdEJpZCxNQUFBdmpDO1VBS0d3cEUsTUFMSHhwRTtVQUtBMDBELE1BTEExMEQ7VUFBRTIwRCxVQUtGRCxLQUFHOFUsS0FBTmxqRCxLQUxLOHNDO1NBQUZwekQsTUFBQXVqQztTQUFFNnZCLE1BQUF1Qjs7Ozs7O1VBc0piSixTQTVLSWxCLFdBc0tzQ0c7S0FXOUMsT0FBQSw4QkFMSWUsUUFMQXY1Qjs7SUE4Qk07S0FBUjtLQTdDNEM3NkI7T0E2Q3BDOztTQWJMb3BFO1NBQ0RycEU7OEIsT0FFQWkwRDthQWxDQWg3QixLQUFLbzZCO0tBQ1AsS0FET0EsUUFFTztTQUNRNzBELElBSGY2MEQsV0FHWTE1RCxJQUhaMDVELFdBR1NuckQsSUFIVG1yRCxXQUdNbHFDLElBSE5rcUM7S0FHcUIsZUFBZmxxQyxHQUFHamhCLElBbktWZ2pCLEtBbUthdnhCLEdBQUc2RTtJQUFpRDtJQUV6RSxHQXlCSzRxRTtLQXRCVztNQXZKYTcvQyxNQTZLeEI2L0M7TUE3SzRCcDVFLFVBMks3QitaO01BMUtXcFEsSUE2SStCc0c7TUE3STdCekI7S0FDYjtnQkFEVzdFLG9CQW1KWE4sT0FuSmFtRjtlQUFGN0U7T0FHVyxJQUFYOHJDLElBSEE5ckMsTUFHSHVPLElBSEd2TyxNQUFBa0csYUFHSHFJLEdBQUd1OUI7T0FIQTlyQyxJQUFBa0c7OztXQUFBbEQsSUFBQWhELE1BQUF5SCxJQUFBekgsTUFJQTBnQyxNQUpBMWdDO09BSWlCLFFBQUEsV0FMQzNKLFNBS2xCcXFDLEtBTGM5UTtRQU1RLElBQWhCNlosTUFMTnpwQyxNQUtHK3FFLE1BTEgvcUUsTUFLQXk2RCxNQUxBejZELE1BQUUwZixVQUtGKzZDLEtBQUdzUSxLQUFHdGhDLEtBTEo1a0M7UUFBRjdFLElBQUFnRDtRQUFFNkIsSUFBQTZhOzs7UUFBRjFmLElBQUF5SDs7Ozs7U0FtSlgvSCxPQXZKQStpRSxRQWlKMENuOEQ7SUFXOUMsT0FBQSw4QkFMSTVHLE1BTEE0L0I7R0FnRGlFO1lBR25Fcm5DLFVBQVE2eEUsYUFBWThGLGNBQWE3OUMsTUFBR0Q7SUFDdEMsSUE1S2tCd3BDLE9BMUJkbUgsUUFxTWtDM3dDLE9BM0t2QnlwQyxPQTFCWGtILFFBcU0rQjF3QyxPQTNLcEIzd0IsS0FBQW02RCxNQUFHbDZELEtBQUFpNkQ7SUFDZDtVQURXbDZELFdBQUdDO1VBQUFBLElBSUY7S0FFRjtNQURpQzgyQixLQUw3QjkyQjtNQUt5QnVjLEtBTHpCdmM7TUFLcUJ3dUUsS0FMckJ4dUU7TUFLaUIra0MsS0FMakIva0M7TUFLTTYyQixLQUxUOTJCO01BS0t1YyxLQUxMdmM7TUFLQzB1RSxLQUxEMXVFO01BS0hpbEMsS0FMR2psQztNQU1Mb08sSUFBSSxXQXFLSnM2RCxhQXRLRXpqQyxJQUF1QkQ7S0FFN0IsU0FESTUyQixHQUVDLE9BRkRBO0tBSU0sSUFBSmdULE1BQUksV0FpS01vdEQsY0F0S05FLElBQXVCRDtLQU0vQixTQURJcnRELEtBRUMsT0FGREE7S0FHSSxHQUFBLDZCQVJJN0UsSUFBdUJDLEtBTDVCeGMsS0FLUzgyQixJQUxONzJCLEtBSzZCODJCO1VBVWhCLElBZmJoZCxPQXhDVm9XLEtBNkNtQzNULElBQUl1YSxLQUxoQ2pkLE9BeENQcVcsS0E2Q1k1VCxJQUFJdWEsS0FMVDkyQixLQUFBOFosTUFBRzdaLEtBQUE4Wjs7R0E0S3VEO1lBR3ZFampCLFFBQU00eEUsYUFBWThGLGNBQWE3OUMsTUFBR0Q7SUFDcEMsSUEzSmtCd3BDLE9BL0NkbUgsUUF5TWdDM3dDLE9BMUpyQnlwQyxPQS9DWGtILFFBeU02QjF3QyxPQTFKbEIzd0IsS0FBQW02RCxNQUFHbDZELEtBQUFpNkQ7SUFDZDtRQURXbDZEO1NBQUdDOztRQUk2QjgyQixLQUo3QjkyQjtRQUl5QnVjLEtBSnpCdmM7UUFJcUJ3dUUsS0FKckJ4dUU7UUFJaUIra0MsS0FKakIva0M7UUFJTTYyQixLQUpUOTJCO1FBSUt1YyxLQUpMdmM7UUFJQzB1RSxLQUpEMXVFO1FBSUhpbEMsS0FKR2psQztxQkFLVCxXQXFKRTBvRSxhQXRKSXpqQyxJQUF1QkQ7O1FBRTFCLFdBQUEsV0FvSld3cEMsY0F0SkpFLElBQXVCRDtRQUU5QjtTQUNHLEdBQUEsNkJBSFFseUQsSUFBdUJDLEtBSjVCeGMsS0FJUzgyQixJQUpONzJCLEtBSTZCODJCO1NBR3FCLElBUGxEaGQsT0E3RFZvVyxLQWlFbUMzVCxJQUFJdWEsS0FKaENqZCxPQTdEUHFXLEtBaUVZNVQsSUFBSXVhO1NBSlQ5MkIsS0FBQThaO1NBQUc3WixLQUFBOFo7Ozs7Ozs7T0FNVDs7O2VBTlM5WixJQUVBO0tBQ087O0dBd0o4QztZQUdyRTBoQixNQUFNM2hCLElBQUdDLElBQUlwQixHQUFHNnBFO0lBSWhCLFdBak5FckgsUUE2TU9waEU7SUFNTixPQWpKRDhoQjthQTJJYzJtRDthQTdNZHJILFFBNk1JcmhFOzs7c0JBTUd3dUIsS0FBS2k3QyxhQUFXLE9BQUEsV0FOWjVxRSxHQU1KMnZCLEtBQUtpN0MsTUFBdUI7R0FBQztZQUd0Q2tGLFFBQU0zdUUsSUFBR0MsSUFBSTNCLE1BQU1PLEdBQUc2cEU7SUFDaUIsV0F2TnJDckgsUUFzTk9waEU7SUFDWCxPQXJKSThoQixNQW9Kb0IybUQsYUF0TnBCckgsUUFzTklyaEUsV0FBTzFCLE1BQU1PO0dBQzhDO1lBS2pFK3ZFLG9CQUFvQjV1RSxJQUFHQyxJQUFJeW9FLGFBQWEwRixZQUFZOXZFLE1BQU1PO0lBTTVELFNBQUlrd0IsSUFBSTNYLEtBQUlnWCxHQUFFamhCO0tBQUksT0FBTSxXQU5vQ3RPLEdBTXBEdVksU0FBSWdYLGtCQUFFamhCO0lBQXVCO0lBQ3JDLFNBQUkyaEIsT0FBTzFYLEtBQUlnWCxHQUFFamhCO0tBQUksT0FBTSxXQVBpQ3RPLEdBT2pEdVksU0FBSWdYLGtCQUFFamhCO0lBQXNCO2FBQ25DMGhFLE1BQU16M0QsS0FBSWdYLEdBQUVrUixLQUFFbnlCO0tBQUssT0FBRyxXQVJnQmloRSxZQVExQjl1QyxLQUFFbnlCO2VBQVJpSztlQUFvRCxXQVJGdlksR0FRbER1WSxTQUFJZ1gsdUJBQUVrUixLQUFFbnlCO0lBQWlFO2FBRzNFSCxLQUFLbEksS0FBRWxHLEdBQUdrd0U7S0FDaEIsSUFEVzl1RSxLQUFBOEUsS0FBRTdFLEtBQUFyQixHQUFHTixPQUFBd3dFO0tBQ2hCO01BQUcsR0FBQSw2QkFEUTl1RSxJQUFFQyxLQUVSLE9BRlczQjtnQkFBTDBCO09BTW9CLE9BOVYzQnJCO2dCQXdWU3NCO2dCQUFHM0I7eUJBTXFCa3dCLEtBQUtpN0MsTUFBS3J5RCxLQUFPLE9BWHBEMlgsSUFXNkMzWCxLQUFWb1gsS0FBS2k3QyxNQUE0Qjs7O2dCQU4zRHpwRTtZQVNFbU4sSUFURm5OLE9BU0RvdUIsSUFUQ3B1QjtrQkFBRUM7aUJBQUFBO1NBVUYsSUFEZ0JxL0IsTUFUZHIvQixPQVNVazZDLE1BVFZsNkMsT0FZTi9SLElBRkksV0FyQmdCdzZFLGFBb0JqQnQ2QyxHQUFhK3JCO1NBRVQsU0FDUGpzRCxHQURnQixPQWRyQjJnRixNQUdjdndFLE1BU044dkIsR0FBR2poQixHQUFjbXlCO1NBR2IsUUFBUHB4QztVQUlVLElBQU42Z0YsUUFyQlRoZ0QsSUFLY3p3QixNQVNPNjdDLEtBQUk3YTtVQVFwQixPQXJCTHhRLE9Bb0JTaWdELE9BUEQzZ0QsR0FBR2poQjs7U0FJSSxJQUFONmhFLFFBakJUbGdELE9BSWN4d0IsTUFTTjh2QixHQUFHamhCO1NBS04sT0FuQkw0aEIsSUFrQlNpZ0QsT0FKWTcwQixLQUFJN2E7Ozs7WUFUaEJqNUIsSUFBQXJHLE9Ba0JLcTVELE1BbEJMcjVELE9Ba0JFazFELE1BbEJGbDFELE9Ba0JENEIsSUFsQkM1QjtrQkFBRUM7aUJBQUFBO2FBa0JtQm9yQixNQWxCbkJwckIsT0FBQW9vQyxNQUFBcG9DLE9Ba0IyQnM1RCxNQWxCM0J0NUQsT0FrQnVCbTFELE1BbEJ2Qm4xRDtTQWtCMkMsU0FBQSxXQTdCN0J5b0UsYUE2QmR4VCxLQUF1QkU7VUFDdEIsSUFBTjZaLFFBbkJGamlFLEtBa0JJcEwsR0FBc0J5cEIsS0FsQmhCL3NCLE9BQUE0d0UsUUFIZEwsTUFzQk1JLE9BREsvWixLQUFHbUUsS0FBd0JFO1VBbEI3QnY1RCxLQUFBcUc7VUFBRXBHLEtBQUFvb0M7VUFBRy9wQyxPQUFBNHdFOzs7OztPQS9HaEI7UUFESXBTO21CQUFJMWxELEtBQUlnWCxHQUFFamhCO1dBQUksT0FBTSxXQXFHa0N0TyxHQXJHbER1WSxTQUFJZ1gsa0JBQUVqaEI7VUFBdUI7UUFDakM0dkQ7bUJBQU8zbEQsS0FBSWdYLEdBQUVqaEI7V0FBSSxPQUFNLFdBb0crQnRPLEdBcEcvQ3VZLFNBQUlnWCxrQkFBRWpoQjtVQUFzQjtRQUNyQmdpRSxVQXpIaEI5TixRQXVPV3BoRTtRQTlHQW12RSxTQXpIWC9OLFFBdU9TcmhFOzs7WUE5R0VrbUMsT0FBQWtwQyxRQUFLanBDLFFBQUFncEMsU0FBTS8zRCxNQThHUjlZO1FBN0dkO2NBRFc0bkM7Y0FBS0M7U0FLTztVQUR3Q3l5QixRQUovQ3p5QjtVQUl3QzB5QixRQUp4QzF5QjtVQUlvQ25CLEtBSnBDbUI7VUFJZ0MrbkMsS0FKaEMvbkM7VUFJUXV5QixRQUpieHlCO1VBSU15eUIsUUFKTnp5QjtVQUlFakIsS0FKRmlCO1VBSUY2aUMsS0FKRTdpQztVQUtMNHlCLGlCQUFpQixXQThGRTRQLGFBL0ZoQkssSUFBdUNtRjtTQUU5QyxTQURJcFY7VUFHVztXQVJLaHdDO2FBUUwsV0EyRnFCc2xELFlBL0Z6Qm5wQyxJQUF1Q0Q7Z0JBSjlCNXRCO2dCQVEwQixXQTJGUXZZLEdBbkdsQ3VZLFNBSWIyeEQsd0JBQUk5akMsSUFBdUNEO1VBSzdDLEdBQUEsNkJBTFUyekIsT0FBdUNFLFFBSjdDM3lCLE9BSWF3eUIsT0FKUnZ5QixRQUkrQ3l5QixPQUp6Q3hoRCxNQUFBMFI7O1dBV1csSUFYakIyL0MsVUF2SVp0NEMsS0EySW9EMG9DLE9BQU9ELFFBSnBEbnhCLFNBdklQdFgsS0EySWF3b0MsT0FBT0Q7V0FKYnh5QixPQUFBdUI7V0FBS3RCLFFBQUFzaUM7V0FBTXJ4RCxNQUFBMFI7OztzQkFLaEJnd0M7VUFZUSxJQWpCUS92QyxRQUZwQit6QyxNQUVvQjFsRCxLQUkwQjgyRCxJQUFJbHBDLEtBSnBDcXFDLFVBdklabC9DLEtBMklvRDBvQyxPQUFPRDtVQUovQ3p5QixRQUFBa3BDO1VBQU1qNEQsTUFBQTJSOzs7VUFjUixJQWRRcWpDLFFBRHBCMlEsU0FDb0IzbEQsS0FJYjJ4RCxJQUFJOWpDLEtBSkZ1RCxTQXZJUHJZLEtBMklhd29DLE9BQU9EO1VBSmJ4eUIsT0FBQXNDO1VBQVdweEIsTUFBQWcxQzs7O1FBRVAsT0FoRVhwekM7aUJBOERrQjVCOzBCQUVzQm9YLEtBQUtpN0MsTUFBS3J5RCxLQUFPLE9BSjNEMGxELE1BSW9EMWxELEtBQVZvWCxLQUFLaTdDLE1BQTRCO2lCQUY3RHRqQzs7T0FHRCxPQWpFWG50QjtnQkE4RGtCNUI7eUJBR3NCb1gsS0FBS2k3QyxNQUFLcnlELEtBQU8sT0FKM0QybEQsU0FJb0QzbEQsS0FBVm9YLEtBQUtpN0MsTUFBK0I7Z0JBSHJFdmpDOztNQXNIa0IsT0FoVzNCdm5DO2VBd1ZPcUI7ZUFBSzFCO3dCQVFxQmt3QixLQUFLaTdDLE1BQUtyeUQsS0FBTyxPQVpwRDBYLE9BWTZDMVgsS0FBVm9YLEtBQUtpN0MsTUFBK0I7O0lBaUJHO0lBRTlFLE9BM0JRejhELEtBWGNoTixJQUFHQyxJQUE2QjNCO0dBc0N2QztZQUdUb0M7SUFBUyw4QkFDSjt1QkFDQztJQUN5QjtLQUFwQjJGO0tBQVR6RTtLQUE2QixPQUgvQmxCLE9BR1cyRjtLQUFTLE9BSHBCM0YsT0FHRWtCO0tBQWtCLE9BQUE7SUFBQSxPQUFBO0dBQXVCO1lBVS9DMHRFLEtBQUsxd0U7SUFBSSxPQTFXTEU7YUEwV0NGLGVBQXdCNHZCLFlBQVl0ckIsTUFBUSxXQUFwQnNyQixLQUFZdHJCLE1BQW1CO0dBQVk7WUFDeEV1bUUsS0FBSzdxRTtJQUFJLE9BM1dMRTthQTJXQ0Ysc0JBQStCNnFFLE1BQUt2bUUsTUFBUSxXQUFidW1FLE1BQUt2bUUsTUFBb0I7R0FBWTs7YUFXdkVxc0UsaUJBQWlCQyxVQUFVbHhFLE1BQU1PLEdBQUc2cEU7S0FDdEMsT0FBb0M7O2NBRGpCOEc7a0JBNnZCbkJqWTs7ZUE1dkJvQztnQkFBMkJrUztnQkFBTGo3QztnQkFBVDl0QjtnQkFBUHNmO2dCQUVoQyxRQXp1Qk5wSSxLQXV1QnNDb0ksT0FBZ0J3TyxLQURwQms2Qzs7b0JBSzNCNThDLGlCQUhMMmpELFlBR0szakQ7O29CQUhMMmpELFlBRnVCbnhFO2VBT2hCLElBQVB3dEUsU0FBTyxXQVBzQmp0RSxHQUU3QjR3RSxXQUR5RGhHO2VBTzdELE9BbDZCRjFqQyxJQTI1QjBDL2xCLE9BQU90ZixRQUFTOHRCLEtBTXBEczlDLFFBUGdDcEQ7Y0FRTTtJQUFBO2FBRzFDZ0gsbUJBQW1CRixVQUFVM3dFLEdBQUc2cEU7S0FDbEMsT0FBb0M7O2NBRGY4RztrQkFrdkJyQmpZOztlQWp2Qm9DO2dCQUEyQmtTO2dCQUFMajdDO2dCQUFUOXRCO2dCQUFQc2Y7Z0JBRWhDLFFBcHZCTnBJLEtBa3ZCc0NvSSxPQUFnQndPLEtBRHhCazZDOztvQkFLdkI1OEMsaUJBSEw2akQsV0FHYSxXQUxZOXdFLEdBS3BCaXRCLE1BSm9EMjlDOztvQkFDekRrRyxXQUR5RGxHO2VBTTdELE9BNTZCRjFqQyxJQXM2QjBDL2xCLE9BQU90ZixRQUFTOHRCLEtBQ3BEbWhELFVBRjRCakg7Y0FPbUI7SUFBQTthQUduRGtILFlBQVlKLFVBQVU5RztLQUN4QixPQUFZO2NBanFDZDc4RDt1QkFpcUNtQnhGO2VBRWI7Z0JBREVwSDtrQkFDRjs7b0JBSFV1d0U7d0JBd3VCZGpZOztxQkFydUJ3QztzQkFBdUJrUztzQkFBTGo3QztzQkFBVDl0QjtzQkFBSDlCO3NCQUNwQ3dZLE1BbjdCVjJ1QixJQWs3QjhDbm5DLEdBQUc4QixRQUFTOHRCLEtBQUtpN0MsTUFIdkNmO3NCQUlUMXdELFdBQUxaOzRCQUR1QzFXLFdBQ2xDc1g7K0JBQ3lCLFdBSnZCM1Isb0JBRXlDbW9COytCQUNoRHBYO29CQUM0RDtlQUVwRSxrQkFMSW5ZO2NBS0c7SUFBQzthQUdSNHdFLHFCQUFxQkwsVUFBVXhnRTtLQUMzQixZQVhKNGdFLFlBVXFCSixVQUFVeGdFOytCQUUzQjlnQixjQUFLLFdBQUxBO0tBRUo7TUFEZXNnQztNQUNmLE9BSitCeGY7TUFLaEIsT0FBQTtNQUFiLE9BQUE7S0FERixPQUFBLDBDQURld2Y7SUFJTzthQUd0QnNoRCxnQkFBZ0JOLFVBQVV4Z0U7S0FDdEIsWUFyQko0Z0UsWUFvQmdCSixVQUFVeGdFOytCQUV0QjlnQixjQUFLLE9BQUxBO0tBRXNCO01BRFhzZ0M7YUFIV3hmO01BSUEsT0FBQTtNQUFiLE9BQUE7TUFBYixPQUFBLHVDQURld2Y7S0FDZixPQUFBO0lBQ2M7SUEvQ2dCO1lBQzlCK2dEO1lBV0FHO1lBVUFFO1lBVUFDO1lBVUFDOzs7SUFjRXRROytCQUpBOXVELE1BSUE4dUQ7SUFHSnVRO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBS0FDLGtCQUFrQlosVUFBVTd3RSxNQUFNK3BFO0lBQ3hCO0tBQVJwNkMsUUFBUSxXQURrQjN2QixNQUFWNndFLHNCQUN1QjV0RSxHQUFFMVQsR0FBSyxXQUFMQSxHQUFGMFQsR0FBYTtJQUN4RCxPQVhFbXVFO2FBVUV6aEQsbUJBQ2lDMXNCLEdBQUUxVCxHQUFLLFdBQUxBLEdBQUYwVCxHQUFhLEdBRmQ4bUU7R0FFNEI7WUFHOUQySCxlQUFlL2hELE9BQU9vNkM7SUFDeEIsT0FORTBILGtCQUtlOWhELHNCQUFPbzZDO0dBQzRCOztJQVE5QzRIO2tDQUpBckksUUFJQXFJO0lBR0pDO0lBQ0FDO0lBQ0E1cUM7SUFDQTZxQztJQUNBQzs7Ozs7Ozs7OztZQUVBQyxrQkFBa0I5cUMsVUFBVTZpQztJQUM5QixPQXhCRTBILGtCQXVCa0J2cUMsNEJBQVU2aUM7R0FDNkI7WUFHekR2bkUsUUFBUXZDLEdBQUdDO0lBQ2IsT0FBWTthQTF1Q1pnTjtzQkEwdUNpQnhGO2NBeGlCWHRIO2dCQXVpQklIO3lCQUVPNnFFO2lCQUFlLGVBQUEsV0FGbkI1cUUsR0FFSTRxRTsrQkFBNkIsV0FEN0JwakU7Z0JBQzJDO2NBQTFEO2FBQ0k7R0FBQztZQUdMOGMsU0FBU3ZrQixHQUFHQztJQUNkLE9BQVk7YUFodkNaZ047c0JBZ3ZDaUJ4RjtjQXBpQlhySDtnQkFtaUJLSjt5QkFFUTR2QixLQUFLaTdDO2lCQUFlLGVBQUEsV0FGekI1cUUsR0FFSzJ2QixLQUFLaTdDOytCQUFtQyxXQUQxQ3BqRTtnQkFDd0Q7Y0FBdkU7YUFDSTtHQUFDO1lBR0x2RixPQUFPbEMsR0FBR0M7SUFDWixPQUFZO2FBdHZDWmdOO3NCQXN2Q2lCeEY7Y0FwakJYdEg7Z0JBbWpCR0g7eUJBRVE2cUU7aUJBQVcsV0FBQSxXQUZoQjVxRSxHQUVLNHFFO2lCQUFXLGNBQVksV0FEdkJwakU7Z0JBQ29DO2NBQW5EO2FBQ0s7R0FBQztZQUdOK2MsUUFBUXhrQixHQUFHQztJQUNiLE9BQVk7YUE1dkNaZ047c0JBNHZDaUJ4RjtjQWhqQlhySDtnQkEraUJJSjt5QkFFUzR2QixLQUFLaTdDO2lCQUFXLFdBQUEsV0FGdEI1cUUsR0FFTTJ2QixLQUFLaTdDO2lCQUFXLGNBQWtCLFdBRHBDcGpFO2dCQUNpRDtjQUFoRTthQUNLO0dBQUM7WUFHTjJRLE1BQU1wWSxHQUFHQztJQUNYLE9BdGdCTUY7YUFxZ0JFQzs7NkJBQ3VCNnFFLE1BQUtyeUQ7Y0FBTyxPQUFHLFdBRG5DdlksR0FDb0I0cUU7d0JBQTJCLDRCQUF0QnJ5RDt3QkFBQUE7YUFBc0M7R0FBQztZQUd6RStVLE9BQU92dEIsR0FBR0M7SUFDWixPQTFnQk1GO2FBeWdCR0M7O3NCQUNlNHZCLEtBQUtpN0MsTUFBS3J5RDtjQUFPLE9BQUcsV0FEaEN2WSxHQUNZMnZCLEtBQUtpN0M7d0JBQWlDLDRCQUE1QnJ5RDt3QkFBQUE7YUFBNEM7R0FBQztZQUc3RXc1RCxTQUFXbnNFLEtBQXlCN0Y7SUFDdEMsR0FEYTZGLFNBQVlDLE1BQVpELFFBQUFvc0UsWUFBWW5zRSxjQUFabXNFO0lBQ2Isb0JBRGFBO2NBcGZQL3hFO2VBb2ZnQ0YsZUFFVTR2QixLQUFLaTdDLE1BQUt2N0UsR0FBSyxlQUFmc2dDLEtBQUtpN0MsT0FBS3Y3RSxHQUFxQjtjQS9nQnpFeVE7ZUE2Z0JnQ0MsZUFHSTR2QixLQUFLaTdDLE1BQUt2N0UsR0FBSyxlQUFmc2dDLEtBQUtpN0MsT0FBS3Y3RSxHQUFxQjtHQUFDO1lBR3hFeTdCLE1BQU0zcEIsSUFBR0MsSUFBSXBCLEdBQUc2cEU7SUFDbEI7S0FBdUUsT0E5SmpFaG9FLE9BNkpLVDtLQUNnRCxPQTlKckRTLE9BNkpFVjtLQUNrRCxPQUFBO0tBQXREbXFELE9BQU87S0FDUHR5RDtJQXZORjhwQjtNQXFOTTNoQjtNQUFHQztlQUd1QnV1QixLQUFVODVDO09BQ3BDLFlBQUEsV0FKT3pwRSxHQUdtQjJ2QixLQUFVODVDO21CQUtoQztXQUhIMTVDO09BQ0wsbUNBTEF1N0IsTUFDQXR5RCxVQUM4QjIyQixLQUV6Qkk7T0FIRCxPQUFBLDZCQUFKLzJCO01BTVU7TUFSSTZ3RTtRQVNkM3FFLE1BUEFsRztJQVFKLFNBQUk4WSxJQUFJOVksR0FBSSxPQUFBLG1DQVRSc3lELE1BU0l0eUQsR0FBNEI7SUFDekIsSUFBUDBnRSxPQXp0Q0Z2RCwrQkF1dENFajNELEtBQ0E0UztJQUVKLFdBREk0bkQsTUFGQXg2RDtHQUdLO1lBSUwreUU7SUFBa0JDLGNBQWFDLFNBQVFDLFNBQVM1MUMsTUFBTTlrQixTQUFTbXlEO0lBQ2pFLE9BcGlCSS9wRTthQW1pQnFDc3lFO2lCQUFSRCxTQUFiRDtzQkFDZ0N2aUQsS0FBVWk3QztjQUFoQixJQUEwQi9vRSxtQkFBSDlCO2NBQ25FLE9BbnBCRnV1RTt1QkFrcEJxRXZ1RTt1QkFBakI0dkI7O3dCQUNiLG1CQUR1Qmk3Qzs0QkFHbkRxQzt3QkFBUSxPQUFBLFdBSitCendDLE1BQU05a0IsU0FDSmlZLEtBR3pDczlDLFFBSG1EckM7dUJBR2Q7dUJBSHdCL29FO3VCQURQZ29FO2FBSWhCO0dBQUE7R0FFbkQsU0FBSXJ0QyxLQUFLeDhCLEdBQUcydkIsS0FBSXRnQyxHQUFFQyxHQUFJLE9BQUEsV0FBYjBRLEdBQUcydkIsS0FBSXRnQyxHQUFFQyxHQUFjO0dBQ2hDLFNBQUlpUixLQUFLUCxHQUFHMnZCLEtBQUl0Z0MsR0FBRUMsR0FBSSxPQUFBLFdBQWIwUSxHQUFHMnZCLEtBQU1yZ0MsR0FBRkQsR0FBZ0I7WUFSOUJnakYsYUFTRWx4RSxJQUFHQyxJQUFJa3hFLFNBQVNDLFNBQVM3NkQsU0FBU215RDtJQUNwQyxPQURrQjBJLFdBQVREO2NBUlBMLGtCQVFPSyxTQUFQbnhFLElBQUdDLElBRkhvN0IsTUFFeUI5a0IsU0FBU215RDtjQVJsQ29JLGtCQVFnQk0sU0FBYm54RSxJQUFIRCxJQURBWixNQUN5Qm1YLFNBQVNteUQ7R0FHaUM7WUFZbkUySSxVQUVHQyxRQUNBbGpELEdBQ0FqaEIsR0FHTCxPQUxLbWtFLGlCQUNBbGpELEdBQ0FqaEIsUUFLaUI7WUF1RHRCb2tFLFlBSGN6c0UsS0FBRWlvQyxLQUFJb04sS0FBR3V1QjtJQUFjLElBckNqQzlwRSxJQXFDVWtHLEtBckNXMHNFLGtCQUFhQyxlQUFVQztJQUM5QztlQURFOXlFO01BRVMsT0ExQlh5eUUsVUF3QnVCRyxjQUFhQyxXQUFVQztjQUE1Qzl5RTtLQWFRO01BYlJ5SCxJQUFBekg7TUFBNEMreUUsZ0JBQTVDL3lFO01BQWtDZ3pFLGNBQWxDaHpFO01BQUFnRCxJQUFBaEQ7TUFhSXdpQixNQUFJLFdBd0JXc25ELGFBckNla0osYUFxQ2xCejNCO0tBdkJoQixTQURJLzRCOzRCQXdCUTJyQjtnQkE5c0NoQnA2QjtrQkF5cUNJL1E7a0JBeEJGeXZFLFVBd0J1QkcsY0FBYUMsV0FBVUM7a0JBNTFCNUNoNkQsUUE0MUJBOVY7O21CQXFDWW1yQzswQkFyQ3NCNmtDLGFBQVVEO2tCQXpxQ2hEaC9EO29CQXlxQ0l0TTtvQkF4QkZnckUsVUF3QnVCRyxjQUFhQyxXQUFVQztvQkFuNEI1Q2w2RCxRQW00QkFuUjt1QkFxQ1kwbUMsbUJBQUFBO2FBeEJSM3JCO09BYkp4aUIsSUFBQWdEO09BQXFCNHZFO09BQWFDLFlBQUFHO09BQVVGLGNBQUFDOzs7TUFBNUMveUUsSUFBQXlIOzs7YUFhSSthO01BYkp4aUIsSUFBQWdEOztNQUFBaEQsSUFBQXlIO01BQXFCbXJFO01BQWFDLFlBQUFHO01BQVVGLGNBQUFDOzs7SUFJcEM7S0FERXhrRSxJQUhWdk87S0FHTXd2QixJQUhOeHZCO0tBSUl3UCxJQUFJLFdBaUNXczZELGFBbENidDZDLEdBa0NVK3JCO0tBaENoQjtvQkFnQ1lwTjt1QkFBQUEsTUFqQ1IzK0Isc0JBQUFBO3dCQWlDUTIrQixNQWpDUjMrQixvQkFBQUE7O3NCQURFZ2dCLEdBQUlqaEI7Y0EzQlpra0UsVUF3QnVCRyxjQUFhQyxXQUFVQztHQXFDNEI7WUFLeEVHLEtBQUtqekUsR0FBRXd2QixHQUFHczZDO0lBQ2hCLElBRFc1akUsTUFBQWxHO0lBQ1g7ZUFEV2tHLGtCQUVBO2NBRkFBO1VBR0hxMUMsTUFIR3IxQztNQUdVLGFBQUEsV0FITDRqRSxhQUdSdnVCLEtBSEsvckI7O0tBS0g7TUFEUS9uQixJQUpQdkI7TUFJQW93RCxNQUpBcHdEO01BSUhsRCxJQUpHa0Q7TUFLTHNKLElBQUksV0FMTXM2RCxhQUlMeFQsS0FKRTltQztLQU1YLFNBREloZ0IsR0FFQyxXQTdRRDFOLE9BMFFFa0I7YUFDRndNO01BS1ksV0FWWnlqRSxLQUlZeHJFLEdBSkwrbkIsR0FBR3M2QztNQVU2QixPQUFBOzs7d0JBQUttSjtnQkFBUTtpQkFBVyxPQWhSL0RueEUsT0EwUUVrQjtpQkFNa0QsT0FBQSw0QkFBUml3RTtnQkFBbUIsT0FBQTtlQUFROztLQVZsRS9zRSxNQUlIbEQ7O0dBTXNFO1lBS3hFNGUsSUFBS3N4RDs7O3FDQUNBOztVQUNBM2tFLGdCQUFIaWhCO21CQUZHMGpEO3dCQUVIMWpELEdBQUdqaEI7aUJBSVAsNkJBTk8ya0U7O0tBU0Y7TUFEUXpyRTtNQUFIaTVCO01BQUg2YTtNQUFIdjRDO01BRUgrNUIsT0FWQ25iLElBQUtzeEQsZUFRSGx3RTtRQUVIKzVCLE1BQWtCLE9BQWxCQTtjQVZNbTJDLGtCQWFELGVBTEMzM0IsS0FBRzdhO0tBT1AsNkJBZkl3eUM7ZUFRTXpyRTs7O1lBV2Z5M0QsTUFBSWwvRCxHQUFFd1MsR0FBSSxPQW5CTm9QLFFBbUJFcFAsSUFBRnhTLEdBQW9CO1lBR3BCNDZCLHNCQUFzQjU2QixHQUFHQztJQUMvQixJQUQ0QmlHLE1BQUFsRztJQUM1QjtlQUQ0QmtHLGtCQUVqQjtjQUZpQkE7VUFHakJxSSxJQUhpQnJJLFFBR3BCc3BCLElBSG9CdHBCO01BR1IsT0FBQSxXQUhXakcsR0FHdkJ1dkIsR0FBR2poQixhQUFIaWhCLEdBQUdqaEI7O1NBSGlCOUcsSUFBQXZCLFFBSWR3NkIsTUFKY3g2QixRQUlqQnExQyxNQUppQnIxQyxRQUlwQmxELElBSm9Ca0Q7S0FLdkIsR0FBQSxXQUwwQmpHLEdBSXBCczdDLEtBQUc3YTtNQUdKLElBRUpweEMsSUFUQXNyQyxzQkFJRTUzQixHQUp1Qi9DO2FBU3pCM1EsSUFBQUEsWUFMS2lzRCxLQUFHN2E7O0tBSmN4NkIsTUFBQXVCOztHQVVLO1lBRzNCMnpCLHFCQUFxQnA3QixHQUFHQztJQUM5QixJQUQyQmlHLE1BQUFsRztJQUMzQjtlQUQyQmtHLGtCQUVoQjtjQUZnQkE7VUFHaEJxSSxJQUhnQnJJLFFBR25Cc3BCLElBSG1CdHBCO01BR1AsT0FBQSxXQUhVakcsR0FHdEJ1dkIsR0FBR2poQixhQUFIaWhCLEdBQUdqaEI7O1NBQ005RyxJQUpVdkIsUUFJYnc2QixNQUpheDZCLFFBSWhCcTFDLE1BSmdCcjFDLFFBQUFsRCxJQUFBa0Q7S0FLdEIsR0FBQSxXQUx5QmpHLEdBSW5CczdDLEtBQUc3YTtNQUdKLElBRUpweEMsSUFUQThyQyxxQkFJVzN6QixHQUpheEg7YUFTeEIzUSxJQUFBQSxZQUxLaXNELEtBQUc3YTs7S0FKYXg2QixNQUFBbEQ7O0dBVUs7WUFHOUJxNEIsY0FBY3I3QixHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0lBQy9CLGlCQUQyQitzQjt5QkFBQUE7O2tCQUFBQTtpQkExQnJCVjtrQkEwQlU1NkI7MkJBZW1CNHZCLEtBQUtpN0M7bUJBQVEsWUFBQSxXQWY3QngwRSxTQWVnQnU1QixLQUFLaTdDLE1BZlR0OEQ7a0JBZTBDO2lCQTVCbkU2c0I7a0JBYVVwN0I7MkJBR2tCNHZCLEtBQUtpN0M7bUJBQVEsT0FBQSxXQUg1QngwRSxTQUdldTVCLEtBQUtpN0MsTUFIUnQ4RDtrQkFHd0M7O2tCQUg1QytzQjtpQkFickJGO2tCQWFVcDdCOzJCQUtrQjR2QixLQUFLaTdDO21CQUFRLE9BQUEsV0FMNUJ4MEUsU0FLZXU1QixLQUFLaTdDLE1BTFJ0OEQ7a0JBS3lDO2lCQS9CbEVxc0I7a0JBMEJVNTZCOzJCQWlCbUI0dkIsS0FBS2k3QzttQkFBUSxXQUFBLFdBakI3QngwRSxTQWlCZ0J1NUIsS0FBS2k3QyxNQWpCVHQ4RDtrQkFpQnlDO3NCQWpCN0Mrc0I7S0FXbEI7TUFDSjYzQztRQXpCQy8zQztVQWFVcDdCO21CQVd5QjR2QixLQUFLaTdDO1dBQVEsT0FBQSxXQVhuQ3gwRSxTQVdzQnU1QixLQUFLaTdDLE1BWGZ0OEQ7VUFXZ0Q7UUFDMUU0a0U7a0JBQUFBLFNBQVd0SSxpQkFBTGo3QztNQUF3QixTQUFBLFdBWmhCdjVCLFNBWVJ1NUIsS0FBS2k3QyxNQVpldDhELElBWWdDLE9BQTFENGtFOztLQUNpQjs7SUFOYjtLQUNKQztPQWxDQ3g0QztTQTBCVTU2QjtrQkFPMEI0dkIsS0FBS2k3QztVQUFRLFlBQUEsV0FQcEN4MEUsU0FPdUJ1NUIsS0FBS2k3QyxNQVBoQnQ4RDtTQU9pRDtPQUMzRTZrRTttQkFBQUEsV0FBV2xHLHFCQUFMcjlDO0tBQXdCLFNBQUEsV0FSaEJ4NUIsU0FRUnc1QixPQUFLcTlDLFFBUmUzK0QsSUFRZ0MsT0FBMUQ2a0U7O0lBQ2lCO0dBUW1EO1lBR3ZFNzNDLHdCQUF3QnY3QixHQUFHdzdCLFlBQVdGO2FBQ3BDRyxRQUFTN0wsS0FBS2k3QztLQUNoQixvQkFBTSxXQUZxQnJ2QyxZQUNoQjVMLEtBQUtpN0M7SUFHQztJQUVuQixTQUFJbnZDLFNBQVU5TCxLQUFLaTdDLE1BQU8sV0FMdEJwdkMsUUFLVTdMLEtBQUtpN0MsTUFBK0I7SUFDbEQsb0JBUHdDdnZDO2NBakNsQ0YscUJBaUNvQnA3QixHQUN0Qnk3QjtjQS9DRWIsc0JBOENvQjU2QixHQU10QjA3QjtHQUdvRDtZQUt0RDIzQztJQUE4QnJ6RSxHQUFFc3pFLGFBQWFqOUUsU0FBU2s5RSxjQUFjQzthQUNsRUMsV0FBV3p6RSxHQUFFczdCLEtBQUlwZixPQUFPN2xCO0tBQ3BCLFlBcENOZ2xDLGNBbUNhcjdCLEdBQWEzSixTQUFYaWxDLEtBQUlwZjtpQkFHVDtTQURGdzNEO0tBQWEsZUFBYkE7SUFDTTtJQUVoQixVQU5rQ0osMEJBU25CO0lBSGYsU0FOa0NBO1NBUTNCcDNELFFBUjJCbzNEO0tBUWxCLE9BUFpHLFdBRDRCenpFLEdBQXNDd3pFLGNBUS9EdDNELE9BUndDN2xCOztRQU94Q3E5RSxVQVAyQko7SUFPbEIsT0FOWkcsV0FENEJ6ekUsR0FBd0J1ekUsY0FPakRHLFNBUHdDcjlFO0dBU2xCO1lBTTNCczlFO0lBQStCM3pFLEdBQUczSixTQUNiMG1CLGFBRG1DQztJQUV4RDs7T0FqQkFxMkQ7U0FlK0JyekUsR0FDVitjLGFBRGExbUI7Z0JBa0IxQjtJQVJSO0tBU0t1OUU7S0FUTDtPQXpCQVA7U0FlK0JyekUsR0FBeUJnZCxhQUF0QjNtQjtrQkFxQnZCO1FBQ0h3OUU7SUFBZSxlQUhsQkQsZUFHR0M7R0FBK0M7WUFRdkRDLFNBQVUxekUsT0FBTzBwRTtJQUNULElBQU50eEQsaUJBaVlGbWdEO0lBaFlGO01BRll2NEQ7ZUFFR3d2QixLQUFLaTdDO09BQ2xCO2dCQUZFcnlEO1FBRU8xVztRQUFMekI7UUFDQTh5RSxPQXp4Q0poc0MsSUF3eENJOW1DLEtBQUt5QixRQURJOHRCLEtBQUtpN0MsTUFGRGY7UUFJUjF3RCxXQUFMKzVEO09BQ21CLEdBRmRyeEUsV0FDQXNYLFlBQ2MsNEJBSnJCWixTQUFBQSxhQUNXb1g7T0FEWHBYLFNBR0UyNkQ7O01BR3VCO2dCQU56QjM2RDtnQkFRTSxrQkFSTkE7UUFTR29YO0lBQU8sd0JBQVBBO0dBQXlCO1lBRzlCbWtELGFBQWMzekUsT0FBUWdRO0lBQ2xCLFlBZEowakUsU0FhYzF6RSxPQUFRZ1E7OEJBRWxCN0IsY0FBSyxPQUFMQTtJQUVKO0tBRGVxaEI7S0FDZjtPQUFBOzs7OztTQURlQTtTQUhPeGY7SUFJdEIsT0FBQTtHQUNjO1lBR2Qyc0QsaUJBQWlCaVgsYUFBWUMsZUFBY2pwRSxNQUFPb0Y7SUFDcEQ7S0FBeUIsT0FBQSw2QkFETjRqRSxhQUFZQztLQUMzQnZrRCxRQUFRLG1DQURpQzFrQjtLQUV6QzgrRCxjQUZnRDE1RDtLQUc5QyxRQXZWSmloRSxTQXFWRTNoRCxPQUNBbzZDOzhCQUVFdjdELGNBQUssT0FBTEE7SUFJMkI7S0FIaEJpaEI7S0FHZ0I7T0FBQTs7d0I7d0I7S0FBM0Iwa0QsY0FBYyxtQ0FSeUJscEU7S0FTdkNtcEU7SUFDSjs7TUFURXprRDtNQU9Fd2tEOztPQUUrQjtRQUFjRTtRQUFSOUU7cUJBQ3BDLFdBVEh4RixhQUdhdDZDLEdBSzBCOC9DOztXQURyQzZFO1NBS0ssT0FBQTtvRUFKd0NDO1FBRDdDRDs7Ozs7O01BTTJCO0lBQy9CLE1BQUE7R0FBWTtZQUdacGxELFlBQVU0N0MsYUFBWTBKLGVBQWNyMEU7YUFDbENDLEVBQUcydkIsS0FBS2k3QyxNQUFLcnlEO0tBQU0sZUFBNkIsV0FENUI2N0QsZUFDWnhKO0tBQVcsbUJBQVksV0FEdkJGLGFBQ0wvNkMsY0FBVXBYO0lBQThEO0lBQy9FLFdBM3hCTXRZLFdBeXhCZ0NGLE1BQ2xDQztHQUNnQztZQUdsQ2dZLGVBQWVqWSxHQUFHOHBFLGFBQWFhO0lBQ2pDO0tBQTJCLE9BM3VCekIzMkQsY0EwdUJlaFUsb0JBQUc4cEU7S0FDVndLO0tBQU5DO0lBQ0QsR0FoNUNEeGdFLFNBKzRDUXVnRSxhQUVMLFdBRkRDO0lBR2tCLFdBVHBCeGxELFlBSytCNDdDLDRCQUN2QjJKO0lBR1ksT0FBQTtHQUFrRDtZQUd0RUUsU0FDRXB6RSxJQUNDbkI7UUFDaUQwcUUsd0JBQXpCYjtJQUVqQixPQUFBO2FBL2pEWjc4RDtzQkErakRtQks7Y0FBUDs7c0JBbjBCTnZOO3dCQSt6QkZxQjs0QkE2VUZ1M0Q7aUNBdlVxQy9vQyxLQUFLaTdDO3lCQUFYOzBCQUFxQi9vRTswQkFBSlQ7MEJBQ3ZDd3VCLFFBQU0sV0FOWjV2QixHQUtrQzJ2Qjt5QkFFaEM7MEJBQUk7OzZCQTcxQ1RxN0M7K0JBMjFDZ0Q1cEUsSUFBSVMsUUFDM0MrdEIsT0FEaUNnN0MsTUFKZmYsYUFBeUJhOzBCQU0zQzs7Ozs7MkJBQ2tCLE9BQUEsV0FMVnI5RCx3QkFHUnVpQjs7O3dCQUV1QzthQUFFOztZQUdsRDRrRCxhQUFhejBFLEdBQUdDLEdBQUdtUTtJQUNmLFlBZEpva0UsU0FhYXgwRSxHQUFHQyxHQUFHbVE7OEJBRWZ5TixtQkFBVSxPQUFWQTtJQUVKO0tBRGUrUjtLQUNYKzZDLGNBSmV2NkQ7S0FNK0IsMEJBQVMsV0FGdkR1NkQsYUFEVy82QztLQUdiLE9BQUE7SUFBQSxPQUFBO0dBQThFO1lBZ0JsRms2QyxZQUFZOXBFLEdBQUksT0FBSkEsUUFBbUM7WUFHL0N3OUQ7UUFBaUQxN0Qsa0JBQU42M0QsZ0JBQWR2cEQ7SUFDL0IsV0FEK0JBLFlBQWN1cEQsTUFBTTczRDs7WUFJakQ0eUUsTUFBTXBsRjtJQUFxQixJQUFmODVCLGNBQUg3NUIsY0FBa0IsT0FKM0JpdUUsS0FJTWx1RSxHQUFNODVCO0lBQUssV0FKakJvMEMsS0FJTWx1RSxHQUFHQzs7WUFFVG9sRixpQkFBaUJDOztLQUE4RDl5RTtLQUFONjNEO0tBQTlDa2IsV0FBVkQ7S0FBZ0N4a0UsYUFBaEN3a0U7SUFFaEIsT0FBQSw2QkFGMEJDLFVBQThDbGI7Y0FBeERpYjtrQkFBZ0N4a0UsWUFBd0J1cEQsTUFBTTczRDs7WUFLL0VnekUsd0JBQWtEbmI7UUFBVDczRCxtQkFBWnNPO0lBQTRCLFdBQTVCQSxZQUFxQnVwRCxNQUFUNzNEOztZQUN6Q2toRSxVQUFTNXlELFlBQVd1cEQ7SUFBTyxXQUFsQnZwRCxZQUFXdXBELE1BMWZkNzNELE9BMGZjNjNEO0dBQXVEO1lBT3pFdnBELFdBQVdwUSxHQUFJLE9BQUpBLEtBQWdCO1lBQzNCbzVELFFBQVFwNUQsR0FBSSxPQUFKQSxLQUFVO1lBRWxCeTlELGFBQVd6OUQ7SUFDYixJQUFxQyxPQTFCckM4cEUsWUF5QmE5cEUsSUFDYixPQTdsREUrMUQsV0E0bERXLzFEO0lBQ2I7Z0JBRGFBLGFBcGdCUDhCLE9Bb2dCTzlCOzs7SUFDMkM7R0FBOEI7WUFHcEZzWixXQUFTdFosR0FBSSxPQXI5Q2IrVCxTQXE5Q1MvVCxNQUF5QjtZQUNsQ29aLFNBQU9wWixHQUFJLE9BQUpBLEtBQVk7WUFFbkIrMEUsTUFBSS8wRSxHQUFHNHZCLEtBQUtpN0M7SUFDb0QsV0FqQ2xFZixZQWdDTTlwRTtJQUNDLE9BOUJQdzlELEtBNkJNeDlELEdBNTRDSm1uQyxJQTQ0Q0lubkMsTUFBQUEsTUFBRzR2QixLQUFLaTdDO0dBQ29FO1lBR2hGbUssVUFBUWgxRSxHQUFHNHZCLEtBQUtpN0M7SUFDbEIsV0FEVTdxRSxTQVFRLE9BNUNsQjhwRSxZQW9DVTlwRTtJQUdSLE9BcENGdzlELEtBaUNVeDlELEdBLzVDUmdyRSxRQSs1Q1FockUsTUFBQUEsTUFBRzR2QixLQUFLaTdDO0dBU3VCO1lBZXZDMTZDLElBQUlud0IsR0FBRzR2QixLQUFLaTdDO0lBQ2Q7S0FMa0I7YUFJWjdxRTtNQUpZLE9BeERsQjhwRSxZQTRETTlwRTtNQUVKNmQsU0EzREYyL0MsS0F5RE14OUQsR0FuN0NKaXJFLGlCQW03Q0lqckUsTUFBQUEsTUFBRzR2QixLQUFLaTdDOzs7OzRCQUdXOzs7SUFEYixrQkFBVmh0RDtHQUNpQztZQUdqQ28zRCxZQUFVajFFLEdBQUc0dkIsS0FBS2k3QztJQUcrQyxXQXJFbkVmLFlBa0VZOXBFO0lBR1YsT0FsRUZ3OUQsS0ErRFl4OUQsR0FqdkNWaXRFLFVBaXZDVWp0RSxNQUFBQSxNQUFHNHZCLEtBQUtpN0M7R0FHK0Q7WUFHakZxSyxlQUFhbDFFLEdBQUU0dkI7SUFDbUQsV0F6RXBFazZDLFlBd0VlOXBFO0lBQ1IsT0F0RVB3OUQsS0FxRWV4OUQsR0FuL0JieXVFLGFBbS9CYXp1RSxNQUFFNHZCLEtBQUY1dkI7R0FDcUU7WUFHbEZtMUUsYUFBV24xRSxHQUFFNHZCO0lBQStDLFdBNUU5RGs2QyxZQTRFYTlwRTtJQUFpRCxPQXR2QzVEbXRFLFdBc3ZDV250RSxNQUFFNHZCO0dBQThEO1lBRTNFd2xELFNBQU9wMUUsR0FBRTR2QixLQUFLM3ZCO0lBQ2lELFdBL0VqRTZwRSxZQThFUzlwRTtJQUNGLE9BNUVQdzlELEtBMkVTeDlELEdBcmtDUGt1RSxPQXFrQ09sdUUsTUFBRTR2QixLQUFLM3ZCLEdBQVBEO0dBQ3dFO1lBRy9FcTFFLFNBQU9yMUUsR0FBRTR2QixLQUFLM3ZCO0lBQ2lELFdBbkZqRTZwRSxZQWtGUzlwRTtJQUNGLE9BaEZQdzlELEtBK0VTeDlELEdBamlDUHV1RSxPQWlpQ092dUUsTUFBRTR2QixLQUFLM3ZCLEdBQVBEO0dBQ3dFO1lBRy9FK3ZCLFdBQVMvdkIsR0FBRTR2QjtJQUNiLFdBRFc1dkIsU0FJSSxPQTFGZjhwRSxZQXNGVzlwRTtXQTF2Q1Rna0IsU0EwdkNTaGtCLE1BQUU0dkI7R0FLd0I7WUFHbkMvVixPQUFLN1osR0FBRTR2QjtJQUF5QyxXQTlGbERrNkMsWUE4Rk85cEU7SUFBMkMsT0F0eEM1Q2daLEtBc3hDQ2haLE1BQUU0dkI7R0FBd0Q7WUFFL0R1dUMsU0FBT24rRCxHQUFFNHZCO0lBRzhDLFdBbkd6RGs2QyxZQWdHUzlwRTtJQUdQLE9BMUZGMjBFLGlCQXVGUzMwRSxHQWxuQ1Brd0IsT0FrbkNPbHdCLE1BQUU0dkIsS0FBRjV2QjtHQUdnRTtZQUd2RWl3QixNQUFJandCLEdBQUU0dkI7SUFBd0MsV0F0R2hEazZDLFlBc0dNOXBFO0lBQTBDLE9BMXZDOUNxYSxJQTB2Q0lyYSxNQUFFNHZCO0dBQXVEO1lBQzdEMGxELFlBQVV0MUUsR0FBR0MsR0FBSSxPQTVnQ2IwdUUsVUE0Z0NNM3VFLE1BQUdDLEdBQTZCO1lBQzFDaVosT0FBS2xaLEdBQUdDLEdBQUksT0FuZ0NSRSxLQW1nQ0NILE1BQUdDLEdBQXdCO1lBQ2hDdytCLFFBQU16K0IsR0FBR0MsR0FBSSxPQTEvQlRHLE1BMC9CRUosTUFBR0MsR0FBeUI7WUFDbENzMUUsY0FBWXYxRSxHQUFHQyxHQUFJLE9Bai9CbkI0dUUsWUFpL0JZN3VFLE1BQUdDLEdBQStCO1lBQzlDKzlELFFBQU01OEQsSUFBR0MsSUFBSXBCO0lBQWdELFdBM0cvRDZwRSxZQTJHUTFvRTtJQUF1RCxPQTlvQjdEMmhCLE1BOG9CTTNoQixPQUFHQyxPQUFJcEI7R0FBZ0U7WUFDN0V5TyxNQUFJMU8sR0FBR0MsR0FBSSxPQTlGYjYwRSxpQkE4Rk05MEUsR0FuK0JBSyxJQW0rQkFMLE1BQUdDLElBQTRDO1lBQ25Eby9DLE9BQUtyL0MsR0FBR0MsR0FBSSxPQS9GZDYwRSxpQkErRk85MEUsR0F6OUJETSxLQXk5QkNOLE1BQUdDLElBQTZDO1lBQ3JEdTFFLE9BQUt4MUUsR0FBR04sTUFBTU8sR0FBSSxPQS84QmRGLEtBKzhCQ0MsTUFBR04sTUFBTU8sR0FBOEI7WUFDNUNrYSxhQUFXbmEsR0FBR04sTUFBTU87SUFBSSxXQUFiRDtJQUFhLHNCLE9BejhCeEIwWSxpQkF5OEJjaFosTUFBTU87R0FBb0M7WUFDeEQ4OUQsYUFBVy85RCxHQUFHTixNQUFNTyxHQUFJLE9BeDdCcEJDLFdBdzdCT0YsTUFBR04sTUFBTU8sR0FBb0M7WUFFeER3MUUsUUFBTXIwRSxJQUFHQyxJQUFJM0IsTUFBTU87SUFDNkIsV0FuSGxENnBFLFlBa0hRMW9FO0lBQzBDLE9BN29CaEQydUUsUUE0b0JNM3VFLE9BQUdDLE9BQUkzQixNQUFNTztHQUM2QztZQUdoRXkxRSxjQUFZMTFFLEdBQUdDO0lBQXFELFdBdEh0RTZwRSxZQXNIYzlwRTtJQUFjLE9Bbkg1Qnc5RCxLQW1IY3g5RCxHQXQ3QlppdkUsWUFzN0JZanZFLE1BQUdDO0dBQXFFO1lBQ3BGZytELFNBQU9qK0QsR0FBR0M7SUFBZ0QsV0F2SDVENnBFLFlBdUhTOXBFO0lBQWMsT0FwSHZCdzlELEtBb0hTeDlELEdBajdCUDRqQixPQWk3Qk81akIsTUFBR0M7R0FBZ0U7WUFDMUUwMUUsVUFBUTMxRSxHQUFHQztJQUFpRCxXQXhIOUQ2cEUsWUF3SFU5cEU7SUFBYyxPQXJIeEJ3OUQsS0FxSFV4OUQsR0E3NkJSMnBCLFFBNjZCUTNwQixNQUFHQztHQUFpRTtZQUM1RStnRSxhQUFXaGhFLEdBQUdDO0lBQW9ELFdBekhwRTZwRSxZQXlIYTlwRTtJQUFjLE9BdEgzQnc5RCxLQXNIYXg5RCxHQXo2QlgwdEIsV0F5NkJXMXRCLE1BQUdDO0dBQW9FO1lBQ2xGMjFFLGNBQVk1MUUsR0FBR0M7SUFBcUQsV0ExSHRFNnBFLFlBMEhjOXBFO0lBQWMsT0F2SDVCdzlELEtBdUhjeDlELEdBbjZCWjZ0QixZQW02Qlk3dEIsTUFBR0M7R0FBcUU7WUFFcEY0MUUsaUJBQWU3MUUsR0FBR0M7SUFDaUMsV0E3SHJENnBFLFlBNEhpQjlwRTtJQUNULE9BdEhSMDBFLE1BcUhpQjEwRSxHQTk1QmZrdkUsZUE4NUJlbHZFLE1BQUdDO0dBQ2lEO1lBR25FNjFFLGdCQUFjOTFFLEdBQUdDO0lBQ2lDLFdBaklwRDZwRSxZQWdJZ0I5cEU7SUFDUixPQTFIUjAwRSxNQXlIZ0IxMEUsR0FwNUJkZ1UsY0FvNUJjaFUsTUFBR0M7R0FDaUQ7WUFHbEU4MUUsZ0JBQWMvMUUsR0FBR0M7SUFDaUMsV0FySXBENnBFLFlBb0lnQjlwRTtJQUNSLE9BOUhSMDBFLE1BNkhnQjEwRSxHQXA1QmRvckMsY0FvNUJjcHJDLE1BQUdDO0dBQ2lEO1lBR2xFNitELGVBQWE5K0QsR0FBR0M7SUFDaUMsV0F6SW5ENnBFLFlBd0llOXBFO0lBQ1AsT0FsSVIwMEUsTUFpSWUxMEUsR0FuNUJibXVCLGFBbTVCYW51QixNQUFHQztHQUNpRDtZQUdqRSsxRSxpQkFBZWgyRTtJQUNqQjtZQURpQkE7S0FLQyxPQWpKbEI4cEUsWUE0SWlCOXBFO0tBR2YsT0F6TEFpWSxlQXNMZWpZO0lBRVosT0FBQTtxRCxPQTNJTHc5RCxLQXlJaUJ4OUQ7R0FNd0I7WUFHdkN3K0QsZUFBZW9SLGNBQWF4dUUsSUFBR0M7SUFDakMsV0FEaUNBLGNBQUhEO1dBaHNCNUJuSixVQTJpQkY2eEUsWUFxSjhCMW9FLEtBQWJ3dUU7R0FDMEM7WUFHekQ5MkUsUUFBTTgyRSxjQUFheHVFLElBQUdDO0lBQUssV0FBTEEsY0FBSEQ7V0Foc0JuQmxKLFFBdWlCRjR4RSxZQXlKcUIxb0UsS0FBYnd1RTtHQUE4RTtZQUNwRnFHLE9BQUtqMkUsR0FBSSxPQXhuQlQwd0UsS0F3bkJLMXdFLE1BQXFCO1lBQzFCa3RFLE9BQUtsdEUsR0FBSSxPQXhuQlQ2cUUsS0F3bkJLN3FFLE1BQXFCO1lBQzFCazJFLFdBQVVqRSxXQUFVanlFLEdBQUksT0FoZnhCZ3lFLFNBZ2ZVQyxXQUFVanlFLE1BQW9DO1lBRXhEdStELGlCQUFlbjlELElBQUdDLElBQUltdUU7SUFDMEIsV0EvSmxEMUYsWUE4SmlCMW9FO0lBQ2pCLE9BcnJCRXc0RCxlQW9yQmV4NEQsT0FBR0MsYUFBSW11RTtHQUNzRDtZQUc1RTJHLHNCQUFvQi8wRSxJQUFHQyxJQUFJbXVFLFlBQVk5dkUsTUFBTU87SUFJaEMsV0F0S2Y2cEUsWUFrS3NCMW9FO0lBQ3RCLE9BdnJCRTR1RSxvQkFzckJvQjV1RSxPQUFHQyxhQUFJbXVFLFlBQVk5dkUsTUFBTU87R0FPM0M7WUFHRm0yRSxRQUFNaDFFLElBQUdDLElBQUlwQjtJQUNzQyxXQTdLckQ2cEUsWUE0S1Exb0U7SUFDQSxPQTFLUm84RCxLQXlLUXA4RCxJQTFmTjJwQixNQTBmTTNwQixPQUFHQyxPQUFJcEI7R0FDdUQ7WUFHcEVvMkUsZUFBYWoxRSxJQUFHQyxJQUFJc1c7SUFFdEI7S0FRa0IsT0ExTGxCbXlELFlBZ0xlMW9FO0tBSWIsT0FuZkFreEUsYUErZWFseEUsT0FBR0MsT0FBSEQsT0FBR0MsT0FBSXNXO0tBQVB1RCxPQUFHN1osU0FBSEQsUUFBQUEsS0FBR0M7SUFJaEIsT0EzS0ZzekUsaUJBdUtlejVEO0dBVW9CO1lBR2pDbEIsVUFBUWhhLEdBQUksT0EvMENSNFksUUErMENJNVksTUFBd0I7WUFDaEMyOUQsY0FBWTM5RCxHQUFJLE9BL3lDaEJvNEQsWUEreUNZcDRELE1BQTRCO1lBQ3hDaWEsVUFBUWphLEdBQUksT0ExeUNSOFksUUEweUNJOVksTUFBd0I7WUFDaEM0OUQsY0FBWTU5RCxHQUFJLE9BcHlDaEJ1NEQsWUFveUNZdjRELE1BQTRCO1lBQ3hDMlosVUFBUTNaLEdBQUdDLEdBQUksT0FyakJmc0MsUUFxakJRdkMsTUFBR0MsR0FBMkI7WUFDdEM4K0IsV0FBUy8rQixHQUFHQyxHQUFJLE9BaGpCaEJza0IsU0FnakJTdmtCLE1BQUdDLEdBQTRCO1lBQ3hDeVosU0FBTzFaLEdBQUdDLEdBQUksT0EzaUJkaUMsT0EyaUJPbEMsTUFBR0MsR0FBMEI7WUFDcEM2K0IsVUFBUTkrQixHQUFHQyxHQUFJLE9BdGlCZnVrQixRQXNpQlF4a0IsTUFBR0MsR0FBMkI7WUFDdEN3WixRQUFNelosR0FBR0MsR0FBSSxPQWppQmJtWSxNQWlpQk1wWSxNQUFHQyxHQUF5QjtZQUNsQzQrQixTQUFPNytCLEdBQUdDLEdBQUksT0E5aEJkc3RCLE9BOGhCT3Z0QixNQUFHQyxHQUEwQjtZQUVwQ2srQyxRQWxMV24rQyxHQWtMSHd2QjtJQUNWO0tBQW9ELE9Bek1wRHM2QyxZQXNCYTlwRTtLQW1MSyxRQS83Q1ptM0MsTUE0d0NPbjNDLE1Ba0xId3ZCO0tBckx5Qm1xQztLQXNMNUJhO0tBdEw0QjhiO0tBQW5CbG1FLGFBR0hwUTtLQXVMVHUyRTtPQUFjLDRCQUpYL2I7VUFJcUMsNEJBdkwvQng2RDtVQUFBQTtLQXdMTyxPQXZ4RGxCMDFELE9BNGxEaUNpRTtPQTVsRGpDakUsT0E0bERpQzRnQjtLQTZMekI7TUFsTER0ekUsSUFmVGdnRSxVQUlnQjV5RCxZQUFtQmttRTtNQUFQeDBFLFNBOExxQiw0QkFKN0N5MEUsVUEvS0t2ekU7S0FtTFAsV0FuTE9BLEdBMktGdzNELFdBdExTcHFELFlBQW1CdXBELE1BQVA3M0Q7O0lBZ01sQjtLQXJMRDJGLElBZlR1N0QsVUFJZ0I1eUQsWUFBbUJ1cEQ7S0FBUHZnRCxXQWlNVyw0QkFQbkNtOUQsVUEvS0s5dUU7SUFzTFAsZUFqTWMySSxZQUFtQmttRSxRQUFQbDlELFdBc0xyQm9oRCxPQTNLRS95RDtHQXNMOEQ7WUFHckUrdUUsU0FqTVd4MkUsR0FpTUMrYyxhQUFhQztJQUMzQjtLQUNrRSxPQXpObEU4c0QsWUFzQmE5cEU7S0FtTVgsUUE3NkNBeXNFLFlBMHVDV3pzRSxNQWlNQytjLGFBQWFDO0tBQ1p1cUI7S0FyTW9Cb3lCO0tBcU0vQnJ5QjtLQU1FbXZDLE1BdnlESi9nQixPQWl5REVwdUI7S0FPRW92QyxNQXh5REpoaEIsT0FpeURhbnVCO0tBS1hvdkM7T0FDRUYsUUFDQUM7VUFDYyw0QkFGZEQ7VUFFMkIsNEJBRjNCQSxLQUNBQztPQUZGQyx1QkF0eURGamhCLE9BNGxEaUNpRSxPQW1OOUIsT0F2TkxxSixVQU9haGpFLE1BSHNCMjVEO0lBaU5nQjtLQUFBLE9BL3NCN0M3M0QsT0Ftc0JTeWxDO0tBWWdCLE9BL3NCekJ6bEMsT0Ftc0JGd2xDO0tBWTBCLE9BQUE7S0FqTkZzdkMsYUFpTlQsNEJBOU1ONTJFO0tBSEdvUSxhQUdIcFE7SUFINkIsV0FBMUJvUSxZQUFtQnVwRCxNQUFQaWQ7R0FtTmU7WUFHekNDLFNBbk5XekosWUFtTlNDO0lBQ3RCO0tBRWlCLE9BNU9qQnZELFlBc0Jhc0Q7S0FxTlgsUUFqMENBL3RFLE9BNG1DVyt0RSxlQW1OU0M7a0NBYU87SUFEZDtLQWxPb0IxVDtLQUFQNzNELFNBa09iLDRCQS9ORnNyRSxlQW1OU0M7S0F0Tk5qOUQsYUFHSGc5RDtJQTJOWCxzQkE5TmNoOUQsWUFBbUJ1cEQsTUFBUDczRDtHQW1Pd0I7WUFHbERnMUUsdUJBQXFCOTJFLEdBQUd2USxLQUFLRCxLQUFLa1EsTUFBTU87SUFDd0IsV0ExUGxFNnBFLFlBeVB1QjlwRTtJQUMyQyxPQXQwQ2hFOHRFLHFCQXEwQ3FCOXRFLE1BQUd2USxLQUFLRCxLQUFLa1EsTUFBTU87R0FDdUM7WUFHL0U4MkUsaUJBQWUvMkUsR0FBR3ZRLEtBQUtEO0lBQzBCLFdBOVBuRHM2RSxZQTZQaUI5cEU7SUFDa0MsT0F0eUNqRCt0RSxlQXF5Q2UvdEUsTUFBR3ZRLEtBQUtEO0dBQ3lDO1lBR2hFd25GLGNBQVloM0UsR0FBRW11QyxLQUFJdmU7SUFDMEIsV0FsUTlDazZDLFlBaVFjOXBFO0lBQ2dDLE9BemU1QzJ5RSxZQXdlWTN5RSxNQUFFbXVDLEtBQUl2ZTtHQUN5QztZQUczRDJ5QyxNQUFJdmlFLEdBQUV3UyxHQUFJLE9BeGNWMHNELE1Bd2NJbC9ELE1BQUV3UyxHQUFzQjtZQUM1QnFQLFFBQVE3aEIsR0FBRXdTO0lBQXFCLFdBRC9CK3ZELE1BQ1F2aUUsR0FBRXdTO0lBQXFCLE9BQUE7R0FBUztZQUN4Q3lrRSxPQUFLajNFLEdBQUU0dkI7SUFBeUMsV0F2UWxEazZDLFlBdVFPOXBFO0lBQTJDLE9BNWU1Q2l6RSxLQTRlQ2p6RSxNQUFFNHZCO0dBQXdEO1lBQy9EMmxCLFlBQVUyaEMsV0FBVUMsa0JBQVluM0UsR0FBSSxPQXZUcEMrdUIsWUF1VFVtb0QsV0FBVUMsV0FBWW4zRTtHQUE4QztZQUU5RW8vRDtJQUFhcCtDLE9BQU95dUQsMEJBQTBCQyx1QkFBc0IxdkU7SUFDdEUsT0E5MEJFd3JDO2FBNjBCb0V4ckM7YUFBdkRnaEI7YUFBT3l1RDthQUEwQkM7YUFBc0IxdkU7R0FNOUQ7WUFHTnEvRCxnQkFBY3IvRCxHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0lBQUksT0F6YmpDOHNCLGNBeWJjcjdCLE1BQUczSixTQUFRaWxDLEtBQUkvc0I7R0FBNkM7WUFFMUUrd0QsMEJBQXdCdC9ELEdBQUd3N0IsWUFBV0Y7SUFDeEMsT0F4YUVDLHdCQXVhd0J2N0IsTUFBR3c3QixZQUFXRjtHQUNZO1lBR2xEa2tDLGlCQUFpQjRYLGVBQWNDLGdCQUFlcHhFLE9BQU1qRztJQUN0RCxJQS92Qm9Fa0csTUE4dkJkbEcsTUEzdkJ6QixPQVR2QjhCLE9BTThEb0U7SUFJL0QsT0FoWUNuRzthQTRYOERtRzthQUc1RCw2QkEydkJ3Q0Q7c0JBMXZCckMycEIsS0FBS2k3QyxNQUFLNWtFO2NBQVMsT0FBQTt1QkEwdkJHb3hFO3VCQTF2QlksV0EwdkIxQkQsZUExdkJFbnhFLE9BQVYycEI7dUJBQUtpN0M7YUFBMkQ7R0EydkJHO1lBRzVFeU0sdUJBQXVCdDNFLEdBQUczSixTQUFTMG1CLGFBQWFDO0lBRWhEOztPQXBaQTIyRCwrQkFrWnVCM3pFLE1BQUczSixTQUFTMG1CLGFBQWFDO2dCQUt4QyxPQXpSVjIzRCxpQkFvUnlCMzBFOzs7S0FJSjZ6RTtLQUFiRDtJQUE2QixPQTFFbkM0QyxTQXNFdUJ4MkUsR0FJakI0ekUsZUFBYUM7R0FDa0I7WUFVckMzUSxlQUFzQixPQUR0QnZLLCtCQUNxRDtZQUNyRG1OLGlCQUFzQm5NLE1BQU8sT0FBUEEsS0FBVztZQUNqQ2gwQixpQkE5MERVL1YsS0FBSWk3QyxNQTgwRGdCLFdBOTBEcEJqN0MsS0FBSWk3QyxNQTgwRG1DO1lBRWpEN0ksNEJBQTJCNXhELFlBQVd4TDtJQUNwQyxXQWx6REZneUQsMEJBaXpEc0NoeUQsT0FBWHdMO0lBQ3pCLE9BQUE7R0FBa0Y7WUFHcEY4eEQsa0JBQWlCOXhELFlBQVd4TDtJQUM5QixXQXh5REVreUQsZ0JBdXlENEJseUQsT0FBWHdMO0lBQ25CLE9BQUE7R0FDc0I7WUFHcEJtbkUsV0FBVW5uRSxZQUFXc2Y7SUFDakIsSUFDSm9jLElBanRCQXVsQyxTQStzQnFCM2hELE9BQVh0ZjtlQUVWMDdCLE1BQXlCLE9BQXpCQTtRQUNLNnRCLE9BREw3dEI7SUFDcUIsa0JBQWhCNnRCO0dBQXdCO1lBRzdCNmQsb0JBQW1CcG5FLFlBQVdzZjtJQUNoQyxXQXJ0QkU0aEQsa0JBb3RCOEI1aEQsT0FBWHRmO0lBQ3JCLE9BQUE7R0FBZ0U7WUFHOURxbkUsZUFBY3JuRSxZQUFXc2Y7SUFBWSxXQXZ0QnJDNmhELGFBdXRCeUI3aEQsT0FBWHRmO0lBQXVCLE9BQUE7R0FBc0M7WUFFM0VzbkUsaUJBQWdCdG5FLFlBQVdzZjtJQUN6QixXQWh0QkYraEQsZUErc0IyQi9oRCxPQUFYdGY7SUFDZCxPQUFBO0dBQXVFO1lBR3pFdW5FLGdCQUFldm5FLFlBQVdzZixPQUFPaHdCLE1BQU1PO0lBQ3JDLFdBbHVCRmt4RSxjQWl1QjBCemhELE9BQU9od0IsTUFBTU8sR0FBeEJtUTtJQUNiLE9BQUE7R0FBK0U7WUFHakZ3bkUsa0JBQWlCeG5FLFlBQVdzZixPQUFPenZCO0lBQ2pDLFdBcnVCRm14RSxnQkFvdUI0QjFoRCxPQUFPenZCLEdBQWxCbVE7SUFDZixPQUFBO0dBQTJFO1lBRzdFeW5FLFdBQVV6bkUsWUFBWWhRO0lBQ2xCLElBRUowckMsSUEzYUFnb0MsU0F3YXNCMXpFLE9BQVpnUTtlQUdWMDdCLE1BQXlCLE9BQXpCQTtRQURLNnRCLE9BQ0w3dEI7SUFEcUIsa0JBQWhCNnRCO0dBQ3FCO1lBRzFCbWUsZUFBYzFuRSxZQUFZaFE7SUFBWSxXQWphdEMyekUsYUFpYTBCM3pFLE9BQVpnUTtJQUF3QixPQUFBO0dBQXVDO1lBRTdFNnhELGlDQUE2QzhWLGtCQUFtQjU0RSxLQUFLYyxHQUN2RSxPQXQzREVtMkQsK0JBcTNEZ0VqM0QsS0FBS2M7R0FDekI7WUFHNUMrM0UseUJBQXdCNW5FLFlBQVd5MkI7SUFDckM7S0FBQTtLQUVFLE9BM25EQTRrQyx1QkF3bkRtQzVrQyxLQUFYejJCO0lBQzFCLE9BQUE7R0FFK0U7WUFHN0UweEQsY0FBYTF4RCxZQUFXeTJCO0lBQ3BCLElBQ0ppRixJQWp1QkE5RSxZQSt0QndCSCxLQUFYejJCO2VBRWIwN0IsTUFBeUIsT0FBekJBO1FBQ0s2dEIsT0FETDd0QjtJQUNxQixrQkFBaEI2dEI7R0FBd0I7WUFHN0JzZSx1QkFBc0I3bkUsWUFBV3kyQjtJQUNuQyxXQXJ1QkVnckMscUJBb3VCaUNockMsS0FBWHoyQjtJQUN4QixPQUFBO0dBQWlFO1lBRy9EOG5FLGtCQUFpQjluRSxZQUFXeTJCO0lBQVUsV0F2dUJ0Q2lyQyxnQkF1dUI0QmpyQyxLQUFYejJCO0lBQXFCLE9BQUE7R0FBdUM7WUFFN0UrbkUsb0JBQW1CL25FLFlBQVd5MkI7SUFDNUIsV0F4dUJGa3JDLGtCQXV1QjhCbHJDLEtBQVh6MkI7SUFDakIsT0FBQTtHQUF3RTtZQUcxRWdvRSxtQkFBa0Job0UsWUFBV3kyQixLQUFLbm5DLE1BQU1PO0lBQ3RDLFdBbHZCRjB4RSxpQkFpdkI2QjlxQyxLQUFLbm5DLE1BQU1PLEdBQXRCbVE7SUFDaEIsT0FBQTtHQUFnRjtZQUdsRmlvRSxxQkFBb0Jqb0UsWUFBV3kyQixLQUFLNW1DO0lBQ2xDLFdBcnZCRjJ4RSxtQkFvdkIrQi9xQyxLQUFLNW1DLEdBQWhCbVE7SUFDbEIsT0FBQTtHQUE0RTtZQUc5RTJ5RCxVQUFRL2lFLEdBQUksT0FBSkEsRUFBSztZQUViMC9ELGFBQVl0dkQsWUFBV3BRLEdBQ3pCLE9BajhERSsxRCxXQWc4RHVCLzFELEdBQVhvUSxlQUMrQztZQUczRHV2RCxXQUFTMy9ELEdBQUksT0F6ekRiK1QsU0F5ekRTL1QsR0FBb0I7WUFDN0JxWixTQUFPclosR0FBSSxPQTcyQlA4QixPQTYyQkc5QixHQUFrQjtZQUV6QnM0RSxNQUFLbG9FLFlBQVdwUSxHQUFHNHZCLEtBQUtpN0M7SUFDdEIsV0FqdkRGMWpDLElBZ3ZEZ0JubkMsTUFBRzR2QixLQUFLaTdDLE1BQW5CejZEO0lBQ0gsT0FBQTtHQUE2RTtZQUcvRW1vRSxVQUFTbm9FLFlBQVdwUSxHQUFHNHZCLEtBQUtpN0M7SUFFNUIsV0Fyd0RBRyxRQW13RG9CaHJFLE1BQUc0dkIsS0FBS2k3QyxNQUFuQno2RCxlQUFBQTtJQUVULE9BQUE7R0FNcUM7WUFHckM4dEQsTUFBSzl0RCxZQUFXcFEsR0FBRzR2QixLQUFLaTdDO0lBQzFCO0tBQUksc0JBWkYwTixVQVdLbm9FLFlBQVdwUSxHQUFHNHZCLEtBQUtpN0M7S0FDdEI7O2dCQUNHO0dBQVU7WUFHZjJOLFlBQVdwb0UsWUFBV3BRLEdBQUc0dkIsS0FBS2k3QztJQUNoQyxXQXhrREVvQyxVQXVrRHNCanRFLE1BQUc0dkIsS0FBS2k3QyxNQUFuQno2RDtJQUNiLE9BQUE7R0FDTTtZQUdKcW9FLGVBQWNyb0UsWUFBV3BRLEdBQUU0dkI7SUFDN0IsVUF6MENFNitDLGFBdzBDeUJ6dUUsR0FBRTR2QixRQUFieGY7SUFDaEIsT0FBQTtHQUFvRjtZQUdsRnNvRSxhQUFZdG9FLFlBQVdwUSxHQUFFNHZCO0lBQzNCLE9BNWtERXU5QyxXQTJrRHVCbnRFLEdBQUU0dkIsS0FBYnhmO0dBQ21EO1lBRy9EdW9FLFNBQVF2b0UsWUFBV3BRLEdBQUU0dkIsS0FBSzN2QjtJQUN4QixVQTc1Q0ZpdUUsT0E0NUNtQmx1RSxHQUFFNHZCLEtBQUszdkIsTUFBbEJtUTtJQUNOLE9BQUE7R0FBNEU7WUFHOUV3b0UsU0FBUXhvRSxZQUFXcFEsR0FBRTR2QixLQUFLM3ZCO0lBQzVCLE9BTEUwNEU7YUFJUXZvRTthQUFXcFE7YUFBRTR2QjtzQkFDVWk3QyxNQUFRLFdBQUssV0FEbEI1cUUsR0FDSzRxRSxPQUFxQjtHQUFDO1lBR3JEbkssV0FBVXR3RCxZQUFXcFEsR0FBRTR2QjtJQUN6QixPQWxsREU1TCxTQWlsRHFCaGtCLEdBQUU0dkIsS0FBYnhmLGVBQUFBO0dBS2tDO1lBRzVDcXdELE9BQU1yd0QsWUFBV3BRLEdBQUU0dkIsS0FBTSxPQTdtRHJCNVcsS0E2bURhaFosR0FBRTR2QixLQUFieGYsZUFBOEU7WUFFcEZpeEQsU0FBUWp4RCxZQUFXcFEsR0FBRTR2QjtJQUNuQixVQTE4Q0ZNLE9BeThDbUJsd0IsR0FBRTR2QixRQUFieGY7SUFDTixPQUFBO0dBQXlFO1lBRzNFK3dELE1BQUsvd0QsWUFBV3BRLEdBQUU0dkIsS0FBTSxPQS9rRHhCdlYsSUEra0RnQnJhLEdBQUU0dkIsS0FBYnhmLGVBQTZFO1lBQ2xGeW9FLFlBQVU3NEUsR0FBR0MsR0FBSSxPQWoyQ2IwdUUsVUFpMkNNM3VFLEdBQUdDLEdBQXdCO1lBQ3JDa1osT0FBS25aLEdBQUdDLEdBQUksT0F4MUNSRSxLQXcxQ0NILEdBQUdDLEdBQW1CO1lBQzNCeStCLFFBQU0xK0IsR0FBR0MsR0FBSSxPQS8wQ1RHLE1BKzBDRUosR0FBR0MsR0FBb0I7WUFDN0I2NEUsY0FBWTk0RSxHQUFHQyxHQUFJLE9BdDBDbkI0dUUsWUFzMENZN3VFLEdBQUdDLEdBQTBCO1lBRXpDaWhFLFFBQU85d0QsWUFBV2hQLElBQUdDLElBQUlwQjtJQUMzQixPQXIrQkU4aUIsTUFvK0JrQjNoQixJQUFHQyxJQUFJcEIsR0FBbEJtUTtHQUNzRDtZQUc3RDBHLE1BQUk5VyxHQUFHQyxHQUFJLE9BNXpDUEksSUE0ekNBTCxHQUFHQyxHQUFrQjtZQUN6Qjg0RSxPQUFLLzRFLEdBQUdDLEdBQUksT0FsekNSSyxLQWt6Q0NOLEdBQUdDLEdBQW1CO1lBQzNCKzRFLE9BQUtoNUUsR0FBR04sTUFBTU8sR0FBSSxPQXh5Q2RGLEtBd3lDQ0MsR0FBR04sTUFBTU8sR0FBeUI7WUFDdkM0Z0UsYUFBVzdnRSxHQUFHTixNQUFNTyxHQUFHMFksUUFBUyxPQWx5Q2hDRCxXQWt5Q1cxWSxHQUFHTixNQUFNTyxHQUFHMFk7R0FBNEM7WUFDbkVtb0QsYUFBVzlnRSxHQUFHTixNQUFNTyxHQUFJLE9BanhDcEJDLFdBaXhDT0YsR0FBR04sTUFBTU8sR0FBK0I7WUFFbkRnNUUsUUFBTzdvRSxZQUFXaFAsSUFBR0MsSUFBSTNCLE1BQU1PO0lBQ2pDLE9BdCtCRTh2RSxRQXErQmtCM3VFLElBQUdDLElBQUkzQixNQUFNTyxHQUF4Qm1RO0dBQzREO1lBR25FOG9FLGNBQWE5b0UsWUFBV3BRLEdBQUdDO0lBQ3pCLFVBaHhDRmd2RSxZQSt3Q3dCanZFLEdBQUdDLEdBQWRtUTtJQUNYLE9BQUE7R0FBbUU7WUFHckUyd0QsU0FBUTN3RCxZQUFXcFEsR0FBR0M7SUFDcEIsVUE5d0NGMmpCLE9BNndDbUI1akIsR0FBR0MsR0FBZG1RO0lBQ04sT0FBQTtHQUE4RDtZQUdoRStvRSxVQUFTL29FLFlBQVdwUSxHQUFHQztJQUNyQixVQTd3Q0YwcEIsUUE0d0NvQjNwQixHQUFHQyxHQUFkbVE7SUFDUCxPQUFBO0dBQStEO1lBR2pFd3pELGFBQVl4ekQsWUFBV3BRLEdBQUdDO0lBQ3hCLFVBNXdDRnl0QixXQTJ3Q3VCMXRCLEdBQUdDLEdBQWRtUTtJQUNWLE9BQUE7R0FBa0U7WUFHcEVncEUsY0FBYWhwRSxZQUFXcFEsR0FBR0M7SUFDekIsVUF6d0NGNHRCLFlBd3dDd0I3dEIsR0FBR0MsR0FBZG1RO0lBQ1gsT0FBQTtHQUFtRTtZQUdyRWlwRSxpQkFBZ0JqcEUsWUFBV3BRLEdBQUdDO0lBQ2hDO0tBQ0UsTUF2d0NBaXZFLGVBcXdDMkJsdkUsR0FBR0MsR0FBZG1RO0tBQ0wvTTtLQUFSRDtJQUdMLFdBSEtBLEdBQVFDO0dBR1Q7WUFHRmkyRSxnQkFBZWxwRSxZQUFXcFEsR0FBR0M7SUFDL0I7S0FDRSxNQWh3Q0ErVCxjQTh2QzBCaFUsR0FBR0MsR0FBZG1RO0tBQ0ovTTtLQUFSRDtJQUdMLFdBSEtBLEdBQVFDO0dBR1Q7WUFHRmsyRSxnQkFBZW5wRSxZQUFXcFEsR0FBR0M7SUFDL0I7S0FDRSxNQW53Q0FtckMsY0Fpd0MwQnByQyxHQUFHQyxHQUFkbVE7S0FDSi9NO0tBQVJEO0lBR0wsV0FIS0EsR0FBUUM7R0FHVDtZQUdGNDlELGVBQWM3d0QsWUFBV3BRLEdBQUdDO0lBQzlCLElBQ0UsTUFyd0NBa3VCLGFBbXdDeUJudUIsR0FBR0MsR0FBZG1RLGdCQUNIL00sZUFBUkQ7SUFHTCxXQUhLQSxHQUFRQztHQUdUO1lBR0ZtMkUsaUJBQWdCcHBFLFlBQVdwUTtJQUM3QjtLQUFBO0tBRUUsTUE1aUJBaVksZUF5aUIyQmpZLEdBQVhvUSxlQUFBQTtJQUNsQixPQUFBO0dBS2tEO1lBR2hEc3hELGlCQUFnQnR4RCxZQUFXdy9ELGNBQWF4dUUsSUFBR0MsSUFDN0MsT0FwakNFcEosVUFtakNnQm1ZLGVBQVd3L0QsY0FBYXh1RSxJQUFHQztHQUNpQjtZQUc1RDFILFFBQU95VyxZQUFXdy9ELGNBQWF4dUUsSUFBR0M7SUFDcEMsT0FwakNFbkosUUFtakNPa1ksZUFBV3cvRCxjQUFheHVFLElBQUdDO0dBQ3dCO1lBRzFEbzRFLE9BQUt6NUUsR0FBSSxPQTkrQlQwd0UsS0E4K0JLMXdFLEdBQWdCO1lBQ3JCMDVFLE9BQUsxNUUsR0FBSSxPQTkrQlQ2cUUsS0E4K0JLN3FFLEdBQWdCO1lBQ3JCMjVFLFdBQVUxSCxXQUFVanlFLEdBQUksT0F0MkJ4Qmd5RSxTQXMyQlVDLFdBQVVqeUUsR0FBK0I7WUFFbkR5aEUsaUJBQWdCcnhELFlBQVdoUCxJQUFHQyxJQUFJbXVFO0lBQ3BDLE9BM2lDRTVWLGVBMGlDMkJ4NEQsSUFBR0MsSUFBZCtPLGVBQWtCby9EO0dBQzZDO1lBRy9Fb0ssc0JBQXFCeHBFLFlBQVdoUCxJQUFHQyxJQUFJbXVFLFlBQVk5dkUsTUFBTU87SUFDM0QsT0E3aUNFK3ZFLG9CQTRpQ2dDNXVFLElBQUdDLElBQWQrTyxlQUFrQm8vRCxZQUFZOXZFLE1BQU1PO0dBT3ZEO1lBR0Y0NUUsUUFBT3pwRSxZQUFXaFAsSUFBR0MsSUFBSXBCO0lBQ3ZCLFVBajNCRjhxQixNQWczQmtCM3BCLElBQUdDLElBQUlwQixHQUFsQm1RO0lBQ0wsT0FBQTtHQUFpRTtZQUduRTBwRSxlQUFjMXBFLFlBcEtQaFAsSUFBQUMsSUFvS3lCc1c7SUFHbEM7V0FIZ0J2SDtLQXBLSCxNQTcyQlB0TyxPQTYyQkdUO0tBd0tQLE1BejJCQWl4RSxhQWlzQk9seEUsSUFBQUMsSUE3MkJIUyxPQTYyQkdWLFVBb0t5QnVXO0lBSWhDLE9BQUE7R0FNOEM7WUFHOUNrb0QsVUFBUTcvRCxHQUFJLE9BcnNEUjRZLFFBcXNESTVZLEdBQW1CO1lBQzNCOC9ELGNBQVk5L0QsR0FBSSxPQXJxRGhCbzRELFlBcXFEWXA0RCxHQUF1QjtZQUNuQysvRCxVQUFRLy9ELEdBQUksT0FocURSOFksUUFncURJOVksR0FBbUI7WUFDM0JnZ0UsY0FBWWhnRSxHQUFJLE9BMXBEaEJ1NEQsWUEwcERZdjRELEdBQXVCO1lBQ25Dc2dFLFVBQVF0Z0UsR0FBR0MsR0FBSSxPQTM2QmZzQyxRQTI2QlF2QyxHQUFHQyxHQUFzQjtZQUNqQzg1RSxXQUFTLzVFLEdBQUdDLEdBQUksT0F0NkJoQnNrQixTQXM2QlN2a0IsR0FBR0MsR0FBdUI7WUFDbkNvZ0UsU0FBT3JnRSxHQUFHQyxHQUFJLE9BajZCZGlDLE9BaTZCT2xDLEdBQUdDLEdBQXFCO1lBQy9CKzVFLFVBQVFoNkUsR0FBR0MsR0FBSSxPQTU1QmZ1a0IsUUE0NUJReGtCLEdBQUdDLEdBQXNCO1lBQ2pDc2dFLFFBQU12Z0UsR0FBR0MsR0FBSSxPQXY1QmJtWSxNQXU1Qk1wWSxHQUFHQyxHQUFvQjtZQUM3Qmc2RSxTQUFPajZFLEdBQUdDLEdBQUksT0FwNUJkc3RCLE9BbzVCT3Z0QixHQUFHQyxHQUFxQjtZQUMvQnFpRSxRQUFPbHlELFlBQVdwUSxHQUFFd3ZCLEdBQUksT0FuekRwQjJuQixNQW16RGNuM0MsR0FBRXd2QixHQUFicGYsZUFBMkU7WUFFbEY4cEUsU0FBUTlwRSxZQUFZZzlELFlBQVlDO0lBQ2xDLE9BdHBERWh1RSxPQXFwRG9CK3RFLFlBQVlDLFlBQXhCajlEO0dBQ3FFO1lBRzdFK3BFLFdBQVUvcEUsWUFBV3BRLEdBQUcrYyxhQUFhQztJQUN2QyxJQUFPeFYsTUF4eERMaWxFLFlBdXhEcUJ6c0UsR0FBRytjLGFBQWFDLGFBQTNCNU07SUFRWixPQVBPNUk7R0FPSjtZQUdENHlFLHVCQUFzQmhxRSxZQUFXcFEsR0FBR3ZRLEtBQUtELEtBQUtrUSxNQUFNTztJQUN0RCxPQTNwREU2dEUscUJBMHBEaUM5dEUsR0FBR3ZRLEtBQUtELEtBQUtrUSxNQUFNTyxHQUE5Qm1RO0dBT29CO1lBRzFDaXFFLGlCQUFnQmpxRSxZQUFXcFEsR0FBR3ZRLEtBQUtEO0lBQ3JDLE9Bam9ERXUrRSxlQWdvRDJCL3RFLEdBQUd2USxLQUFLRCxLQUFuQjRnQjtHQUN5RDtZQUd6RWtxRSxjQUFhbHFFLFlBQVdwUSxHQUFFbXVDLEtBQUl2ZTtJQUNoQyxPQXAwQkUraUQsWUFtMEJ3QjN5RSxHQUFFbXVDLEtBQUl2ZSxLQUFqQnhmO0dBQ3VEO1lBR3BFbXFFLE1BQUl2NkUsR0FBRXdTLEdBQUksT0FueUJWMHNELE1BbXlCSWwvRCxHQUFFd1MsR0FBaUI7WUFDdkJnb0UsVUFESXg2RSxHQUFFd1M7SUFBSSxVQW55QlYwc0QsTUFteUJJbC9ELEdBQUV3UztJQUN5QixPQUFBO0dBQVM7WUFDeENpb0UsT0FBTXJxRSxZQUFXcFEsR0FBRTR2QixLQUFNLE9BdjBCckJxakQsS0F1MEJhanpFLEdBQUU0dkIsS0FBYnhmLGVBQThFO1lBQ3BGcWxELFlBQVV5aEIsV0FBVUMsa0JBQVluM0UsR0FBSSxPQWxwQnBDK3VCLFlBa3BCVW1vRCxXQUFVQyxXQUFZbjNFO0dBQXlDO1lBRXpFeS9ELG1CQUFrQnJ2RCxZQUFXc3FFLFdBQVVDLFdBQVUzdkU7SUFDL0MsVUF4cUJGK3hELGlCQXVxQjZCMmQsV0FBVUMsV0FBVTN2RSxNQUEvQm9GO0lBQ2hCLE9BQUE7R0FBNkQ7WUFHL0RzeUQ7SUFBYXR5RCxZQUFZNFEsT0FBT3l1RCwwQkFBMEJDLHVCQUFzQjF2RTtJQUNsRixPQTdxQ0V3ckM7YUE0cUNhcDdCO2FBQVk0UTthQUFPeXVEO2FBQTBCQzthQUFzQjF2RTtHQUNJO1lBR3BGMmlFLHVCQUE0QjNpRSxHQUFHM0osU0FBUWlsQyxLQUFJL3NCLEdBQUksT0FueEIvQzhzQixjQW14QjRCcjdCLEdBQUczSixTQUFRaWxDLEtBQUkvc0I7R0FBd0M7WUFFbkZxMEQsaUNBQXNDNWlFLEdBQUd3N0IsWUFBV0YsS0FDdEQsT0Fsd0JFQyx3QkFpd0JzQ3Y3QixHQUFHdzdCLFlBQVdGO0dBQ1A7WUFHN0NzL0M7SUFBd0J4cUUsWUFBV3BRLEdBQUczSixTQUFTMG1CLGFBQWFDO0lBQ3hEOztPQXp1QkoyMkQsK0JBd3VCbUMzekUsR0FBRzNKLFNBQVMwbUIsYUFBYUM7Z0JBR3BEOzs7S0FEVzYyRDtLQUFiRDtJQUE2QixPQWxEbkN1RyxXQWdEd0IvcEUsWUFBV3BRLEdBRTdCNHpFLGVBQWFDO0dBQ047WUFHYmdILFdBQVV6cUUsWUFBV3BRLEdBQUdDO0lBQ3BCLElBRUo2NkUsTUEvcEJBdEcsU0E0cEJxQngwRSxHQUFHQyxHQUFkbVE7ZUFHVjBxRSxRQUEyQixPQUEzQkE7UUFESzUwRSxNQUNMNDBFO0lBRGMsa0JBQVQ1MEU7R0FDeUI7WUFHOUI2MEUsZUFBYzNxRSxZQUFXcFEsR0FBR0M7SUFBUSxVQXJwQnBDdzBFLGFBcXBCeUJ6MEUsR0FBR0MsR0FBZG1RO0lBQXNCLE9BQUE7R0FBcUM7WUFPdkU0cUUsVUFBUWg3RSxHQUFHb1EsWUFBWXdmLEtBQUtpN0M7SUFDeEIsWUF4NkRKVyxRQXU2RFF4ckU7O1NBRUgyckU7S0FBYyxRQUFBLFdBRlJ2N0QsZUFFTnU3RCxVQUZrQi83QztNQUd2QixPQUFBOztJQUNLLE9BbDhETHk3QyxjQTg3RFFyckUsR0FBZTR2QixLQUFLaTdDO0dBSTBCO1lBR3REOUUsVUFBUS9sRSxHQUFJLE9BMzdEWnVyRSxrQkEyN0RRdnJFLEdBQThDO0dBWmxDLElBQUEsdUJBR3BCa2hDLE9BRUE4NUMsV0FPQWpWO1lBU0ZqQyxRQUFPMXpEO0lBQWEsV0FBYkEsWUEzV1B1b0Q7R0EyV2tFO1lBQ2xFd0ssWUFBVy95RCxZQUFXd2YsS0FBRWk3QyxNQUFJLFdBQWpCejZELGdCQUFXd2YsS0FBRWk3QztHQUEwRDtZQUNsRm9RLFNBQVU3cUU7UUFBa0J0TyxtQkFBTjYzRDtJQUFnQixXQUE1QnZwRCxZQUFZdXBELE1BQU03M0Q7O1lBQzVCbzVFLFVBQVM5cUUsWUFBV3VwRDtJQUFPLE9BRDNCc2hCLFNBQ1M3cUUsZ0JBQVd1cEQsTUFwb0NoQjczRCxPQW9vQ2dCNjNEO0dBQXFEO1lBR3pFMEosNEJBQTJCanpELFlBQVd4TDtJQUN4QyxPQUxFcTJFO2FBSTJCN3FFLFlBN3BFM0J3bUQsMEJBNnBFc0NoeUQsT0FBWHdMO0dBR3VEO1lBR2xGbXpELGtCQUFpQm56RCxZQUFXeEw7SUFFNUIsVUF2cEVBa3lELGdCQXFwRTRCbHlELE9BQVh3TDtJQUdkLE9BQUE7OztzQkFBS3VwRCxNQUFRLE9BYmhCc2hCLFNBVWlCN3FFLFlBR1R1cEQsTUFBaUM7R0FBQztZQUcxQ3doQixXQUFVL3FFLFlBQVdzZjtJQUNqQixJQUVKdEcsSUFqa0NBaW9ELFNBOGpDcUIzaEQsT0FBWHRmO2VBR1ZnWixNQUF5QixPQUF6QkE7Z0JBQUFBLE1BRFd0bkIsbUJBQU42M0Q7SUFBaUIsc0JBRlp2cEQsWUFFTHVwRCxNQUFNNzNEO0dBQ2U7WUFHMUJzNUUsb0JBQW1CaHJFLFlBQVdzZjtJQUNyQixVQXBrQ1Q0aEQsa0JBbWtDOEI1aEQsT0FBWHRmO0lBQ3FDLE9BQUE7OztzQkFBS3VwRCxNQUM3RCxPQXhCQXNoQixTQXNCbUI3cUUsWUFDMEN1cEQsTUFDcEM7R0FBQztZQUcxQjBoQixlQUFjanJFLFlBQVdzZjtJQUMzQixPQTVCRXVyRCxTQTJCYzdxRSxZQXZrQ2RtaEUsYUF1a0N5QjdoRCxPQUFYdGY7R0FDMkM7WUFHekRrckUsaUJBQWdCbHJFLFlBQVdzZjtJQUM3QixPQWhDRXVyRCxTQStCZ0I3cUUsWUFqa0NoQnFoRSxlQWlrQzJCL2hELE9BQVh0ZjtHQUd1RDtZQUd2RW1yRSxnQkFBZW5yRSxZQUFXc2YsT0FBT2h3QixNQUFNTztJQUN6QyxPQXRDRWc3RSxTQXFDZTdxRSxZQXJsQ2YrZ0UsY0FxbEMwQnpoRCxPQUFPaHdCLE1BQU1PLEdBQXhCbVE7R0FHZ0U7WUFHL0VvckUsa0JBQWlCcHJFLFlBQVdzZixPQUFPenZCO0lBQ3JDLE9BNUNFZzdFLFNBMkNpQjdxRSxZQTFsQ2pCZ2hFLGdCQTBsQzRCMWhELE9BQU96dkIsR0FBbEJtUTtHQUcwRDtZQUczRXFyRSxXQUFVcnJFLFlBQVloUTtJQUNsQixJQUVKZ3BCLElBbnlCQTBxRCxTQWd5QnNCMXpFLE9BQVpnUTtlQUdWZ1osTUFBeUIsT0FBekJBO1FBRElzeUQsY0FDSnR5RDtJQURtQixrQkFuRG5CNnhELFNBaURVN3FFLFlBRU5zckU7R0FDc0I7WUFHMUJDLGVBQWN2ckUsWUFBWWhRO0lBQzVCLE9BeERFNjZFLFNBdURjN3FFLFlBenhCZDJqRSxhQXl4QjBCM3pFLE9BQVpnUTtHQUM0QztZQUcxRGt6RCxpQ0FBa0NsekQsWUFBWWpSLEtBQUtjO0lBQ3JELE9BNURFZzdFO2FBMkRrQzdxRSxnQkEvdUVsQ2dtRCwrQkErdUU4Q2ozRCxLQUFLYyxJQUFMZDtHQUMwQjtZQUd4RXk4RSx5QkFBd0J4ckUsWUFBV3kyQjtJQUduQyxVQXIvREE0a0MsdUJBay9EbUM1a0MsS0FBWHoyQjtJQUVyQixPQUFBOzs7MkIsT0FqRUg2cUUsU0ErRHdCN3FFO0dBR3FEO1lBRzdFcXpELGNBQWFyekQsWUFBV3kyQjtJQUNwQixJQUVKemQsSUE1bENBNGQsWUF5bEN3QkgsS0FBWHoyQjtlQUdiZ1osTUFBeUIsT0FBekJBO2dCQUFBQSxNQURXdG5CLG1CQUFONjNEO0lBQWlCLHNCQUZUdnBELFlBRVJ1cEQsTUFBTTczRDtHQUNlO1lBRzFCKzVFLHVCQUFzQnpyRSxZQUFXeTJCO0lBQ3hCLFVBL2xDVGdyQyxxQkE4bENpQ2hyQyxLQUFYejJCO0lBQ21DLE9BQUE7OztzQkFBS3VwRCxNQUM5RCxPQTdFQXNoQixTQTJFc0I3cUUsWUFDd0N1cEQsTUFDckM7R0FBQztZQUcxQm1pQixrQkFBaUIxckUsWUFBV3kyQjtJQUM5QixPQWpGRW8wQyxTQWdGaUI3cUUsWUFsbUNqQjBoRSxnQkFrbUM0QmpyQyxLQUFYejJCO0dBQ3lDO1lBRzFEMnJFLG9CQUFtQjNyRSxZQUFXeTJCO0lBQ2hDLE9BckZFbzBDLFNBb0ZtQjdxRSxZQXBtQ25CMmhFLGtCQW9tQzhCbHJDLEtBQVh6MkI7R0FHcUQ7WUFHeEU0ckUsbUJBQWtCNXJFLFlBQVd5MkIsS0FBS25uQyxNQUFNTztJQUMxQyxPQTNGRWc3RSxTQTBGa0I3cUUsWUFobkNsQnVoRSxpQkFnbkM2QjlxQyxLQUFLbm5DLE1BQU1PLEdBQXRCbVE7R0FHOEQ7WUFHaEY2ckUscUJBQW9CN3JFLFlBQVd5MkIsS0FBSzVtQztJQUN0QyxPQWpHRWc3RSxTQWdHb0I3cUUsWUFybkNwQndoRSxtQkFxbkMrQi9xQyxLQUFLNW1DLEdBQWhCbVE7R0FHd0Q7WUFHNUU2eUQsbUJBQWtCN3lELFlBQVdzcUUsV0FBVUMsV0FBVTN2RTtJQUNuRCxPQXZHRWl3RTthQXNHa0I3cUU7YUFoMEJsQjJzRCxpQkFnMEI2QjJkLFdBQVVDLFdBQVUzdkUsTUFBL0JvRjtHQUM4RDtZQUdoRjhyRSxXQUFVOXJFLFlBQVdwUSxHQUFHQztJQUNwQixJQUVKNjZFLE1BeHlCQXRHLFNBcXlCcUJ4MEUsTUFBR0MsR0FBZG1RO2VBR1YwcUUsUUFBMkIsT0FBM0JBO1FBREkzSCxPQUNKMkg7SUFEWSxrQkE1R1pHLFNBMEdVN3FFLFlBRU4raUU7R0FDMEI7WUFHOUJnSixlQUFjL3JFLFlBQVdwUSxHQUFHQztJQUM5QixPQWpIRWc3RSxTQWdIYzdxRSxZQTl4QmRxa0UsYUE4eEJ5QnowRSxNQUFHQyxHQUFkbVE7R0FDK0M7O0lBSW5ELElBQVI4d0Isa0JBbGVGeTNCO0lBaWV5RCxXQUN2RHozQjs7WUFXSjJpQyxhQUEwQjdqRSxHQUM1QixJQUlNb1EsYUFMc0JwUSxNQUNwQixXQUlGb1EsWUFDRjtZQUtGZ3NFLFVBQXNCOWpFO0ksZ0JBQWtDcWhELE1BQzFELE9BcnhCRXFKLFVBb3hCc0IxcUQsTUFBa0NxaEQsTUFDckI7O1lBR25DdUwsUUFONEIxckQsR0FNbEIsT0FqSlJzcUQsUUEySTBCdHFELE1BTWtDO1lBQzlEdXFELFlBUDRCdnFELEdBT2hCcFc7SUFBSSxVQVBZb1c7SUFPWixxQixPQWpKZDJwRCxpQkFpSlUvL0Q7R0FBOEQ7WUFDMUVpNUUsV0FSNEI3aUUsR0FRakJwVyxHQUFJLE9BakliKzNFLFdBeUgwQjNoRSxNQVFqQnBXLEdBQTZEO1lBRXhFazVFLG9CQVY0QjlpRSxHQVVScFcsR0FDdEIsT0E5SElnNEUsb0JBbUgwQjVoRSxNQVVScFcsR0FDNEM7WUFHaEVtNUUsZUFkNEIvaUUsR0FjYnBXLEdBQUksT0E1SGpCaTRFLGVBOEcwQjdoRSxNQWNicFcsR0FBaUU7WUFDaEZvNUUsaUJBZjRCaGpFLEdBZVhwVyxHQUFJLE9BekhuQms0RSxpQkEwRzBCOWhFLE1BZVhwVyxHQUFtRTtZQUVwRnE1RSxnQkFqQjRCampFLEdBaUJacFcsR0FBRzFELE1BQU1PO0lBQzNCLE9BdEhJczdFLGdCQW9HMEIvaEUsTUFpQlpwVyxHQUFHMUQsTUFBTU87R0FDNEM7WUFHckV5OEUsa0JBckI0QmxqRSxHQXFCVnBXLEdBQUduRCxHQUN2QixPQXBISXU3RSxrQkE4RjBCaGlFLE1BcUJWcFcsR0FBR25ELEdBQzRDO1lBR2pFZ2tFLDRCQXpCNEJ6cUQsR0F5QkFwVztJQUM5QixPQS9KSWlnRSw0QkFxSTBCN3BELE1BeUJBcFc7R0FDNEM7WUFHeEUrZ0Usa0JBN0I0QjNxRCxHQTZCVnBXLEdBQUksT0E1SnBCbWdFLGtCQStIMEIvcEQsTUE2QlZwVyxHQUFvRTtZQUN0RnU1RSxXQTlCNEJuakUsR0E4QmhCcFosT0FBUSxPQXRIbEJxN0UsV0F3RjBCamlFLE1BOEJoQnBaLE9BQXNFO1lBRWxGdzhFLGVBaEM0QnBqRSxHQWdDWnBaLE9BQ2xCLE9BbkhJdTdFLGVBa0YwQm5pRSxNQWdDWnBaLE9BQ2dEO1lBR2hFOGpFLGlDQXBDNEIxcUQsR0FvQ1FyYSxLQUFLYztJQUMzQyxPQW5ISXFqRSxpQ0E4RTBCOXBELE1Bb0NRcmEsS0FBS2M7R0FDNEM7WUFHckY0OEUseUJBeEM0QnJqRSxHQXdDSHF0QjtJQUMzQixPQW5ISSswQyx5QkEwRTBCcGlFLE1Bd0NIcXRCO0dBQzhDO1lBR3ZFdzlCLGNBNUM0QjdxRCxHQTRDZDliLEdBQUksT0FoSGhCK2xFLGNBb0UwQmpxRCxNQTRDZDliLEdBQWdFO1lBRTlFby9FLHVCQTlDNEJ0akUsR0E4Q0w5YjtJQUN6QixPQTdHSW0rRSx1QkE4RDBCcmlFLE1BOENMOWI7R0FDNEM7WUFHbkVxL0Usa0JBbEQ0QnZqRSxHQWtEVjliLEdBQUksT0EzR3BCbytFLGtCQXlEMEJ0aUUsTUFrRFY5YixHQUFvRTtZQUV0RnMvRSxvQkFwRDRCeGpFLEdBb0RSOWIsR0FDdEIsT0ExR0lxK0Usb0JBcUQwQnZpRSxNQW9EUjliLEdBQzRDO1lBR2hFdS9FLG1CQXhENEJ6akUsR0F3RFQ5YixHQUFHZ0MsTUFBTU87SUFDOUIsT0F4R0krN0UsbUJBK0MwQnhpRSxNQXdEVDliLEdBQUdnQyxNQUFNTztHQUM0QztZQUd4RWk5RSxxQkE1RDRCMWpFLEdBNERQOWIsR0FBR3VDO0lBQzFCLE9BdEdJZzhFLHFCQXlDMEJ6aUUsTUE0RFA5YixHQUFHdUM7R0FDNEM7WUFHcEVrOUUsV0FoRTRCM2pFLEdBZ0VqQnhaLEdBQUdDLEdBQUksT0EvRmhCaThFLFdBK0IwQjFpRSxNQWdFakJ4WixHQUFHQyxHQUFnRTtZQUM5RW05RSxlQUFhNWpFLEdBQUV4WixHQUFHQyxHQUFJLE9BMUZwQms4RSxlQTBGVzNpRSxNQUFFeFosR0FBR0MsR0FBb0U7aUJBTTFGLFdBRUc7WUFnQ0N3a0UsWUFBOEI0WTtJLGdCQUErQmxHLFdBQVVuM0U7S0FDekUsT0Fub0JJdTFDLFlBa29CNEI4bkMsTUFBK0JsRywyQkFDckIsV0FBYSxHQURrQm4zRSxHQUNmOztZQUd4RDJrRSxZQUVVMFk7SSxnQkFDUjFDLFdBQ0EzdkU7S0FFSixPQXRKSWk0RCxtQkFrSlFvYSxNQUFBQSxNQUNSMUMsV0FDQTN2RSxNQUVpRjs7WUFHbkY0NUQsaUJBRVV5WTtJLGdCQUNQQztLQUdMLHVCQUpZRCxVQUNQQyxrQkFNSjs7WUFHQ3pZLG1CQUFvQzBZLFdBQVVuOEUsSUFBR0MsSUFBSyxPQTl3QnBEbTlELGVBOHdCa0MrZSxXQUFVbjhFLElBQUdDO0dBQW1DO1lBQ3BGeWpFLGlCQUFnQzBZLFNBQVFwOEUsSUFBR0MsSUFBSyxPQTN3QjlDdkksUUEyd0I4QjBrRixTQUFRcDhFLElBQUdDO0dBQXdCO1lBRW5FMGpFLGNBQWdDc1k7SSxnQkFBaUNJLGFBQVl4M0U7S0FDL0UsVUFEa0NvM0U7S0FDbEM7TSxPQTlvQkk3ZCxzQkE2b0IrRGllLGFBQVl4M0UsY0FDL0I7O09BVTVDZy9EO1lBQ0F5WSxVQUFRL2pCLE1BQU8sV0FEZnNMLGNBQ1F0TCxNQTc1Q0o3M0QsT0E2NUNJNjNELE9BQXVEOzs7SUFySzdEZ2tCO1lBeUtGeFksWUFBVS9oRTtJQUFJLHFCLE9BL1JkKy9ELFlBMFJBOEIsY0FLVTdoRTtHQUE0QztZQUN0RHc2RSxXQUFTeDZFLEdBQUksT0EvUWIrM0UsV0F5UUFsVyxjQU1TN2hFLEdBQTJDO1lBQ3BEeTZFLG9CQUFrQno2RTtJQUFJLE9BMVF0Qmc0RSxvQkFtUUFuVyxjQU9rQjdoRTtHQUFvRDtZQUN0RTA2RSxlQUFhMTZFLEdBQUksT0F0UWpCaTRFLGVBOFBBcFcsY0FRYTdoRSxHQUErQztZQUM1RDI2RSxpQkFBZTM2RSxHQUFJLE9BblFuQms0RSxpQkEwUEFyVyxjQVNlN2hFLEdBQWlEO1lBQ2hFNDZFLGdCQUFjNTZFLEdBQUcxRCxNQUFNTztJQUFJLE9BOVAzQnM3RSxnQkFvUEF0VyxjQVVjN2hFLEdBQUcxRCxNQUFNTztHQUF5RDtZQUNoRmcrRSxrQkFBZ0I3NkUsR0FBR25EO0lBQUksT0F6UHZCdTdFLGtCQThPQXZXLGNBV2dCN2hFLEdBQUduRDtHQUFxRDtZQUV4RW9sRSw0QkFBMEJqaUU7SUFDNUIsT0FuU0VpZ0UsNEJBcVJBNEIsY0FhMEI3aEU7R0FDNEI7WUFHdERtaUUsa0JBQWdCbmlFLEdBQUksT0FoU3BCbWdFLGtCQStRQTBCLGNBaUJnQjdoRSxHQUFrRDtZQUNsRTg2RSxXQUFVOTlFLE9BQVEsT0ExUGxCcTdFLFdBd09BeFcsY0FrQlU3a0UsT0FBb0Q7WUFDOUQrOUUsZUFBYy85RSxPQUFRLE9BclB0QnU3RSxlQWtPQTFXLGNBbUJjN2tFLE9BQXdEO1lBRXRFa2xFLGlDQUFrQ25tRSxLQUFLYztJQUN6QyxPQXBQRXFqRSxpQ0E4TkEyQixjQXFCa0M5bEUsS0FBS2M7R0FDNEI7WUFHbkVtK0UseUJBQXVCdjNDO0lBQU0sT0FuUDdCKzBDLHlCQTBOQTNXLGNBeUJ1QnArQjtHQUE2RDtZQUNwRjQrQixjQUFZL25FLEdBQUksT0E5T2hCK2xFLGNBb05Bd0IsY0EwQll2bkUsR0FBOEM7WUFDMUQyZ0YsdUJBQXFCM2dGO0lBQUksT0F6T3pCbStFLHVCQThNQTVXLGNBMkJxQnZuRTtHQUF1RDtZQUM1RTRnRixrQkFBZ0I1Z0YsR0FBSSxPQXJPcEJvK0Usa0JBeU1BN1csY0E0QmdCdm5FLEdBQWtEO1lBQ2xFNmdGLG9CQUFrQjdnRjtJQUFJLE9BbE90QnErRSxvQkFxTUE5VyxjQTZCa0J2bkU7R0FBb0Q7WUFFdEU4Z0YsbUJBQWlCOWdGLEdBQUdnQyxNQUFNTztJQUM1QixPQS9ORSs3RSxtQkErTEEvVyxjQStCaUJ2bkUsR0FBR2dDLE1BQU1PO0dBQzRCO1lBR3REdytFLHFCQUFtQi9nRixHQUFHdUM7SUFBSSxPQTVOMUJnOEUscUJBeUxBaFgsY0FtQ21Cdm5FLEdBQUd1QztHQUF3RDtZQUM5RXkrRSxXQUFTMStFLEdBQUdDLEdBQUksT0FuTmhCaThFLFdBK0tBalgsY0FvQ1NqbEUsR0FBR0MsR0FBOEM7WUFDMUQwK0UsZUFBYTMrRSxHQUFHQyxHQUFJLE9BOU1wQms4RSxlQXlLQWxYLGNBcUNhamxFLEdBQUdDLEdBQWtEOzs7Ozs7T0E3N0JsRXc5RDtPQSt2QkZvRztPQWx3QkV6ekQ7T0FpeEJGODBEO09BQ0FuQjtPQUNBc1k7T0FFQUM7T0FJQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FTQUM7T0FFQUM7T0FIQXpZO09BSkFGO09BV0FDO09BSUEyWTtPQUlBeFk7T0FFQXlZO09BSUFDO09BRUFDO09BSUFDO09BSUFDO09BaDBCRTVqRTtPQUNBRjtPQUVBMjdEO09BNEJBNWtEO09BeEJBNmtEO09BOEJBQztPQU1BQztPQUlBQztPQUVBQztPQUlBQztPQVlBeDdEO09BUkFrVztPQVVBb3VDO09BTUFsdUM7T0FDQXFsRDtPQUNBcDhEO09BQ0F1bEI7T0FDQTgyQztPQUNBdlg7T0FDQXR2RDtPQUNBMndDO09Bb3ZCRjg5QjtPQUNBQztPQXB2QkU1SDtPQUNBcjdEO09BQ0E0akQ7T0FFQTBYO09BSUFDO09BQ0F6WDtPQUNBMFg7T0FDQTNVO09BQ0E0VTtPQUVBQztPQUlBQztPQUlBQztPQUlBalg7T0FJQWtYO09BU0F4WDtPQW9JQWdCO09BaElBMW1FO09BQ0FtOUU7T0FDQS9JO09BQ0FnSjtPQWdCQUU7T0FJQUM7O09BbEJBOVg7T0FJQTRYO09BMkJBbjhEO09BQ0EyakQ7T0FDQTFqRDtPQUNBMmpEO09BQ0Fqa0Q7T0FDQW9sQjtPQUNBcmxCO09BQ0FvbEI7T0FDQXJsQjtPQUNBb2xCO09BRUFzZjtPQWlDQTA0QjtPQWxCQUw7T0FrQ0FNO09BSUFDO09BSUFDO09BSUF6VTtPQUNBMWdEO09BQ0FvMUQ7T0FHQTdYO09BU0FDO09BRUFDO09BUUFnWTs7T0E2bUJGN1M7T0FJQUU7T0FTQUM7T0FZQUM7T0FDQUM7T0FFQUM7O1FBOXBCRXh2QjtRQXNmQTB0Qjs7U0EzSkF4TjtTQUVBZ0s7U0F6VEF5RDtTQUVBdjlCO1NBMlVBazFDO1NBTUFFO1NBdFVBeEQ7U0FNQUM7U0FJQUM7U0FFQUM7U0FJQUM7U0FJQUM7U0F6QkExVjtTQUpBRjtTQXlDQUM7U0FJQStWO1NBTUFsVztTQU1BbVc7U0FJQUM7U0FFQUM7U0FJQUM7U0FJQUM7U0F0Q0FSO1NBTUFDO1NBMUNBaFM7U0FnRkFwRztTQUlBQztTQUNBdG1EO1NBaUJBNmtEO1NBWEFxYTtTQUpBRDtTQW9CQUU7U0FLQUM7U0FJQUM7U0FJQUM7U0FJQUM7U0FZQW5ZO1NBUkFDO1NBVUFXO1NBSUFGO1NBQ0EwWDtTQUNBMS9EO1NBQ0F1bEI7U0FDQW82QztTQUVBNVg7U0FJQXBxRDtTQUNBaWlFO1NBQ0FDO1NBQ0FuWTtTQUNBQztTQUVBbVk7U0FJQUM7U0FJQW5ZO1NBSUFvWTtTQUlBdlY7U0FJQXdWO1NBSUFDO1NBT0FDO1NBT0FDO1NBT0F0WTtTQU9BdVk7U0FTQTlYO1NBSUEvbkU7U0FJQTgvRTtTQUNBQztTQUNBQztTQWdCQUU7U0FJQUM7U0FsQkFyWTtTQUlBbVk7U0EyQkEvWjtTQUNBQztTQUNBQztTQUNBQztTQUNBTTtTQUNBeVo7U0FDQTFaO1NBQ0EyWjtTQUNBelo7U0FDQTBaO1NBQ0EzWDtTQUVBNFg7U0FJQUM7U0FXQUM7U0FVQUM7U0FJQUM7U0FJQUM7U0FDQUM7U0FDQUM7U0F2T0ExWDtTQThPQUw7U0FJQUM7U0FFQUM7U0FJQWdZO1NBeFVBamlCOztRQWxSQThFO1FBSUFua0Q7UUFDQUY7UUE4QkErVztRQXhCQTZrRDtRQUpBRDtRQWtDQUU7UUFNQUM7UUFJQUM7UUFFQUM7UUFJQUM7UUFZQXg3RDtRQVJBa1c7UUFVQW91QztRQU1BbHVDO1FBQ0FxbEQ7UUFDQXA4RDtRQUNBdWxCO1FBQ0E4MkM7UUFDQXZYO1FBQ0F0dkQ7UUFDQTJ3QztRQUNBbTJCO1FBQ0FyN0Q7UUFDQTRqRDtRQUVBMFg7UUFJQUM7UUFDQXpYO1FBQ0EwWDtRQUNBM1U7UUFDQTRVO1FBRUFDO1FBSUFDO1FBSUFDO1FBSUFqWDtRQUlBa1g7UUFTQXhYO1FBSUExbEU7UUFDQW05RTtRQUNBL0k7UUFDQWdKO1FBZ0JBRTtRQUlBQztRQWxCQTlYO1FBSUE0WDtRQTJCQW44RDtRQUNBMmpEO1FBQ0ExakQ7UUFDQTJqRDtRQUNBamtEO1FBQ0FvbEI7UUFDQXJsQjtRQUNBb2xCO1FBQ0FybEI7UUFDQW9sQjtRQUVBc2Y7UUFpQ0EwNEI7UUFsQkFMO1FBa0NBTTtRQUlBQztRQUlBQztRQUlBelU7UUFDQTFnRDtRQUNBbzFEO1FBaFBBN2Q7UUFtUEFnRztRQVNBQztRQUVBQztRQVFBZ1k7UUF5WEF4VDtRQUNBWDtRQTJHQStZO1FBTUFDO1FBaEdBaEI7UUFNQUM7UUFLQUM7UUFJQUM7UUFNQUM7UUFNQUM7UUFqQ0FqWTtRQU5BRjtRQXVEQUM7UUFJQXNZO1FBTUFuWTtRQU1Bb1k7UUFLQUM7UUFJQUM7UUFNQUM7UUFNQUM7UUEvQ0FSO1FBTUFFO1FBdERBVDtRQW5vQkE5cUU7UUFtUUFvdkQ7OztRQW9mRW1lO1FBeUtGeFk7UUErQkF1WjtRQUNBQztRQS9CQWY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFNQTFZO1FBSkFGO1FBUUFDO1FBSUE4WTtRQUNBM1k7UUFDQTRZO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBSUFDO1FBakJBUDtRQUNBQztRQWxCQVQ7UUF6NUJBamdCO1FBSUFua0Q7UUFDQUY7UUE4QkErVztRQXhCQTZrRDtRQUpBRDtRQWtDQUU7UUFNQUM7UUFJQUM7UUFFQUM7UUFJQUM7UUFZQXg3RDtRQVJBa1c7UUFVQW91QztRQU1BbHVDO1FBQ0FxbEQ7UUFDQXA4RDtRQUNBdWxCO1FBQ0E4MkM7UUFDQXZYO1FBQ0F0dkQ7UUFDQTJ3QztRQUNBbTJCO1FBQ0FyN0Q7UUFDQTRqRDtRQUVBMFg7UUFJQUM7UUFDQXpYO1FBQ0EwWDtRQUNBM1U7UUFDQTRVO1FBRUFDO1FBSUFDO1FBSUFDO1FBSUFqWDtRQUlBa1g7UUFTQXhYO1FBSUExbEU7UUFDQW05RTtRQUNBL0k7UUFDQWdKO1FBZ0JBRTtRQUlBQztRQWxCQTlYO1FBSUE0WDtRQTJCQW44RDtRQUNBMmpEO1FBQ0ExakQ7UUFDQTJqRDtRQUNBamtEO1FBQ0FvbEI7UUFDQXJsQjtRQUNBb2xCO1FBQ0FybEI7UUFDQW9sQjtRQUVBc2Y7UUFpQ0EwNEI7UUFsQkFMO1FBa0NBTTtRQUlBQztRQUlBQztRQUlBelU7UUFDQTFnRDtRQUNBbzFEO1FBaFBBN2Q7UUFtUEFnRztRQVNBQztRQUVBQztRQVFBZ1k7T0FzZ0JGOEU7T0E1d0JFaGpCOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDM3FERmw2RDtJQUNBZ3NEO0lBQ0ExckQ7SUFDQXVVO0lBQ0FqUztJQUNBcW1FO0lBQ0E3YjtJQUNBSDtJQUNBeXlCO1lBQ0F6K0UsS0FBS0gsR0FBR0MsR0FBSSxPQUFBLDZCQUFKQSxHQUFIRCxHQUEwQjtZQUMvQkQsS0FBS0MsR0FBR04sTUFBTU8sR0FBSSxPQUFBLDZCQUFKQSxHQUFOUCxNQUFITSxHQUFxQzs7OztPQVYxQ2Q7T0FDQWdzRDtPQUNBMXJEO09BQ0F1VTtPQUNBalM7T0FDQXFtRTtPQUNBN2I7T0FDQUg7T0FDQXl5QjtPQUNBeitFO09BQ0FKOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDWEE4bkUsUUFBUTduRSxHQUFFMVEsR0FBSSxPQUFBLGtDQUFKQSxHQUFGMFEsR0FBNEI7WUFDcENnb0UsUUFBUWhvRTtJQUFJLE9BQUcscUJBQVBBOztrQkFBc0Msa0NBQXRDQTtHQUEyRDtPQUNuRStuRTtZQUNBSSxLQUFLbm9FO0lBQUksT0FBRyxxQkFBUEE7O2tCQUFzQyxrQ0FBdENBO0dBQTREO0dBT3REO0lBTlhvb0U7SUFNSWx2RDtJQUNBRTs7OztrQkFEQUYsUUFDQUU7SUFLSmhCO0lBQ0FsVztJQUNBOFc7SUFDQUQ7SUFDQVI7SUFDQUc7SUFDQW5XO0lBQ0F1VztJQUNBdUI7SUFDQXpCO0lBQ0FQO0lBQ0F2WTtJQUNBeXRCO0lBQ0EvSTtJQUNBSjtJQUNBSDtJQUNBeUY7SUFDQW5GO0lBQ0Fua0I7WUFDQXcrRSxTQUFVaGpELEtBQUtFO0lBQU0sT0FBQSxrQ0FBWEYsS0FBS0U7R0FBb0M7WUFFbkRsUixXQUFXNXFCLEdBQUdDO0lBQ04sSUFBTmlELE1BQU07SUFDVjs7TUFGYWxEO2VBRUVvRDtPQUFlLFVBQUEsV0FGZG5ELEdBRURtRDtPQUF3QixPQUFBOzRDQUFLQyxHQUFLLE9BdkMvQ3drRSxRQXNDRTNrRSxLQUN3Q0csR0FBa0I7TUFBQztJQUEvRCxPQURJSDtHQUVEO1lBR0QybkIsWUFBWTdxQixHQUFHQztJQUNQLElBQU5pRCxNQUFNO0lBQ1Y7TUFYRTlDO01BU1lKO2VBRUUvRyxHQUFFbUs7T0FBZSxVQUFBLFdBRmhCbkQsR0FFRGhILEdBQUVtSztPQUEwQixPQUFBOzRDQUFLQyxHQUFLLE9BN0NwRHdrRSxRQTRDRTNrRSxLQUM2Q0csR0FBa0I7TUFBQztJQUFwRSxPQURJSDtHQUVEO1lBR0R3cUIsV0FBVzF0QixHQUFHQztJQUNOLElBQU5pRCxNQUFNO0lBQ1Y7O01BRmFsRDtlQUVFb0Q7T0FDUCxZQUFBLFdBSFFuRCxHQUVEbUQ7bUJBRUg7V0FDSEM7T0FBSyxPQXREWndrRSxRQWtERTNrRSxLQUlLRztNQUFrQjtJQUgzQixPQURJSDtHQUtEO1lBR0QycUIsWUFBWTd0QixHQUFHQztJQUNQLElBQU5pRCxNQUFNO0lBQ1Y7TUExQkU5QztNQXdCWUo7ZUFFRS9HLEdBQUVtSztPQUNWLFlBQUEsV0FIU25ELEdBRURoSCxHQUFFbUs7bUJBRU47V0FDSEM7T0FBSyxPQS9EWndrRSxRQTJERTNrRSxLQUlLRztNQUFrQjtJQUgzQixPQURJSDtHQUtEO1lBR0QwZ0IsT0FBTzVqQixHQUFHQztJQUNGLElBQU5pRCxNQUFNO0lBQ1Y7O01BRlNsRDtlQUVNb0Q7T0FBUSxVQUFBLFdBRlhuRCxHQUVHbUQ7T0FBUSxhQXJFckJ5a0UsUUFvRUUza0UsS0FDV0U7TUFBOEI7SUFBN0MsT0FESUY7R0FFRDtZQUdEeW1CLFFBQVEzcEIsR0FBR0M7SUFDSCxJQUFOaUQsTUFBTTtJQUNWO01BekNFOUM7TUF1Q1FKO2VBRU0vRyxHQUFFbUs7T0FBUSxVQUFBLFdBRmJuRCxHQUVHaEgsR0FBRW1LO09BQVEsYUEzRXhCeWtFLFFBMEVFM2tFLEtBQ2NFO01BQWdDO0lBQWxELE9BRElGO0dBRUQ7WUFHRDdDLElBQUlMLEdBQUdDO0lBQ0MsSUFBTmlELE1BQU07SUFDVixpQkFGTWxELFlBRVNvRCxHQUFLLE9BakZsQnlrRSxRQWdGRTNrRSxLQUM0QixXQUZ2QmpELEdBRU1tRCxJQUFzQjtJQUFyQyxPQURJRjtHQUVEO1lBR0Q1QyxLQUFLTixHQUFHQztJQUNBLElBQU5pRCxNQUFNO0lBQ1Y7TUFyREU5QyxPQW1ES0osWUFFUy9HLEdBQUVtSyxHQUFLLE9BdkZyQnlrRSxRQXNGRTNrRSxLQUMrQixXQUZ6QmpELEdBRU1oSCxHQUFFbUssSUFBd0I7SUFBMUMsT0FESUY7R0FFRDtZQUdEMGxFLGVBQWVpVyxHQUFHNStFO0lBQ1gsSUFBTDYrRSxNQXpCRmw3RCxPQXdCZWk3RCxHQUFHNStFO0lBRXBCLGtCQUZpQjQrRTtJQUVqQixPQTFERUQsU0F5REVFLEtBRGFEO0dBR007WUFHckJoVyxnQkFBZ0JnVyxHQUFHNStFO0lBQ1osSUFBTDYrRSxNQXpCRm4xRCxRQXdCZ0JrMUQsR0FBRzUrRTtJQUVyQixrQkFGa0I0K0U7SUFFbEIsT0FoRUVELFNBK0RFRSxLQURjRDtHQUdLO1lBR3JCblcsWUFBWTFvRSxHQUFFc0U7SUFBTyxPQUFrQix5QkFBekJBLGVBQThCaFYsR0FBSyxPQXZHakR1NEUsUUF1R1k3bkUsR0FBZ0MxUSxHQUFnQjtHQUFDO1lBRTdEc1EsUUFBUTBFO0lBQ0YsSUFBSnRFLElBQUk7SUFDUix5QkFGVXNFLGVBRWFoVixHQUFLLE9BM0cxQnU0RSxRQTBHRTduRSxHQUNtQjFRLEdBQWdCO0lBQXZDLE9BREkwUTtHQUVIO1lBR0NrdEMsU0FBU3RvQztJQUNILElBQUo1RSxJQUFJO0lBQ1IsMEJBRlc0RSxnQkFFY3RWLEdBQUssT0FqSDVCdTRFLFFBZ0hFN25FLEdBQ3FCMVEsR0FBZ0I7SUFBekMsT0FESTBRO0dBRUg7WUFHQ04sS0FBS1AsS0FBS2M7SUFDWjtLQUFJRCxJQUFJO0tBQ0ssTUFBQSw0QkFGTmI7S0FDQzs7U0FDUmxHOztNQXZIRTR1RSxRQXNIRTduRSxHQUVRLFdBSEFDLEdBRVpoSDtNQUNFLFVBREZBO2lCQUFBQTtNQUFBQTs7O0lBR0EsT0FKSStHO0dBSUg7WUFHQ2laLFNBQVNqWjtJQUNMLElBRUpiLE1BRkksbUJBREthO2FBR1RiLEtBREs7SUFFdUI7S0FBQSxNQUFBLFdBN0g1QmlwRSxVQXlIU3BvRTtLQUlMMHhCLE1BQU0sMkJBRFZ2eUI7S0FFSWxHO0lBQ0o7O01BTlMrRztlQU1NdU87T0FDYixVQUZFdFY7T0FFRix5QkFIRXk0QixxQkFFV25qQjtPQUFmLE9BQUEsNkJBREl0VjtNQUdJO0lBRlIsT0FGSXk0QjtHQUtEO1lBR0hoaEIsVUFBVXlzQixXQUFVbnlCO0lBQU8sT0FoQzNCcEwsUUFnQ21DLDZCQUF6QnU5QixXQUFVbnlCO0dBQTRDO1lBQ2hFbEIsVUFBVTBRLFdBQVV4YTtJQUEyQixVQUFBLFdBL0cvQ0YsU0ErR29CRTtJQUEyQixPQUFBLDZCQUFyQ3dhO0dBQWdEO1lBRTFENVEsZUFBeUJ1akM7SUFHRSxVQUFBLHlCQUhGQTtJQUdFLE9BQUE7R0FBNkI7WUFHeER4SCxVQUFVdmlDO0lBQ0osSUFBSnBELElBQUk7SUFuSk42bkUsUUFtSkU3bkUsR0FEUW9EO0lBRVosT0FESXBEO0dBRUg7Ozs7T0FaQzBRO09BQ0E1RztPQUVBRjtPQXBIQXlROzs7OztPQUpBOUI7T0FDQUc7T0FKQXhXO09BS0FLO09BTkE2VjtPQVVBQztPQVJBVztPQUNBRDtPQVFBalo7T0FrR0FtWjtPQXBHQUw7T0FGQUU7T0FTQTRRO09BRUF0cEI7T0FMQW9rQjtPQUlBRDtPQUxBZ0o7T0FHQXRKO09BREFHO09Bb0hBdWhCO09BekNBL2xDO09BTUFzdEM7T0FNQXh0QztPQXJIQW1vRTtPQXVHQWE7T0F0R0FWO09BQ0FEO09BQ0FJO09BQ0FDOzs7T0EyRUEvbkU7T0FNQUM7T0FoREFzcUI7T0FNQUM7T0FNQTZDO09BU0FHO09BU0FqSztPQU1BK0Y7T0FrQkFpL0M7T0FNQUM7O09BOURBK1Y7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQ3lNSXYwRTtJQU9BMDdDOzs7Ozs7Ozs7Ozs7Ozs7O0lBaFBEcmdEO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsd0JBTURTO1lBT0F6VCxrQjtHQUFVO0lBa1FOaUw7SUFEQUM7aURBalFKbEwsU0FQQXlUOztJQWVGQztJQUNBazhDLG9CQUFvQiw0QkFEcEJsOEM7SUFFQW04QyxvQkFBb0IsNEJBRnBCbjhDO0lBR0FnMUU7SUFDQUM7SUFDQTUzQjtJQUNBbGlCO0lBQ0FtaUI7SUEwUEVDO0lBeFBGRztJQUNBRjtJQUNBQztJQUNBN2xEO0lBQ0FEO0lBeU5Fd2xEO0lBdk5GcnNCO0lBQ0FqNUI7SUFDQThsRDtJQUNBUDtJQUNBYjtJQUNBMGlCO0lBQ0Fqa0I7SUFxTkVxQjtJQW5ORjVrRDtJQUNBMmtEOzs7Ozs7O1lBRUExa0QsU0FBU3hCO0lBQ1g7TUFBRyxnQ0FEUUEsR0F6QlRnbUQ7U0EyQkMsZ0NBRlFobUQsR0F4QlRpbUQ7S0EyQkcsT0FBQSxvQkFITWptRDtJQU9QLFVBQUEsNEJBUE9BO0lBS1QsT0FBQTtHQUdJO1lBZ01GbFEsT0E3TEtzVCxHQUFFd0IsR0FBSSxPQUFBLFdBcEJiNmlELEtBb0JPcmtELEdBQUV3QixHQUFXO1lBSUpvNkUsUUFBUTN2RjtJQUFJLE9BQUEsK0JBQStCLGlCQUFuQ0E7R0FBaUQ7WUFFekQ0dkYsUUFBUTV2RjtJQUsxQixPQUFBLCtCQUErQixpQkFMTEE7R0FLbUI7WUFHM0I2dkYsUUFBUTd2RjtJQUFJLE9BQUEsK0JBQStCLGlCQUFuQ0E7R0FBaUQ7O29EQTNEdkUrRyxTQVBBeVQsV0F5UEFzOEM7Ozs7Ozs7Ozs7WUExS0Z2OEMsaUJBQW9CLFNBQUU7WUFDdEJvdkIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU87S0FBQSxNQUFBLGVBQVpELEtBQUhsNUI7S0FBZSxZQUFZLGVBQTNCQSxHQUFRbTVCO0lBQW1CO0dBQVM7WUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7SUFBTSxPQUFHLGNBQWpCd1EsR0FBR3ZRLE9BQUFBLE1BQXVDLGVBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxlQURRQyxLQUFLRCxNQUVwQixPQUpFNHBDLGdCQUVVcDVCLEdBQUd2USxLQUFLRDtJQUNwQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBQ2hCLEtBQUcsaUJBRFFDLEtBQUtELE1BT1gsV0FkSDRwQyxnQkFPTXA1QixHQUFHdlEsS0FBS0Q7SUFNVDs0QkFBaUMsV0E5RnBDc2EsV0F3Rll0YTtLQU1ULHVCQUFTLFdBOUZac2EsV0F3Rk9yYTtLQUlQLE1BQUE7SUFBQSxPQUFBO0dBR2lDO1lBR25DNE4sS0FBS29LLEdBQUFBLE9BQVMsZUFBVEEsTUE5RExzOUMsZUE4RHdCO1lBQ3hCM25ELEtBQUtxSyxHQUFBQSxPQUFTLGVBQVRBLE1BL0RMczlDLGVBK0R3QjtZQUl4QjhCLGtCO1lBQ0FDLFNBQVM5bUQsR0FBSSxPQUFKQSxFQUFLO0dBV0Q7SUFWYnFvRDtJQWlKRWxuRDtJQXRJRkw7SUFDQW1zRDtJQUNBeEc7SUFDQUM7SUFDQUM7SUFDQUk7SUFFQUU7SUFDQW00QjtJQU1FN25EOzs7Ozs7O1lBRUFvd0I7SUFDRixPQUFBO0dBQTJEO1lBUXpEQyxVQUFVdDREO0lBQ1osR0FBRyxlQURTQSxxQkFUVnE0RDtJQVdNO0tBQUp0eEMsTUFBSSw0QkFGSS9tQjtLQUdSMDRELG9CQURBM3hDLG9DQUFBQTtLQUVBMHhDLG9CQURBQyxvQ0FBQUE7S0FFQUYsb0JBREFDLG9DQUFBQTtLQUVBRixvQkFEQUMsb0NBQUFBO0tBRUFsQyxvQkFEQWlDLG9DQUFBQTtLQUVBOW5DLG9CQURBNmxDLG9DQUFBQTtJQUVKLE9BQUEsNEJBREk3bEM7R0FDYTtZQUlma29DLFdBQVc1eEM7SUFDYixHQUFHLGVBRFVBLHVCQXRCWHN4Qzs7S0F3QkVyNEQsa0JBRlMrbUIsb0NBQUFBO0tBR1QweEMsb0JBREF6NEQsa0NBQUFBO0tBRUF3NEQsb0JBREFDLG9DQUFBQTtLQUVBRixvQkFEQUMsb0NBQUFBO0tBRUFsQyxvQkFEQWlDLG9DQUFBQTtLQUVBOW5DLG9CQURBNmxDLG9DQUFBQTtJQUVKLE9BQUEsZUFESTdsQyxvQ0FBQUE7R0FDc0I7WUFHeEJtb0MsUUFBUTU0RDtJQUNWLEdBQUcsZUFET0EscUJBakNScTREO0lBa0MyQjtJQUM3QixPQUFBLDBCQUZVcjRELEdBRUgsNEJBRkdBO0dBRWdDO1lBaUJ4QzY0RCxXQUFXbHZEO0lBQ2IsR0FBRyxlQURVQTtLQUk0Qyx1QkFBTSw2QkFKbERBO0tBR1g7T0F6REFzK0IsU0EwREU7O0lBQ1c7S0FBQSxNQUFBLGdDQUxGdCtCO0tBS2IsTUFBQSw0QkE5S0E4UTtJQThLZSxPQUFBO0dBQUs7WUFJbEJxK0MsVUFBVW52RDtJQUNaLEdBQUcsZUFEU0E7S0FHa0QseUJBQU0sNkJBSHhEQTtLQUdWO09BbEVBcytCLFNBa0VROztJQUNQLEdBQUEsNkJBSlN0K0IscUJBSThCO0lBQWtCLFVBQUEsZ0NBQUksNEJBSnBEQTtJQUlnRCxPQUFBLDRCQXRMNUQ4UTtHQXNMbUY7O3lEQW9FN0V6STs7O0lBMURGaks7SUFFQ21jO0lBSUM2eUM7R0FDSixTQUZHNXlDLE9BRUNua0IsR0FBSyxPQUFBLFdBREwrMkQsUUFDQS8yRCxHQUFXOztJQU9iNmY7OztZQUNBczBDLFlBQVV4cUQsR0FBSSxPQUFBLGdDQUFKQSxHQUEwQjtZQUNwQytzRCxZQUFVdG9EO0lBQUksT0FBMEIsNEJBQTlCQSxzQkFBSTtHQUErQjs7Ozs7O1NBaEI3Q3JHO1NBRUNtYztTQUdBQztTQVVEZ3dDO1NBQ0F1QztTQTBCRkk7U0E1QkVqM0M7U0EzTEptM0M7U0E4TElqOEM7O2dEQU9BMDdDLGVBa0NFemtEOzs7OztTQWhPTkc7U0FIQUQ7U0FrT01EO1NBQ0FEOzs7Ozs7Ozs7Ozs7U0FwQko0bEQ7O1NBSUFkO1NBQ0FqbEQ7U0F6TkZnbUQ7Ozs7Ozs7Ozs7SXpGc0pFN3hEO0lBQ0FqRztJQUNBRztJQUNBQzs7O095RnpMQ21hO09Bd0NIbkk7T0FIQUQ7T0FvTkVMO09BcklGOHJEO09BOUhHdm5EO09BR0EyRDtPQUtEcUg7O09BeVFJblA7T0FDQUQ7OzBCO096Ri9FSjdSO09BREFEO09BRkE4RjtPQUNBakc7T3lGeEdGNHBDO09BR0FJO09BS0FDOzs7T0FuRkVvQjs7Ozs7O09BMEVGN3dCOzs7T0EzQ0FrN0M7T0FEQWlrQjtPQUZBN2hCOzs7Ozs7T0FGQXZsRDtPQURBaTVCO09BRUE2c0I7T0FOQUY7T0FEQUQ7T0FEQUU7T0F3UEVIO09BdktGZTtPQW5GQWhCO09BREFuaUI7T0E4RUE5bkM7T0FEQUM7T0FvQkFvcEQ7T0FFQUU7T0FqQkFFO09BQ0FDO09BaUJBQztPQUdBcTRCO09BckZBajVCO09BeEJBcDhDO09BYUFySTtPQURBQztPQVBBeWxEO09BeUhFUTtPQWFBSztPQXVDQUc7T0FUQUQ7T0FuQkFEO3FCO3FCO1dBNEVBbjRELFFBK0JBdTNELFNBM0JBSixLQUlBZDtPQVJBcjJEO09BK0JBdTNEO09BM0JBSjtPQUlBZDs7OztPQXJJRnRsRDtPQUdBNGxEO09BRUFLO09BRUFFO09BeEdBKzNCO09BREFEO09Bc0NnQkU7T0FFQUM7T0FRQUM7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUM4QmR6NUI7SUFpUkVyN0M7SUFPQTA3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUExWEExdkQ7SUErVkNxUDtJQXBWRG9FO0lBb0pERjtpREEvSkN2VCxTQVdBeVQ7SUEwSkZzRzs7O1lBdkZBaXZFLFNBQVMvdkY7SUFFWCxxQ0FGV0E7SUFHWCxPQUFBLGVBSFdBO0dBR1E7WUFRakJnd0YsT0FBT2h3RixHQUFJLE9BQUEsdUJBQUpBLE1BQThCO1lBOEVyQ3VhLFVBcEVFN0o7SUFDWSxHQUFPLFdBRGYsZUFBSkEsR0FERjBsRCxPQUNFMWxEO0lBQ1ksTUFBQTtHQUFnQjs7SUEwUjlCalE7SUFDQW9mO0lBU0FFO1lBREE2M0MsSUEvUkk1M0QsR0FBSSxPQUFBLDRCQUFKQSxHQUFvQjtHQUNsQixJQUhBeTFELE1BeEJOczZCO1lBb0xGejlFLEtBN0pNd0IsR0FLSyxPQUxDLGVBQU5BLEdBQ0UyaEQsS0FJWTtZQXVKcEJscUIsS0EzSk16M0IsR0FLSyxPQUxDLGVBQU5BLEdBQUUyaEQsS0FLWTtHQVJaO0lBQUp6MUQ7SUFvS0pxUyxZQXBLUSxlQUFKclMsR0FERm8yRDtJQUNFcnZDO0lBbUtKM1UsWUFuS1EsZUFBSjJVLEtBREZxdkM7WUE2VEE0QixRQWpUUWg0RDtJQUFNLElBWForbUIsTUFXWSw2QkFBTi9tQjtJQVhGLE9BQUEsZUFBSittQixLQURGcXZDO0dBWW1DOztJQThTbkM4QjtJQUVBQztJQURBRjtJQUdBRjtZQUNBbmlCLFlBOVNZNTFDLEdBQUUySjtJQUFNLElBaEJsQm9kLE1BZ0JrQix1QkFBUi9tQixHQUFFMko7SUFoQlIsT0FBQSxlQUFKb2QsS0FERnF2QztHQWlCZ0Q7WUErU2hEMEIsb0JBOVNvQjkzRCxHQUFFMko7SUFBTSxJQWpCMUJvZCxNQWlCMEIsK0JBQVIvbUIsR0FBRTJKO0lBakJoQixPQUFBLGVBQUpvZCxLQURGcXZDO0dBa0JnRTs7SUF0QjdEemxEOztHQXVCRyxTQThJUnluRCxJQXJLT3RrRCxHQUFFQztJQUNULE9BQUE7YUFBZTtlQURWcEQsR0FDYSx1QkFEWG1ELE9BQ3dDLHVCQUR0Q0M7OztZQWtTUHpPLFNBMVFJd08sR0FBRUM7SUFBSSxPQUFBLGVBQU5ELEdBQXVCLHVCQUFyQkM7R0FBaUQ7WUEyUXZEeE8sU0ExUUl1TyxHQUFFQztJQUFnQixJQS9CVi9ULElBK0JVLHVCQUFsQjhULEdBQUVDO0lBL0JVLE9BQUEsZUFBSi9UO0dBK0I4Qjs7SUE2STVDNjNEOztZQUxBa0IsU0F0SVcvNEQsR0FBSSxPQUFBLDZCQUFKQSxHQUE2QjtZQTBLeEN3M0QsU0ExTVM5bUQsR0FpQ00sT0FqQ0YsdUJBQUpBLE1BaUNjO1lBc0t2QjRtRCxTQXJLVzVtRDtJQUFJLE9BdENaLHFDQXNDUUE7a0JBdEN5QyxlQXNDekNBOztHQUFVO1lBc0tyQjZtRCxhQXJLZTdtRCxHQUFJLE9BOUNqQnEvRSxTQThDYXIvRSxHQUFjO1lBc0s3Qm9wRSxlQTFNY3BwRSxHQXFDTyxPQXJDSCxlQUFKQSxRQXFDb0I7WUFnQ2hDMFEsVUEvQlVwaEIsR0FBSSxPQWhEZCt2RixTQWdEdUIsNkJBQWIvdkYsSUFBOEI7WUFnQ3hDc2MsWUFyRU90YztJQXNDTyxPQUFjLDZCQXRDakIsdUJBQUpBO0dBc0MrQjtZQThOcEMrSCxVQTdOTy9ILEdBQU9DLEdBQUksT0FBQSxXQWhJbEI4RyxTQWdJTy9HLEdBQU9DLEdBQWU7WUEySWpDMjRELFFBbExTNTREO0lBd0NLLE9BQWMsMkJBeENmLHVCQUFKQTtHQXdDNkI7WUErSXRDaXdGLElBN0lNandGLEdBR04sT0FBQSwyQkFITUEsR0FHSztZQTJJWGt3RixJQXhMU2x3RjtJQWdEQyxPQUFVLDJCQWhEUCx1QkFBSkE7R0FnRHFCO1lBbUk5QjI0RCxXQW5MUzM0RDtJQWlEUSxPQTVEZit2RixTQTREZSwyQkFqREosdUJBQUovdkY7R0FpRCtDO1lBbUl4RHM0RCxVQXBMU3Q0RDtJQWtETyxPQTdEZCt2RixTQTZEYywyQkFsREgsdUJBQUovdkY7R0FrRDhDO1lBbUl2RDY0RCxXQXJMUzc0RDtJQW1EUSxPQUFpQiwyQkFuRHJCLHVCQUFKQTtHQW1EbUM7WUFtSTVDODRELFVBdExTOTREO0lBb0RPLE9BQWdCLDJCQXBEbkIsdUJBQUpBO0dBb0RpQztZQXNOcEMrWixLQXhMRS9aLEdBQVMsT0FBQSxxQ0FBVEEsR0FBNEI7R0FDUjtJQUExQm9yQyxlQXVMSXJ4QixNQU5GaFMsV0EvTEZ1VTs7Ozs7O1lBZUE2ekUsWUFBWW53RixHQUFJLE9BQUEsZ0NBQUpBLE1BQTZEO1lBNE9yRWdTLFVBaFVHaFM7SUE2SE8sT0FBcUIsNkJBN0h4Qix1QkFBSkE7R0E2SHNDO1lBa016Q2lTLFVBaE1NOEo7SUFDWjtTQXpCSWxNLDRCQXdCUWtNOztZQXhCUmxNO01BS00sZUFBQSxnQkFtQkVrTTs7OztjQUVOMnVCLGdCQXhCRnRmOztzQkF3QkVzZixnQkF4QkZ0Zjs7VUF3QkVzZixnQkF4QkZ0Zjs7O1VBd0JFc2YsZ0JBeEJGdGY7UUFTRCw0QkFUQ0EsVUFGQXZiO01BYU87T0FBTHV3QyxLQUFLLGdCQVdDcmtDLEtBdEJScVA7T0FZRWkxQixLQUFLLGdCQVVDdGtDLEtBVkUsNEJBWlZxUDtPQWFGLGVBRklnMUIsU0FDQUM7OztTQVlNK3ZDO0tBQ1YsR0FEVUE7TUFFUSxJQWhHTDEvRSxJQWdHSyxxQkFKUnFMLFlBMUlWZzBFLFNBOENhci9FOztvQkE4RlRnNkI7V0FJRTJsRCxVQU5JdDBFOztPQVErQjtRQUFBLE1BQUEsa0RBUi9CQTtRQU1KczBFLFVBRVEsMkJBUkp0MEU7TUFXSSxJQTNJRnVRLFFBMklFLHFCQUxSK2pFO01BT0QsR0FBQSxjQTdJTy9qRSxhQXFGWjZqRSxZQTJDVXAwRTtNQWhJTTtPQWVadTBFLFVBZlksZUFBSmhrRTtPQThJTmlrRSxtQkFaRjdsRCxPQW5IQTRsRCxVQUFJLGVBQUpBO2FBK0hFQzs7S0FWRDs7ZUFlQSxPQTlETEosWUEyQ1VwMEU7R0FtQlU7WUFHcEI0ekUsUUFySk9qL0U7SUFxSmlCLElBdEpaMVEsSUFzSlksMkJBckpiLHVCQUFKMFE7SUFEUyxPQUFBLGVBQUoxUTtHQXNKc0M7WUFDbEQ0dkYsUUF0Sk9sL0U7SUFzSmlCLElBdkpaMVEsSUF1SlksMkJBdEpiLHVCQUFKMFE7SUFEUyxPQUFBLGVBQUoxUTtHQXVKc0M7WUFDbEQ2dkYsUUF2Sk9uL0U7SUF1SmlCLElBeEpaMVEsSUF3SlksMkJBdkpiLHVCQUFKMFE7SUFEUyxPQUFBLGVBQUoxUTtHQXdKc0M7R0FNaEM7SUFEcEJ5YTtJQUNBazhDLG9CQUFvQiw0QkFEcEJsOEM7SUFFQW04QyxvQkFBb0IsNEJBRnBCbjhDO0lBbUJBaS9ELFlBMUxFcVc7SUF3Qk1TLFFBeEJOVDtJQTJUQWo1QixPQTNUQWk1Qjs7Ozs7OztZQW9NRjc5RSxTQXpMU2xTO0lBeUxJLE9BQUEsNEJBekxBLHVCQUFKQTtHQXlMa0M7WUFDM0M2MkQsbUJBQW1CNzJEO0lBQWdCLElBM0xyQittQixNQTJMcUIsb0JBQWhCL21CO0lBM0xELE9BQUEsZUFBSittQjtHQTJMNEM7WUFFMUQ1VSxTQUFTekI7SUFDWDtNQUNHLGdDQUZRQSxHQS9CVGltRDtTQWlDMkIsZ0NBRmxCam1ELEdBOUJUa21EO0tBaUNlLElBaE1ENTJELElBZ01DLG9CQUhOMFE7S0E3TFMsT0FBQSxlQUFKMVE7O0lBb01aLFVBQUEsNEJBUE8wUTtJQUtULE9BQUE7R0FHSTs7OENBZ0VBM0ksV0EvTEZ1VSxhQTJPQXc2Qzs7Ozs7Ozs7OztZQTlGRm50QixRQUFRajVCLEdBQUdrNUIsS0FBS0M7SUFBTztLQUFBLE1BQUEsZUFBWkQsS0FBSGw1QjtLQUFlLFlBQVksZUFBM0JBLEdBQVFtNUI7SUFBbUI7R0FBUztZQUM1Q0MsZ0JBQWdCcDVCLEdBQUd2USxLQUFLRDtJQUFNLE9BQUcsY0FBakJ3USxHQUFHdlEsT0FBQUEsTUFBdUMsZUFBMUN1USxHQUFReFEsT0FBUndRLElBQVF4UTtHQUEwRDtZQUVsRjZwQyxVQUFVcjVCLEdBQUd2USxLQUFLRDtJQUNwQixHQUFPLGVBRFFDLEtBQUtELE1BRXBCLE9BSkU0cEMsZ0JBRVVwNUIsR0FBR3ZRLEtBQUtEO0lBQ3BCLE1BQUE7R0FDMkI7WUFHekI4cEMsTUFBTXQ1QixHQUFHdlEsS0FBS0Q7SUFDaEIsS0FBRyxpQkFEUUMsS0FBS0QsTUFPWCxXQWRINHBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtJQU1UOzRCQTNKSG9jLFlBcUpZcGM7S0FNVCx1QkEzSkhvYyxZQXFKT25jO0tBSVAsTUFBQTtJQUFBLE9BQUE7R0FHaUM7WUF5RWpDcUYsU0FqRUt1TyxHQUFFd0IsR0FBSSxPQS9EYjZpRCxJQStET3JrRCxHQUFFd0IsR0FBVztZQUNwQnhILEtBQUtvSyxHQUFJLElBOU5IblksSUE4TkRtWSxNQUFBQSxPQTlOTyxlQUFOblksR0FDRXd3RixpQkE2TmM7WUFDdEIxaUYsS0FBS3FLLEdBQUksSUE5TkhuWSxJQThORG1ZLE1BQUFBLE9BOU5PLGVBQU5uWSxHQUFFd3dGLGlCQThOYztZQUd0QjUrRSxPQUFPNVI7SUFBSSxPQXpQVCt2RixTQXlQa0Isb0NBQWIvdkY7R0FBa0M7WUFtRXZDNlIsV0FsRVM3UixHQUFJLE9BRGY0UixPQUNXNVIsR0FBWTtZQUN2QndSLE9BaFBTeFI7SUFnUEUsT0FBa0IscUNBaFBoQix1QkFBSkE7R0FnUDhCO1lBQ3ZDMjlELFdBalBTMzlEO0lBaVBNLE9BQXNCLHFDQWpQeEIsdUJBQUpBO0dBaVBzQztZQUMvQzQ1RSxhQWxQUzU1RTtJQWtQUSxPQUF3QixxQ0FsUDVCLHVCQUFKQTtHQWtQMEM7WUFDbkRrM0QsU0FBU2wzRDtJQUFJLE9BOVBYK3ZGLFNBOFBvQixvQ0FBYi92RjtHQUFvQztZQUM3Q20zRCxhQUFhbjNELEdBQUksT0FEakJrM0QsU0FDYWwzRCxHQUFjO1lBQzNCbzNELFNBclBTcDNEO0lBcVBJLE9BQW9CLHFDQXJQcEIsdUJBQUpBO0dBcVBrQztZQUMzQ3EzRCxhQXRQU3IzRDtJQXNQUSxPQUF3QixxQ0F0UDVCLHVCQUFKQTtHQXNQMEM7WUFDbkQ2NUUsZUF2UFM3NUU7SUF1UFUsT0FBMEIscUNBdlBoQyx1QkFBSkE7R0F1UDhDO1lBQ3ZEeTNELGFBQWF6M0Q7SUFBSSxPQWpEakJzM0QsU0FpRDBCLHFDQUFidDNEO0dBQXdDO1lBQ3JEMDNELGlCQUFpQjEzRDtJQUFJLE9BcFFuQit2RixTQW9RNEIscUNBQWIvdkY7R0FBd0M7WUFDekR5d0YsbUJBQW1CendGO0lBQW1CLElBM1B4QjBRLElBMlB3QixxQ0FBbkIxUTtJQTNQRCxPQUFBLGVBQUowUTtHQTJQbUQ7WUFDakVpbkQsYUEzUFMzM0Q7SUEyUFEsT0FBd0IscUNBM1A1Qix1QkFBSkE7R0EyUDBDO1lBQ25EOHZGLGlCQTVQUzl2RjtJQTRQWSxPQUE0QixxQ0E1UHBDLHVCQUFKQTtHQTRQa0Q7WUFDM0Qwd0YsbUJBN1BTMXdGO0lBNlBjLE9BQThCLHFDQTdQeEMsdUJBQUpBO0dBNlBzRDs7eURBbUV6RGdTOzs7R0FyREosU0FGR21TLE9BRUNua0IsR0FBSyxPQURMK1osS0FDQS9aLEdBQVc7O0lBT2J5Rjs7O1lBRUEwdUQsWUFuUmN4cUQ7SUFxUmhCLE9BQXFCO2tDQXJSRCwrQkFBSkE7R0FxUndCO1lBR3RDK3NELFlBQVV0b0Q7SUFBSSxPQXNDWjZELFVBdENzQixxQ0FBZDdEO0dBQXdCOzs7Ozs7U0FyQmxDckc7U0FFQ3FPO1NBR0ErTjtTQVdEZ3dDO1NBS0F1QztTQXVCRkk7U0E5QkVyeEQ7U0E2QkZzYTtTQXJCRWhGOztZQU1BNDFFLFlBQVUzd0YsR0FBSSxPQWdDWmdTLFVBaENRaFMsR0FBZTtHQWdEbkI7OzZDQS9DTnkyRCxlQURBazZCO0lBWXVDanJGO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOzs7OztTQWhIM0NvTTtTQUhBRDtTQXNJTUQ7U0FDQUQ7U0EzQkp2UjtTQUNBb2Y7U0FDQXZhO1NBQ0FDO1NBT0F3YTtTQUh5Q2hhO1NBQUFEO1NBQUFEO1NBQUFEO1NBQUFEO1NBQUFEO1NBRXpDa3lEO1NBQ0E3M0M7U0FDQSsyQztTQUNBamxEO1NBdElGZ21EOzs7Ozs7Ozs7SUFxS1U7O0kxRmhQUjd4RDtJQUNBakc7SUFDQUc7SUFDQUM7OztPMEY3QkNtYTtPQXNISG5JO09BSEFEO09Bd0hFTDtPQWhFRjhyRDtPQXFCS3ZuRDtPQUlDMkQ7T0F0TUpxSDs7T0EyUEluUDtPQUNBRDs7Ozs7Ozs7MEI7TzFGN05KN1I7T0FEQUQ7T0FGQThGO09BQ0FqRztPMEZpSEY0cEM7T0FHQUk7T0FLQUM7T0E5SUVscEI7O09BT0FzcUI7Ozs7OztPQUxBN3dCOzs7T0FrT0F1OEM7T0FuU00wNUI7T0FrS1I5VztPQXNIRWo1RTtPQUNBb2Y7T0FDQXZhO09BR0FFO09BS0F1YTtPQUFBQTs7O09BUEF4YTtPQTdIRnN5RDs7T0F3SkVLO09BQ0FEO09BQ0FFO09BQ0FIO09BQ0FEO09BQ0FuaUI7Ozs7OztPQTFCQWdpQjtPQXJJRnRsRDtPQURBaTVCO09BRUE2c0I7T0F5SkVGO09BQ0FEO09BQ0FFO09BQ0FIO09BaEtGZTtPQWlLRWhCO09BQ0FuaUI7T0E3RkY5bkM7T0FEQUM7T0FVQW9wRDtPQUVBRTtPQTlDQUU7T0FFQUM7T0ErQ0FFO09BR0FvNEI7T0FsRUFqNUI7T0E5QkFwOEM7T0FpQkFySTtPQUNBQztPQTJKRXlsRDtPQUFBQTtPQXJKRlE7T0FEQUs7T0FHQUc7T0FEQUQ7T0FIQUQ7T0FLQXEzQjtPQUNBQzs7UUE2R0V6dkY7UUFDQW9mO1FBQ0F2YTtRQUNBQztRQU9Bd2E7UUFMQXZhO1FBRXlDTztRQUFBRDtRQUFBRDtRQUFBRDtRQUFBRDtRQUFBRDtRQUV6Q2t5RDtRQUNBNzNDO1FBQ0ErMkM7Ozs7UUFtQkFvQjtRQUNBRDtRQUNBRTtRQUNBSDtRQUNBRDtRQUNBbmlCO1FBQ0FraUI7T0EzRkZsbUQ7T0FFQUo7T0FFQW9vRTtPQUNBMWlCO09BRUFFO09BRUF5aUI7T0FoREF2aUI7T0FFQXdpQjtPQStDQXJpQjtPQUdBRTtPQURBODRCO09BR0FDO09BeEdFZjtPQUNBQztPQUNBQztXQWxLQUUsVUFXQUM7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDOUZBcjFFO0lBa0NFSTs7Ozs7Ozs7SUF4Q0oxTTtJQUtFdEg7SUFHQ3FQO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsTUFORGhULFNBWUF5VDs7Ozs7WUFPQXZJLFVBR0E3RDtJQUhZLE9BR1pBO2NBQUFBLGVBQUssV0EzQlBDLG1CQTJCRUQ7O0dBQTBFOztJQUcxRTREO2lEQXpCQWpMLFNBWUF5VDs7OzZDQXVCRU8sYUFWRi9JOzs7Ozs7WUFrQkZ1SSxpQkFBb0IsU0FBRTtZQUN0Qm92QixRQUFRajVCLEdBQUdrNUIsS0FBS0M7SUFBTyxVQUFBLGdDQUFaRCxLQUFIbDVCO0lBQWUsNkNBQWZBLEdBQVFtNUI7R0FBNEI7WUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7SUFBTSxPQUFHLGdDQUFqQndRLEdBQUd2UTtjQUFBQTtjQUF1QyxnQ0FBMUN1USxHQUFReFEsT0FBUndRLElBQVF4UTtHQUEwRDtZQUVsRjZwQyxVQUFVcjVCLEdBQUd2USxLQUFLRDtJQUNwQixHQUFPLGdDQURRQyxLQUFLRDtLQUVwQixPQUpFNHBDLGdCQUVVcDVCLEdBQUd2USxLQUFLRDtJQUNwQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBQ2hCLEtBQUcsZ0NBRFFDLEtBQUtEO0tBT1gsV0FkSDRwQyxnQkFPTXA1QixHQUFHdlEsS0FBS0Q7SUFNVDs0QkFBaUMsV0E5Q3BDc2EsV0F3Q1l0YTtLQU1ULHVCQUFTLFdBOUNac2EsV0F3Q09yYTtLQUlQLE1BQUE7SUFBQSxPQUFBO0dBR2lDO1lBR25DcVIsT0FBT3hSLEdBQUksT0FBQSw0QkFBSkEsR0FBaUI7WUFNdEJTLE9BQU9xVCxHQUFFQztJQUFJO0tBQTRCLE1BTjNDdkMsT0FNV3VDO0tBQW1CLE1BTjlCdkMsT0FNU3NDO0tBRFE5VCxJQUNZO0lBRE0sT0FBbEJBO0dBQ21DO1lBQ2xENmYsU0FBTy9MLEdBQUVDO0lBQUk7S0FBNkIsTUFQNUN2QyxPQU9XdUM7S0FBbUIsTUFQOUJ2QyxPQU9Tc0M7S0FGUTlULElBRVk7SUFGTSxPQUFsQkE7R0FFb0M7O0dBTUMsU0FidER3UixtQkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBN0RFbUo7UUFZQ0w7UUFWQWxFO1FBR0EyRDtRQUtEcUg7UUFDQTVHO1FBT0F2STtRQU1BRDs7Ozs7Ozs7Ozs7OztRQW1CRjIzQjtRQUdBSTtRQUtBQzs7O1FBbkNFb0I7UUEwQkY3d0I7UUFtQkEvSTtZQU9FcU8sVUFEQXBmOzs7O0dBT0csTUFBQTtFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQ3NLRHNhO0lBT0EwN0M7Ozs7Ozs7Ozs7Ozs7Ozs7SUF6UERyZ0Q7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXO0dBU2E7SUFOMUJvaEI7SUFDQTVHO0lBQ0NGO0lBSUQ4d0IsZUFYQ3J4Qix3QkFNRFM7WUF3RUF4VSxVQWxFU2hHLEdBQU9DLEdBQUksT0FBQSw2QkFBWEQsR0FBT0MsR0FBZTtHQVNiO0lBZ1FkK1I7SUFEQUM7aURBdE1Kak0sV0F4RUF3VTs7SUFjRkM7SUFDQWs4QyxvQkFBb0IsNEJBRHBCbDhDO0lBRUFtOEMsb0JBQW9CLDRCQUZwQm44QztJQUdBZzFFO0lBQ0FDO1lBc1FFNTNCLDhCO1lBREFsaUIsc0I7WUFEQW1pQixxQjtHQWpRVyxJQWdRWEM7WUFEQUcsa0I7WUFEQUYsaUI7WUFEQUMsa0I7R0F6UFE7SUFDVjdsRDtJQUNBRDtJQWtPRXdsRDtJQWhPRnJzQjtJQUNBajVCO0lBQ0F1bEQ7WUErTkVwM0QsWTtHQTlOSTtJQUNOaTVFO0lBQ0Fqa0I7SUE2TkVxQjs7Ozs7OztZQTFORjVrRCxjO1lBQ0Eya0Qsd0I7WUFFQTFrRCxTQUFTeEI7SUFDWDtNQUFHLGdDQURRQSxHQXpCVGdtRDtTQTJCQyxnQ0FGUWhtRCxHQXhCVGltRDtLQTJCRyxPQUhNam1EO0lBT1AsVUFBQSw0QkFQT0E7SUFLVCxPQUFBO0dBR0k7OzswQ0F3QkYzSyxXQXhFQXdVLFdBK1BBczhDOzs7Ozs7SUFKZWozQztJQUFBRTtJQUFBemE7SUFBQUM7SUFBQUM7SUFBQUM7Ozs7O1lBbExmMUYsV0FBV0MsR0FBRUMsR0FBSSxPQURqQitGLFVBQ2EvRixHQUFGRCxHQUFpQjtZQUM1QkcsSUFWT0gsR0FBT0MsR0FVRSxPQVZFLGNBQVhELEdBQU9DLEtBQVBELElBQU9DLEVBVXdCO1lBQ3RDQyxJQVpPRixHQUFPQyxHQVlFLE9BWkUsaUJBQVhELEdBQU9DLEtBQVBELElBQU9DLEVBWXdCO1lBQ3RDK0csTUFkT2hILEdBQU9DLEdBY0ksT0FkQSxXQUFYRCxHQUFPQyxHQWNTO1lBQ3ZCMHBDLFFBaEJlajVCLEdBQVBrNUIsS0FBT0M7SUFBSSxVQUFBLGVBQVhELEtBQU9sNUI7SUFnQlEsYUFoQkosZUFBSkEsR0FBQW01QjtHQWdCNkI7WUFDNUNDLGdCQWRPcDVCLEdBQU92USxLQUhDRDtJQWlCZSxPQWRaLGNBQVh3USxHQUFPdlEsT0FBQUEsTUFISyxlQUdadVEsR0FIUXhRLE9BR1J3USxJQUhReFE7R0FpQm1FO1lBRWxGNnBDLFVBQVVyNUIsR0FuQkZ2USxLQUFPRDtJQW9CakIsR0FwQnFCLGVBQVhDLEtBQU9ELE1BcUJqQixPQUpFNHBDLGdCQUVVcDVCLEdBbkJGdlEsS0FBT0Q7SUFvQmpCLE1BQUE7R0FDMkI7WUFHekI4cEMsTUFBTXQ1QixHQXRCQ3ZRLEtBQU9EO0lBdUJoQixLQXZCb0IsaUJBQVhDLEtBQU9ELE1BNkJYLFdBZEg0cEMsZ0JBT01wNUIsR0F0QkN2USxLQUFPRDtJQTRCVDs0QkFBaUMsV0EzRnRDc2EsV0ErRGN0YTtLQTRCVCx1QkFBUyxXQTNGZHNhLFdBK0RPcmE7S0EwQkwsTUFBQTtJQUFBLE9BQUE7R0FHaUM7WUFNckNvYSxpQkFBb0IsU0FBRTtPQXFKcEI3VSw2QkFEQUM7WUFEQUMsbUI7WUFEQUMsbUI7WUE1SUZrSSxLQUFLb0ssR0FBQUEsT0FBQUEsT0F0RUxzOUMsa0JBc0VzQjtZQUN0QjNuRCxLQUFLcUssR0FBQUEsT0FBQUEsT0F2RUxzOUMsa0JBdUVzQjtZQUN0QnlCLFNBQVN4bUQsR0FBSSxPQUFKQSxFQUFLO1lBRWQwbUQsU0FBUzFtRCxHQUFJLE9BQUpBLEVBQUs7O0lBRWRxb0Q7SUFJQW5uRDtJQThJRUM7SUE1SUYrK0U7SUFDQXAvRTtJQUNBbXNEO0lBQ0FpYztJQUNBdGlCO0lBQ0FDO0lBQ0F1aUI7SUFDQXRpQjtJQUNBQztJQUNBQztJQUNBKzRCO0lBQ0E5NEI7WUFFQVMsSUFBSXJrRCxHQUFFd0I7SUFBSSxJQUFvRCxNQUFBLFdBWDlEb29ELFlBV01wb0QsSUFBeUMsTUFBQSxXQVgvQ29vRCxZQVdJNXBEO0lBQWlCLE9BQUEsV0ErSG5CbEMsWUEvSG1CO0dBQXdEO1lBd0gzRS9MLFVBdkhLaU8sR0FBRXdCLEdBQUksT0FEYjZpRCxJQUNPcmtELEdBQUV3QixHQUFXO1lBSXBCbzZFLFFBQVEzdkYsR0FBSSxPQUErQixpQkFBbkNBLGNBQWlEOztJQU12RGlvQzs7Ozs7OztZQUVBb3dCO0lBQ0YsT0FBQTtHQUEyRDtZQVF6REMsVUFBVXQ0RDtJQUNaLEdBQUcsZ0NBRFNBO0tBVFZxNEQ7SUFXTTtLQUFKdHhDLE1BQUksNEJBRkkvbUI7S0FHUnk0RCxNQURBMXhDLE1BQUFBO0tBRUF5eEMsTUFEQUMsTUFBQUE7S0FFQUYsTUFEQUMsTUFBQUE7S0FFQWxDLE1BREFpQyxNQUFBQTtLQUVBOW5DLE1BREE2bEMsTUFBQUE7SUFFSixPQUFBLDRCQURJN2xDO0dBQ2E7WUFJZmtvQyxXQUFXNXhDO0lBQ2IsR0FBRyxnQ0FEVUE7S0FyQlhzeEM7O0tBdUJFcjRELElBRlMrbUIsTUFBQUE7S0FHVHl4QyxNQURBeDRELElBQUFBO0tBRUF1NEQsTUFEQUMsTUFBQUE7S0FFQWxDLE1BREFpQyxNQUFBQTtLQUVBOW5DLE1BREE2bEMsTUFBQUE7SUFFSixPQURJN2xDLE9BQUFBO0dBQ3NCO1lBR3hCbW9DLFFBQVE1NEQ7SUFDVixHQUFHLGdDQURPQTtLQS9CUnE0RDtJQWdDMkIsSUFBQSw2QkFEbkJyNEQsSUFFSCw0QkFGR0E7SUFDbUIsT0FBQTtHQUNhO1lBaUJ4QzY0RCxXQUFXbHZEO0lBQ2IsR0FBRyxnQ0FEVUE7S0FJNEMsdUJBQU0sNkJBSmxEQTtLQUdYO09BdkRBcytCLFNBd0RFOztJQUNXO0tBQUEsTUFBQSxnQ0FMRnQrQjtLQUtiLE1BQUEsNEJBdkxBOFE7SUF1TGUsT0FBQTtHQUFLO1lBSWxCcStDLFVBQVVudkQ7SUFDWixHQUFHLGdDQURTQTtLQUdrRCx5QkFBTSw2QkFIeERBO0tBR1Y7T0FoRUFzK0IsU0FnRVE7O0lBRVAsR0FBQSw2QkFMU3QrQixxQkFLOEI7SUFBa0IsVUFBQSxnQ0FBSSw0QkFMcERBO0lBS2dELE9BQUEsNEJBaE01RDhRO0dBZ01tRjs7eURBaUU3RXpJOzs7SUF2REZqTDtJQUVDbWQ7SUFJQzZ5Qzs7O0dBQ0osU0FGRzV5QyxPQUVDbmtCLEdBQUssT0FBQSxXQURMKzJELFFBQ0EvMkQsR0FBVztZQVFibTBELFlBQVV4cUQsR0FBSSxPQUFBLGdDQUFKQSxHQUEwQjtZQUNwQytzRCxZQUFVdG9EO0lBQUksT0FBMEIsNEJBQTlCQSxzQkFBSTtHQUErQjs7Ozs7O1NBaEI3Q3JIO1NBRUNtZDtTQUdBQztTQVVEZ3dDO1NBQ0F1QztTQXVCRkk7U0FKZXR4RDtTQUdmL0U7U0FyQkVzYTs7Z0RBT0EwN0MsZUErQkV6a0Q7Ozs7O1NBdk9ORztTQUhBRDtTQXlPTUQ7U0FDQUQ7U0EzQkpuTTtTQUNBRDtTQUNBRDtTQUNBRDtTQU9BakY7U0FIZW9mO1NBQUFFO1NBQUF6YTtTQUFBQztTQUFBQztTQUFBQztTQUVmbXlEO1NBQ0FuM0Q7U0FDQXEyRDtTQUNBamxEO1NBak9GZ21EOzs7Ozs7Ozs7OztPQTlCR3Y5QztPQXVDSG5JO09BSEFEO09BMk5FTDtPQTFJRjhyRDtPQS9IR3ZuRDtPQUdBMkQ7T0FLRHFIOztPQStRSW5QO09BQ0FEO09BcEJXNk47T0FBQUU7T0FBQXphO09BQUFDO09BQUFDO09BQUFDO09BL0tmdUI7T0FKQWhCO09BRUE3RjtPQUNBRDtPQUhBOEY7T0FDQWpHO09BSUE0cEM7T0FHQUk7T0FLQUM7OztPQWhGQW9COzs7Ozs7T0E2RkY3d0I7OztPQTZKRXU4QztPQTdORnJCO09BREFpa0I7T0FtTkU3ekU7T0FDQUQ7T0FDQUQ7T0FHQUc7T0FLQXJGO09BQUFBOzs7T0FQQWlGO09BeE5GbXlEOztPQW1QRUs7T0FDQUQ7T0FDQUU7T0FDQUg7T0FDQUQ7T0FDQW5pQjs7Ozs7O09BMUJBZ2lCO09BL05GdGxEO09BREFpNUI7T0FvR0E2c0I7T0FpSkVGO09BQ0FEO09BQ0FFO09BQ0FIO09BdktGZTtPQXdLRWhCO09BQ0FuaUI7T0E5S0Y5bkM7T0FEQUM7T0FFQW1wRDtPQUVBRTtPQWFBRztPQUVBQztPQUVBRTtPQUVBQztPQXpGQWQ7T0F4QkFwOEM7T0FhQXJJO09BREFDO09BOFBFeWxEO09BQUFBO09BaklBUTtPQVlBSztPQXNDQUc7T0FUQUQ7T0FuQkFEO3FCO3FCOztRQXVFQS95RDtRQUNBRDtRQUNBRDtRQUNBRDtRQU9BakY7UUFMQXFGO1FBRWUrWjtRQUFBRTtRQUFBemE7UUFBQUM7UUFBQUM7UUFBQUM7UUFFZm15RDtRQUNBbjNEO1FBQ0FxMkQ7Ozs7UUFtQkFvQjtRQUNBRDtRQUNBRTtRQUNBSDtRQUNBRDtRQUNBbmlCO1FBQ0FraUI7T0F0S0ZsbUQ7T0FHQUo7T0FYQTBsRDtPQUVBRTtPQWdCQUs7T0FHQUU7T0FQQUw7T0FKQXM1QjtPQUdBaFg7T0FPQTZXO09BSkEzVztPQXhHQTRWO09BREFEO09BcUhBRTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ25KQTFuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBd0NJNG9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBdUNBci9FLE9BQU94UixHQUFJLFdBQUpBLEdBQVU7WUFDakI0NUUsYUFBYTU1RSxHQUFJLE9BQUpBLEVBQUs7WUFJbEIwd0YsbUJBQW1CMXdGLEdBQUksT0FBQSxnQkFBSkEsR0FBa0I7WUFDckMyM0QsYUFBYTMzRCxHQUFJLFdBQUssZ0JBQVRBLElBQXlCO1lBRXRDNHZGLFFBQVFsL0U7SUFBSSxPQUFtQjthQUFBLDJCQUFlLG9CQUF0Q0E7R0FBdUQ7WUFDL0RtL0UsUUFBUW4vRTtJQUFJLE9BQW1CO2FBQUEsMkJBQWUsb0JBQXRDQTtHQUF1RDs7SUFGL0RvZ0Y7SUFLRkM7TUFuREVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Qjs4Qjs4Qjs4Qjs4Qjs4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCOzhCOzs7d0I7d0I7Ozs7Ozs4Qjs4Qjs4Qjs7OEI7OEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEI7Ozs7Ozs7Ozs7K0I7OEI7Ozt3Qjs7NkI7NkI7NkI7NkI7NkI7NkI7O3dCOzs7Ozs2Qjs2Qjs2Qjs7NkI7NkI7NkI7O1NBdUNBci9FO1NBQ0Fvb0U7Ozt1Qjs7OztTQUtBamlCO3VCO1NBREErNEI7O1NBRUFJOztTQUNBbEI7U0FDQUM7SUFyQ1U3dkQsbUJBd0NaK3dEO0lBeENZQyxhQXdDWkQ7SUF4Q1lFLGFBd0NaRjtJQXhDWUcsZUF3Q1pIO0lBeENZSSxlQXdDWko7SUF4Q1k3c0UsZ0JBd0NaNnNFO0lBeENZNXNFLFNBd0NaNHNFO0lBeENZL3hELGNBd0NaK3hEO0lBeENZejBFLGNBd0NaeTBFO0lBeENZcjZCLGNBd0NacTZCO0lBeENZNThCLGNBd0NaNDhCO0lBeENZeHJGLFdBd0Nad3JGO0lBeENZdnJGLFdBd0NadXJGO0lBeENZdHJGLFdBd0Nac3JGO0lBeENZcnJGLFdBd0NacXJGO0lBeENZcHJGLFdBd0Nab3JGO0lBeENZbnJGLFdBd0NabXJGO0lBeENZL29GLFVBd0NaK29GO0lBeENZaHBGLFlBd0NaZ3BGO0lBeENZN3FGLFFBd0NaNnFGO0lBeENZOXFGLFFBd0NaOHFGO0lBeENZNXFGLGNBd0NaNHFGO0lBeENZM3FGLGVBd0NaMnFGO0lBeENZdGhDLFlBd0Nac2hDO0lBeENZcmhDLGNBd0NacWhDO0lBeENZcGhDLFVBd0Nab2hDO0lBeENZcGIsZUF3Q1pvYjtJQXhDWUssT0F3Q1pMO0lBeENZTSxhQXdDWk47SUF4Q1lPLGdCQXdDWlA7SUF4Q1lRLG9CQXdDWlI7SUF4Q1lTLGdCQXdDWlQ7SUF4Q1lVLG9CQXdDWlY7SUF4Q1lXLFNBd0NaWDtJQXhDWVksY0F3Q1paO1lBQUFBO0lBeENZYSxrQkF3Q1piO0lBeENZdFgsU0F3Q1pzWDtJQXhDWVAsUUF3Q1pPO0lBeENZYyxjQXdDWmQ7SUF4Q1lsckYsV0F3Q1prckY7SUF4Q1lqckYsWUF3Q1ppckY7SUF4Q1lockYsWUF3Q1pnckY7SUF4Q1l4cUYsWUF3Q1p3cUY7SUF4Q1kvNUIsTUF3Q1orNUI7SUF4Q1l2cUYsWUF3Q1p1cUY7SUF4Q1l0cUYsWUF3Q1pzcUY7SUF4Q1lycUYsWUF3Q1pxcUY7SUF4Q1lwcUYsWUF3Q1pvcUY7SUF4Q1llLFFBd0NaZjtJQXhDWW5xRixZQXdDWm1xRjtJQXhDWTlqRixPQXdDWjhqRjtJQXhDWTVqRixNQXdDWjRqRjtJQXhDWXpqRixPQXdDWnlqRjtJQXhDWTdqRixTQXdDWjZqRjtJQXhDWTNqRixNQXdDWjJqRjtJQXhDWS9qRixNQXdDWitqRjtJQXhDWWdCLFVBd0NaaEI7SUF4Q1lpQix1QkF3Q1pqQjtJQXhDWWtCLGVBd0NabEI7SUF4Q1ltQixhQXdDWm5CO0lBeENZb0Isa0JBd0NacEI7SUF4Q1l2akYsUUF3Q1p1akY7SUF4Q1lxQixTQXdDWnJCO0lBeENZc0IsU0F3Q1p0QjtJQXhDWXVCLFFBd0NadkI7SUF4Q1l3QixZQXdDWnhCO0lBeENZeUIsV0F3Q1p6QjtJQXhDWTBCLFlBd0NaMUI7SUF4Q1kyQixZQXdDWjNCO0lBeENZNEIsYUF3Q1o1QjtJQXhDWTZCLGVBd0NaN0I7SUF4Q1k4QixnQkF3Q1o5QjtJQXhDWStCLFNBd0NaL0I7SUF4Q1lnQyxTQXdDWmhDO0lBeENZaUMsaUJBd0NaakM7SUF4Q1lrQyxpQkF3Q1psQztJQXhDWW1DLGlCQXdDWm5DO0lBeENZb0MsYUF3Q1pwQztJQXhDWXFDLHFCQXdDWnJDO0lBeENZc0MscUJBd0NadEM7SUF4Q1l1QyxhQXdDWnZDO0lBeENZd0MsY0F3Q1p4QztJQXhDWXlDLGNBd0NaekM7SUF4Q1kxakYsTUF3Q1owakY7SUF4Q1kwQyx3QkF3Q1oxQztJQXhDWTJDLGNBd0NaM0M7SUF4Q1k0QyxlQXdDWjVDO0lBeENZNkMsY0F3Q1o3QztJQXhDWThDLFlBd0NaOUM7SUF4Q1krQyxRQXdDWi9DO0lBeENZZ0QsUUF3Q1poRDtVQUFBQTtJQXhDWWlELFdBd0NaakQ7SUF4Q1lrRCxXQXdDWmxEO0lBeENZbUQsaUJBd0NabkQ7SUF4Q1k3NUIsV0F3Q1o2NUI7SUF4Q1lvRCxhQXdDWnBEO0lBeENZbFgsaUJBd0Naa1g7SUF4Q1lxRCxhQXdDWnJEO0lBeENZalgsaUJBd0NaaVg7SUF4Q1lzRCxpQkF3Q1p0RDtJQXhDWXVELGlCQXdDWnZEO0lBeENZTixxQkF3Q1pNO0lBeENZd0QsdUJBd0NaeEQ7SUF4Q1l5RCx1QkF3Q1p6RDtJQXhDWTBELFNBd0NaMUQ7SUF4Q1lwQixVQXdDWm9CO0lBeENZMkQsWUF3Q1ozRDtJQXhDWTRELFlBd0NaNUQ7WUFVQXhwRixVQUFNbUosR0FBRW9QO0lBQ1Y7S0FBSWlKLE1BQU0sV0FuRElsakIsVUFrRE42SyxHQUFFb1A7S0FFYyxNQUFBLFdBcERWMnlFLFdBa0ROL2hGLEdBRTJCLFdBcERyQmdpRixXQW1EVjNwRTtJQUNEO01BQUE7UUFwRFdwakI7UUFvRFgsV0FwRFc2c0YsVUFvREosV0FwRElDLFdBa0ROL2hGLEdBQUVvUDtRQWxESTI1RDtLQXFEVCxPQUZEMXdEO0lBT0c7NEJBQTZDLFdBMUR0Q3pNLGFBbURWeU07MEJBTzRCLFdBMURsQnpNLGFBa0RKd0Q7S0FRSCxxQkFBTyxXQTFEQXhELGFBa0RONUw7SUFNSixPQUFBLFdBM0dKdTNCLFNBMkdJO0dBRWdFO1lBR2xFemdDLFVBQU1rSixHQUFFb1A7SUFDVjtLQUFJaU8sT0FBTyxXQTlER2pvQixXQTZETjRLLEdBQUVvUDtLQUVOODBFLFdBQVcsV0EvRERsdkYsVUE2RE5nTCxHQUFFb1A7SUFHUCxHQUFBLFdBaEVXbGEsVUE2RE44SyxHQUFFb1A7S0FHd0IsVUFBQSxXQWhFcEJ3eEUsZUE4RFZ2akU7S0FFUyxHQUFBLDBCQURUNm1FO01BTUc7K0JBQThDLFdBckV2Q3Q0RSxhQThEVnlSOzhCQU80QixXQXJFbEJ6UixhQTZESndEO09BUUgsdUJBQU8sV0FyRUF4RCxhQTZETjVMO01BTUosT0FBQTtlQXRISnUzQixTQXNISTs7O0lBR0MsT0FSRGxhO0dBUUs7R0FHUSxJQUFmOG1FLGVBQWUsV0F6RUhiO1lBMEVaYyxtQkFBbUJwa0YsR0FBRW9QO0lBQUksVUFBQSxXQTFFYnJhLFVBMEVPaUwsR0ExRVA4aUY7SUEwRWEsYUFEVixXQXpFSC90RixVQTBFU3FhLEdBRHJCKzBFO0dBQzBEO1lBRTFEcHRGLFVBQU1pSixHQUFFb1A7SUFDSSxJQUFWaTFFLFVBQVUsV0E3RUFodkYsV0E0RU4ySyxHQUFFb1A7O09BRVAsV0E5RVdsYSxVQTRFSmthLEdBNUVJMjVEO0tBOEVtQzs7T0FKL0NxYixtQkFHRUMsU0FETWoxRTtZQUV1QyxXQTlFbkNsYSxVQThFbUMsV0E5RW5DZSxXQTZFVm91RixTQURNajFFLElBQUZwUDs7S0FPRDtpQ0FBaUQsV0FuRjFDNEwsYUE2RVZ5NEU7NkJBTTRCLFdBbkZsQno0RSxhQTRFSndEO01BT0gsdUJBQU8sV0FuRkF4RCxhQTRFTjVMO0tBS0osT0FBQSxXQXBJSnUzQixTQW9JSTs7SUFHQyxPQVBEOHNEO0dBT1E7WUFHVnJ0RixVQUFNZ0osR0FBRW9QO0lBQ1YsS0FkRWcxRSxtQkFhTXBrRixHQUFFb1AsSUFPTCxPQUFBLFdBOUZTblosV0F1Rk4rSixHQUFFb1A7SUFNSDs7Ozs7U0FBaUQsV0E3RjFDeEQsYUE2Rm9ELFdBN0ZwRDNWLFdBdUZOK0osR0FBRW9QOzs0QkFNc0IsV0E3RmxCeEQsYUF1Rkp3RDtLQU1ILHVCQUFPLFdBN0ZBeEQsYUF1Rk41TDtJQUlKLE9BQUEsV0E5SUp1M0IsU0E4SUk7R0FHTTtZQUdSK3NELE1BQUl0a0Y7SUFBSSxPQUFHLFdBakdDakwsVUFpR1JpTCxHQWpHUThpRjtjQWlHa0I7Y0FBNkIsV0FqRy9DaG1GLE9BaUdSa0Q7R0FBNEQ7WUFDaEV1a0YsTUFBSXZrRjtJQUFJLE9BQUcsV0FsR0NqTCxVQWtHUmlMLEdBbEdROGlGO2NBa0drQjtjQUE2QixXQWxHL0N4OEIsS0FrR1J0bUQ7R0FBNEQ7YUFsR3BENGlGO0lBcUdULE1BQUE7WUFFTDRCLGNBQWdCMytFLEtBQThCcVc7SUFDaEQsR0FEa0JyVztTQUFRQyxNQUFSRCxRQUFBSSxRQUFRSDs7U0FBUkc7SUFDYSxVQUFBLFdBeEdmdzZFLGNBdUdnQ3ZrRTtJQUN6QyxPQUFBLFdBeEdTb25FLFVBd0dULCtCQURXcjlFO0dBQ2dDO1lBR2hEdytFLGdCQUFrQjUrRSxLQUE4QnFXO0lBQ2xELEdBRG9Cclc7U0FBUUMsTUFBUkQsUUFBQUksUUFBUUg7O1NBQVJHO0lBQ21CLFVBQUEsV0E1R3ZCdzhFLFlBMkdrQ3ZtRTtJQUNyQyxPQUFBO2FBNUdHc21FLGdCQTRHSCwrQkFET3Y4RTtHQUNvQztPQUd0RHkrRSxzQ0FSQUYsZ0JBSUFDO1lBVUFFLG1CQUFxQjkrRSxLQUE4QnNYLElBQUdDO0lBQ3hELEdBRHVCdlg7U0FBUUMsTUFBUkQsUUFBQUksUUFBUUg7O1NBQVJHO0lBQzZCO0tBQUEsTUFBQSxXQXRIcEN3NkUsY0FxSHdDcmpFO0tBQ3BCLE1BQUEsV0F0SHBCcWpFLGNBcUhxQ3RqRTtJQUM5QyxPQUFBO2FBdEhTbW1FLFVBc0hULGdDQURnQnI5RTtHQUM2QztZQUdsRTIrRSxxQkFBdUIvK0UsS0FBOEJzWCxJQUFHQztJQUMxRCxHQUR5QnZYO1NBQVFDLE1BQVJELFFBQUFJLFFBQVFIOztTQUFSRztJQUNpQyxJQUFBLE1BQUEsV0ExSDFDdzhFLFlBeUgwQ3JsRSxLQUNkLE1BQUEsV0ExSDVCcWxFLFlBeUh1Q3RsRTtJQUMxQyxPQUFBO2FBMUhHcWxFLGdCQTBISCxnQ0FEWXY4RTtHQUMrQzs7SUFHdEU0K0U7MEJBUkFGLHFCQUlBQztZQVVBejhCLFdBQVdub0Q7SUFDYjtLQUNTLFVBQUEsV0FySU95Z0YsY0FtSUh6Z0Y7S0FFSixPQUFBOztJQUVKLEdBQUEsV0F2SVdsTCxVQW1JSGtMLEdBbklHK29FO0tBd0lrRCx1QkFBTSxXQXhJeERuOUQsYUFtSUg1TDtLQUtOO09BM0xMdTNCLFNBMkxhOztJQUNJLElBQWI0d0IsaUJBeklVeTZCOztLQTBJUjs7T0FBQTtTQTFJUXRyRjtTQUFBeXhFO1NBMElHO1dBMUlIOFksV0FtSUg3aEYsR0FPaUIsV0ExSWRraUYsY0FBQXBDLE9BeUlWMzNCO2FBQUFBO0tBQUFBLGdCQUFBQTs7R0FJTzs7OztPQTdJRzc0QjtPQUFBZ3hEO09BQUFDO09BQUFDO09BQUFDO09BQUFqdEU7T0FBQUM7T0FBQTZhO09BQUExaUI7T0FBQW82QztPQUFBdkM7T0FBQTV1RDtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBb0M7T0FBQUQ7T0FBQTdCO09BQUFEO09BQUFFO09BQUFDO09BQUFxcEQ7T0FBQUM7T0FBQUM7T0FBQWdtQjtPQUFBeWI7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7O09BQUFDO09BQUFuWTtPQUFBK1c7T0FBQXFCO09BQUFoc0Y7T0FBQUM7T0FBQUM7T0FBQVE7T0FBQXl3RDtPQUFBeHdEO09BQUFDO09BQUFDO09BQUFDO09BQUFtckY7T0FBQWxyRjtPQUFBcUc7T0FBQUU7T0FBQUc7T0FBQUo7T0FBQUU7T0FBQUo7T0FBQStrRjtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBM2tGO09BQUE0a0Y7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQW1CO09BQUFsQjtPQUFBQztPQUFBQztPQUFBbm1GO09BQUFvbUY7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7O1dBa0RaeHNGLFdBV0FDLFdBZUFDLFdBV0FDLFdBVUFzdEYsT0FDQUM7T0FsR1lqQjtPQUFBQztPQUFBLzhCO09BQUFpOUI7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUo7T0FBQXJhO09BQUFDO09BQUEyVztPQUFBOEQ7T0FBQTVFO09BQUErRTtPQUFBQztPQStHZFM7T0FjQUc7T0FNQTE4QjtpQ0FuSWM0N0I7OztFOzs7Ozs7R0NsREw7O0lBQUE7SUFtQmM7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztJQ2pCdkJ4c0Q7WUFLRS9uQyxJQUFLRixHQUFPQyxHQUFJLE9BQUpBLElBQVBELElBQUFBLElBQU9DLEVBQTBCOzs7Ozs7Ozs7Ozs7Ozs7O1lBdUJ4Q3drQixnQkFBVyx5Q0FFYTtZQUd4QjJoRDtJQUFTLDhCQUNBO3VCQUNDO1FBQzJCQTtJQUF1QixPQUF2QkE7R0FBNkI7WUE4QmxFN3JELFVBQVU3SixHQUFHM0o7YUFkUHl1RjtLQUFNO01BR2dCO09BRG5CeDlDO09BUlMxWDtPQVEwQjNHO09BQUdzZTtPQUNyQ3N1QixLQXRCVkgsT0FxQitDbnVCO09BQ3pDcXVCLEtBdEJORixPQXFCU3B1QjtNQUZIdzlDLElBRUd4OUM7TUFGSHc5QyxJQUV5Q3Y5QztnQkFBdENEO1dBWk15OUMsaUJBWU56OUMsVUFBQUEsVUFBQUE7T0FWQyxRQUFBLFdBc0JHanhDLFNBeEJFMHVGLFVBSUduMUQ7UUFGaEIsTUFBQTs7Z0JBVTZDMlg7V0FOaEN5OUMsa0JBTWdDejlDLFdBQUFBLFdBQUFBO09BSnJDLFFBQUEsV0FnQkdseEMsU0FsQkUydUYsV0FGR3AxRDtRQUloQixNQUFBOztNQVVZLFVBdkRacGdDLElBa0RJb21FLElBQUlDO1NBRGtDNXNDLE1BTTlCO09BQVosTUFBQTtNQUNZLFVBQUEsNEJBTlIyc0MsSUFBSUM7TUFNQSxPQUFBO09BQVIsTUFBQTs7O0tBUmtCO0lBUVM7SUFLTixPQWRqQml2QixJQWNJOWtGO0dBQWdDO1lBVzFDaWxGLGNBQ0szMUY7SUFEVyxVQUNYQSx3QkFBQUE7S0FDa0M7TUFEL0JnNEMsT0FBSGg0QztNQUFzQzQxRixhQUF0QzUxRjtNQUFrRGk0QyxRQUFsRGo0QztNQUNrQyxNQTlDdkNvbUUsT0E2Q3VEbnVCO01BQ3RDLE1BMUVmLzNDLElBNEJGa21FLE9BNkNRcHVCO01BQ0o2OUMsYUFBYTtRQUFiQSxlQUR1Q0QsWUFBdEM1MUYsT0FDRDYxRjs7O0lBRWMsTUFBQTtHQUFZO1lBTTlCQyxRQUFRQztJQUNWLFVBRFVBLGdDQUFBQTtLQUlDO01BRERDLFlBSEFEO01BR3NDRSxhQUh0Q0Y7TUFJSnp2QixLQTFESkYsT0F5RFE0dkI7TUFFSnp2QixLQTNESkgsT0F5RDhDNnZCO1FBU3RDLDRCQVBKMXZCLFNBREFEO2dCQURJMHZCLGdDQUFBQTtPQXNCd0I7UUFOaEJFLGlCQWhCUkY7UUFvQlNHLGtCQXBCVEg7UUFzQndCLE1BL0VoQzV2QixPQTZFaUIrdkI7aUJBN0VqQi92QixPQXlFZ0I4dkI7UUFuQlJILGVBdUJTSTtRQXBCVEgsZUFIQUQ7UUFWUkosY0FVUUk7UUFWUkosY0FhUUs7UUEyQkYsT0EzQkVBOztpQkFvQlNHLHNDQUFBQTtZQWVHQyxVQWZIRCxvQkFlb0RFLFdBZnBERjtRQXBCVEgsZUFtQ1lJO1FBdENaTCxlQXNDNkRNO1FBZnBERixxQkF2QlRKO1FBdUJTSSxxQkFwQlRIO1FBYlJMLGNBYVFLO1FBYlJMLGNBVVFJO1FBVlJKLGNBaUNpQlE7UUF1QlQsT0F2QlNBOztPQWFTLE1BQUE7O01BbkJKLE1BQUE7O1FBK0JULDRCQTVDVDd2QixVQUNBQyxJQWZKb3ZCLGNBVVFJLFlBbUZOLE9BbkZNQTs7ZUFHc0NFLGlDQUFBQTtNQXlEWjtPQU5sQkssa0JBbkQ4Qkw7T0F1RDdCTSxtQkF2RDZCTjtPQXlEWixNQWxIbEM3dkIsT0E0R2dCa3dCO2dCQTVHaEJsd0IsT0FnSGlCbXdCO09BMURUUixlQXNEUU87T0FuRDhCTCxnQkFIdENGO09BVlJKLGNBVVFJO09BVlJKLGNBYThDTTtPQThEeEMsT0E5RHdDQTs7Z0JBbUQ5Qkssc0NBQUFBO1dBa0JJRSxVQWxCSkYsb0JBa0JxREcsV0FsQnJESDtPQW5EOEJMLGdCQXFFdUJRO09BeEU3RFYsZUF3RVlTO09BbEJKRixxQkF0RFJQO09Bc0RRTyxxQkFuRDhCTDtPQWI5Q04sY0FhOENNO09BYjlDTixjQVVRSTtPQVZSSixjQWdFZ0JXO09BMEJSLE9BMUJRQTs7TUFnQlUsTUFBQTs7S0FsQkosTUFBQTs7SUFsREosT0FGVlA7R0FvRkQ7WUFVUFcsU0FBU0MsTUFBS3RzQjtJQUNMLElBQVAyYyxTQS9GRjhPLFFBOEZjenJCO0lBRWhCLFVBRldzc0IsMkJBQUFBO1NBR0QzK0MsT0FIQzIrQztLQUlOLEtBQUEsNkJBREszK0MsTUFGTmd2QyxTQURPMlAsVUFDUDNQO0tBSUYsT0E3R0EyTyxjQXdHU2dCOztJQU1KLE1BQUE7R0FBWTtZQU1qQkMsVUFBVUQsTUFBS3RzQjtJQUNOLElBQVAyYyxTQTNHRjhPLFFBMEdlenJCO0lBRWpCLFVBRllzc0IsMkJBQUFBO1NBR3dDMStDLFFBSHhDMCtDO0tBSVAsS0FBQSw2QkFEK0MxK0MsT0FGaEQrdUMsU0FEUTJQLFVBQ1IzUDtLQUlGLE9BekhBMk8sY0FvSFVnQjs7SUFNTCxNQUFBO0dBQVk7WUFPWDkxRCxJQUFJbndCLEdBQUVnbUUsU0FBUW1nQixPQUFNOXZGLFNBQVFtNUIsR0FBRWpoQjtJQUNwQyxVQURVdk8sZ0JBQVVtbUYsY0FJYixXQUoyQjMyRCxHQUFFamhCO2FBQTFCdk87S0FNQSxJQURNczJELE1BTE50MkQsTUFNSndpQixNQUFJLFdBTmdCbnNCLFNBS1ZpZ0UsS0FMa0I5bUM7S0FVaEMsU0FKSWhOO01BTmMyakU7a0JBTWQzakUsYUFONEJnTixHQUFFamhCLE1BQTFCdk8sU0FBQUEsR0FBd0J3dkIsR0FBRWpoQjs7S0FBaEI0M0U7UUFBUm5nQixTQUFGaG1FLE9BQTBCdU87S0FjaEMsT0FkTXZPOztJQXFCQTtLQURBc25DLE9BcEJBdG5DO0tBb0JZdTdDLE1BcEJadjdDO0tBb0J1Q3VuQyxRQXBCdkN2bkM7S0FxQkp3UCxJQUFJLFdBckJnQm5aLFNBQVFtNUIsR0FvQlorckI7SUFFcEIsU0FESS9yQztLQXJCYzIyRTtRQUFSbmdCLFNBQUZobUUsT0FBMEJ1Tzs7aUJBcUI5QmlCO0tBbENOMDJFLFVBYVVsbUYsR0FBSm13QixJQW9CMkNvWCxPQXBCckN5K0IsU0FBUW1nQixPQUFNOXZGLFNBQVFtNUIsR0FBRWpoQjs7S0F6QnBDeTNFLFNBeUJVaG1GLEdBQUptd0IsSUFvQkltWCxNQXBCRTArQixTQUFRbWdCLE9BQU05dkYsU0FBUW01QixHQUFFamhCO0lBNEI3QixPQTVCR3ZPO0dBNkJQO1lBOUJIaytELE1BZ0NFbCtELEdBQUdnbUUsU0FBUzN2RSxTQUFTOHZGLE9BQU92MkQsS0FBS2k3QztJQUMzQixJQUFKM2tFLE1BaENFaXFCLElBK0JKbndCLEdBQUdnbUUsU0FBa0JtZ0IsT0FBVDl2RixTQUFnQnU1QixLQUFLaTdDO1dBQVpzYixXQXRKdkJmLFFBdUpJbC9FLE9BQUFBO0dBQzJCO1lBRzNCdzNCLE1BQU0xOUI7SUFDWixJQURZa0csTUFBQWxHO0lBQ1o7ZUFEWWtHLGtCQUVEO2NBRkNBO1VBQUFsRCxJQUFBa0Q7Z0JBQUFsRCxnQkFBQWtELE1BQUFsRDtVQUdjdUwsSUFIZHJJLFFBR0dzcEIsSUFISHRwQjs7O1VBR0dxMUMsTUFISHIxQyxRQUdjdzZCLE1BSGR4NkIsUUFHY3FJLElBQUFteUIsS0FBWGxSLElBQUErckI7S0FDdUQsZUFEdkQvckIsR0FBV2poQjs7R0FFK0M7WUFHbkU4YyxLQUFLcnJCO0lBQ1gsSUFEV2tHLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQTtnQkFBQUEsY0FBQUE7Z0JBQUFBLHlCQUFBdUIsSUFBQXZCLFFBQUFBLE1BQUF1QjtVQUdlOEcsU0FBWGloQjs7O1VBQUErckIsTUFISnIxQyxRQUdldzZCLE1BSGZ4NkIsUUFHZXFJLElBQUFteUIsS0FBWGxSLElBQUErckI7S0FDdUQsZUFEdkQvckIsR0FBV2poQjs7R0FFOEM7WUFJbEQ2M0U7SUFDRXBtRjtJQUNDM0o7SUFDRG01QjtJQUNBNjJEO0lBQ0FDO0lBQ0NDO0lBQ0FDO0lBQ0EzN0M7SUFDQUM7SUFFekIsSUFWd0I1a0MsTUFBQWxHO0lBVXhCO2VBVndCa0c7TUFXYixPQUFBLFdBTGNzZ0YsbUJBRUExN0MsY0FORHRiLEdBQ0E2MkQsTUFDQUM7Y0FKQXBnRjtVQVlUb3dELE1BWlNwd0QsUUFZR3c2QixNQVpIeDZCO01BYW5CLGFBQUEsV0Fab0I3UCxTQUNEbTVCLEdBVVQ4bUM7Z0JBRVIsV0FUa0Jpd0IsZUFFQTE3QyxVQUtWeXJCLEtBQVk1MUIsS0FUSDJsRCxNQUNBQztnQkFXakIsV0FUa0JFLG1CQUVBMTdDLGNBTkR0YixHQUNBNjJELE1BQ0FDOztLQWFkO01BRERoL0MsT0FoQmVwaEM7TUFnQkhxMUMsTUFoQkdyMUM7TUFnQlNxSSxJQWhCVHJJO01BZ0J3QnFoQyxRQWhCeEJyaEM7TUFpQmxCc0osSUFBSSxXQWhCZW5aLFNBQ0RtNUIsR0FjSCtyQjtLQUVuQixTQURJL3JDO01BRUMsT0FBQSxXQWRrQisyRSxlQUVBMTdDLFVBU0owUSxLQUFZaHRDLEdBYlQ4M0UsTUFDQUM7U0FKQXpjLGVBaUJsQnI2RCxJQUQwQyszQixRQUF2Q0Q7S0FoQmVwaEMsTUFBQTJqRTs7R0E4Qkw7WUFJZjBjLGNBQWUxN0MsaUJBQWlCZ2dDLGdCQUFhLE9BQUEsV0FBOUJoZ0MsVUFBaUJnZ0M7R0FBMEI7R0FDOUQsU0FBSTJiLGtCQUFtQjE3QyxjQUFhbGIsaUJBQVksT0FBQSxXQUF6QmtiLGNBQWFsYjtHQUE0QjtZQUY5RDYyRCxjQUdFem1GLEdBQUczSixTQUFRbTVCLEdBQUdxYixVQUFVQztJQUMxQixPQXRDb0JzN0M7YUFxQ2xCcG1GO2FBQUczSjthQUFRbTVCOzs7YUFGWCsyRDthQUNBQzthQUNjMzdDO2FBQVVDO0dBVVg7WUFJYjQ3QyxnQkFBZTc3QyxVQUFVamIsS0FBS2k3QyxrQkFBYSxPQUFBLFdBQTVCaGdDLFVBQVVqYixLQUFLaTdDO0dBQWdDO0dBQ2xFLFNBQUk4YixvQkFBbUI3N0MsY0FBYWxiLGlCQUFZLE9BQUEsV0FBekJrYixjQUFhbGI7R0FBNEI7WUFGOURnM0QsZUFHRTVtRixHQUFHM0osU0FBUW01QixHQUFHcWIsVUFBVUM7SUFDMUIsT0F0RG9CczdDO2FBcURsQnBtRjthQUFHM0o7YUFBUW01Qjs7O2FBRlhrM0Q7YUFDQUM7YUFDYzk3QzthQUFVQztHQVVYO1lBSWIrN0MsZ0JBQWVoOEMsaUJBQWlCZ2dDLE1BQUt0aEUsVUFBUyxPQUFBLFdBQS9Cc2hDLFVBQWlCZ2dDLE1BQUt0aEU7R0FBMEI7R0FDbkUsU0FBSXU5RSxvQkFBbUJoOEMsY0FBYWxiLEtBQUlybUIsWUFBUyxPQUFBLFdBQTFCdWhDLGNBQWFsYixLQUFJcm1CO0dBQTZCO1lBRm5FdzlFLGVBR0UvbUYsR0FBRzNKLFNBQVFtNUIsR0FBR3BzQixHQUFHeW5DLFVBQVVDO0lBQzdCLE9BdEVvQnM3QzthQXFFbEJwbUY7YUFBRzNKO2FBQVFtNUI7YUFBR3BzQjs7YUFGZHlqRjthQUNBQzthQUNpQmo4QzthQUFVQztHQVVkO1lBSWJrOEMsZ0JBQWVuOEMsVUFBVWpiLEtBQUtpN0MsTUFBS3RoRSxZQUFTLE9BQUEsV0FBN0JzaEMsVUFBVWpiLEtBQUtpN0MsTUFBS3RoRTtHQUFnQztHQUN2RSxTQUFJMDlFLG9CQUFtQm44QyxjQUFhbGIsS0FBSXJtQixZQUFTLE9BQUEsV0FBMUJ1aEMsY0FBYWxiLEtBQUlybUI7R0FBNkI7WUFGbkUyOUUsZ0JBR0VsbkYsR0FBRzNKLFNBQVFtNUIsR0FBR3BzQixHQUFHeW5DLFVBQVVDO0lBQzdCLE9BdEZvQnM3QzthQXFGbEJwbUY7YUFBRzNKO2FBQVFtNUI7YUFBR3BzQjs7YUFGZDRqRjthQUNBQzthQUNpQnA4QzthQUFVQztHQVVkO1lBSWJxOEMsZ0JBQWV0OEMsaUJBQWlCZ2dDLE1BQUt3YixNQUFLQyxNQUFPLE9BQUEsV0FBbEN6N0MsVUFBaUJnZ0MsTUFBS3diLE1BQUtDO0dBQThCO0dBQzVFLFNBQUljLG9CQUFtQnQ4QyxjQUFhbGIsS0FBSXkyRCxNQUFLQyxNQUFPLE9BQUEsV0FBN0J4N0MsY0FBYWxiLEtBQUl5MkQsTUFBS0M7R0FBaUM7WUFGNUVlLGVBR0VybkYsR0FBRzNKLFNBQVFtNUIsR0FBR3BzQixHQUFHQyxHQUFHd25DLFVBQVVDO0lBQ2hDLE9BdEdvQnM3QzthQXFHbEJwbUY7YUFBRzNKO2FBQVFtNUI7YUFBR3BzQjthQUFHQzthQUZqQjhqRjthQUNBQzthQUNvQnY4QzthQUFVQztHQVVqQjtZQUlidzhDLGdCQUFlejhDLFVBQVVqYixLQUFLaTdDLE1BQUt3YixNQUFLQyxNQUFPLE9BQUEsV0FBaEN6N0MsVUFBVWpiLEtBQUtpN0MsTUFBS3diLE1BQUtDO0dBQW9DO0dBQ2hGLFNBQUlpQixvQkFBbUJ6OEMsY0FBYWxiLEtBQUl5MkQsTUFBS0MsTUFBTyxPQUFBLFdBQTdCeDdDLGNBQWFsYixLQUFJeTJELE1BQUtDO0dBQWlDO1lBRjVFa0IsZ0JBR0V4bkYsR0FBRzNKLFNBQVFtNUIsR0FBR3BzQixHQUFHQyxHQUFHd25DLFVBQVVDO0lBQ2hDLE9BdEhvQnM3QzthQXFIbEJwbUY7YUFBRzNKO2FBQVFtNUI7YUFBR3BzQjthQUFHQzthQUZqQmlrRjthQUNBQzthQUNvQjE4QzthQUFVQztHQVVqQjtZQUliRCxTQUFTdDhCLEdBQUksV0FBSkEsR0FBVTtHQUN2QixTQUFJdThCLG9CQUFpQixTQUFJO1lBRnZCOXhCLEtBR0VoWixHQUFHM0osU0FBUW01QjtJQUFLLE9BbkdsQmkzRCxjQW1HRXptRixHQUFHM0osU0FBUW01QixHQUZYcWIsVUFDQUM7R0FDa0U7WUFJbEUyOEMsa0JBQWEsU0FBSTtHQUNyQixTQUFJQyxzQkFBaUIsU0FBSztZQUZ4QnJ0RSxJQUdFcmEsR0FBRzNKLFNBQVFtNUI7SUFBSyxPQXpHbEJpM0QsY0F5R0V6bUYsR0FBRzNKLFNBQVFtNUIsR0FGWGk0RCxZQUNBQztHQUNrRTtZQVc5RGx2QixlQUFlbUI7SUFDckIsVUFEcUJBO0tBRVYsTUFBQTthQUZVQSxTQUdUO1FBT0hyeUIsT0FWWXF5QjtjQVVacnlCLHVCQU44Q0MsUUFKbENveUIsU0FJNkMsT0FBWHB5QjthQU05Q0QsU0E5T1QwK0MsU0FvT3FCcnNCLE1BQWZuQixlQVVHbHhCLFFBQ1AsT0FYbUJxeUI7UUFLU25xQyxJQUxUbXFDLFNBS29CcHJELElBTHBCb3JEO2tCQUFBQSwyQkFLU25xQyxHQUFXamhCLE1Bek96Q3kzRSxTQW9PcUJyc0IsVUFBQUE7R0FZZjtZQXdCQXpwQyxPQUFPbHdCLEdBQUUybkYsU0FBUXR4RixTQUFRa2xEO0lBQy9CLFVBRGF2N0MsZ0JBQUUybkYsZ0JBSWI7YUFKVzNuRjtTQUtFdzJELE1BTEZ4MkQ7S0FNUixhQUFBLFdBTmtCM0osU0FBUWtsRCxLQUtoQmliO2dCQUxBbXhCO2dCQUFBQSxnQkFBRjNuRjs7SUFjSDtLQURENm9DLFNBYkk3b0M7S0FhUXMyRCxNQWJSdDJEO0tBYW1DdW5DLFFBYm5Ddm5DO0tBY1B3UCxJQUFJLFdBZGFuWixTQUFRa2xELEtBYVYrYTtJQUVuQixTQURJOW1EO2lCQUFBQTtnQkExUU4wMkUsVUE0UGFsbUYsR0FBUGt3QixPQWEwQ3FYLE9BYmpDb2dELFNBQVF0eEYsU0FBUWtsRCxPQUFsQnY3QztnQkF4UWJnbUYsU0F3UWFobUYsR0FBUGt3QixPQWFHMlksUUFiTTgrQyxTQUFRdHhGLFNBQVFrbEQsT0FBbEJ2N0M7SUFBRTJuRjtjQWFOOStDLHFCQWpDSyxPQWlDa0N0QjtjQUFBQSxvQkFoQ2xDLE9BZ0NMc0I7UUF4REs4d0IsT0F3RGtDcHlCO0lBdkRoRDtlQURjb3lCO1VBMEJSMmM7bUJBMUJRM2M7VUFBQXJ5QixPQUFBcXlCO2dCQUFBcnlCLG1CQUFBcXlCLE9BQUFyeUI7VUEwQlJndkMsU0ExQlEzYzs7O1VBMEJSMmMsU0ExQlEzYztLQTJCWixVQURJMmM7TUFFUSxNQUFBO0tBRFosU0FESUE7TUEzT040UCxVQTJPTTVQLFFBbkJBOWQsZUFpRDBDanhCO01BclJoRHkrQyxTQXVQTTFQLFFBOEJHenRDO01BaEJKLE9BZEN5dEM7O0tBSVE7TUFESTltRCxJQUhaOG1EO01BR3VCL25FLElBSHZCK25FO01BSUdqMUUsS0F6VlQrakYsUUFrVU01c0IsZUFpRDBDanhCO01BckJWLE1BcFp0Q211QixPQStZU3IwRDtNQUtTLE1BaGJoQjdSLElBNEJGa21FLE9BeWFTN3NCO0tBeEJGLFdBd0JFQSxRQTNCU3JaLEdBQVdqaEIsR0FNWCxxQ0FMVGxOOztHQXNDSDtZQXJFTjg4RCxTQXVFRW4rRCxHQUFHMm5GLFNBQVN0eEYsU0FBUW01QjtJQUFLLE9BalkzQjQxRCxRQXNXTWwxRCxPQTJCSmx3QixHQUFHMm5GLFNBQVN0eEYsU0FBUW01QjtHQUF5QztZQUczRHp2QixLQUFLQyxHQUFHTixNQUFNTztJQUNwQixJQURXaUcsTUFBQWxHLEdBQUcwNkQsU0FBQWg3RDtJQUNkO2VBRFd3RyxrQkFFQSxPQUZHdzBEO2NBQUh4MEQ7VUFHRjBoRixRQUhFMWhGLFFBR1cyaEYsU0FIWDNoRjtNQUdxQixPQUFBLFdBSFpqRyxHQUdYMm5GLE9BQWFDLFFBSFJudEI7O1NBMEJScHpCLE9BMUJLcGhDO2VBMEJMb2hDO1VBTkExWCxNQXBCSzFwQixRQXFCRzJrRSxPQXJCSDNrRSxnQkFBQUE7O1dBdUJnQjRoRixpQkFBY0M7T0FDUixPQUFBLFdBeEJiOW5GLEdBdUJPNm5GLE1BQWNDLE9BQ1IsV0F4QmI5bkYsR0FvQmQydkIsS0FDUWk3QyxNQXJCQW5ROzs7O2VBMEJScHpCO1dBQU0wZ0QsUUExQkQ5aEYsUUEwQmN3ekUsU0ExQmR4ekUsa0JBQUFBOztZQTBCcUQraEYscUJBQWNDO1FBQ2pELE9BQUE7aUJBM0JUam9GO2lCQTBCNENnb0Y7aUJBQWNDO2lCQUNqRCxXQTNCVGpvRixHQTBCUituRixPQUFhdE8sUUExQm5CMzVFLEtBMEJBdW5DLE1BMUJRb3pCLFFBQU16NkQ7Ozs7O1FBS01rb0YsU0FxQnBCN2dEO1FBckJrQzhnRCxVQXFCbEM5Z0Q7UUFwQkErZ0QsUUFOS25pRjtRQU9Hb2lGLFNBUEhwaUY7a0JBQUFBOztRQWlCVyxPQUFBO2lCQWpCRmpHLEdBTWRvb0YsT0FDUUMsUUFVUSxXQWpCRnJvRixHQUtNa29GLFFBQWNDLFNBTDFCMXRCOztZQVNhNnRCLHFCQUFjQztRQUNSLE9BQUE7aUJBVmJ2b0Y7aUJBU09zb0Y7aUJBQWNDO2lCQUNSO21CQVZidm9GLEdBTWRvb0YsT0FDUUMsUUFHaUMsV0FWM0Jyb0YsR0FLTWtvRixRQUFjQyxTQUwxQjF0Qjs7O2dCQTBCUnB6QiwyQkFBQUE7T0FJZ0I7UUFESW1oRCxPQUhwQm5oRDtRQUdrQ29oRCxRQUhsQ3BoRDtRQUcyQ3FoRCxRQTdCdEN6aUY7UUE2Qm1EMGlGLFNBN0JuRDFpRjtRQUFBMmpFLFVBQUEzakU7UUFBRzJuRTtVQThCUSxXQTlCRjV0RSxHQTZCNkIwb0YsT0FBYUMsUUFDMUIsV0E5QmhCM29GLEdBNkJNd29GLE1BQWNDLE9BN0IxQmh1QjtPQUFIeDBELE1BQUEyakU7T0FBR25QLFNBQUFtVDs7OztLQWdDSztNQURKaCtDLFFBL0JKM3BCO01BK0JpQmduRSxTQS9CakJobkU7TUFBQXFoQyxRQUFBcmhDO01BQUd5bkUsU0FnQ0ssV0FoQ0MxdEUsR0ErQkw0dkIsT0FBYXE5QyxRQS9CdEJudEUsS0EwQkF1bkMsTUExQlFvekIsUUFBTXo2RDtLQUFUaUcsTUFBQXFoQztLQUFHbXpCLFNBQUFpVDs7R0FnQzJDO1lBR25EeHRFLEtBQUtILEdBQUdDO0lBQ2QsSUFEV2lHLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQTtVQUdGMnBCLFFBSEUzcEIsUUFHV2duRSxTQUhYaG5FO01BR3FCLE9BQUEsV0FIbEJqRyxHQUdMNHZCLE9BQWFxOUM7O1NBQ2I1bEMsT0FKRXBoQyxRQUlJMHBCLE1BSkoxcEIsUUFJaUIya0UsT0FKakIza0UsUUFBQXFoQyxRQUFBcmhDO0tBQUwvRixLQUlHbW5DLE1BSktybkM7S0FNWixXQU5ZQSxHQUlDMnZCLEtBQWFpN0M7S0FKakIza0UsTUFBQXFoQzs7R0FPSTtZQUdUc2hELGFBQWE3b0YsR0FBR0M7SUFDdEIsSUFEbUJpRyxNQUFBbEc7SUFDbkI7ZUFEbUJrRyxrQkFFUjtjQUZRQTtVQUdUMnBCLFFBSFMzcEIsUUFHSm95RCxVQUhJcHlEO01BQUFBLFNBR3dCLFdBSHJCakcsR0FHWjR2QixPQUFLeW9DOzs7U0FDTGh4QixPQUpTcGhDLFFBSUgwcEIsTUFKRzFwQixRQUlFOHBCLFFBSkY5cEIsUUFBQXFoQyxRQUFBcmhDO0tBQWIyaUYsYUFJSXZoRCxNQUpZcm5DO0tBQUhpRyxTQU1OLFdBTlNqRyxHQUlOMnZCLEtBQUtJO0tBSkY5cEIsTUFBQXFoQzs7R0FPSTtZQUdyQjAwQjtJQUFhO0tBQ0ksT0FBQTtjQW5oQmpCMWtDO2NBbWhCaUI7O1NBQ0x2SCxrQkFBTEo7O1NBQUFDLGtCQUFLeW9DLG9CQUFBdG9DLFFBQUFzb0MsU0FBTDFvQyxNQUFBQztJQUE0QyxXQUE1Q0QsS0FBS0k7R0FBaUQ7Ozs7O09BeGY3RGpjO09Bc0NBbEs7T0EySUFxMEQ7T0FxQ0l4Z0M7T0FRQXJTO09BMklKclM7T0FoR0F5dEU7T0FnQ0FNO09BZ0NBTTtPQWhEQVQ7T0FnQ0FNO09BZ0NBTTtPQXNCQW50RTtPQU1BOGpEO09BMEVJcCtEO09BbUNBSTtPQVVBMG9GO09BVUo1c0I7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ2xoQkFodkQ7SUFDQWd0QjtJQUNBNXdCO0lBQ0FrdUI7OztZQSt2QkVvekMsWUFodkJVM3FFLEdBQUksT0FBSkEsUUFBaUM7WUFDN0M4cEUsWUFBWTlwRSxHQUFJLE9BQUpBLFFBQStCO1lBRTNDOG9GLHdCQUF3QjlvRjtJQUMxQixlQUQwQkE7O2NBQ0s7O0dBQXlEO1lBR3RGK29GLGlCQUFpQi9vRixHQUFFQztJQUNyQixLQURtQkQsTUFXZCxPQUFBLFdBWGdCQztJQUFGRDtJQUlqQixJQUFNLElBQ0oxUSxJQURJLFdBSmEyUTtVQVFQcUw7U0FBQUYsMEJBQUFFO0tBUkt0TDtLQVVmLE1BQUEsNEJBRlVvTDs7SUFSS3BMO0lBT2YsT0FGQTFRO0dBTUs7R0FLWTtJQUFuQjA1RixtQkFBbUI7Ozs7Ozs7Ozs7OztZQVduQjlwRixPQUFTMkcsV0FBb0M2MEI7SUFDL0MsR0FEVzcwQjtTQUFpQkMsTUFBakJELFFBQUFvakYsaUJBQWlCbmpGOztTQUFqQm1qRjtJQUNYLGFBRDJDOXBFLGlCQUFQNHNDLE9BQU81c0MsZ0JBQVA0c0M7SUFDakI7S0FBQSxPQUFBLDRCQURpQkE7S0FDaENtOUIsU0FBTywrQkFaVEY7S0FhRUcsU0FBTyx5QkFEUEQ7SUFFSjtZQUFVLDJCQUROQzs7O1lBRk9GO1lBQW9DdnVEOztHQVM5QztZQVlDMHVELEtBQUtwcEYsR0FBRTR2QjtJQUNUO0tBQUl2bUIsT0FBTyxXQURKckosU0FBRTR2QjtLQUdDLE9BQUEsNEJBSEg1dkI7SUFHRyxPQUFBLDZCQUZOcUo7R0FFZ0M7WUFHbENnZ0YsV0FBV3JwRixHQUFHZ21FLFNBQVNwMkMsS0FBS2k3QztJQUM5QjtLQUFJNXhFLElBUEZtd0YsS0FNV3BwRixHQUFZNHZCO0tBRXJCK1gsd0JBRlMzbkMsTUFDVC9HLE9BQUFBO0tBRUFrdEYsUUFIU25tRjtJQUdUbW1GO0lBUWlDO0tBQUEsT0F2RW5DcmMsWUE0RFc5cEU7S0FLVHNwRjtPQU1GLDRCQVRFM2hELE1BRllxK0IsZUFHWm1nQixPQUhxQnYyRCxLQUFLaTdDO09BRzFCc2IsVUFIU25tRixPQWFjLDRCQWJkQTtJQWdCTjtLQUFBLFdBQUEsNkJBWEhzcEYsVUFIQTNoRDtxQ0FGUzNuQyxNQUNUL0csT0FBQUEsS0FJQXF3RjtJQVdtQztHQUF1QjtZQUc1REMsbUJBQW1CdnBGO0lBQ3JCO0tBQUliLE1BRGlCYTtLQUVqQndwRixjQURBcnFGLE1BRGlCYTtLQUdyQixPQURJd3BGLGNBRmlCeHBGLE9BRWpCd3BGOztLQUc2QjtNQUFBLE9BQUEsNEJBSjdCcnFGO01BSUVzcUYsbUJBQW1CLCtCQTlEdkJUO2FBMERFN3BGLE1BSUVzcUY7O01BR2M7T0FBWkM7U0FBWSwyQkFIZEQ7T0FJRUUsWUFUYTNwRjtNQUFBQSxPQVFiMHBGO01BUmExcEY7TUFhSjtPQURUQyxhQUFHMnZCLEtBQUtpN0MsTUFBTyxPQS9CckJ3ZSxXQW1CbUJycEYsTUFZVjR2QixLQUFLaTdDLE1BQTRDO09BQzNDLE9BQUEsNEJBSlQ4ZTs7O1dBSUoxd0Y7O1FBQ2UsNEJBTFgwd0YsV0FJSjF3RixPQUFBQTtRQUNFLG1DQUZFZ0g7UUFFRixXQURGaEg7b0JBQUFBO1FBQUFBOzs7Ozs7Ozs7Ozs7R0FFTTtZQXFsQk5rdUMsSUFsbEJFbm5DLEdBQUc0dkIsS0FBS2k3QztJQS9GWmllLHdCQStGSTlvRjtJQXJDSnFwRixXQXFDSXJwRixNQUFHNHZCLEtBQUtpN0M7SUFFZCxPQXBCRTBlLG1CQWtCSXZwRjtHQUdjO1lBZ2xCaEJtd0IsSUE3a0JFbndCLEdBQUc0dkIsS0FBS2k3QztJQXJHWmllLHdCQXFHSTlvRjtJQTNDSnFwRixXQTJDSXJwRixNQUFHNHZCLEtBQUtpN0M7V0FBUjdxRSxXQXhCSnVwRixtQkF3Qkl2cEY7R0FPUztZQXVrQlhnckUsUUFwa0JNaHJFLEdBQUc0dkIsS0FBS2k3QztJQUNsQixZQWtrQkkxNkMsSUFua0JNbndCLEdBQUc0dkIsS0FBS2k3QyxPQUVUO0lBRVc7S0FBZCtlLGdCQTBuQkZqZixZQTluQk0zcUU7S0FLSnlXO09BQVE7Ozs7O1NBTERtWjtTQUlQZzZEO0lBRUosT0FBQSwyQkFESW56RTtHQUNhO1lBeWpCZnkwQyxNQXRqQklsckQ7SUF4SE44b0Ysd0JBd0hNOW9GO0lBRUssSUFBQSxPQUFBLDRCQUZMQSxxQkFDUjs7U0FDQS9HOztNQUNFO01BQUEsaUJBSE0rRyxNQUVSL0csT0FBQUE7TUFDRSxXQURGQTtrQkFBQUE7TUFBQUE7OztJQUZRK0c7O0dBS0s7WUF5bEJUeW1GLGNBdGxCWXptRixHQUFFNHZCLEtBQUtpYixVQUFVQztJQUlqQyxJQUFlLE9BaEZicytDLEtBNEVjcHBGLEdBQUU0dkIsTUFRaEIrcEMsd0JBUmMzNUQ7Y0FRZDI1RCxtQkFIaUIsT0FBQSxXQUxjN3VCLGNBQWZsYjthQVFoQitwQztLQUNvQyxXQTNJcENtUSxZQWtJYzlwRTtLQVNkLE9BQUE7K0JBREEyNUQsWUFSZ0IvcEMsS0FBS2liLFVBQVVDOztRQU1WdGIsSUFFckJtcUMsU0FGZ0NwckQsSUFFaENvckQ7SUFERyxhQUFBLFdBeklIbVEsWUFrSWM5cEUsSUFNT3d2QixHQU5MSTtjQU9nQixXQVBYaWIsVUFNV3Q4QjtjQUNnQixXQVBqQnU4QixjQUFmbGI7R0FTK0Q7WUE4a0I3RW0zRCxlQTNrQmEvbUYsR0FBRTR2QixLQUFLeHNCLEdBQUd5bkMsVUFBVUM7SUFDckMsSUFBZSxPQXpGYnMrQyxLQXdGZXBwRixHQUFFNHZCLE1BS2pCK3BDLHdCQUxlMzVEO2NBS2YyNUQsbUJBSGlCLE9BQUEsV0FGa0I3dUIsY0FBbEJsYixLQUFLeHNCO2FBS3RCdTJEO0tBQ3FDLFdBcEpyQ21RLFlBOEllOXBFO0tBTWYsT0FBQTsrQkFEQTI1RCxZQUxpQi9wQyxLQUFLeHNCLEdBQUd5bkMsVUFBVUM7O1FBR2R0YixJQUVyQm1xQyxTQUZnQ3ByRCxJQUVoQ29yRDtJQURHLGFBQUEsV0FsSkhtUSxZQThJZTlwRSxJQUdNd3ZCLEdBSEpJO2NBSWUsV0FKUGliLFVBR090OEIsR0FIVm5MO2NBSTRCLFdBSmYwbkMsY0FBbEJsYixLQUFLeHNCO0dBTTZEO1lBc2tCakZpa0YsZUFua0Jhcm5GLEdBQUU0dkIsS0FBS3hzQixHQUFHQyxHQUFHd25DLFVBQVVDO0lBQ3hDLElBQWUsT0FsR2JzK0MsS0FpR2VwcEYsR0FBRTR2QixNQUtqQitwQyx3QkFMZTM1RDtjQUtmMjVELG1CQUhpQixPQUFBLFdBRnFCN3VCLGNBQXJCbGIsS0FBS3hzQixHQUFHQzthQUt6QnMyRDtLQUNxQyxXQTdKckNtUSxZQXVKZTlwRTtLQU1mLE9BQUE7Z0NBREEyNUQsWUFMaUIvcEMsS0FBS3hzQixHQUFHQyxHQUFHd25DLFVBQVVDOztRQUdqQnRiLElBRXJCbXFDLFNBRmdDcHJELElBRWhDb3JEO0lBREcsYUFBQSxXQTNKSG1RLFlBdUplOXBFLElBR013dkIsR0FISkk7Y0FJZSxXQUpKaWIsVUFHSXQ4QixHQUhWbkwsR0FBR0M7Y0FJMkIsV0FKZHluQyxjQUFyQmxiLEtBQUt4c0IsR0FBR0M7R0FNNkQ7WUE4akJwRnVqRixlQTNqQmE1bUYsR0FBRTR2QixLQUFLaWIsVUFBVUM7SUFJbEMsSUFBZSxPQTlHYnMrQyxLQTBHZXBwRixHQUFFNHZCLE1BUWpCK3BDLHdCQVJlMzVEO2NBUWYyNUQsbUJBSGlCLE9BQUEsV0FMZTd1QixjQUFmbGI7YUFRakIrcEM7S0FDcUMsV0F6S3JDbVEsWUFnS2U5cEU7S0FTZixPQUFBO2dDQURBMjVELFlBUmlCL3BDLEtBQUtpYixVQUFVQzs7UUFNWHRiLElBRXJCbXFDLFNBRmdDcHJELElBRWhDb3JEO0lBREcsYUFBQSxXQXZLSG1RLFlBZ0tlOXBFLElBTU13dkIsR0FOSkk7Y0FPZSxXQVBWaWIsVUFNRHJiLEdBQVdqaEI7Y0FDNkIsV0FQN0J1OEIsY0FBZmxiO0dBUytEO1lBbWpCOUVzM0QsZ0JBaGpCY2xuRixHQUFFNHZCLEtBQUt4c0IsR0FBR3luQyxVQUFVQztJQUN0QyxJQUFlLE1BdkhicytDLEtBc0hnQnBwRixHQUFFNHZCLE1BS2xCK3BDLHdCQUxnQjM1RDtjQUtoQjI1RCxtQkFIaUIsT0FBQSxXQUZtQjd1QixjQUFsQmxiLEtBQUt4c0I7YUFLdkJ1MkQ7S0FDc0MsV0FsTHRDbVEsWUE0S2dCOXBFO0tBTWhCLE9BQUE7Z0NBREEyNUQsWUFMa0IvcEMsS0FBS3hzQixHQUFHeW5DLFVBQVVDOztRQUdmdGIsSUFFckJtcUMsU0FGZ0NwckQsSUFFaENvckQ7SUFERyxhQUFBLFdBaExIbVEsWUE0S2dCOXBFLElBR0t3dkIsR0FISEk7Y0FJYyxXQUpOaWIsVUFHTHJiLEdBQVdqaEIsR0FIVG5MO2NBSXdDLFdBSjNCMG5DLGNBQWxCbGIsS0FBS3hzQjtHQU02RDtZQTJpQmxGb2tGLGdCQXhpQmN4bkYsR0FBRTR2QixLQUFLeHNCLEdBQUdDLEdBQUd3bkMsVUFBVUM7SUFDekMsSUFBZSxNQWhJYnMrQyxLQStIZ0JwcEYsR0FBRTR2QixNQUtsQitwQyx3QkFMZ0IzNUQ7Y0FLaEIyNUQsbUJBSGlCLE9BQUEsV0FGc0I3dUIsY0FBckJsYixLQUFLeHNCLEdBQUdDO2FBSzFCczJEO0tBR1csVUE3TFhtUSxZQXFMZ0I5cEU7S0FNaEIsT0FBQTtnQ0FEQTI1RCxXQUxrQi9wQyxLQUFLeHNCLEdBQUdDLEdBQUd3bkMsVUFBVUM7O1FBR2xCdGIsSUFFckJtcUMsU0FGZ0NwckQsSUFFaENvckQ7SUFERyxhQUFBLFdBekxIbVEsWUFxTGdCOXBFLElBR0t3dkIsR0FISEk7Y0FJYyxXQUpIaWIsVUFHUnJiLEdBQVdqaEIsR0FIVG5MLEdBQUdDO2NBSXVDLFdBSjFCeW5DLGNBQXJCbGIsS0FBS3hzQixHQUFHQztHQWFYO1lBSWJ3bkMsU0FBU3Q4QixHQUFJLFdBQUpBLEdBQVU7R0FDdkIsU0FBSXU4QixvQkFBaUIsU0FBSTtZQStnQnJCOXhCLEtBOWdCQWhaLEdBQUU0dkI7SUFBTyxPQWdoQlQ2MkQsY0FoaEJBem1GLEdBQUU0dkIsS0FGRmliLFVBQ0FDO0dBQ29EO1lBb2ZwRHp3QixJQWpmRXJhLEdBQUU0dkI7SUFDUixJQUFlLE1BdEpidzVELEtBcUpJcHBGLEdBQUU0dkIsTUFJTitwQyx3QkFKSTM1RDtjQUlKMjVELG1CQUZpQjthQUVqQkE7S0FBa0MsVUEvTWxDbVEsWUEyTUk5cEU7S0FJSSxPQUFBLDZCQUFSMjVELFdBSk0vcEM7O1FBR2VKLElBQ3JCbXFDO2lCQUR1QyxXQTlNdkNtUSxZQTJNSTlwRSxJQUdpQnd2QixHQUhmSTtHQUkrQztZQW1lbkRNLE9BaGVLbHdCLEdBQUU0dkI7SUFoTlRrNUQsd0JBZ05POW9GO0lBRUQ7S0FBSi9HLElBOUpGbXdGLEtBNEpPcHBGLEdBQUU0dkI7S0FHUCtYLHdCQUhLM25DLE1BRUwvRyxPQUFBQTtLQUVBNHdGLG1CQUpLN3BGO0lBSUw2cEY7SUFHcUQ7S0FBQSxNQXpOdkQvZixZQWtOTzlwRTtLQU1Mc3BGLFdBQ0YsNkJBSkUzaEQsTUFDQWtpRCx1QkFKT2o2RDtXQVNKLDZCQU5IK1gsTUFHQTJoRDtLQUdtQyxpQkFUOUJ0cEYsTUFFTC9HLE9BQUFBLEtBSUFxd0Y7O1dBRkFPO2tCQUpLN3BGLE9BVTZCLDRCQVY3QkE7O0dBVXlDO1lBMmU5QzhCLE9BeGVLOUIsR0FBSSxPQUFKQSxLQUFZO1lBeWVqQitULFNBemVLL1QsR0FDTSxhQUROQSxhQUNrQjtZQXNldkJELEtBdmVLQyxHQUdDTixNQUFNTztJQUNoQixTQUpTRCxNQUtKLE9BRktOO0lBS0UsSUFETjhTLElBUEd4UyxpQkFRSHdZLFVBTEk5WSxPQU1KOFosSUFUR3haO0lBVVA7S0FWT0E7S0FZUSxJQUFBLE1BQUEsNEJBTFh3UyxPQUtGOztVQUFBdlo7O1dBSUk2d0YsU0FoQkM5cEYsU0FZTC9HO2lCQUlJNndGO2lCQUFBQTtTQVJGdHhFLFNBUW1CLDZCQUFqQnN4RSxRQVJGdHhFLFFBTFV2WTs7YUFZTzJ2QixNQUNmazZELFdBRDRCamYsT0FDNUJpZjtTQVJGdHhFLFNBTytDLFdBWnJDdlksR0FZTzJ2QixLQUFhaTdDLE1BUDlCcnlEOztPQUlGLFVBQUF2ZjtrQkFBQUE7T0FBQUE7Ozs7VUFVVXFTO1NBQUFGLDBCQUFBRTtLQXRCTHRMLE9BU0h3WjtLQWVGLE1BQUEsNEJBRlVwTzs7SUF0QkxwTCxPQVNId1o7V0FEQWhCO0dBZ0JRO1lBd2NWcFksTUFyY0lKLEdBQUdDO0lBQ1gsU0FEUUQsTUFFSDtJQUdILElBREl3UyxJQUpFeFMsaUJBS0Z3WixJQUxFeFo7SUFNTjtLQU5NQTtLQVFTLElBQUEsTUFBQSw0QkFKWHdTLE9BSUY7O1VBQUF2Wjs7V0FJSTZ3RixTQVpBOXBGLFNBUUovRztpQkFJSTZ3RjtpQkFBQUE7U0FBVSw2QkFBVkEsUUFaRzdwRjtpQkFXWTJ2QixNQUNmazZELFdBRDRCamYsT0FDNUJpZixXQURzQyxXQVhuQzdwRixHQVdZMnZCLEtBQWFpN0M7T0FIaEMsVUFBQTV4RTtrQkFBQUE7T0FBQUE7Ozs7VUFRVXFTO1NBQUFGLDBCQUFBRTtLQWhCTnRMLE9BS0Z3WjtLQWFGLE1BQUEsNEJBRlVwTzs7SUFoQk5wTCxPQUtGd1o7O0dBYVE7WUFrYlZyWixLQS9hR0gsR0FBR0M7SUFBSSxPQWdiVkcsTUFoYkdKLG1CQUErQjZxRSxNQUFRLE9BQUEsV0FBcEM1cUUsR0FBNEI0cUUsTUFBYztHQUFDO1lBOGFqRDhELFVBN2FRM3VFLEdBQUdDO0lBQUksT0ErYWZHLE1BL2FRSixZQUF3QjR2QixZQUFlLE9BQUEsV0FBcEMzdkIsR0FBcUIydkIsS0FBb0I7R0FBQztZQUVuRG02RCxnQkFBZ0JDLE9BQU0vd0Y7SUFDNUIsSUFENEI2TCxNQUFBN0w7SUFDNUI7S0FBYyxJQUFWZ3hGLDJCQURrQkQsT0FBTWxsRixTQUFBQTtLQUV6QixLQUFBLDRCQURDbWxGO01BR0MsT0FBQSw2QkFIREE7S0FFdUIsSUFIQ3I4RCxNQUdELDRCQUhDOW9CO0tBQUFBLE1BQUE4b0I7O0dBSUc7WUF5WjNCcXVDLFdBdFpTajhEO0lBQ2IsU0FEYUE7S0FDUTtPQTFTbkJ1M0IsU0EwUzJCO0lBQVIsT0FSZnd5RCxnQkFPTy9wRjtHQUVZO1lBbVpyQmc4RCxPQWhaS2g4RCxHQUFJLE9BMGFUK1QsU0ExYUsvVCxhQVpIK3BGLGdCQVlHL3BGLFVBQWlFO1lBK1l0RTZKLFVBN1lRcWdGLGVBQWNDLGdCQUFlbnFGO0lBQ3pDLElBQWEsTUFBQSw0QkFENEJBLHFCQUN6Qzs7U0FBQS9HOztNQUN5QyxJQUFBLE1BbFN2QzZ3RSxZQWdTdUM5cEUsSUFFckIsdUJBRnFCQSxNQUN6Qy9HLE9BQUFBO01BQ0U7TUFBQSxVQURGQTtpQkFBQUE7TUFBQUE7OztJQUlFO0tBREVteEY7T0FrYUFycUY7U0F0YXFDQzs7a0JBS2Y0dkIsS0FBS2k3QyxNQUFLNXhFO1VBQ2hDLFdBTlFpeEYsZUFLY3Q2RDtVQUV0QixXQVBzQnU2RCxnQkFLS3RmO1VBRTNCLE9BQUEsNEJBRmdDNXhFO1NBRzNCO09BSkxteEYsYUFKcUNwcUY7SUFVekMsTUFBQTtHQUE0QjtZQUl4QnluRixXQUFTbDVFLFVBQU0sT0FBTkEsRUFBTztHQUNwQixTQUFJbTVFLGVBQWFsNEQsR0FBRXh2QjtJQUVGLDJCQUE0QyxXQUYxQ0EsU0FBRnd2QjtJQUNmLE1BQUE7R0FDcUY7WUFzYW5GeEwsU0FwYVNoa0IsR0FBRTR2QjtJQUFNLE9Bc2FqQm0zRCxlQXRhUy9tRixHQUFFNHZCLEtBQUY1dkIsR0FMVHluRixZQUNBQztHQUlrRTtZQThZbEVsakUsUUF6WU14a0IsR0FBR0M7SUFDYixPQUFZO2FBNVVWZ047c0JBNFVleEY7Y0FzWWJySDtnQkF2WU1KO3lCQUVTNHZCLEtBQUtpN0M7aUJBQVcsVUFBQSxXQUZ0QjVxRSxHQUVNMnZCLEtBQUtpN0M7aUJBQVcsYUFBa0IsV0FEcENwakU7Z0JBQ2lEO2NBQWhFO2FBQ0s7R0FBQztZQXFZSnZGLE9BbFlLbEMsR0FBR0M7SUFBSSxPQW1ZWnVrQixRQW5ZS3hrQixtQkFBaUM2cUUsTUFBUSxPQUFBLFdBQXRDNXFFLEdBQThCNHFFLE1BQWM7R0FBQztZQXFZckR0bUQsU0FwWU92a0IsR0FBR0M7SUFBSTs7WUFrWWR1a0I7Y0FsWU94a0IsWUFBK0I0dkIsS0FBS2k3QyxNQUFRLFdBQUksV0FBN0M1cUUsR0FBNEIydkIsS0FBS2k3QyxNQUEwQjtHQUFFO1lBbVl2RXRvRSxRQWxZTXZDLEdBQUdDO0lBQUk7O1lBaVlidWtCLFFBallNeGtCLG1CQUFzQzZxRSxNQUFRLFdBQUksV0FBL0M1cUUsR0FBbUM0cUUsTUFBb0I7R0FBRTtZQXFZbEV0OUMsT0FuWUt2dEIsR0FBR0M7SUFDWixPQW1ZSUY7YUFwWUtDOztzQkFDZTR2QixLQUFLaTdDLE1BQUtyeUQ7Y0FBTyxPQUFHLFdBRGhDdlksR0FDWTJ2QixLQUFLaTdDO3dCQUFpQyw0QkFBNUJyeUQ7d0JBQUFBO2FBQTRDO0dBQUM7WUFpWTNFSixNQTlYSXBZLEdBQUdDO0lBQ1gsT0ErWElGO2FBaFlJQzs7NkJBQ3VCNnFFLE1BQUtyeUQ7Y0FBTyxPQUFHLFdBRG5DdlksR0FDb0I0cUU7d0JBQTJCLDRCQUF0QnJ5RDt3QkFBQUE7YUFBc0M7R0FBQztZQW1ZdkVsWSxLQWhZR04sR0FBR0M7SUFFUixJQURFb3FGLFFBMVNGbnJGLFdBeVNLYyxXQUFBQSxPQUFBQTtJQXFYSEk7TUFyWEdKO2VBSVU0dkIsS0FBS2k3QyxNQUFRLE9BcVcxQjFqQyxJQXhXQWtqRCxPQUdhejZELEtBQWtDLFdBSnpDM3ZCLEdBSU8ydkIsS0FBS2k3QyxPQUEyQztJQUFqRSxPQUhJd2Y7R0FJQztZQTBYRGhxRixJQXZYRUwsR0FBR0M7SUFBSSxPQXdYVEssS0F4WEVOLG1CQUE4QjZxRSxNQUFRLE9BQUEsV0FBbkM1cUUsR0FBMkI0cUUsTUFBYztHQUFDO1lBK1YvQ3JyRSxLQTlWR1EsR0FBSSxPQXNYUEssSUF0WEdMLGlCQUFJLGNBQWM7WUF5WHJCNnRCLFlBdlhVN3RCLEdBQUdDO0lBRWYsSUFERW9xRixRQXJURm5yRixXQW9UWWMsV0FBQUEsT0FBQUE7SUEwV1ZJO01BMVdVSjtlQUlHNHZCLEtBQUtpN0M7T0FDZCxZQUFBLFdBTFM1cUUsR0FJQTJ2QixLQUFLaTdDO21CQUdWO1dBREhrRztPQUFZLE9Bd1ZqQjVwQyxJQTdWQWtqRCxPQUdhejZELEtBRVJtaEQ7TUFDSztJQUhkLE9BSElzWjtHQU9DO1lBOFdEMzhELFdBM1dTMXRCLEdBQUdDO0lBQUksT0E0V2hCNHRCLFlBNVdTN3RCLG1CQUFxQzZxRSxNQUFRLE9BQUEsV0FBMUM1cUUsR0FBa0M0cUUsTUFBYztHQUFDO1lBK1c3RGxoRCxRQTdXTTNwQixHQUFHQztJQUNiLE9BeVdJNHRCO2FBMVdNN3RCO3NCQUNhNHZCLEtBQUtpN0M7Y0FBUSxPQUFHLFdBRDFCNXFFLEdBQ1UydkIsS0FBS2k3QyxZQUFBQTthQUFnRDtHQUFDO1lBMld6RWpuRCxPQXhXSzVqQixHQUFHQztJQUFJLE9BeVdaMHBCLFFBeldLM3BCLG1CQUFpQzZxRSxNQUFRLE9BQUEsV0FBdEM1cUUsR0FBOEI0cUUsTUFBYztHQUFDO1lBdVdyRG9FLFlBdFdVanZFLEdBQUdDO0lBQUksT0F3V2pCMHBCLFFBeFdVM3BCLFlBQTBCNHZCLFlBQWUsT0FBQSxXQUF0QzN2QixHQUF1QjJ2QixLQUFvQjtHQUFDO1lBMFd6RHMvQyxlQXhXYWx2RSxHQUFHQztJQUNwQjtLQUFJcXFGLEtBelVGcHJGLFdBd1VlYyxXQUFBQSxPQUFBQTtLQUlib0IsS0E1VUZsQyxXQXdVZWMsV0FBQUEsT0FBQUE7SUFzVmJJO01BdFZhSjtlQU9BNHZCLEtBQUtpN0M7T0FDYixZQUFBLFdBUlc1cUUsR0FPSDJ2QixLQUFLaTdDOztZQUVaa0c7UUFBWSxPQWlVbEI1cEMsSUF6VUFtakQsSUFNYTE2RCxLQUVQbWhEOztXQUNDd1o7T0FBWSxPQWdVbkJwakQsSUF0VUEvbEMsSUFHYXd1QixLQUdOMjZEO01BQXNDO0lBQ2pELFdBVklELElBR0FscEY7R0FPRTtZQTRWRjRTLGNBelZZaFUsR0FBR0M7SUFBSSxPQTBWbkJpdkU7YUExVllsdkUsbUJBQXdDNnFFLE1BQVEsT0FBQSxXQUE3QzVxRSxHQUFxQzRxRSxNQUFjO0dBQUM7WUE0Vm5Fei9CLGNBMVZZcHJDLEdBQUdDO0lBQ25CLE9BdVZJaXZFO2FBeFZZbHZFO3NCQUNVNHZCLEtBQUtpN0M7Y0FBUSxPQUFHLFdBRHZCNXFFLEdBQ08ydkIsS0FBS2k3QyxZQUFBQSxZQUFBQTthQUF3RDtHQUFDO1lBd1ZwRjE4QyxhQXJWV251QixHQUFHQztJQUFJLE9Bc1ZsQm1yQzthQXRWV3ByQyxtQkFBdUM2cUUsTUFBUSxPQUFBLFdBQTVDNXFFLEdBQW9DNHFFLE1BQWM7R0FBQztZQXVWakUyZixZQXJWVXhxRixHQUFFeXFGLElBQUlwdkU7SUFDcEIsT0EwVklnc0U7YUEzVlVybkY7YUFBRXlxRjthQUFGenFGO2FBQU1xYjtzQkFNSHd2RCxrQkFBWSxPQUFaQSxLQUFnQjtzQkFDWmo3QyxLQUFJNXZCLEdBQUVxYjtjQUNULElBQVYwQyxZQUFVLFdBRFMxQztjQTZTdkI4ckIsSUE3U3FCbm5DLEdBQUo0dkIsS0FDYjdSO2NBQ0osT0FESUE7YUFFRztHQUFDO1lBNFVSMnNFLGFBelVXMXFGLEdBQUV5cUYsSUFBSXB2RTtJQUNyQixPQTZVSWdzRTthQTlVV3JuRjthQUFFeXFGO2FBQUZ6cUY7YUFBTXFiO3NCQU1Kd3ZELGtCQUFZLE9BQVpBLEtBQWdCO3NCQUNaajdDLEtBQUk1dkIsR0FBRXFiO2NBQ1QsSUFBVjBDLFlBQVUsV0FEUzFDLFdBQU51VTtjQWdTakJ1WCxJQWhTcUJubkMsR0FBSjR2QixLQUNiN1I7Y0FDSixPQURJQTthQUVHO0dBQUM7WUF3VVI0c0UsZ0JBdGhCQTNxRixHQUFFNHZCO0lBQU4sSUFvTkkvUixTQTRUQTRvRSxjQWhoQkF6bUYsR0FBRTR2QixLQUZGaWIsVUFDQUM7SUFzTkQsR0FBQSw0QkFEQ2p0QixTQXNSQXFTLE9BMWVBbHdCLEdBQUU0dkI7SUFxTndCLE9BRDFCL1I7R0FFRTtZQXdSRnF3RCxPQTllQWx1RSxHQUFFNHZCLEtBME5TM3ZCO0lBQ1QsWUFBQSxXQURTQSxHQXNUWHdtRixjQWhoQkF6bUYsR0FBRTR2QixLQUZGaWIsVUFDQUM7Z0JBNk5NLE9BOFFONWEsT0ExZUFsd0IsR0FBRTR2QjtRQTZOQ2k3QztJQUFRLE9BOFFYMWpDLElBM2VBbm5DLEdBQUU0dkIsS0E2TkNpN0M7R0FBMkI7WUFtUjlCK2Ysa0JBaGZBNXFGLEdBQUU0dkIsS0FnT29CM3ZCO0lBQ2YsSUFBUDRxRSxPQUFPLFdBRGU1cUUsR0FnVHRCd21GLGNBaGhCQXptRixHQUFFNHZCLEtBRkZpYixVQUNBQztJQTRlQTNELElBM2VBbm5DLEdBQUU0dkIsS0FpT0ZpN0M7SUFDSixPQURJQTtHQUVBO1lBNFFBMEQsT0F6UUt2dUUsR0FBRXlxRixJQUFJeHFGLEdBMFFYMnFGLGtCQTFRSzVxRixHQUFFeXFGLElBQUl4cUYsSUFBWSxTQUE4QjtZQUV2RDRxRixRQUFTQyxnQkFBZTlxRixHQUFFNHZCLEtBQUltN0Q7SUFDaEMsT0FEV0Q7Y0FzUVA1YztlQXRRc0JsdUU7ZUFBRTR2Qjt3QkFHTC9wQjtnQkFDbkI7aUJBQVcsTUFBQSw0QkFEUUE7aUJBR2pCMk0sSUFGSSw0QkFKc0J1NEU7NkJBTTFCdjRFLFlBQUFBO2VBQVc7Y0FpUWIrN0Q7ZUF2UXNCdnVFO2VBQUU0dkI7O2dCQVFWLFlBQWhCLE9BUjhCbTdEO29CQVVyQjl4RjtnQkFBSyxPQUFBLDRCQVZnQjh4RixJQVVyQjl4RjtlQUFZO0dBQUE7WUFtVG5Cb0UsS0FoVEt3SSxVQUFrQzdGLEdBQUU0dkI7SUFBTSxHQUExQy9wQixTQUFLQyxNQUFMRCxRQUFBa2xGLEtBQUtqbEYsY0FBTGlsRjtJQUEwQztTQUFmNXJFLGdCQUFqQjJyRSxpQkFBaUIzckU7O1NBQWpCMnJFO0lBQWdDLE9BYmpERCxRQWFpQkMsZ0JBQXdCOXFGLEdBQUU0dkIsS0FBcENtN0Q7R0FBMEU7WUFpVC9FM3RGLEtBaFRLeUksVUFBa0M3RixHQUFFNHZCO0lBQU0sR0FBMUMvcEIsU0FBS0MsTUFBTEQsUUFBQWtsRixLQUFLamxGLGNBQUxpbEY7SUFBMEM7U0FBZjVyRSxnQkFBakIyckUsaUJBQWlCM3JFOztTQUFqQjJyRTtJQUE4RCxPQWQvRUQsUUFjaUJDLGdCQUF3QjlxRixHQUFFNHZCLEtBQW9DLDZCQUF4RW03RDtHQUE2RTtZQTJQbEY5ZCxVQXpQUWp0RSxHQUFHNHZCLEtBQUtpN0M7SUFDcEIsT0FzUEkwRDthQXZQUXZ1RTthQUFHNHZCOztjQUNDLFlBQ0osV0FGUWk3QztrQkFHWDduRTtjQUFLLFdBSE02bkUsTUFHWDduRTthQUFlO0dBQUE7WUF1UHBCeXJFLGFBbGZBenVFLEdBQUU0dkI7SUFBTixZQWdoQkk2MkQsY0FoaEJBem1GLEdBQUU0dkIsS0FGRmliLFVBQ0FDO2dCQWlRTTs7MEJBRUducEIsYUFBTyxPQXlPaEJ3bEIsSUEzZUFubkMsR0FBRTR2QixLQWtRT2pPO0lBRGEsT0F5T3RCdU8sT0ExZUFsd0IsR0FBRTR2QjtHQWtRaUM7WUFpUG5DdTlDLFdBbmZBbnRFLEdBQUU0dkI7SUFBTixZQWdoQkk2MkQsY0FoaEJBem1GLEdBQUU0dkIsS0FGRmliLFVBQ0FDO2dCQXdRTTtRQUNIOW5DO0lBQUssT0FBTEE7R0FBTTtZQUdYZ29GO0lBQWUvQixnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVNDLFVBQVNoNUQ7SUFDbkUsR0FEaUM2NUI7U0FHeEJydUQsSUFId0JxdUQsU0FDN0JtOUIsU0FFS3hyRjs7U0FGTHdyRixTQUdRLHlCQUp1RGgzRDtJQU16RDtLQUFOaHZCLE1BeGJGaEUsT0FrYmUrcEYsb0JBQ2JDLFNBRG1DeHVEO0tBT25DeXdEO0lBQ0o7O01BUm1FajVEO2VBUTVDenFCO09BQ3JCLElBQUltb0IsTUFBTSxXQVRxQ3E3RCxTQVExQnhqRixJQUVqQm9qRSxPQUFPLFdBVjZDcWdCLFVBUW5DempGO09BR2xCLE9BOE5ENFMsSUFuT0FuWCxLQUdFMHNCO2tCQUZGdTdELGVBRUV2N0QsS0FGRnU3RDtpQkF5TkFoa0QsSUExTkFqa0MsS0FHRTBzQixLQUNBaTdDO01BQzhEO1FBR2xFNkYsT0FQRXlhO1dBT0Z6YTs2QkFBd0IsMkJBQXhCQSxNQWRxQ2gyQzt5QkFNbkN4M0I7R0FRbUY7WUFpQnJGbXVFLFNBQVU0WCxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFTN047SUFDckM7O09BaENKbStEO1NBK0JVL0I7U0FBZ0JsOUI7U0FBTXJ4Qjs7O1NBQVM3Tjs7U0FHekIyQztLQUFLLHdCQUFlLDBCQUFwQkE7O1FBRFp4dkI7SUFBSyxrQkFBTEE7R0FDK0M7WUFHbkRvckYseUJBQTBCbkMsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOO0lBQzNELE9BdENFbStEO2FBcUMwQi9CO2FBQWdCbDlCO2FBQU1yeEI7OzthQUFTN047R0FDaUI7WUFHMUV5a0Qsa0JBQW1CMlgsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOO0lBQzlDLFlBWEp3a0QsU0FVbUI0WCxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFTN047OEJBRTlDdGUsY0FBSyxXQUFMQTtJQUVKLElBRGVxaEIsZ0JBQ1grNkMsY0FKcUNqd0M7SUFLekMsT0FBQTs7Ozs7YUFGZTlLO2FBQ1grNkM7R0FDZ0U7WUFHcEU0RyxhQUFjMFgsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOO0lBQ3pDLFlBVEp5a0Qsa0JBUWMyWCxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFTN047MkJBRW5DdGUsY0FBSyxPQUFMQTtRQUNHMUo7SUFBSyxPQUFBLDJCQUFMQTtHQUFrQjtZQUcvQjRzRSxlQUFnQndYLGdCQUFnQkMsUUFBTXh1RCxVQUFTeEk7SUFDakQsSUF2Q2dFZzVELDZCQUFURDtPQXNDckIvQjtTQW5DekJ4ckYsSUFtQ3lCd3JGLFdBckM5Qm45QixPQUVLcnVEOztTQUZMcXVELE9BR1EseUJBa0NxQzc1QjtJQWhDdkMsSUFBTmh2QixNQXpjRmhFLE9BeWVnQitwRixvQkFyQ2RsOUIsT0FxQ29DcnhCO0lBL0J4Qzs7TUErQmlEeEk7ZUEvQjFCenFCO09BQ3JCLElBQUltb0IsTUFBTSxXQVIyQ3E3RCxTQU9oQ3hqRixJQUVqQm9qRSxPQUFPLFdBVG1EcWdCLFVBT3pDempGO09BR3JCLE9BMk1Fd2xFLFVBL01BL3BFLEtBRUUwc0IsS0FDQWk3QztNQUNvQjtJQUgxQixPQURJM25FO0dBaUM4RTtZQW9OOUU4dUUsU0FqTk9oeUU7SUFBSSxPQXdMWEQ7YUF4TE9DOztzQkFBa0I0dkIsS0FBS2k3QyxNQUFLdm1FLE1BQVEsZUFBbEJzckIsS0FBS2k3QyxPQUFLdm1FLE1BQTJCO0dBQVk7WUFFNUV3RixVQUFVNmdFLGFBQVkwZ0IsY0FBYXJyRjtJQUNyQztLQUFBLE1BOE1JZ3lFLFNBL01pQ2h5RTtLQUdmO09BQUE7Ozs7VUFBQSxJQUFjc3ZFLGFBQVJuRjtVQUFrQixPQUFBLFdBSFRucUUsU0FHVG1xRSxJQUFRbUY7U0FBbUM7S0FDdkQsTUFBQSw2QkFKSjNFLGFBQVkwZ0I7SUFDeEIsT0FBQSxXQUdHO0dBQW9EO1lBR3JEMzZFLFVBQVdncUIsVUFBU2dnRCxXQUFVNFEsV0FBVXRnRjtJQUMxQztLQUF5QixNQUFBLDZCQURIMHZFLFdBQVU0UTtLQUM1QjU3RCxRQUFRLGtDQUQ4QjFrQjtLQUVwQztPQXZDSnFtRSxnQkF1Q21DLHlCQURqQzNoRCxTQURTZ0wsVUFDVGhMOzhCQUVFbmhCLGNBQUssT0FBTEE7SUFJMkI7S0FIaEJpaEI7S0FHZ0I7T0FBQTs7dUI7dUI7S0FBM0Iwa0QsY0FBYyxrQ0FQc0JscEU7S0FRcENtcEU7SUFDSjs7TUFSRXprRDtNQU1Fd2tEOztPQUVnQztRQUFjRTtRQUFSOUU7b0JBQ3JDLFdBVk01MEMsYUFJSWxMLEdBSzJCOC9DOztXQUR0QzZFO1NBS0ssT0FBQTtvRUFKeUNDO1FBRDlDRDs7Ozs7O01BTTJCO0lBQy9CLE1BQUE7R0FBWTtZQUdadnFFLGVBRUcyaEYsV0FDQWpPO0lBR3dCLFVBQUEsOEJBSnhCaU8sV0FDQWpPO0lBR3dCLE9BQUE7R0FBK0M7WUFtTHhFNU0sS0FoTEcxd0U7SUFBSSxPQW9KUEQsS0FwSkdDLGVBQTZCNHZCLFlBQVlwWCxLQUFPLFdBQW5Cb1gsS0FBWXBYLEtBQWlCO0dBQUM7WUFpTDlEcXlELEtBaExHN3FFO0lBQUksT0FtSlBELEtBbkpHQyxzQkFBeUI2cUUsTUFBS3ZtRSxNQUFRLFdBQWJ1bUUsTUFBS3ZtRSxNQUFvQjtHQUFZO1lBY25Fb21CO0lBQU91K0QsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFTQyxVQUFVdnpFLFNBQVF1YTtJQUMxRCxJQTFYTjFILFNBdktGdHJCLE9BZ2lCTytwRixnQkFBZ0JsOUIsTUFBTXJ4QjtJQVhiOztNQVdrRHhJO2VBWDdDczVEO09BQ3JCO1FBL1dJNTdELE1BK1dNLFdBVTZCcTdELFNBWGxCTztRQUVqQjNnQixPQUFPLFdBU3FDcWdCLFVBWDNCTTtRQTlXdkIsUUFnaEJJL0UsY0FoaEJBajhELFFBQUVvRixLQUZGaWIsVUFDQUM7O1lBcVhPMmdELGdCQUhMdmUsU0FHWSxXQUswQ3YxRCxTQUxqRDh6RSxLQUpMNWdCOztZQUNBcUMsU0FEQXJDO09BTUosT0FxSEUxakMsSUEzZUEzYyxRQUFFb0YsS0FpWEFzOUM7TUFLaUI7SUFLdkIsT0EzWEkxaUQ7R0E0WEQ7WUFHRGtoRSxnQkFBaUJ6QyxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVEvNEQ7SUFDM0QsT0FySEU4NEQ7YUFvSGlCL0I7YUFBZ0JsOUI7YUFBTXJ4QjthQUFVdXdEOzJCO2FBQVEvNEQ7R0FDZ0I7WUFHekV5NUQ7SUFBMEIxQyxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVEvNEQ7SUFDOUQ7YUFMSnc1RCxnQkFJMEJ6QyxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVEvNEQ7O0tBSWxFO01BRGdCdytDO01BQ1ovRixjQUo0Q2p3QztNQVEzQzswQkFBVSw2QkFKWGl3QyxhQURZK0Y7TUFHZCxNQUFBO0tBQUEsT0FBQTs7UUFKRTF3RTtJQUFLLFdBQUxBO0dBTTJDO1lBRy9DNHJGLG9CQUFxQjNDLGdCQUFnQmw5QixNQUFNcnhCLFVBQVV1d0QsU0FBUS80RDtJQUMvQzs7T0FaZHk1RCx5QkFXcUIxQyxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVEvNEQ7SUFDL0MsT0FBQTtHQUF3RTtZQUlwRjI1RCxVQUFVN3JGLEdBQUc0dkIsS0FBSzN2QixHQUFFNnJDO0lBQ2hCLFlBQUEsV0FEYzdyQyxHQUFMMnZCLEtBQU9rYztnQkFFWjtRQUNIdjlCO0lBQUssT0FxRlY0NEIsSUF4RlVubkMsR0FBRzR2QixLQUdScmhCO0dBQXVCO1lBa0k1QndjLE1BeGhCQStnRSxRQUFBQyxTQXdaZ0I5ckY7SUFDbEIsT0FBTyw2QkF6Wkw2ckYsV0FBQUM7S0EwWkc7SUFFSCxJQURFMUIsUUFsa0JKbnJGLFdBdUtFNHNGLGdCQUFBQSxZQUFBQTtJQWxNRi9DO01Ba01FK0M7O09BbWFBLE9Bcm1CRi9DO2dCQWtNRWdEOztpQkF1ZkEzckY7bUJBdmZBMHJGOzRCQUFFbDhELEtBb2FnQzBYO29CQXBhdEM7NkJBZ2hCSW0vQyxjQWhoQkFzRixTQUFFbjhELEtBRkZpYixVQUNBQzs7cUJBdWFzQyxPQW5CdEMrZ0QsVUFRRXhCLE9BM1pBejZELEtBd1pjM3ZCLGtCQVlrQnFuQzt3QkFHdkJDO29CQUFpQyxPQXBCNUNza0Q7NkJBUUV4QixPQTNaQXo2RCxLQXdaYzN2QixzQkFZa0JxbkMsTUFHdkJDO21CQUFzRDtpQkFDOUMsT0ErRW5Cbm5DOzBCQXZmQTJyRjttQ0FBRW44RCxLQXdhaUMyWDsyQkFDL0IsT0F1R0prL0MsY0FoaEJBcUYsUUFBRWw4RCxLQUZGaWIsVUFDQUM7O3FDQW9aQStnRCxVQVFFeEIsT0EzWkF6NkQsS0F3WmMzdkIsa0JBZ0JtQnNuQzswQkFHakI7Z0JBQ1c7TUFBQztJQVZoQyxPQVBJOGlEO0dBa0JDO1lBNEdIMkIsV0F6R1Vwd0QsS0FoYlZFLEtBZ2JvQjc3QjtJQUN4QixPQXNFSUc7YUF2RVV3N0I7c0JBaGJSaE0sS0FpYmtCaTdDO2NBQ3RCO2VBQUlvaEIsYUE4RkZ4RixjQWhoQkEzcUQsS0FBRWxNLEtBRkZpYixVQUNBQztlQW9iRW9oRDtpQkFybkJKbkQ7bUJBa01FanREOztvQkFtYjJDLE9BQTdDLFdBSHNCNzdCLEdBaGJsQjJ2QixLQWlia0JpN0MsTUFDbEJvaEI7bUJBQzZEO2NBQ2pFLEtBRElDLFFBRVEsT0FxRFZoOEQsT0ExZUE0TCxLQUFFbE07a0JBc2JLczlDLFNBSExnZjtjQUlGLEtBTEVELFlBTVMsT0FtRFg5a0QsSUEzZUFyTCxLQUFFbE0sS0FzYktzOUM7Y0FHb0I7ZUFBbkJpZixXQVBORjtlQU95QixVQUFBLDZCQUFuQkUsVUFIRGpmOzJCQXFEUC9sQyxJQTNlQXJMLEtBQUVsTSxLQXNiS3M5QzthQUd1RTtHQUFDO1lBcUcvRXJFLGdCQWxHYzdvRSxHQUFHQztJQUVuQjtLQURFbXNGO09BaUVBcnNGO1NBbEVjQzs7a0JBRVM0dkIsS0FBS2k3QyxNQUFLdGlEO1VBQU0sT0FBRyxXQUZ6QnRvQixHQUVNMnZCLEtBQUtpN0MsUUFBS3RpRCxTQUFWcUgsS0FBVXJIO1NBQTRDO0lBRTFELE9BQUE7MkJBSG5CNmpFLG9CQUd3Qng4RCxLQUFPLE9BMEMvQk0sT0E5Q2Nsd0IsR0FJVTR2QixLQUFtQjtHQUFDO1lBNkY1Q2c1QyxlQTFGYTVvRSxHQUFHQztJQUFJLE9BMkZwQjRvRTthQTNGYTdvRSxtQkFBeUM2cUUsTUFBUSxPQUFBLFdBQTlDNXFFLEdBQXNDNHFFLE1BQWM7R0FBQztZQXlGckV3aEIsb0JBeEZrQnJzRixHQUFHQztJQUFJLE9BMEZ6QjRvRTthQTFGa0I3b0UsWUFBa0M0dkIsWUFBZSxPQUFBLFdBQTlDM3ZCLEdBQStCMnZCLEtBQW9CO0dBQUM7WUE4RnpFMDhELG9CQTVGa0J0c0YsR0FBR0M7SUFDUDtLQUFkc3NGO09BdURBeHNGO1NBeERrQkM7O2tCQUNxQjR2QixLQUFLaTdDLE1BQUt0aUQ7VUFBTSxlQUFoQnFILEtBQXNCLFdBRHhDM3ZCLEdBQ2tCMnZCLEtBQUtpN0MsUUFBS3RpRDtTQUErQjtJQUMzRCxPQUFBOzthQURyQmdrRTs7Y0FDcUIsSUFBVzF1RSxtQkFBTCtSO2NBQzdCLEtBRGtDL1IsUUFFeEIsT0FnQ1JxUyxPQXBDa0Jsd0IsR0FFUzR2QjtrQkFHdEJpN0MsT0FIMkJodEQ7Y0FHbkIsT0FnQ2JzcEIsSUFyQ2tCbm5DLEdBRVM0dkIsS0FHdEJpN0M7YUFBeUI7R0FBQTtZQXNGOUIyaEIsbUJBbkZpQnhzRixHQUFHQztJQUFJLE9Bb0Z4QnFzRjthQXBGaUJ0c0YsbUJBQTZDNnFFLE1BQVEsT0FBQSxXQUFsRDVxRSxHQUEwQzRxRSxNQUFjO0dBQUM7WUFrRjdFZ2UsYUFoRlc3b0YsR0FBR0M7SUF0cEJoQjZvRix3QkFzcEJhOW9GO0lBRUksT0FwcEJqQitvRjthQWtwQmEvb0Y7O2NBRWU7Y0FBc0IsT0FBQTs7dUJBRnJDQTtxQ0FDZixPQUFBLHFCQURrQkM7YUFFMkQ7R0FBQztZQTZFMUUwcUMsWUExRVUzcUMsR0FBR0M7SUFBSSxPQTJFakI0b0YsYUEzRVU3b0YsbUJBQXNDNnFFLE1BQVEsT0FBQSxXQUEzQzVxRSxHQUFtQzRxRSxNQUFjO0dBQUM7WUErRS9ENGhCLFFBN0VJbjJGLE9BaGNDNFAsS0FBQWxHO0lBaWNULFVBamNTa0csV0FBQWxHOztjQWtjTTtlQXByQmJpTjt3QkFvckJrQnhGO2dCQTNwQmxCc2hGO2tCQXlOTy9vRjs7bUJBb2NMLE9BNEJBSTs0QkFoZUs4RjtxQ0F2QkgwcEIsS0EyZG9CaTdDOzZCQTNkMUIsWUFnaEJJNGIsY0F6Zkt6bUYsR0F2Qkg0dkIsS0FGRmliLFVBQ0FDO3lDQThkWSxPQUFBLFdBSklyakM7NkJBS1M7OEJBQWhCeWxFOzhCQUFnQixVQUFBLFdBUHJCNTJFLE9BSWtCdTBFLE1BR2JxQzswQ0FBd0MsV0FMakN6bEU7NEJBSytDO2tCQUFDO2dCQUpsRTtlQUtJOztHQUFDOztRQTJGSGl6QjthQUlBd2tCLFNBQVErcEMsZ0JBQWdCbDlCO0tBQVUsT0FydUJwQzdzRCxPQXF1QlUrcEYsZ0JBQWdCbDlCLE1BSnhCcnhCO0lBSTJFO2FBQzNFNjhDLFdBQVUwUixnQkFBZ0JsOUIsTUFBSy9vRDtLQUFJLE9BclJyQ3F1RSxTQXFSWTRYLGdCQUFnQmw5QixNQUwxQnJ4QixVQUsrQjEzQjtJQUE4QzthQUU3RTBwRiwyQkFBMEJ6RCxnQkFBZ0JsOUIsTUFBSy9vRDtLQUNqRCxPQWxSQW9vRix5QkFpUjRCbkMsZ0JBQWdCbDlCLE1BUDFDcnhCLFVBTytDMTNCO0lBQ1M7YUFHeER3MEUsb0JBQW1CeVIsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FDMUMsT0FsUkFzdUUsa0JBaVJxQjJYLGdCQUFnQmw5QixNQVhuQ3J4QixVQVd3QzEzQjtJQUNTO2FBR2pEeTBFLGVBQWN3UixnQkFBZ0JsOUIsTUFBSy9vRDtLQUNyQyxPQTlRQXV1RSxhQTZRZ0IwWCxnQkFBZ0JsOUIsTUFmOUJyeEIsVUFlbUMxM0I7SUFDUzthQUc1Q3NyQixZQUFVb3NELFdBQVU0USxXQUFVdGdGO0tBQU8sT0E5UHZDMEYsVUEyT0VncUIsVUFtQlVnZ0QsV0FBVTRRLFdBQVV0Z0Y7SUFBbUQ7YUFFakYwc0UsaUJBQWdCdVIsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FDdkMsT0E5UUF5dUUsZUE2UWtCd1gsZ0JBQWdCbDlCLE1BckJoQ3J4QixVQXFCcUMxM0I7SUFDUzthQUc5QzJwRixnQkFBZTFELGdCQUFnQmw5QixNQUFNay9CLFNBQVNDLFVBQVNsb0Y7S0FDekQsT0F6VUFnb0Y7Y0F3VWlCL0IsZ0JBQWdCbDlCLE1BekIvQnJ4QixVQXlCcUN1d0QsU0FBU0MsVUFBU2xvRjtJQUNTO2FBR2hFNHBGLGtCQUFpQjNELGdCQUFnQmw5QixNQUFNay9CLFNBQVFqb0Y7S0FDakQsT0F6TkEwb0YsZ0JBd05tQnpDLGdCQUFnQmw5QixNQTdCakNyeEIsVUE2QnVDdXdELFNBQVFqb0Y7SUFDUzthQUd4RDZwRiwyQkFBMEI1RCxnQkFBZ0JsOUIsTUFBTWsvQixTQUFRam9GO0tBQzFELE9Bek5BMm9GO2NBd040QjFDLGdCQUFnQmw5QixNQWpDMUNyeEIsVUFpQ2dEdXdELFNBQVFqb0Y7SUFDUzthQUdqRThwRixzQkFBcUI3RCxnQkFBZ0JsOUIsTUFBTWsvQixTQUFRam9GO0tBQ3JELE9BbE5BNG9GLG9CQWlOdUIzQyxnQkFBZ0JsOUIsTUFyQ3JDcnhCLFVBcUMyQ3V3RCxTQUFRam9GO0lBQ1M7YUFHNUR5c0IsUUFBT3c1RCxnQkFBZ0JsOUIsTUFBTWsvQixTQUFTQyxVQUFVdnpFLFNBQVEzVTtLQUMxRCxPQTNPQTBuQjtjQTBPU3UrRCxnQkFBZ0JsOUIsTUF6Q3ZCcnhCLFVBeUM2QnV3RCxTQUFTQyxVQUFVdnpFLFNBQVEzVTtJQUNTO0lBM0NqRTtZQW9CQXNyQjtZQWZBNHdCO1lBQ0FxNEI7WUFFQW1WO1lBSUFsVjtZQUlBQztZQU1BQztZQUlBaVY7WUFJQUM7WUFJQUM7WUFJQUM7WUFJQXI5RDs7R0F6RFU7SUFrRVZpTDt1QkFBQUE7SUEzREpwTTtJQUdFNHdCO0lBQUFxNEI7SUFBQW1WO0lBQUFsVjtJQUFBQztJQUFBQztJQUFBaVY7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQXI5RDtZQTZFRWt4RCxXQUFTM2dGLEdBQUksT0FBSkEsS0FBYztHQVBaLGtCQU9YMmdGO1lBR0Z4aEMsU0FBUThwQyxnQkFBZ0JsOUIsTUFBS3Z5QztJQUMvQixPQTV5QkV0YSxPQTJ5QlErcEYsZ0JBQWdCbDlCLE1BQ1QsNkJBRGN2eUM7R0FDOEI7WUFHM0QyaEUsV0FBVThOLGdCQUFnQmw5QixNQUFLdnlDLEdBQUV4VztJQUNuQyxPQS9WRXF1RSxTQThWVTRYLGdCQUFnQmw5QixNQUNULDZCQURjdnlDLElBQUV4VztHQUMyQjtZQUc1RCtwRiwyQkFBMEI5RCxnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDbkQsT0E3VkVvb0Y7YUE0VjBCbkMsZ0JBQWdCbDlCLE1BQ1QsNkJBRGN2eUMsSUFBRXhXO0dBQzJCO1lBRzVFbzRFLG9CQUFtQjZOLGdCQUFnQmw5QixNQUFLdnlDLEdBQUV4VztJQUM1QyxPQTdWRXN1RTthQTRWbUIyWCxnQkFBZ0JsOUIsTUFDVCw2QkFEY3Z5QyxJQUFFeFc7R0FDMkI7WUFHckVxNEUsZUFBYzROLGdCQUFnQmw5QixNQUFLdnlDLEdBQUV4VztJQUN2QyxPQXpWRXV1RTthQXdWYzBYLGdCQUFnQmw5QixNQUNULDZCQURjdnlDLElBQUV4VztHQUMyQjtZQUdoRXM0RSxpQkFBZ0IyTixnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDekMsT0F2VkV5dUU7YUFzVmdCd1gsZ0JBQWdCbDlCLE1BQ1QsNkJBRGN2eUMsSUFBRXhXO0dBQzJCO1lBR2xFZ3FGLGdCQUFlL0QsZ0JBQWdCbDlCLE1BQUt2eUMsR0FBR3l4RSxTQUFTQyxVQUFTbG9GO0lBQzNELE9BbFpFZ29GO2FBaVplL0I7YUFBZ0JsOUI7YUFDVCw2QkFEY3Z5QzthQUFHeXhFO2FBQVNDO2FBQVNsb0Y7R0FDMkI7WUFHcEZpcUYsa0JBQWlCaEUsZ0JBQWdCbDlCLE1BQUt2eUMsR0FBR3l4RSxTQUFRam9GO0lBQ25ELE9BbFNFMG9GO2FBaVNpQnpDO2FBQWdCbDlCO2FBQ1QsNkJBRGN2eUM7YUFBR3l4RTthQUFRam9GO0dBQzJCO1lBRzVFa3FGLDJCQUEwQmpFLGdCQUFnQmw5QixNQUFLdnlDLEdBQUd5eEUsU0FBUWpvRjtJQUM1RCxPQWxTRTJvRjthQWlTMEIxQzthQUFnQmw5QjthQUNULDZCQURjdnlDO2FBQUd5eEU7YUFBUWpvRjtHQUMyQjtZQUdyRm1xRixzQkFBcUJsRSxnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFHeXhFLFNBQVFqb0Y7SUFDdkQsT0EzUkU0b0Y7YUEwUnFCM0M7YUFBZ0JsOUI7YUFDVCw2QkFEY3Z5QzthQUFHeXhFO2FBQVFqb0Y7R0FDMkI7WUFHaEZvcUYsUUFBT25FLGdCQUFnQmw5QixNQUFLdnlDLEdBQUd5eEUsU0FBU0MsVUFBVXZ6RSxTQUFRM1U7SUFDNUQsT0FwVEUwbkI7YUFtVE91K0Q7YUFBZ0JsOUI7YUFDVCw2QkFEY3Z5QzthQUFHeXhFO2FBQVNDO2FBQVV2ekU7YUFBUTNVO0dBQzJCO1lBR3JGcXFGLFdBQVdydEYsR0FBSSxvQ0FBSkEsTUFBOEI7aUJBRXhCLFdBRWxCO1lBOEJDeWtFLFlBQThCNFk7SSxnQkFBK0JsRyxXQUFVbjNFLEdBQ3pFLE9BM1lFOEosVUEwWThCdXpFLE1BQStCbEcsV0FBVW4zRSxHQUN4Qzs7WUFHL0Iya0UsWUFBOEIwWTtJLGdCQUErQjFDLFdBQVUzdkU7S0FDekUsVUFEZ0NxeUU7S0FDaEMsT0F4WUUzc0U7Y0F3WWtCLGlDQURZMnNFLE1BQUFBLE1BQUFBOztjQUErQjFDO2NBQVUzdkUsTUFDRTs7WUFHekU0NUQsaUJBQW1DeVk7SSxnQkFBb0NDLFdBQ3pFLE9BMVhFMXpFLGVBeVhtQ3l6RSxNQUFvQ0MsV0FDaEM7O1lBR3ZDeFksaUJBQWdDMFksU0FBUXA4RSxJQUFHQyxJQUFLLE9BMUw5Q29yRixRQTBMOEJqUCxTQUFRcDhFLElBQUdDO0dBQXdCOzs7O09BdjdCbkVnSTtPQURBNHdCO09Ba2lCQW53QjtPQTRUQXExQztPQUlBZzhCO09BSUE0UjtPQUlBM1I7T0FJQUM7T0FJQUM7T0FJQTBSO09BSUFDO09BSUFDO09BSUFDO09BSUFDO09BcklFemlCO09BL0RBemY7T0FDQTFyRDtPQXFCQU87T0FUQTR1RTtPQUNBeHVFO09BQ0FDO09BRUFva0I7T0FEQXRpQjtPQUdBcWlCO09BREFoaUI7T0FHQWdyQjtPQURBblY7T0FHQXRXO09BQ0FpUztPQVpBc0c7T0FWQTZWO09BSkE4ckM7T0FDQUM7T0FJQTkwQjtPQUNBaFg7T0FDQTY2QztPQUNBa0Q7T0FDQUs7T0FDQXFjO09BaUJBdnFGO09BQ0FDO09BQ0FvdEI7T0FDQUc7T0FDQW9oRDtPQUNBcnJEO09BQ0ErRjtPQUNBM1Y7T0FDQWs3RDtPQUNBL2dEO09BQ0FpZDtPQUNBby9DO09BQ0FFO09BQ0ExeEU7T0FDQWdMO09BQ0F5aUU7T0FDQU07T0FDQU07T0FDQVQ7T0FDQU07T0FDQU07T0FDQW1EO09BRUE1L0Q7T0FDQWloRTtPQUNBdGI7T0FDQTdGO09BQ0F3aEI7T0FDQXpqQjtPQUNBQztPQUNBbCtCO09BQ0FrK0M7T0FDQTJEO09BQ0FGO09BRUFHO09BQUFBO09BYkF6YTtPQWNBMzBFO09BQ0FEO09BckRBNnZFO09BQ0F3QjtPQUNBdEI7T0E2TEZrZ0I7T0EzTUV4akY7OztRQTRFSnlrQjtRQXpPRXhrQjtRQXlCQUY7UUEyUUU4d0I7UUF2SUE3d0I7UUErRUZxMUM7UUFBQXE0QjtRQUFBbVY7UUFBQWxWO1FBQUFDO1FBQUFDO1FBQUFpVjtRQUFBQztRQUFBQztRQUFBQztRQUFBcjlEO1FBYkVrN0M7UUEvREF6ZjtRQUNBMXJEO1FBcUJBTztRQVRBNHVFO1FBQ0F4dUU7UUFDQUM7UUFFQW9rQjtRQURBdGlCO1FBR0FxaUI7UUFEQWhpQjtRQUdBZ3JCO1FBREFuVjtRQUdBdFc7UUFDQWlTO1FBWkFzRztRQVZBNlY7UUFKQThyQztRQUNBQztRQUlBOTBCO1FBQ0FoWDtRQUNBNjZDO1FBQ0FrRDtRQUNBSztRQUNBcWM7UUFpQkF2cUY7UUFDQUM7UUFDQW90QjtRQUNBRztRQUNBb2hEO1FBQ0FyckQ7UUFDQStGO1FBQ0EzVjtRQUNBazdEO1FBQ0EvZ0Q7UUFDQWlkO1FBQ0FvL0M7UUFDQUU7UUFDQTF4RTtRQUNBZ0w7UUFDQXlpRTtRQUNBTTtRQUNBTTtRQUNBVDtRQUNBTTtRQUNBTTtRQUNBbUQ7UUFFQTUvRDtRQUNBaWhFO1FBQ0F0YjtRQUNBN0Y7UUFDQXdoQjtRQUNBempCO1FBQ0FDO1FBQ0FsK0I7UUFDQWsrQztRQUNBMkQ7UUFDQUY7UUFFQUc7UUFBQUE7UUFiQXphO1FBY0EzMEU7UUFDQUQ7UUFyREE2dkU7UUFDQXdCO1FBQ0F0Qjs7T0ErTkYxSTtPQUlBRTtPQUlBQztPQUlBRTs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7SUMzN0JBdW9CO0lBVUUzeUQ7SUFSRjR5RDtJQUNBcmdGO0lBUUVpK0M7SUFDQXBwRDtJQUNBdVk7OztZQUNBdEcsU0FBUy9ULEdBQUksT0FBQSw2QkFBSkEsR0FBc0I7WUFFL0IrWSxTQUFTL1ksR0FBR0M7SUFDZCxPQUFZO2FBZFpnTjtzQkFjaUJ4RjtjQUNmOztnQkFGU3pIO3lCQUVtQjZZO2lCQUNwQixJQUVKMmpCLElBRkksV0FISXY4QixHQUVnQjRZO3dCQUd4QjJqQixJQUFlLFdBSkovMEIsR0FJWCswQjtnQkFBeUI7Y0FIN0I7YUFJSTtHQUFDO1lBR0x4akIsS0FBS2haLEdBQUdDO0lBQUksT0FUWjhZLFNBU0svWSxZQUEwQm9ELEdBQUssT0FBRyxXQUEvQm5ELEdBQXVCbUQsU0FBQUEsT0FBaUM7R0FBQztZQUNqRStzQixJQUFJbndCLEdBQUV3dkIsR0FBSSxPQUFBLDZCQUFOeHZCLEdBQUV3dkIsTUFBaUM7WUFFdkMrOUQsV0FBV3Z0RixHQUFFd3ZCO0lBQ2YsT0FBRyxXQWhCRG5WLEtBZVdyYSxHQUFFd3ZCO2NBRVY7ZUFFSCw2QkFKV3h2QixHQUFFd3ZCO0dBS0E7WUFHYmcrRCxlQUFleHRGLEdBQUV3dkI7SUFBb0IsVUFSckMrOUQsV0FRZXZ0RixHQUFFd3ZCO0lBQW9CLE9BQUE7R0FBZ0I7O0lBQ3JEVTs7O1lBRUF1OUQsY0FBY3p0RixHQUFFd3ZCO0lBQ2xCLEdBQUcsV0EzQkRuVixLQTBCY3JhLEdBQUV3dkIsSUFHaEIsV0FMQVUsUUFFY2x3QixHQUFFd3ZCLElBR2hCO0lBRXlDLFVBQUEsNkJBTDNCeHZCO0lBSzJCLE9BQUEsNERBTHpCd3ZCO0dBS2dEO1lBR2hFaytELGtCQUFrQjF0RixHQUFFd3ZCO0lBQW9CLFVBUnhDaStELGNBUWtCenRGLEdBQUV3dkI7SUFBb0IsT0FBQTtHQUFtQjtZQUMzRHp2QixLQUFLQyxHQUFHTixNQUFNTztJQUFJLE9BQXdCOzthQUFyQ0Q7YUFBR047c0JBQXdDa3dCLFlBQWFwWCxLQUFPLE9BQUEsV0FBdER2WSxHQUErQ3VZLEtBQWJvWCxLQUE2QjtHQUFDO1lBQzlFenZCLEtBQUtILEdBQUdDLEdBQUksT0FBQSw2QkFBUEQsR0FBR0MsR0FBMEI7WUFDbENtWSxNQUFNcFksR0FBR0MsR0FBSSxPQUFBLDhCQUZiRixNQUVNQyxHQUFHQyxHQUE4QjtZQUN2Q29ZLElBQUltQixHQUFFeFosR0FBR0MsR0FBSSxPQUFBLDhCQUhiRixNQUdJeVosR0FBRXhaLEdBQUdDLEdBQThCO1lBQ3ZDMlksUUFBUTVZLEdBQUczSjtJQUFVLE9BQUEsOEJBSnJCMEosTUFJUUMsR0FBRzNKO0dBQTRDO1lBQ3ZEeWlCLFFBQVE5WSxHQUFHM0o7SUFBVSxPQUFBLDhCQUxyQjBKLE1BS1FDLEdBQUczSjtHQUE0QztZQUN2RGtpQixZQUFZdlksR0FBR04sTUFBTU87SUFBSSxPQUFBLDhCQU56QkYsTUFNZUwsTUFBTU8sR0FBVEQ7R0FBbUQ7WUFDL0QwWSxXQUFXMVksR0FBR04sTUFBTU87SUFBSSx3Q0FQeEJGLE1BT2NMLE1BQU1PO0lBQUkscUIsNEJBQWJEO0dBQWtEOztJQUM3REY7Ozs7O1lBMkdBZ0ssVUF6R1U2akYsV0FBVTN0RjtJQUN0QjtLQUF3QixNQUFBLFdBSHRCRixTQUVvQkU7S0FDRTtLQUFnQyxNQUFBLHNCQUFBLFdBakR0RDA2QixVQWdEb0IxNkI7SUFDQyxPQUFBLDZCQURYMnRGO0dBQ2lFO1lBRzNFMTBFLFNBQVNqWjtJQUNYO0tBQUliLE1BQU0sV0FuRFIyQyxRQWtEUzlCO0tBRVBxd0MsWUFBWSw0QkFEWmx4QztJQUVpQixPQWpCbkJZO2FBY1NDOztzQkFHZXdZLEtBQUlvWDtjQUM1QixTQUR3QnBYO2VBRW5CLE9BQUEsMkJBSkhyWixLQUUwQnl3QjtjQUQxQnlnQixXQUtTLDRCQUxUQTt3QkFBQUE7Y0FNQSx5QkFMc0I3M0IscUJBQUlvWDtjQUsxQixPQUxzQnBYO2FBTWxCO0dBQUM7WUFHUHRXLE9BQU9sQyxHQUFHQztJQUFJLE9BQXFCOzthQUE1QkQ7c0JBQWtDNHZCLFlBQWdCLE9BQUEsV0FBL0MzdkIsR0FBK0IydkIsS0FBcUI7R0FBQztZQUMvRHJ0QixRQUFRdkMsR0FBR0M7SUFBSTs7WUFBSTs7Y0FBWEQ7dUJBQXVDNHZCLFlBQWdCLFdBQUksV0FBeEQzdkIsR0FBb0MydkIsS0FBMkI7R0FBRTtZQUM1RXQ1QixNQUFNOEssSUFBR0M7SUFBSyxPQUFBO29EQUE0QixTQUFJLEdBQXhDRCxJQUFHQztHQUE0QztZQUNyRDdCLEtBQUtRLEdBQUksT0FBQSw2QkFBSkEsR0FBa0I7WUFDdkI0akIsT0FBTzVqQixHQUFHQztJQUFJLE9BQXFCOzthQUE1QkQ7c0JBQWtDNHZCLFlBQWdCLE9BQUEsV0FBL0MzdkIsR0FBK0IydkIsS0FBcUI7R0FBQztZQUMvRGtwQyxNQUFNMTNELElBQUdDO0lBQUssT0FBdUI7K0JBQS9CRCxJQUFHQyx5QkFBNkMsV0FBTztHQUFDO1lBQzlEZ2MsS0FBS2pjLElBQUdDO0lBQUssT0FGYnVpQjthQUVLeGlCO3NCQUEwQnd1QixLQUFPLFdBQUksNkJBQWxDdnVCLElBQXVCdXVCLEtBQStCO0dBQUM7WUFFL0R5cEMsTUFBTWo0RCxJQUFHQztJQUMwQixVQUFBLFdBdkVuQ1MsUUFzRVNUO2FBQ2MsV0F2RXZCUyxRQXNFTVY7U0FDS3dzRixTQURMeHNGLElBQ0p5c0YsVUFET3hzRjs7U0FDRXVzRixTQURGdnNGLElBQ1B3c0YsVUFESXpzRjtJQUVtQixPQUFBOzthQUR2QnlzRjtzQkFDNkJqK0Q7Y0FBZ0IsT0FBQSw2QkFEcENnK0QsUUFDb0JoK0Q7YUFBc0M7R0FBQztZQUd0RWc1QyxlQUFlNW9FLEdBQUdDO0lBQ0o7S0FBWm1zRjtPQXhDRnJzRixLQXVDZUMsZUFDdUJ1b0IsSUFBR2o1QixHQUFLLE9BQUcsV0FEL0IyUSxHQUN1QjNRLEtBQUhpNUIsU0FBR2o1QixHQUFIaTVCLElBQW1DO0lBQ3BELE9BQUE7O2FBRG5CNmpFO3NCQUN3Qjk4RixHQUFLLE9BQUEsV0FwRC9CNGdDLFFBa0RlbHdCLEdBRVcxUSxHQUFlO0dBQUM7WUFHMUN3K0YsZ0JBQWdCQztJQUFVLE9BQXVCLDZCQUFqQ0EsdUI7R0FBdUM7WUFDdkRDLFdBQVdodUYsR0FBR0M7SUFBSSxPQUFrQjs7YUFBekJEO3NCQUErQjR2QixZQUFnQixPQUFBLFdBQTVDM3ZCLEdBQTRCMnZCLEtBQXFCO0dBQUM7WUFLbEUxd0IsT0FBUStwRixnQkFBZ0JsOUIsTUFBS3Z5QztJQUFJLE9BQUEsNEJBQXpCeXZFLGdCQUFnQmw5QixNQUFLdnlDO0dBQTBDO1lBRXZFNVosUUFBU3FwRixnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDbEMsR0FEMkIrb0Q7U0FHbEJ6OEQsSUFIa0J5OEQsU0FDdkJtOUIsU0FFSzU1Rjs7U0FGTDQ1RixTQUdRLHlCQUpzQmxtRjtJQU0xQixJQUFKaEQsSUFBSSw0QkFOR2lwRixvQkFDUEMsU0FENEIxdkU7SUFPaEMseUJBUGtDeFcsWUFPZHdzQixHQUFLLE9BakZyQlcsSUFnRkFud0IsR0FDZ0J3dkIsR0FBWTtJQUFoQyxPQURJeHZCO0dBRUg7WUFHQzBRLFVBQVU4SSxHQUFFeTBFLFdBQVVqakY7SUFDeEIsU0FEd0JBO0tBRVAsT0FBQSw2REFGT0E7SUFJZCxJQURFMUcsT0FIWTBHLFNBSWxCaEwsSUFqQkpkLGNBaUJ1Qix5QkFEYm9GLFFBSEFrVjtJQUtWOztNQUZVbFY7ZUFFYTBHO09BQ2IsSUFBSm5HLElBQUksV0FORW9wRixXQUtXampGO29CQXhGckJ1aUYsV0F1RkV2dEYsR0FFRTZFOztpQkFHUztvRUFKUW1HO01BSXVEO0lBSjlFLE9BREloTDtHQU1IOzthQWlCQ2svQyxTQUFRK3BDLGdCQUFnQmw5QjtLQUMxQixPQXpDQTdzRCxPQXdDVStwRixnQkFBZ0JsOUIsTUFDRztJQUE4QjthQUd6RDhWLFVBQVNvbkIsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FDaEMsT0EzQ0FwRDtjQTBDV3FwRixnQkFBZ0JsOUIsTUFDRyxzQ0FERS9vRDtJQUM4QjthQUc1RHNyQixZQUFVMi9ELFdBQVVqakY7S0FBTyxPQW5DN0IwRixVQW1DdUMsc0NBQTNCdTlFLFdBQVVqakY7SUFBOEQ7SUFUbEYsV0FTQXNqQixhQVJBNHdCLFVBSUEyaUI7Ozt1QkE1SUZ5ckI7SUErSEZoL0Q7SUFHRTR3QjtJQUFBMmlCO1lBZ0NFajRELGVBQWV1akM7SUFBdUMsVUFBQSx5QkFBdkNBO0lBQXVDLE9BQUE7R0FBNkI7bUJBR2xFLFdBRXBCO1lBRUNzM0IsWUFBZ0NDO0ksZ0JBQW1DMWtFLEdBQ3JFLE9BVEk4SixVQVE4QjQ2RCxRQUFtQzFrRSxHQUM1Qzs7WUFHdkIya0UsWUFBZ0NEO0ksZ0JBQW1DMTVEO0tBQ3JFLE9BakVFMEYsY0FnRWdDZzBELFFBQUFBLFFBQUFBLFNBQUFBLFFBQW1DMTVELE1BQzVCOztZQUd2QzQ1RCxpQkFBcUNGO0lBQ1YsVUFBQSw2QkFEVUE7SUFDVixPQUFBOztZQUczQkksaUJBQWdDMWpFLElBQUdDLElBQUssT0EzR3RDL0ssTUEyRzhCOEssSUFBR0MsSUFBZ0I7R0FFdEM7SUFDWHMvRTtJQURXLGNBQ1hBOzs7T0F2QkE3MkU7T0FqRUY1SztPQUVBVTtPQXhGRWtDO09BRUFpUztPQW1DQTVUO09BREFKO09BTUF3WTtPQUNBRztPQW1CQXhXO09BQ0FLO09BekJBNlY7T0FDQUM7T0ExQkFXO09BVEFEO09Bd0NBalo7T0FNQW1aO09BVkFMO09BQ0FFO09BeENBdUI7T0FnRUE3YTtPQW5EQTJ3QjtPQUVBbzlEO09BUUFDO09BQ0F0OUQ7T0FFQXU5RDtPQVFBQztPQXBDQXhpQztPQWlFQTUwRDtPQUVBc3RCO09BU0FnbEQ7T0FMQXZQO09BSEFQO09BQ0F6N0M7T0FZQXl3RTtPQUNBRTtPQTdGRlg7O1FBaUlGLytEO1FBa0NJeGtCO1FBQ0FGO1FBaENGczFDO1FBQUEyaUI7UUF4SEUvL0Q7UUFFQWlTO1FBbUNBNVQ7UUFEQUo7UUFNQXdZO1FBQ0FHO1FBbUJBeFc7UUFDQUs7UUF6QkE2VjtRQUNBQztRQTFCQVc7UUFUQUQ7UUF3Q0FqWjtRQU1BbVo7UUFWQUw7UUFDQUU7UUF4Q0F1QjtRQWdFQTdhO1FBbkRBMndCO1FBRUFvOUQ7UUFRQUM7UUFDQXQ5RDtRQUVBdTlEO1FBUUFDO1FBcENBeGlDO1FBaUVBNTBEO1FBRUFzdEI7UUFTQWdsRDtRQUxBdlA7UUFIQVA7UUFDQXo3QztRQVlBeXdFO1FBQ0FFOzs7T0E4RUZ2cEI7T0FJQUU7T0FJQUM7T0FJQUU7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7SUM4VkU3NkQ7SUFHR2lqRDtJQW9DRjU5Qjs7Ozs7Ozs7Ozs7SUEwWUNqbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTF4QkozSTtJQUNBbk47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBM0tBZ2pDO0lBS0c3eEI7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXO0dBU2E7SUFOMUJvaEI7SUFDQTVHO0lBQ0NGO0lBSUQ4d0IsZUFYQ3J4QixlQU1EUztJQU1BelM7aURBQUFBLFdBTkF5Uzs7O1lBaUJGRCxpQkFBb0IsU0FBRTtZQUN0QnJJLFNBQVNsUyxHQUFJLE9BQUpBLEVBQUs7WUFDZG1TLFNBQVNuUyxHQUFJLE9BQUpBLEVBQUs7WUFFZGlTLFVBQVU3RDtJQUNaLElBQUksV0FBQSw0QkFEUUEsSUFDUjtnQkFDRyxPQUFBLGdDQUZLQTtHQUVpQztZQStIM0M0RCxVQUFVaFM7SUFDWjtLQUNPQyxJQUFJLDJCQUZDRDtLQUdOLE9BQUEsNEJBRENDO0tBeEhhMmtCO09BeUhkLHNDQUhNNWtCO1VBRUxDO1VBQ2lDLDJCQUg1QkQ7S0FySFIwVCxrQ0FEZ0JrUjtLQUVQamI7SUFDWDtRQUZFK0osS0FDUy9KLEdBRU4sT0FBQSw2QkFKYWliO0tBTVYsWUFBQSx3QkFOVUEsS0FFUGpiOzs7O01BQWIsT0FGb0JpYjs7S0FPVyxJQUxsQnBQLE1BS2tCLDRCQUxsQjdMO0tBQUFBLElBQUE2TDs7R0F1SGtEO0dBSzlCO0lBQS9Cb3BGLCtCQUErQjtJQUMvQkMsNEJBQTRCO0lBQzVCL25DO0lBT0FsbEQ7SUFDQUo7WUFDQXN0RixTQUFTbjFGLEdBQUksT0FBQSwwQkFBSkEsR0FBb0I7R0FHYjtJQUZoQjJ0RDtJQUNBRTtJQUNBdW5DLGdCQUFnQjtJQUNoQkMsZ0JBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBZWhCQyxVQUFVdnVGO0lBQ1osS0FBRyxnQ0FEU0E7S0FLSixPQUFBLGdDQUxJQSxHQWhCVnF1RjttQkFzQlEseUJBTkVydUY7O0lBR0QsSUFBTGtHLE1BQUsscUJBSENsRztJQUlQLE9BQUEsZ0NBRENrRyxLQWxCSm9vRjtrQkFtQmlDLHlCQUQ3QnBvRjs7R0FJRztZQUdlc29GLGNBQWN4dUY7SUFDdEMsR0FBRyxnQ0FEbUNBO0tBRzNCLElBQUxrRyxNQUFLLHFCQUgyQmxHO0tBSWpDLEdBQUEsZ0NBRENrRyxLQTVCSm9vRjtNQThCSyxPQUFBLHlCQUZEcG9GO0tBR2dFLFdBQUEsZ0JBTmhDbEc7S0FNL0IsT0FBQTs7SUFDQyxHQUFBLGdDQVA4QkEsR0ExQnBDcXVGO0tBa0NHLE9BQUEseUJBUmlDcnVGO0lBU3FDLFdBQUEsZ0JBVHJDQTtJQVNqQyxPQUFBO0dBQWdGO1lBR25GeXVGLFlBQVl6dUY7SUFDZCxHQUFHLGdDQURXQTtLQUVOLE9BQUEsZ0NBRk1BLEdBckNac3VGO21CQXVDbUMseUJBRnZCdHVGOztJQUlILElBQUxrRyxNQUFLLHVCQUpHbEc7SUFLVCxPQUFBLGdDQURDa0csS0ExQ0ptb0Y7a0JBMkNpQyx5QkFEN0Jub0Y7O0dBQ21FO1lBR2pEd29GLGdCQUFnQjF1RjtJQUN4QyxHQUFHLGdDQURxQ0E7S0FHbkMsR0FBQSxnQ0FIbUNBLEdBN0N0Q3N1RjtNQWlESyxPQUFBLHlCQUppQ3R1RjtLQUtnQyxXQUFBLGdCQUxoQ0E7S0FLakMsT0FBQTs7SUFFSSxJQUFMa0csTUFBSyx1QkFQNkJsRztJQVFuQyxHQUFBLGdDQURDa0csS0FyREptb0Y7S0F1REssT0FBQSx5QkFGRG5vRjtJQUlzRSxXQUFBLGdCQVhwQ2xHO0lBV3BDLE9BQUE7R0FBbUY7WUFHckYydUYsb0JBQW9CM3VGO0lBQ3RCO01BQUcsZ0NBRG1CQSxHQTVEcEJxdUY7U0E2RHVCLGdDQURIcnVGLEdBM0RwQnN1RjtLQTZERyxXQUFLLHlCQUZZdHVGO0lBR2pCO0dBQUk7WUFHZTR1Rix3QkFBd0I1dUY7SUFDaEQ7TUFBRyxnQ0FENkNBLEdBbEU5Q3F1RjtTQW1FdUIsZ0NBRHVCcnVGLEdBakU5Q3N1RjtLQW1FRyxPQUFBLHlCQUYyQ3R1RjtJQU01QyxXQUFBLGdCQU40Q0E7SUFJOUMsT0FBQTtHQUdJO0dBa0JpQjtJQUFBLE1BQUE7SUFBckI2dUYsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFLbkJDLHlCQUF5QjtZQUVIQywyQkFBMkJodkY7SUFHaEQ7O09BQUEsZ0NBSGdEQSxHQUZqRCt1RjtVQUFBQTs7SUFBeUIsT0FBQSw0QkFFd0IvdUY7R0FLM0M7WUFHTml2RixrQkFBa0JqdkY7SUFDcEIsR0FBRyxnQ0FEaUJBO0tBR1QsSUFBTGtHLE1BWGtCOG9GLDJCQVFKaHZGO0tBSWYsT0FBQSxnQ0FEQ2tHLEtBN0dKb29GO21CQThHaUMseUJBRDdCcG9GOzs7SUFHSyxJQUFMQyxNQUFLLHVCQUFNLDRCQU5Hbkc7SUFPZixPQUFBLGdDQURDbUcsS0FqSEprb0Y7a0JBa0hpQyx5QkFEN0Jsb0Y7O0dBQ21FO1lBR3ZFK29GLGtCQUFrQmx2RjtJQUNwQixHQUFHLGdDQURpQkE7S0FHZixLQUFBLGdDQUhlQSxHQXpCbEI4dUY7TUE4QlEsT0FBQSxnQ0FMVTl1RixHQXBIbEJzdUY7b0JBMEhVLHlCQU5RdHVGOztLQUlnQixXQXRCWmd2RiwyQkFrQkpodkY7S0FJYixXQUFLOztJQUlKLEtBQUEsZ0NBUllBLEdBMUJsQjZ1RjtLQW9DTSxPQUFBLGdDQVZZN3VGLEdBckhsQnF1RjttQkFnSVEseUJBWFVydUY7O0lBU2MsV0FBQSx1QkFBTyw0QkFUckJBO0lBU2YsV0FBSztHQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNUlQK2tEO0lBQ0Fpa0I7SUFDQW1tQjtJQUNBQztJQUNBQztJQUNBQztJQTBJQUM7MEJBZkFMLG9CQVZBRDtZQStCQU8sc0JBQXNCeHZGO0lBQ3hCLEdBQUcsZ0NBRHFCQTtLQUdiLElBQUxrRyxNQTFDa0I4b0YsMkJBdUNBaHZGO0tBSW5CLEdBQUEsZ0NBRENrRyxLQTVJSm9vRjtNQThJSyxPQUFBLHlCQUZEcG9GO0tBR3FFLFdBQUEsZ0JBTm5EbEc7S0FNakIsT0FBQTs7SUFFSSxJQUFMbUcsTUFBSyx1QkFBTSw0QkFST25HO0lBU25CLEdBQUEsZ0NBRENtRyxLQWxKSmtvRjtLQW9KSyxPQUFBLHlCQUZEbG9GO0lBR3FFLFdBQUEsZ0JBWG5Ebkc7SUFXakIsT0FBQTtHQUErRTtZQUc5RHl2RixzQkFBc0J6dkY7SUFDOUMsR0FBRyxnQ0FEMkNBO0tBR3pDLEdBQUEsZ0NBSHlDQSxHQTVENUM4dUY7TUFnRTRCLFdBekRORSwyQkFxRHNCaHZGO01BSWhCLE9BQUE7O0tBQ3BCLEdBQUEsZ0NBTG9DQSxHQXZKNUNzdUY7TUE2SkssT0FBQSx5QkFOdUN0dUY7S0FPNkIsV0FBQSxnQkFQN0JBO0tBT3ZDLE9BQUE7O0lBQ0MsR0FBQSxnQ0FSc0NBLEdBN0Q1QzZ1RjtLQXNFMEIsV0FBQSx1QkFBTyw0QkFUVzd1RjtLQVNsQixPQUFBOztJQUNwQixHQUFBLGdDQVZzQ0EsR0F4SjVDcXVGO0tBbUtHLE9BQUEseUJBWHlDcnVGO0lBYStCLFdBQUEsZ0JBYi9CQTtJQWE1QyxPQUFBO0dBQXFGOztJQUdyRjB2RjswQkFoQnNCRCx3QkFkdEJEO1lBdUNTRyxXQUFhOXBGLEtBQWdCN0Y7SUFDeEMsR0FEd0I2RixTQUFNQyxNQUFORCxRQUFBc29DLE1BQU1yb0MsY0FBTnFvQztJQUN4QixvQkFEd0JBOztpQkFBQUE7Z0JBL0dBeWdELHdCQStHZ0I1dUY7Z0JBVHRDMHZGLG1CQVNzQzF2RjsyQkFBaEJtdUMsTUFuSUF1Z0QsZ0JBbUlnQjF1RixLQXZKaEJ3dUYsY0F1SmdCeHVGO0dBS1o7WUFHMUI0dkYsT0FBUy9wRixLQUFnQjdGO0lBQzNCLEdBRFc2RixTQUFNQyxNQUFORCxRQUFBc29DLE1BQU1yb0MsY0FBTnFvQztJQUNYLElBQUksZUFUT3doRCxlQVFBeGhELE1BQWdCbnVDLEtBQ3ZCO2dCQUNHO0dBQUk7WUFHVDZ2RixPQUFPN3ZGO0lBQUksV0FBQSxnQ0FBSkE7SUFBSSxPQUFBO0dBQVk7WUFDdkI4dkYsVUFBVTl2RjtJQUFJLFdBQUEsNEJBQUpBLEdBQUFBO0lBQUksT0FBQTtHQUFXO1lBRXpCK3ZGLFNBQVV6Z0csR0FBT0M7SUFDbkIsT0FBRyxtQkFEZ0JBO2NBQVBEO2NBQ2U7d0JBRGZBO2dCQUFPQztnQkFDZ0MsZ0NBRHZDRCxHQUFPQyxLQUFQRCxJQUFPQztHQUNtRDtZQUdwRXlnRyxTQUFVMWdHLEdBQU9DO0lBQ25CLE9BQUcsbUJBRGdCQTtjQUFQRDtjQUNlO3dCQURmQTtnQkFBT0M7Z0JBQ2dDLGdDQUR2Q0QsR0FBT0MsS0FBUEQsSUFBT0M7R0FDbUQ7O0lBR3BFNGdDO0lBQ0F0d0I7SUFDQXltRDtJQUVBNW9DO1lBQ0F1eUUsT0FBTzNnRyxHQUFJLE9BQUEsNEJBQUpBLEdBQUFBLEdBQVU7WUFXZjRnRyxXQUFXbHdGLEdBQUksT0FBQSw2QkFBSkEsR0FBUztZQUNwQm13RixTQUFTbndGLEdBQUksT0FBQSw2QkFBSkEsR0FBUztZQU9wQm9sRCxtQkFBbUJwbEQ7SUFBSSxPQUFHLGdDQUFQQTtjQUFvQix1QkFBcEJBO2NBQXNDLHFCQUF0Q0E7R0FBZ0Q7WUFHcERvd0YscUJBQXFCcHdGO0lBQ3RDO01BQUcsZ0NBRG1DQSxHQXpJcEM2dUY7U0EwSXlCLGdDQURXN3VGLEdBeElwQzh1RjtLQTBJUyxPQUFBLHVCQW5JYUUsMkJBaUljaHZGO0lBR2pDLE9BQUEsNEJBSGlDQTtHQUcxQjtZQUdWc2xELGNBQWN0bEQsR0FBSSxPQU5Ib3dGLHFCQU1EcHdGLEdBQW9EO1lBRWxFcXdGLDJCQUEyQnJ3RjtJQUM3Qjs7TUFBRyxnQ0FEMEJBLEdBakozQjZ1RjtXQWtKMEIsZ0NBREM3dUYsR0FoSjNCOHVGO0tBb0pZO01BQVJ6aEQsUUFBUSx1QkFKZXJ0QztNQU12QnN3RixlQUFlLDRCQUZmampEO01BR0FrakQsYUFBYSw0QkFQVXZ3RixHQUl2QnF0QztNQUlBbWpELFlBQVksNEJBRlpGLGNBTnVCdHdGO0tBU3hCLEdBQUEsZ0NBRkN1d0YsWUFDQUMsWUFFQyxPQU5EbmpEO0tBT0ksR0FBQSxnQ0FKSmtqRCxZQUNBQztNQUlDLE9BTkRGO0tBUUYsV0FBQSxzQkFWRWpqRDtLQVVGLE9BQUEsNENBVkVBLFFBRUFpakQ7O0lBSkQsT0FBQSw0QkFGd0J0d0Y7R0FnQlQ7R0FHRztJQUFyQnl3RixxQkFBcUI7SUFDckJDLHFCQUFxQjtZQUVyQkMsbUJBQW1CM3dGO0lBQ3JCLEdBQUcsZ0NBRGtCQTtLQUdWLElBQUxrRyxNQUFLLHFCQUhVbEc7S0FJaEIsR0FBQSxnQ0FEQ2tHLEtBTEp3cUY7TUFPSyxPQUFBLDJCQUZEeHFGO0tBTUEsV0FBQSw0QkFUZWxHO0tBT2pCLE9BQUE7O0lBSUksR0FBQSxnQ0FYYUEsR0FIbkJ5d0Y7S0FlRyxPQUFBLDJCQVpnQnp3RjtJQWdCakIsV0FBQSw0QkFoQmlCQTtJQWNuQixPQUFBO0dBR0k7WUFHSjR3RixxQkFBcUI1d0Y7SUFDdkIsR0FBRyxnQ0FEb0JBO0tBR2xCLEdBQUEsZ0NBSGtCQSxHQXRCckIwd0Y7TUEwQkssT0FBQSwyQkFKZ0Ixd0Y7S0FRakIsV0FBQSw0QkFSaUJBO0tBTW5CLE9BQUE7O0lBS08sSUFBTGtHLE1BQUssdUJBWFlsRztJQVlsQixHQUFBLGdDQURDa0csS0FsQ0p1cUY7S0FvQ0ssT0FBQSwyQkFGRHZxRjtJQU1BLFdBQUEsNEJBakJpQmxHO0lBZW5CLE9BQUE7R0FHSztZQUdQNndGLCtCQUF1Q3ZHO0lBQ2pDLElBQUp0cUYsSUF4RWFvd0YscUJBdUV3QjlGO0lBRXRDLEdBQUEsZ0NBREN0cUY7S0FHQyxHQUFBLGdDQUhEQSxHQTVDRjB3RjtNQWdESyxPQUFBLDJCQUpIMXdGO0tBUUUsV0FBQSxnQkFUbUNzcUY7S0FPckMsT0FBQTs7SUFJSSxHQUFBLGdDQVZKdHFGLEdBN0NGeXdGO0tBd0RHLE9BQUEsMkJBWER6d0Y7SUFlQSxXQUFBLGdCQWhCcUNzcUY7SUFjdkMsT0FBQTtHQUdJO1lBR0p3RywrQkFBdUM3d0Y7SUFBaUIsV0F2SnhEeXZGLG1CQXVKdUN6dkY7SUFBaUIsT0FBQTtHQUFzQjs7SUFFOUU4d0Y7O1NBRkFEO1NBcEJBRDtZQTRCQXJyQyxNQUFRMy9DLEtBN0ZNN0Y7SUE4RmhCLEdBRFU2RixTQUFNQyxNQUFORCxRQUFBc29DLE1BQU1yb0MsY0FBTnFvQztJQUNWLG9CQURVQTs7aUJBQUFBO2dCQXRHUmlYLG1CQVNjcGxEO2dCQU5Db3dGLHFCQU1EcHdGOztpQkE2Rk5tdUM7Z0JBR0MsdUJBaEdLbnVDO2dCQWlHUCxxQkFqR09BO0dBa0dlO09BWTNCL0g7R0FLRCxTQUZDcTJCLFlBb0JDL1o7SUFsQkY7O2NBa0JFQTtpQkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFqQmdEOztTQUNWOztRQUNNOztPQUNNOztNQUNWOztnQkFheENBOztNQUNBLE9BQUE7NENBcEJFMjRDLGtCQW1CRjM0Qzs7O01BREEsT0FBQTs0Q0FsQkUyNEMsa0JBbUJGMzRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQVhjLE9BQUE7K0NBUloyNEMsa0JBbUJGMzRDOztRQVRBLE9BQUE7OENBVkUyNEMsa0JBbUJGMzRDOztPQVBBLE9BQUE7NkNBWkUyNEMsa0JBbUJGMzRDOztNQUxjLE9BQUE7NENBZFoyNEMsa0JBbUJGMzRDOztLQUhBLE9BQUE7MkNBaEJFMjRDLGtCQW1CRjM0Qzs7SUFHQSxPQUFBLHdDQXRCRTI0QyxrQkFtQkYzNEM7R0FHc0U7WUFJdkUzSTtJQUNEOztPQUNlOztPQUNMOztPQUNHOztPQUNHO2VBQ0w7O0dBQXlCO1lBcUJuQzYzQyxZQUFVempEO0lBQW1CLFdBM0I3QjRMLFlBMkJVNUw7SUFBbUIsT0FBQTtHQUFhO1lBQzFDZ21ELFlBQVV0b0Q7SUFBSSxPQXZEZDR3QixZQXVEd0IsNkJBQWQ1d0I7R0FBZ0M7WUFHNUNzekYsU0FBU2h4RjtJQUNYLE9BQ00sMkJBRktBOztPQUdJOztPQUNHOztPQUNMOztPQUNJO2VBQ0w7O0dBQUs7WUFHZnFqRCxtQkFBcUJ4OUMsV0FBdUNrdkI7SUFDOUQsR0FEdUJsdkIsU0FBWUMsTUFBWkQsUUFBQTQ4QyxZQUFZMzhDLGNBQVoyOEM7SUFDdkIsYUFEdUR0akMsaUJBQWI4eEUsYUFBYTl4RSxnQkFBYjh4RTtJQUNwQyxZQUFBLDRCQUR3RGw4RDs7S0FFcEQsT0FBQSxxQ0FGb0RBLFFBQXZDMHRCO0lBSVY7O0tBRENsYjtLQUFORDtLQUNGdUIsU0FBTyxxQ0FETHZCLE1BSGVtYjtLQUtqQm9uQjtPQUxvQ29uQjtVQU1uQjs7d0JBQStCemhGLEdBQUssT0FBQSwwQkFBTEEsT0FBcUI7V0FIN0QrM0I7VUFBQUE7T0FFUnNpQyxtQkFJSyxPQUxMaGhDO0lBTVcsV0FBQSxvQ0FMWGdoQztJQUtXLE9BQUEsNkJBTlhoaEM7R0FNdUI7WUFHM0IxUyxjQUFlc3NCLFdBQVk1OEMsS0FBZW9yRixrQkFBb0NoeEY7SUFDaEYsR0FENkI0RixTQUFXQyxNQUFYRCxRQUFBcXJGLFdBQVdwckYsY0FBWG9yRjtJQUM3QjtTQUR5RS94RSxpQkFBaEJneUUsZ0JBQWdCaHlFOztTQUFoQmd5RTtPQUE1QkQsY0FFeEIsZ0NBRndCQTtJQUd2QixZQTFCSkYsU0F1QjhFL3dGO29CQUtqRTs7S0FEUSxPQUFBLGdDQUp5REE7O0tBTzFFdkM7T0FQbUR5ekY7VUFRL0IsZ0NBUkdELFVBQW1EanhGO1VBUXRCLGdDQVI3Qml4RixVQUFtRGp4RjtJQVU5RSxPQXZCQW9qRCxtQkFhZVosV0FBMkJ3dUMsWUFPdEN2ekY7R0FHdUM7WUFHM0NxeEIsWUFBVS91QjtJQUNELElBQVBnTCxPQUFPLFdBdG1CUGxCLFdBcW1CUTlKO3VDQUdTLE9BRmpCZ0w7YUFBQUE7U0FVTStwQixTQVZOL3BCO0tBV0ksT0FBQSxrQ0FERStwQjtlQVZOL3BCO21CQTNCRnE0Qyx5QkFxQ1F0dUI7O0lBREEsNkJBQVUseUJBVGhCL3BCO0lBT0csT0FBQTthQTNuQkx1c0I7YUEybkJLO0dBSTRFO1lBR2pGNjVEO0lBQWdDcHhGLEdBQUk2RixLQUFjd3JGLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DO0lBSzVFLEdBTHNDNXJGLFNBQVNDLE1BQVRELFFBQUEwbEIsU0FBU3psQixjQUFUeWxCO0lBOEJoQyxZQWpGSnlsRSxTQW1EZ0NoeEY7b0JBZ0NuQjs7S0FEUSxPQUFBLGdDQS9CV0E7YUFrQzVCb3JFLEdBQUdwckU7Y0FjRHFwRCxLQUFLcW9DLEtBQUlDLFdBQUVDO01BQ2I7O09BQ3lCO1NBQXRCLGdDQUZVQTtZQUVZLGdDQUZkRDs7T0FHTCxHQUFBLGdDQUhPQztRQUd1QztTQWpSMUMxckYsTUFpUjBDLDRCQUh2QzByRjtTQTlRQyxPQU5IeEIscUJBTURscUY7UUFpUnVCLEdBQUEsZ0NBSHRCeXJGOztPQUNYLE1BQUE7O01BRzBCO09BbFJoQjN4RixJQWtSZ0IsNEJBSmI0eEY7T0E5UUMsT0FOSHhCLHFCQU1EcHdGO01Ba1JILEtBQUEsZ0NBSkkyeEY7T0FJWCxNQUFBO01BOUNJO09BQUpuaUU7U0FBSTt1QkFBTSw0QkEwQ0NtaUUsV0FBRUM7T0FuQ2JoakMsUUFBUSw0QkFtQ0tnakMsYUExQ2JwaUU7T0FRd0IsT0FBQSw0QkFSeEJBO09BUUFxaUUsU0FBUyw0QkFrQ0lEO09BOUJiRSxhQUFhLDRCQUpiRCxRQWtDV0Y7T0E3QlhJLFlBQVksNEJBNkJESixXQW5DWC9pQztPQU9BclQsTUFwVEptMEMsbUJBc1NJbGdFO09BZ0RNOG1DO1NBakNQLGdDQUhDdzdCLFlBQ0FDO1lBR0MsNEJBRkR4MkM7WUFHSTttQ0FMSnUyQyxZQUNBQztjQUNBeDJDOztrQkFNb0MsNkJBTnBDQTtnQkFBQUE7Z0JBUUMsNEJBUkRBO09BaUNPelAsSUFHRyw2QkFGSndxQjtPQURGcjlELElBR0YsNEJBRklxOUQ7Y0FERnI5RCxZQUFBQTtlQUFHNnlDLFVBQUFBO3FCQUFBQTtrQkFTRixnQ0E5RDJCdmdCLFFBcUQ1QnR5QixHQUxHeTRGO2tCQWVGLGdDQS9EMkJubUUsUUFxRDVCdHlCLEdBTEd5NEYsS0FLQTVsRDtPQU9QLE1BQUE7O01BREEsTUFBQTtLQUlzQztLQWFyQyxLQUFBLGdDQTFDRTlyQztNQTRDRyxHQUFBLGdDQTVDSEE7T0E2Q0EsT0EvQkRxcEQsS0FoRDRDZ29DLE1Ba0MzQ3J4RjtNQThDRyxHQUFBLGdDQTlDSEE7T0ErQ0EsT0FqQ0RxcEQsS0FoRGtEaW9DLE1Ba0NqRHR4RjtNQWdERyxHQUFBLGdDQWhESEE7T0FpREEsT0FuQ0RxcEQsS0FoRHdEa29DLE1Ba0N2RHZ4RjtNQWtERyxHQUFBLGdDQWxESEE7T0FtREEsT0FyQ0RxcEQsS0FoRDhEbW9DLE1Ba0M3RHh4RjtXQWxDbUV5eEYsTUF3RjVELE9BQUEsZ0NBeEZzQmxtRSxRQWtDN0J2ckI7VUF1RElneUYsU0F6RitEUDtNQTBGakUsT0FBQSxnQ0F4REZ6eEY7Z0JBY0RxcEQsS0F5Q0syb0MsUUF2REpoeUY7Z0JBMERJLGdDQTVGeUJ1ckIsUUFrQzdCdnJCOztLQUVnQjtPQUFYLG9DQUZMQTtVQUVnQixnQ0FGaEJBO01BR0s7T0FBSjFRLElBQUksNkJBckN3Qmk4QixRQXFDZiwwQkFIZHZyQjtNQUtBLEtBQUEsNEJBRkMxUSxXQVNDLE9BVERBO01BSU07T0FBSittQixNQUFJLDRCQUpOL21CO09BS0VrakIsSUFBSiw2QkFESTZEO01BRUosZUFGSUEsS0FFUSw0QkFEUjdEO01BRUosZUFISTZELEtBR1EsNEJBRlI3RDtNQUVKLE9BQUEsNEJBSEk2RDs7S0FMTixNQUFBO0lBd0RpQztJQUVsQyxHQUFBLGdDQTlGNkJyVyxRQThGaEIsT0E1RFpvckUsR0FsQzRCcHJFO0lBOEZBLFdBNUQ1Qm9yRSxHQTREK0IsNkJBOUZIcHJFO0lBOEZBLE9BQUE7R0FBTztZQUd2Q2l5Rix5QkFBeUJqeUY7SUFDM0IsT0FsR0VveEY7YUFpR3lCcHhGO0dBQzJEO1lBVXBGeWtELFFBQVFuMUQsR0FBRWtqQjtJQUNaLFNBRFlBLEdBR1A7SUFRSztLQUFKNkQsVUFBUSw0QkFYSi9tQjtLQVlKbWpCLFVBWk1EO0tBYU40TztPQURBM087S0FEQTRELFNBTUcsZ0NBTkhBO0tBQ0E1RCxTQU1HLDZCQU5IQTtRQUFBQSxZQUNBMk8sV0FGQS9LLFFBZUEsNkJBZEE1RDs7O2FBQUFBLDJDQURBNEQsUUFFQStLO2NBaUJDLDZCQWxCRDNPO01BQ0EyTyxXQWlCOEIsNEJBbkI5Qi9LLFFBRUErSztLQUZBL0ssU0FvQkcsNEJBcEJIQSxRQUFBQTtLQUNBNUQsU0FvQkcsNkJBcEJIQTs7R0F3QlM7WUFHYnkvRSxVQUFVNWlHLEdBQUdnc0M7SUFDZixHQUFHLGdDQURTaHNDLFFBRVA7SUFDTyxLQS9aVndnRyxVQTRaVXhnRyxJQUlQLE9BSk9BO29CQUFHZ3NDO0tBVUs7TUFETTYyRCxLQVRYNzJEO01BVUs7UUFBQTtVQXptQmxCeDZCO1VBeW1CeUIscUJBQVUsaUJBQU8sc0JBVmhDeFI7TUFVRjhpRyxLQUFLLDRCQURXRDtNQUZoQkUsT0FHQUQ7TUFISkUsT0FFb0JIOztLQUlOO01BTlZJLE9BUEtqM0Q7TUFhSztRQUFBO1VBNW1CbEJ4NkI7VUE0bUJ5QixxQkFBVSxpQkFBTyxzQkFiaEN4UjtNQU9Oa2pHLE9BTVMsNEJBTkxEO01BQUFGLE9BQUFFO01BQUpELE9BQUFFO1dBQUFGLE1BV0M7YUFYREEsTUFhQyxPQXBCS2hqRztJQXdCSyxJQUFUbWpHLFNBQVMseUJBakJQSjthQWlCRkksZUFqQkZIO0tBb0NZLElBQVJ0eEUsUUFsRlJ5akMsYUErRE1ndUM7S0FvQkYsUUFyQ0lKO01Bc0NDOztTQTVaVGhDLDJCQTRab0MsNEJBN0MxQi9nRyxHQTJDRjB4QjtNQUVDLE9BQUEsa0NBRkRBOztLQUdDO2FBN1pUcXZFLDJCQTZab0MsNEJBOUMxQi9nRyxHQTJDRjB4QjtLQUdDLE9BQUEsa0NBSERBOztJQUZTLE9BM3hCakJ6ZixVQTJ4QmlCLGdDQWxDYit3RixNQVBNaGpHO0dBOENrRDtZQUc1RG9qRyxrQkFBa0JwakcsR0FBR3FqRztJQUN2QixXQUR1QkE7Y0FqRHJCVCxVQWlEa0I1aUcsa0JBQUdxakc7Y0FHckIsZ0NBSHFCQTtHQU91QztZQUc1REMsY0FBY3RqRyxHQUFHdWpHO0lBQWlCLE9BM0RsQ1gsVUEyRGM1aUcsbUJBQUd1akc7R0FBa0U7WUFDbkY1NUQsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU8sV0FBQSxnQ0FBWkQsS0FBSGw1QjtJQUFlLDhDQUFmQSxHQUFRbTVCO0dBQTRCO1lBRTVDRSxVQUFVcjVCLEdBQUd2USxLQUFLRDtJQUVwQixHQUFPLGdDQUZRQyxLQUFLRDtLQUlwQixPQUFBLDRCQUpZd1EsR0FBR3ZRLEtBQUtEO0lBRXBCLE1BQUE7R0FFMkI7WUFHekI4cEMsTUFBTXQ1QixHQUFHdlEsS0FBS0Q7SUFFaEIsR0FBRyxnQ0FGUUMsS0FBS0Q7S0FHWCxXQUFHLDRCQUhBd1EsR0FBR3ZRLEtBQUtEO0lBUVQ7NEJBQWlDLFdBcDFCcENzYSxXQTQwQll0YTtLQVFULHVCQUFTLFdBcDFCWnNhLFdBNDBCT3JhO0tBTVAsTUFBQTtJQUFBLE9BQUE7R0FFc0Q7O0lBR3hENGY7SUFDQXphO0lBQ0FDO0lBRUFDO0lBRUFDO1lBRUErOUYsU0FBUzl5RjtJQUNYLEdBQUcsZ0NBRFFBLFFBRU47SUFDRyxHQUFBLGdDQUhHQSxRQUlOO0lBQ0csR0FBQSxnQ0FMR0EsUUFNTjtJQUNvRDtLQUFBLHFCQWpRdkQrdUIsWUEwUFMvdUI7S0FPUSxNQUFBO0lBQUEsT0FBQTtHQUEwRDtZQUczRSt5RixZQUFZL3lGO0lBQ2QsT0FBRyxnQ0FEV0E7O2NBQ2E7cUNBRGJBOztnQkFDcUMsZ0NBRHJDQTtHQUM4RDtZQUcxRWd6RixjQUFjaHpGO0lBQ0wsSUFBUHliLE9BQU8seUJBREt6YjtJQUVWLE9BQUEsc0JBREZ5YjtHQUN5QjtHQUtGO0lBRHpCdzNFOztJQUNBQztNQUF5QjtRQUFBO0lBQ3pCQyxnQkFBZ0IsMEJBRGhCRDtJQUNnQjtJQUNPLE1BQUEsMkNBSHZCRDtJQUdBRyxnQkFBdUI7SUFDdkJDLGtCQUFrQiwyQkFEbEJEO1lBR0FFLGNBQWN0ekY7SUFDaEI7S0FBSXliLE9BQU8seUJBREt6YjtLQUVELE1BQUEsMkJBRFh5YixNQVBGdzNFO0lBUUssT0FBQTthQUFBLGdDQVBMQztHQVFrQjtZQUdsQkssY0FBY3Z6RjtJQUNMLElBQVB5YixPQUFPLHlCQURLemI7SUFFZSxPQUFBOzZCQUFBLHVCQUQzQnliLE1BVEY0M0U7R0FVeUQ7WUFHekRHLGdCQUFpQkMsVUFBVTl1QyxVQUFVK3VDO0lBQ3ZDLEdBQVEseUJBRHFCL3VDLFVBZjNCd3VDLG1CQWUyQnh1QztLQUV4QixPQUFBLGdDQUZ3QkEsVUFmM0J3dUM7SUFrQmEsVUFBQSwyQkFId0JPLFVBZHJDTjtJQWlCYSxHQUFBLGdDQUh3Qk07S0FRbkM7TUFBQSxNQUFBLDJCQXRCRk47TUFxQkUsTUFBQSwyQkFQbUNNO0tBS3JDLE9BQUE7O0lBT2dCO0tBRFpDLFlBWGFGO0tBWWJHO09BQVk7U0FBc0IsNEJBWlhqdkM7S0FhdkJrdkMsWUFBWSwyQkFicUJIO0tBY2pDajRFLE9BQW1CLGNBSG5CazRFLFdBR21DLGNBRm5DQyxXQUNBQztJQUVKLE9BQUEsaUNBRElwNEU7R0FDMEI7WUFHOUJxNEUsWUFBYUwsVUFBVTl1QyxVQUFVK3VDO0lBQ25DLE9BQWtCOzs7O2NBQVcsT0FuQjNCRixnQkFrQmFDLFVBQVU5dUMsVUFBVSt1QzthQUN1QztHQUFDO1lBT3ZFelQsWUFBVTN3RixHQUFJLE9BQUEsZ0NBQUpBLEdBQTJCO1lBQ3JDaW1ELFlBQVVqbUQsR0FBSSxXQURkMndGLFlBQ1Uzd0YsSUFBMkI7WUFDckNpM0QsWUFBVWozRCxHQUFJLE9BMzRCaEJpUyxVQTI0QllqUyxHQUFlOzs7MENBMTVCekIrSCxXQU5BeVMsV0FnS0ZzOEM7O1lBOHdCQXhzQixZQUFZNTVCLEdBQUksT0FBQSxnQ0FBSkEsT0FBVTtZQUN0QjY1QixnQkFBZ0I3NUIsR0FBSSxPQUFBLGdDQUFKQSxPQUFXO1lBQzNCODVCLFlBQVk5NUIsR0FBSSxPQUFBLGdDQUFKQSxPQUFVO1lBQ3RCKzVCLGdCQUFnQi81QixHQUFJLE9BQUEsZ0NBQUpBLE9BQVc7Ozs2Q0FLdkJxSyxhQWh5QkovSTs7O0lBNnlCMkN0TTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztZQU16Q2lyRixXQUFTaHhGLEdBQUksT0FBSkEsRUFBSztHQWFIO0lBS1h5a0c7SUFMVzs7Ozs7O09BS1hBO09BOXNCRmhGO09BME1BOEI7T0FvQkFDO09BdktzQnJCOzs7Ozs7Ozs7Ozs7WUFpc0J0QmhnRyxJQUFLSCxHQUFPQztJQUFJLEtBQUcsc0JBQWRELEdBQU9DLFFBQWdCLG1CQUF2QkQsSUFBNEMsT0FBckNDO0lBQThCLE9BQXJDRDtHQUE2QztZQUNsREUsSUFBS0YsR0FBT0M7SUFBSSxLQUFHLHNCQUFkRCxHQUFPQyxRQUFnQixtQkFBdkJELElBQTRDLE9BQXJDQztJQUE4QixPQUFyQ0Q7R0FBNkM7Ozs7T0FyZ0MvQ3NhO09Ba0JIbkk7T0FEQUQ7T0EzQkdrRTtPQUdBMkQ7T0FLRHFIO09Bc21CRnFlO09BaGxCQXh0Qjs7Ozs7Ozs7O09BZy9CQTlSO09BQ0FEOzs7T0FuTUF5cEM7T0FFQUk7T0FPQUM7OztPQXYwQkVvQjtPQXk2QkZkO09BQ0FDO09BQ0FDO09BQ0FDO09BaDZCQWx3Qjs7T0EySUFuSTtPQUNBbk47T0FEQW1OO09BQ0FuTjtPQUdBNnhEO09BQ0FyQjtPQUNBaWtCO09BQ0FtbUI7T0FDQUM7T0FDQUM7T0FDQUM7OztPQVJBcEI7T0FDQUM7Ozs7O09BUUFqdEY7T0FDQUo7T0FDQXN0RjtPQUNBeG5DO09BQ0FFO09Bd1VBdEI7T0E5SUFvcUM7T0FSU0Q7T0FnRFR2cUM7OztPQVNBRTtPQUVBK3FDO09BaExBMUI7T0F0QkFGO09BdEJBRjtPQW9IQWdCO09BbEVzQlg7T0FwQkFGO09BcEJBRjtPQThJdEJrQjtPQThHQWtCO09BcEJBRDtPQStEQUk7T0FqVUExQztPQUNBQztPQThQQW1DO09BQ0FDO09BNFlBZ0M7T0FVQUU7O09BeGRBL0M7T0FDQUM7O09BRUFDO09BSUFDO09Bc2VBM2dGO09BQ0F6YTtPQUdBRTs7T0FGQUQ7O09BSUFFO1dBeGRFbTdGLFlBQ0FDOzs7T0FqQkZoZ0U7T0FDQXR3QjtPQUNBeW1EO09BRUE1b0M7OztRQThkQXJPO1FBQ0F6YTtRQUNBQztRQUVBQzs7O1FBRUFDO1FBc0cyQ007UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7O1FBNWtCM0NzeEQ7UUF2TkFGO1FBT0FsbEQ7UUFreUJFby9FO1dBbEhGanhFLFVBQ0F6YSxVQUNBQyxVQUVBQyw0QkFFQUM7T0F2c0JBdU07T0FrY0E2MEI7T0E2SEE4N0Q7T0FqR0FiO09BNEdBM3NDO09BdFdBd3JDOzs7O1FBMElFaDRGO1FBQ0FnUztRQUVBcWtCO1FBMkJBMWlCO1FBVUMwakI7UUFrQkQwMkI7UUFEQXZDO09BSUZ1dEM7O09BOFJBOEI7T0FVQUM7T0E2Q0FlO09BbEJBTjtPQXZCQVI7T0FZQU07T0FNQUM7V0FoNEJFN2lGLFdBZzZCQTZrQyxhQTk1QkMzckMsZ0JBKzVCRDI4QyxhQUZBMDVCOzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQzU2QkYrVCxjQUFjaDBGLEdBQUV0QyxHQUFHZ2QsS0FBS3ZiO0lBQU0sT0FBQSxnQkFBaEJhLEdBQUV0QyxHQUFHZ2QsS0FBS3ZiO0dBQStCO1lBQ3ZEODBGLGFBQWFqMEYsR0FBRXRDLEdBQUdnZCxLQUFLdmI7SUFBTSxPQUFBLGdCQUFoQmEsR0FBRXRDLEdBQUdnZCxLQUFLdmI7R0FBOEI7WUFDckQySyxVQUFVOUo7SUFBbUIsVUFBQSxxQkFBbkJBO0lBQW1CLE9BQUE7R0FBWTtZQVluQ2svQyxTQUFRLy9DLEtBQU0sT0FBQSwyQkFBTkEsS0FBc0I7T0FDOUJpYTtZQUVBbkosWUFBYTJyQixLQUFLQyxTQUFTQyxLQUFLQyxTQUFTNThCO0lBQzNDLE9BQUEsNkJBRGV5OEIsS0FBS0MsU0FBU0MsS0FBS0MsU0FBUzU4QjtHQUNDOzs7OztZQUgxQ2lhLFVBREE4bEMsVUFHQWp2Qzs7Ozs7Ozs7O09BZk5uRzs7Ozs7Ozs7Ozs7Ozs7OztPQUZBa3FGOztPQUNBQzs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0NEUTs7SUFDUkM7Ozs7Ozs7SUFEQUM7WUFHQXBpRixJQUFNbE07SUFDUixHQURRQTtTQUFxQkMsTUFBckJELFFBQUF1dUYscUJBQXFCdHVGOztTQUFyQnN1RjtJQUNSLE9BQUEsbUNBRFFBO0dBQ3NDO1lBRzVDOXlGLFVBQVV0QjtJQUNaLE9BUkVtMEYsV0FDQUQsaUJBT2lDLGdDQUR2QmwwRjtHQUM4RDtZQUd4RXEwRixlQUFlcjBGO0lBQXVCLFVBSnRDc0IsVUFJZXRCO0lBQXVCLE9BQUE7R0FBYTtZQUNuRDhKLFVBQVU5SjtJQUF3QixVQURsQ3EwRixlQUNVcjBGO0lBQUksV0FBVSx3Q0FBcUMxUSxHQUFLLFdBQUxBLEdBQWdCO0dBQUU7O0lBRzdFZ2xHO0lBQ0FDOzs7WUFDQUMsbUJBQWlCLE9BQUEsbUNBQWtDO1lBRW5EQyxvQkFBb0JycEY7SUFDdEIsT0FBRyx5QkFEbUJBLFdBRnBCb3BGO0dBR3VFO1lBZXZFRSxlQUFlcnhGLEdBQUdwRDtJQUNSLElBQVIwMEYsUUFBUSxXQXBCVko7SUFxQkYsV0F0QkVELGVBb0JlanhGO0lBR08sT0FBQTs7YUFISnBEOzZCQUdlLE9BRG5DLFdBdEJFcTBGLGVBcUJFSyxPQUVrRDtHQUFDO1lBSXZENW5GO0lBaEJRLFlBQUE7O0tBRWtCO01BQWpCemQ7O01BQWlCLE1BQUEsNEJBQWpCQTtNQUhMc2xHO1FBR1U7Ozt3QkFBQSxPQUFBOztTQUhWQTtJQUtKLGNBTElBO2lCQUswQyxXQWY1Q047R0EyQitDOzs7O09BOUJqRHhxRjtPQVRBaUk7T0FJQXpRO09BSUEreUY7T0FYQUY7O1FBZ0JFSTtRQURBRDtRQW9CQUk7UUFsQkFGO1FBRUFDO09BdUJGMW5GOzs7RTs7Ozs7Ozs7O0c7Ozs7O0dDcUhVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXBJVnJkO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvSVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBYVI2STtJQVA4QixpQ0FPOUJBO0lBU0E2SjtJQUNBc0I7SUFFQW1zRjtJQUlBQztZQUlDQyxtQkFHQzUvRTtJQUFvQixPQUFBLDBCQUFwQkE7R0FBeUQ7R0FBN0Q7SUFPRXhPO0lBQ0FzQjtJQUVDbkU7SUFNQytJO0dBQ0osU0FGR3pILFVBRUM5VixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXOztJQUdiMGxHO0lBQ0FDO0lBQ0NDO0lBTUR0dUY7SUFDQXNCO0lBRUNyRTtJQU1Dd2lEO0dBQ0osU0FGR25oRCxVQUVDNVYsR0FBSyxPQUFBLFdBREwrMkQsUUFDQS8yRCxHQUFXOztJQUdiNmxHO0lBQ0FDO0lBQ0NDO0lBTURDO0lBTUF6dUY7SUFDQTRCO0lBRUNoRjtJQU1DOHhGO0dBQ0osU0FGR2p3RixXQUVDaFcsR0FBSyxPQUFBLFdBRExpbUcsUUFDQWptRyxHQUFXOztJQUdia21HO0lBQ0FDO0lBQ0NDO0lBTUQ1dUY7SUFDQXFCO0lBRUM1RTtJQUlDb3lGO0dBQ0osU0FGR3h3RixTQUVDN1YsR0FBSyxPQUFBLFdBRExxbUcsUUFDQXJtRyxHQUFXOztJQUdic21HO0lBQ0FDO0lBQ0NDO0lBTUQvdUY7SUFDQXFCO0lBRUN4RTtJQU1DbXlGO0dBQ0osU0FGRzl3RixXQUVDM1YsR0FBSyxPQUFBLFdBREx5bUcsUUFDQXptRyxHQUFXOztJQUdiMG1HO0lBQ0FDO0lBQ0NDO0lBTURsdkY7SUFDQXFCO0lBRUM3RTtJQU1DMnlGO0dBQ0osU0FGR254RixXQUVDMVYsR0FBSyxPQUFBLFdBREw2bUcsUUFDQTdtRyxHQUFXOztJQUdiOG1HO0lBQ0FDO0lBQ0NDO0lBTUQ1dUY7SUFDQWtCO0lBRUExRTtJQVVBcXlGO0lBSUFDO1lBSUNDLGtCQUNDdGhGO0lBQW9CLE9BQUEseUJBQXBCQTtHQUF3RDtHQUE1RDtJQVFFbE87SUFDQXFCO0lBRUN2RTtJQU1DMnlGO0dBQ0osU0FGRzN4RixlQUVDelYsR0FBSyxPQUFBLFdBRExvbkcsUUFDQXBuRyxHQUFXOztJQUdicW5HO0lBQ0FDO0lBRUNDO0lBU0Q5dUY7SUFJQWM7SUFJQTdFO0lBVUE4eUY7SUFJQUM7WUFJQ0Msb0JBR0M3aEY7SUFBb0IsT0FBQSwyQkFBcEJBO0dBQTBEO0dBQTlEO0lBT0VuTjtJQUNBYztJQUVBbXVGO0lBSUFDO1lBSUNDLGlCQUNDaGlGO0lBQW9CLE9BQUEsd0JBQXBCQTtHQUF1RDtHQUEzRDtJQU9Fak87SUFDQXFCO0lBRUM3RTtHQU9ILFNBRkcyQixZQUVDL1YsR0FBSyxnQ0FBTEEsR0FBVzs7SUFHYjhuRztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQU1EeHdGO0lBQ0FxQjtJQUVDbEY7SUFNQ3MwRjtHQUNKLFNBRkdyeUYsVUFFQ2pXLEdBQUssT0FBQSxXQURMc29HLFFBQ0F0b0csR0FBVztHQWxUSDtJQXFUVnVvRztJQUNBQztJQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQ0QzbEY7SUFZQXBWO0lBQ0FFO0lBT0E4NkY7SUFDQUM7SUFDQTFnRTtJQUlBcDZCO0lBM1hVOztPQUlWaUs7T0FDQXNCO09BRUFtc0Y7T0FJQUM7T0FJQ0M7T0FVRHB1RjtPQUNBc0I7T0FFQ25FO09BS0FzQjtPQUtENHZGO09BQ0FDO09BQ0NDO09BTUR0dUY7T0FDQXNCO09BRUNyRTtPQUtBcUI7T0FLRGl3RjtPQUNBQztPQUNDQztPQU1EQztPQU1BenVGO09BQ0E0QjtPQUVDaEY7T0FLQTZCO09BS0Rrd0Y7T0FDQUM7T0FDQ0M7T0FNRDV1RjtPQUNBcUI7T0FFQzVFO09BR0E0QjtPQUtEeXdGO09BQ0FDO09BQ0NDO09BTUQvdUY7T0FDQXFCO09BRUN4RTtPQUtBcUI7T0FLRCt3RjtPQUNBQztPQUNDQztPQU1EbHZGO09BQ0FxQjtPQUVDN0U7T0FLQXdCO09BS0RveEY7T0FDQUM7T0FDQ0M7T0FNRDV1RjtPQUNBa0I7T0FFQTFFO09BVUFxeUY7T0FJQUM7T0FJQ0M7T0FTRHh2RjtPQUNBcUI7T0FFQ3ZFO09BS0FnQjtPQUtENHhGO09BQ0FDO09BRUNDO09BU0Q5dUY7T0FJQWM7T0FJQTdFO09BVUE4eUY7T0FJQUM7T0FJQ0M7T0FVRGh2RjtPQUNBYztPQUVBbXVGO09BSUFDO09BSUNDO09BUURqd0Y7T0FDQXFCO09BRUM3RTtPQUtBMkI7T0FLRCt4RjtPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQU1EeHdGO09BQ0FxQjtPQUVDbEY7T0FLQWlDO09BS0RzeUY7T0FDQUM7T0FDQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMENEM2xGO09BWUFwVjtPQUNBRTtPQU9BODZGO09BQ0FDO09BQ0ExZ0U7T0FJQXA2QjtJQXZYQSs2RjtJQUNBQztJQUVBQztJQUlBQztJQUlDQztJQVVEQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQU1BQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVDQztJQUdBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVBQztJQVVBQztJQUlBQztJQUlDQztJQVNEQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUVDQztJQVNEQztJQUlBQztJQUlBQztJQVVBQztJQUlBQztJQUlDQztJQVVEQztJQUNBQztJQUVBQztJQUlBQztJQUlDQztJQVFEQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUNBQztJQUNBQztJQUNDQztJQU1EQztJQUNBQztJQUVDQztJQUtBQztJQUtEQztJQUNBQztJQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQ0R6aEc7SUFZQThYO0lBQ0FFO0lBT0FwWDtJQUNBRTtJQUNBNGdHO0lBSUFDOzs7O0dBZ0JHOzs7Ozs7T0FqaUJMcHBHO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEO09BQUFEOzs7O09BMEpFd29HO09BQ0FDO09BRUFDO09BSUFDO09BSUNDO09BVURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BTUFDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BR0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUFDO09BVUFDO09BSUFDO09BSUNDO09BU0RDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BRUNDO09BU0RDO09BSUFDO09BSUFDO09BVUFDO09BSUFDO09BSUNDO09BVURDO09BQ0FDO09BRUFDO09BSUFDO09BSUNDO09BUURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBDRHpoRztPQVlBOFg7T0FDQUU7T0FPQXBYO09BQ0FFO09BQ0E0Z0c7T0FJQUM7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiogUHJpbWl0aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGVxdWFsIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggPSBDYW1sLm1heFxubGV0IG1pbiA9IENhbWwubWluXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAoKiBUaGVzZSBtb2R1bGVzIGFyZSByZWRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0KSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIENhbWwucmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG4oKiBSZXNodWZmbGUgW0NhbWxdIHNvIHRoYXQgd2UgY2hvb3NlIHRoZSBtb2R1bGVzIHVzaW5nIGxhYmVscyB3aGVuIGF2YWlsYWJsZS4gKilcbm1vZHVsZSBDYW1sID0gc3RydWN0XG5cbiAgaW5jbHVkZSBDYW1sXG5cbiAgbW9kdWxlIEFyZyA9IENhbWwuQXJnICgqKiBAY2Fub25pY2FsIENhbWwuQXJnICopXG5cbiAgbW9kdWxlIEFycmF5ID0gQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKilcblxuICBtb2R1bGUgQm9vbCA9IENhbWwuQm9vbCAoKiogQGNhbm9uaWNhbCBDYW1sLkJvb2wgKilcblxuICBtb2R1bGUgQnVmZmVyID0gQ2FtbC5CdWZmZXIgKCoqIEBjYW5vbmljYWwgQ2FtbC5CdWZmZXIgKilcblxuICBtb2R1bGUgQnl0ZXMgPSBDYW1sLlN0ZExhYmVscy5CeXRlcyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5CeXRlcyAqKVxuXG4gIG1vZHVsZSBDaGFyID0gQ2FtbC5DaGFyICgqKiBAY2Fub25pY2FsIENhbWwuQ2hhciAqKVxuXG4gIG1vZHVsZSBFcGhlbWVyb24gPSBDYW1sLkVwaGVtZXJvbiAoKiogQGNhbm9uaWNhbCBDYW1sLkVwaGVtZXJvbiAqKVxuXG4gIG1vZHVsZSBGbG9hdCA9IENhbWwuRmxvYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5GbG9hdCAqKVxuXG4gIG1vZHVsZSBGb3JtYXQgPSBDYW1sLkZvcm1hdCAoKiogQGNhbm9uaWNhbCBDYW1sLkZvcm1hdCAqKVxuXG4gIG1vZHVsZSBGdW4gPSBDYW1sLkZ1biAoKiogQGNhbm9uaWNhbCBDYW1sLkZ1biAqKVxuXG4gIG1vZHVsZSBHYyA9IENhbWwuR2MgKCoqIEBjYW5vbmljYWwgQ2FtbC5HYyAqKVxuXG4gIG1vZHVsZSBIYXNodGJsID0gQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKilcblxuICBtb2R1bGUgSW50MzIgPSBDYW1sLkludDMyICgqKiBAY2Fub25pY2FsIENhbWwuSW50MzIgKilcblxuICBtb2R1bGUgSW50ID0gQ2FtbC5JbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5JbnQgKilcblxuICBtb2R1bGUgSW50NjQgPSBDYW1sLkludDY0ICgqKiBAY2Fub25pY2FsIENhbWwuSW50NjQgKilcblxuICBtb2R1bGUgTGF6eSA9IENhbWwuTGF6eSAoKiogQGNhbm9uaWNhbCBDYW1sLkxhenkgKilcblxuICBtb2R1bGUgTGV4aW5nID0gQ2FtbC5MZXhpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5MZXhpbmcgKilcblxuICBtb2R1bGUgTGlzdCA9IENhbWwuU3RkTGFiZWxzLkxpc3QgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuTGlzdCAqKVxuXG4gIG1vZHVsZSBNYXAgPSBDYW1sLk1vcmVMYWJlbHMuTWFwICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5NYXAgKilcblxuICBtb2R1bGUgTmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5OYXRpdmVpbnQgKilcblxuICBtb2R1bGUgT2JqID0gQ2FtbC5PYmogKCoqIEBjYW5vbmljYWwgQ2FtbC5PYmogKilcblxuICBtb2R1bGUgT3B0aW9uID0gQ2FtbC5PcHRpb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5PcHRpb24gKilcblxuICBtb2R1bGUgUGFyc2luZyA9IENhbWwuUGFyc2luZyAoKiogQGNhbm9uaWNhbCBDYW1sLlBhcnNpbmcgKilcblxuICBtb2R1bGUgUHJpbnRleGMgPSBDYW1sLlByaW50ZXhjICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRleGMgKilcblxuICBtb2R1bGUgUHJpbnRmID0gQ2FtbC5QcmludGYgKCoqIEBjYW5vbmljYWwgQ2FtbC5QcmludGYgKilcblxuICBtb2R1bGUgUXVldWUgPSBDYW1sLlF1ZXVlICgqKiBAY2Fub25pY2FsIENhbWwuUXVldWUgKilcblxuICBtb2R1bGUgUmFuZG9tID0gQ2FtbC5SYW5kb20gKCoqIEBjYW5vbmljYWwgQ2FtbC5SYW5kb20gKilcblxuICBtb2R1bGUgUmVzdWx0ID0gQ2FtbC5SZXN1bHQgKCoqIEBjYW5vbmljYWwgQ2FtbC5SZXN1bHQgKilcblxuICBtb2R1bGUgU2NhbmYgPSBDYW1sLlNjYW5mICgqKiBAY2Fub25pY2FsIENhbWwuU2NhbmYgKilcblxuICBtb2R1bGUgU2VxID0gQ2FtbC5TZXEgKCoqIEBjYW5vbmljYWwgQ2FtbC5TZXEgKilcblxuICBtb2R1bGUgU2V0ID0gQ2FtbC5Nb3JlTGFiZWxzLlNldCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuU2V0ICopXG5cbiAgbW9kdWxlIFN0YWNrID0gQ2FtbC5TdGFjayAoKiogQGNhbm9uaWNhbCBDYW1sLlN0YWNrICopXG5cbiAgbW9kdWxlIFN0cmluZyA9IENhbWwuU3RkTGFiZWxzLlN0cmluZyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKilcblxuICBtb2R1bGUgU3lzID0gQ2FtbC5TeXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TeXMgKilcblxuICBtb2R1bGUgVWNoYXIgPSBDYW1sLlVjaGFyICgqKiBAY2Fub25pY2FsIENhbWwuVWNoYXIgKilcblxuICBtb2R1bGUgVW5pdCA9IENhbWwuVW5pdCAoKiogQGNhbm9uaWNhbCBDYW1sLlVuaXQgKilcblxuICBleGNlcHRpb24gTm90X2ZvdW5kID0gQ2FtbC5Ob3RfZm91bmRcbmVuZFxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4oKiBXZSB1c2UgW09iai5tYWdpY10gaGVyZSBhcyBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZ2VuZXJhdGUgYSBjb25kaXRpb25hbCBqdW1wIGFuZCB0aGVcbiAgIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2UgaXMgbm90aWNlYWJsZS4gKilcbmxldCBib29sX3RvX2ludCAoeCA6IGJvb2wpIDogaW50ID0gQ2FtbC5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5ICopXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgKCAhPSApID0gQ2FtbC4oICE9IClcbmxldCAoICogKSA9IENhbWwuKCAqIClcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxubGV0ICggKi4gKSA9IENhbWwuKCAqLiApXG5sZXQgKCArICkgPSBDYW1sLiggKyApXG5sZXQgKCArLiApID0gQ2FtbC4oICsuIClcbmxldCAoIC0gKSA9IENhbWwuKCAtIClcbmxldCAoIC0uICkgPSBDYW1sLiggLS4gKVxubGV0ICggLyApID0gQ2FtbC4oIC8gKVxubGV0ICggLy4gKSA9IENhbWwuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWF4ICh4IDogaW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGludCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBDYW1sLkludDMyLnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYm9vbCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBib29sKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogY2hhcikgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBjaGFyKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCBpIHggPSBDYW1sLlVjaGFyLnRvX2ludCB4XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIChpIHgpIChpIHkpXG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5kZXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuICBsZXQgbWF4ICh4IDogQ2FtbC5VY2hhci50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogZmxvYXQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogZmxvYXQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogc3RyaW5nKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogc3RyaW5nKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHN0cmluZykgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIFRoaXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBjYW4gc3BlY2lhbGl6ZSBpdCBhcyBhXG4gICBkaXJlY3Qgc2V0IG9yIGNhbWxfbW9kaWZ5ICopXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBvdGhlcndpc2UgdGhlIGNvbXBpbGVyIHdvbid0IHVuYm94XG4gICByZWZlcmVuY2VzICopXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5cbmxldCAoIEAgKSA9IENhbWwuKCBAIClcbmxldCAoIF4gKSA9IENhbWwuKCBeIClcbmxldCAoIH4tICkgPSBDYW1sLiggfi0gKVxubGV0ICggfi0uICkgPSBDYW1sLiggfi0uIClcbmxldCAoIGFzciApID0gQ2FtbC4oIGFzciApXG5sZXQgKCBsYW5kICkgPSBDYW1sLiggbGFuZCApXG5sZXQgbG5vdCA9IENhbWwubG5vdFxubGV0ICggbG9yICkgPSBDYW1sLiggbG9yIClcbmxldCAoIGxzbCApID0gQ2FtbC4oIGxzbCApXG5sZXQgKCBsc3IgKSA9IENhbWwuKCBsc3IgKVxubGV0ICggbHhvciApID0gQ2FtbC4oIGx4b3IgKVxubGV0ICggbW9kICkgPSBDYW1sLiggbW9kIClcbmxldCBhYnMgPSBDYW1sLmFic1xubGV0IGZhaWx3aXRoID0gQ2FtbC5mYWlsd2l0aFxubGV0IGZzdCA9IENhbWwuZnN0XG5sZXQgaW52YWxpZF9hcmcgPSBDYW1sLmludmFsaWRfYXJnXG5sZXQgc25kID0gQ2FtbC5zbmRcblxuKCogW3JhaXNlXSBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIGFzIHRoZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHJlcGxhY2VzXG4gICAnJXJhaXNlJyBieSAnJXJlcmFpc2UnIHdoZW4gYXBwcm9wcmlhdGUuICopXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG5sZXQgcGh5c19lcXVhbCA9IENhbWwuKCA9PSApXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IGluY3IgPSBDYW1sLmluY3JcblxuKCogdXNlZCBieSBzZXhwX2NvbnYsIHdoaWNoIGZsb2F0MCBkZXBlbmRzIG9uIHRocm91Z2ggb3B0aW9uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gQ2FtbC5mbG9hdF9vZl9zdHJpbmdcblxuKCogW2FtX3Rlc3RpbmddIGlzIHVzZWQgaW4gYSBmZXcgcGxhY2VzIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSB3aGVuIGluIHRlc3RpbmcgbW9kZSwgc3VjaFxuICAgYXMgaW4gW3JhbmRvbS5tbF0uICBbYW1fdGVzdGluZ10gaXMgaW1wbGVtZW50ZWQgdXNpbmcgW0Jhc2VfYW1fdGVzdGluZ10sIGEgd2VhayBDL2pzXG4gICBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFtmYWxzZV0sIGJ1dCB3aGVuIGxpbmtpbmcgYW4gaW5saW5lLXRlc3QtcnVubmVyIGV4ZWN1dGFibGUsIGlzXG4gICBvdmVycmlkZGVuIGJ5IGFub3RoZXIgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbdHJ1ZV0uICopXG5leHRlcm5hbCBhbV90ZXN0aW5nIDogdW5pdCAtPiBib29sID0gXCJCYXNlX2FtX3Rlc3RpbmdcIlxuXG5sZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmcgKClcbiIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgQ2FtbC5QcmludGZcblxuKCoqIGZhaWx3aXRoLCBpbnZhbGlkX2FyZywgYW5kIGV4aXQgYWNjZXB0aW5nIHByaW50ZidzIGZvcm1hdC4gKilcblxubGV0IGZhaWx3aXRoZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG5sZXQgaW52YWxpZF9hcmdmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbiIsIigqIFtTeXMwXSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW0NhbWwuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN5c10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzeXMubWxcbiAgIHNob3VsZCB1c2UgW0NhbWwuU3lzXS4gW1N5czBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlXG4gICBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHRoZXNlXG4gICBmdW5jdGlvbnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN5c10gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIFN5cyA9IFN5czBdLiAgRGVmaW5pbmcgW21vZHVsZSBTeXMgPSBTeXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN5c10uICopXG5cbm9wZW4hIEltcG9ydDBcblxudHlwZSBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGVcbmxldCBpbnRlcmFjdGl2ZSA9IENhbWwuU3lzLmludGVyYWN0aXZlXG5sZXQgb3NfdHlwZSA9IENhbWwuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gQ2FtbC5TeXMudW5peFxubGV0IHdpbjMyID0gQ2FtbC5TeXMud2luMzJcbmxldCBjeWd3aW4gPSBDYW1sLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IENhbWwuU3lzLndvcmRfc2l6ZVxubGV0IGludF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy5pbnRfc2l6ZVxubGV0IGJpZ19lbmRpYW4gPSBDYW1sLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBDYW1sLlN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IG1heF9hcnJheV9sZW5ndGggPSBDYW1sLlN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5sZXQgcnVudGltZV92YXJpYW50ID0gQ2FtbC5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gQ2FtbC5TeXMucnVudGltZV9wYXJhbWV0ZXJzXG5sZXQgYXJndiA9IENhbWwuU3lzLmFyZ3ZcbmxldCBnZXRfYXJndiAoKSA9IENhbWwuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gQ2FtbC5TeXMub2NhbWxfdmVyc2lvblxubGV0IGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzID0gQ2FtbC5TeXMuZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcbmxldCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgPSBDYW1sLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IENhbWwuTm90X2ZvdW5kIC0+XG4gICAgUHJpbnRmLmZhaWx3aXRoZiBcIlN5cy5nZXRlbnZfZXhuOiBlbnZpcm9ubWVudCB2YXJpYWJsZSAlcyBpcyBub3Qgc2V0XCIgdmFyICgpXG47O1xuXG5sZXQgZ2V0ZW52IHZhciA9XG4gIG1hdGNoIENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcblxuZXhjZXB0aW9uIEJyZWFrID0gQ2FtbC5TeXMuQnJlYWtcbiIsIigqIFtBcnJheTBdIGRlZmluZXMgYXJyYXkgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zXG4gICBvZiBbQ2FtbC5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuQXJyYXldXG4gICB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGFycmF5MC5tbCBzaG91bGQgdXNlIFtDYW1sLkFycmF5XS5cbiAgIFtBcnJheTBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGFycmF5cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQXJyYXldIGluIGJ1aWxkIG9yZGVyIHNob3VsZFxuICAgZG8gW21vZHVsZSBBcnJheSA9IEFycmF5MF0uICBUaGlzIGluY2x1ZGVzIHVzZXMgb2Ygc3Vic2NyaXB0IHN5bnRheCAoW3guKGkpXSwgW3guKGkpIDwtXG4gICBlXSksIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbQXJyYXkuZ2V0XSBhbmQgW0FycmF5LnNldF0uXG4gICBEZWZpbmluZyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwIGZyb21cbiAgIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkFycmF5XS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCA6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuICBleHRlcm5hbCBnZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIHNldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOidhIGFycmF5XG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6J2EgYXJyYXlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5lbmRcblxuaW5jbHVkZSBBcnJheVxuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZSBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZSB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW4gPVxuICB0cnkgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgbGVuIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGFwcGVuZCA9IENhbWwuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IENhbWwuQXJyYXkuYmxpdFxubGV0IGNvbmNhdCA9IENhbWwuQXJyYXkuY29uY2F0XG5sZXQgY29weSA9IENhbWwuQXJyYXkuY29weVxubGV0IGZpbGwgPSBDYW1sLkFycmF5LmZpbGxcbmxldCBpbml0ID0gQ2FtbC5BcnJheS5pbml0XG5sZXQgbWFrZV9tYXRyaXggPSBDYW1sLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IENhbWwuQXJyYXkub2ZfbGlzdFxubGV0IHN1YiA9IENhbWwuQXJyYXkuc3ViXG5sZXQgdG9fbGlzdCA9IENhbWwuQXJyYXkudG9fbGlzdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkFycmF5LmZvbGRfbGVmdCB0IH5pbml0IH5mXG5sZXQgZm9sZF9yaWdodCB0IH5mIH5pbml0ID0gQ2FtbC5BcnJheS5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXIgdCB+ZlxubGV0IGl0ZXJpIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXJpIHQgfmZcbmxldCBtYXAgdCB+ZiA9IENhbWwuQXJyYXkubWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBDYW1sLkFycmF5Lm1hcGkgdCB+ZlxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBDYW1sLkFycmF5LnN0YWJsZV9zb3J0IHQgfmNtcDpjb21wYXJlXG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGVsdF9pID0gdC4oaSkgaW5cbiAgbGV0IGVsdF9qID0gdC4oaikgaW5cbiAgdW5zYWZlX3NldCB0IGkgZWx0X2o7XG4gIHVuc2FmZV9zZXQgdCBqIGVsdF9pXG47O1xuIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5DaGFyXS4gIFtDaGFyMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkNoYXJdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGNoYXIwLm1sIHNob3VsZCB1c2UgW0NhbWwuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IENhbWwuQ2hhci5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gQ2FtbC5DaGFyLmxvd2VyY2FzZV9hc2NpaVxubGV0IHRvX2ludCA9IENhbWwuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IENhbWwuQ2hhci51bnNhZmVfY2hyXG5sZXQgdXBwZXJjYXNlID0gQ2FtbC5DaGFyLnVwcGVyY2FzZV9hc2NpaVxuXG4oKiBXZSB1c2Ugb3VyIG93biByYW5nZSB0ZXN0IHdoZW4gY29udmVydGluZyBpbnRlZ2VycyB0byBjaGFycyByYXRoZXIgdGhhblxuICAgY2FsbGluZyBbQ2FtbC5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiIsIigqIFtJbnQwXSBkZWZpbmVzIGludGVnZXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbF0uIFtJbnQwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlXG4gICBwYXJ0IG9mIFtDYW1sXSB0aGF0IFtCYXNlXSB1c2VzIGZvciBpbnRlZ2VycyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gaW50MC5tbCBzaG91bGQgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0aHJvdWdoIFtDYW1sXS4gW0ludDBdIGhhc1xuICAgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgaW50cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuSW50XSBpbiBidWlsZFxuICAgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgSW50ICA9IEludDBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgSW50ID0gSW50MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcFxuICAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5JbnRdLiAqKVxuXG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgb2Zfc3RyaW5nID0gQ2FtbC5pbnRfb2Zfc3RyaW5nXG5sZXQgdG9fZmxvYXQgPSBDYW1sLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0ID0gQ2FtbC5pbnRfb2ZfZmxvYXRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBzdWNjID0gQ2FtbC5zdWNjXG4iLCIoKiBbTGlzdDBdIGRlZmluZXMgbGlzdCBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtDYW1sLkxpc3RdLiAgW0xpc3QwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbQ2FtbC5MaXN0XS5cbiAgIFtMaXN0MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgbGlzdHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkxpc3RdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBMaXN0ID0gTGlzdDBdLiAgRGVmaW5pbmcgW21vZHVsZSBMaXN0ID0gTGlzdDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuTGlzdF0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGhkX2V4biA9IENhbWwuTGlzdC5oZFxubGV0IGxlbmd0aCA9IENhbWwuTGlzdC5sZW5ndGhcbmxldCByZXZfYXBwZW5kID0gQ2FtbC5MaXN0LnJldl9hcHBlbmRcbmxldCB0bF9leG4gPSBDYW1sLkxpc3QudGxcbmxldCB1bnppcCA9IENhbWwuTGlzdC5zcGxpdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBleGlzdHMgdCB+ZiA9IENhbWwuTGlzdC5leGlzdHMgdCB+ZlxubGV0IGV4aXN0czJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZXhpc3RzMiBsMSBsMiB+ZlxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQgdCB+ZiB+aW5pdFxubGV0IGZvbGQyX29rIGwxIGwyIH5pbml0IH5mID0gQ2FtbC5MaXN0LmZvbGRfbGVmdDIgbDEgbDIgfmluaXQgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbCB0IH5mXG5sZXQgZm9yX2FsbDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbDIgbDEgbDIgfmZcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkxpc3QuaXRlciB0IH5mXG5sZXQgaXRlcjJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuaXRlcjIgbDEgbDIgfmZcbmxldCBub250YWlsX21hcCB0IH5mID0gQ2FtbC5MaXN0Lm1hcCB0IH5mXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBDYW1sLkxpc3QubWFwaSB0IH5mXG5sZXQgcGFydGl0aW9uIHQgfmYgPSBDYW1sLkxpc3QucGFydGl0aW9uIHQgfmZcbmxldCByZXZfbWFwIHQgfmYgPSBDYW1sLkxpc3QucmV2X21hcCB0IH5mXG5sZXQgcmV2X21hcDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QucmV2X21hcDIgbDEgbDIgfmZcbmxldCBzb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc29ydCBsIH5jbXA6Y29tcGFyZVxubGV0IHN0YWJsZV9zb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc3RhYmxlX3NvcnQgbCB+Y21wOmNvbXBhcmVcblxubGV0IHJldiA9IGZ1bmN0aW9uXG4gIHwgKFtdIHwgWyBfIF0pIGFzIHJlcyAtPiByZXNcbiAgfCB4IDo6IHkgOjogcmVzdCAtPiByZXZfYXBwZW5kIHJlc3QgWyB5OyB4IF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0IGwgfmYgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbClcbjs7XG4iLCIoKlxuICAgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHRvIHRoZSBydW50aW1lIHN1cHBvcnQgZm9yIFtwcHhfaGFzaF0uXG5cbiAgIFRoZSBbcHB4X2hhc2hdIHN5bnRheCBleHRlbnNpb24gc3VwcG9ydHM6IFtAQGRlcml2aW5nIGhhc2hdIGFuZCBbJWhhc2hfZm9sZDogVFlQRV0gYW5kXG4gICBbJWhhc2g6IFRZUEVdXG5cbiAgIEZvciB0eXBlIFt0XSBhIGZ1bmN0aW9uIFtoYXNoX2ZvbGRfdF0gb2YgdHlwZSBbSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGVdIGlzXG4gICBnZW5lcmF0ZWQuXG5cbiAgIFRoZSBnZW5lcmF0ZWQgW2hhc2hfZm9sZF88VD5dIGZ1bmN0aW9uIGlzIGNvbXBvc2l0aW9uYWwsIGZvbGxvd2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgdHlwZTsgYWxsb3dpbmcgdXNlciBvdmVycmlkZXMgYXQgZXZlcnkgbGV2ZWwuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gb2NhbWwncyBidWlsdGluXG4gICBwb2x5bW9ycGhpYyBoYXNoaW5nIFtIYXNodGJsLmhhc2hdIHdoaWNoIGlnbm9yZXMgdXNlciBvdmVycmlkZXMuXG5cbiAgIFRoZSBnZW5lcmF0b3IgYWxzbyBwcm92aWRlcyBhIGRpcmVjdCBoYXNoLWZ1bmN0aW9uIFtoYXNoXSAobmFtZWQgW2hhc2hfPFQ+XSB3aGVuIDxUPiAhPVxuICAgXCJ0XCIpIG9mIHR5cGU6IFt0IC0+IEhhc2guaGFzaF92YWx1ZV0uXG5cbiAgIFRoZSBmb2xkaW5nIGhhc2ggZnVuY3Rpb24gY2FuIGJlIGFjY2Vzc2VkIGFzIFslaGFzaF9mb2xkOiBUWVBFXVxuICAgVGhlIGRpcmVjdCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2g6IFRZUEVdXG4qKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEhhc2hfaW50ZlxuXG4oKiogQnVpbHRpbiBmb2xkaW5nLXN0eWxlIGhhc2ggZnVuY3Rpb25zLCBhYnN0cmFjdGVkIG92ZXIgW0hhc2hfaW50Zi5TXSAqKVxubW9kdWxlIEZvbGRpbmcgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuQnVpbHRpbl9pbnRmXG4gIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgaGFzaF9mb2xkX3VuaXQgcyAoKSA9IHNcbiAgbGV0IGhhc2hfZm9sZF9pbnQgPSBIYXNoLmZvbGRfaW50XG4gIGxldCBoYXNoX2ZvbGRfaW50NjQgPSBIYXNoLmZvbGRfaW50NjRcbiAgbGV0IGhhc2hfZm9sZF9mbG9hdCA9IEhhc2guZm9sZF9mbG9hdFxuICBsZXQgaGFzaF9mb2xkX3N0cmluZyA9IEhhc2guZm9sZF9zdHJpbmdcbiAgbGV0IGFzX2ludCBmIHMgeCA9IGhhc2hfZm9sZF9pbnQgcyAoZiB4KVxuXG4gICgqIFRoaXMgaWdub3JlcyB0aGUgc2lnbiBiaXQgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIHVubGlrZWx5IHRvIGxlYWQgdG9cbiAgICAgZnJlcXVlbnQgY29sbGlzaW9ucyAobWluX3ZhbHVlIGNvbGxpZGluZyB3aXRoIDAgaXMgdGhlIG1vc3QgbGlrZWx5IG9uZSkuICAqKVxuICBsZXQgaGFzaF9mb2xkX2ludDMyID0gYXNfaW50IENhbWwuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoQ2FtbC5MYXp5LmZvcmNlIHgpXG4gIGxldCBoYXNoX2ZvbGRfcmVmX2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzICF4XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gcyBhcnJheSBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIGFycmF5XG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZSA9IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSBpblxuICAgICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIGUpIGFycmF5IChpICsgMSkpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9hcnJheV9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyBhcnJheSA9XG4gICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pXG4gICAgICAoKiBbbGVuZ3RoXSBtdXN0IGJlIGluY29ycG9yYXRlZCBmb3IgYXJyYXlzLCBhcyBpdCBpcyBmb3IgbGlzdHMuIFNlZSBjb21tZW50IGFib3ZlICopXG4gICAgICBoYXNoX2ZvbGRfZWxlbVxuICAgICAgKGhhc2hfZm9sZF9pbnQgcyAoQXJyYXkubGVuZ3RoIGFycmF5KSlcbiAgICAgIGFycmF5XG4gICAgICAwXG4gIDs7XG5cbiAgKCogdGhlIGR1cGxpY2F0aW9uIGhlcmUgaXMgYmVjYXVzZSB3ZSB0aGlua1xuICAgICBvY2FtbCBjYW4ndCBlbGltaW5hdGUgaW5kaXJlY3QgZnVuY3Rpb24gY2FsbHMgb3RoZXJ3aXNlLiAqKVxuICBsZXQgaGFzaF9uYXRpdmVpbnQgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX25hdGl2ZWludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfaW50NjQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQ2NCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludDMyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50MzIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9jaGFyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfY2hhciAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2Jvb2wgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9ib29sIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcblxuICBsZXQgaGFzaF9zdHJpbmcgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3N0cmluZyAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZmxvYXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9mbG9hdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX3VuaXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF91bml0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbmVuZFxuXG5tb2R1bGUgRiAoSGFzaCA6IEhhc2hfaW50Zi5TKSA6XG4gIEhhc2hfaW50Zi5GdWxsXG4gIHdpdGggdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIHNlZWQgPSBIYXNoLnNlZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBvZl9mb2xkIGhhc2hfZm9sZF90IHQgPSBnZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3QgKGNyZWF0ZSAoKSkgdClcblxuICBtb2R1bGUgQnVpbHRpbiA9IEZvbGRpbmcgKEhhc2gpXG5cbiAgbGV0IHJ1biA/c2VlZCBmb2xkZXIgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChIYXNoLnJlc2V0ID9zZWVkIChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxoYXNoIDogc2lnXG4gIGluY2x1ZGVcbiAgICBIYXNoX2ludGYuU1xuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnN0YXRlXG4gICAgICgqIFdlIGdpdmUgYSBjb25jcmV0ZSB0eXBlIGZvciBbc3RhdGVdLCBhbGJlaXQgb25seSBwYXJ0aWFsbHkgZXhwb3NlZCAoc2VlXG4gICAgICAgIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzKSwgc28gdGhhdCBpdCB1bmlmaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBpbiBbQmFzZV9ib290XSxcbiAgICAgICAgYW5kIHRvIGFsbG93IG9wdGltaXphdGlvbnMgZm9yIHRoZSBpbW1lZGlhdGUgdHlwZS4gKilcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnNlZWRcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0IDogc3RhdGUgLT4gaW50NjQgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfaW50IDogc3RhdGUgLT4gaW50IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9mbG9hdCA6IHN0YXRlIC0+IGZsb2F0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX3N0cmluZyA6IHN0YXRlIC0+IHN0cmluZyAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGdldF9oYXNoX3ZhbHVlIDogc3RhdGUgLT4gaGFzaF92YWx1ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcIlxuICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCJCYXNlX2hhc2hfZG91YmxlXCIgW0BAbm9hbGxvY11cblxuICAgIGxldCBoYXNoX3VuaXQgKCkgPSAwXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgVFxuIiwib3BlbiBJbXBvcnQwXG5cbmxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG5leHRlcm5hbCBwb2x5bW9ycGhpY19jb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBwb2x5bW9ycGhpY19lcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG5cbm1vZHVsZSBDb21wYXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjb21wYXJlIDogdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2EgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAoJ2EsICdiKSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAnYyBjb21wYXJlIC0+ICgnYSwgJ2IsICdjKSB0IGNvbXBhcmVcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnVpbHRpbiA9IHN0cnVjdFxuICBsZXQgY29tcGFyZV9ib29sIDogYm9vbCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfZmxvYXQgOiBmbG9hdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludCA6IGludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfc3RyaW5nIDogc3RyaW5nIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfdW5pdCA6IHVuaXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgaWYgcGh5c19lcXVhbCBhIGJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgICAgaWYgcmV0IDw+IDBcbiAgICAgIHRoZW4gcmV0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgICAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAwKSlcbiAgOztcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdCBhIGJcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9lbHQgIWEgIWJcbiAgbGV0IGVxdWFsX2Jvb2wgOiBib29sIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfY2hhciA6IGNoYXIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMiA6IGludDMyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjQgOiBpbnQ2NCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA6IG5hdGl2ZWludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZyA6IHN0cmluZyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXQgOiB1bml0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gICgqIFtQb2x5LmVxdWFsXSBpcyBJRUVFIGNvbXBsaWFudCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudCBoZXJlLiAqKVxuICBsZXQgZXF1YWxfZmxvYXQgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0IHggeSkgMFxuXG4gIGxldCBlcXVhbF9hcnJheSBlcXVhbF9lbHQgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8XG4gICAgbGV0IGxlbl9hID0gQXJyYXkwLmxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgZXF1YWwgbGVuX2EgbGVuX2JcbiAgICAmJlxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGkgPSBsZW5fYVxuICAgICAgfHxcbiAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgZXF1YWxfZWx0IGwgciAmJiBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdCBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCBbXSwgXyB8IF8sIFtdIC0+IGZhbHNlXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+IGVxdWFsX2VsdCB4IHkgJiYgZXF1YWxfbGlzdCBlcXVhbF9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGVxdWFsX2VsdCBhIGJcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIGVxdWFsX2VsdCBhIGIgPSBlcXVhbF9lbHQgIWEgIWJcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIGZvciB1c2UgYnkgcHB4X2hhc2gsIGFuZCBpcyB0aHVzIG5vdCBpbiB0aGUgaW50ZXJmYWNlIG9mIEJhc2UuICopXG5tb2R1bGUgU3RkID0gc3RydWN0XG4gIG1vZHVsZSBIYXNoID0gSGFzaCAoKiogQGNhbm9uaWNhbCBCYXNlLkhhc2ggKilcbmVuZFxuXG50eXBlICdhIGhhc2hfZm9sZCA9IFN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFN0ZC5IYXNoLnN0YXRlXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiB0IGhhc2hfZm9sZFxuICAgIHZhbCBoYXNoIDogdCAtPiBTdGQuSGFzaC5oYXNoX3ZhbHVlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2EgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBoYXNoX2ZvbGRfdCA6ICdhIGhhc2hfZm9sZCAtPiAnYiBoYXNoX2ZvbGQgLT4gKCdhLCAnYikgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3RcbiAgICAgIDogICdhIGhhc2hfZm9sZFxuICAgICAgLT4gJ2IgaGFzaF9mb2xkXG4gICAgICAtPiAnYyBoYXNoX2ZvbGRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSB0IGhhc2hfZm9sZFxuICBlbmRcbmVuZFxuIiwib3BlbiBIYXNoLkJ1aWx0aW5cbm9wZW4gUHB4X2NvbXBhcmVfbGliLkJ1aWx0aW5cbmluY2x1ZGUgU2V4cGxpYjAuU2V4cFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPSBTZXhwbGliMC5TZXhwLnQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG5sZXQgcmVjIGNvbXBhcmUgPVxuICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZyBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgIHwgVzY0IC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlc2NFwiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBudW1fYml0cyA9IGZ1bmN0aW9uXG4gIHwgVzMyIC0+IDMyXG4gIHwgVzY0IC0+IDY0XG47O1xuXG5sZXQgd29yZF9zaXplID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZV9pbl9iaXRzIHdpdGhcbiAgfCAzMiAtPiBXMzJcbiAgfCA2NCAtPiBXNjRcbiAgfCBfIC0+IGZhaWx3aXRoIFwidW5rbm93biB3b3JkIHNpemVcIlxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgciA9IHJlZiBbIFwiQmFzZS5TZXhwLnBwX2h1bVwiIF1cbmxldCBhbGwgKCkgPSAhclxubGV0IHJlZ2lzdGVyIHAgPSByIDo9IHAgOjogIXJcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgcHAgOiBGb3JtYXR0ZXIudCAtPiB0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXJfcHAgKE0gOiBzaWdcbiAgICBpbmNsdWRlIFNcblxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICBsZXQgKCkgPSByZWdpc3RlciAoTS5tb2R1bGVfbmFtZSBeIFwiLnBwXCIpXG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyIChNIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG4gIFJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIGxldCBwcCBmb3JtYXR0ZXIgdCA9IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgKE0udG9fc3RyaW5nIHQpXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBDYW1sLmV4aXRcblxuZXhjZXB0aW9uIEZpbmFsbHkgb2YgdCAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGaW5hbGx5XSAoZnVuY3Rpb25cbiAgICB8IEZpbmFsbHkgKGFyZzBfXzAwMV8sIGFyZzFfXzAwMl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDAzXyA9IHNleHBfb2ZfdCBhcmcwX18wMDFfXG4gICAgICBhbmQgcmVzMV9fMDA0XyA9IHNleHBfb2ZfdCBhcmcxX18wMDJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuRmluYWxseVwiOyByZXMwX18wMDNfOyByZXMxX18wMDRfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFJlcmFpc2VkIG9mIHN0cmluZyAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBSZXJhaXNlZF0gKGZ1bmN0aW9uXG4gICAgfCBSZXJhaXNlZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgIGxldCByZXMwX18wMDdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA1X1xuICAgICAgYW5kIHJlczFfXzAwOF8gPSBzZXhwX29mX3QgYXJnMV9fMDA2XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLlJlcmFpc2VkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gU2V4cCBvZiBTZXhwLnRcblxuKCogV2UgaW5zdGFsbCBhIGN1c3RvbSBleG4tY29udmVydGVyIHJhdGhlciB0aGFuIHVzZTpcblxuICAge1tcbiAgICAgZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuICAgICAoKiAuLi4gKilcbiAgICAgW0BAQGVuZF1cbiAgIF19XG5cbiAgIHRvIGVsaW1pbmF0ZSB0aGUgZXh0cmEgd3JhcHBpbmcgb2YgWyhTZXhwIC4uLildLiAqKVxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNleHBdIChmdW5jdGlvblxuICAgIHwgU2V4cCB0IC0+IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBTZXhwIHNleHBcblxubGV0IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIHQgYmFja3RyYWNlID1cbiAgQ2FtbC5QcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB0IGJhY2t0cmFjZVxuOztcblxuZXh0ZXJuYWwgaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCA6IHQgLT4gYm9vbCA9IFwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG5cIlxuXG5sZXQgcmVyYWlzZSBleG4gc3RyID1cbiAgbGV0IGV4bicgPSBSZXJhaXNlZCAoc3RyLCBleG4pIGluXG4gIGlmIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuXG4gIHRoZW4gKFxuICAgIGxldCBidCA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgKG1hdGNoIGZpbmFsbHkgeCB3aXRoXG4gICAgIHwgKCkgLT4gcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuIGJ0XG4gICAgIHwgZXhjZXB0aW9uIGZpbmFsX2V4biAtPlxuICAgICAgICgqIFVuZm9ydHVuYXRlbHksIHRoZSBiYWNrdHJhY2Ugb2YgdGhlIFtmaW5hbF9leG5dIGlzIGRpc2NhcmRlZCBoZXJlLiAqKVxuICAgICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChGaW5hbGx5IChleG4sIGZpbmFsX2V4bikpIGJ0KVxuOztcblxubGV0IHByb3RlY3QgfmYgfmZpbmFsbHkgPSBwcm90ZWN0eCB+ZiAoKSB+ZmluYWxseVxuXG5sZXQgZG9lc19yYWlzZSAodHlwZSBhKSAoZiA6IHVuaXQgLT4gYSkgPVxuICB0cnlcbiAgICBpZ25vcmUgKGYgKCkgOiBhKTtcbiAgICBmYWxzZVxuICB3aXRoXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBleG5cblxuICAgIGxldCBwcCBwcGYgdCA9XG4gICAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgdCB3aXRoXG4gICAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgICAgfCBOb25lIC0+IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKENhbWwuUHJpbnRleGMudG9fc3RyaW5nIHQpXG4gICAgOztcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuICBlbmQpXG5cbmxldCBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSA9XG4gIENhbWwuRm9ybWF0LmVwcmludGYgXCJAWzwyPlVuY2F1Z2h0IGV4Y2VwdGlvbjpAXFxuQFxcbkBbJWFAXUBdQFxcbkAuXCIgcHAgZXhjO1xuICBpZiBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBDYW1sLlByaW50ZXhjLnByaW50X3Jhd19iYWNrdHJhY2UgQ2FtbC5zdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgQ2FtbC5mbHVzaCBDYW1sLnN0ZGVyclxuOztcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKSA9XG4gIENhbWwuUHJpbnRleGMuc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHByaW50X3dpdGhfYmFja3RyYWNlXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2F1eCB+ZG9fYXRfZXhpdCB+ZXhpdCBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4YyAtPlxuICAgIGxldCByYXdfYmFja3RyYWNlID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgQ2FtbC5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgXyAtPiAoKSk7XG4gICAgKHRyeSBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnlcbiAgICAgICAgICBDYW1sLlByaW50Zi5lcHJpbnRmIFwiRXhuLmhhbmRsZV91bmNhdWdodCBjb3VsZCBub3QgcHJpbnQ7IGV4aXRpbmcgYW55d2F5XFxuJSFcIlxuICAgICAgICB3aXRoXG4gICAgICAgIHwgXyAtPiAoKSkpO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmID0gaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0IH5kb19hdF9leGl0OnRydWVcblxubGV0IGhhbmRsZV91bmNhdWdodCB+ZXhpdDptdXN0X2V4aXQgZiA9XG4gIGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdDooaWYgbXVzdF9leGl0IHRoZW4gZXhpdCBlbHNlIGlnbm9yZSkgfmRvX2F0X2V4aXQ6bXVzdF9leGl0XG47O1xuXG5sZXQgcmVyYWlzZV91bmNhdWdodCBzdHIgZnVuYyA9XG4gIHRyeSBmdW5jICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIENhbWwucmFpc2Vfbm90cmFjZSBlXG47O1xuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKClcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsZWFyX2JhY2t0cmFjZSA9IGNsZWFyX2JhY2t0cmFjZVxuZW5kXG4iLCIoKiBiZWxvbmdzIGluIENvbW1vbiwgYnV0IG1vdmVkIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHJldHVybiA9IHsgcmV0dXJuIDogJ2IuICdhIC0+ICdiIH0gW0BAdW5ib3hlZF1cblxubGV0IHdpdGhfcmV0dXJuICh0eXBlIGEpIGYgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAoKiBSYWlzZWQgdG8gaW5kaWNhdGUgfnJldHVybiB3YXMgY2FsbGVkLiAgTG9jYWwgc28gdGhhdCB0aGUgZXhjZXB0aW9uIGlzIHRpZWQgdG8gYVxuICAgICAgIHBhcnRpY3VsYXIgY2FsbCBvZiBbd2l0aF9yZXR1cm5dLiAqKVxuICAgIGV4Y2VwdGlvbiBSZXR1cm4gb2YgYVxuICBlbmRcbiAgaW5cbiAgbGV0IGlzX2FsaXZlID0gcmVmIHRydWUgaW5cbiAgbGV0IHJldHVybiBhID1cbiAgICBpZiBub3QgIWlzX2FsaXZlXG4gICAgdGhlbiBmYWlsd2l0aCBcInVzZSBvZiBbcmV0dXJuXSBmcm9tIGEgW3dpdGhfcmV0dXJuXSB0aGF0IGFscmVhZHkgcmV0dXJuZWRcIjtcbiAgICBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgKE0uUmV0dXJuIGEpXG4gIGluXG4gIHRyeVxuICAgIGxldCBhID0gZiB7IHJldHVybiB9IGluXG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgYVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgKG1hdGNoIGV4biB3aXRoXG4gICAgIHwgTS5SZXR1cm4gYSAtPiBhXG4gICAgIHwgXyAtPiByYWlzZSBleG4pXG47O1xuXG5sZXQgd2l0aF9yZXR1cm5fb3B0aW9uIGYgPVxuICB3aXRoX3JldHVybiAoZnVuIHJldHVybiAtPlxuICAgIGYgeyByZXR1cm4gPSAoZnVuIGEgLT4gcmV0dXJuLnJldHVybiAoU29tZSBhKSkgfTtcbiAgICBOb25lKVxuOztcblxubGV0IHByZXBlbmQgeyByZXR1cm4gfSB+ZiA9IHsgcmV0dXJuID0gKGZ1biB4IC0+IHJldHVybiAoZiB4KSkgfVxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSB0eXBlIEJhc2ljID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgKCoqIFRoZSBmb2xsb3dpbmcgaWRlbnRpdGllcyBvdWdodCB0byBob2xkIChmb3Igc29tZSB2YWx1ZSBvZiA9KTpcblxuICAgICAgLSBbcmV0dXJuIHggPj49IGYgPSBmIHhdXG4gICAgICAtIFt0ID4+PSBmdW4geCAtPiByZXR1cm4geCA9IHRdXG4gICAgICAtIFsodCA+Pj0gZikgPj49IGcgPSB0ID4+PSBmdW4geCAtPiAoZiB4ID4+PSBnKV1cblxuICAgICAgTm90ZTogWz4+PV0gaXMgdGhlIGluZml4IG5vdGF0aW9uIGZvciBbYmluZF0pICopXG5cbiAgKCoqIFRoZSBbbWFwXSBhcmd1bWVudCB0byBbTW9uYWQuTWFrZV0gc2F5cyBob3cgdG8gaW1wbGVtZW50IHRoZSBtb25hZCdzIFttYXBdIGZ1bmN0aW9uLlxuICAgICAgW2BEZWZpbmVfdXNpbmdfYmluZF0gbWVhbnMgdG8gZGVmaW5lIFttYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC5cblxuICAgICAgU29tZSBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW01vbmFkLk1ha2VdIGFyZSBkZWZpbmVkIGluIHRlcm1zIG9mIFttYXBdLCBzb1xuICAgICAgcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFttYXBdIHdpbGwgaW1wcm92ZSB0aGVpciBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBtYXAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdCBdXG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXggPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIFt0ID4+PSBmXSByZXR1cm5zIGEgY29tcHV0YXRpb24gdGhhdCBzZXF1ZW5jZXMgdGhlIGNvbXB1dGF0aW9ucyByZXByZXNlbnRlZCBieSB0d29cbiAgICAgIG1vbmFkIGVsZW1lbnRzLiAgVGhlIHJlc3VsdGluZyBjb21wdXRhdGlvbiBmaXJzdCBkb2VzIFt0XSB0byB5aWVsZCBhIHZhbHVlIFt2XSwgYW5kXG4gICAgICB0aGVuIHJ1bnMgdGhlIGNvbXB1dGF0aW9uIHJldHVybmVkIGJ5IFtmIHZdLiAqKVxuICB2YWwgKCA+Pj0gKSA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiogW3QgPj58IGZdIGlzIFt0ID4+PSAoZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uICopXG4gIHZhbCAoID4+fCApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IpIC0+ICdiIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXggPSBzaWdcbiAgKCoqIE9wZW5pbmcgYSBtb2R1bGUgb2YgdGhpcyB0eXBlIGFsbG93cyBvbmUgdG8gdXNlIHRoZSBbJWJpbmRdIGFuZCBbJW1hcF0gc3ludGF4XG4gICAgICBleHRlbnNpb25zIGRlZmluZWQgYnkgcHB4X2xldCwgYW5kIGJyaW5ncyBbcmV0dXJuXSBpbnRvIHNjb3BlLiAqKVxuXG4gIHR5cGUgJ2EgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgKCoqIFRoZXNlIGFyZSBjb252ZW5pZW50IHRvIGhhdmUgaW4gc2NvcGUgd2hlbiBwcm9ncmFtbWluZyB3aXRoIGEgbW9uYWQ6ICopXG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICAgaW5jbHVkZSBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgICAgIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gICAgICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICAgICAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtiaW5kIHQgfmZdID0gW3QgPj49IGZdICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFtyZXR1cm4gdl0gcmV0dXJucyB0aGUgKHRyaXZpYWwpIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyB2LiAqKVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBbbWFwIHQgfmZdIGlzIHQgPj58IGYuICopXG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG5cbiAgKCoqIFtqb2luIHRdIGlzIFt0ID4+PSAoZnVuIHQnIC0+IHQnKV0uICopXG4gIHZhbCBqb2luIDogJ2EgdCB0IC0+ICdhIHRcblxuICAoKiogW2lnbm9yZV9tIHRdIGlzIFttYXAgdCB+ZjooZnVuIF8gLT4gKCkpXS4gIFtpZ25vcmVfbV0gdXNlZCB0byBiZSBjYWxsZWQgW2lnbm9yZV0sXG4gICAgICBidXQgd2UgZGVjaWRlZCB0aGF0IHdhcyBhIGJhZCBuYW1lLCBiZWNhdXNlIGl0IHNoYWRvd2VkIHRoZSB3aWRlbHkgdXNlZFxuICAgICAgW0NhbWwuaWdub3JlXS4gIFNvbWUgbW9uYWRzIHN0aWxsIGRvIFtsZXQgaWdub3JlID0gaWdub3JlX21dIGZvciBoaXN0b3JpY2FsXG4gICAgICByZWFzb25zLiAqKVxuICB2YWwgaWdub3JlX20gOiAnYSB0IC0+IHVuaXQgdFxuXG4gIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgKCoqIExpa2UgW2FsbF0sIGJ1dCBlbnN1cmVzIHRoYXQgZXZlcnkgbW9uYWRpYyB2YWx1ZSBpbiB0aGUgbGlzdCBwcm9kdWNlcyBhIHVuaXQgdmFsdWUsXG4gICAgICBhbGwgb2Ygd2hpY2ggYXJlIGRpc2NhcmRlZCByYXRoZXIgdGhhbiBiZWluZyBjb2xsZWN0ZWQgaW50byBhIGxpc3QuICopXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTeW50YXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMiA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBnZXRzIHVuaWZpZWQgYWNyb3NzIGFsbCB0aGUgY29tcHV0YXRpb24uXG4gICAgICBUaGlzIGlzIHVzZWQgdG8gZW5jb2RlIG1vbmFkcyB3b3JraW5nIG9uIGEgbXVsdGkgcGFyYW1ldGVyIGRhdGEgc3RydWN0dXJlIGxpa2VcbiAgICAgIChbKCdhLCdiKSByZXN1bHRdKS4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgbWFwIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHQgXVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgyID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MiA9IHNpZ1xuICB0eXBlICgnYSwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZSkgdCAtPiAoJ2IsICdlKSB0IC0+ICgnYSAqICdiLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdHdvIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBpcyBhbHdheXMganVzdFxuICAgICAgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBpbmNsdWRlIFN5bnRheDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnZSkgdCwgJ2UpIHQgLT4gKCdhLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2UpIHQgLT4gKHVuaXQsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMyA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGdldCB1bmlmaWVkIGFjcm9zcyBhbGwgdGhlXG4gICAgICBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0IF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgzID0gc2lnXG4gICgqKiBTYW1lIGFzIEluZml4LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmQgdGhpcmQgYXJlXG4gICAgICBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheDMgPSBzaWdcbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuXG4gICAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdiLCAnZCwgJ2UpIHQgLT4gKCdhICogJ2IsICdkLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kXG4gICAgICBhbmQgdGhpcmQgYXJlIGFsd2F5cyBqdXN0IHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBpbmNsdWRlIEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgaW5jbHVkZSBTeW50YXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2QsICdlKSB0LCAnZCwgJ2UpIHQgLT4gKCdhLCAnZCwgJ2UpIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdkLCAnZSkgdCAtPiAodW5pdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdkLCAnZSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnZCwgJ2UpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdkLCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gc2lnXG4gICgqKiBJbmRleGVkIG1vbmFkLCBpbiB0aGUgc3R5bGUgb2YgQXRrZXkuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnMgYXJlIGNvbXBvc2VkXG4gICAgICBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiBUbyBzZWUgdGhpcyBtb3JlIGNsZWFybHksIHlvdSBjYW4gbG9vayBhdCB0aGUgdHlwZSBvZiBiaW5kOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICAgICAgXX1cblxuICAgICAgYW5kIGlzb2xhdGUgc29tZSBvZiB0aGUgdHlwZSB2YXJpYWJsZXMgdG8gc2VlIHRoZWlyIGluZGl2aWR1YWwgYmVoYXZpb3JzOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICdhICAgICAgICAgICAgIC0+IGY6KCdhIC0+ICAnYiAgICAgICAgICAgKSAtPiAgJ2JcbiAgICAgICAgdmFsIGJpbmQgOiAgICAgICdpLCAnaiAgICAtPiAgICAgICAgICAgICAgICdqLCAnayAgICAgLT4gICAgICdpLCAna1xuICAgICAgXX1cblxuICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQXRrZXktc3R5bGUgaW5kZXhlZCBtb25hZHMsIHNlZTpcblxuICAgICAge3ZcbiAgICAgICAgUGFyYW1ldGVyaXNlZCBOb3Rpb25zIG9mIENvbXB1dGF0aW9uXG4gICAgICAgIFJvYmVydCBBdGtleVxuICAgICAgICBodHRwOi8vYmVudG5pYi5vcmcvcGFyYW1ub3Rpb25zLWpmcC5wZGZcbiAgICAgIHZ9ICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuXG4gICAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdiLCAnaiwgJ2spIHQgLT4gKCdhICogJ2IsICdpLCAnaykgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfaW5kZXhlZCA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmRcbiAgICAgIHRoaXJkIGFyZSBjb21wb3NlZCBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBpbmNsdWRlIEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIGluY2x1ZGUgU3ludGF4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnaiwgJ2spIHQsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaykgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2ksICdqKSB0IC0+ICh1bml0LCAnaSwgJ2opIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2ksICdpKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdpLCAnaSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2ksICdpKSB0IGxpc3QgLT4gKHVuaXQsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTX3RvX1NfaW5kZXhlZCAoWCA6IFMpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUzIgKFggOiBTMykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgU19pbmRleGVkX3RvX1MyIChYIDogU19pbmRleGVkKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudCA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1vbmFkID0gc2lnXG4gICgqKiBBIG1vbmFkIGlzIGFuIGFic3RyYWN0aW9uIG9mIHRoZSBjb25jZXB0IG9mIHNlcXVlbmNpbmcgb2YgY29tcHV0YXRpb25zLiAgQSB2YWx1ZSBvZlxuICAgICAgdHlwZSBbJ2EgbW9uYWRdIHJlcHJlc2VudHMgYSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIFsnYV0uICopXG5cbiAgbW9kdWxlIHR5cGUgQmFzaWMgPSBCYXNpY1xuICBtb2R1bGUgdHlwZSBCYXNpYzIgPSBCYXNpYzJcbiAgbW9kdWxlIHR5cGUgQmFzaWMzID0gQmFzaWMzXG4gIG1vZHVsZSB0eXBlIEJhc2ljX2luZGV4ZWQgPSBCYXNpY19pbmRleGVkXG4gIG1vZHVsZSB0eXBlIEluZml4ID0gSW5maXhcbiAgbW9kdWxlIHR5cGUgSW5maXgyID0gSW5maXgyXG4gIG1vZHVsZSB0eXBlIEluZml4MyA9IEluZml4M1xuICBtb2R1bGUgdHlwZSBJbmZpeF9pbmRleGVkID0gSW5maXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTeW50YXggPSBTeW50YXhcbiAgbW9kdWxlIHR5cGUgU3ludGF4MiA9IFN5bnRheDJcbiAgbW9kdWxlIHR5cGUgU3ludGF4MyA9IFN5bnRheDNcbiAgbW9kdWxlIHR5cGUgU3ludGF4X2luZGV4ZWQgPSBTeW50YXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gU193aXRob3V0X3N5bnRheFxuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gIG1vZHVsZSB0eXBlIFMzID0gUzNcbiAgbW9kdWxlIHR5cGUgU19pbmRleGVkID0gU19pbmRleGVkXG5cbiAgbW9kdWxlIE1ha2UgKFggOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudFxuICBtb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50XG4gIG1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gIG1vZHVsZSBNYWtlX2luZGV4ZWQgKFggOiBCYXNpY19pbmRleGVkKSA6XG4gICAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50XG5cbiAgKCoqIERlZmluZSBhIG1vbmFkIHRocm91Z2ggYW4gaXNvbW9ycGhpc20gd2l0aCBhbiBleGlzdGluZyBtb25hZC4gRm9yIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgJ2EgdCA9IHsgdmFsdWUgOiAnYSB9XG5cbiAgICAgICAgaW5jbHVkZSBNb25hZC5PZl9tb25hZCAoTW9uYWQuSWRlbnQpIChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgICAgICAgIGxldCB0b19tb25hZCB7IHZhbHVlIH0gPSB2YWx1ZVxuICAgICAgICAgICAgbGV0IG9mX21vbmFkIHZhbHVlID0geyB2YWx1ZSB9XG4gICAgICAgICAgZW5kKVxuICAgICAgXX0gKilcbiAgbW9kdWxlIE9mX21vbmFkXG4gICAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgZW5kKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkMlxuICAgICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDNcbiAgICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50XG5cbiAgbW9kdWxlIElkZW50IDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNb25hZF9pbnRmXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2dlbmVyYWwgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmRcbiAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmRcbiAgICAgIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5lcmFsIChNIDogQmFzaWNfZ2VuZXJhbCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmQgPSBNLmJpbmRcbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gIGxldCBtYXBfdmlhX2JpbmQgbWEgfmYgPSBNLmJpbmQgbWEgfmY6KGZ1biBhIC0+IE0ucmV0dXJuIChmIGEpKVxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIE0ubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYmluZCAtPiBtYXBfdmlhX2JpbmRcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG4gICAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggYSBiID0gYSA+Pj0gZnVuIGEgLT4gYiA+PnwgZnVuIGIgLT4gYSwgYlxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBqb2luIHQgPSB0ID4+PSBmdW4gdCcgLT4gdCdcbiAgbGV0IGlnbm9yZV9tIHQgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpXG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9pbmRleGVkIChNIDogQmFzaWNfaW5kZXhlZCkgOlxuICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMyAoTSA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIE0udCA9XG4gIE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UyIChNIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0IDo9ICgnYSwgJ2QpIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoTSA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9nZW5lcmFsIChNb25hZCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gICAgdmFsIGJpbmRcbiAgICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG4gIGVuZCkgKE0gOiBzaWdcbiAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudFxuICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgICBlbmQpID1cbiAgTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNLnRcblxuICAgIGxldCByZXR1cm4gYSA9IE0ub2ZfbW9uYWQgKE1vbmFkLnJldHVybiBhKVxuICAgIGxldCBiaW5kIHQgfmYgPSBNLm9mX21vbmFkIChNb25hZC5iaW5kIChNLnRvX21vbmFkIHQpIH5mOihmdW4gYSAtPiBNLnRvX21vbmFkIChmIGEpKSlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIHQgfmYgLT4gTS5vZl9tb25hZCAoTW9uYWQubWFwIChNLnRvX21vbmFkIHQpIH5mKSlcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQzXG4gICAgKE1vbmFkIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiLCAnYykgTW9uYWQudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyXG4gICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZFxuICAgIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICAgIGVuZClcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCBiaW5kIGEgfmYgPSBmIGFcbiAgICAgIGxldCByZXR1cm4gYSA9IGFcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gYSB+ZiAtPiBmIGEpXG4gICAgZW5kKVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuXG4oKiogVGhpcyBtb2R1bGUgc2VydmVzIG1vc3RseSBhcyBhIHBhcnRpYWwgY2hlY2sgdGhhdCBbUzJdIGFuZCBbU10gYXJlIGluIHN5bmMsIGJ1dFxuICAgIGFjdHVhbGx5IGNhbGxpbmcgaXQgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bC4gKilcbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYXBwbHkgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IG1hcDIgdGEgdGIgfmYgPSBtYXAgfmYgdGEgPCo+IHRiXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwIH5mIHRhIDwqPiB0YiA8Kj4gdGNcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgKCAqPiApIHUgdiA9IHJldHVybiAoZnVuICgpIHkgLT4geSkgPCo+IHUgPCo+IHZcbiAgbGV0ICggPCogKSB1IHYgPSByZXR1cm4gKGZ1biB4ICgpIC0+IHgpIDwqPiB1IDwqPiB2XG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTMgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4M1xuICAgIChYIDogRm9yX2xldF9zeW50YXgzKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gSW1wbFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4MlxuICAgIChYIDogRm9yX2xldF9zeW50YXgyKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4M1xuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgJ2QsIF8pIHQgPSAoJ2EsICdkKSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXhcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4KSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0eXBlIFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbigqKiBUaGlzIGZ1bmN0b3IgY2xvc2VseSByZXNlbWJsZXMgW01ha2UzXSwgYW5kIGluZGVlZCBpdCBjb3VsZCBiZSBpbXBsZW1lbnRlZFxuICAgIG11Y2ggc2hvcnRlciBpbiB0ZXJtcyBvZiBbTWFrZTNdLiBIb3dldmVyLCB3ZSBpbXBsZW1lbnQgaXQgYnkgaGFuZCBzbyB0aGF0XG4gICAgdGhlIHJlc3VsdGluZyBmdW5jdGlvbnMgYXJlIG1vcmUgZWZmaWNpZW50LCBlLmcuIHVzaW5nIFttYXAyXSBkaXJlY3RseSBpbnN0ZWFkIG9mXG4gICAgZGVmaW5pbmcgW2FwcGx5XSBpbiB0ZXJtcyBvZiBpdCBhbmQgdGhlbiBbbWFwMl0gaW4gdGVybXMgb2YgdGhhdC4gRm9yIG1vc3RcbiAgICBhcHBsaWNhdGl2ZXMgdGhpcyBkb2VzIG5vdCBtYXR0ZXIsIGJ1dCBmb3Igc29tZSAoc3VjaCBhcyBCb25zYWkuVmFsdWUudCksIGl0IGhhcyBhXG4gICAgbGFyZ2VyIGltcGFjdC4gKilcbm1vZHVsZSBNYWtlM191c2luZ19tYXAyIChYIDogQmFzaWMzX3VzaW5nX21hcDIpIDpcbiAgUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0IGFwcGx5IHRmIHRhID0gbWFwMiB0ZiB0YSB+ZjooZnVuIGYgYSAtPiBmIGEpXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfbWFwMiAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPSBtYXAyIChtYXAyIHRhIHRiIH5mKSB0YyB+ZjooZnVuIGZhYiBjIC0+IGZhYiBjKVxuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0ICggKj4gKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuICgpIHkgLT4geSlcbiAgbGV0ICggPCogKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuIHggKCkgLT4geClcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMl91c2luZ19tYXAyIChYIDogQmFzaWMyX3VzaW5nX21hcDIpIDpcbiAgUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTNfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfdXNpbmdfbWFwMiAoWCA6IEJhc2ljX3VzaW5nX21hcDIpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPVxuICBNYWtlMl91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDIgKE0gOiBNb25hZC5TMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBNLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgTS50XG5cbiAgICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgICBsZXQgYXBwbHkgbWYgbXggPSBNLmJpbmQgbWYgfmY6KGZ1biBmIC0+IE0ubWFwIG14IH5mKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIE0ubWFwXG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkIChNIDogTW9uYWQuUykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE9mX21vbmFkMiAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgXykgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBDb21wb3NlIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRy5yZXR1cm4gKEYucmV0dXJuIGEpXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBHLmFwcGx5IChHLm1hcCB+ZjpGLmFwcGx5IHRmKSB0eFxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEcubWFwIH5mOihGLm1hcCB+ZikgdFxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgUGFpciAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgcmV0dXJuIGEgPSBGLnJldHVybiBhLCBHLnJldHVybiBhXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBGLmFwcGx5IChmc3QgdGYpIChmc3QgdHgpLCBHLmFwcGx5IChzbmQgdGYpIChzbmQgdHgpXG4gICAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRi5tYXAgfmYgKGZzdCB0KSwgRy5tYXAgfmYgKHNuZCB0KVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuIiwiKCogW0J5dGVzMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbC5CeXRlc10uIFtCeXRlczBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzc1xuICAgdGhlIHBhcnQgb2YgW0NhbWwuQnl0ZXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGJ5dGVzMC5tbCBzaG91bGQgdXNlIFtDYW1sLkJ5dGVzXS4gW0J5dGVzMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZFxuICAgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5CeXRlc10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEJ5dGVzICA9IEJ5dGVzMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBCeXRlcyA9IEJ5dGVzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5CeXRlc10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBQcmltaXRpdmVzID0gc3RydWN0XG4gIGV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0ICAgICAgICA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5cbiAgKCogW3Vuc2FmZV9ibGl0X3N0cmluZ10gaXMgbm90IGV4cG9ydGVkIGluIHRoZSBbc3RkbGliXSBzbyB3ZSBleHBvcnQgaXQgaGVyZSAqKVxuICBleHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICA6ICBzcmM6c3RyaW5nXG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6Ynl0ZXNcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0dVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmVuZFxuXG5pbmNsdWRlIFByaW1pdGl2ZXNcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBibGl0ID0gQ2FtbC5CeXRlcy5ibGl0XG5sZXQgYmxpdF9zdHJpbmcgPSBDYW1sLkJ5dGVzLmJsaXRfc3RyaW5nXG5sZXQgY29tcGFyZSA9IENhbWwuQnl0ZXMuY29tcGFyZVxubGV0IGNvcHkgPSBDYW1sLkJ5dGVzLmNvcHlcbmxldCBjcmVhdGUgPSBDYW1sLkJ5dGVzLmNyZWF0ZVxubGV0IGZpbGwgPSBDYW1sLkJ5dGVzLmZpbGxcbmxldCBtYWtlID0gQ2FtbC5CeXRlcy5tYWtlXG5sZXQgbWFwID0gQ2FtbC5CeXRlcy5tYXBcbmxldCBtYXBpID0gQ2FtbC5CeXRlcy5tYXBpXG5sZXQgc3ViID0gQ2FtbC5CeXRlcy5zdWJcbmxldCB1bnNhZmVfYmxpdCA9IENhbWwuQnl0ZXMudW5zYWZlX2JsaXRcbmxldCB0b19zdHJpbmcgPSBDYW1sLkJ5dGVzLnRvX3N0cmluZ1xubGV0IG9mX3N0cmluZyA9IENhbWwuQnl0ZXMub2Zfc3RyaW5nXG5sZXQgdW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpzID0gQ2FtbC5CeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcbmxldCB1bnNhZmVfb2Zfc3RyaW5nX3Byb21pc2Vfbm9fbXV0YXRpb24gPSBDYW1sLkJ5dGVzLnVuc2FmZV9vZl9zdHJpbmdcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ3dpdG5lc3MpIHQgPVxuICB7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2IpIGNvbXBhcmF0b3IgPSAoJ2EsICdiKSB0XG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAodCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EgdCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgU19mYyA9IHNpZ1xuICB0eXBlIGNvbXBhcmFibGVfdFxuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgdCA6PSBjb21wYXJhYmxlX3RcbmVuZFxuXG5tb2R1bGUgTW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdiKVxuZW5kXG5cbmxldCBtYWtlICh0eXBlIHQpIH5jb21wYXJlIH5zZXhwX29mX3QgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgY29tcGFyYWJsZV90ID0gdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kIDogU19mY1xuICAgIHdpdGggdHlwZSBjb21wYXJhYmxlX3QgPSB0KVxuOztcblxubW9kdWxlIFNfdG9fUzEgKFMgOiBTKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBTLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBTLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIG9wZW4gU1xuXG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBNYWtlIChNIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICdhIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgXyA9IFNleHAuQXRvbSBcIl9cIlxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIGNvbXBhcmF0b3IgLT4gKCdhIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQgKE0gOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wX2EpIGNvbXBhcmF0b3JcbiAgICAtPiAoJ2IsICdjbXBfYikgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsICdiKSB0LCAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkMiAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2EsICdiKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhIGIgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdFxuICAgIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcCkgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsIF8pIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWRfcGhhbnRvbSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYSwgXykgdCAtPiBTZXhwLnRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wX2EgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOlxuICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICdmICdzLlxuICAoU2V4cGxpYjAuU2V4cC50IC0+ICdmKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdzKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKCdmLCAncykgdFxuICA9XG4gIGZ1biAodHlwZSBmX18wMjNfIHNfXzAyNF8pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjNfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAyNF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAgIC0+IChmX18wMjNfLCBzX18wMjRfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAxMV8gPSBcImVpdGhlcjAubWwudFwiIGluXG4gICAgZnVuIF9vZl9mX18wMDdfIF9vZl9zX18wMDhfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2ZfXzAwN18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgICBGaXJzdCByZXMwX18wMTdfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMTlfKSA6OiBzZXhwX2FyZ3NfXzAyMF8pIGFzXG4gICAgICAgIF9zZXhwX18wMThfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyMF8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAyMV8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9zX18wMDhfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgICAgU2Vjb25kIHJlczBfXzAyMl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTFfXG4gICAgICAgICAgICAgX3RhZ19fMDE5X1xuICAgICAgICAgICAgIF9zZXhwX18wMThfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgc2V4cF9fMDEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTJfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICdmICdzLlxuICAoJ2YgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2YsICdzKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBmX18wMzFfIHNfXzAzMl8pXG4gICAgICA6ICAoKGZfXzAzMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDMyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGZfXzAzMV8sIHNfXzAzMl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfZl9fMDI1XyBfb2Zfc19fMDI2XyAtPiBmdW5jdGlvblxuICAgICAgfCBGaXJzdCBhcmcwX18wMjdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2ZfXzAyNV8gYXJnMF9fMDI3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJGaXJzdFwiOyByZXMwX18wMjhfIF1cbiAgICAgIHwgU2Vjb25kIGFyZzBfXzAyOV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMF8gPSBfb2Zfc19fMDI2XyBhcmcwX18wMjlfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNlY29uZFwiOyByZXMwX18wMzBfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nZl9zZXhwX2dyYW1tYXIgXydzX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRmlyc3RcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlNlY29uZFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nc19zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cbiIsIigqIFRoZSB0eXBlIFt0XSBzaG91bGQgYmUgYWJzdHJhY3QgdG8gbWFrZSB0aGUgZnNldCBhbmQgc2V0IGZ1bmN0aW9ucyB1bmF2YWlsYWJsZVxuICAgZm9yIHByaXZhdGUgdHlwZXMgYXQgdGhlIGxldmVsIG9mIHR5cGVzIChhbmQgbm90IGJ5IHB1dHRpbmcgTm9uZSBpbiB0aGUgZmllbGQpLlxuICAgVW5mb3J0dW5hdGVseSwgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0IG1lYW5zIHRoYXQgd2hlbiBjcmVhdGluZyBmaWVsZHMgKHRocm91Z2hcbiAgIGEgW2NyZWF0ZV0gZnVuY3Rpb24pIHZhbHVlIHJlc3RyaWN0aW9uIGtpY2tzIGluLiBUaGlzIGlzIHdvcmtlZCBhcm91bmQgYnkgaW5zdGVhZFxuICAgbm90IG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCwgYnV0IGZvcmNpbmcgYW55b25lIGJyZWFraW5nIHRoZSBhYnN0cmFjdGlvbiB0byB1c2VcbiAgIHRoZSBbRm9yX2dlbmVyYXRlZF9jb2RlXSBtb2R1bGUsIG1ha2luZyBpdCBvYnZpb3VzIHRvIGFueSByZWFkZXIgdGhhdCBzb21ldGhpbmcgdWdseVxuICAgaXMgZ29pbmcgb24uXG4gICB0X3dpdGhfcGVybSAoYW5kIGRlcml2YXRpdmVzKSBpcyB0aGUgdHlwZSB0aGF0IHVzZXJzIHJlYWxseSB1c2UuIEl0IGlzIGEgY29uc3RydWN0b3JcbiAgIGJlY2F1c2U6XG4gICAxLiBpdCBtYWtlcyB0eXBlIGVycm9ycyBtb3JlIHJlYWRhYmxlIChsZXNzIGFsaWFzaW5nKVxuICAgMi4gdGhlIHR5cGVyIGluIG9jYW1sIDQuMDEgYWxsb3dzIHRoaXM6XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBBID0gc3RydWN0XG4gICAgICAgdHlwZSB0ID0ge2EgOiBpbnR9XG4gICAgIGVuZFxuICAgICB0eXBlIHQgPSBBLnRcbiAgICAgbGV0IGYgKHggOiB0KSA9IHguYVxuICAgXX1cblxuICAgKGFsdGhvdWdoIHdpdGggV2FybmluZyA0MDogYSBpcyB1c2VkIG91dCBvZiBzY29wZSlcbiAgIHdoaWNoIG1lYW5zIHRoYXQgaWYgW3Rfd2l0aF9wZXJtXSB3YXMgcmVhbGx5IGFuIGFsaWFzIG9uIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0sXG4gICBwZW9wbGUgY291bGQgc2F5IFt0LnNldHRlcl0gYW5kIGJyZWFrIHRoZSBhYnN0cmFjdGlvbiB3aXRoIG5vIGluZGljYXRpb24gdGhhdFxuICAgc29tZXRoaW5nIHVnbHkgaXMgZ29pbmcgb24gaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgVGhlIHdhcm5pbmcgaXMgKEkgdGhpbmspIGZvciBwZW9wbGUgd2hvIHdhbnQgdG8gbWFrZSB0aGVpciBjb2RlIGNvbXBhdGlibGUgd2l0aFxuICAgcHJldmlvdXMgdmVyc2lvbnMgb2Ygb2NhbWwsIHNvIHdlIG1heSB2ZXJ5IHdlbGwgdHVybiBpdCBvZmYuXG5cbiAgIFRoZSB0eXBlIHRfd2l0aF9wZXJtIGNvdWxkIGFsc28gaGF2ZSBiZWVuIGEgW3VuaXQgLT4gRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHRvIHdvcmtcbiAgIGFyb3VuZCB2YWx1ZSByZXN0cmljdGlvbiBhbmQgdGhlbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHdvdWxkIGhhdmUgYmVlbiBhIHByb3BlclxuICAgYWJzdHJhY3QgdHlwZSwgYnV0IGl0IGxvb2tzIGxpa2UgaXQgY291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIChmb3IgZXhhbXBsZSwgYSBmb2xkIG9uIGFcbiAgIHJlY29yZCB0eXBlIHdpdGggNDAgZmllbGRzIHdvdWxkIGFjdHVhbGx5IGFsbG9jYXRlIHRoZSA0MCBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdJ3MgYXRcbiAgIGV2ZXJ5IHNpbmdsZSBmb2xkLikgKilcblxubW9kdWxlIEZvcl9nZW5lcmF0ZWRfY29kZSA9IHN0cnVjdFxuICB0eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0ID1cbiAgICB7IGZvcmNlX3ZhcmlhbmNlIDogJ3Blcm0gLT4gdW5pdFxuICAgIDsgKCogZm9yY2UgW3RdIHRvIGJlIGNvbnRyYXZhcmlhbnQgaW4gWydwZXJtXSwgYmVjYXVzZSBwaGFudG9tIHR5cGUgdmFyaWFibGVzIG9uXG4gICAgICAgICBjb25jcmV0ZSB0eXBlcyBkb24ndCB3b3JrIHRoYXQgd2VsbCBvdGhlcndpc2UgKHVzaW5nIDo+IGNhbiByZW1vdmUgdGhlbSBlYXNpbHkpICopXG4gICAgICBuYW1lIDogc3RyaW5nXG4gICAgOyBzZXR0ZXIgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBnZXR0ZXIgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgIDsgZnNldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkIC0+ICdyZWNvcmRcbiAgICB9XG5cbiAgbGV0IG9wYXF1ZV9pZGVudGl0eSA9IFN5czAub3BhcXVlX2lkZW50aXR5XG5lbmRcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gPVxuICB8IEZpZWxkIG9mICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSBGb3JfZ2VuZXJhdGVkX2NvZGUudFxuW0BAdW5ib3hlZF1cblxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0ID0gKFsgYFJlYWQgfCBgU2V0X2FuZF9jcmVhdGUgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSByZWFkb25seV90ID0gKFsgYFJlYWQgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxuXG5sZXQgbmFtZSAoRmllbGQgZmllbGQpID0gZmllbGQubmFtZVxubGV0IGdldCAoRmllbGQgZmllbGQpIHIgPSBmaWVsZC5nZXR0ZXIgclxubGV0IGZzZXQgKEZpZWxkIGZpZWxkKSByIHYgPSBmaWVsZC5mc2V0IHIgdlxubGV0IHNldHRlciAoRmllbGQgZmllbGQpID0gZmllbGQuc2V0dGVyXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAncmVzdWx0KSB1c2VyID1cbiAgeyBmIDogJ2ZpZWxkLiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gLT4gJ3Jlc3VsdCB9XG5cbmxldCBtYXAgKEZpZWxkIGZpZWxkKSByIH5mID0gZmllbGQuZnNldCByIChmIChmaWVsZC5nZXR0ZXIgcikpXG5cbmxldCB1cGRhdGVyIChGaWVsZCBmaWVsZCkgPVxuICBtYXRjaCBmaWVsZC5zZXR0ZXIgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgc2V0dGVyIC0+IFNvbWUgKGZ1biByIH5mIC0+IHNldHRlciByIChmIChmaWVsZC5nZXR0ZXIgcikpKVxuOztcbiIsIigqIFtTdHJpbmcwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN0cmluZ10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzdHJpbmcwLm1sIHNob3VsZFxuICAgdXNlIFtDYW1sLlN0cmluZ10uICBbU3RyaW5nMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzXG4gICBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzLCBpbmNsdWRpbmcgdGhlIHN1YnNjcmlwdCBzeW50YXhcbiAgIFt4LihpKV0gb3IgW3guKGkpIDwtIGVdIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0b1xuICAgW1N0cmluZ10sIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TdHJpbmddIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBDYW1sLlN0cmluZy5jYXBpdGFsaXplX2FzY2lpXG5sZXQgY29tcGFyZSA9IENhbWwuU3RyaW5nLmNvbXBhcmVcblxubGV0IGNvcHkgeCA9XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmdcbiAgICB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpcbiAgICAgIChCeXRlcy5vZl9zdHJpbmcgeClcbjs7XG5cbmxldCBlc2NhcGVkID0gQ2FtbC5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxubGV0IG1ha2UgPSBDYW1sLlN0cmluZy5tYWtlXG5sZXQgc3ViID0gQ2FtbC5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLlN0cmluZy51bnNhZmVfYmxpdFxubGV0IHVwcGVyY2FzZSA9IENhbWwuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxuXG5sZXQgY29uY2F0ID8oc2VwID0gXCJcIikgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiXCJcbiAgKCogVGhlIHN0ZGxpYiBkb2VzIG5vdCBzcGVjaWFsaXplIHRoaXMgY2FzZSBiZWNhdXNlIGl0IGNvdWxkIGJyZWFrIGV4aXN0aW5nIHByb2plY3RzLiAqKVxuICB8IFsgeCBdIC0+IHhcbiAgfCBsIC0+IENhbWwuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbigqIFRoZXNlIGFyZSBldGEgZXhwYW5kZWQgaW4gb3JkZXIgdG8gcGVybXV0ZSBwYXJhbWV0ZXIgb3JkZXIgdG8gZm9sbG93IEJhc2VcbiAgIGNvbnZlbnRpb25zLiAqKVxubGV0IGl0ZXIgdCB+ZiA9IENhbWwuU3RyaW5nLml0ZXIgdCB+ZlxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQ2FtbC5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID1cbiAgICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmcgYV9fMDAxXy5wb3NfZm5hbWUgYl9fMDAyXy5wb3NfZm5hbWUgd2l0aFxuICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19sbnVtIGJfXzAwMl8ucG9zX2xudW0gd2l0aFxuICAgICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludCBhX18wMDFfLnBvc19jbnVtIGJfXzAwMl8ucG9zX2NudW1cbiAgICAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIDogdCAtPiB0IC0+IGludClcbiAgOztcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgZnVuIGhzdiBhcmcgLT5cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IGFyZy5wb3NfZm5hbWVcbiAgICAgICAgICBpblxuICAgICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgICBpblxuICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2JvbFxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfY251bVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW4geyBwb3NfZm5hbWUgPSBwb3NfZm5hbWVfXzAwNF9cbiAgICAgICAgIDsgcG9zX2xudW0gPSBwb3NfbG51bV9fMDA2X1xuICAgICAgICAgOyBwb3NfYm9sID0gcG9zX2JvbF9fMDA4X1xuICAgICAgICAgOyBwb3NfY251bSA9IHBvc19jbnVtX18wMTBfXG4gICAgICAgICB9IC0+XG4gICAgICBsZXQgYm5kc19fMDAzXyA9IFtdIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfY251bVwiOyBhcmdfXzAxMV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfYm9sXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfbG51bVwiOyBhcmdfXzAwN18gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19mbmFtZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwM19cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIFBweF9oZXJlLmxpZnRfcG9zaXRpb25fYXNfc3RyaW5nLiAqKVxubGV0IG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbCA9XG4gIFN0cmluZy5jb25jYXRcbiAgICBbIHBvc19mbmFtZTsgXCI6XCI7IEludC50b19zdHJpbmcgcG9zX2xudW07IFwiOlwiOyBJbnQudG9fc3RyaW5nIChwb3NfY251bSAtIHBvc19ib2wpIF1cbjs7XG5cbmxldCB0b19zdHJpbmcgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCB9ID1cbiAgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpc3QwXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIChmIHggOiBfIEVpdGhlcjAudCkgd2l0aFxuICAgICAgIHwgRmlyc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmRcbiAgICAgICB8IFNlY29uZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBDYW1sLnJlc3VsdCA9XG4gIHwgT2sgb2YgJ2FcbiAgfCBFcnJvciBvZiAnYlxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgZXF1YWwsIGhhc2hdXG5cbmxldCB0X29mX3NleHAgOlxuICAnYSAnYi5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE3XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoYV9fMDE3XywgYl9fMDE4XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJyZXN1bHQubWwudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcIm9rXCIgfCBcIk9rXCIpIGFzIF90YWdfXzAwOF8pIDo6IHNleHBfYXJnc19fMDA5XykgYXNcbiAgICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDA5XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDEwXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgICBPayByZXMwX18wMTFfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAwOF9cbiAgICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgX3RhZ19fMDEzXykgOjogc2V4cF9hcmdzX18wMTRfKSBhc1xuICAgICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTRfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTVfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICAgIEVycm9yIHJlczBfXzAxNl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgICAgX3RhZ19fMDEzX1xuICAgICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwib2tcIiB8IFwiT2tcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDI1XyBiX18wMjZfKVxuICAgICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxOV8gX29mX2JfXzAyMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDIyXyBdXG4gICAgICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyNF8gPSBfb2ZfYl9fMDIwXyBhcmcwX18wMjNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkVycm9yXCI7IHJlczBfXzAyNF8gXVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJPa1wiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXJyb3JcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyN18gYl9fMDI4XyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMjdfIGJfXzAyOF9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAyN18sIGJfXzAyOF8gd2l0aFxuICAgIHwgT2sgX2FfXzAyOV8sIE9rIF9iX18wMzBfIC0+IF9jbXBfX2EgX2FfXzAyOV8gX2JfXzAzMF9cbiAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICB8IF8sIE9rIF8gLT4gMVxuICAgIHwgRXJyb3IgX2FfXzAzMV8sIEVycm9yIF9iX18wMzJfIC0+IF9jbXBfX2IgX2FfXzAzMV8gX2JfXzAzMl8pXG47O1xuXG5sZXQgZXF1YWwgOlxuICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDMzXyBiX18wMzRfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAzM18gYl9fMDM0X1xuICB0aGVuIHRydWVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDMzXywgYl9fMDM0XyB3aXRoXG4gICAgfCBPayBfYV9fMDM1XywgT2sgX2JfXzAzNl8gLT4gX2NtcF9fYSBfYV9fMDM1XyBfYl9fMDM2X1xuICAgIHwgT2sgXywgXyAtPiBmYWxzZVxuICAgIHwgXywgT2sgXyAtPiBmYWxzZVxuICAgIHwgRXJyb3IgX2FfXzAzN18sIEVycm9yIF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGEgYi5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGEsIGIpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgT2sgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICB8IEVycm9yIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbjs7XG5cbltAQEBlbmRdXG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IGYgeFxuICAgIDs7XG5cbiAgICBsZXQgbWFwIHggfmYgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgICB8IE9rIHggLT4gT2sgKGYgeClcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgbGV0IHJldHVybiB4ID0gT2sgeFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgY2hlY2tfb2sgY2hlY2tfZXJyb3IgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIG9rIC0+IGNoZWNrX29rIG9rXG4gIHwgRXJyb3IgZXJyb3IgLT4gY2hlY2tfZXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBmYWlsIHggPSBFcnJvciB4XG5sZXQgZmFpbGYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGZhaWwgZm9ybWF0XG5cbmxldCBtYXBfZXJyb3IgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIF8gYXMgeCAtPiB4XG4gIHwgRXJyb3IgeCAtPiBFcnJvciAoZiB4KVxuOztcblxubW9kdWxlIEVycm9yID0gTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBPayBfIGFzIG9rIC0+IG9rXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcF9lcnJvclxuICAgIGxldCByZXR1cm4gZSA9IEVycm9yIGVcbiAgZW5kKVxuXG5sZXQgaXNfb2sgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBmYWxzZVxuICB8IEVycm9yIF8gLT4gdHJ1ZVxuOztcblxubGV0IG9rID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IFNvbWUgeFxuICB8IEVycm9yIF8gLT4gTm9uZVxuOztcblxubGV0IGVycm9yID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IE5vbmVcbiAgfCBFcnJvciB4IC0+IFNvbWUgeFxuOztcblxubGV0IG9mX29wdGlvbiBvcHQgfmVycm9yID1cbiAgbWF0Y2ggb3B0IHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT4gRXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBpdGVyIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayB4IC0+IGYgeFxuICB8IEVycm9yIF8gLT4gKClcbjs7XG5cbmxldCBpdGVyX2Vycm9yIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayBfIC0+ICgpXG4gIHwgRXJyb3IgeCAtPiBmIHhcbjs7XG5cbmxldCB0b19laXRoZXIgOiBfIHQgLT4gXyBFaXRoZXIudCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBGaXJzdCB4XG4gIHwgRXJyb3IgeCAtPiBTZWNvbmQgeFxuOztcblxubGV0IG9mX2VpdGhlciA6IF8gRWl0aGVyLnQgLT4gXyB0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IE9rIHhcbiAgfCBTZWNvbmQgeCAtPiBFcnJvciB4XG47O1xuXG5sZXQgb2tfaWZfdHJ1ZSBib29sIH5lcnJvciA9IGlmIGJvb2wgdGhlbiBPayAoKSBlbHNlIEVycm9yIGVycm9yXG5cbmxldCB0cnlfd2l0aCBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIGV4blxuOztcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IG9rX29yX2ZhaWx3aXRoID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBzdHIgLT4gZmFpbHdpdGggc3RyXG47O1xuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdvaywgJ2VycikgX3Jlc3VsdCA9ICgnb2ssICdlcnIpIHQgPVxuICAgIHwgT2sgb2YgJ29rXG4gICAgfCBFcnJvciBvZiAnZXJyXG5cbiAgbGV0IGlzX2Vycm9yID0gaXNfZXJyb3JcbiAgbGV0IGlzX29rID0gaXNfb2tcbmVuZFxuXG5sZXQgY29tYmluZSB0MSB0MiB+b2sgfmVyciA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgT2sgXywgRXJyb3IgZSB8IEVycm9yIGUsIE9rIF8gLT4gRXJyb3IgZVxuICB8IE9rIG9rMSwgT2sgb2syIC0+IE9rIChvayBvazEgb2syKVxuICB8IEVycm9yIGVycjEsIEVycm9yIGVycjIgLT4gRXJyb3IgKGVyciBlcnIxIGVycjIpXG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QxLnBhcnRpdGlvbl9tYXAgbCB+Zjp0b19laXRoZXIgaW5cbiAgbWF0Y2ggZXJycyB3aXRoXG4gIHwgW10gLT4gT2sgb2tcbiAgfCBfIDo6IF8gLT4gRXJyb3IgZXJyc1xuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IG1hcCAoY29tYmluZV9lcnJvcnMgbCkgfmY6KGZ1biAoXyA6IHVuaXQgbGlzdCkgLT4gKCkpXG5cbigqIGRlcHJlY2F0ZWQgYmluZGluZyBmb3IgZXhwb3J0IG9ubHkgKilcbmxldCBva19mc3QgPSB0b19laXRoZXJcbiIsIigqKiBQcm92aWRlcyBnZW5lcmljIHNpZ25hdHVyZXMgZm9yIGNvbnRhaW5lciBkYXRhIHN0cnVjdHVyZXMuXG5cbiAgICBUaGVzZSBzaWduYXR1cmVzIGluY2x1ZGUgZnVuY3Rpb25zIChbaXRlcl0sIFtmb2xkXSwgW2V4aXN0c10sIFtmb3JfYWxsXSwgLi4uKSB0aGF0XG4gICAgeW91IHdvdWxkIGV4cGVjdCB0byBmaW5kIGluIGFueSBjb250YWluZXIuIFVzZWQgYnkgaW5jbHVkaW5nIFtDb250YWluZXIuUzBdIG9yXG4gICAgW0NvbnRhaW5lci5TMV0gaW4gdGhlIHNpZ25hdHVyZSBmb3IgZXZlcnkgY29udGFpbmVyLWxpa2UgZGF0YSBzdHJ1Y3R1cmUgKFtBcnJheV0sXG4gICAgW0xpc3RdLCBbU3RyaW5nXSwgLi4uKSB0byBlbnN1cmUgYSBjb25zaXN0ZW50IGludGVyZmFjZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCoqIFtDb250aW51ZV9vcl9zdG9wLnRdIGlzIHVzZWQgYnkgdGhlIFtmXSBhcmd1bWVudCB0byBbZm9sZF91bnRpbF0gaW4gb3JkZXIgdG9cbiAgICAgIGluZGljYXRlIHdoZXRoZXIgZm9sZGluZyBzaG91bGQgY29udGludWUsIG9yIHN0b3AgZWFybHkuXG5cbiAgICAgIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuQ29udGludWVfb3Jfc3RvcFxuICAqKVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgICB8IENvbnRpbnVlIG9mICdhXG4gICAgICB8IFN0b3Agb2YgJ2JcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuU3VtbWFibGUgKilcbm1vZHVsZSB0eXBlIFN1bW1hYmxlID0gc2lnXG4gIHR5cGUgdFxuXG4gICgqKiBUaGUgcmVzdWx0IG9mIHN1bW1pbmcgbm8gdmFsdWVzLiAqKVxuICB2YWwgemVybyA6IHRcblxuICAoKiogQW4gb3BlcmF0aW9uIHRoYXQgY29tYmluZXMgdHdvIFt0XSdzIGFuZCBoYW5kbGVzIFt6ZXJvICsgeF0gYnkganVzdCByZXR1cm5pbmcgW3hdLFxuICAgICAgYXMgd2VsbCBhcyBpbiB0aGUgc3ltbWV0cmljIGNhc2UuICopXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgbW9ub21vcnBoaWMgY29udGFpbmVyIC0gYSBjb250YWluZXIgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCB0eXBlLCBlLmcuLFxuICAgIHN0cmluZywgd2hpY2ggaXMgYSBjb250YWluZXIgb2YgY2hhcmFjdGVycyAoW3R5cGUgZWx0ID0gY2hhcl0pIGFuZCBuZXZlciBvZiBhbnl0aGluZ1xuICAgIGVsc2UuICopXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBlbHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG5cbiAgKCoqIFtpdGVyXSBtdXN0IGFsbG93IGV4Y2VwdGlvbnMgcmFpc2VkIGluIFtmXSB0byBlc2NhcGUsIHRlcm1pbmF0aW5nIHRoZSBpdGVyYXRpb25cbiAgICAgIGNsZWFubHkuICBUaGUgc2FtZSBob2xkcyBmb3IgYWxsIGZ1bmN0aW9ucyBiZWxvdyB0YWtpbmcgYW4gW2ZdLiAqKVxuICB2YWwgaXRlciA6IHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwLiBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWVcbiAgICAgIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiBfIHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6IF8gdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiBfIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZVxuICAgICAgZWxlbWVudHMgd2lsbCBiZSBzdW1tZWQgaXMgdW5zcGVjaWZpZWQuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gXyB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiBfIHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiBfIHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogXyB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gKilcbiAgdmFsIG1pbl9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIHBvbHltb3JwaGljIGNvbnRhaW5lciwgZS5nLiwgWydhIGxpc3RdIG9yIFsnYSBhcnJheV0uICopXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIFtlcXVhbF0uICopXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XSAgKilcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiAnYSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbmltdW0gKHJlc3AgbWF4aW11bSkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAgW2NvbXBhcmVdIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdFxuICAgICAgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZSBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5IGFzIFtmb2xkXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5XG4gICAgICBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICsncGhhbnRvbSkgdFxuXG4gIGluY2x1ZGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEdlbmVyaWMgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSBlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgZWx0IGFycmF5XG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIGVsdCAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBlbHQgYXJyYXlcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2dlbl9hcmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogVGhlIFtpdGVyXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2l0ZXJdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lIFtpdGVyXVxuICAgICAgdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBpdGVyIHQgfmYgPSBDb250YWluZXIuaXRlciB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtpdGVyXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtpdGVyXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeVxuICAgICAgYXMgd2VsbC4gKilcbiAgdmFsIGl0ZXIgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdCBdXG5cbiAgKCoqIFRoZSBbbGVuZ3RoXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2xlbmd0aF0gZnVuY3Rpb24uICBbYERlZmluZV91c2luZ19mb2xkXSBtZWFucyB0byBkZWZpbmVcbiAgICAgIFtsZW5ndGhdIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgbGVuZ3RoIHQgfmYgPSBDb250YWluZXIubGVuZ3RoIH5mb2xkIHQgfmZcbiAgICAgIF19XG5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LiAgU2V2ZXJhbCBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW0NvbnRhaW5lci5NYWtlXSBhcmUgZGVmaW5lZCBpblxuICAgICAgdGVybXMgb2YgW2xlbmd0aF0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbbGVuZ3RoXSB3aWxsIGltcHJvdmUgdGhlaXJcbiAgICAgIGVmZmljaWVuY3kgYXMgd2VsbC4gKilcbiAgdmFsIGxlbmd0aCA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAnYSB0IC0+IGludCBdXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBNb25hZC5JZGVudC50XG5cbm1vZHVsZSB0eXBlIE1ha2UwX2FyZyA9IHNpZ1xuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICB0eXBlIHRcblxuICBpbmNsdWRlIE1ha2VfZ2VuX2FyZyB3aXRoIHR5cGUgJ2EgdCA6PSB0IGFuZCB0eXBlICdhIGVsdCA6PSBFbHQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbnRhaW5lciA9IHNpZ1xuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRXhwb3J0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMwID0gUzBcbiAgbW9kdWxlIHR5cGUgUzBfcGhhbnRvbSA9IFMwX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBTMV9waGFudG9tX2ludmFyaWFudCA9IFMxX3BoYW50b21faW52YXJpYW50XG4gIG1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBTMV9waGFudG9tXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWMgPSBHZW5lcmljXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWNfcGhhbnRvbSA9IEdlbmVyaWNfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBTdW1tYWJsZSA9IFN1bW1hYmxlXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2ZvbGRdLlxuXG4gICAgICBFLmcuOiBbaXRlciB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpXS4gKilcblxuICB0eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuICB0eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbiAgdmFsIGl0ZXIgOiBmb2xkOigndCwgJ2EsIHVuaXQpIGZvbGQgLT4gKCd0LCAnYSkgaXRlclxuICB2YWwgY291bnQgOiBmb2xkOigndCwgJ2EsIGludCkgZm9sZCAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgbWluX2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBsZW5ndGggOiBmb2xkOigndCwgXywgaW50KSBmb2xkIC0+ICd0IC0+IGludFxuICB2YWwgdG9fbGlzdCA6IGZvbGQ6KCd0LCAnYSwgJ2EgbGlzdCkgZm9sZCAtPiAndCAtPiAnYSBsaXN0XG5cbiAgdmFsIHN1bVxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ3N1bSkgZm9sZFxuICAgIC0+IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICd0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYikgZm9sZFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdlKSBSZXN1bHQudClcbiAgICAtPiAndFxuICAgIC0+ICgnYiwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBmb2xkOigndCwgJ2EsICdiKSBmb2xkXG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ3RcbiAgICAtPiAnZmluYWxcblxuICAoKiogR2VuZXJpYyBkZWZpbml0aW9ucyBvZiBjb250YWluZXIgb3BlcmF0aW9ucyBpbiB0ZXJtcyBvZiBbaXRlcl0gYW5kIFtsZW5ndGhdLiAqKVxuICB2YWwgaXNfZW1wdHkgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gYm9vbFxuXG4gIHZhbCBleGlzdHMgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmaW5kIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2FycmF5IDogbGVuZ3RoOid0IGxlbmd0aCAtPiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gJ2EgYXJyYXlcblxuICAoKiogVGhlIGlkaW9tIGZvciB1c2luZyBbQ29udGFpbmVyLk1ha2VdIGlzIHRvIGJpbmQgdGhlIHJlc3VsdGluZyBtb2R1bGUgYW5kIHRvXG4gICAgICBleHBsaWNpdGx5IGltcG9ydCBlYWNoIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBvbmUgd2FudHM6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgICBsZXQgY291bnQgICAgPSBDLmNvdW50XG4gICAgICAgIGxldCBleGlzdHMgICA9IEMuZXhpc3RzXG4gICAgICAgIGxldCBmaW5kICAgICA9IEMuZmluZFxuICAgICAgICAoKiAuLi4gKilcbiAgICAgIF19XG5cbiAgICAgIFRoaXMgaXMgcHJlZmVyYWJsZSB0bzpcblxuICAgICAge1tcbiAgICAgICAgaW5jbHVkZSBDb250YWluZXIuTWFrZSAoc3RydWN0IC4uLiBlbmQpXG4gICAgICBdfVxuXG4gICAgICBiZWNhdXNlIHRoZSBbaW5jbHVkZV0gbWFrZXMgaXQgdG9vIGVhc3kgdG8gc2hhZG93IHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICAgY29udGFpbmVyIGZ1bmN0aW9ucyAoW2xlbmd0aF0gYmVpbmcgYSBjb21tb24gb25lKS5cblxuICAgICAgW0NvbnRhaW5lci5NYWtlMF0gaXMgbGlrZSBbQ29udGFpbmVyLk1ha2VdLCBidXQgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lcnMgbGlrZVxuICAgICAgW3N0cmluZ10uICopXG4gIG1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5cbiAgbW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBlbHQgOj0gVC5FbHQudFxuXG4gIG1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICAgIEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBDb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxudHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxudHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxubGV0IGl0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKVxubGV0IGNvdW50IH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gYSAtPiBpZiBmIGEgdGhlbiBuICsgMSBlbHNlIG4pXG5cbmxldCBzdW0gKHR5cGUgYSkgfmZvbGQgKG1vZHVsZSBNIDogU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgZm9sZCB0IH5pbml0Ok0uemVybyB+ZjooZnVuIG4gYSAtPiBNLiggKyApIG4gKGYgYSkpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIFJlc3VsdC5Pa1xuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgUmVzdWx0Lk9rIHggLT4geFxuICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGUpKSlcbjs7XG5cbmxldCBmb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIH5maW5pc2ggdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIGZpbmlzaFxuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSB4IC0+IHhcbiAgICAgICAgIHwgU3RvcCB4IC0+IHJldHVybiB4KSkpXG47O1xuXG5sZXQgbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWluIC0+IGlmIGNvbXBhcmUgbWluIGVsdCA+IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYylcbjs7XG5cbmxldCBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtYXggLT4gaWYgY29tcGFyZSBtYXggZWx0IDwgMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKVxuOztcblxubGV0IGxlbmd0aCB+Zm9sZCBjID0gZm9sZCBjIH5pbml0OjAgfmY6KGZ1biBhY2MgXyAtPiBhY2MgKyAxKVxuXG5sZXQgaXNfZW1wdHkgfml0ZXIgYyA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIF8gLT4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZXhpc3RzIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGZvcl9hbGwgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgbm90IChmIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXAgfml0ZXIgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgZmluZCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiAoU29tZSB4KSk7XG4gICAgTm9uZSlcbjs7XG5cbmxldCB0b19saXN0IH5mb2xkIGMgPSBMaXN0LnJldiAoZm9sZCBjIH5pbml0OltdIH5mOihmdW4gYWNjIHggLT4geCA6OiBhY2MpKVxuXG5sZXQgdG9fYXJyYXkgfmxlbmd0aCB+aXRlciBjID1cbiAgbGV0IGFycmF5ID0gcmVmIFt8fF0gaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICBpdGVyIGMgfmY6KGZ1biB4IC0+XG4gICAgaWYgIWkgPSAwIHRoZW4gYXJyYXkgOj0gQXJyYXkuY3JlYXRlIH5sZW46KGxlbmd0aCBjKSB4O1xuICAgICFhcnJheS4oIWkpIDwtIHg7XG4gICAgaW5jciBpKTtcbiAgIWFycmF5XG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDogc2lnXG4gIGluY2x1ZGUgR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kID0gc3RydWN0XG4gIGxldCBmb2xkID0gVC5mb2xkXG5cbiAgbGV0IGl0ZXIgPVxuICAgIG1hdGNoIFQuaXRlciB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXIgLT4gaXRlclxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXIgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBsZW5ndGggPVxuICAgIG1hdGNoIFQubGVuZ3RoIHdpdGhcbiAgICB8IGBDdXN0b20gbGVuZ3RoIC0+IGxlbmd0aFxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IC0+IGxlbmd0aCB+Zm9sZCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBpc19lbXB0eSB+aXRlciB0XG4gIGxldCBzdW0gbSB0ID0gc3VtIH5mb2xkIG0gdFxuICBsZXQgY291bnQgdCB+ZiA9IGNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzIH5pdGVyIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGwgfml0ZXIgdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmQgfml0ZXIgdCB+ZlxuICBsZXQgdG9fbGlzdCB0ID0gdG9fbGlzdCB+Zm9sZCB0XG4gIGxldCB0b19hcnJheSB0ID0gdG9fYXJyYXkgfmxlbmd0aCB+aXRlciB0XG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IGZvbGRfcmVzdWx0IHQgfmZvbGQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gZm9sZF91bnRpbCB0IH5mb2xkIH5pbml0IH5mIH5maW5pc2hcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuXG4gIGxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IGVsdCA9IGV4aXN0cyB0IH5mOihULkVsdC5lcXVhbCBlbHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDYW1sLkxhenlcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsYXp5X3Rfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGF6eV90XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuIHggPSBmcm9tX3ZhbCB4XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGxhenkgKGZvcmNlIChmIChmb3JjZSB0KSkpXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBUX3VuZm9yY2luZyA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGlmIGlzX3ZhbCB0IHRoZW4gc2V4cF9vZl9hIChmb3JjZSB0KSBlbHNlIHNleHBfb2Zfc3RyaW5nIFwiPHVuZm9yY2VkIGxhenk+XCJcbiAgOztcbmVuZFxuIiwiKCogU3BsaXQgb2ZmIHRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCBbT3JfZXJyb3JdLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubGV0IHNsb3dfY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgcG9zaXRpb246ICVkXCIgcG9zICgpO1xuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgbGVuZ3RoOiAlZFwiIGxlbiAoKTtcbiAgKCogV2UgdXNlIFtwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiB0b3RhbF9sZW5ndGhdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwicG9zICsgbGVuIHBhc3QgZW5kOiAlZCArICVkID4gJWRcIiBwb3MgbGVuIHRvdGFsX2xlbmd0aCAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gICgqIFRoaXMgaXMgYmV0dGVyIHRoYW4gW3Nsb3dfY2hlY2tfcG9zX2xlbl9leG5dIGZvciB0d28gcmVhc29uczpcblxuICAgICAtIG11Y2ggbGVzcyBpbmxpbmVkIGNvZGVcbiAgICAgLSBvbmx5IG9uZSBjb25kaXRpb25hbCBqdW1wXG5cbiAgICAgVGhlIHJlYXNvbiBpdCB3b3JrcyBpcyB0aGF0IGNoZWNraW5nIFs8IDBdIGlzIHRlc3RpbmcgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0LCBzb1xuICAgICBbYSA8IDAgfHwgYiA8IDBdIGlzIHRoZSBzYW1lIGFzIFthIGxvciBiIDwgMF0uXG5cbiAgICAgW3BvcyArIGxlbl0gY2FuIG92ZXJmbG93LCBzbyBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSBpcyBub3QgZXF1aXZhbGVudCB0b1xuICAgICBbdG90YWxfbGVuZ3RoIC0gbGVuIC0gcG9zIDwgMF0sIHdlIG5lZWQgdG8gdGVzdCBmb3IgW3BvcyArIGxlbl0gb3ZlcmZsb3cgYXNcbiAgICAgd2VsbC4gKilcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgaWYgcG9zIGxvciBsZW4gbG9yIHN0b3AgbG9yICh0b3RhbF9sZW5ndGggLSBzdG9wKSA8IDBcbiAgdGhlbiBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iLCJcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3QgOiBpbnQgYXJyYXlcbiAgICA7IG11dGFibGUgaWR4IDogaW50XG4gICAgfVxuXG4gIGxldCBvZl9zdGF0ZSA6IENhbWwuUmFuZG9tLlN0YXRlLnQgLT4gdCA9IENhbWwuT2JqLm1hZ2ljXG5lbmRcblxubGV0IGFzc2lnbiB0MSB0MiA9XG4gIGxldCB0MSA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDEpIGluXG4gIGxldCB0MiA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDIpIGluXG4gIEFycmF5LmJsaXQgfnNyYzp0Mi5zdCB+c3JjX3BvczowIH5kc3Q6dDEuc3QgfmRzdF9wb3M6MCB+bGVuOihBcnJheS5sZW5ndGggdDEuc3QpO1xuICB0MS5pZHggPC0gdDIuaWR4XG5cbmxldCBtYWtlX2RlZmF1bHQgZGVmYXVsdCA9IGRlZmF1bHRcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBnZXRfc3RhdGUgc3RhdGUgPSBzdGF0ZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIENoYXIgPSBDaGFyMFxuXG4oKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGRvZXMgbm90IGV4cG9zZVxuICAgW0NhbWwuUmFuZG9tLlN0YXRlLmRlZmF1bHRdLCB3ZSBoYXZlIHRvIGNvbnN0cnVjdCBvdXIgb3duLiAgV2UgdGhlbiBidWlsZCB0aGVcbiAgIFtDYW1sLlJhbmRvbS5pbnRdLCBbQ2FtbC5SYW5kb20uYm9vbF0gZnVuY3Rpb25zIGFuZCBmcmllbmRzIHVzaW5nIHRoYXQgZGVmYXVsdCBzdGF0ZSBpblxuICAgZXhhY3RseSB0aGUgc2FtZSB3YXkgYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkuXG5cbiAgIE9uZSBvdGhlciB0cmlja2luZXNzIGlzIHRoYXQgd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHVuZXhwb3NlZCBbQ2FtbC5SYW5kb20uU3RhdGUuYXNzaWduXVxuICAgZnVuY3Rpb24sIHdoaWNoIGFjY2Vzc2VzIHRoZSB1bmV4cG9zZWQgc3RhdGUgcmVwcmVzZW50YXRpb24uICBTbywgd2UgY29weSB0aGVcbiAgIFtTdGF0ZS5yZXByXSB0eXBlIGRlZmluaXRpb24gYW5kIFthc3NpZ25dIGZ1bmN0aW9uIHRvIGhlcmUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSxcbiAgIGFuZCB1c2UgW09iai5tYWdpY10gdG8gZ2V0IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gKilcblxuKCogUmVncmVzc2lvbiB0ZXN0cyBvdWdodCB0byBiZSBkZXRlcm1pbmlzdGljIGJlY2F1c2UgdGhhdCB3YXkgYW55b25lIHdobyBicmVha3MgdGhlIHRlc3RcbiAgIGtub3dzIHRoYXQgaXQncyB0aGVpciBjb2RlIHRoYXQgYnJva2UgdGhlIHRlc3QuICBJZiB0ZXN0cyBhcmUgbm9uZGV0ZXJtaW5pc3RpYywgYSB0ZXN0XG4gICBmYWlsdXJlIG1heSBpbnN0ZWFkIGhhcHBlbiBiZWNhdXNlIHRoZSB0ZXN0IHJ1bm5lciBnb3QgdW5sdWNreSBhbmQgdW5jb3ZlcmVkIGFuXG4gICBleGlzdGluZyBidWcgaW4gdGhlIGNvZGUgc3VwcG9zZWRseSBiZWluZyBcInByb3RlY3RlZFwiIGJ5IHRoZSB0ZXN0IGluIHF1ZXN0aW9uLiAqKVxubGV0IGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHMgPVxuICBpZiBhbV90ZXN0aW5nXG4gIHRoZW4gKFxuICAgIG1hdGNoIGFsbG93X2luX3Rlc3RzIHdpdGhcbiAgICB8IFNvbWUgdHJ1ZSAtPiAoKVxuICAgIHwgTm9uZSB8IFNvbWUgZmFsc2UgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nIFJhbmRvbSB3aXRoIGEgbm9uZGV0ZXJtaW5pc3RpYyBzZWVkIGlzIGZvcmJpZGRlbiBpbiBpbmxpbmUgdGVzdHNcIilcbjs7XG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkIDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubGV0IHJhbmRvbV9zZWVkID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gIHJhbmRvbV9zZWVkICgpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogV2UgYWxsb3cgbGF6aW5lc3Mgb25seSBmb3IgdGhlIGRlZmluaXRpb24gb2YgW2RlZmF1bHRdLCBiZWxvdywgd2hpY2ggbWF5IGxhemlseSBjYWxsXG4gICAgIFttYWtlX3NlbGZfaW5pdF0uIEZvciBhbGwgb3RoZXIgcHVycG9zZXMsIHdlIGNyZWF0ZSBhbmQgdXNlIFt0XSBlYWdlcmx5LiAqKVxuICB0eXBlIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS50IExhenkudFxuXG4gIGxldCBiaXRzIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHQpXG4gIGxldCBib29sIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5ib29sIChMYXp5LmZvcmNlIHQpXG4gIGxldCBpbnQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDMyIHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDMyIChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDY0IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDY0IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5uYXRpdmVpbnQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgbWFrZSBzZWVkID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUubWFrZSBzZWVkKVxuICBsZXQgY29weSB0ID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUuY29weSAoTGF6eS5mb3JjZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBMYXp5LmZyb21fdmFsIChDYW1sLlJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcbiAgOztcblxuICBsZXQgYXNzaWduID0gUmFuZG9tX3JlcHIuYXNzaWduXG5cbiAgbGV0IGZ1bGxfaW5pdCB0IHNlZWQgPSBhc3NpZ24gdCAobWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIENhbWwuUmFuZG9tLiBIb3dldmVyLCBiZWNhdXNlIFtnZXRfc3RhdGVdIHJldHVybnNcbiAgICAgICAgIGEgY29weSwgQmFzZS5SYW5kb20gYW5kIE9DYW1sLlJhbmRvbSBhcmUgbm90IHVzaW5nIHRoZSBzYW1lIHN0YXRlLiBJZiBhIHByb2dyYW1cbiAgICAgICAgIHVzZWQgYm90aCwgZWFjaCBvZiB0aGVtIHdvdWxkIGdvIHRocm91Z2ggdGhlIHNhbWUgc2VxdWVuY2Ugb2YgcmFuZG9tIGJpdHMuIFRvXG4gICAgICAgICBhdm9pZCB0aGF0LCB3ZSByZXNldCBPQ2FtbCdzIHJhbmRvbSBzdGF0ZSB0byBhIGRpZmZlcmVudCBzZWVkLCBnaXZpbmcgaXQgYVxuICAgICAgICAgZGlmZmVyZW50IHNlcXVlbmNlLiAqKVxuICAgICAgbGV0IHQgPSBDYW1sLlJhbmRvbS5nZXRfc3RhdGUgKCkgaW5cbiAgICAgIENhbWwuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgTGF6eS5mcm9tX3ZhbCB0KVxuICAgIGVsc2VcbiAgICAgIGxhenlcbiAgICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgICAgV2UgZm9yY2UgdGhlIHJhbmRvbSBpbml0aWFsaXphdGlvbiB0byBiZSBsYXp5IHNvIHRoYXQgd2UgZG8gbm90IHBheSBhbnkgY29zdFxuICAgICAgICAgICBmb3IgaXQgaW4gcHJvZ3JhbXMgdGhhdCBkbyBub3QgdXNlIHJhbmRvbW5lc3MuICopXG4gICAgICAgIChMYXp5LmZvcmNlIChtYWtlX3NlbGZfaW5pdCAoKSkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIENhbWwuSW50NjQudG9faW50IChpbnQ2NCB0IChDYW1sLkludDY0Lm9mX2ludCBib3VuZCkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl8zMmJpdHMgdCBib3VuZCA9XG4gICAgKCogTm90IGFsd2F5cyB0cnVlIHdpdGggdGhlIEphdmFTY3JpcHQgYmFja2VuZC4gKilcbiAgICBpZiBib3VuZCA8PSAweDNGRkZGRkZGICgqICgxIGxzbCAzMCkgLSAxICopXG4gICAgdGhlbiBpbnQgdCBib3VuZFxuICAgIGVsc2UgQ2FtbC5JbnQzMi50b19pbnQgKGludDMyIHQgKENhbWwuSW50MzIub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDY0ID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+XG4gICAgICBsb2d4b3JcbiAgICAgICAgKGJpdHMgc3RhdGUpXG4gICAgICAgIChsb2d4b3IgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKSAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgNjApKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDMyID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBDYW1sLkludDY0LnRvX2ludCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSlcbiAgbGV0IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyBzdGF0ZSA9IENhbWwuSW50MzIudG9faW50IChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKVxuXG4gIGxldCBmdWxsX3JhbmdlX2ludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5OYXRpdmVpbnQub2ZfaW50MzIgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgcmFpc2VfY3Jvc3NlZF9ib3VuZHMgbmFtZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCBzdHJpbmdfb2ZfYm91bmQgPVxuICAgIFByaW50Zi5mYWlsd2l0aGZcbiAgICAgIFwiUmFuZG9tLiVzOiBjcm9zc2VkIGJvdW5kcyBbJXMgPiAlc11cIlxuICAgICAgbmFtZVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCBsb3dlcl9ib3VuZClcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgdXBwZXJfYm91bmQpXG4gICAgICAoKVxuICBbQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuICA7O1xuXG4gIGxldCBpbnRfaW5jbCA9XG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnRcIiBsbyBoaSBJbnQudG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBoaSAtIGxvIGluXG4gICAgICBpZiBkaWZmID0gSW50Lm1heF92YWx1ZVxuICAgICAgdGhlbiBsbyArIChmdWxsX3JhbmdlX2ludCBzdGF0ZSBsYW5kIEludC5tYXhfdmFsdWUpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMFxuICAgICAgdGhlbiBsbyArIGludCBzdGF0ZSAoSW50LnN1Y2MgZGlmZilcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgaW50MzJfaW5jbCA9XG4gICAgbGV0IG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQzMlwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwbFxuICAgICAgdGhlbiBhZGQgbG8gKGludDMyIHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfaW5jbCA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuTmF0aXZlaW50IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJuYXRpdmVpbnRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBuXG4gICAgICB0aGVuIGFkZCBsbyAobmF0aXZlaW50IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQ2NF9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDY0IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludDY0XCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBMXG4gICAgICB0aGVuIGFkZCBsbyAoaW50NjQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgKCogUmV0dXJuIGEgdW5pZm9ybWx5IHJhbmRvbSBmbG9hdCBpbiBbMCwgMSkuICopXG4gIGxldCByZWMgcmF3ZmxvYXQgc3RhdGUgPVxuICAgIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBzY2FsZSA9IDB4MXAtMzAgaW5cbiAgICAoKiAyXi0zMCAqKVxuICAgIGxldCByMSA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByMiA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByZXN1bHQgPSAoKHIxICouIHNjYWxlKSArLiByMikgKi4gc2NhbGUgaW5cbiAgICAoKiBXaXRoIHZlcnkgc21hbGwgcHJvYmFiaWxpdHksIHJlc3VsdCBjYW4gcm91bmQgdXAgdG8gMS4wLCBzbyBpbiB0aGF0IGNhc2UsIHdlIGp1c3RcbiAgICAgICB0cnkgYWdhaW4uICopXG4gICAgaWYgcmVzdWx0IDwgMS4wIHRoZW4gcmVzdWx0IGVsc2UgcmF3ZmxvYXQgc3RhdGVcbiAgOztcblxuICBsZXQgZmxvYXQgc3RhdGUgaGkgPSByYXdmbG9hdCBzdGF0ZSAqLiBoaVxuXG4gIGxldCBmbG9hdF9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiZmxvYXRcIiBsbyBoaSBDYW1sLnN0cmluZ19vZl9mbG9hdDtcbiAgICBsbyArLiBmbG9hdCBzdGF0ZSAoaGkgLS4gbG8pXG4gIDs7XG5lbmRcblxubGV0IGRlZmF1bHQgPSBSYW5kb21fcmVwci5tYWtlX2RlZmF1bHQgU3RhdGUuZGVmYXVsdFxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGludCB4ID0gU3RhdGUuaW50IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzXG4iLCIoKiogQW4gaW50ZXJuYWwtb25seSBtb2R1bGUgZmFjdG9yZWQgb3V0IGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBjb3JlX2FycmF5XG4gICAgYW5kIGNvcmVfbGlzdC4gIENvbnRhaW5zIGNvZGUgZm9yIHBlcm11dGluZyBhbiBhcnJheS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSA/KHBvcyA9IDApID9sZW4gdCA9XG4gICgqIENvcGllZCBmcm9tIFtPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMF0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlIHdoZW4gY29tcGlsaW5nXG4gICAgIHdpdGhvdXQgZmxhbWJkYS4gKilcbiAgbGV0IHRvdGFsX2xlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGwgLT4gbFxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAuY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGxldCBudW1fc3dhcHMgPSBsZW4gLSAxIGluXG4gIGZvciBpID0gbnVtX3N3YXBzIGRvd250byAxIGRvXG4gICAgbGV0IHRoaXNfaSA9IHBvcyArIGkgaW5cbiAgICAoKiBbcmFuZG9tX2ldIGlzIGRyYXduIGZyb20gW3Bvcyx0aGlzX2ldICopXG4gICAgbGV0IHJhbmRvbV9pID0gcG9zICsgUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGkgKyAxKSBpblxuICAgIHN3YXAgdCB0aGlzX2kgcmFuZG9tX2lcbiAgZG9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgY29uc3QgYyBfID0gY1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiB0aGlzIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbQ2FtbC5pZ25vcmVdICopXG5cbmxldCBub24gZiB4ID0gbm90IChmIHgpXG5cbmxldCBmb3JldmVyIGYgPVxuICBsZXQgcmVjIGZvcmV2ZXIgKCkgPVxuICAgIGYgKCk7XG4gICAgZm9yZXZlciAoKVxuICBpblxuICB0cnkgZm9yZXZlciAoKSB3aXRoXG4gIHwgZSAtPiBlXG47O1xuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoZXNlIGZ1bmN0aW9ucyBpcyB0byBwYXNzIGluIGZ1bmN0aW9uYWwgYXJndW1lbnRzIGFuZCBnZXRcbiAgIGZ1bmN0aW9ucyBhcyBhIHJlc3VsdC4gKilcbmxldCBjb21wb3NlIGYgZyB4ID0gZiAoZyB4KVxubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IHJlYyBhcHBseV9uX3RpbWVzIH5uIGYgeCA9IGlmIG4gPD0gMCB0aGVuIHggZWxzZSBhcHBseV9uX3RpbWVzIH5uOihuIC0gMSkgZiAoZiB4KVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTGVzc1xuICB8IEVxdWFsXG4gIHwgR3JlYXRlclxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgTGVzcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBFcXVhbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBHcmVhdGVyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBMZXNzOyBFcXVhbDsgR3JlYXRlciBdIDogdCBsaXN0KVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcIm9yZGVyaW5nLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSAtPiBMZXNzXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSAtPiBFcXVhbFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIC0+IEdyZWF0ZXJcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBMZXNzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkxlc3NcIlxuICAgIHwgRXF1YWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXF1YWxcIlxuICAgIHwgR3JlYXRlciAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJHcmVhdGVyXCJcbiAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTGVzc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiRXF1YWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkdyZWF0ZXJcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgX29yZGVyaW5nID0gdCA9XG4gICAgfCBMZXNzXG4gICAgfCBFcXVhbFxuICAgIHwgR3JlYXRlclxuZW5kXG5cbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTGVzcyBlbHNlIGlmIG4gPSAwIHRoZW4gRXF1YWwgZWxzZSBHcmVhdGVyXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IExlc3MgLT4gLTFcbiAgfCBFcXVhbCAtPiAwXG4gIHwgR3JlYXRlciAtPiAxXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5cblxuaW5jbHVkZSBMaXN0MVxuXG4oKiBUaGlzIGl0c2VsZiBpbmNsdWRlcyBbTGlzdDBdLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxpc3Rfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9saXN0XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsaXN0X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgT3JfdW5lcXVhbF9sZW5ndGhzID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBPayBvZiAnYVxuICAgIHwgVW5lcXVhbF9sZW5ndGhzXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNl8gYl9fMDA3XyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwNl8gYl9fMDA3X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDA2XywgYl9fMDA3XyB3aXRoXG4gICAgICB8IE9rIF9hX18wMDhfLCBPayBfYl9fMDA5XyAtPiBfY21wX19hIF9hX18wMDhfIF9iX18wMDlfXG4gICAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICAgIHwgXywgT2sgXyAtPiAxXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocywgVW5lcXVhbF9sZW5ndGhzIC0+IDApXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuICh0eXBlIGFfXzAxM18pIDogKChhX18wMTNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gYV9fMDEzXyB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDExXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMTBfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDEyXyBdXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsX2xlbmd0aHNcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5sZXQgb2ZfbGlzdCB0ID0gdFxuXG5sZXQgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGUgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgbGV0IG5leHRfaSA9IHN0cmlkZSBzdGFydF9pIGluXG4gIGxldCBvcmRlciB4IHkgPSBPcmRlcmluZy5vZl9pbnQgKGNvbXBhcmUgeCB5KSBpblxuICBsZXQgcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKSA9XG4gICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgdmFsdWVcIlxuICBpblxuICBsZXQgaW5pdGlhbF9zdHJpZGVfb3JkZXIgPVxuICAgIG1hdGNoIG9yZGVyIHN0YXJ0X2kgbmV4dF9pIHdpdGhcbiAgICB8IEVxdWFsIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICB8IExlc3MgLT4gYExlc3NcbiAgICB8IEdyZWF0ZXIgLT4gYEdyZWF0ZXJcbiAgaW5cbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGxldCBpX3RvX3N0b3Bfb3JkZXIgPSBvcmRlciBpIHN0b3BfaSBpblxuICAgIG1hdGNoIGlfdG9fc3RvcF9vcmRlciwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPlxuICAgICAgKCogaGF2ZW4ndCB5ZXQgcmVhY2hlZCBbc3RvcF9pXS4gQ29udGludWUuICopXG4gICAgICBsZXQgbmV4dF9pID0gc3RyaWRlIGkgaW5cbiAgICAgIChtYXRjaCBvcmRlciBpIG5leHRfaSwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgICAgIHwgRXF1YWwsIF8gLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCBjaGFuZ2UgZGlyZWN0aW9uXCJcbiAgICAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT4gbG9vcCBuZXh0X2kgKGkgOjogYWNjdW0pKVxuICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgKCogc3RlcHBlZCBwYXN0IFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICBhY2N1bVxuICAgIHwgRXF1YWwsIF8gLT5cbiAgICAgICgqIHJlYWNoZWQgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIChtYXRjaCBzdG9wIHdpdGhcbiAgICAgICB8IGBpbmNsdXNpdmUgLT4gaSA6OiBhY2N1bVxuICAgICAgIHwgYGV4Y2x1c2l2ZSAtPiBhY2N1bSlcbiAgaW5cbiAgbGV0IHN0YXJ0X2kgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfaVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBuZXh0X2lcbiAgaW5cbiAgcmV2IChsb29wIHN0YXJ0X2kgW10pXG47O1xuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBpZiBzdHJpZGUgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlOiBzdHJpZGUgbXVzdCBiZSBub24temVyb1wiO1xuICByYW5nZScgfmNvbXBhcmUgfnN0cmlkZTooZnVuIHggLT4geCArIHN0cmlkZSkgfnN0YXJ0IH5zdG9wIHN0YXJ0X2kgc3RvcF9pXG47O1xuXG5sZXQgaGQgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IF8gLT4gU29tZSB4XG47O1xuXG5sZXQgdGwgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IHQnIC0+IFNvbWUgdCdcbjs7XG5cbmxldCBudGggdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbnRoX2F1eCB0IG4gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYSA6OiB0IC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCB0IChuIC0gMSlcbiAgICBpblxuICAgIG50aF9hdXggdCBuKVxuOztcblxubGV0IG50aF9leG4gdCBuID1cbiAgbWF0Y2ggbnRoIHQgbiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJMaXN0Lm50aF9leG4gJWQgY2FsbGVkIG9uIGxpc3Qgb2YgbGVuZ3RoICVkXCIgbiAobGVuZ3RoIHQpICgpXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB1bm9yZGVyZWRfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbCB8IGwsIFtdIC0+IGxcbiAgfCBfIC0+IHJldl9hcHBlbmQgbDEgbDJcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiAtPiBsb29wIGEgYiAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfIHwgXywgW10gLT4gVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYiB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSBsMSBsMiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYiB9IC0+XG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIlxuICAgICAgbmFtZVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hKVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iKVxuICAgICAgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgyIGwxIGwyIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9jIDogJ2MgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiBsMyA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBjIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiwgYyB3aXRoXG4gICAgICB8IFtdLCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiwgXyA6OiBjIC0+IGxvb3AgYSBiIGMgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXywgXyB8IF8sIFtdLCBfIHwgXywgXywgW10gLT5cbiAgICAgICAgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYjsgdGFpbF9vZl9jID0gYyB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIGwzIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoM19leG4gbmFtZSBsMSBsMiBsMyA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYjsgdGFpbF9vZl9jIH0gLT5cbiAgICBsZXQgbjEgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSBpblxuICAgIGxldCBuMiA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iIGluXG4gICAgbGV0IG4zID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2MgaW5cbiAgICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkIHx8ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiBuMiBuMyAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMiBsMylcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbmxldCBpdGVyMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGl0ZXIyX29rIH5mKVxuXG5sZXQgaXRlcjJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJpdGVyMl9leG5cIiBsMSBsMjtcbiAgaXRlcjJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KHJldl9tYXAyX29rIH5mKVxuXG5sZXQgcmV2X21hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJyZXZfbWFwMl9leG5cIiBsMSBsMjtcbiAgcmV2X21hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBmb2xkMiBsMSBsMiB+aW5pdCB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvbGQyX29rIH5pbml0IH5mKVxuXG5sZXQgZm9sZDJfZXhuIGwxIGwyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb2xkMl9leG5cIiBsMSBsMjtcbiAgZm9sZDJfb2sgbDEgbDIgfmluaXQgfmZcbjs7XG5cbmxldCBmb3JfYWxsMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvcl9hbGwyX29rIH5mKVxuXG5sZXQgZm9yX2FsbDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb3JfYWxsMl9leG5cIiBsMSBsMjtcbiAgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBleGlzdHMyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZXhpc3RzMl9vayB+ZilcblxubGV0IGV4aXN0czJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJleGlzdHMyX2V4blwiIGwxIGwyO1xuICBleGlzdHMyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgZXF1YWwgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgYiA6OiBicyAtPiBlcXVhbCBhIGIgfHwgbG9vcCBlcXVhbCBhIGJzXG4gIGluXG4gIGxvb3AgZXF1YWwgYSB0XG47O1xuXG4oKiBUaGlzIGlzIGEgY29weSBvZiB0aGUgY29kZSBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIGFuIGV4dHJhIGV0YS1leHBhbnNpb24gdG9cbiAgIGF2b2lkIGNyZWF0aW5nIHBhcnRpYWwgY2xvc3VyZXMgKHNob3dlZCB1cCBmb3IgW2ZpbHRlcl0pIGluIHByb2ZpbGluZykuICopXG5sZXQgcmV2X2ZpbHRlciB0IH5mID1cbiAgbGV0IHJlYyBmaW5kIH5mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIGZpbmQgfmYgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgfmYgYWNjdSBsXG4gIGluXG4gIGZpbmQgfmYgW10gdFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gcmV2IChyZXZfZmlsdGVyIHQgfmYpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgbFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcilcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBsb29wIGxcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJlYyBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgeCA6OiB0IC0+IGlmIGYgeCB0aGVuIHggZWxzZSBmaW5kX2V4biB0IH5mXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiBpIHggdGhlbiBTb21lIChpLCB4KSBlbHNlIGxvb3AgKGkgKyAxKSBsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG5sZXQgZmluZGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gIGZpbmRpX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIGkgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgbClcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHRydWVcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCAmJiBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgfHwgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG4oKiogRm9yIHRoZSBjb250YWluZXIgaW50ZXJmYWNlLiAqKVxubGV0IGZvbGRfbGVmdCA9IGZvbGRcblxubGV0IHRvX2FycmF5ID0gQXJyYXkub2ZfbGlzdFxubGV0IHRvX2xpc3QgdCA9IHRcblxubGV0IG1heF9ub25fdGFpbGNhbGwgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDFfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3Mgc21hbGwuIFRoaXNcbiAgICAgbnVtYmVyIHdhcyB0YWtlbiBmcm9tIG9jYW1sI3N0ZGxpYi9saXN0Lm1sIHdoaWNoIGlzIGFsc28gZXF1YWwgdG8gdGhlIGRlZmF1bHQgbGltaXRcbiAgICAgb2YgcmVjdXJzaXZlIGNhbGwgaW4gdGhlIGpzX29mX29jYW1sIGNvbXBpbGVyIGJlZm9yZSBzd2l0Y2hpbmcgdG8gdHJhbXBvbGluZS4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuOztcblxuKCoqIFRhaWwgcmVjdXJzaXZlIHZlcnNpb25zIG9mIHN0YW5kYXJkIFtMaXN0XSBtb2R1bGUgKilcblxubGV0IHRhaWxfYXBwZW5kIGwxIGwyID0gcmV2X2FwcGVuZCAocmV2IGwxKSBsMlxuXG4oKiBUaGVyZSBhcmUgYSBmZXcgb3B0aW1pemVkIGxpc3Qgb3BlcmF0aW9ucyBoZXJlLCBpbmNsdWRpbmcgYXBwZW5kIGFuZCBtYXAuICBUaGVyZSBhcmVcbiAgIGJhc2ljYWxseSB0d28gb3B0aW1pemF0aW9ucyBpbiBwbGF5OiBsb29wIHVucm9sbGluZywgYW5kIGR5bmFtaWMgc3dpdGNoaW5nIGJldHdlZW5cbiAgIHN0YWNrIGFuZCBoZWFwIGFsbG9jYXRpb24uXG5cbiAgIFRoZSBsb29wLXVucm9sbGluZyBpcyBzdHJhaWdodGZvcndhcmQsIHdlIGp1c3QgdW5yb2xsIDUgbGV2ZWxzIG9mIHRoZSBsb29wLiAgVGhpcyBtYWtlc1xuICAgZWFjaCBpdGVyYXRpb24gZmFzdGVyLCBhbmQgYWxzbyByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzIGNvbnN1bWVkIHBlciBsaXN0XG4gICBlbGVtZW50LlxuXG4gICBUaGUgZHluYW1pYyBzd2l0Y2hpbmcgaXMgZG9uZSBieSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcywgYW5kIHRoZW5cbiAgIHN3aXRjaGluZyB0byB0aGUgXCJzbG93XCIgaW1wbGVtZW50YXRpb24gd2hlbiB3ZSBleGNlZWQgYSBnaXZlbiBsaW1pdC4gIFRoaXMgbWVhbnMgdGhhdFxuICAgc2hvcnQgbGlzdHMgdXNlIHRoZSBmYXN0IHN0YWNrLWFsbG9jYXRpb24gbWV0aG9kLCBhbmQgbG9uZyBsaXN0cyB1c2UgYSBzbG93ZXIgb25lIHRoYXRcbiAgIGRvZXNuJ3QgcmVxdWlyZSBzdGFjayBzcGFjZS4gKilcbmxldCByZWMgY291bnRfYXBwZW5kIGwxIGwyIGNvdW50ID1cbiAgbWF0Y2ggbDIgd2l0aFxuICB8IFtdIC0+IGwxXG4gIHwgXyAtPlxuICAgIChtYXRjaCBsMSB3aXRoXG4gICAgIHwgW10gLT4gbDJcbiAgICAgfCBbIHgxIF0gLT4geDEgOjogbDJcbiAgICAgfCBbIHgxOyB4MiBdIC0+IHgxIDo6IHgyIDo6IGwyXG4gICAgIHwgWyB4MTsgeDI7IHgzIF0gLT4geDEgOjogeDIgOjogeDMgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT4geDEgOjogeDIgOjogeDMgOjogeDQgOjogbDJcbiAgICAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgICAgIHgxXG4gICAgICAgOjogeDJcbiAgICAgICA6OiB4M1xuICAgICAgIDo6IHg0XG4gICAgICAgOjogeDVcbiAgICAgICA6OlxuICAgICAgIChpZiBjb3VudCA+IG1heF9ub25fdGFpbGNhbGxcbiAgICAgICAgdGhlbiB0YWlsX2FwcGVuZCB0bCBsMlxuICAgICAgICBlbHNlIGNvdW50X2FwcGVuZCB0bCBsMiAoY291bnQgKyAxKSkpXG47O1xuXG5sZXQgYXBwZW5kIGwxIGwyID0gY291bnRfYXBwZW5kIGwxIGwyIDBcblxuKCogQW4gb3JkaW5hcnkgdGFpbCByZWN1cnNpdmUgbWFwIGJ1aWxkcyB1cCBhbiBpbnRlcm1lZGlhdGUgKHJldmVyc2VkKSByZXByZXNlbnRhdGlvbixcbiAgIHdpdGggb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCBwZXIgZWxlbWVudC4gVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIGNodW5rc1xuICAgOSBvYmplY3RzIGludG8gb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCwgcmVkdWNpbmcgYWxsb2NhdGlvbiBhbmQgcGVyZm9ybWFuY2UgY29zdHNcbiAgIGFjY29yZGluZ2x5LiBOb3RlIHRoYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBsaXN0IGlzIGRvbmUgYnkgdGhlIHN0ZGxpYidzIG1hcFxuICAgZnVuY3Rpb24uICopXG5sZXQgdGFpbF9tYXAgeHMgfmYgPVxuICBsZXQgcmVjIHJpc2UgeXMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4geXNcbiAgICB8ICh5MCwgeTEsIHkyLCB5MywgeTQsIHk1LCB5NiwgeTcsIHk4KSA6OiBicyAtPlxuICAgICAgcmlzZSAoeTAgOjogeTEgOjogeTIgOjogeTMgOjogeTQgOjogeTUgOjogeTYgOjogeTcgOjogeTggOjogeXMpIGJzXG4gIGluXG4gIGxldCByZWMgZGl2ZSBicyA9IGZ1bmN0aW9uXG4gICAgfCB4MCA6OiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB4NiA6OiB4NyA6OiB4OCA6OiB4cyAtPlxuICAgICAgbGV0IHkwID0gZiB4MCBpblxuICAgICAgbGV0IHkxID0gZiB4MSBpblxuICAgICAgbGV0IHkyID0gZiB4MiBpblxuICAgICAgbGV0IHkzID0gZiB4MyBpblxuICAgICAgbGV0IHk0ID0gZiB4NCBpblxuICAgICAgbGV0IHk1ID0gZiB4NSBpblxuICAgICAgbGV0IHk2ID0gZiB4NiBpblxuICAgICAgbGV0IHk3ID0gZiB4NyBpblxuICAgICAgbGV0IHk4ID0gZiB4OCBpblxuICAgICAgZGl2ZSAoKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzKSB4c1xuICAgIHwgeHMgLT4gcmlzZSAobm9udGFpbF9tYXAgfmYgeHMpIGJzXG4gIGluXG4gIGRpdmUgW10geHNcbjs7XG5cbmxldCByZWMgY291bnRfbWFwIH5mIGwgY3RyID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBbIHgxIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgWyBmMSBdXG4gIHwgWyB4MTsgeDIgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgWyBmMTsgZjIgXVxuICB8IFsgeDE7IHgyOyB4MyBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgWyBmMTsgZjI7IGYzIF1cbiAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgWyBmMTsgZjI7IGYzOyBmNCBdXG4gIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgbGV0IGY1ID0gZiB4NSBpblxuICAgIGYxXG4gICAgOjogZjJcbiAgICA6OiBmM1xuICAgIDo6IGY0XG4gICAgOjogZjVcbiAgICA6OiAoaWYgY3RyID4gbWF4X25vbl90YWlsY2FsbCB0aGVuIHRhaWxfbWFwIH5mIHRsIGVsc2UgY291bnRfbWFwIH5mIHRsIChjdHIgKyAxKSlcbjs7XG5cbmxldCBtYXAgbCB+ZiA9IGNvdW50X21hcCB+ZiBsIDBcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgKCA+PnwgKSBsIGYgPSBtYXAgbCB+ZlxubGV0IG1hcDJfb2sgbDEgbDIgfmYgPSByZXYgKHJldl9tYXAyX29rIGwxIGwyIH5mKVxubGV0IG1hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihtYXAyX29rIH5mKVxuXG5sZXQgbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIm1hcDJfZXhuXCIgbDEgbDI7XG4gIG1hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwM19vayBsMSBsMiBsMyB+ZiA9XG4gIGxldCByZWMgbG9vcCBsMSBsMiBsMyBhYyA9XG4gICAgbWF0Y2ggbDEsIGwyLCBsMyB3aXRoXG4gICAgfCBbXSwgW10sIFtdIC0+IGFjXG4gICAgfCB4MSA6OiBsMSwgeDIgOjogbDIsIHgzIDo6IGwzIC0+IGxvb3AgbDEgbDIgbDMgKGYgeDEgeDIgeDMgOjogYWMpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsb29wIGwxIGwyIGwzIFtdXG47O1xuXG5sZXQgcmV2X21hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihyZXZfbWFwM19vayB+ZilcblxubGV0IHJldl9tYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwicmV2X21hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIHJldl9tYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgbWFwM19vayBsMSBsMiBsMyB+ZiA9IHJldiAocmV2X21hcDNfb2sgbDEgbDIgbDMgfmYpXG5sZXQgbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KG1hcDNfb2sgfmYpXG5cbmxldCBtYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwibWFwM19leG5cIiBsMSBsMiBsMztcbiAgbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZCBsMSBsMiB+ZiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IGggOjogdCAtPiByZXZfbWFwX2FwcGVuZCB+ZiB0IChmIGggOjogbDIpXG47O1xuXG5sZXQgdW56aXAgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMlxuICAgIHwgKHgsIHkpIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW11cbjs7XG5cbmxldCB1bnppcDMgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyIGwzID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMiwgbDNcbiAgICB8ICh4LCB5LCB6KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMikgKHogOjogbDMpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXSBbXVxuOztcblxubGV0IHppcF9leG4gbDEgbDIgPVxuICB0cnkgbWFwMl9vayB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMiB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gemlwX2V4bjogJWQgPD4gJWRcIiAobGVuZ3RoIGwxKSAobGVuZ3RoIGwyKSAoKVxuOztcblxubGV0IHppcCBsMSBsMiA9IG1hcDIgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDJcblxuKCoqIEFkZGl0aW9uYWwgbGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZXZfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaCA6OiB0IC0+IGxvb3AgKGkgKyAxKSAoZiBpIGggOjogYWNjKSB0XG4gIGluXG4gIGxvb3AgMCBbXSBsXG47O1xuXG5sZXQgbWFwaSBsIH5mID0gcmV2IChyZXZfbWFwaSBsIH5mKVxuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBpdGVyaSBsIH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgbCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBzbmQgKGZvbGQgdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB2IC0+IGkgKyAxLCBmIGkgYWNjIHYpKVxuOztcblxubGV0IGZpbHRlcmkgbCB+ZiA9XG4gIHJldiAoZm9sZGkgbCB+ZjooZnVuIHBvcyBhY2MgeCAtPiBpZiBmIHBvcyB4IHRoZW4geCA6OiBhY2MgZWxzZSBhY2MpIH5pbml0OltdKVxuOztcblxubGV0IHJlZHVjZSBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGhkIDo6IHRsIC0+IFNvbWUgKGZvbGQgfmluaXQ6aGQgfmYgdGwpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkIGwgfmYgPVxuICAoKiBDYWxsIHRoZSBcInNpemVcIiBvZiBhIHZhbHVlIHRoZSBudW1iZXIgb2YgbGlzdCBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjb21iaW5lZCBpbnRvXG4gICAgIGl0IHZpYSBjYWxscyB0byBbZl0uICBXZSBwcm9jZWVkIGJ5IHVzaW5nIFtmXSB0byBjb21iaW5lIGVsZW1lbnRzIGluIHRoZSBhY2N1bXVsYXRvclxuICAgICBvZiB0aGUgc2FtZSBzaXplIHVudGlsIHdlIGNhbid0IGNvbWJpbmUgYW55IG1vcmUsIHRoZW4gZ2V0dGluZyBhIG5ldyBlbGVtZW50IGZyb20gdGhlXG4gICAgIGlucHV0IGxpc3QgYW5kIHJlcGVhdGluZy5cblxuICAgICBXaXRoIHRoaXMgc3RyYXRlZ3ksIGluIHRoZSBhY2N1bXVsYXRvcjpcbiAgICAgLSB3ZSBvbmx5IGV2ZXIgaGF2ZSBlbGVtZW50cyBvZiBzaXplcyBhIHBvd2VyIG9mIHR3b1xuICAgICAtIHdlIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBlbGVtZW50IG9mIGVhY2ggc2l6ZVxuICAgICAtIHRoZSBzdW0gb2YgYWxsIHRoZSBlbGVtZW50IHNpemVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWRcblxuICAgICBUaGVzZSBjb25kaXRpb25zIGVuZm9yY2UgdGhhdCBsaXN0IG9mIGVsZW1lbnRzIG9mIGVhY2ggc2l6ZSBpcyBwcmVjaXNlbHkgdGhlIGJpbmFyeVxuICAgICBleHBhbnNpb24gb2YgdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZDogaWYgeW91J3ZlIGNvbnN1bWVkIDEzID0gMGIxMTAxXG4gICAgIGVsZW1lbnRzLCB5b3UgaGF2ZSBvbmUgZWxlbWVudCBvZiBzaXplIDgsIG9uZSBvZiBzaXplIDQsIGFuZCBvbmUgb2Ygc2l6ZSAxLiAgSGVuY2VcbiAgICAgd2hlbiBhIG5ldyBlbGVtZW50IGNvbWVzIGFsb25nLCB0aGUgbnVtYmVyIG9mIGNvbWJpbmluZ3MgeW91IG5lZWQgdG8gZG8gaXMgdGhlIG51bWJlclxuICAgICBvZiB0cmFpbGluZyAxcyBpbiB0aGUgYmluYXJ5IGV4cGFuc2lvbiBvZiBbbnVtXSwgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgYWxyZWFkeSBnb25lIGludG8gdGhlIGFjY3VtdWxhdG9yLiAgVGhlIGFjY3VtdWxhdG9yIGlzIGluIGFzY2VuZGluZyBvcmRlciBvZiBzaXplLCBzb1xuICAgICB0aGUgbmV4dCBlbGVtZW50IHRvIGNvbWJpbmUgd2l0aCBpcyBhbHdheXMgdGhlIGhlYWQgb2YgdGhlIGxpc3QuICopXG4gIGxldCByZWMgc3RlcF9hY2N1bSBudW0gYWNjIHggPVxuICAgIGlmIG51bSBsYW5kIDEgPSAwXG4gICAgdGhlbiB4IDo6IGFjY1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAoKiBOZXcgZWxlbWVudHMgZnJvbSBsYXRlciBpbiB0aGUgaW5wdXQgbGlzdCBnbyBvbiB0aGUgZnJvbnQgb2YgdGhlIGFjY3VtdWxhdG9yLCBzb1xuICAgICAgICAgdGhlIGFjY3VtdWxhdG9yIGlzIGluIHJldmVyc2Ugb3JkZXIgd3J0IHRoZSBvcmlnaW5hbCBsaXN0IG9yZGVyLCBoZW5jZSBbZiB5IHhdXG4gICAgICAgICBpbnN0ZWFkIG9mIFtmIHggeV0uICopXG4gICAgICB8IHkgOjogeXMgLT4gc3RlcF9hY2N1bSAobnVtIGFzciAxKSB5cyAoZiB5IHgpKVxuICBpblxuICAoKiBFeHBlcmltZW50YWxseSwgaW5saW5pbmcgW2ZvbGRpXSBhbmQgdW5yb2xsaW5nIHRoaXMgbG9vcCBhIGZldyB0aW1lcyBjYW4gcmVkdWNlXG4gICAgIHJ1bnRpbWUgZG93biB0byBhIHRoaXJkIGFuZCBhbGxvY2F0aW9uIHRvIDEvMTZ0aCBvciBzbyBpbiB0aGUgbWljcm9iZW5jaG1hcmtzIGJlbG93LlxuICAgICBIb3dldmVyLCBpbiBtb3N0IHVzZSBjYXNlcyBbZl0gaXMgbGlrZWx5IHRvIGJlIGV4cGVuc2l2ZSAob3RoZXJ3aXNlIHdoeSBkbyB5b3UgY2FyZVxuICAgICBhYm91dCB0aGUgb3JkZXIgb2YgcmVkdWN0aW9uPykgc28gdGhlIG92ZXJoZWFkIG9mIHRoaXMgZnVuY3Rpb24gaXRzZWxmIGRvZXNuJ3QgcmVhbGx5XG4gICAgIG1hdHRlci4gSWYgeW91IGNvbWUgdXAgd2l0aCBhIHVzZS1jYXNlIHdoZXJlIGl0IGRvZXMsIHRoZW4gdGhhdCdzIHNvbWV0aGluZyB5b3UgbWlnaHRcbiAgICAgd2FudCB0byB0cnk6IHNlZSBoZyBsb2cgLXByIDQ5ZWYwNjVmNDI5ZC4gKilcbiAgbWF0Y2ggZm9sZGkgbCB+aW5pdDpbXSB+ZjpzdGVwX2FjY3VtIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBTb21lIChmb2xkIHhzIH5pbml0OnggfmY6KGZ1biB4IHkgLT4gZiB5IHgpKVxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZF9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZV9iYWxhbmNlZCBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfYmFsYW5jZWRfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IGdyb3VwaSBsIH5icmVhayA9XG4gIGxldCBncm91cHMgPVxuICAgIGZvbGRpIGwgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyB4IC0+XG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBbIFsgeCBdIF1cbiAgICAgIHwgY3VycmVudF9ncm91cCA6OiB0bCAtPlxuICAgICAgICBpZiBicmVhayBpIChoZF9leG4gY3VycmVudF9ncm91cCkgeFxuICAgICAgICB0aGVuIFsgeCBdIDo6IGN1cnJlbnRfZ3JvdXAgOjogdGwgKCogc3RhcnQgbmV3IGdyb3VwICopXG4gICAgICAgIGVsc2UgKHggOjogY3VycmVudF9ncm91cCkgOjogdGwpXG4gICAgKCogZXh0ZW5kIGN1cnJlbnQgZ3JvdXAgKilcbiAgaW5cbiAgbWF0Y2ggZ3JvdXBzIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGwgLT4gcmV2X21hcCBsIH5mOnJldlxuOztcblxubGV0IGdyb3VwIGwgfmJyZWFrID0gZ3JvdXBpIGwgfmJyZWFrOihmdW4gXyB4IHkgLT4gYnJlYWsgeCB5KVxuXG5sZXQgc29ydF9hbmRfZ3JvdXAgbCB+Y29tcGFyZSA9XG4gIGwgfD4gc3RhYmxlX3NvcnQgfmNvbXBhcmUgfD4gZ3JvdXAgfmJyZWFrOihmdW4geCB5IC0+IGNvbXBhcmUgeCB5IDw+IDApXG47O1xuXG5sZXQgY29uY2F0X21hcCBsIH5mID1cbiAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IGF1eCAocmV2X2FwcGVuZCAoZiBoZCkgYWNjKSB0bFxuICBpblxuICBhdXggW10gbFxuOztcblxubGV0IGNvbmNhdF9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGF1eCBjb250IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBhdXggKGNvbnQgKyAxKSAocmV2X2FwcGVuZCAoZiBjb250IGhkKSBhY2MpIHRsXG4gIGluXG4gIGF1eCAwIFtdIGxcbjs7XG5cbmxldCBtZXJnZSBsMSBsMiB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBhY2MgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBhY2MgbDJcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGFjYyBsMVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjb21wYXJlIGgxIGgyIDw9IDAgdGhlbiBsb29wIChoMSA6OiBhY2MpIHQxIGwyIGVsc2UgbG9vcCAoaDIgOjogYWNjKSBsMSB0MlxuICBpblxuICBsb29wIFtdIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2FydGVzaWFuX3Byb2R1Y3QgPSBzdHJ1Y3RcbiAgKCogV2UgYXJlIGV4cGxpY2l0IGFib3V0IHdoYXQgd2UgZXhwb3J0IGZyb20gZnVuY3RvcnMgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHlcbiAgICAgcmViaW5kIG1vcmUgZWZmaWNpZW50IGxpc3Qtc3BlY2lmaWMgZnVuY3Rpb25zLiAqKVxuXG4gIGxldCBiaW5kID0gY29uY2F0X21hcFxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXAyIGEgYiB+ZiA9IGNvbmNhdF9tYXAgYSB+ZjooZnVuIHggLT4gbWFwIGIgfmY6KGZ1biB5IC0+IGYgeCB5KSlcbiAgbGV0IHJldHVybiB4ID0gWyB4IF1cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuXG4gIG9wZW4gc3RydWN0XG4gICAgbW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICAgIGxldCBtYXAyID0gbWFwMlxuICAgICAgZW5kKVxuXG4gICAgbW9kdWxlIE1vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGVuZClcbiAgZW5kXG5cbiAgbGV0IGFsbCA9IE1vbmFkLmFsbFxuICBsZXQgYWxsX3VuaXQgPSBNb25hZC5hbGxfdW5pdFxuICBsZXQgaWdub3JlX20gPSBNb25hZC5pZ25vcmVfbVxuICBsZXQgam9pbiA9IE1vbmFkLmpvaW5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcbiAgZW5kXG5cbiAgbGV0IGFwcGx5ID0gQXBwbGljYXRpdmUuYXBwbHlcbiAgbGV0IGJvdGggPSBBcHBsaWNhdGl2ZS5ib3RoXG4gIGxldCBtYXAzID0gQXBwbGljYXRpdmUubWFwM1xuICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gICAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICAgIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcbiAgZW5kXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIChDYXJ0ZXNpYW5fcHJvZHVjdCA6IE1vbmFkLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdClcblxuKCoqIHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3RfZXhuIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0X2V4biB0bFxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiTGlzdC5sYXN0XCJcbjs7XG5cbigqKiBvcHRpb25hbGx5IHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3QgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IFNvbWUgeFxuICB8IF8gOjogdGwgLT4gbGFzdCB0bFxuICB8IFtdIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgaXNfcHJlZml4IGxpc3QgfnByZWZpeCB+ZXF1YWwgPVxuICBtYXRjaCBwcmVmaXggd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBoZCA6OiB0bCAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiBmYWxzZVxuICAgICB8IGhkJyA6OiB0bCcgLT4gZXF1YWwgaGQgaGQnICYmIGlzX3ByZWZpeCB0bCcgfnByZWZpeDp0bCB+ZXF1YWwpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgYTEgOjogdCAtPlxuICAgIGxldCByZWMgbG9vcCBhMSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEyIDo6IHQgLT4gaWYgZXF1YWwgYTEgYTIgdGhlbiBTb21lIChhMSwgYTIpIGVsc2UgbG9vcCBhMiB0XG4gICAgaW5cbiAgICBsb29wIGExIHRcbjs7XG5cbigqIHJldHVybnMgbGlzdCB3aXRob3V0IGFkamFjZW50IGR1cGxpY2F0ZXMgKilcbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyA/KHdoaWNoX3RvX2tlZXAgPSBgTGFzdCkgbGlzdCB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgdG9fa2VlcCBhY2N1bSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0b19rZWVwIDo6IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgZXF1YWwgaGQgdG9fa2VlcFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0b19rZWVwID1cbiAgICAgICAgICBtYXRjaCB3aGljaF90b19rZWVwIHdpdGhcbiAgICAgICAgICB8IGBGaXJzdCAtPiB0b19rZWVwXG4gICAgICAgICAgfCBgTGFzdCAtPiBoZFxuICAgICAgICBpblxuICAgICAgICBsb29wIHRvX2tlZXAgYWNjdW0gdGwpXG4gICAgICBlbHNlIGxvb3AgaGQgKHRvX2tlZXAgOjogYWNjdW0pIHRsXG4gIGluXG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gcmV2IChsb29wIGhkIFtdIHRsKVxuOztcblxuKCoqIHJldHVybnMgc29ydGVkIHZlcnNpb24gb2YgbGlzdCB3aXRoIGR1cGxpY2F0ZXMgcmVtb3ZlZCAqKVxubGV0IGRlZHVwX2FuZF9zb3J0IGxpc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3QgKCogcGVyZm9ybWFuY2UgaGFjayAqKVxuICB8IF8gLT5cbiAgICBsZXQgZXF1YWwgeCB4JyA9IGNvbXBhcmUgeCB4JyA9IDAgaW5cbiAgICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsaXN0IGluXG4gICAgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgfmVxdWFsIHNvcnRlZFxuOztcblxubGV0IGZpbmRfYV9kdXAgbCB+Y29tcGFyZSA9XG4gIGxldCBzb3J0ZWQgPSBzb3J0IGwgfmNvbXBhcmUgaW5cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiBOb25lXG4gICAgfCBoZDEgOjogKGhkMiA6OiBfIGFzIHRsKSAtPiBpZiBjb21wYXJlIGhkMSBoZDIgPSAwIHRoZW4gU29tZSBoZDEgZWxzZSBsb29wIHRsXG4gIGluXG4gIGxvb3Agc29ydGVkXG47O1xuXG5sZXQgY29udGFpbnNfZHVwIGxzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGZpbmRfYV9kdXAgbHN0IH5jb21wYXJlIHdpdGhcbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmaW5kX2FsbF9kdXBzIGwgfmNvbXBhcmUgPVxuICAoKiBXZSBhZGQgdGhpcyByZXZlcnNhbCwgc28gd2UgY2FuIHNraXAgYSBbcmV2XSBhdCB0aGUgZW5kLiBXZSBjb3VsZCBza2lwXG4gICAgIFtyZXZdIGFueXdheSBzaW5jZSB3ZSBkb24gbm90IGdpdmUgYW55IG9yZGVyaW5nIGd1YXJhbnRlZXMsIGJ1dCBpdCBpc1xuICAgICBuaWNlIHRvIGdldCByZXN1bHRzIGluIG5hdHVyYWwgb3JkZXIuICopXG4gIGxldCBjb21wYXJlIGEgYiA9IC0xICogY29tcGFyZSBhIGIgaW5cbiAgbGV0IHNvcnRlZCA9IHNvcnQgfmNvbXBhcmUgbCBpblxuICAoKiBXYWxrIHRoZSBsaXN0IGFuZCByZWNvcmQgdGhlIGZpcnN0IG9mIGVhY2ggY29uc2VjdXRpdmUgcnVuIG9mIGlkZW50aWNhbCBlbGVtZW50cyAqKVxuICBsZXQgcmVjIGxvb3Agc29ydGVkIHByZXYgfmFscmVhZHlfcmVjb3JkZWQgYWNjID1cbiAgICBtYXRjaCBzb3J0ZWQgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgY29tcGFyZSBwcmV2IGhkIDw+IDBcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBhY2NcbiAgICAgIGVsc2UgaWYgYWxyZWFkeV9yZWNvcmRlZFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWUgYWNjXG4gICAgICBlbHNlIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSAoaGQgOjogYWNjKVxuICBpblxuICBtYXRjaCBzb3J0ZWQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBbXVxuOztcblxubGV0IHJlYyBhbGxfZXF1YWxfdG8gdCB2IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCB4IDo6IHhzIC0+IGVxdWFsIHggdiAmJiBhbGxfZXF1YWxfdG8geHMgdiB+ZXF1YWxcbjs7XG5cbmxldCBhbGxfZXF1YWwgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBpZiBhbGxfZXF1YWxfdG8geHMgeCB+ZXF1YWwgdGhlbiBTb21lIHggZWxzZSBOb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID0gMCB0aGVuIGFjY3VtIGVsc2UgbG9vcCAoaSAtIDEpIChmIChpIC0gMSkgOjogYWNjdW0pXG4gIGluXG4gIGxvb3AgbiBbXVxuOztcblxubGV0IHJldl9maWx0ZXJfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIHRsIGFjY3VtKVxuICBpblxuICBsb29wIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIGwgfmYgPSByZXYgKHJldl9maWx0ZXJfbWFwIGwgfmYpXG5cbmxldCByZXZfZmlsdGVyX21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBpIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIChpICsgMSkgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCAwIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcGkgbCB+ZilcbmxldCBmaWx0ZXJfb3B0IGwgPSBmaWx0ZXJfbWFwIGwgfmY6Rm4uaWRcblxubGV0IHBhcnRpdGlvbjNfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kIHRyZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kLCByZXYgdHJkXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgYEZzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZCB0cmRcbiAgICAgICB8IGBTbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkgdHJkXG4gICAgICAgfCBgVHJkIHkgLT4gbG9vcCB0IGZzdCBzbmQgKHkgOjogdHJkKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdIFtdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICBsZXQgZiB4IDogXyBFaXRoZXIudCA9IGlmIGYgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCBpblxuICBwYXJ0aXRpb25fbWFwIHQgfmZcbjs7XG5cbmxldCBwYXJ0aXRpb25fcmVzdWx0IHQgPSBwYXJ0aXRpb25fbWFwIHQgfmY6UmVzdWx0LnRvX2VpdGhlclxuXG5tb2R1bGUgQXNzb2MgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhICogJ2IpIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMjJfID0gXCJsaXN0Lm1sLkFzc29jLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDE0XyBfb2ZfYl9fMDE1XyB4X18wMjNfIC0+XG4gICAgICBsaXN0X29mX3NleHBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wMTdfOyBhcmcxX18wMThfIF0gLT5cbiAgICAgICAgICAgIGxldCByZXMwX18wMTlfID0gX29mX2FfXzAxNF8gYXJnMF9fMDE3X1xuICAgICAgICAgICAgYW5kIHJlczFfXzAyMF8gPSBfb2ZfYl9fMDE1XyBhcmcxX18wMThfIGluXG4gICAgICAgICAgICByZXMwX18wMTlfLCByZXMxX18wMjBfXG4gICAgICAgICAgfCBzZXhwX18wMjFfIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDIyX1xuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgIHNleHBfXzAyMV8pXG4gICAgICAgIHhfXzAyM19cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2FfXzAyNF8gX29mX2JfXzAyNV8geF9fMDMwXyAtPlxuICAgICAgc2V4cF9vZl9saXN0XG4gICAgICAgIChmdW4gKGFyZzBfXzAyNl8sIGFyZzFfXzAyN18pIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2FfXzAyNF8gYXJnMF9fMDI2X1xuICAgICAgICAgICBhbmQgcmVzMV9fMDI5XyA9IF9vZl9iX18wMjVfIGFyZzFfXzAyN18gaW5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDI4XzsgcmVzMV9fMDI5XyBdKVxuICAgICAgICB4X18wMzBfXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgbGlzdF9zZXhwX2dyYW1tYXJcbiAgICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICAgIExpc3QgKENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkpKVxuICAgICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcGFpcl9vZl9ncm91cCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IChrLCBfKSA6OiBfIGFzIGxpc3QgLT4gaywgbWFwIGxpc3QgfmY6c25kXG4gIDs7XG5cbiAgbGV0IGdyb3VwIGFsaXN0IH5lcXVhbCA9XG4gICAgZ3JvdXAgYWxpc3QgfmJyZWFrOihmdW4gKHgsIF8pICh5LCBfKSAtPiBub3QgKGVxdWFsIHggeSkpIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlID1cbiAgICBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZTooZnVuICh4LCBfKSAoeSwgXykgLT4gY29tcGFyZSB4IHkpXG4gICAgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgZmluZCB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBlcXVhbCBrZXkga2V5Jykgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSAoc25kIHgpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LkFzc29jLmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgICBsZXQgZmluZF9leG4gdCB+ZXF1YWwga2V5ID1cbiAgICAgIG1hdGNoIGZpbmQgdCBrZXkgfmVxdWFsIHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2YWx1ZSAtPiB2YWx1ZVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZXF1YWwga2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgXyAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IH5lcXVhbCBrZXkgPSBmaWx0ZXIgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBub3QgKGVxdWFsIGtleSBrZXknKSlcblxuICBsZXQgYWRkIHQgfmVxdWFsIGtleSB2YWx1ZSA9XG4gICAgKCogdGhlIHJlbW92ZSBkb2Vzbid0IGNoYW5nZSB0aGUgbWFwIHNlbWFudGljcywgYnV0IGtlZXBzIHRoZSBsaXN0IHNtYWxsICopXG4gICAgKGtleSwgdmFsdWUpIDo6IHJlbW92ZSB0IH5lcXVhbCBrZXlcbiAgOztcblxuICBsZXQgaW52ZXJzZSB0ID0gbWFwIHQgfmY6KGZ1biAoeCwgeSkgLT4geSwgeClcbiAgbGV0IG1hcCB0IH5mID0gbWFwIHQgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgLT4ga2V5LCBmIHZhbHVlKVxuZW5kXG5cbmxldCBzdWIgbCB+cG9zIH5sZW4gPVxuICAoKiBXZSB1c2UgW3BvcyA+IGxlbmd0aCBsIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gbGVuZ3RoIGxdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBsIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiO1xuICByZXZcbiAgICAoZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGVsIC0+XG4gICAgICAgaWYgaSA+PSBwb3MgJiYgaSA8IHBvcyArIGxlbiB0aGVuIGVsIDo6IGFjYyBlbHNlIGFjYykpXG47O1xuXG5sZXQgc3BsaXRfbiB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdLCB0X29yaWdcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiByZXYgYWNjdW0sIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiB0X29yaWcsIFtdICgqIGluIHRoaXMgY2FzZSwgdF9vcmlnID0gcmV2IGFjY3VtICopXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X25dIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2UgdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZ1xuICAgICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbmxldCByZWMgZHJvcCB0IG4gPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBfIDo6IHRsIHdoZW4gbiA+IDAgLT4gZHJvcCB0bCAobiAtIDEpXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgY2h1bmtzX29mIGwgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8PSAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5jaHVua3Nfb2Y6IEV4cGVjdGVkIGxlbmd0aCA+IDAsIGdvdCAlZFwiIGxlbmd0aCAoKTtcbiAgbGV0IHJlYyBhdXggb2ZfbGVuZ3RoIGFjYyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IHN1Ymxpc3QsIGwgPSBzcGxpdF9uIGwgbGVuZ3RoIGluXG4gICAgICBhdXggb2ZfbGVuZ3RoIChzdWJsaXN0IDo6IGFjYykgbFxuICBpblxuICBhdXggbGVuZ3RoIFtdIGxcbjs7XG5cbmxldCBzcGxpdF93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IHQgLT4gcmV2IGFjYywgdFxuICBpblxuICBsb29wIFtdIHhzXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfd2hpbGVdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2Vfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCBfIC0+IHJldiBhY2NcbiAgaW5cbiAgbG9vcCBbXSB4c1xuOztcblxubGV0IHJlYyBkcm9wX3doaWxlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gZHJvcF93aGlsZSB0bCB+ZlxuICB8IHQgLT4gdFxuOztcblxubGV0IGRyb3BfbGFzdCB0ID1cbiAgbWF0Y2ggcmV2IHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IGxzdCAtPiBTb21lIChyZXYgbHN0KVxuOztcblxubGV0IGRyb3BfbGFzdF9leG4gdCA9XG4gIG1hdGNoIGRyb3BfbGFzdCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiTGlzdC5kcm9wX2xhc3RfZXhuOiBlbXB0eSBsaXN0XCJcbiAgfCBTb21lIGxzdCAtPiBsc3Rcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBsaXN0MSBsaXN0MiA9XG4gIGlmIGlzX2VtcHR5IGxpc3QyXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGwxIGwyIGFjY3VtID1cbiAgICAgIG1hdGNoIGwxIHdpdGhcbiAgICAgIHwgW10gLT4gYWNjdW1cbiAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBsMiAocmV2X2FwcGVuZCAobWFwIH5mOihmdW4geCAtPiBoZCwgeCkgbDIpIGFjY3VtKVxuICAgIGluXG4gICAgcmV2IChsb29wIGxpc3QxIGxpc3QyIFtdKSlcbjs7XG5cbmxldCBjb25jYXQgbCA9IGZvbGRfcmlnaHQgbCB+aW5pdDpbXSB+ZjphcHBlbmRcbmxldCBjb25jYXRfbm9fb3JkZXIgbCA9IGZvbGQgbCB+aW5pdDpbXSB+ZjooZnVuIGFjYyBsIC0+IHJldl9hcHBlbmQgbCBhY2MpXG5sZXQgY29ucyB4IGwgPSB4IDo6IGxcblxubGV0IGlzX3NvcnRlZCBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDw9IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDwgMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICAoKiBzcGVjaWFsIGNhc2VzIHRvIHNwZWVkIHRoaW5ncyB1cCBpbiB0cml2aWFsIGNhc2VzICopXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0XG4gIHwgWyB4OyB5IF0gLT4gaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlIHRoZW4gWyB5OyB4IF0gZWxzZSBsaXN0XG4gIHwgXyAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgICBBcnJheV9wZXJtdXRlLnBlcm11dGUgYXJyIH5yYW5kb21fc3RhdGU7XG4gICAgQXJyYXkudG9fbGlzdCBhcnJcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIGlmIGlzX2VtcHR5IGxpc3RcbiAgdGhlbiBmYWlsd2l0aCBcIkxpc3QucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBsaXN0XCJcbiAgZWxzZSBudGhfZXhuIGxpc3QgKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggbGlzdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSBsaXN0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCBuID0gY21wIHggeSBpblxuICAgIGlmIG4gPSAwIHRoZW4gY29tcGFyZSBjbXAgeHMgeXMgZWxzZSBuXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgPSBoYXNoX2ZvbGRfbGlzdFxuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPVxuICBsZXQgcmVjIGxvb3AgfmVxdWFsIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IHgxIDo6IHQxLCB4MiA6OiB0MiAtPiBlcXVhbCB4MSB4MiAmJiBsb29wIH5lcXVhbCB0MSB0MlxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIH5lcXVhbCB0MSB0MlxuOztcblxubGV0IHRyYW5zcG9zZSA9XG4gIGxldCByZWMgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0IGNvbHVtbl9hY2MgdHJpbW1lZCBmb3VuZF9lbXB0eSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBjb2x1bW5fYWNjLCB0cmltbWVkLCBmb3VuZF9lbXB0eVxuICAgIHwgW10gOjogdGwgLT4gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCBjb2x1bW5fYWNjIHRyaW1tZWQgdHJ1ZVxuICAgIHwgKHggOjogeHMpIDo6IHRsIC0+XG4gICAgICBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsICh4IDo6IGNvbHVtbl9hY2MpICh4cyA6OiB0cmltbWVkKSBmb3VuZF9lbXB0eVxuICBpblxuICBsZXQgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzID0gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIFtdIFtdIGZhbHNlIGluXG4gIGxldCByZWMgbG9vcCByb3dzIGNvbHVtbnMgZG9fcmV2ID1cbiAgICBtYXRjaCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3Mgd2l0aFxuICAgIHwgW10sIFtdLCBfIC0+IFNvbWUgKHJldiBjb2x1bW5zKVxuICAgIHwgY29sdW1uLCB0cmltbWVkX3Jvd3MsIGZvdW5kX2VtcHR5IC0+XG4gICAgICBpZiBmb3VuZF9lbXB0eVxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGNvbHVtbiA9IGlmIGRvX3JldiB0aGVuIHJldiBjb2x1bW4gZWxzZSBjb2x1bW4gaW5cbiAgICAgICAgbG9vcCB0cmltbWVkX3Jvd3MgKGNvbHVtbiA6OiBjb2x1bW5zKSAobm90IGRvX3JldikpXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXSB0cnVlXG47O1xuXG5leGNlcHRpb24gVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBvZiBpbnQgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc11cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBhcmcwX18wMzFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMzJfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfaW50IGFyZzBfXzAzMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsaXN0Lm1sLlRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNcIlxuICAgICAgICAgIDsgcmVzMF9fMDMyX1xuICAgICAgICAgIF1cbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdHJhbnNwb3NlX2V4biBsID1cbiAgbWF0Y2ggdHJhbnNwb3NlIGwgd2l0aFxuICB8IFNvbWUgbCAtPiBsXG4gIHwgTm9uZSAtPiByYWlzZSAoVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyAobWFwIGwgfmY6bGVuZ3RoKSlcbjs7XG5cbmxldCBpbnRlcnNwZXJzZSB0IH5zZXAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT4geCA6OiBmb2xkX3JpZ2h0IHhzIH5pbml0OltdIH5mOihmdW4geSBhY2MgLT4gc2VwIDo6IHkgOjogYWNjKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcblxubGV0IGlzX3N1ZmZpeCBsaXN0IH5zdWZmaXggfmVxdWFsOmVxdWFsX2VsdCA9XG4gIGxldCBsaXN0X2xlbiA9IGxlbmd0aCBsaXN0IGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsaXN0X2xlbiA+PSBzdWZmaXhfbGVuICYmIGVxdWFsIGVxdWFsX2VsdCAoZHJvcCBsaXN0IChsaXN0X2xlbiAtIHN1ZmZpeF9sZW4pKSBzdWZmaXhcbjs7XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtJbmZvXSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiBhcyBtYW55IHBsYWNlcyBhcyBwb3NzaWJsZS4gUGxlYXNlIGF2b2lkXG4gICBhZGRpbmcgbmV3IGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9faW50ZlxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIE1lc3NhZ2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgb2YgU2V4cC50XG4gICAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gICAgfCBFeG4gb2YgZXhuXG4gICAgfCBTZXhwIG9mIFNleHAudFxuICAgIHwgVGFnX3NleHAgb2Ygc3RyaW5nICogU2V4cC50ICogU291cmNlX2NvZGVfcG9zaXRpb24wLnQgb3B0aW9uXG4gICAgfCBUYWdfdCBvZiBzdHJpbmcgKiB0XG4gICAgfCBUYWdfYXJnIG9mIHN0cmluZyAqIFNleHAudCAqIHRcbiAgICB8IE9mX2xpc3Qgb2YgaW50IG9wdGlvbiAqIHQgbGlzdFxuICAgIHwgV2l0aF9iYWNrdHJhY2Ugb2YgdCAqIHN0cmluZyAoKiBiYWNrdHJhY2UgKilcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHJlYyBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IGFyZzBfXzAwMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwMl8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkNvdWxkX25vdF9jb25zdHJ1Y3RcIjsgcmVzMF9fMDAyXyBdXG4gICAgICB8IFN0cmluZyBhcmcwX18wMDNfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDRfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDAzXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTdHJpbmdcIjsgcmVzMF9fMDA0XyBdXG4gICAgICB8IEV4biBhcmcwX18wMDVfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDZfID0gc2V4cF9vZl9leG4gYXJnMF9fMDA1XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFeG5cIjsgcmVzMF9fMDA2XyBdXG4gICAgICB8IFNleHAgYXJnMF9fMDA3XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDA4XyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwN18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2V4cFwiOyByZXMwX18wMDhfIF1cbiAgICAgIHwgVGFnX3NleHAgKGFyZzBfXzAwOV8sIGFyZzFfXzAxMF8sIGFyZzJfXzAxMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA5X1xuICAgICAgICBhbmQgcmVzMV9fMDEzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAxMF9cbiAgICAgICAgYW5kIHJlczJfXzAxNF8gPSBzZXhwX29mX29wdGlvbiBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGFyZzJfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfc2V4cFwiOyByZXMwX18wMTJfOyByZXMxX18wMTNfOyByZXMyX18wMTRfIF1cbiAgICAgIHwgVGFnX3QgKGFyZzBfXzAxNV8sIGFyZzFfXzAxNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE1X1xuICAgICAgICBhbmQgcmVzMV9fMDE4XyA9IHNleHBfb2ZfdCBhcmcxX18wMTZfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ190XCI7IHJlczBfXzAxN187IHJlczFfXzAxOF8gXVxuICAgICAgfCBUYWdfYXJnIChhcmcwX18wMTlfLCBhcmcxX18wMjBfLCBhcmcyX18wMjFfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAxOV9cbiAgICAgICAgYW5kIHJlczFfXzAyM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMjBfXG4gICAgICAgIGFuZCByZXMyX18wMjRfID0gc2V4cF9vZl90IGFyZzJfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfYXJnXCI7IHJlczBfXzAyMl87IHJlczFfXzAyM187IHJlczJfXzAyNF8gXVxuICAgICAgfCBPZl9saXN0IChhcmcwX18wMjVfLCBhcmcxX18wMjZfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI3XyA9IHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfaW50IGFyZzBfXzAyNV9cbiAgICAgICAgYW5kIHJlczFfXzAyOF8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl90IGFyZzFfXzAyNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2ZfbGlzdFwiOyByZXMwX18wMjdfOyByZXMxX18wMjhfIF1cbiAgICAgIHwgV2l0aF9iYWNrdHJhY2UgKGFyZzBfXzAyOV8sIGFyZzFfXzAzMF8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMzFfID0gc2V4cF9vZl90IGFyZzBfXzAyOV9cbiAgICAgICAgYW5kIHJlczFfXzAzMl8gPSBzZXhwX29mX3N0cmluZyBhcmcxX18wMzBfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIldpdGhfYmFja3RyYWNlXCI7IHJlczBfXzAzMV87IHJlczFfXzAzMl8gXVxuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHJlYyB0b19zdHJpbmdzX2h1bSB0IGFjID1cbiAgICAoKiBXZSB1c2UgW1NleHAudG9fc3RyaW5nX21hY2hdLCBkZXNwaXRlIHRoZSBmYWN0IHRoYXQgd2UgYXJlIGltcGxlbWVudGluZ1xuICAgICAgIFt0b19zdHJpbmdzX2h1bV0sIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5mbyB0byBmaXQgb24gYSBzaW5nbGUgbGluZSwgYW5kIG9uY2Ugd2UndmVcbiAgICAgICBoYWQgdG8gcmVzb3J0IHRvIHNleHBzLCB0aGUgbWVzc2FnZSBpcyBnb2luZyB0byBzdGFydCBub3QgbG9va2luZyBzbyBwcmV0dHlcbiAgICAgICBhbnl3YXkuICopXG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IHNleHAgLT5cbiAgICAgIFwiY291bGQgbm90IGNvbnN0cnVjdCBpbmZvOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gc3RyaW5nIDo6IGFjXG4gICAgfCBFeG4gZXhuIC0+IFNleHAudG9fc3RyaW5nX21hY2ggKEV4bi5zZXhwX29mX3QgZXhuKSA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3NleHAgKHRhZywgc2V4cCwgXykgLT4gdGFnIDo6IFwiOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFRhZ190ICh0YWcsIHQpIC0+IHRhZyA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhY1xuICAgIHwgVGFnX2FyZyAodGFnLCBzZXhwLCB0KSAtPlxuICAgICAgbGV0IGJvZHkgPSBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogXCI6IFwiIDo6IHRvX3N0cmluZ3NfaHVtIHQgYWMgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIGJvZHkgZWxzZSB0YWcgOjogXCI6IFwiIDo6IGJvZHlcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICB0b19zdHJpbmdzX2h1bSB0IChcIlxcbkJhY2t0cmFjZTpcXG5cIiA6OiBiYWNrdHJhY2UgOjogYWMpXG4gICAgfCBPZl9saXN0ICh0cnVuY19hZnRlciwgdHMpIC0+XG4gICAgICBsZXQgdHMgPVxuICAgICAgICBtYXRjaCB0cnVuY19hZnRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0c1xuICAgICAgICB8IFNvbWUgbWF4IC0+XG4gICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCB0cyBpblxuICAgICAgICAgIGlmIG4gPD0gbWF4XG4gICAgICAgICAgdGhlbiB0c1xuICAgICAgICAgIGVsc2UgTGlzdC50YWtlIHRzIG1heCBAIFsgU3RyaW5nIChQcmludGYuc3ByaW50ZiBcImFuZCAlZCBtb3JlIGluZm9cIiAobiAtIG1heCkpIF1cbiAgICAgIGluXG4gICAgICBMaXN0LmZvbGQgKExpc3QucmV2IHRzKSB+aW5pdDphYyB+ZjooZnVuIGFjIHQgLT5cbiAgICAgICAgdG9fc3RyaW5nc19odW0gdCAoaWYgTGlzdC5pc19lbXB0eSBhYyB0aGVuIGFjIGVsc2UgXCI7IFwiIDo6IGFjKSlcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIHQgPSBTdHJpbmcuY29uY2F0ICh0b19zdHJpbmdzX2h1bSB0IFtdKVxuXG4gIGxldCByZWMgdG9fc2V4cHNfaHVtIHQgYWMgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBfIGFzIHQgLT4gc2V4cF9vZl90IHQgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gQXRvbSBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gRXhuLnNleHBfb2ZfdCBleG4gOjogYWNcbiAgICB8IFNleHAgc2V4cCAtPiBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBoZXJlKSAtPlxuICAgICAgTGlzdFxuICAgICAgICAoQXRvbSB0YWdcbiAgICAgICAgIDo6IHNleHBcbiAgICAgICAgIDo6XG4gICAgICAgICAobWF0Y2ggaGVyZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgICAgfCBTb21lIGhlcmUgLT4gWyBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGhlcmUgXSkpXG4gICAgICA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gTGlzdCAoQXRvbSB0YWcgOjogdG9fc2V4cHNfaHVtIHQgW10pIDo6IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IHNleHAgOjogdG9fc2V4cHNfaHVtIHQgW10gaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIExpc3QgYm9keSA6OiBhYyBlbHNlIExpc3QgKEF0b20gdGFnIDo6IGJvZHkpIDo6IGFjXG4gICAgfCBXaXRoX2JhY2t0cmFjZSAodCwgYmFja3RyYWNlKSAtPlxuICAgICAgU2V4cC5MaXN0IFsgdG9fc2V4cF9odW0gdDsgU2V4cC5BdG9tIGJhY2t0cmFjZSBdIDo6IGFjXG4gICAgfCBPZl9saXN0IChfLCB0cykgLT5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPiB0b19zZXhwc19odW0gdCBhYylcblxuICBhbmQgdG9fc2V4cF9odW0gdCA9XG4gICAgbWF0Y2ggdG9fc2V4cHNfaHVtIHQgW10gd2l0aFxuICAgIHwgWyBzZXhwIF0gLT4gc2V4cFxuICAgIHwgc2V4cHMgLT4gU2V4cC5MaXN0IHNleHBzXG4gIDs7XG5cbiAgKCogV2UgdXNlIFtwcm90ZWN0XSB0byBndWFyZCBhZ2FpbnN0IGV4Y2VwdGlvbnMgcmFpc2VkIGJ5IHVzZXItc3VwcGxpZWQgZnVuY3Rpb25zLCBzb1xuICAgICB0aGF0IGZhaWx1cmUgdG8gcHJvZHVjZSBvbmUgcGFydCBvZiBhbiBpbmZvIGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggb3RoZXIgcGFydHMuICopXG4gIGxldCBwcm90ZWN0IGYgPVxuICAgIHRyeSBmICgpIHdpdGhcbiAgICB8IGV4biAtPiBDb3VsZF9ub3RfY29uc3RydWN0IChFeG4uc2V4cF9vZl90IGV4bilcbiAgOztcblxuICBsZXQgb2ZfaW5mbyBpbmZvID0gcHJvdGVjdCAoZnVuICgpIC0+IExhenkuZm9yY2UgaW5mbylcbiAgbGV0IHRvX2luZm8gdCA9IGxhenkgdFxuZW5kXG5cbm9wZW4gTWVzc2FnZVxuXG50eXBlIHQgPSBNZXNzYWdlLnQgTGF6eS50XG5cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5sZXQgdG9fbWVzc2FnZSA9IE1lc3NhZ2Uub2ZfaW5mb1xubGV0IG9mX21lc3NhZ2UgPSBNZXNzYWdlLnRvX2luZm9cblxuKCogSXQgaXMgT0sgdG8gdXNlIFtNZXNzYWdlLnRvX3NleHBfaHVtXSwgd2hpY2ggaXMgbm90IHN0YWJsZSwgYmVjYXVzZSBbdF9vZl9zZXhwXSBiZWxvd1xuICAgY2FuIGhhbmRsZSBhbnkgc2V4cC4gKilcbmxldCBzZXhwX29mX3QgdCA9IE1lc3NhZ2UudG9fc2V4cF9odW0gKHRvX21lc3NhZ2UgdClcbmxldCB0X29mX3NleHAgc2V4cCA9IGxhenkgKE1lc3NhZ2UuU2V4cCBzZXhwKVxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gQW55IFwiSW5mby50XCIgfVxubGV0IGNvbXBhcmUgdDEgdDIgPSBTZXhwLmNvbXBhcmUgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBlcXVhbCB0MSB0MiA9IFNleHAuZXF1YWwgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gU2V4cC5oYXNoX2ZvbGRfdCBzdGF0ZSAoc2V4cF9vZl90IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG5sZXQgdG9fc3RyaW5nX2h1bSB0ID1cbiAgbWF0Y2ggdG9fbWVzc2FnZSB0IHdpdGhcbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgbWVzc2FnZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gKE1lc3NhZ2UudG9fc2V4cF9odW0gbWVzc2FnZSlcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IE1lc3NhZ2UudG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkICh0b19tZXNzYWdlIHQpXG5sZXQgdG9fc3RyaW5nX21hY2ggdCA9IFNleHAudG9fc3RyaW5nX21hY2ggKHNleHBfb2ZfdCB0KVxubGV0IG9mX2xhenkgbCA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfc2V4cCBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFNleHAgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfdCBsYXp5X3QgPSBMYXp5LmpvaW4gbGF6eV90XG5sZXQgb2Zfc3RyaW5nIG1lc3NhZ2UgPSBMYXp5LmZyb21fdmFsIChTdHJpbmcgbWVzc2FnZSlcbmxldCBjcmVhdGVmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBvZl9zdHJpbmcgZm9ybWF0XG5sZXQgb2ZfdGh1bmsgZiA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKGYgKCkpKSlcblxubGV0IGNyZWF0ZSA/aGVyZSA/c3RyaWN0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIG1hdGNoIHN0cmljdCB3aXRoXG4gIHwgTm9uZSAtPiBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKSlcbiAgfCBTb21lICgpIC0+IG9mX21lc3NhZ2UgKFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoU2V4cCBzZXhwKVxubGV0IHRhZyB0IH50YWcgPSBsYXp5IChUYWdfdCAodGFnLCB0b19tZXNzYWdlIHQpKVxuXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAoXCJcIiwgTGF6eS5mb3JjZSB0YWcsIHRvX21lc3NhZ2UgdCkpKVxuOztcblxubGV0IHRhZ19zIHQgfnRhZyA9IHRhZ19zX2xhenkgdCB+dGFnOihMYXp5LmZyb21fdmFsIHRhZylcblxubGV0IHRhZ19hcmcgdCB0YWcgeCBzZXhwX29mX3ggPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAodGFnLCBzZXhwX29mX3ggeCwgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgb2ZfbGlzdCA/dHJ1bmNfYWZ0ZXIgdHMgPSBsYXp5IChPZl9saXN0ICh0cnVuY19hZnRlciwgTGlzdC5tYXAgdHMgfmY6dG9fbWVzc2FnZSkpXG5cbmV4Y2VwdGlvbiBFeG4gb2YgdFxuXG5sZXQgKCkgPVxuICAoKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlXG4gICAgIFtleGNlcHRpb24gRXhuIG9mIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdIC4uLiBbQEBAZW5kXV0gdG8gZWxpbWluYXRlIHRoZSBleHRyYVxuICAgICB3cmFwcGluZyBvZiBcIihFeG4gLi4uKVwiLiAqKVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhuXSAoZnVuY3Rpb25cbiAgICB8IEV4biB0IC0+IHNleHBfb2ZfdCB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB0b19leG4gdCA9XG4gIGlmIG5vdCAoTGF6eS5pc192YWwgdClcbiAgdGhlbiBFeG4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBMYXp5LmZvcmNlIHQgd2l0aFxuICAgIHwgTWVzc2FnZS5FeG4gZXhuIC0+IGV4blxuICAgIHwgXyAtPiBFeG4gdClcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPVxuICBsZXQgYmFja3RyYWNlID1cbiAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGBHZXQgLT4gU29tZSAoQ2FtbC5QcmludGV4Yy5nZXRfYmFja3RyYWNlICgpKVxuICAgIHwgU29tZSAoYFRoaXMgcykgLT4gU29tZSBzXG4gIGluXG4gIG1hdGNoIGV4biwgYmFja3RyYWNlIHdpdGhcbiAgfCBFeG4gdCwgTm9uZSAtPiB0XG4gIHwgRXhuIHQsIFNvbWUgYmFja3RyYWNlIC0+IGxhenkgKFdpdGhfYmFja3RyYWNlICh0b19tZXNzYWdlIHQsIGJhY2t0cmFjZSkpXG4gIHwgXywgTm9uZSAtPiBMYXp5LmZyb21fdmFsIChNZXNzYWdlLkV4biBleG4pXG4gIHwgXywgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKFNleHAgKEV4bi5zZXhwX29mX3QgZXhuKSwgYmFja3RyYWNlKSlcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW5mb1wiXG4gICAgbGV0IHBwIHBwZiB0ID0gQ2FtbC5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nX2h1bSB0KVxuICBlbmQpXG5cbm1vZHVsZSBJbnRlcm5hbF9yZXByID0gTWVzc2FnZVxuXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtFcnJvcl0gYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcy4gIFBsZWFzZSBhdm9pZCBhZGRpbmcgbmV3XG4gICBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvXG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJFcnJvci50XCIgfVxubGV0IHJhaXNlIHQgPSByYWlzZSAodG9fZXhuIHQpXG5sZXQgcmFpc2VfcyBzZXhwID0gcmFpc2UgKGNyZWF0ZV9zIHNleHApXG5sZXQgdG9faW5mbyB0ID0gdFxubGV0IG9mX2luZm8gdCA9IHRcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FcnJvclwiXG4gICAgbGV0IHBwID0gcHBcbiAgZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludmFyaWFudF9pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5sZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA6IHVuaXQgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJcIiwgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlXG4gICAgICAgICA7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4blxuICAgICAgICAgOyBcIlwiLCBzZXhwX29mX3QgdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCBjaGVja19maWVsZCB0IGYgZmllbGQgPVxuICB0cnkgZiAoRmllbGQuZ2V0IGZpZWxkIHQpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcInByb2JsZW0gd2l0aCBmaWVsZFwiXG4gICAgICAgICBbIFwiZmllbGRcIiwgc2V4cF9vZl9zdHJpbmcgKEZpZWxkLm5hbWUgZmllbGQpOyBcImV4blwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG4gIFJlc3VsdCA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBSZXN1bHRcbiAgZW5kXG4gIHdpdGggbW9kdWxlIEVycm9yIDo9IFJlc3VsdC5FcnJvcilcblxudHlwZSAnYSB0ID0gKCdhLCBFcnJvci50KSBSZXN1bHQudFxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT4gUmVzdWx0LmNvbXBhcmUgX2NtcF9fYSBFcnJvci5jb21wYXJlIGFfXzAwMV8gYl9fMDAyX1xuOztcblxubGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gIGZ1biBfY21wX19hIGFfXzAwN18gYl9fMDA4XyAtPiBSZXN1bHQuZXF1YWwgX2NtcF9fYSBFcnJvci5lcXVhbCBhX18wMDdfIGJfXzAwOF9cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA6XG4gICdhLlxuICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gIC0+ICdhIHRcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBoc3YgYXJnIC0+IFJlc3VsdC5oYXNoX2ZvbGRfdCBfaGFzaF9mb2xkX2EgRXJyb3IuaGFzaF9mb2xkX3QgaHN2IGFyZ1xuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDEzXyB4X18wMTVfIC0+IFJlc3VsdC50X29mX3NleHAgX29mX2FfXzAxM18gRXJyb3IudF9vZl9zZXhwIHhfXzAxNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAxNl8geF9fMDE3XyAtPiBSZXN1bHQuc2V4cF9vZl90IF9vZl9hX18wMTZfIEVycm9yLnNleHBfb2ZfdCB4X18wMTdfXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZXN1bHQudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hciBFcnJvci50X3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgYSAtPiBpbnZhcmlhbnRfYSBhXG4gIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IuaW52YXJpYW50IGVycm9yXG47O1xuXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBsZXQgYXBwbHkgZiB4ID1cbiAgICAgIFJlc3VsdC5jb21iaW5lIGYgeCB+b2s6KGZ1biBmIHggLT4gZiB4KSB+ZXJyOihmdW4gZTEgZTIgLT4gRXJyb3Iub2ZfbGlzdCBbIGUxOyBlMiBdKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICgqIGZyb20gQXBwbGljYXRpdmUuTWFrZSAqKVxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgZW5kXG5lbmRcblxubGV0IG9rID0gUmVzdWx0Lm9rXG5sZXQgaXNfb2sgPSBSZXN1bHQuaXNfb2tcbmxldCBpc19lcnJvciA9IFJlc3VsdC5pc19lcnJvclxuXG5sZXQgdHJ5X3dpdGggPyhiYWNrdHJhY2UgPSBmYWxzZSkgZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4biA/YmFja3RyYWNlOihpZiBiYWNrdHJhY2UgdGhlbiBTb21lIGBHZXQgZWxzZSBOb25lKSlcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9iYWNrdHJhY2UgZiA9IGpvaW4gKHRyeV93aXRoID9iYWNrdHJhY2UgZilcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXJyIC0+IEVycm9yLnJhaXNlIGVyclxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9IEVycm9yIChFcnJvci5vZl9leG4gP2JhY2t0cmFjZSBleG4pXG5cbmxldCBvZl9leG5fcmVzdWx0ID9iYWNrdHJhY2UgPSBmdW5jdGlvblxuICB8IE9rIF8gYXMgeiAtPiB6XG4gIHwgRXJyb3IgZXhuIC0+IG9mX2V4biA/YmFja3RyYWNlIGV4blxuOztcblxubGV0IGVycm9yID9oZXJlID9zdHJpY3QgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIEVycm9yIChFcnJvci5jcmVhdGUgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IGVycm9yX3Mgc2V4cCA9IEVycm9yIChFcnJvci5jcmVhdGVfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtZXNzYWdlID0gRXJyb3IgKEVycm9yLm9mX3N0cmluZyBtZXNzYWdlKVxubGV0IGVycm9yZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZXJyb3Jfc3RyaW5nIGZvcm1hdFxubGV0IHRhZyB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3MgfnRhZylcbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3NfbGF6eSB+dGFnKVxuXG5sZXQgdGFnX2FyZyB0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KGZ1biBlIC0+IEVycm9yLnRhZ19hcmcgZSBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgcyA9IGVycm9yIFwidW5pbXBsZW1lbnRlZFwiIHMgc2V4cF9vZl9zdHJpbmdcbmxldCBjb21iaW5lX2Vycm9ycyBsID0gUmVzdWx0Lm1hcF9lcnJvciAoUmVzdWx0LmNvbWJpbmVfZXJyb3JzIGwpIH5mOkVycm9yLm9mX2xpc3RcbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBSZXN1bHQubWFwIChjb21iaW5lX2Vycm9ycyBsKSB+ZjooZnVuIChfIDogdW5pdCBsaXN0KSAtPiAoKSlcblxubGV0IGZpbHRlcl9va19hdF9sZWFzdF9vbmUgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QucGFydGl0aW9uX21hcCBsIH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgbWF0Y2ggb2sgd2l0aFxuICB8IFtdIC0+IEVycm9yIChFcnJvci5vZl9saXN0IGVycnMpXG4gIHwgXyAtPiBPayBva1xuOztcblxubGV0IGZpbmRfb2sgbCA9XG4gIG1hdGNoIExpc3QuZmluZF9tYXAgbCB+ZjpSZXN1bHQub2sgd2l0aFxuICB8IFNvbWUgeCAtPiBPayB4XG4gIHwgTm9uZSAtPlxuICAgIEVycm9yXG4gICAgICAoRXJyb3Iub2ZfbGlzdFxuICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICB8IE9rIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSlcbjs7XG5cbmxldCBmaW5kX21hcF9vayBsIH5mID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICAgICAgfCBPayBfIGFzIHggLT4gcmV0dXJuIHhcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKSlcbjs7XG5cbmxldCBtYXAgPSBSZXN1bHQubWFwXG5sZXQgaXRlciA9IFJlc3VsdC5pdGVyXG5sZXQgaXRlcl9lcnJvciA9IFJlc3VsdC5pdGVyX2Vycm9yXG4iLCIoKiBUaGlzIGlzIGJyb2tlbiBvZmYgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFNpZ24gYW5kIENvbXBhcmFibGUuICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IE5lZ1xuICB8IFplcm9cbiAgfCBQb3NcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZV1cblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduMC5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IE5lZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBaZXJvIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBOZWc7IFplcm87IFBvcyBdIDogdCBsaXN0KVxuXG5bQEBAZW5kXVxuXG5tb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxubGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTFcbiAgfCBaZXJvIC0+IDBcbiAgfCBQb3MgLT4gMVxuOztcblxubGV0IF8gPSBoYXNoXG5cbigqIElnbm9yZSB0aGUgaGFzaCBmdW5jdGlvbiBwcm9kdWNlZCBieSBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaF0gKilcbmxldCBoYXNoID0gdG9faW50XG5sZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnblwiXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIE5lZyBlbHNlIGlmIG4gPSAwIHRoZW4gWmVybyBlbHNlIFBvc1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbXBhcmFibGVfaW50ZlxuXG5tb2R1bGUgV2l0aF96ZXJvIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgemVybyA6IHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgUG9seVxuICBlbmRcblxuICBpbmNsdWRlIFBvbHlcblxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcblxuICBtb2R1bGUgQyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUpXG4gIGVuZFxuXG4gIGluY2x1ZGUgQ1xuZW5kXG5cbmxldCBndCBjbXAgYSBiID0gY21wIGEgYiA+IDBcbmxldCBsdCBjbXAgYSBiID0gY21wIGEgYiA8IDBcbmxldCBnZXEgY21wIGEgYiA9IGNtcCBhIGIgPj0gMFxubGV0IGxlcSBjbXAgYSBiID0gY21wIGEgYiA8PSAwXG5sZXQgZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPSAwXG5sZXQgbm90X2VxdWFsIGNtcCBhIGIgPSBjbXAgYSBiIDw+IDBcbmxldCBtaW4gY21wIHQgdCcgPSBpZiBsZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcbmxldCBtYXggY21wIHQgdCcgPSBpZiBnZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcblxubW9kdWxlIEluZml4IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBJbmZpeCB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgbGV0ICggPiApIGEgYiA9IGd0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPCApIGEgYiA9IGx0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPj0gKSBhIGIgPSBnZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PSApIGEgYiA9IGxlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoID0gKSBhIGIgPSBlcXVhbCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw+ICkgYSBiID0gbm90X2VxdWFsIFQuY29tcGFyZSBhIGJcbmVuZFxuXG5tb2R1bGUgUG9seW1vcnBoaWNfY29tcGFyZSAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIDogUG9seW1vcnBoaWNfY29tcGFyZSB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVC5jb21wYXJhdG9yX3dpdG5lc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyYXRvci5jb21wYXJlXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gUG9seW1vcnBoaWNfY29tcGFyZSAoVClcbiAgaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB0IHQnID0gY29tcGFyZSB0JyB0XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG4gIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gIGVuZClcblxubW9kdWxlIEluaGVyaXQgKEMgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSAoVCA6IHNpZ1xuICAgICAgICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICAgICAgW0BAQGVuZF1cblxuICAgICAgICAgIHZhbCBjb21wb25lbnQgOiB0IC0+IEMudFxuICAgICAgICBlbmQpID1cbiAgTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIHQgdCcgPSBDLmNvbXBhcmUgKFQuY29tcG9uZW50IHQpIChULmNvbXBvbmVudCB0JylcbiAgZW5kKVxuXG4oKiBjb21wYXJlIFt4XSBhbmQgW3ldIGxleGljb2dyYXBoaWNhbGx5IHVzaW5nIGZ1bmN0aW9ucyBpbiB0aGUgbGlzdCBbY21wc10gKilcbmxldCBsZXhpY29ncmFwaGljIGNtcHMgeCB5ID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IGNtcCA6OiBjbXBzIC0+XG4gICAgICBsZXQgcmVzID0gY21wIHggeSBpblxuICAgICAgaWYgcmVzID0gMCB0aGVuIGxvb3AgY21wcyBlbHNlIHJlc1xuICAgIHwgW10gLT4gMFxuICBpblxuICBsb29wIGNtcHNcbjs7XG5cbmxldCBsaWZ0IGNtcCB+ZiB4IHkgPSBjbXAgKGYgeCkgKGYgeSlcbmxldCByZXZlcnNlIGNtcCB4IHkgPSBjbXAgeSB4XG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZS5LZXkgKilcbm1vZHVsZSB0eXBlIEtleSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gICgqKiBWYWx1ZXMgcmV0dXJuZWQgYnkgW2hhc2hdIG11c3QgYmUgbm9uLW5lZ2F0aXZlLiAgQW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGluIHRoZVxuICAgICAgY2FzZSB0aGF0IFtoYXNoXSByZXR1cm5zIGEgbmVnYXRpdmUgdmFsdWUuICopXG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICAoKiogVGhpcyBmdW5jdGlvbiBpcyBzb3VuZCBidXQgbm90IGNvbXBsZXRlLCBtZWFuaW5nIHRoYXQgaWYgaXQgcmV0dXJucyBbdHJ1ZV0gdGhlbiBpdCdzXG4gICAgICBzYWZlIHRvIHVzZSB0aGUgdHdvIGludGVyY2hhbmdlYWJseS4gIElmIGl0J3MgW2ZhbHNlXSwgeW91IGhhdmUgbm8gZ3VhcmFudGVlcy4gIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgPiB1dG9wXG4gICAgICAgIG9wZW4gQ29yZTs7XG4gICAgICAgIGxldCBlcXVhbCAoYSA6ICdhIEhhc2h0YmxfaW50Zi5IYXNoYWJsZS50KSBiID1cbiAgICAgICAgICBwaHlzX2VxdWFsIGEgYlxuICAgICAgICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gICAgICAgIDs7XG4gICAgICAgIGxldCBhID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgbGV0IGIgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBlcXVhbCBhIGI7OyAgKCogZmFsc2U/ISAqKVxuICAgICAgXX1cbiAgKilcbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBoYXNoX3BhcmFtID0gQ2FtbC5IYXNodGJsLmhhc2hfcGFyYW1cbiAgbGV0IGhhc2ggPSBDYW1sLkhhc2h0YmwuaGFzaFxuICBsZXQgcG9seSA9IHsgaGFzaDsgY29tcGFyZSA9IFBvbHkuY29tcGFyZTsgc2V4cF9vZl90ID0gKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgfVxuXG4gIGxldCBvZl9rZXkgKHR5cGUgYSkgKG1vZHVsZSBLZXkgOiBLZXkgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgeyBoYXNoID0gS2V5Lmhhc2g7IGNvbXBhcmUgPSBLZXkuY29tcGFyZTsgc2V4cF9vZl90ID0gS2V5LnNleHBfb2ZfdCB9XG4gIDs7XG5cbiAgbGV0IHRvX2tleSAodHlwZSBhKSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9ID1cbiAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgaGFzaCA9IGhhc2hcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZCA6IEtleVxuICAgICAgd2l0aCB0eXBlIHQgPSBhKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgSGFzaGFibGVcblxubW9kdWxlIHR5cGUgSGFzaGFibGUgPSBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgSGFzaGFibGUudCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIHBvbHkgOiAnYSB0XG4gIHZhbCBvZl9rZXkgOiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKSAtPiAnYSB0XG4gIHZhbCB0b19rZXkgOiAnYSB0IC0+IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpXG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIElkZW50aWZpYWJsZV9pbnRmXG5cbm1vZHVsZSBNYWtlIChUIDogQXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBBcmdfd2l0aF9jb21wYXJhdG9yKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgYWxsID0gKFsgKCkgXSA6IHQgbGlzdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3VuaXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3VuaXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHVuaXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfdW5pdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB1bml0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGNvbXBhcmUgXyBfID0gMFxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCIoKVwiIC0+ICgpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiQmFzZS5Vbml0Lm9mX3N0cmluZzogKCkgZXhwZWN0ZWRcIlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVuaXRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxubGV0IGludmFyaWFudCAoKSA9ICgpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBcblxubGV0IGdldF9wb3NfbGVuID9wb3MgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgdHJ5IFJlc3VsdC5PayAoZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBzIC0+IE9yX2Vycm9yLmVycm9yX3N0cmluZyBzXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgYSBzZWFyY2ggZm9yIHRoZSBmaXJzdCAocmVzcC4gbGFzdCkgZWxlbWVudFxuICAgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgYXNzdW1pbmcgdGhhdCB0aGUgcHJlZGljYXRlIGlzIGluY3JlYXNpbmcgb25cbiAgIHRoZSBjb250YWluZXIsIG1lYW5pbmcgdGhhdCwgaWYgdGhlIGNvbnRhaW5lciBpcyBbdTEuLi51bl0sIHRoZXJlIGV4aXN0cyBhXG4gICBrIHN1Y2ggdGhhdCBwKHUxKT0uLi4uPXAodWspID0gZmFsc2UgYW5kIHAodWsrMSk9Li4uLj1wKHVuKT0gdHJ1ZS5cbiAgIElmIHRoaXMgayA9IDEgKHJlc3AgbiksIGZpbmRfbGFzdF9ub3Rfc2F0aXNmeWluZyAocmVzcCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcpXG4gICB3aWxsIHJldHVybiBOb25lLiAqKVxuXG5sZXQgcmVjIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gIGlmIGxvID4gaGlcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgcHJlZCAoZ2V0IHQgbG8pXG4gIHRoZW4gU29tZSBsb1xuICBlbHNlIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihsbyArIDEpIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYSBjb250YWluZXIgW3RdLCBhIHByZWRpY2F0ZSBbcHJlZF0gYW5kIHR3byBpbmRpY2VzIFtsbyA8IGhpXSwgc3VjaCB0aGF0XG4gICBbcHJlZF0gaXMgaW5jcmVhc2luZyBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLlxuXG4gICByZXR1cm4gYSByYW5nZSAobG8sIGhpKSB3aGVyZTpcbiAgIC0gbG8gYW5kIGhpIGFyZSBjbG9zZSBlbm91Z2ggdG9nZXRoZXIgZm9yIGEgbGluZWFyIHNlYXJjaFxuICAgLSBJZiBbcHJlZF0gaXMgbm90IGNvbnN0YW50bHkgW2ZhbHNlXSBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICBvbiB3aGljaCBbcHJlZF0gaXMgW3RydWVdIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXS4gKilcbigqIEludmFyaWFudDogdGhlIGZpcnN0IGVsZW1lbnQgc2F0aXNmeWluZyBbcHJlZF0sIGlmIGl0IGV4aXN0cyBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0gKilcbmxldCByZWMgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICAoKiBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHRlcm1pbmF0ZSBpZiB0aGUgY29uc3RhbnQgKGN1cnJlbnRseSA4KSBpc1xuICAgICBzZXQgPD0gMSAqKVxuICBpZiBoaSAtIGxvIDw9IDhcbiAgdGhlbiBsbywgaGlcbiAgZWxzZSAoXG4gICAgbGV0IG1pZCA9IGxvICsgKChoaSAtIGxvKSAvIDIpIGluXG4gICAgaWYgcHJlZCAoZ2V0IHQgbWlkKVxuICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCBpcyBiZXR3ZWVuIFtsb10gYW5kIFttaWRdICopXG4gICAgdGhlblxuICAgICAgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGk6bWlkIH5wcmVkXG4gICAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQsIGlmIGl0IGV4aXN0cyxcbiAgICAgICAgIGlzIGJldHdlZW4gW21pZCsxXSBhbmQgW2hpXSAqKVxuICAgIGVsc2UgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobWlkICsgMSkgfmhpIH5wcmVkKVxuOztcblxubGV0IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxvID0gcG9zIGluXG4gIGxldCBoaSA9IHBvcyArIGxlbiAtIDEgaW5cbiAgbGV0IGxvLCBoaSA9IGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkIGluXG4gIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYW4gYXJyYXkgd2l0aCBzaGFwZSBbdHJ1ZSwuLi50cnVlLGZhbHNlLC4uLmZhbHNlXSAoaS5lLiwgdGhlIF9yZXZlcnNlXyBvZiB3aGF0XG4gICBpcyBkZXNjcmliZWQgYWJvdmUpIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB0cnVlIG9yIE5vbmUgaWYgdGhlcmUgYXJlIG5vXG4gICB0cnVlKilcbmxldCBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+cHJlZCB+Z2V0IH5sZW5ndGggPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgKCogVGhlIGxhc3Qgc2F0aXNmeWluZyBpcyB0aGUgb25lIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBub3Qgc2F0aXNmeWluZyAqKVxuICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB+cG9zIH5sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KEZuLm5vbiBwcmVkKSB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgKHBvcyArIGxlbiAtIDEpXG4gICAgKCogVGhpcyBtZWFucyB0aGF0IGFsbCBlbGVtZW50cyBzYXRpc2Z5IHByZWQuXG4gICAgICAgVGhlcmUgaXMgYXQgbGVhc3QgYW4gZWxlbWVudCBhcyAobGVuID4gMCkgKilcbiAgICB8IFNvbWUgaSB3aGVuIGkgPSBwb3MgLT4gTm9uZSAoKiBubyBlbGVtZW50IHNhdGlzZmllcyBwcmVkICopXG4gICAgfCBTb21lIGkgLT4gU29tZSAoaSAtIDEpKVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5jb21wYXJlIGhvdyB2ID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMClcbiAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPiAwKVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+c2VnbWVudF9vZiBob3cgPVxuICBsZXQgaXNfbGVmdCB4ID1cbiAgICBtYXRjaCBzZWdtZW50X29mIHggd2l0aFxuICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gIGluXG4gIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfbGVmdFxuICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX3JpZ2h0XG47O1xuIiwiKCoqIE1vZHVsZSB0eXBlcyBmb3IgYSBbYmluYXJ5X3NlYXJjaF0gZnVuY3Rpb24gZm9yIGEgc2VxdWVuY2UsIGFuZCBmdW5jdG9ycyBmb3IgYnVpbGRpbmdcbiAgICBbYmluYXJ5X3NlYXJjaF0gZnVuY3Rpb25zLiAqKVxuXG5vcGVuISBJbXBvcnRcblxuKCoqIEFuIFtJbmRleGFibGVdIHR5cGUgaXMgYSBmaW5pdGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMgaW5kZXhlZCBieSBjb25zZWN1dGl2ZSBpbnRlZ2Vyc1xuICAgIFswXSAuLi4gW2xlbmd0aCB0IC0gMV0uICBbZ2V0XSBhbmQgW2xlbmd0aF0gbXVzdCBiZSBPKDEpIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgW2JpbmFyeV9zZWFyY2hdIHRvIGJlIGxnKG4pLiAqKVxubW9kdWxlIHR5cGUgSW5kZXhhYmxlID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuXG4gIHZhbCBnZXQgOiB0IC0+IGludCAtPiBlbHRcbiAgdmFsIGxlbmd0aCA6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIHR5cGUgSW5kZXhhYmxlMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X2tleSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZV1cblxuICBsZXQgYWxsID1cbiAgICAoWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW5cbiAgICAgOyBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgOyBgTGFzdF9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgIF1cbiAgICAgOiB0IGxpc3QpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X29uX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodFxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZV1cblxuICBsZXQgYWxsID0gKFsgYExhc3Rfb25fbGVmdDsgYEZpcnN0X29uX3JpZ2h0IF0gOiB0IGxpc3QpXG5cbiAgW0BAQGVuZF1cbmVuZFxuXG50eXBlICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaCA9XG4gID9wb3M6aW50XG4gIC0+ID9sZW46aW50XG4gIC0+ICd0XG4gIC0+IGNvbXBhcmU6KCdlbHQgLT4gJ2tleSAtPiBpbnQpXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9rZXkudFxuICAtPiAna2V5XG4gIC0+IGludCBvcHRpb25cblxudHlwZSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gc2VnbWVudF9vZjooJ2VsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgLT4gaW50IG9wdGlvblxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF0gaW4gYmluYXJ5X3NlYXJjaC5tbCAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICh0LCBlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcblxuICAoKiogU2VlIFtCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA6ICh0LCBlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2ggOiAoJ2EgdCwgJ2EsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKCdhIHQsICdhKSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJpbmFyeV9zZWFyY2hhYmxlID0gc2lnXG4gIG1vZHVsZSB0eXBlIFMgPSBTXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlID0gSW5kZXhhYmxlXG4gIG1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBJbmRleGFibGUxXG5cbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBXaGljaF90YXJnZXRfYnlfa2V5XG4gIG1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50XG5cbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID0gKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoXG4gIHR5cGUgbm9ucmVjICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5cbiAgbW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgd2l0aCB0eXBlIGVsdCA6PSBULmVsdFxuICBtb2R1bGUgTWFrZTEgKFQgOiBJbmRleGFibGUxKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG5tb2R1bGUgdHlwZSBBcmcgPSBzaWdcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIGVsdFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuXG4gIGxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5jb21wYXJlIGhvdyB2XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAnYSBlbHQgPSBULmVsdFxuICAgIHR5cGUgJ2EgdCA9IFQudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICdhIHQgPSAnYSBULnRcblxuICAgIGxldCBnZXQgPSBULmdldFxuICAgIGxldCBsZW5ndGggPSBULmxlbmd0aFxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlblxuICAgIChTcmMgOiBTZXF1ZW5jZV9nZW4pIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIFNlcXVlbmNlX2dlblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSBTcmMudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIFNyYy50LCAnYSB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuc3RydWN0XG4gIGxldCB1bnNhZmVfYmxpdCA9IERzdC51bnNhZmVfYmxpdFxuXG4gIGxldCBibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOnNyY19wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOmRzdF9wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KERzdC5sZW5ndGggZHN0KTtcbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW5cbiAgOztcblxuICBsZXQgYmxpdG9cbiAgICAgICAgfnNyY1xuICAgICAgICA/KHNyY19wb3MgPSAwKVxuICAgICAgICA/KHNyY19sZW4gPSBTcmMubGVuZ3RoIHNyYyAtIHNyY19wb3MpXG4gICAgICAgIH5kc3RcbiAgICAgICAgPyhkc3RfcG9zID0gMClcbiAgICAgICAgKClcbiAgICA9XG4gICAgYmxpdCB+c3JjIH5zcmNfcG9zIH5sZW46c3JjX2xlbiB+ZHN0IH5kc3RfcG9zXG4gIDs7XG5cbiAgKCogW3N1Yl0gYW5kIFtzdWJvXSBlbnN1cmUgdGhhdCBldmVyeSBwb3NpdGlvbiBvZiB0aGUgY3JlYXRlZCBzZXF1ZW5jZSBpcyBwb3B1bGF0ZWQgYnlcbiAgICAgYW4gZWxlbWVudCBvZiB0aGUgc291cmNlIGFycmF5LiAgVGh1cyBldmVyeSBlbGVtZW50IG9mIFtkc3RdIGJlbG93IGlzIHdlbGxcbiAgICAgZGVmaW5lZC4gKilcbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgbGV0IGRzdCA9IERzdC5jcmVhdGVfbGlrZSB+bGVuIHNyYyBpblxuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICBkc3RcbiAgOztcblxuICBsZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgICBzdWJcbiAgICAgIHNyY1xuICAgICAgfnBvc1xuICAgICAgfmxlbjpcbiAgICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgICB8IE5vbmUgLT4gU3JjLmxlbmd0aCBzcmMgLSBwb3MpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChTZXF1ZW5jZSA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBibGl0XG4gIGVuZCkgPVxuICBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UxX2dlbmVyaWMgKFNlcXVlbmNlIDogU2VxdWVuY2UxKSA9IE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZSAoU2VxdWVuY2UgOiBzaWdcbiAgICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiB0XG4gICAgdmFsIHVuc2FmZV9ibGl0IDogKHQsIHQpIGJsaXRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFNlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gU2VxdWVuY2UudFxuXG4gICAgb3BlbiBTZXF1ZW5jZVxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5lbmRcblxubW9kdWxlIE1ha2VfZGlzdGluY3RcbiAgICAoU3JjIDogU2VxdWVuY2UpIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKFNyYy50LCB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE1ha2VfZ2VuXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gU3JjLnRcblxuICAgICAgb3BlbiBTcmNcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBEc3QudFxuXG4gICAgICBvcGVuIERzdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gICAgZW5kKVxuXG5tb2R1bGUgTWFrZV90b19zdHJpbmcgKFQgOiBzaWdcbiAgICB0eXBlIHRcbiAgZW5kKVxuICAgIChUb19ieXRlcyA6IFNfZGlzdGluY3Qgd2l0aCB0eXBlIHNyYyA6PSBULnQgd2l0aCB0eXBlIGRzdCA6PSBieXRlcykgPVxuc3RydWN0XG4gIG9wZW4gVG9fYnl0ZXNcblxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWIgc3JjIH5wb3MgfmxlbilcbiAgOztcblxuICBsZXQgc3VibyA/cG9zID9sZW4gc3JjID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3VibyA/cG9zID9sZW4gc3JjKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfb3B0aW9uXG5cbiAgbGV0IGhhc2hfZm9sZF90IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGhhc2hfZm9sZF9vcHRpb25cbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgICBvcHRpb25fb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIHNleHBfb2Zfb3B0aW9uXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBvcHRpb25fc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSBvcHRpb24gW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID1cbiAgfCBOb25lXG4gIHwgU29tZSBvZiAnYVxuXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NvbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHZhbHVlX21hcCBvIH5kZWZhdWx0IH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IGYgeFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuOztcblxubGV0IGl0ZXIgbyB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxuXG5sZXQgY2FsbCB4IH5mID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmIHhcbjs7XG5cbmxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCB2YWx1ZV9leG4gP2hlcmUgP2Vycm9yID9tZXNzYWdlIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT5cbiAgICBsZXQgZXJyb3IgPVxuICAgICAgbWF0Y2ggaGVyZSwgZXJyb3IsIG1lc3NhZ2Ugd2l0aFxuICAgICAgfCBOb25lLCBOb25lLCBOb25lIC0+IEVycm9yLm9mX3N0cmluZyBcIk9wdGlvbi52YWx1ZV9leG4gTm9uZVwiXG4gICAgICB8IE5vbmUsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5vZl9zdHJpbmcgbVxuICAgICAgfCBOb25lLCBTb21lIGUsIE5vbmUgLT4gZVxuICAgICAgfCBOb25lLCBTb21lIGUsIFNvbWUgbSAtPiBFcnJvci50YWcgZSB+dGFnOm1cbiAgICAgIHwgU29tZSBwLCBOb25lLCBOb25lIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSBcIk9wdGlvbi52YWx1ZV9leG5cIiBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBOb25lLCBTb21lIG0gLT4gRXJyb3IuY3JlYXRlIG0gcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgU29tZSBlLCBfIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZVxuICAgICAgICAgICh2YWx1ZSBtZXNzYWdlIH5kZWZhdWx0OlwiXCIpXG4gICAgICAgICAgKGUsIHApXG4gICAgICAgICAgKHNleHBfb2ZfcGFpciBFcnJvci5zZXhwX29mX3QgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdClcbiAgICBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgdmFsdWVfb3JfdGh1bmsgbyB+ZGVmYXVsdCA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0ICgpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW3x8XVxuICB8IFNvbWUgeCAtPiBbfCB4IHxdXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgeCAtPiBbIHggXVxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZTpfID0gdFxubGV0IG1heF9lbHQgdCB+Y29tcGFyZTpfID0gdFxuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICB2YWx1ZV9tYXAgdCB+ZGVmYXVsdDpNLnplcm8gfmZcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgYScgLT4gZXF1YWwgYSBhJ1xuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBfIC0+IDFcbjs7XG5cbmxldCBpc19lbXB0eSA9IGlzX25vbmVcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gaW5pdFxuICB8IFNvbWUgeCAtPiBmIGluaXQgeFxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIGEgLT4gaWYgZiBhIHRoZW4gMSBlbHNlIDBcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gaWYgZiB4IHRoZW4gdCBlbHNlIE5vbmVcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGVxdWFsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHNvbWUgeCA9IFNvbWUgeFxuXG5sZXQgZmlyc3Rfc29tZSB4IHkgPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBTb21lIF8gLT4geFxuICB8IE5vbmUgLT4geVxuOztcblxubGV0IHNvbWVfaWYgY29uZCB4ID0gaWYgY29uZCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcblxubGV0IG1lcmdlIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE5vbmUsIHggfCB4LCBOb25lIC0+IHhcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBTb21lIChmIGEgYilcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgdiBhcyBvIHdoZW4gZiB2IC0+IG9cbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiBTb21lIHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IFNvbWUgKGYgYSlcbjs7XG5cbmxldCBhcHBseSBmIHggPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGYgLT4gbWFwIH5mIHhcbjs7XG5cbm1vZHVsZSBNb25hZF9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBhcHBseSA9IGFwcGx5XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBiaW5kIG8gfmYgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNb25hZC5NYWtlIChNb25hZF9hcmcpXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKE1vbmFkX2FyZylcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZVxuXG5tb2R1bGUgT2Zfc2V4cGFibGVcbiAgICAoU2V4cGFibGUgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogdCAtPiBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogU2V4cGFibGUudCAtPiB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTFcbiAgICAoU2V4cGFibGUgOiBTMSkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogJ2EgdCAtPiAnYSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICdhIFNleHBhYmxlLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2EgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUyXG4gICAgKFNleHBhYmxlIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlM1xuICAgIChTZXhwYWJsZSA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3N0cmluZ2FibGUgKE0gOiBTdHJpbmdhYmxlLlMpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IE0ub2Zfc3RyaW5nIHMgd2l0aFxuICAgICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwKVxuICAgIHwgU2V4cC5MaXN0IF8gLT5cbiAgICAgIG9mX3NleHBfZXJyb3JcbiAgICAgICAgXCJTZXhwYWJsZS5PZl9zdHJpbmdhYmxlLnRfb2Zfc2V4cCBleHBlY3RlZCBhbiBhdG9tLCBidXQgZ290IGEgbGlzdFwiXG4gICAgICAgIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKE0udG9fc3RyaW5nIHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBFaXRoZXJfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBFaXRoZXIwXG5cbmxldCBzd2FwID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IFNlY29uZCB4XG4gIHwgU2Vjb25kIHggLT4gRmlyc3QgeFxuOztcblxubGV0IGlzX2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IHRydWVcbiAgfCBTZWNvbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiBmYWxzZVxuICB8IFNlY29uZCBfIC0+IHRydWVcbjs7XG5cbmxldCB2YWx1ZSAoRmlyc3QgeCB8IFNlY29uZCB4KSA9IHhcblxubGV0IHZhbHVlX21hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBmaXJzdCB4XG4gIHwgU2Vjb25kIHggLT4gc2Vjb25kIHhcbjs7XG5cbmxldCBpdGVyID0gdmFsdWVfbWFwXG5cbmxldCBtYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gRmlyc3QgKGZpcnN0IHgpXG4gIHwgU2Vjb25kIHggLT4gU2Vjb25kIChzZWNvbmQgeClcbjs7XG5cbmxldCBmaXJzdCB4ID0gRmlyc3QgeFxubGV0IHNlY29uZCB4ID0gU2Vjb25kIHhcblxubGV0IGVxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCBmIHMgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gZiB4XG4gIHwgU2Vjb25kIHkgLT4gcyB5XG47O1xuXG5tb2R1bGUgTWFrZV9mb2N1c2VkIChNIDogc2lnXG4gICAgdHlwZSAoKydhLCArJ2IpIHRcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgICB2YWwgb3RoZXIgOiAnYiAtPiAoXywgJ2IpIHRcbiAgICB2YWwgZWl0aGVyIDogKCdhLCAnYikgdCAtPiByZXR1cm46KCdhIC0+ICdjKSAtPiBvdGhlcjooJ2IgLT4gJ2MpIC0+ICdjXG5cbiAgICB2YWwgY29tYmluZVxuICAgICAgOiAgKCdhLCAnZCkgdFxuICAgICAgLT4gKCdiLCAnZCkgdFxuICAgICAgLT4gZjooJ2EgLT4gJ2IgLT4gJ2MpXG4gICAgICAtPiBvdGhlcjooJ2QgLT4gJ2QgLT4gJ2QpXG4gICAgICAtPiAoJ2MsICdkKSB0XG5cbiAgICB2YWwgYmluZCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gKCdjLCAnYikgdCkgLT4gKCdjLCAnYikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cbiAgb3BlbiBXaXRoX3JldHVyblxuXG4gIGxldCBtYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKVxuXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgbW9kdWxlIEFwcCA9IEFwcGxpY2F0aXZlLk1ha2UyIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBhcHBseSB0MSB0MiA9IGJpbmQgdDEgfmY6KGZ1biBmIC0+IGJpbmQgdDIgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSkpXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBcHBcblxuICBsZXQgY29tYmluZV9hbGwgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4gXyAtPiBvdGhlcl9sb29wIGYgYWNjIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuIHggLT4gcmV0dXJuX2xvb3AgZiAoeCA6OiBhY2MpIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiBbXSB0c1xuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbF91bml0ID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuICgpIC0+IG90aGVyX2xvb3AgZiBhY2MgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8pIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyIHQgfnJldHVybjooZnVuICgpIC0+IHJldHVybl9sb29wIGYgdHMpIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiB0c1xuICA7O1xuXG4gIGxldCB0b19vcHRpb24gdCA9IGVpdGhlciB0IH5yZXR1cm46T3B0aW9uLnNvbWUgfm90aGVyOihmdW4gXyAtPiBOb25lKVxuICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9IGVpdGhlciB0IH5yZXR1cm46Rm4uaWQgfm90aGVyOihmdW4gXyAtPiBkZWZhdWx0KVxuXG4gIGxldCB3aXRoX3JldHVybiBmID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHJldCAtPiBvdGhlciAoZiAoV2l0aF9yZXR1cm4ucHJlcGVuZCByZXQgfmY6cmV0dXJuKSkpXG4gIDs7XG5lbmRcblxubW9kdWxlIEZpcnN0ID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IGZpcnN0XG4gICAgbGV0IG90aGVyID0gc2Vjb25kXG5cbiAgICBsZXQgZWl0aGVyIHQgfnJldHVybiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpcnN0IHggLT4gcmV0dXJuIHhcbiAgICAgIHwgU2Vjb25kIHkgLT4gb3RoZXIgeVxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAoZiB4IHkpXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKG90aGVyIHggeSlcbiAgICAgIHwgU2Vjb25kIHgsIF8gfCBfLCBTZWNvbmQgeCAtPiBTZWNvbmQgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaXJzdCB4IC0+IGYgeFxuICAgICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24uICopXG4gICAgICB8IFNlY29uZCBfIGFzIHkgLT4geVxuICAgIDs7XG4gIGVuZClcblxubW9kdWxlIFNlY29uZCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICAgIGxldCByZXR1cm4gPSBzZWNvbmRcbiAgICBsZXQgb3RoZXIgPSBmaXJzdFxuXG4gICAgbGV0IGVpdGhlciB0IH5yZXR1cm4gfm90aGVyID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeSAtPiByZXR1cm4geVxuICAgICAgfCBGaXJzdCB4IC0+IG90aGVyIHhcbiAgICA7O1xuXG4gICAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKGYgeCB5KVxuICAgICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChvdGhlciB4IHkpXG4gICAgICB8IEZpcnN0IHgsIF8gfCBfLCBGaXJzdCB4IC0+IEZpcnN0IHhcbiAgICA7O1xuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgU2Vjb25kIHggLT4gZiB4XG4gICAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbiwgbGlrZSBbRmlyc3QuYmluZF0gYWJvdmUuICopXG4gICAgICB8IEZpcnN0IF8gYXMgeSAtPiB5XG4gICAgOztcbiAgZW5kKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdmLCAncykgX2VpdGhlciA9ICgnZiwgJ3MpIHQgPVxuICAgIHwgRmlyc3Qgb2YgJ2ZcbiAgICB8IFNlY29uZCBvZiAnc1xuZW5kXG4iLCJpbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubGV0IGl0ZXJpIH5mb2xkIHQgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIHYgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgdiBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYylcbjs7XG5cbmxldCBjb3VudGkgfmZvbGRpIHQgfmYgPSBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpIG4gYSAtPiBpZiBmIGkgYSB0aGVuIG4gKyAxIGVsc2UgbilcblxubGV0IGV4aXN0c2kgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZm9yX2FsbGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIG5vdCAoZiBpIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXBpIH5pdGVyaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKVxuOztcblxubGV0IGZpbmRpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIChTb21lIChpLCB4KSkpO1xuICAgIE5vbmUpXG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBzaWdcbiAgICBpbmNsdWRlIENvbnRhaW5lcl9pbnRmLk1ha2VfZ2VuX2FyZ1xuXG4gICAgdmFsIGl0ZXJpIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICgnYSB0LCAnYSBlbHQpIGl0ZXJpIF1cbiAgICB2YWwgZm9sZGkgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhIHQsICdhIGVsdCwgXykgZm9sZGkgXVxuICBlbmQpIDogR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBpbmNsdWRlIENvbnRhaW5lci5NYWtlX2dlbiAoVClcblxuICBsZXQgaXRlcmkgPVxuICAgIG1hdGNoIFQuaXRlcmkgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyaSAtPiBpdGVyaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXJpIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgZm9sZGkgPVxuICAgIG1hdGNoIFQuZm9sZGkgd2l0aFxuICAgIHwgYEN1c3RvbSBmb2xkaSAtPiBmb2xkaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5pbml0IH5mIC0+IGZvbGRpIH5mb2xkIHQgfmluaXQgfmZcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPSBjb3VudGkgfmZvbGRpIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IGV4aXN0c2kgfml0ZXJpIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBmb3JfYWxsaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZF9tYXBpIHQgfmYgPSBmaW5kX21hcGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRpIHQgfmYgPSBmaW5kaSB+aXRlcmkgdCB+ZlxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgVC50XG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZTAgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiBDb250YWluZXJfaW50Zi5FeHBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MVxuXG5tb2R1bGUgU3RlcCA9IHN0cnVjdFxuICAoKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2ZcbiAgICAgdGhlIHNlcXVlbmNlICopXG4gIHR5cGUgKCdhLCAncykgdCA9XG4gICAgfCBEb25lXG4gICAgfCBTa2lwIG9mICdzXG4gICAgfCBZaWVsZCBvZiAnYSAqICdzXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdzLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdzKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wMDlfIHNfXzAxMF8pXG4gICAgICAgIDogICgoYV9fMDA5XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMTBfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wMDlfLCBzX18wMTBfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2Zfc19fMDAyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IERvbmUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRG9uZVwiXG4gICAgICAgIHwgU2tpcCBhcmcwX18wMDNfIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBfb2Zfc19fMDAyXyBhcmcwX18wMDNfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2tpcFwiOyByZXMwX18wMDRfIF1cbiAgICAgICAgfCBZaWVsZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDA3XyA9IF9vZl9hX18wMDFfIGFyZzBfXzAwNV9cbiAgICAgICAgICBhbmQgcmVzMV9fMDA4XyA9IF9vZl9zX18wMDJfIGFyZzFfXzAwNl8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJZaWVsZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm9wZW4gU3RlcFxuXG4oKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2YgdGhlXG4gICBzZXF1ZW5jZSAqKVxudHlwZSArXyB0ID0gU2VxdWVuY2UgOiAncyAqICgncyAtPiAoJ2EsICdzKSBTdGVwLnQpIC0+ICdhIHRcbnR5cGUgJ2Egc2VxdWVuY2UgPSAnYSB0XG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IG5leHRfc3RlcCAoU2VxdWVuY2UgKHMsIGYpKSA9XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSlcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgU2VxdWVuY2UgKHMsIGYpKVxuICA7O1xuXG4gIGxldCBkZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgbG9vcCBzIG5leHQgZmluaXNoIGYgYWNjID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgICAgfCBTa2lwIHMgLT4gZiBhY2MgTm9uZSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBmIGFjYyAoU29tZSBhKSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dCBmaW5pc2ggZiBpbml0XG4gIDs7XG5lbmRcblxubGV0IHVuZm9sZF9zdGVwIH5pbml0IH5mID0gU2VxdWVuY2UgKGluaXQsIGYpXG5cbmxldCB1bmZvbGQgfmluaXQgfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjooZnVuIHMgLT5cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGVwLkRvbmVcbiAgICB8IFNvbWUgKGEsIHMpIC0+IFN0ZXAuWWllbGQgKGEsIHMpKVxuOztcblxubGV0IHVuZm9sZF93aXRoIHMgfmluaXQgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoaW5pdCwgcylcbiAgICAgICwgZnVuIChzZWVkLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChzZWVkLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgICAgIChtYXRjaCBmIHNlZWQgYSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzZWVkIC0+IFNraXAgKHNlZWQsIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHNlZWQpIC0+IFlpZWxkIChhLCAoc2VlZCwgcykpKSApXG47O1xuXG5sZXQgdW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCBzIH5pbml0IH5ydW5uaW5nX3N0ZXAgfmlubmVyX2ZpbmlzaGVkIH5maW5pc2hpbmdfc3RlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBJbm5lcl9ydW5uaW5nIChpbml0LCBzKVxuICAgICAgLCBmdW4gc3RhdGUgLT5cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgaW5uZXJfc3RhdGUgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gU2tpcCAoYElubmVyX2ZpbmlzaGVkIChpbm5lcl9maW5pc2hlZCBzdGF0ZSkpXG4gICAgICAgICAgIHwgU2tpcCBpbm5lcl9zdGF0ZSAtPiBTa2lwIChgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSlcbiAgICAgICAgICAgfCBZaWVsZCAoeCwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHJ1bm5pbmdfc3RlcCBzdGF0ZSB4IHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKVxuICAgICAgICAgICAgICB8IFlpZWxkICh5LCBzdGF0ZSkgLT4gWWllbGQgKHksIGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKSkpXG4gICAgICAgIHwgYElubmVyX2ZpbmlzaGVkIHN0YXRlIC0+XG4gICAgICAgICAgKG1hdGNoIGZpbmlzaGluZ19zdGVwIHN0YXRlIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9maW5pc2hlZCBzdGF0ZSlcbiAgICAgICAgICAgfCBZaWVsZCAoeSwgc3RhdGUpIC0+IFlpZWxkICh5LCBgSW5uZXJfZmluaXNoZWQgc3RhdGUpKSApXG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6bCB+ZjooZnVuY3Rpb25cbiAgICB8IFtdIC0+IERvbmVcbiAgICB8IHggOjogbCAtPiBZaWVsZCAoeCwgbCkpXG47O1xuXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCB2IG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gdlxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyB2IG5leHQgZlxuICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoZiB2IGEpIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIGluaXQgbmV4dCBmXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgdCA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpXG5cblxubGV0IHRvX2xpc3QgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgc2FmZV90b19saXN0IHQgPSBMaXN0LnJldiAodG9fbGlzdF9yZXYgdCkgaW5cbiAgbGV0IHJlYyB0b19saXN0IHMgbmV4dCBpID1cbiAgICBpZiBpID0gMFxuICAgIHRoZW4gc2FmZV90b19saXN0IChTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IFtdXG4gICAgICB8IFNraXAgcyAtPiB0b19saXN0IHMgbmV4dCBpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBhIDo6IHRvX2xpc3QgcyBuZXh0IChpIC0gMSkpXG4gIGluXG4gIHRvX2xpc3QgcyBuZXh0IDUwMFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X3Ygc3RvcF92ID1cbiAgbGV0IHN0ZXAgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgYGluY2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID4gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGluY2x1c2l2ZSAtPiBmdW4gaSAtPiBpZiBpIDwgc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGV4Y2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID49IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgICB8IGBleGNsdXNpdmUgLT4gZnVuIGkgLT4gaWYgaSA8PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gIGluXG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X3ZcbiAgICB8IGBleGNsdXNpdmUgLT4gc3RhcnRfdiArIHN0cmlkZVxuICBpblxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjpzdGVwXG47O1xuXG5sZXQgb2ZfbGF6eSB0X2xhenkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDp0X2xhenkgfmY6KGZ1biB0X2xhenkgLT5cbiAgICBsZXQgKFNlcXVlbmNlIChzLCBuZXh0KSkgPSBMYXp5LmZvcmNlIHRfbGF6eSBpblxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPlxuICAgICAgU2tpcFxuICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgIGxhenkgdilcbiAgICB8IFlpZWxkICh4LCBzKSAtPlxuICAgICAgWWllbGRcbiAgICAgICAgKCB4XG4gICAgICAgICwgbGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgICBsYXp5IHYgKSlcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChmIGEsIHMpIClcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoZiBpIGEsIChpICsgMSwgcykpIClcbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdCB+ZjooZnVuIGFjYyB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgYWNjKSlcbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGkgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgKGkgKyAxLCBhY2MpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFlpZWxkIChhLCBzKVxuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIHMgKVxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIG1hcCB+ZjpzbmQgKGZpbHRlciAobWFwaSB0IH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGlcbiAgICB8IFNraXAgcyAtPiBsb29wIGkgcyBuZXh0XG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCAoaSArIDEpIHMgbmV4dFxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6KFtdLCAwKSB+ZjooZnVuIChsLCBpKSB4IC0+IHggOjogbCwgaSArIDEpXG5cbmxldCB0b19hcnJheSB0ID1cbiAgbGV0IGwsIGxlbiA9IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IHggOjogbCAtPlxuICAgIGxldCBhID0gQXJyYXkuY3JlYXRlIH5sZW4geCBpblxuICAgIGxldCByZWMgbG9vcCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IC0xKVxuICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgYS4oaSkgPC0geDtcbiAgICAgICAgbG9vcCAoaSAtIDEpIGxcbiAgICBpblxuICAgIGxvb3AgKGxlbiAtIDIpIGw7XG4gICAgYVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBhIC0+IFNvbWUgYVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBmIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGYgaSBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgaSBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgaSBhIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gKClcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIGYgYTtcbiAgICAgIGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCBfIC0+IGZhbHNlXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBhID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGIsIF8pIHdoZW4gZXF1YWwgYSBiIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBhXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBhXG47O1xuXG5sZXQgZW1wdHkgPSBTZXF1ZW5jZSAoKCksIGZ1biAoKSAtPiBEb25lKVxuXG5sZXQgYmluZCB0IH5mID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpLCByZXN0IC0+XG4gICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgfCBEb25lIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGVtcHR5LCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBTa2lwIChmIGEsIFNlcXVlbmNlIChzLCBuZXh0KSkpKVxuICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIG5leHQpLCByZXN0KVxuICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChTZXF1ZW5jZSAocywgbmV4dCksIHJlc3QpKSkpXG4gICAgfmluaXQ6KGVtcHR5LCB0KVxuOztcblxubGV0IHJldHVybiB4ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6KFNvbWUgeCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IERvbmVcbiAgICB8IFNvbWUgeCAtPiBZaWVsZCAoeCwgTm9uZSkpXG47O1xuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGVuZClcblxubGV0IG50aCBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTm9uZVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIHMgbmV4dFxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gaWYgcGh5c19lcXVhbCBpIDAgdGhlbiBTb21lIGEgZWxzZSBsb29wIChpIC0gMSkgcyBuZXh0XG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIG4gcyBuZXh0KVxuOztcblxubGV0IG50aF9leG4gcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLm50aFwiXG4gIGVsc2UgKFxuICAgIG1hdGNoIG50aCBzIG4gd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLm50aFwiXG4gICAgfCBTb21lIHggLT4geClcbjs7XG5cbm1vZHVsZSBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgTGVmdCBvZiAnYVxuICAgIHwgUmlnaHQgb2YgJ2JcbiAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAxMV8gYl9fMDEyX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDExXywgYl9fMDEyXyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAxM18sIExlZnQgX2JfXzAxNF8gLT4gX2NtcF9fYSBfYV9fMDEzXyBfYl9fMDE0X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgTGVmdCBfIC0+IDFcbiAgICAgIHwgUmlnaHQgX2FfXzAxNV8sIFJpZ2h0IF9iX18wMTZfIC0+IF9jbXBfX2IgX2FfXzAxNV8gX2JfXzAxNl9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBSaWdodCBfIC0+IDFcbiAgICAgIHwgQm90aCAoX2FfXzAxN18sIF9hX18wMTlfKSwgQm90aCAoX2JfXzAxOF8sIF9iX18wMjBfKSAtPlxuICAgICAgICAobWF0Y2ggX2NtcF9fYSBfYV9fMDE3XyBfYl9fMDE4XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fYiBfYV9fMDE5XyBfYl9fMDIwX1xuICAgICAgICAgfCBuIC0+IG4pKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdFxuICAgIDogdHlwZSBhIGIuXG4gICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgLT4gKGEsIGIpIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgfCBMZWZ0IF9hMCAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgIHwgUmlnaHQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuICAgICAgfCBCb3RoIChfYTAsIF9hMSkgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMiBpblxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgICAgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTFcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDQ0XyBiX18wNDVfKVxuICAgICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wNDRfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzA0NV8pXG4gICAgICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKGFfXzA0NF8sIGJfXzA0NV8pIHQpIC0+XG4gICAgICBsZXQgZXJyb3Jfc291cmNlX18wMjVfID0gXCJzZXF1ZW5jZS5tbC5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50XCIgaW5cbiAgICAgIGZ1biBfb2ZfYV9fMDIxXyBfb2ZfYl9fMDIyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIF90YWdfXzAyOF8pIDo6IHNleHBfYXJnc19fMDI5XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDI3XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyOV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDMwXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBfb2ZfYV9fMDIxXyBhcmcwX18wMzBfIGluXG4gICAgICAgICAgICAgTGVmdCByZXMwX18wMzFfXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDI4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAyN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBfdGFnX18wMzNfKSA6OiBzZXhwX2FyZ3NfXzAzNF8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzMl8gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzRfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzAzNV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wMzZfID0gX29mX2JfXzAyMl8gYXJnMF9fMDM1XyBpblxuICAgICAgICAgICAgIFJpZ2h0IHJlczBfXzAzNl9cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMzNfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDMyXylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBfdGFnX18wMzhfKSA6OiBzZXhwX2FyZ3NfXzAzOV8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzN18gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzlfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzA0MF87IGFyZzFfXzA0MV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wNDJfID0gX29mX2FfXzAyMV8gYXJnMF9fMDQwX1xuICAgICAgICAgICAgIGFuZCByZXMxX18wNDNfID0gX29mX2JfXzAyMl8gYXJnMV9fMDQxXyBpblxuICAgICAgICAgICAgIEJvdGggKHJlczBfXzA0Ml8sIHJlczFfXzA0M18pXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDM4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAzN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNl9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAyNF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjRfXG4gICAgICAgIHwgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDU2XyBiX18wNTdfKVxuICAgICAgICA6ICAoKGFfXzA1Nl8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDU3XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgICAtPiAoYV9fMDU2XywgYl9fMDU3XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgICBmdW4gX29mX2FfXzA0Nl8gX29mX2JfXzA0N18gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBMZWZ0IGFyZzBfXzA0OF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDQ5XyA9IF9vZl9hX18wNDZfIGFyZzBfXzA0OF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IHJlczBfXzA0OV8gXVxuICAgICAgICB8IFJpZ2h0IGFyZzBfXzA1MF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDUxXyA9IF9vZl9iX18wNDdfIGFyZzBfXzA1MF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyByZXMwX18wNTFfIF1cbiAgICAgICAgfCBCb3RoIChhcmcwX18wNTJfLCBhcmcxX18wNTNfKSAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX2FfXzA0Nl8gYXJnMF9fMDUyX1xuICAgICAgICAgIGFuZCByZXMxX18wNTVfID0gX29mX2JfXzA0N18gYXJnMV9fMDUzXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIjsgcmVzMF9fMDU0XzsgcmVzMV9fMDU1XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJCb3RoXCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubGV0IG1lcmdlX3dpdGhfZHVwbGljYXRlcyAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgfmNvbXBhcmUgPVxuICBsZXQgdW5zaGFkb3dlZF9jb21wYXJlID0gY29tcGFyZSBpblxuICBsZXQgb3BlbiBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCBpblxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCAoWWllbGQgKGEsIHMxJykgYXMgczEpLCAoWWllbGQgKGIsIHMyJykgYXMgczIpIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IHVuc2hhZG93ZWRfY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPCAwXG4gICAgICB0aGVuIFlpZWxkIChMZWZ0IGEsIChTa2lwIHMxJywgczIpKVxuICAgICAgZWxzZSBpZiBjb21wYXJpc29uID0gMFxuICAgICAgdGhlbiBZaWVsZCAoQm90aCAoYSwgYiksIChTa2lwIHMxJywgU2tpcCBzMicpKVxuICAgICAgZWxzZSBZaWVsZCAoUmlnaHQgYiwgKHMxLCBTa2lwIHMyJykpXG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKExlZnQgYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoUmlnaHQgYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCBzMSBzMiB+Y29tcGFyZSA9XG4gIG1hcCAobWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIHMxIHMyIH5jb21wYXJlKSB+ZjooZnVuY3Rpb25cbiAgICB8IExlZnQgeCB8IFJpZ2h0IHggfCBCb3RoICh4LCBfKSAtPiB4KVxuOztcblxubGV0IChtZXJnZSBbQGRlcHJlY2F0ZWRcbiAgICAgICBcIltzaW5jZSAyMDIxLTA3XSBGb3IgaWRlbnRpY2FsIGJlaGF2aW9yLCB1c2UgXFxcbiAgICAgICAgW1NlcXVlbmNlLm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZF0sIGJ1dCBjb25zaWRlciB1c2luZyBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2Vfc29ydGVkXSBpbnN0ZWFkLlwiXSlcbiAgPVxuICBtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWRcbjs7XG5cbmxldCBtZXJnZV9zb3J0ZWQgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpIH5jb21wYXJlID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgKFlpZWxkIChhLCBzMScpIGFzIHMxKSwgKFlpZWxkIChiLCBzMicpIGFzIHMyKSAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSBjb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8PSAwIHRoZW4gWWllbGQgKGEsIChTa2lwIHMxJywgczIpKSBlbHNlIFlpZWxkIChiLCAoczEsIFNraXAgczInKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGhkIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChhLCBfKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgaGRfZXhuIHMgPVxuICBtYXRjaCBoZCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiaGRfZXhuXCJcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHRsIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChfLCBhKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgKG1hdGNoIGxvb3AgcyBuZXh0IHdpdGhcbiAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfCBTb21lIHMgLT4gU29tZSAoU2VxdWVuY2UgKHMsIG5leHQpKSlcbjs7XG5cbmxldCB0bF9lYWdlcmx5X2V4biBzID1cbiAgbWF0Y2ggdGwgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRsX2V4blwiXG4gIHwgU29tZSBzIC0+IHNcbjs7XG5cbmxldCBsaWZ0X2lkZW50aXR5IG5leHQgcyA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgRG9uZSAtPiBEb25lXG4gIHwgU2tpcCBzIC0+IFNraXAgKGBJZGVudGl0eSBzKVxuICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYElkZW50aXR5IHMpXG47O1xuXG5sZXQgbmV4dCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCAoYSwgcykgLT4gU29tZSAoYSwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBmaWx0ZXJfb3B0IHMgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChOb25lLCBzKSAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoU29tZSBhLCBzKSAtPiBZaWVsZCAoYSwgcykgKVxuOztcblxubGV0IGZpbHRlcl9tYXAgcyB+ZiA9IGZpbHRlcl9vcHQgKG1hcCBzIH5mKVxubGV0IGZpbHRlcl9tYXBpIHMgfmYgPSBmaWx0ZXJfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgc3BsaXRfbiBzIG4gPVxuICBsZXQgcmVjIGxvb3AgcyBpIGFjY3VtIG5leHQgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gTGlzdC5yZXYgYWNjdW0sIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBMaXN0LnJldiBhY2N1bSwgZW1wdHlcbiAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBpIGFjY3VtIG5leHRcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoaSAtIDEpIChhIDo6IGFjY3VtKSBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG4gW10gbmV4dFxuOztcblxubGV0IGNodW5rc19leG4gdCBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jaHVua3NfZXhuXCJcbiAgZWxzZVxuICAgIHVuZm9sZF9zdGVwIH5pbml0OnQgfmY6KGZ1biB0IC0+XG4gICAgICBtYXRjaCBzcGxpdF9uIHQgbiB3aXRoXG4gICAgICB8IFtdLCBfZW1wdHkgLT4gRG9uZVxuICAgICAgfCAoXyA6OiBfIGFzIHhzKSwgdCAtPiBZaWVsZCAoeHMsIHQpKVxuOztcblxubGV0IGZpbmRpIHMgfmYgPSBmaW5kIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgZmluZF9leG4gcyB+ZiA9XG4gIG1hdGNoIGZpbmQgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLmZpbmRfZXhuXCJcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIG1hdGNoIHMxLCBzMiB3aXRoXG4gIHwgU2VxdWVuY2UgKHMxLCBuZXh0MSksIFNlcXVlbmNlIChzMiwgbmV4dDIpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEZpcnN0X2xpc3QgczFcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRmlyc3RfbGlzdCBzMSAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0MSBzMSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIChgU2Vjb25kX2xpc3QgczIpXG4gICAgICAgICAgIHwgU2tpcCBzMSAtPiBTa2lwIChgRmlyc3RfbGlzdCBzMSlcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczEpIC0+IFlpZWxkIChhLCBgRmlyc3RfbGlzdCBzMSkpXG4gICAgICAgIHwgYFNlY29uZF9saXN0IHMyIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQyIHMyIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKGBTZWNvbmRfbGlzdCBzMilcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczIpIC0+IFlpZWxkIChhLCBgU2Vjb25kX2xpc3QgczIpKSApXG47O1xuXG5sZXQgY29uY2F0X21hcCBzIH5mID0gYmluZCBzIH5mXG5sZXQgY29uY2F0IHMgPSBjb25jYXRfbWFwIHMgfmY6Rm4uaWRcbmxldCBjb25jYXRfbWFwaSBzIH5mID0gY29uY2F0X21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHppcCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkICgoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIF8gfCBfLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCB6aXBfZnVsbCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChgQm90aCAoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYFJpZ2h0IGIsIChEb25lLCBuZXh0MiBzMikpXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChgTGVmdCBhLCAobmV4dDEgczEsIERvbmUpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGJvdW5kZWRfbGVuZ3RoIChTZXF1ZW5jZSAoc2VlZCwgbmV4dCkpIH5hdF9tb3N0ID1cbiAgbGV0IHJlYyBsb29wIGkgc2VlZCBuZXh0ID1cbiAgICBpZiBpID4gYXRfbW9zdFxuICAgIHRoZW4gYEdyZWF0ZXJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICB8IERvbmUgLT4gYElzIGlcbiAgICAgIHwgU2tpcCBzZWVkIC0+IGxvb3AgaSBzZWVkIG5leHRcbiAgICAgIHwgWWllbGQgKF8sIHNlZWQpIC0+IGxvb3AgKGkgKyAxKSBzZWVkIG5leHQpXG4gIGluXG4gIGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCBsZW5ndGhfaXNfYm91bmRlZF9ieSA/KG1pbiA9IC0xKSA/bWF4IHQgPVxuICBsZXQgbGVuZ3RoX2lzX2F0X2xlYXN0IChTZXF1ZW5jZSAocywgbmV4dCkpID1cbiAgICBsZXQgcmVjIGxvb3AgcyBhY2MgPVxuICAgICAgaWYgYWNjID49IG1pblxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBhY2NcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIChhY2MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgcyAwXG4gIGluXG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBsZW5ndGhfaXNfYXRfbGVhc3QgdFxuICB8IFNvbWUgbWF4IC0+XG4gICAgKG1hdGNoIGJvdW5kZWRfbGVuZ3RoIHQgfmF0X21vc3Q6bWF4IHdpdGhcbiAgICAgfCBgSXMgbGVuIHdoZW4gbGVuID49IG1pbiAtPiB0cnVlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBpdGVyaSBzIH5mID0gaXRlciAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IGZvbGRpIHMgfmluaXQgfmYgPVxuICBmb2xkIH5pbml0IChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gYWNjIChpLCBzKSAtPiBmIGkgYWNjIHMpXG47O1xuXG5sZXQgcmVkdWNlIHMgfmYgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGEsIHMpIC0+IFNvbWUgKGZvbGQgcyB+aW5pdDphIH5mKVxuOztcblxubGV0IHJlZHVjZV9leG4gcyB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UucmVkdWNlX2V4blwiXG4gIHwgU29tZSByZXMgLT4gcmVzXG47O1xuXG5sZXQgZ3JvdXAgKFNlcXVlbmNlIChzLCBuZXh0KSkgfmJyZWFrID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+aW5pdDooU29tZSAoW10sIHMpKVxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IERvbmVcbiAgICAgIHwgU29tZSAoYWNjLCBzKSAtPlxuICAgICAgICAobWF0Y2ggYWNjLCBuZXh0IHMgd2l0aFxuICAgICAgICAgfCBfLCBTa2lwIHMgLT4gU2tpcCAoU29tZSAoYWNjLCBzKSlcbiAgICAgICAgIHwgW10sIERvbmUgLT4gRG9uZVxuICAgICAgICAgfCBhY2MsIERvbmUgLT4gWWllbGQgKExpc3QucmV2IGFjYywgTm9uZSlcbiAgICAgICAgIHwgW10sIFlpZWxkIChjdXIsIHMpIC0+IFNraXAgKFNvbWUgKFsgY3VyIF0sIHMpKVxuICAgICAgICAgfCAocHJldiA6OiBfIGFzIGFjYyksIFlpZWxkIChjdXIsIHMpIC0+XG4gICAgICAgICAgIGlmIGJyZWFrIHByZXYgY3VyXG4gICAgICAgICAgIHRoZW4gWWllbGQgKExpc3QucmV2IGFjYywgU29tZSAoWyBjdXIgXSwgcykpXG4gICAgICAgICAgIGVsc2UgU2tpcCAoU29tZSAoY3VyIDo6IGFjYywgcykpKSlcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgbGFzdF9lbHQgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgbGFzdF9lbHQgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggbGFzdF9lbHQgd2l0aFxuICAgICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNvbWUgKGIsIGEpXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IGxvb3AgKFNvbWUgYSkgcylcbiAgaW5cbiAgbG9vcCBOb25lIHNcbjs7XG5cbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyBzIH5lcXVhbCA9XG4gIHVuZm9sZF93aXRoIHMgfmluaXQ6Tm9uZSB+ZjooZnVuIHByZXYgYSAtPlxuICAgIG1hdGNoIHByZXYgd2l0aFxuICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNraXAgKFNvbWUgYSlcbiAgICB8IE5vbmUgfCBTb21lIF8gLT4gWWllbGQgKGEsIFNvbWUgYSkpXG47O1xuXG5sZXQgY291bnQgcyB+ZiA9IGxlbmd0aCAoZmlsdGVyIHMgfmYpXG5sZXQgY291bnRpIHQgfmYgPSBsZW5ndGggKGZpbHRlcmkgdCB+ZilcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT4gaWYgaSA+PSBuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIChmIGksIGkgKyAxKSlcbjs7XG5cbmxldCBzdWIgcyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnN1YlwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpIC0gcG9zID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IHBvcyAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIChpICsgMSwgcykpIClcbjs7XG5cbmxldCB0YWtlIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UudGFrZVwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChpICsgMSwgcykpKSApXG47O1xuXG5sZXQgZHJvcCBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLmRyb3BcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IGxlbiAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gU2tpcCAoaSArIDEsIHMpIClcbjs7XG5cbmxldCB0YWtlX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBZaWVsZCAoYSwgcylcbiAgICAgICAgfCBZaWVsZCAoXywgXykgLT4gRG9uZSApXG47O1xuXG5sZXQgZHJvcF93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYERyb3BwaW5nIHNcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRHJvcHBpbmcgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgRHJvcHBpbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gU2tpcCAoYERyb3BwaW5nIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgSWRlbnRpdHkgcykpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0IHMgeCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBDb25zaW5nIChzZWVkLCB4KVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBDb25zaW5nIChzZWVkLCB4KSAtPiBZaWVsZCAoeCwgYElkZW50aXR5IHNlZWQpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCBzIGwgPSBhcHBlbmQgKG9mX2xpc3QgbCkgc1xubGV0IHNoaWZ0X2xlZnQgPSBkcm9wXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgaW50ZXJzcGVyc2UgcyB+c2VwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEluaXQgc1xuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBJbml0IHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYEluaXQgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpKVxuICAgICAgICB8IGBSdW5uaW5nIHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYFJ1bm5pbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKHNlcCwgYFB1dHRpbmcgKGEsIHMpKSlcbiAgICAgICAgfCBgUHV0dGluZyAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpIClcbjs7XG5cbmxldCByZXBlYXQgeCA9IHVuZm9sZF9zdGVwIH5pbml0OnggfmY6KGZ1biB4IC0+IFlpZWxkICh4LCB4KSlcblxubGV0IGN5Y2xlX2xpc3RfZXhuIHhzID1cbiAgaWYgTGlzdC5pc19lbXB0eSB4cyB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY3ljbGVfbGlzdF9leG5cIjtcbiAgbGV0IHMgPSBvZl9saXN0IHhzIGluXG4gIGNvbmNhdF9tYXAgfmY6KGZ1biAoKSAtPiBzKSAocmVwZWF0ICgpKVxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHNhIHNiID0gY29uY2F0X21hcCBzYSB+ZjooZnVuIGEgLT4gemlwIChyZXBlYXQgYSkgc2IpXG5sZXQgc2luZ2xldG9uIHggPSByZXR1cm4geFxuXG5sZXQgZGVsYXllZF9mb2xkIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5maW5pc2ggfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICB8IE5vbmUgLT4gayBhY2NcbiAgICB8IFNvbWUgYSAtPiBmIGFjYyBhIH5rKVxuOztcblxubGV0IGZvbGRfbSB+YmluZCB+cmV0dXJuIHQgfmluaXQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXRcbiAgICB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuIGFjYykgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhY2MgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGl0ZXJfbSB+YmluZCB+cmV0dXJuIHQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXQ6KClcbiAgICB+ZjooZnVuICgpIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gKCkpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGZvbGRfdW50aWwgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6ICgnYSwgJ2IpIENvbnRpbnVlX29yX3N0b3AudCkgd2l0aFxuICAgICAgIHwgU3RvcCB4IC0+IHhcbiAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvbGRfcmVzdWx0IHMgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBSZXN1bHQucmV0dXJuIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6IChfLCBfKSBSZXN1bHQudCkgd2l0aFxuICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgICB8IE9rIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvcmNlX2VhZ2VybHkgdCA9IG9mX2xpc3QgKHRvX2xpc3QgdClcblxubGV0IG1lbW9pemUgKHR5cGUgYSkgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUIG9mIChhLCB0KSBTdGVwLnQgTGF6eS50XG4gIGVuZFxuICBpblxuICBsZXQgcmVjIG1lbW9pemUgcyA9IE0uVCAobGF6eSAoZmluZF9zdGVwIHMpKVxuICBhbmQgZmluZF9zdGVwIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPiBmaW5kX3N0ZXAgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBtZW1vaXplIHMpXG4gIGluXG4gIFNlcXVlbmNlIChtZW1vaXplIHMsIGZ1biAoTS5UIGwpIC0+IExhenkuZm9yY2UgbClcbjs7XG5cbmxldCBkcm9wX2VhZ2VybHkgcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaSB+bGVuIHMgbmV4dCA9XG4gICAgaWYgaSA+PSBsZW5cbiAgICB0aGVuIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBlbXB0eVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIH5sZW4gcyBuZXh0XG4gICAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIChpICsgMSkgfmxlbiBzIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIDAgfmxlbiBzIG5leHRcbjs7XG5cbmxldCBkcm9wX3doaWxlX29wdGlvbiAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZiA9XG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzXG4gICAgfCBZaWVsZCAoeCwgcykgLT4gaWYgZiB4IHRoZW4gbG9vcCBzIGVsc2UgU29tZSAoeCwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBsb29wIHNcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgKHppcF9mdWxsIHQxIHQyKSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgXyAtPiByLnJldHVybiAxXG4gICAgICB8IGBSaWdodCBfIC0+IHIucmV0dXJuICgtMSlcbiAgICAgIHwgYEJvdGggKHYxLCB2MikgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2EgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA8PiAwIHRoZW4gci5yZXR1cm4gYyk7XG4gICAgMClcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID1cbiAgZm9yX2FsbCAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgIHwgYEJvdGggKGExLCBhMikgLT4gZXF1YWxfYSBhMSBhMlxuICAgIHwgYExlZnQgXyB8IGBSaWdodCBfIC0+IGZhbHNlKVxuOztcblxubGV0IHJvdW5kX3JvYmluIGxpc3QgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaykgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIGYpIDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmIHMgd2l0aFxuICAgICAgIHwgWWllbGQgKHgsIHMpIC0+IFlpZWxkICh4LCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMsIGYpIDo6IGRvbmVfc3RhY2spKVxuICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSA6OiB0b2RvX3N0YWNrLCBkb25lX3N0YWNrKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSlcbiAgICB8IFtdIC0+IGlmIExpc3QuaXNfZW1wdHkgZG9uZV9zdGFjayB0aGVuIERvbmUgZWxzZSBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gbGlzdCwgW10gaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmUgKFNlcXVlbmNlIChzMSwgZjEpKSA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMyLCBmMikgOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYyIHMyIHdpdGhcbiAgICAgICB8IFlpZWxkICh4LCBzMikgLT4gWWllbGQgKHgsICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAoczIsIGYyKSA6OiBkb25lX3N0YWNrLCBzMSkpXG4gICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzMiwgZjIpIDo6IGRvbmVfc3RhY2ssIHMxKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkpXG4gICAgfCBbXSAtPlxuICAgICAgKG1hdGNoIGYxIHMxLCBkb25lX3N0YWNrIHdpdGhcbiAgICAgICB8IFlpZWxkICh0LCBzMSksIF8gLT4gU2tpcCAoTGlzdC5yZXYgKHQgOjogZG9uZV9zdGFjayksIFtdLCBzMSlcbiAgICAgICB8IFNraXAgczEsIF8gLT4gU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxKVxuICAgICAgIHwgRG9uZSwgXyA6OiBfIC0+IFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSlcbiAgICAgICB8IERvbmUsIFtdIC0+IERvbmUpXG4gIGluXG4gIGxldCBzdGF0ZSA9IFtdLCBbXSwgczEgaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0IHMxIHMyID1cbiAgbWFwIHMxIH5mOihmdW4geDEgLT4gbWFwIHMyIH5mOihmdW4geDIgLT4geDEsIHgyKSkgfD4gaW50ZXJsZWF2ZVxuOztcblxubGV0IG9mX3NlcSAoc2VxIDogXyBDYW1sLlNlcS50KSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnNlcSB+ZjooZnVuIHNlcSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gRG9uZVxuICAgIHwgQ29ucyAoaGQsIHRsKSAtPiBZaWVsZCAoaGQsIHRsKSlcbjs7XG5cbmxldCB0b19zZXEgKFNlcXVlbmNlIChzdGF0ZSwgbmV4dCkpID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICB8IERvbmUgLT4gQ2FtbC5TZXEuTmlsXG4gICAgfCBTa2lwIHN0YXRlIC0+IGxvb3Agc3RhdGVcbiAgICB8IFlpZWxkIChoZCwgc3RhdGUpIC0+IENhbWwuU2VxLkNvbnMgKGhkLCBmdW4gKCkgLT4gbG9vcCBzdGF0ZSlcbiAgaW5cbiAgZnVuICgpIC0+IGxvb3Agc3RhdGVcbjs7XG5cbm1vZHVsZSBHZW5lcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAnZWx0IHN0ZXBzID0gV3JhcCBvZiAoJ2VsdCwgdW5pdCAtPiAnZWx0IHN0ZXBzKSBTdGVwLnRcblxuICBsZXQgdW53cmFwIChXcmFwIHN0ZXApID0gc3RlcFxuXG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlbHQpIHQgPSAoJ2EgLT4gJ2VsdCBzdGVwcykgLT4gJ2VsdCBzdGVwc1xuXG4gICAgbGV0IHJldHVybiB4IGsgPSBrIHhcblxuICAgIGxldCBiaW5kIG0gfmYgayA9XG4gICAgICBtIChmdW4gYSAtPlxuICAgICAgICBsZXQgbScgPSBmIGEgaW5cbiAgICAgICAgbScgaylcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBtIH5mIGsgPSBtIChmdW4gYSAtPiBrIChmIGEpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoVClcblxuICBsZXQgeWllbGQgZSBrID0gV3JhcCAoWWllbGQgKGUsIGspKVxuICBsZXQgdG9fc3RlcHMgdCA9IHQgKGZ1biAoKSAtPiBXcmFwIERvbmUpXG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgICBkZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biAoKSB4IH5rIGYgLT4gV3JhcCAoWWllbGQgKHgsIGZ1biAoKSAtPiBrICgpIGYpKSlcbiAgICAgIH5maW5pc2g6cmV0dXJuXG4gIDs7XG5cbiAgbGV0IHJ1biB0ID1cbiAgICBsZXQgaW5pdCAoKSA9IHRvX3N0ZXBzIHQgaW5cbiAgICBsZXQgZiB0aHVuayA9IHVud3JhcCAodGh1bmsgKCkpIGluXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQgfmZcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG50eXBlICdhIHQgPSAnYSBhcnJheSBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9hcnJheVxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGFycmF5X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2FycmF5XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGFycmF5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGEgbmV3IGluLXBsYWNlLCBjb25zdGFudCBoZWFwIHNvcnRpbmcgYWxnb3JpdGhtIHRvIHJlcGxhY2UgdGhlXG4gICBvbmUgdXNlZCBieSB0aGUgc3RhbmRhcmQgbGlicmFyaWVzLiAgSXRzIG9ubHkgcHVycG9zZSBpcyB0byBiZSBmYXN0ZXIgKGhvcGVmdWxseVxuICAgc3RyaWN0bHkgZmFzdGVyKSB0aGFuIHRoZSBiYXNlIHNvcnQgYW5kIHN0YWJsZV9zb3J0LlxuXG4gICBBdCBhIGhpZ2ggbGV2ZWwgdGhlIGFsZ29yaXRobSBpczpcbiAgIC0gcGljayB0d28gcGl2b3QgcG9pbnRzIGJ5OlxuICAgLSBwaWNrIDUgYXJiaXRyYXJ5IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5XG4gICAtIHNvcnQgdGhlbSB3aXRoaW4gdGhlIGFycmF5XG4gICAtIHRha2UgdGhlIGVsZW1lbnRzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBtaWRkbGUgZWxlbWVudCBvZiB0aGUgc29ydCBhcyB0aGUgcGl2b3RzXG4gICAtIHNvcnQgdGhlIGFycmF5IHdpdGg6XG4gICAtIGFsbCBlbGVtZW50cyBsZXNzIHRoYW4gcGl2b3QxIHRvIHRoZSBsZWZ0IChyYW5nZSAxKVxuICAgLSBhbGwgZWxlbWVudHMgPj0gcGl2b3QxIGFuZCA8PSBwaXZvdDIgaW4gdGhlIG1pZGRsZSAocmFuZ2UgMilcbiAgIC0gYWxsIGVsZW1lbnRzID4gcGl2b3QyIHRvIHRoZSByaWdodCAocmFuZ2UgMylcbiAgIC0gaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIGVxdWFsLCB0aGVuIHRoZSBtaWRkbGUgcmFuZ2UgaXMgc29ydGVkLCBzbyBpZ25vcmUgaXRcbiAgIC0gcmVjdXJzZSBpbnRvIHJhbmdlIDEsIDIgKGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSB1bmVxdWFsKSwgYW5kIDNcbiAgIC0gZHVyaW5nIHJlY3Vyc2lvbiB0aGVyZSBhcmUgdHdvIGluZmxlY3Rpb24gcG9pbnRzOlxuICAgLSBpZiB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCByYW5nZSBpcyBzbWFsbCwgdXNlIGluc2VydGlvbiBzb3J0IHRvIHNvcnQgaXRcbiAgIC0gaWYgdGhlIHN0YWNrIGRlcHRoIGlzIGxhcmdlLCBzb3J0IHRoZSByYW5nZSB3aXRoIGhlYXAtc29ydCB0byBhdm9pZCBuXjIgd29yc3QtY2FzZVxuICAgICBiZWhhdmlvclxuXG4gICBTZWUgdGhlIGZvbGxvd2luZyBmb3IgbW9yZSBpbmZvcm1hdGlvbjpcbiAgIC0gXCJEdWFsLVBpdm90IFF1aWNrc29ydFwiIGJ5IFZsYWRpbWlyIFlhcm9zbGF2c2tpeS5cbiAgICAgQXZhaWxhYmxlIGF0XG4gICAgIGh0dHA6Ly93d3cua3JpY2hlLmNvbS5hci9yb290L3Byb2dyYW1taW5nL3NwYWNlVGltZUNvbXBsZXhpdHkvRHVhbFBpdm90UXVpY2tzb3J0LnBkZlxuICAgLSBcIlF1aWNrc29ydCBpcyBPcHRpbWFsXCIgYnkgU2VkZ2V3aWNrIGFuZCBCZW50bGV5LlxuICAgICBTbGlkZXMgYXQgaHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L35ycy90YWxrcy9RdWlja3NvcnRJc09wdGltYWwucGRmXG4gICAtIGh0dHA6Ly93d3cuc29ydGluZy1hbGdvcml0aG1zLmNvbS9xdWljay1zb3J0LTMtd2F5ICopXG5cbm1vZHVsZSBTb3J0ID0gc3RydWN0XG4gICgqIEZvciB0aGUgc2FrZSBvZiBzcGVlZCB3ZSBjb3VsZCB1c2UgdW5zYWZlIGdldC9zZXQgdGhyb3VnaG91dCwgYnV0IHNwZWVkIHRlc3RzIGRvbid0XG4gICAgIHNob3cgYSBzaWduaWZpY2FudCBpbXByb3ZlbWVudC4gKilcbiAgbGV0IGdldCA9IGdldFxuICBsZXQgc2V0ID0gc2V0XG5cbiAgbGV0IHN3YXAgYXJyIGkgaiA9XG4gICAgbGV0IHRtcCA9IGdldCBhcnIgaSBpblxuICAgIHNldCBhcnIgaSAoZ2V0IGFyciBqKTtcbiAgICBzZXQgYXJyIGogdG1wXG4gIDs7XG5cbiAgbW9kdWxlIHR5cGUgU29ydCA9IHNpZ1xuICAgIHZhbCBzb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBsZWZ0OmludCAoKiBsZWZ0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gcmlnaHQ6aW50ICgqIHJpZ2h0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gdW5pdFxuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luc2VydGlvbl9zb3J0ICopXG4gIG1vZHVsZSBJbnNlcnRpb25fc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgICAgW2Fycl0gaXMgc29ydGVkIGZyb20gW2xlZnRdIHRvIFtwb3MgLSAxXSwgaW5jbHVzaXZlICopXG4gICAgICBmb3IgcG9zID0gbGVmdCArIDEgdG8gcmlnaHQgZG9cbiAgICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uIGktMV0gaXMgc29ydGVkXG4gICAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLiBwb3NdIGlzIHNvcnRlZCBhbmQgY29udGFpbnMgb25seSBlbGVtZW50cyA+IHZcbiAgICAgICAgICAgMy4gIGFycltpXSBtYXkgYmUgdGhvdWdodCBvZiBhcyBjb250YWluaW5nIHZcblxuICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhbGxvY2F0ZSBhIGNsb3N1cmUsIGJ1dCBpcyBsZWZ0IGluIHRoZSBmb3JcbiAgICAgICAgICAgbG9vcCBmb3IgdGhlIHJlYWRhYmlsaXR5IG9mIHRoZSBkb2N1bWVudGF0aW9uLiAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGkgdiA9XG4gICAgICAgICAgbGV0IGlfbmV4dCA9IGkgLSAxIGluXG4gICAgICAgICAgaWYgaV9uZXh0ID49IGxlZnQgJiYgY29tcGFyZSAoZ2V0IGFyciBpX25leHQpIHYgPiAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBzZXQgYXJyIGkgKGdldCBhcnIgaV9uZXh0KTtcbiAgICAgICAgICAgIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGlfbmV4dCB2KVxuICAgICAgICAgIGVsc2UgaVxuICAgICAgICBpblxuICAgICAgICBsZXQgdiA9IGdldCBhcnIgcG9zIGluXG4gICAgICAgIGxldCBmaW5hbF9wb3MgPSBsb29wIGFyciB+bGVmdCB+Y29tcGFyZSBwb3MgdiBpblxuICAgICAgICBzZXQgYXJyIGZpbmFsX3BvcyB2XG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwc29ydCAqKVxuICBtb2R1bGUgSGVhcF9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgIHJvb3QncyBjaGlsZHJlbiBhcmUgYm90aCBlaXRoZXIgcm9vdHMgb2YgbWF4LWhlYXBzIG9yID4gcmlnaHQgKilcbiAgICBsZXQgcmVjIGhlYXBpZnkgYXJyIH5jb21wYXJlIHJvb3QgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCByZWxhdGl2ZV9yb290ID0gcm9vdCAtIGxlZnQgaW5cbiAgICAgIGxldCBsZWZ0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAxIGluXG4gICAgICBsZXQgcmlnaHRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDIgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgbGVmdF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIGxlZnRfY2hpbGQpIChnZXQgYXJyIHJvb3QpID4gMFxuICAgICAgICB0aGVuIGxlZnRfY2hpbGRcbiAgICAgICAgZWxzZSByb290XG4gICAgICBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiByaWdodF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIHJpZ2h0X2NoaWxkKSAoZ2V0IGFyciBsYXJnZXN0KSA+IDBcbiAgICAgICAgdGhlbiByaWdodF9jaGlsZFxuICAgICAgICBlbHNlIGxhcmdlc3RcbiAgICAgIGluXG4gICAgICBpZiBsYXJnZXN0IDw+IHJvb3RcbiAgICAgIHRoZW4gKFxuICAgICAgICBzd2FwIGFyciByb290IGxhcmdlc3Q7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxhcmdlc3QgfmxlZnQgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIEVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgYXJyYXkgYXJlIGFscmVhZHkgaGVhcHMgb2Ygc2l6ZSAxLiAgV2UgbW92ZVxuICAgICAgICAgdGhyb3VnaCB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgYXJyYXkgZnJvbSBiYWNrIHRvIGZyb250IGV4YW1pbmluZyB0aGUgZWxlbWVudCBhdFxuICAgICAgICAgaGFuZCwgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZHJlbiwgZml4aW5nIHRoZSBoZWFwIHByb3BlcnR5IGFzIHdlIGdvLiAqKVxuICAgICAgZm9yIGkgPSAobGVmdCArIHJpZ2h0KSAvIDIgZG93bnRvIGxlZnQgZG9cbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgaSB+bGVmdCB+cmlnaHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ7XG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uLiBpXSBpcyBhIG1heC1oZWFwIEhcbiAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLi4gcmlnaHRdIGlzIHNvcnRlZCAoY2FsbCBpdCBTKVxuICAgICAgICAgMy4gIGV2ZXJ5IGVsZW1lbnQgb2YgSCBpcyBsZXNzIHRoYW4gZXZlcnkgZWxlbWVudCBvZiBTICopXG4gICAgICBmb3IgaSA9IHJpZ2h0IGRvd250byBsZWZ0ICsgMSBkb1xuICAgICAgICBzd2FwIGFyciBsZWZ0IGk7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxlZnQgfmxlZnQgfnJpZ2h0OihpIC0gMSlcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludHJvc29ydCAqKVxuICBtb2R1bGUgSW50cm9fc29ydCA6IHNpZ1xuICAgIGluY2x1ZGUgU29ydFxuXG4gICAgdmFsIGZpdmVfZWxlbWVudF9zb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01ID1cbiAgICAgIGxldCBjb21wYXJlX2FuZF9zd2FwIGkgaiA9XG4gICAgICAgIGlmIGNvbXBhcmUgKGdldCBhcnIgaSkgKGdldCBhcnIgaikgPiAwIHRoZW4gc3dhcCBhcnIgaSBqXG4gICAgICBpblxuICAgICAgKCogT3B0aW1hbCA1LWVsZW1lbnQgc29ydGluZyBuZXR3b3JrOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgMS0tby0tLS0tby0tLS0tby0tLS0tLS0tLS0tLS0tMVxuICAgICAgICAgICAgICAgfCAgICAgfCAgICAgfFxuICAgICAgICAgICAgMi0tby0tLS0tfC0tby0tfC0tLS0tby0tby0tLS0tMlxuICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfCAgICAgfCAgfFxuICAgICAgICAgICAgMy0tLS0tLS0tby0tby0tfC0tby0tfC0tby0tLS0tM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfFxuICAgICAgICAgICAgNC0tLS0tby0tLS0tLS0tby0tby0tfC0tLS0tby0tNFxuICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfFxuICAgICAgICAgICAgNS0tLS0tby0tLS0tLS0tLS0tLS0tby0tLS0tby0tNVxuICAgICAgICAgIHZ9ICopXG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0yO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTMgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTVcbiAgICA7O1xuXG4gICAgKCogY2hvb3NlIHBpdm90cyBmb3IgdGhlIGFycmF5IGJ5IHNvcnRpbmcgNSBlbGVtZW50cyBhbmQgZXhhbWluaW5nIHRoZSBjZW50ZXIgdGhyZWVcbiAgICAgICBlbGVtZW50cy4gIFRoZSBnb2FsIGlzIHRvIGNob29zZSB0d28gcGl2b3RzIHRoYXQgd2lsbCBlaXRoZXI6XG4gICAgICAgLSBicmVhayB0aGUgcmFuZ2UgdXAgaW50byAzIGV2ZW4gcGFydGl0aW9uc1xuICAgICAgICAgb3JcbiAgICAgICAtIGVsaW1pbmF0ZSBhIGNvbW1vbmx5IGFwcGVhcmluZyBlbGVtZW50IGJ5IHNvcnRpbmcgaXQgaW50byB0aGUgY2VudGVyIHBhcnRpdGlvblxuICAgICAgICAgYnkgaXRzZWxmXG4gICAgICAgICBUbyB0aGlzIGVuZCB3ZSBsb29rIGF0IHRoZSBjZW50ZXIgMyBlbGVtZW50cyBvZiB0aGUgNSBhbmQgcmV0dXJuIHBhaXJzIG9mIGVxdWFsXG4gICAgICAgICBlbGVtZW50cyBvciB0aGUgd2lkZXN0IHJhbmdlICopXG4gICAgbGV0IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgc2l4dGggPSAocmlnaHQgLSBsZWZ0KSAvIDYgaW5cbiAgICAgIGxldCBtMSA9IGxlZnQgKyBzaXh0aCBpblxuICAgICAgbGV0IG0yID0gbTEgKyBzaXh0aCBpblxuICAgICAgbGV0IG0zID0gbTIgKyBzaXh0aCBpblxuICAgICAgbGV0IG00ID0gbTMgKyBzaXh0aCBpblxuICAgICAgbGV0IG01ID0gbTQgKyBzaXh0aCBpblxuICAgICAgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01O1xuICAgICAgbGV0IG0yX3ZhbCA9IGdldCBhcnIgbTIgaW5cbiAgICAgIGxldCBtM192YWwgPSBnZXQgYXJyIG0zIGluXG4gICAgICBsZXQgbTRfdmFsID0gZ2V0IGFyciBtNCBpblxuICAgICAgaWYgY29tcGFyZSBtMl92YWwgbTNfdmFsID0gMFxuICAgICAgdGhlbiBtMl92YWwsIG0zX3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBpZiBjb21wYXJlIG0zX3ZhbCBtNF92YWwgPSAwXG4gICAgICB0aGVuIG0zX3ZhbCwgbTRfdmFsLCB0cnVlXG4gICAgICBlbHNlIG0yX3ZhbCwgbTRfdmFsLCBmYWxzZVxuICAgIDs7XG5cbiAgICBsZXQgZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcGl2b3QxLCBwaXZvdDIsIHBpdm90c19lcXVhbCA9IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIGxlZnQgPD0gbCA8IHIgPD0gcmlnaHRcbiAgICAgICAgIDIuICBsIDw9IHAgPD0gclxuICAgICAgICAgMy4gIGwgPD0geCA8IHAgICAgIGltcGxpZXMgYXJyW3hdID49IHBpdm90MVxuICAgICAgICAgYW5kIGFyclt4XSA8PSBwaXZvdDJcbiAgICAgICAgIDQuICBsZWZ0IDw9IHggPCBsICBpbXBsaWVzIGFyclt4XSA8IHBpdm90MVxuICAgICAgICAgNS4gIHIgPCB4IDw9IHJpZ2h0IGltcGxpZXMgYXJyW3hdID4gcGl2b3QyICopXG4gICAgICBsZXQgcmVjIGxvb3AgbCBwIHIgPVxuICAgICAgICBsZXQgcHYgPSBnZXQgYXJyIHAgaW5cbiAgICAgICAgaWYgY29tcGFyZSBwdiBwaXZvdDEgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN3YXAgYXJyIHAgbDtcbiAgICAgICAgICBjb250IChsICsgMSkgKHAgKyAxKSByKVxuICAgICAgICBlbHNlIGlmIGNvbXBhcmUgcHYgcGl2b3QyID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBsb29wIGludmFyaWFudHM6ICBzYW1lIGFzIHRob3NlIG9mIHRoZSBvdXRlciBsb29wICopXG4gICAgICAgICAgbGV0IHJlYyBzY2FuX2JhY2t3YXJkcyByID1cbiAgICAgICAgICAgIGlmIHIgPiBwICYmIGNvbXBhcmUgKGdldCBhcnIgcikgcGl2b3QyID4gMCB0aGVuIHNjYW5fYmFja3dhcmRzIChyIC0gMSkgZWxzZSByXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgciA9IHNjYW5fYmFja3dhcmRzIHIgaW5cbiAgICAgICAgICBzd2FwIGFyciByIHA7XG4gICAgICAgICAgY29udCBsIHAgKHIgLSAxKSlcbiAgICAgICAgZWxzZSBjb250IGwgKHAgKyAxKSByXG4gICAgICBhbmQgY29udCBsIHAgciA9IGlmIHAgPiByIHRoZW4gbCwgciBlbHNlIGxvb3AgbCBwIHIgaW5cbiAgICAgIGxldCBsLCByID0gY29udCBsZWZ0IGxlZnQgcmlnaHQgaW5cbiAgICAgIGwsIHIsIHBpdm90c19lcXVhbFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBsZW4gPSByaWdodCAtIGxlZnQgKyAxIGluXG4gICAgICAoKiBUaGlzIHRha2VzIGNhcmUgb2Ygc29tZSBlZGdlIGNhc2VzLCBzdWNoIGFzIGxlZnQgPiByaWdodCBvciB2ZXJ5IHNob3J0IGFycmF5cyxcbiAgICAgICAgIHNpbmNlIEluc2VydGlvbl9zb3J0LnNvcnQgaGFuZGxlcyB0aGVzZSBjYXNlcyBwcm9wZXJseS4gIFRodXMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgbWFrZSBzdXJlIHRoYXQgbGVmdCBhbmQgcmlnaHQgYXJlIHZhbGlkIGluIHJlY3Vyc2l2ZSBjYWxscy4gKilcbiAgICAgIGlmIGxlbiA8PSAzMlxuICAgICAgdGhlbiBJbnNlcnRpb25fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgaWYgbWF4X2RlcHRoIDwgMFxuICAgICAgdGhlbiBIZWFwX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG1heF9kZXB0aCA9IG1heF9kZXB0aCAtIDEgaW5cbiAgICAgICAgbGV0IGwsIHIsIG1pZGRsZV9zb3J0ZWQgPSBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0OihsIC0gMSk7XG4gICAgICAgIGlmIG5vdCBtaWRkbGVfc29ydGVkIHRoZW4gaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDpsIH5yaWdodDpyO1xuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OihyICsgMSkgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBoZWFwX3NvcnRfc3dpdGNoX2RlcHRoID1cbiAgICAgICAgKCogV2UgYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0IGEgcmVjdXJzaW9uIGRlcHRoIG9mIDMyLiBHTlUgaW50cm9zb3J0IHVzZXMgMmxnKG4pLlxuICAgICAgICAgICBUaGUgZXhwZWN0ZWQgcmVjdXJzaW9uIGRlcHRoIGZvciBwZXJmZWN0IDMtd2F5IHNwbGl0cyBpcyBsb2dfMyhuKS5cblxuICAgICAgICAgICBVc2luZyAzMiBtZWFucyBhIGJhbGFuY2VkIDMtd2F5IHNwbGl0IHdvdWxkIHdvcmsgdXAgdG8gM14zMiBlbGVtZW50cyAocm91Z2hseVxuICAgICAgICAgICAyXjUwIG9yIDEwXjE1KS4gR05VIHJlYWNoZXMgYSBkZXB0aCBvZiAzMiBhdCA2NTUzNiBlbGVtZW50cy5cblxuICAgICAgICAgICBGb3Igc21hbGwgYXJyYXlzLCB0aGlzIG1ha2VzIHVzIGxlc3MgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCwgYnV0IHRoZVxuICAgICAgICAgICAzMipOIGNvc3QgYmVmb3JlIHdlIGRvIGlzIG5vdCB0aGF0IG11Y2guXG5cbiAgICAgICAgICAgRm9yIGxhcmdlIGFycmF5cywgdGhpcyBtZWFucyB3ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0XG4gICAgICAgICAgIHNvbWUgcG9pbnQgaWYgd2UgZ2V0IHNvbWUgYmFkIHNwbGl0cyBvciBpZiB0aGUgYXJyYXkgaXMgaHVnZS4gQnV0IHRoYXQncyBvbmx5IGFcbiAgICAgICAgICAgY29uc3RhbnQgZmFjdG9yIGNvc3QgaW4gdGhlIGZpbmFsIHN0YWdlcyBvZiByZWN1cnNpb24uXG5cbiAgICAgICAgICAgQWxsIGluIGFsbCwgdGhpcyBzZWVtcyB0byBiZSBhIHNtYWxsIHRyYWRlb2ZmIGFuZCBhdm9pZHMgcGF5aW5nIGEgY29zdCB0b1xuICAgICAgICAgICBjb21wdXRlIGEgbG9nYXJpdGhtIGF0IHRoZSBzdGFydC4gKilcbiAgICAgICAgMzJcbiAgICAgIGluXG4gICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoOmhlYXBfc29ydF9zd2l0Y2hfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHNvcnQgP3BvcyA/bGVuIGFyciB+Y29tcGFyZSA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBhcnIpXG4gIGluXG4gIFNvcnQuSW50cm9fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdDpwb3MgfnJpZ2h0Oihwb3MgKyBsZW4gLSAxKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSB0XG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgaXNfc29ydGVkIHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID49IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZXJnZSBhMSBhMiB+Y29tcGFyZSA9XG4gIGxldCBsMSA9IEFycmF5Lmxlbmd0aCBhMSBpblxuICBsZXQgbDIgPSBBcnJheS5sZW5ndGggYTIgaW5cbiAgaWYgbDEgPSAwXG4gIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGwyID0gMFxuICB0aGVuIGNvcHkgYTFcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEyIDApICh1bnNhZmVfZ2V0IGExIChsMSAtIDEpKSA+PSAwXG4gIHRoZW4gYXBwZW5kIGExIGEyXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMSAwKSAodW5zYWZlX2dldCBhMiAobDIgLSAxKSkgPiAwXG4gIHRoZW4gYXBwZW5kIGEyIGExXG4gIGVsc2UgKFxuICAgIGxldCBsZW4gPSBsMSArIGwyIGluXG4gICAgbGV0IG1lcmdlZCA9IGNyZWF0ZSB+bGVuICh1bnNhZmVfZ2V0IGExIDApIGluXG4gICAgbGV0IGExX2luZGV4ID0gcmVmIDAgaW5cbiAgICBsZXQgYTJfaW5kZXggPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgdXNlX2ExID1cbiAgICAgICAgaWYgbDEgPSAhYTFfaW5kZXhcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGlmIGwyID0gIWEyX2luZGV4XG4gICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICBlbHNlIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpIDw9IDBcbiAgICAgIGluXG4gICAgICBpZiB1c2VfYTFcbiAgICAgIHRoZW4gKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCk7XG4gICAgICAgIGExX2luZGV4IDo9ICFhMV9pbmRleCArIDEpXG4gICAgICBlbHNlIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpO1xuICAgICAgICBhMl9pbmRleCA6PSAhYTJfaW5kZXggKyAxKVxuICAgIGRvbmU7XG4gICAgbWVyZ2VkKVxuOztcblxubGV0IGNvcHlfbWF0cml4ID0gbWFwIH5mOmNvcHlcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudClcbjs7XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcCB+ZiB0KSlcbmxldCBjb25jYXRfbWFwaSB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXBpIH5mIHQpKVxuXG5sZXQgcmV2X2lucGxhY2UgdCA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgd2hpbGUgIWkgPCAhaiBkb1xuICAgIHN3YXAgdCAhaSAhajtcbiAgICBpbmNyIGk7XG4gICAgZGVjciBqXG4gIGRvbmVcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCB0ID0gY29weSB0IGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3JldiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGEgOjogbCAtPlxuICAgIGxldCBsZW4gPSAxICsgTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW4gYSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICAoKiBXZSBzdGFydCBhdCBbbGVuIC0gMl0gYmVjYXVzZSB3ZSBhbHJlYWR5IHB1dCBbYV0gYXQgW3QuKGxlbiAtIDEpXS4gKilcbiAgICBmb3IgaSA9IGxlbiAtIDIgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICB0LihpKSA8LSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHRcbjs7XG5cbigqIFtvZl9saXN0X21hcF0gYW5kIFtvZl9saXN0X3Jldl9tYXBdIGFyZSBiYXNlZCBvbiBmdW5jdGlvbnMgZnJvbSB0aGUgT0NhbWxcbiAgIGRpc3RyaWJ1dGlvbi4gKilcblxubGV0IG9mX2xpc3RfbWFwIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGhkKTtcbiAgICAgICAgZmlsbCAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X21hcGkgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiAwIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBhIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGkgaGQpO1xuICAgICAgICBmaWxsIGEgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCBhIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXAgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXBpIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcGkgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBbfHxdIGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgW3x8XVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfb3B0IHQgPSBmaWx0ZXJfbWFwIHQgfmY6Rm4uaWRcblxubGV0IHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yID1cbiAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSB0MSB0MiA9XG4gIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMlxuOztcblxubGV0IGl0ZXIyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuaXRlcjJfZXhuXCIgdDEgdDI7XG4gIGl0ZXJpIHQxIH5mOihmdW4gaSB4MSAtPiBmIHgxICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5tYXAyX2V4blwiIHQxIHQyO1xuICBpbml0IChsZW5ndGggdDEpIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9sZDJfZXhuXCIgdDEgdDI7XG4gIGZvbGRpIHQxIH5pbml0IH5mOihmdW4gaSBhYyB4IC0+IGYgYWMgeCAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbmxldCBmaWx0ZXJpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcblxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSlcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIChsZW5ndGggLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICFpICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmV4aXN0czJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb3JfYWxsMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGVxdWFsIGVxdWFsIHQxIHQyID0gbGVuZ3RoIHQxID0gbGVuZ3RoIHQyICYmIGZvcl9hbGwyX2V4biB0MSB0MiB+ZjplcXVhbFxuXG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZmluZGlfaW50ZXJuYWwgdCB+ZiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gaWZfbm90X2ZvdW5kICgpXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlIChub3QgIWZvdW5kKSAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBmICFpIHZhbHVlXG4gICAgICB0aGVuIChcbiAgICAgICAgdmFsdWVfZm91bmQgOj0gdmFsdWU7XG4gICAgICAgIGZvdW5kIDo9IHRydWUpXG4gICAgICBlbHNlIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgIWZvdW5kIHRoZW4gaWZfZm91bmQgfmk6IWkgfnZhbHVlOiF2YWx1ZV9mb3VuZCBlbHNlIGlmX25vdF9mb3VuZCAoKSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gU29tZSAoaSwgdmFsdWUpKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKVxuOztcblxubGV0IGZpbmRpX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gaSwgdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmY6KGZ1biBfaSB4IC0+IGYgeClcbiAgICB+aWZfZm91bmQ6KGZ1biB+aTpfIH52YWx1ZSAtPiB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9leG46IG5vdCBmb3VuZFwiKSkpXG47O1xuXG5sZXQgZmluZCB0IH5mID0gT3B0aW9uLm1hcCAoZmluZGkgdCB+ZjooZnVuIF9pIHggLT4gZiB4KSkgfmY6KGZ1biAoX2ksIHgpIC0+IHgpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmICFpIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPD0gMVxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGkgPSByZWYgMSBpblxuICAgIGxldCBwcmV2ID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjdXIgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGVxdWFsIGN1ciAhcHJldlxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlc3VsdCA6PSBTb21lICghcHJldiwgY3VyKTtcbiAgICAgICAgaSA6PSBuKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHByZXYgOj0gY3VyO1xuICAgICAgICBpbmNyIGkpXG4gICAgZG9uZTtcbiAgICAhcmVzdWx0KVxuOztcblxubGV0IHJlZHVjZSB0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgciA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgICBkb25lO1xuICAgIFNvbWUgIXIpXG47O1xuXG5sZXQgcmVkdWNlX2V4biB0IH5mID1cbiAgbWF0Y2ggcmVkdWNlIHQgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHBlcm11dGUgPSBBcnJheV9wZXJtdXRlLnBlcm11dGVcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBhcnJheVwiXG4gIGVsc2UgdC4oUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCB0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB6aXAgdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyIHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKSlcbjs7XG5cbmxldCB6aXBfZXhuIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MlxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkuemlwX2V4blwiXG4gIGVsc2UgbWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpXG47O1xuXG5sZXQgdW56aXAgdCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB4LCB5ID0gdC4oMCkgaW5cbiAgICBsZXQgcmVzMSA9IGNyZWF0ZSB+bGVuOm4geCBpblxuICAgIGxldCByZXMyID0gY3JlYXRlIH5sZW46biB5IGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgeCwgeSA9IHQuKGkpIGluXG4gICAgICByZXMxLihpKSA8LSB4O1xuICAgICAgcmVzMi4oaSkgPC0geVxuICAgIGRvbmU7XG4gICAgcmVzMSwgcmVzMilcbjs7XG5cbmxldCBzb3J0ZWRfY29weSB0IH5jb21wYXJlID1cbiAgbGV0IHQxID0gY29weSB0IGluXG4gIHNvcnQgdDEgfmNvbXBhcmU7XG4gIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgbGV0IGJvdGggPSBtYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBFaXRoZXIuRmlyc3QgeCBlbHNlIEVpdGhlci5TZWNvbmQgeCkgaW5cbiAgbGV0IHRydWVzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IHggLT4gU29tZSB4XG4gICAgICB8IFNlY29uZCBfIC0+IE5vbmUpXG4gIGluXG4gIGxldCBmYWxzZXMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgXyAtPiBOb25lXG4gICAgICB8IFNlY29uZCB4IC0+IFNvbWUgeClcbiAgaW5cbiAgdHJ1ZXMsIGZhbHNlc1xuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gX2kgeCAtPiBmIHgpXG5sZXQgbGFzdCB0ID0gdC4obGVuZ3RoIHQgLSAxKVxuXG4oKiBDb252ZXJ0IHRvIGEgc2VxdWVuY2UgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gcHJvdGVjdCBhZ2FpbnN0IG1vZGlmaWNhdGlvblxuICAgaW4gdGhlIGFycmF5LiAqKVxubGV0IHRvX3NlcXVlbmNlX211dGFibGUgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBsZW5ndGggdCB0aGVuIFNlcXVlbmNlLlN0ZXAuRG9uZSBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKHQuKGkpLCBpICsgMSkpXG47O1xuXG5sZXQgdG9fc2VxdWVuY2UgdCA9IHRvX3NlcXVlbmNlX211dGFibGUgKGNvcHkgdClcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHQxIHQyID1cbiAgaWYgaXNfZW1wdHkgdDEgfHwgaXNfZW1wdHkgdDJcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICAgIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW46KG4xICogbjIpICh0MS4oMCksIHQyLigwKSkgaW5cbiAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgZm9yIGkxID0gMCB0byBuMSAtIDEgZG9cbiAgICAgIGZvciBpMiA9IDAgdG8gbjIgLSAxIGRvXG4gICAgICAgIHQuKCFyKSA8LSB0MS4oaTEpLCB0Mi4oaTIpO1xuICAgICAgICBpbmNyIHJcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgdHJhbnNwb3NlIHR0ID1cbiAgaWYgbGVuZ3RoIHR0ID0gMFxuICB0aGVuIFNvbWUgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgd2lkdGggPSBsZW5ndGggdHQgaW5cbiAgICBsZXQgZGVwdGggPSBsZW5ndGggdHQuKDApIGluXG4gICAgaWYgZXhpc3RzIHR0IH5mOihmdW4gdCAtPiBsZW5ndGggdCA8PiBkZXB0aClcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKGluaXQgZGVwdGggfmY6KGZ1biBkIC0+IGluaXQgd2lkdGggfmY6KGZ1biB3IC0+IHR0Lih3KS4oZCkpKSkpXG47O1xuXG5sZXQgdHJhbnNwb3NlX2V4biB0dCA9XG4gIG1hdGNoIHRyYW5zcG9zZSB0dCB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnRyYW5zcG9zZV9leG5cIlxuICB8IFNvbWUgdHQnIC0+IHR0J1xuOztcblxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBnZXQgPSBnZXRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIFt8fF1cbiAgICAgIGVsc2UgKFxuICAgICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICAgIGNyZWF0ZSB+bGVuIHQuKDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGl0ZXIgdCB+ZjppbnZhcmlhbnRfYVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgU29ydCA9IFNvcnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBtYWludGFpbiB0aGUgcHJvcGVydHkgdGhhdCBhbGwgdmFsdWVzIG9mIHR5cGUgW3RdIGRvIG5vdCBoYXZlIHRoZSB0YWdcbiAgIFtkb3VibGVfYXJyYXlfdGFnXS4gIFNvbWUgZnVuY3Rpb25zIGJlbG93IGFzc3VtZSB0aGlzIGluIG9yZGVyIHRvIGF2b2lkIHRlc3RpbmcgdGhlXG4gICB0YWcsIGFuZCB3aWxsIHNlZ2ZhdWx0IGlmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBob2xkLiAqKVxudHlwZSB0ID0gQ2FtbC5PYmoudCBhcnJheVxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKENhbWwuT2JqLnRhZyAoQ2FtbC5PYmoucmVwciB0KSA8PiBDYW1sLk9iai5kb3VibGVfYXJyYXlfdGFnKVxubGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCAoKiB3b3VsZCBjaGVjayBmb3IgZmxvYXQgYXJyYXlzIGluIDMyIGJpdCwgYnV0IHdoYXRldmVyICopXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIFNleHAuQXRvbVxuICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBbIFwiPE9ial9hcnJheS50IG9mIGxlbmd0aCBcIjsgSW50LnRvX3N0cmluZyAobGVuZ3RoIHQpOyBcIj5cIiBdKVxuOztcblxubGV0IHplcm9fb2JqID0gQ2FtbC5PYmoucmVwciAoMCA6IGludClcblxuKCogV2UgY2FsbCBbQXJyYXkuY3JlYXRlXSB3aXRoIGEgdmFsdWUgdGhhdCBpcyBub3QgYSBmbG9hdCBzbyB0aGF0IHRoZSBhcnJheSBkb2Vzbid0IGdldFxuICAgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxubGV0IGNyZWF0ZV96ZXJvIH5sZW4gPSBBcnJheS5jcmVhdGUgfmxlbiB6ZXJvX29ialxubGV0IGVtcHR5ID0gW3x8XVxuXG50eXBlIG5vdF9hX2Zsb2F0ID1cbiAgfCBOb3RfYV9mbG9hdF8wXG4gIHwgTm90X2FfZmxvYXRfMSBvZiBpbnRcblxubGV0IF9ub3RfYV9mbG9hdF8wID0gTm90X2FfZmxvYXRfMFxubGV0IF9ub3RfYV9mbG9hdF8xID0gTm90X2FfZmxvYXRfMSA0MlxuXG5sZXQgZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAgSXQgaXMgTk9UIG9rIHRvIHVzZSBbaW50IGFycmF5XSBzaW5jZSAoaWZcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBpbmxpbmVkIGFuZCB0aGUgYXJyYXkgY29udGFpbnMgaW4taGVhcCBib3hlZCB2YWx1ZXMpIHdyb25nIHJlZ2lzdGVyXG4gICAgIHR5cGluZyBtYXkgcmVzdWx0LCBsZWFkaW5nIHRvIGEgZmFpbHVyZSB0byByZWdpc3RlciBuZWNlc3NhcnkgR0Mgcm9vdHMuICopXG4gIENhbWwuT2JqLnJlcHIgKChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxuICBDYW1sLk9iai5yZXByXG4gICAgKEFycmF5LnVuc2FmZV9nZXQgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkgaSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIFNhbWUgY29tbWVudCBhcyBbdW5zYWZlX2dldF0uIFN5cy5vcGFxdWVfaWRlbnRpdHkgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb21cbiAgICAgcG90ZW50aWFsbHkgd3JvbmdseSBndWVzc2luZyB0aGUgdHlwZSBvZiB0aGUgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgZWxlbWVudCwgdGhhdFxuICAgICBpcyBwcmV2ZW50IHRoZSBpbXBsaWNhdGlvbjogKE9iai50YWcgb2JqID0gT2JqLmRvdWJsZV90YWcpID0+IChPYmoudGFnIHQgPVxuICAgICBPYmouZG91YmxlX2FycmF5X3RhZykgd2hpY2ggZmxhbWJkYSBoYXMgdHJpZWQgaW4gdGhlIHBhc3QgKGF0IGxlYXN0IHRoYXQncyBhc3N1bWluZ1xuICAgICB0aGUgY29tcGlsZXIgcmVzcGVjdHMgU3lzLm9wYXF1ZV9pZGVudGl0eSwgd2hpY2ggaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KVxuICAgIGlcbiAgICAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIHNhbWUgYXMgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IGJ1dCBzYWZlICopXG4gIChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKVxuICA8LSAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50ID1cbiAgKCogVGhpcyBza2lwcyBbY2FtbF9tb2RpZnldLCB3aGljaCBpcyBPSyBpZiBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlIGludGVnZXJzLiAqKVxuICBBcnJheS51bnNhZmVfc2V0IChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogaW50IGFycmF5KSBpIChTeXMub3BhcXVlX2lkZW50aXR5IGludClcbjs7XG5cbigqIEZvciBbc2V0XSBhbmQgW3Vuc2FmZV9zZXRdLCBpZiBhIHBvaW50ZXIgaXMgaW52b2x2ZWQsIHdlIGZpcnN0IGRvIGEgcGh5c2ljYWwtZXF1YWxpdHlcbiAgIHRlc3QgdG8gc2VlIGlmIHRoZSBwb2ludGVyIGlzIGNoYW5naW5nLiAgSWYgbm90LCB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBbc2V0XSwgd2hpY2hcbiAgIHNhdmVzIGEgY2FsbCB0byBbY2FtbF9tb2RpZnldLiAgV2UgdGhpbmsgdGhpcyBwaHlzaWNhbC1lcXVhbGl0eSB0ZXN0IGlzIHdvcnRoIGl0XG4gICBiZWNhdXNlIGl0IGlzIHZlcnkgY2hlYXAgKGJvdGggdmFsdWVzIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSBmcm9tIHRoZSBbaXNfaW50XSB0ZXN0KVxuICAgYW5kIGJlY2F1c2UgW2NhbWxfbW9kaWZ5XSBpcyBleHBlbnNpdmUuICopXG5cbmxldCBzZXQgdCBpIG9iaiA9XG4gICgqIFdlIHVzZSBbZ2V0XSBmaXJzdCBidXQgdGhlbiB3ZSB1c2UgW0FycmF5LnVuc2FmZV9zZXRdIHNpbmNlIHdlIGtub3cgdGhhdCBbaV0gaXNcbiAgICAgdmFsaWQuICopXG4gIGxldCBvbGRfb2JqID0gZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXQgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGEgPSBnZXQgdCBpIGluXG4gIGxldCBiID0gZ2V0IHQgaiBpblxuICB1bnNhZmVfc2V0IHQgaSBiO1xuICB1bnNhZmVfc2V0IHQgaiBhXG47O1xuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gICgqIElmIHdlIGNhbiwgdXNlIFtBcnJheS5jcmVhdGVdIGRpcmVjdGx5LiAqKVxuICBpZiBDYW1sLk9iai50YWcgeCA8PiBDYW1sLk9iai5kb3VibGVfdGFnXG4gIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4geFxuICBlbHNlIChcbiAgICAoKiBPdGhlcndpc2UgdXNlIFtjcmVhdGVfemVyb10gYW5kIHNldCB0aGUgY29udGVudHMgKilcbiAgICBsZXQgdCA9IGNyZWF0ZV96ZXJvIH5sZW4gaW5cbiAgICBsZXQgeCA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHhcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIG9iaiA9IGNyZWF0ZSB+bGVuOjEgb2JqXG5cbigqIFByZS1jb25kaXRpb246IHQuKGkpIGlzIGFuIGludGVnZXIuICopXG5sZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBvYmogPVxuICBpZiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2VcbiAgICAoKiBbdC4oaSldIGlzIGFuIGludGVnZXIgYW5kIFtvYmpdIGlzIG5vdCwgc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaWYgdGhleSBhcmVcbiAgICAgICBlcXVhbC4gKilcbiAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHVuc2FmZV9zZXRfaW50IHQgaSBpbnQgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50XG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciBpbnQpXG47O1xuXG5sZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgdCBpID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBub3QgKENhbWwuT2JqLmlzX2ludCBvbGRfb2JqKSB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgMClcbjs7XG5cbigqKiBbdW5zYWZlX2JsaXRdIGlzIGxpa2UgW0FycmF5LmJsaXRdLCBleGNlcHQgaXQgdXNlcyBvdXIgb3duIGZvci1sb29wIHRvIGF2b2lkXG4gICAgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZS4gIEl0cyBwZXJmb3JtYW5jZSBpcyBzdGlsbCBub3QgY29tcGFyYWJsZSB0byBhIG1lbWNweS4gKilcbmxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICgqIFdoZW4gW3BoeXNfZXF1YWwgc3JjIGRzdF0sIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBbZHN0X3BvcyA8IHNyY19wb3NdIGFuZCBoYXZlIHRoZVxuICAgICBmb3IgbG9vcCBnbyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGRhdGEgdGhhdCB3ZSBzdGlsbCBuZWVkXG4gICAgIHRvIHJlYWQuICBXaGVuIFtub3QgKHBoeXNfZXF1YWwgc3JjIGRzdCldLCBkb2luZyB0aGlzIGlzIGhhcm1sZXNzLiAgRnJvbSBhXG4gICAgIG1lbW9yeS1wZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSwgaXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciBvbmUgbG9vcHMgdXAgb3IgZG93bi5cbiAgICAgQ29uc3RhbnQtc3RyaWRlIGFjY2VzcywgZm9yd2FyZCBvciBiYWNrd2FyZCwgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIChhdCBsZWFzdCBvblxuICAgICBhbiBpbnRlbCBpNykuICBTbywgd2UgZG9uJ3QgZG8gYSBjaGVjayBmb3IgW3BoeXNfZXF1YWwgc3JjIGRzdF0gYW5kIGFsd2F5cyBsb29wIHVwIGluXG4gICAgIHRoYXQgY2FzZS4gKilcbiAgaWYgZHN0X3BvcyA8IHNyY19wb3NcbiAgdGhlblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbiAgZWxzZVxuICAgIGZvciBpID0gbGVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG47O1xuXG5pbmNsdWRlIEJsaXQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVfemVyb1xuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGVfemVybyB+bGVuOihsZW5ndGggc3JjKSBpblxuICBibGl0byB+c3JjIH5kc3QgKCk7XG4gIGRzdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBXQVJOSU5HOlxuICAgV2UgdXNlIG5vbi1tZW1vcnktc2FmZSB0aGluZ3MgdGhyb3VnaG91dCB0aGUgW1RydXN0ZWRdIG1vZHVsZS5cbiAgIE1vc3Qgb2YgaXQgaXMgb25seSBzYWZlIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHR5cGUgc2lnbmF0dXJlIChlLmcuIGV4cG9zaW5nXG4gICBbdmFsIGNvcHkgOiAnYSB0IC0+ICdiIHRdIHdvdWxkIGJlIGEgYmlnIG1pc3Rha2UpLiAqKVxubW9kdWxlIFRydXN0ZWQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGVfb2JqX2FycmF5IDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzd2FwIDogXyB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX2dldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCB1bnNhZmVfc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHNldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIEJsaXQuYmxpdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgOiBfIHQgLT4gaW50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBPYmpfYXJyYXkudFxuXG4gIGxldCBlbXB0eSA9IE9ial9hcnJheS5lbXB0eVxuICBsZXQgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlX29ial9hcnJheSB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZSB+bGVuIHggPSBPYmpfYXJyYXkuY3JlYXRlIH5sZW4gKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHNpbmdsZXRvbiB4ID0gT2JqX2FycmF5LnNpbmdsZXRvbiAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgc3dhcCB0IGkgaiA9IE9ial9hcnJheS5zd2FwIHQgaSBqXG4gIGxldCBnZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS5nZXQgYXJyIGkpXG4gIGxldCBzZXQgYXJyIGkgeCA9IE9ial9hcnJheS5zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9nZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS51bnNhZmVfZ2V0IGFyciBpKVxuICBsZXQgdW5zYWZlX3NldCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9zZXRfaW50IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnQgYXJyIGkgeFxuXG4gIGxldCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHhcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgbGVuZ3RoID0gT2JqX2FycmF5Lmxlbmd0aFxuICBsZXQgdW5zYWZlX2JsaXQgPSBPYmpfYXJyYXkudW5zYWZlX2JsaXRcbiAgbGV0IGNvcHkgPSBPYmpfYXJyYXkuY29weVxuXG4gIGxldCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID0gT2JqX2FycmF5LnNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgPSBPYmpfYXJyYXkudW5zYWZlX2NsZWFyX2lmX3BvaW50ZXJcbmVuZFxuXG5pbmNsdWRlIFRydXN0ZWRcblxubGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChDYW1sLk9iai50YWcgKENhbWwuT2JqLnJlcHIgdCkgPD4gQ2FtbC5PYmouZG91YmxlX2FycmF5X3RhZylcblxubGV0IGluaXQgbCB+ZiA9XG4gIGlmIGwgPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJVbmlmb3JtX2FycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46bCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG9mX2FycmF5IGFyciA9IGluaXQgfmY6KEFycmF5LnVuc2FmZV9nZXQgYXJyKSAoQXJyYXkubGVuZ3RoIGFycilcbmxldCBtYXAgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKVxubGV0IG1hcGkgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgaSAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpXG5cbmxldCBpdGVyIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBmb2xkaSBhIH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5pbml0IH5mOihnZXQgdCkgKGxlbmd0aCB0KVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgeCAtPiBzZXQgcmVzIGkgeCk7XG4gIHJlc1xuOztcblxuKCogSXQgaXMgbm90IHNhZmUgZm9yIFt0b19hcnJheV0gdG8gYmUgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBjb2RlIHRoYXRcbiAgIHJlbGllcyBvbiBbZmxvYXQgYXJyYXldcyBiZWluZyB1bmJveGVkLCBmb3IgZXhhbXBsZSBpbiBbYmluX3dyaXRlX2FycmF5XS4gKilcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBmYWxzZSBlbHNlIGYgKHVuc2FmZV9nZXQgdCBpKSB8fCBsb29wIHQgfmYgKGkgLSAxKVxuICBpblxuICBsb29wIHQgfmYgKGxlbmd0aCB0IC0gMSlcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiBpID0gaWYgaSA8IDAgdGhlbiB0cnVlIGVsc2UgZiAodW5zYWZlX2dldCB0IGkpICYmIGxvb3AgdCB+ZiAoaSAtIDEpIGluXG4gIGxvb3AgdCB+ZiAobGVuZ3RoIHQgLSAxKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0MSBpblxuICBpZiBsZW5ndGggdDIgPD4gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyX2V4blwiO1xuICBpbml0IGxlbiB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChncmFtbWFyIDogZWx0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGVsdCB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoQXJyYXkudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmluY2x1ZGVcbiAgU2V4cGFibGUuT2Zfc2V4cGFibGUxXG4gICAgKEFycmF5KVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX2FycmF5XG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9hcnJheVxuICAgIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIGVtcHR5XG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgICBjcmVhdGUgfmxlbiAoZ2V0IHQgMCkpXG4gICAgOztcblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHB4X2NvbXBhcmUgW2NvbXBhcmVfYXJyYXldIGJ1dCB1c2VzIG91ciBbdW5zYWZlX2dldF0gYW5kIFtsZW5ndGhdLiAqKVxubGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgYSBiID1cbiAgaWYgcGh5c19lcXVhbCBhIGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIGxldCBsZW5fYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gbGVuZ3RoIGIgaW5cbiAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgIGlmIHJldCA8PiAwXG4gICAgdGhlbiByZXRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgaWYgaSA9IGxlbl9hXG4gICAgICAgIHRoZW4gMFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbCA9IHVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgYW5kIHIgPSB1bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCBsIHIgaW5cbiAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIDApKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGNlaWwgPSBDYW1sLmNlaWxcbmxldCBmbG9vciA9IENhbWwuZmxvb3JcbmxldCBtb2RfZmxvYXQgPSBDYW1sLm1vZF9mbG9hdFxubGV0IG1vZGYgPSBDYW1sLm1vZGZcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBDYW1sLmZsb2F0X29mX3N0cmluZ1xubGV0IG5hbiA9IENhbWwubmFuXG5sZXQgaW5maW5pdHkgPSBDYW1sLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gQ2FtbC5uZWdfaW5maW5pdHlcbmxldCBtYXhfZmluaXRlX3ZhbHVlID0gQ2FtbC5tYXhfZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gQ2FtbC5lcHNpbG9uX2Zsb2F0XG5sZXQgY2xhc3NpZnlfZmxvYXQgPSBDYW1sLmNsYXNzaWZ5X2Zsb2F0XG5sZXQgYWJzX2Zsb2F0ID0gQ2FtbC5hYnNfZmxvYXRcbmxldCBpc19pbnRlZ2VyID0gQ2FtbC5GbG9hdC5pc19pbnRlZ2VyXG5sZXQgKCAqKiApID0gQ2FtbC4oICoqIClcblxubGV0ICggJS4gKSBhIGIgPVxuICAoKiBSYWlzZSBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgbW9kdWx1cywgYXMgZG9lcyBJbnQuKCAlICkuICopXG4gIGlmIGIgPCAwLlxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCIlZiAlJSAlZiBpbiBmbG9hdDAubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIgYSBiICgpO1xuICBsZXQgbSA9IENhbWwubW9kX2Zsb2F0IGEgYiBpblxuICAoKiBQcm9kdWNlIGEgbm9uLW5lZ2F0aXZlIHJlc3VsdCBpbiBhbmFsb2d5IHdpdGggSW50LiggJSApLiAqKVxuICBpZiBtIDwgMC4gdGhlbiBtICsuIGIgZWxzZSBtXG47O1xuXG4oKiBUaGUgYml0cyBvZiBJTlJJQSdzIFtQZXJ2YXNpdmVzXSB0aGF0IHdlIGp1c3Qgd2FudCB0byBleHBvc2UgaW4gW0Zsb2F0XS4gTW9zdCBhcmVcbiAgIGFscmVhZHkgZGVwcmVjYXRlZCBpbiBbUGVydmFzaXZlc10sIGFuZCBldmVudHVhbGx5IGFsbCBvZiB0aGVtIHNob3VsZCBiZS4gKilcbmluY2x1ZGUgKFxuICBDYW1sIDpcbiAgc2lnXG4gICAgZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5cbiAgICBleHRlcm5hbCBsZGV4cFxuICAgICAgOiAgKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICA9IFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgZW5kKVxuXG4oKiBXZSBuZWVkIHRoaXMgaW5kaXJlY3Rpb24gYmVjYXVzZSB0aGVzZSBhcmUgZXhwb3NlZCBhcyBcInZhbFwiIGluc3RlYWQgb2YgXCJleHRlcm5hbFwiICopXG5sZXQgZnJleHAgPSBmcmV4cFxubGV0IGxkZXhwID0gbGRleHBcbmxldCBpc19uYW4geCA9ICh4IDogZmxvYXQpIDw+IHhcblxuKCogQW4gb3JkZXItcHJlc2VydmluZyBiaWplY3Rpb24gYmV0d2VlbiBhbGwgZmxvYXRzIGV4Y2VwdCBmb3IgTmFOcywgYW5kIDk5Ljk1JSBvZlxuICAgaW50NjRzLlxuXG4gICBOb3RlIHdlIGRvbid0IGRpc3Rpbmd1aXNoIDAuIGFuZCAtMC4gYXMgc2VwYXJhdGUgdmFsdWVzIGhlcmUsIHRoZXkgYm90aCBtYXAgdG8gMEwsIHdoaWNoXG4gICBtYXBzIGJhY2sgdG8gMC5cblxuICAgVGhpcyBzaG91bGQgd29yayBib3RoIG9uIGxpdHRsZS1lbmRpYW4gYW5kIGhpZ2gtZW5kaWFuIENQVXMuICBXaWtpcGVkaWEgc2F5czogXCJvblxuICAgbW9kZXJuIHN0YW5kYXJkIGNvbXB1dGVycyAoaS5lLiwgaW1wbGVtZW50aW5nIElFRUUgNzU0KSwgb25lIG1heSBpbiBwcmFjdGljZSBzYWZlbHlcbiAgIGFzc3VtZSB0aGF0IHRoZSBlbmRpYW5uZXNzIGlzIHRoZSBzYW1lIGZvciBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFzIGZvciBpbnRlZ2Vyc1wiXG4gICAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbmRpYW5uZXNzI0Zsb2F0aW5nLXBvaW50X2FuZF9lbmRpYW5uZXNzKS5cbiopXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCA9XG4gIGlmIGlzX25hbiB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuICgqIGFsc28gaW5jbHVkZXMgLTAuICopXG4gICAgU29tZSAwTFxuICBlbHNlIGlmIHQgPiAwLlxuICB0aGVuIFNvbWUgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0KVxuICBlbHNlIFNvbWUgKENhbWwuSW50NjQubmVnIChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKC0udCkpKVxuOztcblxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biB4ID0gT3B0aW9uLnZhbHVlX2V4biAodG9faW50NjRfcHJlc2VydmVfb3JkZXIgeClcblxubGV0IG9mX2ludDY0X3ByZXNlcnZlX29yZGVyIHggPVxuICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIHggMExcbiAgdGhlbiBDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgeFxuICBlbHNlIH4tLihDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgKENhbWwuSW50NjQubmVnIHgpKVxuOztcblxubGV0IG9uZV91bHAgZGlyIHQgPVxuICBtYXRjaCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0IHdpdGhcbiAgfCBOb25lIC0+IENhbWwubmFuXG4gIHwgU29tZSB4IC0+XG4gICAgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXJcbiAgICAgIChDYW1sLkludDY0LmFkZFxuICAgICAgICAgeFxuICAgICAgICAgKG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgVXAgLT4gMUxcbiAgICAgICAgICB8IGBEb3duIC0+IC0xTCkpXG47O1xuXG4oKiBbdXBwZXJfYm91bmRfZm9yX2ludF0gYW5kIFtsb3dlcl9ib3VuZF9mb3JfaW50XSBhcmUgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXgvbWluIGZsb2F0XG4gICB0aGF0IGZpdHMgaW4gYSBnaXZlbi1zaXplIGludGVnZXIgd2hlbiByb3VuZGVkIHRvd2FyZHMgMCAodXNpbmcgW2ludF9vZl9mbG9hdF0pLlxuXG4gICBtYXhfaW50L21pbl9pbnQgZGVwZW5kIG9uIFtudW1fYml0c10sIGUuZy4gKy8tIDJeMzAsICsvLSAyXjYyIGlmIDMxLWJpdCwgNjMtYml0XG4gICAocmVzcGVjdGl2ZWx5KSB3aGlsZSBmbG9hdCBpcyBJRUVFIHN0YW5kYXJkIGZvciBkb3VibGUgKDUyIHNpZ25pZmljYW50IGJpdHMpLlxuXG4gICBJbiBhbGwgY2FzZXMsIHdlIHdhbnQgdG8gZ3VhcmFudGVlIHRoYXRcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IDw9IHggPD0gdXBwZXJfYm91bmRfZm9yX2ludF1cbiAgIGlmZiBbaW50X29mX2Zsb2F0IHhdIGZpdHMgaW4gYW4gaW50IHdpdGggW251bV9iaXRzXSBiaXRzLlxuXG4gICBbMiAqKiAobnVtX2JpdHMgLSAxKV0gaXMgdGhlIGZpcnN0IGZsb2F0IGdyZWF0ZXIgdGhhdCBtYXhfaW50LCB3ZSB1c2UgdGhlIHByZWNlZGluZ1xuICAgZmxvYXQgYXMgdXBwZXIgYm91bmQuXG5cbiAgIFstICgyICoqIChudW1fYml0cyAtIDEpKV0gaXMgZXF1YWwgdG8gbWluX2ludC5cbiAgIEZvciBsb3dlciBib3VuZCB3ZSBsb29rIGZvciB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0gc28gdGhhdFxuICAgW2ZdIHJvdW5kcyB0b3dhcmQgemVybyB0byBbbWluX2ludF1cblxuICAgU28gaW4gcGFydGljdWxhciB3ZSB3aWxsIGhhdmU6XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCB4IDw9IC0gKDIgKiogKDEteCkpXVxuICAgW3VwcGVyX2JvdW5kX2Zvcl9pbnQgeCAgPCAgICAyICoqICgxLXgpIF1cbiopXG5sZXQgdXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBDYW1sLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBvbmVfdWxwIGBEb3duICgyLiAqKiBleHApXG47O1xuXG5sZXQgaXNfeF9taW51c19vbmVfZXhhY3QgeCA9XG4gICgqIFt4ID0geCAtLiAxLl0gZG9lcyBub3Qgd29yayB3aXRoIHg4NyBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGJhY2tlbmQgKHdoaWNoIGlzIHVzZWRcbiAgICAgb24gMzItYml0IG9jYW1sKSBiZWNhdXNlIG9mIDgwLWJpdCByZWdpc3RlciBwcmVjaXNpb24gb2YgaW50ZXJtZWRpYXRlIGNvbXB1dGF0aW9ucy5cblxuICAgICBBbiBhbHRlcm5hdGl2ZSB3YXkgb2YgY29tcHV0aW5nIHRoaXM6IFt4IC0uIG9uZV91bHAgYERvd24geCA8PSAxLl0gaXMgYWxzbyBwcm9uZSB0b1xuICAgICB0aGUgc2FtZSBwcmVjaXNpb24gaXNzdWVzOiB5b3UgbmVlZCB0byBtYWtlIHN1cmUgW3hdIGlzIDY0LWJpdC5cbiAgKilcbiAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIG5vdCAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHggPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKHggLS4gMS4pKVxuOztcblxubGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gQ2FtbC5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgbGV0IG1pbl9pbnRfYXNfZmxvYXQgPSB+LS4oMi4gKiogZXhwKSBpblxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG51bV9iaXRzIC0gMSA8IDUzICgqIDUzID0gI2JpdHMgaW4gdGhlIGZsb2F0J3MgbWFudGlzc2Egd2l0aCBzaWduIGluY2x1ZGVkICopXG4gIHRoZW4gKFxuICAgICgqIFRoZSBzbWFsbGVzdCBmbG9hdCB0aGF0IHJvdW5kcyB0b3dhcmRzIHplcm8gdG8gW21pbl9pbnRdIGlzXG4gICAgICAgW21pbl9pbnQgLSAxICsgZXBzaWxvbl0gKilcbiAgICBhc3NlcnQgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpO1xuICAgIG9uZV91bHAgYFVwIChtaW5faW50X2FzX2Zsb2F0IC0uIDEuKSlcbiAgZWxzZSAoXG4gICAgKCogW21pbl9pbnRfYXNfZmxvYXRdIGlzIGFscmVhZHkgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdLiAqKVxuICAgIGFzc2VydCAobm90IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KSk7XG4gICAgbWluX2ludF9hc19mbG9hdClcbjs7XG5cbigqIEZsb2F0IGNsYW1waW5nIGlzIHN0cnVjdHVyZWQgc2xpZ2h0bHkgZGlmZmVyZW50bHkgdGhhbiBjbGFtcGluZyBmb3Igb3RoZXIgdHlwZXMsIHNvXG4gICB0aGF0IHdlIGdldCB0aGUgYmVoYXZpb3Igb2YgW2NsYW1wX3VuY2hlY2tlZCBuYW4gfm1pbiB+bWF4ID0gbmFuXSAoZm9yIGFueSBbbWluXSBhbmRcbiAgIFttYXhdKSBmb3IgZnJlZS5cbiopXG5sZXQgY2xhbXBfdW5jaGVja2VkICh0IDogZmxvYXQpIH5taW4gfm1heCA9XG4gIGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiBtYXggPCB0IHRoZW4gbWF4IGVsc2UgdFxuOztcblxubGV0IGJveCA9XG4gICgqIFByZXZlbnQgcG90ZW50aWFsIGNvbnN0YW50IGZvbGRpbmcgb2YgWysuIDAuXSBpbiB0aGUgbmVhciBvY2FtbG9wdCBmdXR1cmUuICopXG4gIGxldCB4ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHkgMC4gaW5cbiAgZnVuIGYgLT4gZiArLiB4XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgQ2hhcjBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfY2hhciA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9jaGFyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9jaGFyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFN0cmluZy5tYWtlIDEgdFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbWF0Y2ggU3RyaW5nLmxlbmd0aCBzIHdpdGhcbiAgICB8IDEgLT4gcy5bMF1cbiAgICB8IF8gLT4gZmFpbHdpdGhmIFwiQ2hhci5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5DaGFyXCJcbiAgZW5kKVxuXG5sZXQgcHAgZm10IGMgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVDXCIgY1xuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGFsbCA9IEFycmF5LmluaXQgMjU2IH5mOnVuc2FmZV9vZl9pbnQgfD4gQXJyYXkudG9fbGlzdFxuXG5sZXQgaXNfbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfcHJpbnQgPSBmdW5jdGlvblxuICB8ICcgJyAuLiAnficgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc193aGl0ZXNwYWNlID0gZnVuY3Rpb25cbiAgfCAnXFx0JyB8ICdcXG4nIHwgJ1xcMDExJyAoKiB2ZXJ0aWNhbCB0YWIgKikgfCAnXFwwMTInICgqIGZvcm0gZmVlZCAqKSB8ICdcXHInIHwgJyAnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19hbHBoYSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbigqIFdyaXRpbmcgdGhlc2Ugb3V0LCBpbnN0ZWFkIG9mIGNhbGxpbmcgW2lzX2FscGhhXSBhbmQgW2lzX2RpZ2l0XSwgcmVkdWNlc1xuICAgcnVudGltZSBieSBhcHByb3guIDMwJSAqKVxubGV0IGlzX2FscGhhbnVtID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfZGlnaXRfdW5zYWZlIHQgPSB0b19pbnQgdCAtIHRvX2ludCAnMCdcblxubGV0IGdldF9kaWdpdF9leG4gdCA9XG4gIGlmIGlzX2RpZ2l0IHRcbiAgdGhlbiBnZXRfZGlnaXRfdW5zYWZlIHRcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLmdldF9kaWdpdF9leG4gJUM6IG5vdCBhIGRpZ2l0XCIgdCAoKVxuOztcblxubGV0IGdldF9kaWdpdCB0ID0gaWYgaXNfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9kaWdpdF91bnNhZmUgdCkgZWxzZSBOb25lXG5cbmxldCBpc19oZXhfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF9sb3dlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfdXBwZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdF9leG4gPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnMCdcbiAgfCAnYScgLi4gJ2YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ2EnICsgMTBcbiAgfCAnQScgLi4gJ0YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ0EnICsgMTBcbiAgfCB0IC0+XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJDaGFyLmdldF9oZXhfZGlnaXRfZXhuOiBub3QgYSBoZXhhZGVjaW1hbCBkaWdpdFwiXG4gICAgICAgICBbIFwiY2hhclwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IGdldF9oZXhfZGlnaXQgdCA9IGlmIGlzX2hleF9kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2hleF9kaWdpdF9leG4gdCkgZWxzZSBOb25lXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoID49ICkgPSAoID49IClcbiAgbGV0ICggPD0gKSA9ICggPD0gKVxuICBsZXQgKCA9ICkgPSAoID0gKVxuICBsZXQgKCA+ICkgPSAoID4gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgKCA8PiApID0gKCA8PiApXG5lbmRcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgYzEgYzIgPSBjb21wYXJlIChsb3dlcmNhc2UgYzEpIChsb3dlcmNhc2UgYzIpXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBoYXNoX2ZvbGRfY2hhciBzdGF0ZSAobG93ZXJjYXNlIHQpXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwibW9kdWxlIExpc3QgPSBMaXN0XG5cbm1vZHVsZSBFbnVtZXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBhbGwgOiB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdhIHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2IgbGlzdCAtPiAoJ2EsICdiKSB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYiBsaXN0IC0+ICdjIGxpc3QgLT4gKCdhLCAnYiwgJ2MpIHQgbGlzdFxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0MC5JbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbigqIENvbnN0cnVjdCBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAyNTYsIG1hcHBpbmcgZXZlcnkgaW5wdXQgY2hhcmFjdGVyIGNvZGUgdG9cbiAgIGl0cyBjb3JyZXNwb25kaW5nIG91dHB1dCBjaGFyYWN0ZXIuXG5cbiAgIEJlbmNobWFya3MgaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuIHRoZSBsYW1iZGEgKGluY2x1ZGluZyBjb3N0IG9mXG4gICB0aGlzIGZ1bmN0aW9uKSwgZXZlbiBpZiB0YXJnZXQvcmVwbGFjZW1lbnQgYXJlIGp1c3QgMiBjaGFyYWN0ZXJzIGVhY2guXG5cbiAgIFJldHVybiBOb25lIGlmIHRoZSB0cmFuc2xhdGlvbiBtYXAgaXMgZXF1aXZhbGVudCB0byBqdXN0IHRoZSBpZGVudGl0eS4gKilcbmxldCB0cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgbGV0IHRyX21hcCA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgZm9yIGkgPSAwIHRvIDI1NSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGkgKENoYXIub2ZfaW50X2V4biBpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIC0gMSBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCAoU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgaSlcbiAgZG9uZTtcbiAgbGV0IGxhc3RfcmVwbGFjZW1lbnQgPSBTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCAtIDEpIGluXG4gIGZvclxuICAgIGkgPSBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgdG8gU3RyaW5nLmxlbmd0aCB0YXJnZXQgLSAxXG4gIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IGxhc3RfcmVwbGFjZW1lbnRcbiAgZG9uZTtcbiAgbGV0IHJlYyBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIGkgPVxuICAgIGlmIGkgPSAyNTZcbiAgICB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIGkpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgKGkgKyAxKVxuICBpblxuICAoKiBxdWljayBjaGVjayBvbiB0aGUgZmlyc3QgdGFyZ2V0IGNoYXJhY3RlciB3aGljaCB3aWxsIDk5JSBiZSB0cnVlICopXG4gIGxldCBmaXJzdF90YXJnZXQgPSB0YXJnZXQuWzBdIGluXG4gIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGZpcnN0X3RhcmdldCkpIGZpcnN0X3RhcmdldFxuICB8fCBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIDBcbiAgdGhlbiBTb21lIChCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0cl9tYXApXG4gIGVsc2UgTm9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPSAnYVxuXG5sZXQgc3RhZ2UgPSBGbi5pZFxubGV0IHVuc3RhZ2UgPSBGbi5pZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbmluY2x1ZGUgU3RyaW5nMFxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG4oKiBUaGlzIGFsaWFzIGlzIG5lY2Vzc2FyeSBkZXNwaXRlIFtTdHJpbmcwXSBkZWZpbmluZyBbQnl0ZXMgPSBCeXRlczBdLCBpbiBvcmRlciB0b1xuICAgY29udmluY2Ugb2NhbWxkZXAgdGhhdCB0aGlzIGZpbGUgZG9lc24ndCBkZXBlbmQgb24gYnl0ZXMubWwuICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3N0cmluZ1xuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfc3RyaW5nIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxudHlwZSBlbHQgPSBjaGFyXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbigqIFRoaXMgaXMgY29waWVkL2FkYXB0ZWQgZnJvbSAnYmxpdC5tbCcuXG4gICBbc3ViXSwgW3N1Ym9dIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtCbGl0Lk1ha2UoQnl0ZXMpXSBwbHVzIHVuc2FmZSBjYXN0cyB0by9mcm9tXG4gICBzdHJpbmcgYnV0IHdlcmUgaW5saW5lZCBoZXJlIHRvIGF2b2lkIHVzaW5nIFtCeXRlcy51bnNhZmVfb2Zfc3RyaW5nXSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuKilcbmxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA9IDAgJiYgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmNcbiAgdGhlbiBzcmNcbiAgZWxzZSAoXG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHNyYyk7XG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KSlcbjs7XG5cbmxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICBzdWJcbiAgICBzcmNcbiAgICB+cG9zXG4gICAgfmxlbjpcbiAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICB8IE5vbmUgLT4gbGVuZ3RoIHNyYyAtIHBvcylcbjs7XG5cbmxldCByZWMgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXyBjaGFyID1cbiAgcG9zIDwgZW5kX1xuICAmJiAoQ2hhci5lcXVhbCAodW5zYWZlX2dldCB0IHBvcykgY2hhciB8fCBjb250YWluc191bnNhZmUgdCB+cG9zOihwb3MgKyAxKSB+ZW5kXyBjaGFyKVxuOztcblxubGV0IGNvbnRhaW5zID8ocG9zID0gMCkgP2xlbiB0IGNoYXIgPVxuICBsZXQgdG90YWxfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gIGxldCBsZW4gPSBPcHRpb24udmFsdWUgbGVuIH5kZWZhdWx0Oih0b3RhbF9sZW5ndGggLSBwb3MpIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF86KHBvcyArIGxlbikgY2hhclxuOztcblxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IHJlYyBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA+PSBsZW5cbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvczoocG9zICsgMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCBpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3M6MCB+bGVuOihsZW5ndGggdCkgfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBpbmRleF9leG4gdCBjaGFyID0gaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgaW5kZXhfZXhuXG47O1xuXG5sZXQgaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhclxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgcmVjIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA8IDBcbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyAtIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgcmluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOihsZW4gLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZXhuIHQgY2hhciA9IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZXhuXG47O1xuXG5sZXQgcmluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgLTEgfHwgcG9zID49IGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZnJvbV9leG5cbjs7XG5cbmxldCBpbmRleCB0IGNoYXIgPVxuICB0cnkgU29tZSAoaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmluZGV4IHQgY2hhciA9XG4gIHRyeSBTb21lIChyaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICB0cnkgU29tZSAocmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuMCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgPSBfIH0gOiBTZXhwLnQgPVxuICAgIExpc3RcbiAgICAgIFsgTGlzdCBbIEF0b20gXCJwYXR0ZXJuXCI7IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm4gXVxuICAgICAgOyBMaXN0IFsgQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZSBdXG4gICAgICBdXG4gIDs7XG5cbiAgbGV0IHBhdHRlcm4gdCA9IHQucGF0dGVyblxuICBsZXQgY2FzZV9zZW5zaXRpdmUgdCA9IHQuY2FzZV9zZW5zaXRpdmVcblxuICAoKiBGaW5kIG1heCBudW1iZXIgb2YgbWF0Y2hlZCBjaGFyYWN0ZXJzIGF0IFtuZXh0X3RleHRfY2hhcl0sIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgIFttYXRjaGVkX2NoYXJzXS4gVHJ5IHRvIGV4dGVuZCB0aGUgY3VycmVudCBtYXRjaCwgaWYgY2hhcnMgZG9uJ3QgbWF0Y2gsIHRyeSB0byBtYXRjaFxuICAgICBmZXdlciBjaGFycy4gSWYgY2hhcnMgbWF0Y2ggdGhlbiBleHRlbmQgdGhlIG1hdGNoLiAqKVxuICBsZXQga21wX2ludGVybmFsX2xvb3Agfm1hdGNoZWRfY2hhcnMgfm5leHRfdGV4dF9jaGFyIH5wYXR0ZXJuIH5rbXBfYXJyYXkgfmNoYXJfZXF1YWwgPVxuICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIG1hdGNoZWRfY2hhcnMgaW5cbiAgICB3aGlsZVxuICAgICAgIW1hdGNoZWRfY2hhcnMgPiAwXG4gICAgICAmJiBub3QgKGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycykpXG4gICAgZG9cbiAgICAgIG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKCFtYXRjaGVkX2NoYXJzIC0gMSlcbiAgICBkb25lO1xuICAgIGlmIGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycylcbiAgICB0aGVuIG1hdGNoZWRfY2hhcnMgOj0gIW1hdGNoZWRfY2hhcnMgKyAxO1xuICAgICFtYXRjaGVkX2NoYXJzXG4gIDs7XG5cbiAgbGV0IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbWF0Y2ggY2FzZV9zZW5zaXRpdmUgd2l0aFxuICAgIHwgdHJ1ZSAtPiBDaGFyLmVxdWFsXG4gICAgfCBmYWxzZSAtPiBDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVAgcHJlLXByb2Nlc3Npbmcgb2YgdGhlIHBhdHRlcm46IGJ1aWxkIHRoZSBpbnQgYXJyYXksIHdoaWNoLCBmb3IgZWFjaCBpLFxuICAgICBjb250YWlucyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IG5vbi10cml2aWFsIHByZWZpeCBvZiBzIHdoaWNoIGlzIGVxdWFsIHRvIGEgc3VmZml4XG4gICAgIGVuZGluZyBhdCBzLltpXSAqKVxuICBsZXQgY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBsZXQgbiA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgbGV0IGttcF9hcnJheSA9IEFycmF5LmNyZWF0ZSB+bGVuOm4gKC0xKSBpblxuICAgIGlmIG4gPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgMCAwO1xuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhcjoodW5zYWZlX2dldCBwYXR0ZXJuIGkpXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IGkgIW1hdGNoZWRfY2hhcnNcbiAgICAgIGRvbmUpO1xuICAgIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9XG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVA6IHVzZSB0aGUgcHJlLXByb2Nlc3NlZCBwYXR0ZXJuIHRvIG9wdGltaXplIGxvb2stYmVoaW5kcyBvbiBub24tbWF0Y2hlcy5cbiAgICAgV2UgcmV0dXJuIGludCB0byBhdm9pZCBhbGxvY2F0aW9uIGluIFtpbmRleF9leG5dLiAtMSBtZWFucyBubyBtYXRjaC4gKilcbiAgbGV0IGluZGV4X2ludGVybmFsID8ocG9zID0gMCkgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfmluXzp0ZXh0ID1cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlbmd0aCB0ZXh0IC0gbGVuZ3RoIHBhdHRlcm5cbiAgICB0aGVuIC0xXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IGogPSByZWYgcG9zIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICB3aGlsZSAhaiA8IG4gJiYgIW1hdGNoZWRfY2hhcnMgPCBrIGRvXG4gICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCAhaiBpblxuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgaiA6PSAhaiArIDFcbiAgICAgIGRvbmU7XG4gICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGsgdGhlbiAhaiAtIGsgZWxzZSAtMSlcbiAgOztcblxuICBsZXQgbWF0Y2hlcyB0IHN0ciA9IGluZGV4X2ludGVybmFsIHQgfmluXzpzdHIgPj0gMFxuXG4gIGxldCBpbmRleCA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPCAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgcFxuICA7O1xuXG4gIGxldCBpbmRleF9leG4gP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwID49IDBcbiAgICB0aGVuIHBcbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJTdWJzdHJpbmcgbm90IGZvdW5kXCIgWyBcInN1YnN0cmluZ1wiLCBzZXhwX29mX3N0cmluZyB0LnBhdHRlcm4gXSlcbiAgOztcblxuICBsZXQgaW5kZXhfYWxsIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5tYXlfb3ZlcmxhcCB+aW5fOnRleHQgPVxuICAgIGlmIGxlbmd0aCBwYXR0ZXJuID0gMFxuICAgIHRoZW4gTGlzdC5pbml0ICgxICsgbGVuZ3RoIHRleHQpIH5mOkZuLmlkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgbGV0IGZvdW5kID0gcmVmIFtdIGluXG4gICAgICBmb3IgaiA9IDAgdG8gbiBkb1xuICAgICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGtcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgZm91bmQgOj0gKGogLSBrKSA6OiAhZm91bmQ7XG4gICAgICAgICAgKCogd2UganVzdCBmb3VuZCBhIG1hdGNoIGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb24gKilcbiAgICAgICAgICBtYXRjaCBtYXlfb3ZlcmxhcCB3aXRoXG4gICAgICAgICAgfCB0cnVlIC0+IG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKGsgLSAxKVxuICAgICAgICAgIHwgZmFsc2UgLT4gbWF0Y2hlZF9jaGFycyA6PSAwKTtcbiAgICAgICAgaWYgaiA8IG5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0IGogaW5cbiAgICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICB+Y2hhcl9lcXVhbClcbiAgICAgIGRvbmU7XG4gICAgICBMaXN0LnJldiAhZm91bmQpXG4gIDs7XG5cbiAgbGV0IHJlcGxhY2VfZmlyc3QgP3BvcyB0IH5pbl86cyB+d2l0aF8gPVxuICAgIG1hdGNoIGluZGV4ID9wb3MgdCB+aW5fOnMgd2l0aFxuICAgIHwgTm9uZSAtPiBzXG4gICAgfCBTb21lIGkgLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgbGVuX3dpdGggLSBsZW5fdCkgaW5cbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOndpdGhfIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczppIH5sZW46bGVuX3dpdGg7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6KGkgKyBsZW5fdClcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczooaSArIGxlbl93aXRoKVxuICAgICAgICB+bGVuOihsZW5fcyAtIGkgLSBsZW5fdCk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG5cbiAgbGV0IHJlcGxhY2VfYWxsIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgbWF0Y2ggbWF0Y2hlcyB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBudW1fbWF0Y2hlcyA9IExpc3QubGVuZ3RoIG1hdGNoZXMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgKChsZW5fd2l0aCAtIGxlbl90KSAqIG51bV9tYXRjaGVzKSkgaW5cbiAgICAgIGxldCBuZXh0X2RzdF9wb3MgPSByZWYgMCBpblxuICAgICAgbGV0IG5leHRfc3JjX3BvcyA9IHJlZiAwIGluXG4gICAgICBMaXN0Lml0ZXIgbWF0Y2hlcyB+ZjooZnVuIGkgLT5cbiAgICAgICAgbGV0IGxlbiA9IGkgLSAhbmV4dF9zcmNfcG9zIGluXG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczohbmV4dF9zcmNfcG9zIH5kc3QgfmRzdF9wb3M6IW5leHRfZHN0X3BvcyB+bGVuO1xuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICAgIH5zcmM6d2l0aF9cbiAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgfmRzdFxuICAgICAgICAgIH5kc3RfcG9zOighbmV4dF9kc3RfcG9zICsgbGVuKVxuICAgICAgICAgIH5sZW46bGVuX3dpdGg7XG4gICAgICAgIG5leHRfZHN0X3BvcyA6PSAhbmV4dF9kc3RfcG9zICsgbGVuICsgbGVuX3dpdGg7XG4gICAgICAgIG5leHRfc3JjX3BvcyA6PSAhbmV4dF9zcmNfcG9zICsgbGVuICsgbGVuX3QpO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOiFuZXh0X3NyY19wb3NcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczohbmV4dF9kc3RfcG9zXG4gICAgICAgIH5sZW46KGxlbl9zIC0gIW5leHRfc3JjX3Bvcyk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG4gIGxldCBzcGxpdF9vbiB0IHMgPVxuICAgIGxldCBwYXR0ZXJuX2xlbiA9IFN0cmluZy5sZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgTGlzdC5tYXAyX2V4blxuICAgICAgKC1wYXR0ZXJuX2xlbiA6OiBtYXRjaGVzKVxuICAgICAgKG1hdGNoZXMgQCBbIFN0cmluZy5sZW5ndGggcyBdKVxuICAgICAgfmY6KGZ1biBpIGogLT4gc3ViIHMgfnBvczooaSArIHBhdHRlcm5fbGVuKSB+bGVuOihqIC0gaSAtIHBhdHRlcm5fbGVuKSlcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgcHVibGljID0gdFxuXG4gICAgdHlwZSBub25yZWMgdCA9IHQgPVxuICAgICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWwgPVxuICAgICAgKGZ1biBhX18wMDJfIGJfXzAwM18gLT5cbiAgICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMl8gYl9fMDAzX1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAoZXF1YWxfc3RyaW5nIGFfXzAwMl8ucGF0dGVybiBiX18wMDNfLnBhdHRlcm4pXG4gICAgICAgICAgICAgKFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAgICAoZXF1YWxfYm9vbCBhX18wMDJfLmNhc2Vfc2Vuc2l0aXZlIGJfXzAwM18uY2FzZV9zZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgKGVxdWFsX2FycmF5IGVxdWFsX2ludCBhX18wMDJfLmttcF9hcnJheSBiX18wMDNfLmttcF9hcnJheSkpXG4gICAgICAgICAgIDogdCAtPiB0IC0+IGJvb2wpXG4gICAgOztcblxuICAgIGxldCBzZXhwX29mX3QgPVxuICAgICAgKGZ1biB7IHBhdHRlcm4gPSBwYXR0ZXJuX18wMDdfXG4gICAgICAgICAgIDsgY2FzZV9zZW5zaXRpdmUgPSBjYXNlX3NlbnNpdGl2ZV9fMDA5X1xuICAgICAgICAgICA7IGttcF9hcnJheSA9IGttcF9hcnJheV9fMDExX1xuICAgICAgICAgICB9IC0+XG4gICAgICAgIGxldCBibmRzX18wMDZfID0gW10gaW5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgIGxldCBhcmdfXzAxMl8gPSBzZXhwX29mX2FycmF5IHNleHBfb2ZfaW50IGttcF9hcnJheV9fMDExXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImttcF9hcnJheVwiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlX18wMDlfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiY2FzZV9zZW5zaXRpdmVcIjsgYXJnX18wMTBfIF1cbiAgICAgICAgICA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA3XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBhdHRlcm5cIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDA2X1xuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gRm4uaWRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuX2hlbHBlciA9IHN0cnVjdFxuICBtb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBTZWFyY2hfcGF0dGVybjBcbmVuZFxuXG5vcGVuIFNlYXJjaF9wYXR0ZXJuX2hlbHBlclxuXG5sZXQgc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXggP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfZXhuID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfm1heV9vdmVybGFwIH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfYWxsXG4gICAgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybilcbiAgICB+bWF5X292ZXJsYXBcbiAgICB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfZmlyc3QgP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9hbGwgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+c3Vic3RyaW5nID1cbiAgT3B0aW9uLmlzX3NvbWUgKHN1YnN0cl9pbmRleF9nZW4gdCB+cGF0dGVybjpzdWJzdHJpbmcgfmNhc2Vfc2Vuc2l0aXZlKVxuOztcblxubGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5cbmxldCBpc19zdWJzdHJpbmdfYXRfZ2VuID1cbiAgbGV0IHJlYyBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvcyB+c3ViX2xlbiB+Y2hhcl9lcXVhbCA9XG4gICAgaWYgc3ViX3BvcyA9IHN1Yl9sZW5cbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGlmIGNoYXJfZXF1YWwgKHVuc2FmZV9nZXQgc3RyIHN0cl9wb3MpICh1bnNhZmVfZ2V0IHN1YiBzdWJfcG9zKVxuICAgIHRoZW4gbG9vcCB+c3RyIH5zdHJfcG9zOihzdHJfcG9zICsgMSkgfnN1YiB+c3ViX3Bvczooc3ViX3BvcyArIDEpIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG4gICAgZWxzZSBmYWxzZVxuICBpblxuICBmdW4gc3RyIH5wb3M6c3RyX3BvcyB+c3Vic3RyaW5nOnN1YiB+Y2hhcl9lcXVhbCAtPlxuICAgIGxldCBzdHJfbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCBzdWJfbGVuID0gbGVuZ3RoIHN1YiBpblxuICAgIGlmIHN0cl9wb3MgPCAwIHx8IHN0cl9wb3MgPiBzdHJfbGVuXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiU3RyaW5nLmlzX3N1YnN0cmluZ19hdDogaW52YWxpZCBpbmRleCAlZCBmb3Igc3RyaW5nIG9mIGxlbmd0aCAlZFwiXG4gICAgICAgIHN0cl9wb3NcbiAgICAgICAgc3RyX2xlblxuICAgICAgICAoKTtcbiAgICBzdHJfcG9zICsgc3ViX2xlbiA8PSBzdHJfbGVuXG4gICAgJiYgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3M6MCB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3N1ZmZpeF9nZW4gc3RyaW5nIH5zdWZmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIHN0cmluZ19sZW4gPj0gc3VmZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuXG4gICAgICAgc3RyaW5nXG4gICAgICAgfnBvczooc3RyaW5nX2xlbiAtIHN1ZmZpeF9sZW4pXG4gICAgICAgfnN1YnN0cmluZzpzdWZmaXhcbiAgICAgICB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3ByZWZpeF9nZW4gc3RyaW5nIH5wcmVmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHByZWZpeF9sZW4gPSBsZW5ndGggcHJlZml4IGluXG4gIHN0cmluZ19sZW4gPj0gcHJlZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuIHN0cmluZyB+cG9zOjAgfnN1YnN0cmluZzpwcmVmaXggfmNoYXJfZXF1YWxcbjs7XG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9zdHJpbmcgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNoYXJfY29tcGFyZV9jYXNlbGVzcyBjMSBjMiA9IENoYXIuY29tcGFyZSAoQ2hhci5sb3dlcmNhc2UgYzEpIChDaGFyLmxvd2VyY2FzZSBjMilcblxuICAgIGxldCByZWMgY29tcGFyZV9sb29wIH5wb3MgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjIgPVxuICAgICAgaWYgcG9zID0gbGVuMVxuICAgICAgdGhlbiBpZiBwb3MgPSBsZW4yIHRoZW4gMCBlbHNlIC0xXG4gICAgICBlbHNlIGlmIHBvcyA9IGxlbjJcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjID0gY2hhcl9jb21wYXJlX2Nhc2VsZXNzICh1bnNhZmVfZ2V0IHN0cmluZzEgcG9zKSAodW5zYWZlX2dldCBzdHJpbmcyIHBvcykgaW5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgMCAtPiBjb21wYXJlX2xvb3AgfnBvczoocG9zICsgMSkgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjJcbiAgICAgICAgfCBfIC0+IGMpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIHN0cmluZzEgc3RyaW5nMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHN0cmluZzEgc3RyaW5nMlxuICAgICAgdGhlbiAwXG4gICAgICBlbHNlXG4gICAgICAgIGNvbXBhcmVfbG9vcFxuICAgICAgICAgIH5wb3M6MFxuICAgICAgICAgIH5zdHJpbmcxXG4gICAgICAgICAgfmxlbjE6KFN0cmluZy5sZW5ndGggc3RyaW5nMSlcbiAgICAgICAgICB+c3RyaW5nMlxuICAgICAgICAgIH5sZW4yOihTdHJpbmcubGVuZ3RoIHN0cmluZzIpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID1cbiAgICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgICAgbGV0IHN0YXRlID0gcmVmIChoYXNoX2ZvbGRfaW50IHN0YXRlIGxlbikgaW5cbiAgICAgIGZvciBwb3MgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgc3RhdGUgOj0gaGFzaF9mb2xkX2NoYXIgIXN0YXRlIChDaGFyLmxvd2VyY2FzZSAodW5zYWZlX2dldCB0IHBvcykpXG4gICAgICBkb25lO1xuICAgICAgIXN0YXRlXG4gICAgOztcblxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gICAgbGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nX2F0ID0gaXNfc3Vic3RyaW5nX2F0X2dlbiB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbmVuZFxuXG5sZXQgb2Zfc3RyaW5nID0gRm4uaWRcbmxldCB0b19zdHJpbmcgPSBGbi5pZFxuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgQnl0ZXMuc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCB0b19saXN0IHMgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpIDwgMCB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgLSAxKSBpblxuICBsb29wIFtdIChsZW5ndGggcyAtIDEpXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpID0gbGVuIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSArIDEpIGluXG4gIGxvb3AgW10gMFxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCByZXMgaSAodW5zYWZlX2dldCB0IChsZW4gLSAxIC0gaSkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzXG47O1xuXG4oKiogRWZmaWNpZW50IHN0cmluZyBzcGxpdHRpbmcgKilcblxubGV0IGxzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmxzcGxpdDJfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGxzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgcG9zID0gaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGxzcGxpdDJfZXhuXG47O1xuXG5sZXQgcnNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucnNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcnNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBwb3MgPSByaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJzcGxpdDJfZXhuXG47O1xuXG5sZXQgbHNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChsc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcnNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChyc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG5sZXQgc3BsaXRfbGluZXMgPVxuICBsZXQgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbCA9XG4gICAgcG9zIDo9ICFwb3MgLSBpZiAhcG9zID4gMCAmJiBDaGFyLmVxdWFsIHQuWyFwb3MgLSAxXSAnXFxyJyB0aGVuIDIgZWxzZSAxO1xuICAgIGVvbCA6PSAhcG9zICsgMVxuICBpblxuICBmdW4gdCAtPlxuICAgIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgICgqIEludmFyaWFudDogWy0xIDw9IHBvcyA8IGVvbF0uICopXG4gICAgICBsZXQgcG9zID0gcmVmIChuIC0gMSkgaW5cbiAgICAgIGxldCBlb2wgPSByZWYgbiBpblxuICAgICAgbGV0IGFjID0gcmVmIFtdIGluXG4gICAgICAoKiBXZSB0cmVhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgc3BlY2lhbGx5LCBiZWNhdXNlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGFcbiAgICAgICAgIG5ld2xpbmUsIHdlIGRvbid0IHdhbnQgYW4gZXh0cmEgZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG91dHB1dC4gKilcbiAgICAgIGlmIENoYXIuZXF1YWwgdC5bIXBvc10gJ1xcbicgdGhlbiBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sO1xuICAgICAgd2hpbGUgIXBvcyA+PSAwIGRvXG4gICAgICAgIGlmIENoYXIuKCA8PiApIHQuWyFwb3NdICdcXG4nXG4gICAgICAgIHRoZW4gZGVjciBwb3NcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogQmVjYXVzZSBbcG9zIDwgZW9sXSwgd2Uga25vdyB0aGF0IFtzdGFydCA8PSBlb2xdLiAqKVxuICAgICAgICAgIGxldCBzdGFydCA9ICFwb3MgKyAxIGluXG4gICAgICAgICAgYWMgOj0gc3ViIHQgfnBvczpzdGFydCB+bGVuOighZW9sIC0gc3RhcnQpIDo6ICFhYztcbiAgICAgICAgICBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sKVxuICAgICAgZG9uZTtcbiAgICAgIHN1YiB0IH5wb3M6MCB+bGVuOiFlb2wgOjogIWFjKVxuOztcblxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBpIC0+IFNvbWUgdC5baV1cbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG5cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGYgdC5baV0gd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHJlcylcbiAgaW5cbiAgbG9vcCAwXG47O1xuXG5sZXQgcmZpbmRpID9wb3MgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA8IDAgdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSAtIDEpIGluXG4gIGxldCBwb3MgPVxuICAgIG1hdGNoIHBvcyB3aXRoXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgICB8IE5vbmUgLT4gbGVuZ3RoIHQgLSAxXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKVxuXG5sZXQgcnN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSBpIC0+IGlmIGkgPSBsZW5ndGggdCAtIDEgdGhlbiB0IGVsc2UgcHJlZml4IHQgKGkgKyAxKVxuOztcblxubGV0IGZpcnN0X25vbl9kcm9wIH5kcm9wIHQgPSBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBub3QgKGRyb3AgYykpXG5cbmxldCBsc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSAwIC0+IHRcbiAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG47O1xuXG4oKiBbc3RyaXAgdF0gY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgW2xzdHJpcCAocnN0cmlwIHQpXS4gIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG5sZXQgc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBmaXJzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgICB8IE5vbmUgLT4gXCJcIlxuICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHQnID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0JyBpIChmIGkgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbigqIHJlcGVhdGVkIGNvZGUgdG8gYXZvaWQgcmVxdWlyaW5nIGFuIGV4dHJhIGFsbG9jYXRpb24gZm9yIGEgY2xvc3VyZSBvbiBlYWNoIGNhbGwuICopXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiB0LltpXSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0J1xuOztcblxubGV0IHRvX2FycmF5IHMgPSBBcnJheS5pbml0IChsZW5ndGggcykgfmY6KGZ1biBpIC0+IHMuW2ldKVxuXG5sZXQgZXhpc3RzID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA8IGxlbiAmJiAoZiBzLltpXSB8fCBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb3JfYWxsID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA9IGxlbiB8fCAoZiBzLltpXSAmJiBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGZvbGRpID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBpIGFjIHQuW2ldKSB+ZiB+bGVuXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCAwIGluaXQgfmYgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0ID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdFxubGV0IG1heF9lbHQgdCA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHRcbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZmluZF9tYXBpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kX21hcGkgfml0ZXJpIHQgfmZcbmxldCBmaW5kaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZGkgfml0ZXJpIHQgfmZcbmxldCBjb3VudGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmNvdW50aSB+Zm9sZGkgdCB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5mb3JfYWxsaSB+aXRlcmkgdCB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmV4aXN0c2kgfml0ZXJpIHQgfmZcblxubGV0IG1lbSA9XG4gIGxldCByZWMgbG9vcCB0IGMgfnBvczppIH5sZW4gPVxuICAgIGkgPCBsZW4gJiYgKENoYXIuZXF1YWwgYyAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCBjIH5wb3M6KGkgKyAxKSB+bGVuKVxuICBpblxuICBmdW4gdCBjIC0+IGxvb3AgdCBjIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgaWYgQ2hhci5lcXVhbCB0YXJnZXQgcmVwbGFjZW1lbnRcbiAgdGhlbiBzXG4gIGVsc2UgaWYgbWVtIHMgdGFyZ2V0XG4gIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IGlmIENoYXIuZXF1YWwgYyB0YXJnZXQgdGhlbiByZXBsYWNlbWVudCBlbHNlIGMpXG4gIGVsc2Ugc1xuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgaXNfZW1wdHkgdGFyZ2V0XG4gIHRoZW4gc3RhZ2UgRm4uaWRcbiAgZWxzZSBpZiBpc19lbXB0eSByZXBsYWNlbWVudFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGkgcmVwbGFjZW1lbnQgaXMgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIEZuLmlkXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGlmIGV4aXN0cyBzIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICh1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpKVxuICAgICAgICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiB1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpXG4gICAgICAgIGVsc2UgcykpXG47O1xuXG4oKiBmYXN0IHZlcnNpb24sIGlmIHdlIGV2ZXIgbmVlZCBpdDpcbiAgIHtbXG4gICAgIGxldCBjb25jYXRfYXJyYXkgfnNlcCBhciA9XG4gICAgICAgbGV0IGFyX2xlbiA9IEFycmF5Lmxlbmd0aCBhciBpblxuICAgICAgIGlmIGFyX2xlbiA9IDAgdGhlbiBcIlwiXG4gICAgICAgZWxzZVxuICAgICAgICAgbGV0IHNlcF9sZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICBsZXQgcmVzX2xlbl9yZWYgPSByZWYgKHNlcF9sZW4gKiAoYXJfbGVuIC0gMSkpIGluXG4gICAgICAgICBmb3IgaSA9IDAgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICByZXNfbGVuX3JlZiA6PSAhcmVzX2xlbl9yZWYgKyBsZW5ndGggYXIuKGkpXG4gICAgICAgICBkb25lO1xuICAgICAgICAgbGV0IHJlcyA9IGNyZWF0ZSAhcmVzX2xlbl9yZWYgaW5cbiAgICAgICAgIGxldCBzdHJfMCA9IGFyLigwKSBpblxuICAgICAgICAgbGV0IGxlbl8wID0gbGVuZ3RoIHN0cl8wIGluXG4gICAgICAgICBibGl0IH5zcmM6c3RyXzAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczowIH5sZW46bGVuXzA7XG4gICAgICAgICBsZXQgcG9zX3JlZiA9IHJlZiBsZW5fMCBpblxuICAgICAgICAgZm9yIGkgPSAxIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgbGV0IHBvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzZXAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3Bvczpwb3MgfmxlbjpzZXBfbGVuO1xuICAgICAgICAgICBsZXQgbmV3X3BvcyA9IHBvcyArIHNlcF9sZW4gaW5cbiAgICAgICAgICAgbGV0IHN0cl9pID0gYXIuKGkpIGluXG4gICAgICAgICAgIGxldCBsZW5faSA9IGxlbmd0aCBzdHJfaSBpblxuICAgICAgICAgICBibGl0IH5zcmM6c3RyX2kgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczpuZXdfcG9zIH5sZW46bGVuX2k7XG4gICAgICAgICAgIHBvc19yZWYgOj0gbmV3X3BvcyArIGxlbl9pXG4gICAgICAgICBkb25lO1xuICAgICAgICAgcmVzXG4gICBdfSAqKVxuXG5sZXQgY29uY2F0X2FycmF5ID9zZXAgYXIgPSBjb25jYXQgP3NlcCAoQXJyYXkudG9fbGlzdCBhcilcbmxldCBjb25jYXRfbWFwID9zZXAgcyB+ZiA9IGNvbmNhdF9hcnJheSA/c2VwIChBcnJheS5tYXAgKHRvX2FycmF5IHMpIH5mKVxuXG4oKiBbZmlsdGVyIHQgZl0gaXMgaW1wbGVtZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0uXG5cbiAgIExldCBbbiA9IGxlbmd0aCB0XS5cblxuICAgMS4gRmluZCB0aGUgbG93ZXN0IFtpXSBzdWNoIHRoYXQgW25vdCAoZiB0LltpXSldLlxuXG4gICAyLiBJZiB0aGVyZSBpcyBubyBzdWNoIFtpXSwgdGhlbiByZXR1cm4gW3RdLlxuXG4gICAzLiBJZiB0aGVyZSBpcyBzdWNoIGFuIFtpXSwgYWxsb2NhdGUgYSBzdHJpbmcsIFtvdXRdLCB0byBob2xkIHRoZSByZXN1bHQuICBbb3V0XSBoYXNcbiAgIGxlbmd0aCBbbiAtIDFdLCB3aGljaCBpcyB0aGUgbWF4aW11bSBwb3NzaWJsZSBvdXRwdXQgc2l6ZSBnaXZlbiB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0XG4gICBvbmUgY2hhcmFjdGVyIG5vdCBzYXRpc2Z5aW5nIFtmXS5cblxuICAgNC4gQ29weSBjaGFyYWN0ZXJzIGF0IGluZGljZXMgMCAuLi4gW2kgLSAxXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNS4gV2FsayB0aHJvdWdoIGNoYXJhY3RlcnMgYXQgaW5kaWNlcyBbaSsxXSAuLi4gW24tMV0gb2YgW3RdLCBjb3B5aW5nIHRob3NlIHRoYXRcbiAgIHNhdGlzZnkgW2ZdIGZyb20gW3RdIHRvIFtvdXRdLlxuXG4gICA2LiBJZiB3ZSBjb21wbGV0ZWx5IGZpbGxlZCBbb3V0XSwgdGhlbiByZXR1cm4gaXQuICBJZiBub3QsIHJldHVybiB0aGUgcHJlZml4IG9mIFtvdXRdXG4gICB0aGF0IHdlIGRpZCBmaWxsIGluLlxuXG4gICBUaGlzIGFsZ29yaXRobSBoYXMgdGhlIHByb3BlcnR5IHRoYXQgaXQgZG9lc24ndCBhbGxvY2F0ZSBhIG5ldyBzdHJpbmcgaWYgdGhlcmUnc1xuICAgbm90aGluZyB0byBmaWx0ZXIsIHdoaWNoIGlzIGEgY29tbW9uIGNhc2UuICopXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IG4gJiYgZiAhaSB0LlshaV0gZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgaWYgIWkgPSBuXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgb3V0ID0gQnl0ZXMuY3JlYXRlIChuIC0gMSkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om91dCB+ZHN0X3BvczowIH5sZW46IWk7XG4gICAgbGV0IG91dF9wb3MgPSByZWYgIWkgaW5cbiAgICBpbmNyIGk7XG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgYyA9IHQuWyFpXSBpblxuICAgICAgaWYgZiAhaSBjXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dCAhb3V0X3BvcyBjO1xuICAgICAgICBpbmNyIG91dF9wb3MpO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBsZXQgb3V0ID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXQgaW5cbiAgICBpZiAhb3V0X3BvcyA9IG4gLSAxIHRoZW4gb3V0IGVsc2Ugc3ViIG91dCB+cG9zOjAgfmxlbjohb3V0X3Bvcylcbjs7XG5cbmxldCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gU29tZSAoZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3BfcHJlZml4X2lmX2V4aXN0cyBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9wcmVmaXhfZXhuIHMgfnByZWZpeCA9XG4gIG1hdGNoIGNob3BfcHJlZml4IHMgfnByZWZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9wcmVmaXhfZXhuICVTICVTXCIgcyBwcmVmaXggKClcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gU29tZSAoZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3Bfc3VmZml4X2lmX2V4aXN0cyBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9zdWZmaXhfZXhuIHMgfnN1ZmZpeCA9XG4gIG1hdGNoIGNob3Bfc3VmZml4IHMgfnN1ZmZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9zdWZmaXhfZXhuICVTICVTXCIgcyBzdWZmaXggKClcbjs7XG5cbm1vZHVsZSBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4ID0gc3RydWN0XG4gICgqIFdoZW4gdGFraW5nIGEgc3RyaW5nIHByZWZpeCBvciBzdWZmaXgsIHdlIGV4dHJhY3QgZnJvbSB0aGUgc2hvcnRlc3QgaW5wdXQgYXZhaWxhYmxlXG4gICAgIGluIGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIG9uZSBvZiBvdXIgaW5wdXRzIHdpdGhvdXQgYWxsb2NhdGluZyBhIG5ldyBzdHJpbmcuICopXG5cbiAgbGV0IHNob3J0ZXIgYSBiID0gaWYgbGVuZ3RoIGEgPD0gbGVuZ3RoIGIgdGhlbiBhIGVsc2UgYlxuXG4gIGxldCBzaG9ydGVzdCBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT4gTGlzdC5mb2xkIHJlc3QgfmluaXQ6Zmlyc3QgfmY6c2hvcnRlclxuICA7O1xuXG4gICgqIE91ciBnZW5lcmljIGFjY2Vzc29ycyBmb3IgY29tbW9uIHByZWZpeC9zdWZmaXggYWJzdHJhY3Qgb3ZlciBbZ2V0X3Bvc10sIHdoaWNoIGlzXG4gICAgIGVpdGhlciBbcG9zX2Zyb21fbGVmdF0gb3IgW3Bvc19mcm9tX3JpZ2h0XS4gKilcblxuICBsZXQgcG9zX2Zyb21fbGVmdCAoXyA6IHQpIChpIDogaW50KSA9IGlcbiAgbGV0IHBvc19mcm9tX3JpZ2h0IHQgaSA9IGxlbmd0aCB0IC0gaSAtIDFcblxuICBsZXQgcmVjIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXIgPVxuICAgIGlmIGxlbl9zb19mYXIgPj0gbWF4X2xlblxuICAgIHRoZW4gbWF4X2xlblxuICAgIGVsc2UgaWYgQ2hhci5lcXVhbFxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBhIChnZXRfcG9zIGEgbGVuX3NvX2ZhcikpXG4gICAgICAgICAgICAgICh1bnNhZmVfZ2V0IGIgKGdldF9wb3MgYiBsZW5fc29fZmFyKSlcbiAgICB0aGVuIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6KGxlbl9zb19mYXIgKyAxKVxuICAgIGVsc2UgbGVuX3NvX2ZhclxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyA9XG4gICAgbGV0IG1heF9sZW4gPSBtaW4gKGxlbmd0aCBhKSAobGVuZ3RoIGIpIGluXG4gICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCBsaXN0IH5nZXRfcG9zIH5tYXhfbGVuID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IG1heF9sZW5cbiAgICB8IHNlY29uZCA6OiByZXN0IC0+XG4gICAgICBsZXQgbWF4X2xlbiA9XG4gICAgICAgICgqIFdlIGNhbGwgW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW4gW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhdIHNvXG4gICAgICAgICAgIHRoYXQgW21heF9sZW5dIGxpbWl0cyBvdXIgdHJhdmVyc2FsIG9mIFtmaXJzdF0gYW5kIFtzZWNvbmRdLiAqKVxuICAgICAgICBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgZmlyc3Qgc2Vjb25kIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOjBcbiAgICAgIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBzZWNvbmQgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3BvcyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiAwXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+XG4gICAgICAoKiBQcmVjb21wdXRpbmcgW21heF9sZW5dIGJhc2VkIG9uIFtzaG9ydGVzdCBsaXN0XSBzYXZlcyB1cyB3b3JrIGluIGxvbmdlciBzdHJpbmdzLFxuICAgICAgICAgYXQgdGhlIGNvc3Qgb2YgYW4gZXh0cmEgcGFzcyBvdmVyIHRoZSBzcGluZSBvZiBbbGlzdF0uXG5cbiAgICAgICAgIEZvciBleGFtcGxlLCBpZiB5b3UncmUgbG9va2luZyBmb3IgdGhlIGxvbmdlc3QgcHJlZml4IG9mIHRoZSBzdHJpbmdzOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgbGV0IGxvbmdfYSA9IExpc3QuaW5pdCAxMDAwIH5mOihGbi5jb25zdCAnYScpXG4gICAgICAgICAgICBbIGxvbmdfYTsgbG9uZ19hOyAnYWEnIF1cbiAgICAgICAgIHZ9XG5cbiAgICAgICAgIHRoZSBhcHByb2FjaCBiZWxvdyB3aWxsIGp1c3QgY2hlY2sgdGhlIGZpcnN0IHR3byBjaGFyYWN0ZXJzIG9mIGFsbCB0aGUgc3RyaW5ncy5cbiAgICAgICopXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCAoc2hvcnRlc3QgbGlzdCkgaW5cbiAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgdGhhdCBwcm9kdWNlIGEgc3RyaW5nIGFic3RyYWN0IG92ZXIgW3Rha2VdLCB3aGljaCBpcyBlaXRoZXJcbiAgICAgW3ByZWZpeF0gb3IgW3N1ZmZpeF0uICopXG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljMiBhIGIgfmdldF9wb3MgfnRha2UgPVxuICAgIGxldCBsZW4gPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyBpblxuICAgICgqIFVzZSB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIHN0cmluZ3MsIHNvIHRoYXQgaWYgdGhlIHNob3J0ZXIgb25lIGlzIHRoZSBzaGFyZWRcbiAgICAgICBwcmVmaXgsIFt0YWtlXSB3b24ndCBhbGxvY2F0ZSBhbm90aGVyIHN0cmluZy4gKilcbiAgICB0YWtlIChzaG9ydGVyIGEgYikgbGVuXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljIGxpc3QgfmdldF9wb3MgfnRha2UgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gXCJcIlxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogQXMgd2l0aCBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSwgd2UgYmFzZSBbbWF4X2xlbl0gb24gW3Nob3J0ZXN0IGxpc3RdLiBXZSBhbHNvXG4gICAgICAgICB1c2UgdGhpcyByZXN1bHQgZm9yIFt0YWtlXSwgYmVsb3csIHRvIHBvdGVudGlhbGx5IGF2b2lkIGFsbG9jYXRpbmcgYSBzdHJpbmcuICopXG4gICAgICBsZXQgcyA9IHNob3J0ZXN0IGxpc3QgaW5cbiAgICAgIGxldCBtYXhfbGVuID0gbGVuZ3RoIHMgaW5cbiAgICAgIGlmIG1heF9sZW4gPSAwXG4gICAgICB0aGVuIFwiXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbGVuID1cbiAgICAgICAgICAoKiBXZSBjYWxsIGRpcmVjdGx5IGludG8gW2NvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wXSByYXRoZXIgdGhhblxuICAgICAgICAgICAgIFtjb21tb25fZ2VuZXJpY19sZW5ndGhdIHRvIGF2b2lkIHJlY29tcHV0aW5nIFtzaG9ydGVzdCBsaXN0XS4gKilcbiAgICAgICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gICAgICAgIGluXG4gICAgICAgIHRha2UgcyBsZW4pXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4XG5cbiAgbGV0IGNvbW1vbl9wcmVmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6cHJlZml4IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6c3VmZml4IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeF9sZW5ndGggbGlzdCA9IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDJfbGVuZ3RoIGEgYiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuZW5kXG5cbigqIFRoZXJlIHVzZWQgdG8gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gdGhhdCB3YXMgZmFzdGVyIGZvciB2ZXJ5IHNob3J0IHN0cmluZ3NcbiAgIChwZWFraW5nIGF0IDQwJSBmYXN0ZXIgZm9yIDQtNiBjaGFyIGxvbmcgc3RyaW5ncykuXG4gICBUaGlzIG5ldyBmdW5jdGlvbiBpcyBhcm91bmQgMjAlIGZhc3RlciB0aGFuIHRoZSBkZWZhdWx0IGhhc2ggZnVuY3Rpb24sIGJ1dCBzbG93ZXJcbiAgIHRoYW4gdGhlIHByZXZpb3VzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdGhlIG5ldyBPQ2FtbCBmdW5jdGlvbiBpcyB3ZWxsXG4gICBiZWhhdmVkLCBhbmQgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBsZXNzIGxpa2VseSB0byBkaXZlcmdlIGZyb20gdGhlIGRlZmF1bHQgT0NhbWxcbiAgIGltcGxlbWVudGF0aW9uIGRvZXMsIHdoaWNoIGlzIGEgZGVzaXJhYmxlIHByb3BlcnR5LiAoVGhlIG9ubHkgd2F5IHRvIGF2b2lkIHRoZVxuICAgZGl2ZXJnZW5jZSBpcyB0byBleHBvc2UgdGhlIG1hY3JvIHJlZGVmaW5lZCBpbiBoYXNoX3N0dWJzLmMgaW4gdGhlIGhhc2guaCBoZWFkZXIgb2ZcbiAgIHRoZSBPQ2FtbCBjb21waWxlci4pICopXG5tb2R1bGUgSGFzaCA9IHN0cnVjdFxuICBleHRlcm5hbCBoYXNoIDogc3RyaW5nIC0+IGludCA9IFwiQmFzZV9oYXNoX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5lbmRcblxuKCogW2luY2x1ZGUgSGFzaF0gdG8gbWFrZSB0aGUgW2V4dGVybmFsXSB2ZXJzaW9uIG92ZXJyaWRlIHRoZSBbaGFzaF0gZnJvbVxuICAgW0hhc2hhYmxlLk1ha2VfYmluYWJsZV0sIHNvIHRoYXQgd2UgZ2V0IGEgbGl0dGxlIGJpdCBvZiBhIHNwZWVkdXAgYnkgZXhwb3NpbmcgaXQgYXNcbiAgIGV4dGVybmFsIGluIHRoZSBtbGkuICopXG5sZXQgXyA9IGhhc2hcblxuaW5jbHVkZSBIYXNoXG5cbigqIGZvciBpbnRlcmFjdGl2ZSB0b3AtbGV2ZWxzIC0tIG1vZHVsZXMgZGVyaXZpbmcgZnJvbSBTdHJpbmcgc2hvdWxkIGhhdmUgU3RyaW5nJ3MgcHJldHR5XG4gICBwcmludGVyLiAqKVxubGV0IHBwIHBwZiBzdHJpbmcgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbm1vZHVsZSBFc2NhcGluZyA9IHN0cnVjdFxuICAoKiBJZiB0aGlzIGlzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0byB1cGRhdGUgW2VzY2FwZV0sIHdoaWNoIGF0dGVtcHRzIHRvIGVuc3VyZSBhbGwgdGhlXG4gICAgIGludmFyaWFudHMgY2hlY2tlZCBoZXJlLiAgKilcbiAgbGV0IGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgZnVuYyA9XG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgaWYgTGlzdC5Bc3NvYy5tZW0gZXNjYXBld29ydGh5X21hcCB+ZXF1YWw6Q2hhci5lcXVhbCBlc2NhcGVfY2hhclxuICAgICAgdGhlbiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICBlbHNlIChlc2NhcGVfY2hhciwgZXNjYXBlX2NoYXIpIDo6IGVzY2FwZXdvcnRoeV9tYXBcbiAgICBpblxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgKC0xKSBpblxuICAgIGxldCB2YWxzID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2IGZhbHNlIGluXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gT2sgYXJyXG4gICAgICB8IChjX2Zyb20sIGNfdG8pIDo6IGwgLT5cbiAgICAgICAgbGV0IGssIHYgPVxuICAgICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICAgIHwgYEVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX2Zyb20sIGNfdG9cbiAgICAgICAgICB8IGBVbmVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX3RvLCBjX2Zyb21cbiAgICAgICAgaW5cbiAgICAgICAgaWYgYXJyLihrKSA8PiAtMSB8fCB2YWxzLihDaGFyLnRvX2ludCB2KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgICAgXCJlc2NhcGV3b3J0aHlfbWFwIG5vdCBvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgIFsgXCJjX2Zyb21cIiwgc2V4cF9vZl9jaGFyIGNfZnJvbVxuICAgICAgICAgICAgICAgOyBcImNfdG9cIiwgc2V4cF9vZl9jaGFyIGNfdG9cbiAgICAgICAgICAgICAgIDsgKCBcImVzY2FwZXdvcnRoeV9tYXBcIlxuICAgICAgICAgICAgICAgICAsIHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2ZfY2hhciBzZXhwX29mX2NoYXIpIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgXSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYXJyLihrKSA8LSBDaGFyLnRvX2ludCB2O1xuICAgICAgICAgIHZhbHMuKENoYXIudG9faW50IHYpIDwtIHRydWU7XG4gICAgICAgICAgbG9vcCBsKVxuICAgIGluXG4gICAgbG9vcCBlc2NhcGV3b3J0aHlfbWFwXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBFc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAgKCogY2FsY3VsYXRlIGEgbGlzdCBvZiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpIGZpcnN0LCB0aGUgb3JkZXJcbiAgICAgICAgICAgICAgaXMgZnJvbSB0YWlsIHRvIGhlYWQgKilcbiAgICAgICAgICAgbGV0IHRvX2VzY2FwZV9sZW4gPSByZWYgMCBpblxuICAgICAgICAgICBsZXQgdG9fZXNjYXBlID1cbiAgICAgICAgICAgICBmb2xkaSBzcmMgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyBjIC0+XG4gICAgICAgICAgICAgICBtYXRjaCBlc2NhcGV3b3J0aHkuKENoYXIudG9faW50IGMpIHdpdGhcbiAgICAgICAgICAgICAgIHwgLTEgLT4gYWNjXG4gICAgICAgICAgICAgICB8IG4gLT5cbiAgICAgICAgICAgICAgICAgKCogKGluZGV4IG9mIGNoYXIgdG8gZXNjYXBlICogZXNjYXBlZCBjaGFyKSAqKVxuICAgICAgICAgICAgICAgICBpbmNyIHRvX2VzY2FwZV9sZW47XG4gICAgICAgICAgICAgICAgIChpLCBDaGFyLnVuc2FmZV9vZl9pbnQgbikgOjogYWNjKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBtYXRjaCB0b19lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAoKiBbdG9fZXNjYXBlXSBkaXZpZGUgW3NyY10gdG8gW0xpc3QubGVuZ3RoIHRvX2VzY2FwZSArIDFdIHBpZWNlcyBzZXBhcmF0ZWQgYnlcbiAgICAgICAgICAgICAgICB0aGUgY2hhcnMgdG8gZXNjYXBlLlxuXG4gICAgICAgICAgICAgICAgTGV0cyB0YWtlXG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIGVzY2FwZV9nZW5fZXhuXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGV3b3J0aHlfbWFwOlsoJ2EnLCAnQScpOyAoJ2InLCAnQicpOyAoJ2MnLCAnQycpXVxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBlX2NoYXI6J18nXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgYW5kIGFzc3VtZSB0aGUgc3RyaW5nIHRvIGVzY2FwZSBpc1xuXG4gICAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgICAgdGhlbiBbdG9fZXNjYXBlXSBpcyBbKDExLCAnQycpOyAoNywgJ0InKTsgKDMsICdBJyldLlxuXG4gICAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBbZHN0XSBvZiBsZW5ndGggW2xlbmd0aCBzcmMgKyAzXSB0byBzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICByZXN1bHQsIGNvcHkgcGllY2UgXCIzMzNcIiB0byBbZHN0XSBkaXJlY3RseSwgdGhlbiBjb3B5ICdfJyBhbmQgJ0MnIHRvIFtkc3RdO1xuICAgICAgICAgICAgICAgIHRoZW4gbW92ZSBvbiB0byBuZXh0OyBhZnRlciAzIGl0ZXJhdGlvbnMsIGNvcHkgcGllY2UgXCIwMDBcIiBhbmQgd2UgYXJlIGRvbmUuXG5cbiAgICAgICAgICAgICAgICBGaW5hbGx5IHRoZSByZXN1bHQgd2lsbCBiZVxuXG4gICAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIiAqKVxuICAgICAgICAgICAgIGxldCBzcmNfbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgICAgICAgICAgIGxldCBkc3RfbGVuID0gc3JjX2xlbiArICF0b19lc2NhcGVfbGVuIGluXG4gICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBkc3RfbGVuIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCAoaWR4LCBlc2NhcGVkX2NoYXIpIDo6IHRvX2VzY2FwZSAtPlxuICAgICAgICAgICAgICAgICAoKltpZHhdID0gdGhlIGNoYXIgdG8gZXNjYXBlKilcbiAgICAgICAgICAgICAgICAgKCogdGFrZSBmaXJzdCBpdGVyYXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICAgICAgICAgICAgICAgKCogY2FsY3VsYXRlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAxIGJlY2F1c2Ugd2UgZG9uJ3QgY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMSBpblxuICAgICAgICAgICAgICAgICAoKiBzZXQgdGhlIGRzdF9wb3MgdG8gY29weSB0byAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIsIHNldCBbc3JjX3Bvc10gdG8gW2lkeCArIDFdIHRvIHNraXAgJ2MnICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDEpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMiB0byBjb3B5ICdfJyBhbmQgJ0MnICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDIgaW5cbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCBkc3RfcG9zIGVzY2FwZV9jaGFyO1xuICAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IChkc3RfcG9zICsgMSkgZXNjYXBlZF9jaGFyO1xuICAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX2VzY2FwZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gZmlyc3QgKilcbiAgICAgICAgICAgICBsb29wIHNyY19sZW4gZHN0X2xlbiB0b19lc2NhcGU7XG4gICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuIChlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgZXNjYXBlIH5lc2NhcGV3b3J0aHkgfmVzY2FwZV9jaGFyID1cbiAgICAoKiBGb3IgW2VzY2FwZV9nZW5fZXhuXSwgd2UgZG9uJ3Qga25vdyBob3cgdG8gZml4IGludmFsaWQgZXNjYXBld29ydGh5X21hcCBzbyB3ZSBoYXZlXG4gICAgICAgdG8gcmFpc2UgZXhjZXB0aW9uOyBidXQgaW4gdGhpcyBjYXNlLCB3ZSBrbm93IGhvdyB0byBmaXggZHVwbGljYXRlZCBlbGVtZW50cyBpblxuICAgICAgIGVzY2FwZXdvcnRoeSBsaXN0LCBzbyB3ZSBqdXN0IGZpeCBpdCBpbnN0ZWFkIG9mIHJhaXNpbmcgZXhjZXB0aW9uIHRvIG1ha2UgdGhpc1xuICAgICAgIGZ1bmN0aW9uIGVhc2llciB0byB1c2UuICAqKVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGVzY2FwZXdvcnRoeVxuICAgICAgfD4gTGlzdC5kZWR1cF9hbmRfc29ydCB+Y29tcGFyZTpDaGFyLmNvbXBhcmVcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gYyAtPiBjLCBjKVxuICAgIGluXG4gICAgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBVbmVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICAoKiBDb250aW51ZSB0aGUgZXhhbXBsZSBpbiBbZXNjYXBlX2dlbl9leG5dLCBub3cgd2UgdW5lc2NhcGVcblxuICAgICAgICAgICAgICBcIjAwMF9BMTExX0IyMjJfQzMzM1wiXG5cbiAgICAgICAgICAgICAgYmFjayB0b1xuXG4gICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICBUaGVuIFt0b191bmVzY2FwZV0gaXMgWzE0OyA5OyA0XSwgd2hpY2ggaXMgaW5kZXhlcyBvZiAnXydzLlxuXG4gICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgc3RyaW5nIFtkc3RdIHRvIHN0b3JlIHRoZSByZXN1bHQsIGNvcHkgXCIzMzNcIiB0byBpdCwgdGhlbiBjb3B5XG4gICAgICAgICAgICAgICdjJywgdGhlbiBtb3ZlIG9uIHRvIG5leHQgaXRlcmF0aW9uLiBBZnRlciAzIGl0ZXJhdGlvbnMgY29weSBcIjAwMFwiIGFuZCB3ZSBhcmVcbiAgICAgICAgICAgICAgZG9uZS4gICopXG4gICAgICAgICAgICgqIGluZGV4ZXMgb2YgZXNjYXBlIGNoYXJzICopXG4gICAgICAgICAgIGxldCB0b191bmVzY2FwZSA9XG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzIGFjYyA9XG4gICAgICAgICAgICAgICBpZiBpID49IGxlbmd0aCBzcmNcbiAgICAgICAgICAgICAgIHRoZW4gYWNjXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHNyYyB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMgaW5cbiAgICAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBpbmcgLT4gaSA6OiBhY2NcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGFjYykpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBsb29wIDAgYExpdGVyYWwgW11cbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbWF0Y2ggdG9fdW5lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZScgLT5cbiAgICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5ndGggc3JjIC0gTGlzdC5sZW5ndGggdG9fdW5lc2NhcGUpIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAgKCogW2lkeF0gPSBpbmRleCBvZiBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICAgICgqIHRha2UgMXN0IGl0ZXJhdGlvbiBhcyBleGFtcGxlLCBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAyIHRvXG4gICAgICAgICAgICAgICAgICAgIHNraXAgJ19DJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAyIGluXG4gICAgICAgICAgICAgICAgICgqIHBvaW50IFtkc3RfcG9zXSB0byB0aGUgcG9zaXRpb24gdG8gY29weSBcIjMzM1wiIHRvICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAyKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDEgdG8gY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMSBpblxuICAgICAgICAgICAgICAgICBCeXRlcy5zZXRcbiAgICAgICAgICAgICAgICAgICBkc3RcbiAgICAgICAgICAgICAgICAgICBkc3RfcG9zXG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgc3JjLltpZHggKyAxXSkgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IC0xIC0+IHNyYy5baWR4ICsgMV1cbiAgICAgICAgICAgICAgICAgICAgfCBuIC0+IENoYXIudW5zYWZlX29mX2ludCBuKTtcbiAgICAgICAgICAgICAgICAgKCogdXBkYXRlIFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdICopXG4gICAgICAgICAgICAgICAgIGxvb3AgaWR4IGRzdF9wb3MgdG9fdW5lc2NhcGVcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIGlkeCA8IGxlbmd0aCBzcmMgLSAxXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gKilcbiAgICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICgqIGZvciBlc2NhcGVkIHN0cmluZyBlbmRpbmcgd2l0aCBhbiBlc2NhcGluZyBjaGFyIGxpa2UgXCIwMDBfXCIsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICB0aGUgbGFzdCBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjIC0gMSkgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlJztcbiAgICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIE9yX2Vycm9yLm9rX2V4biAodW5lc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgdW5lc2NhcGUgfmVzY2FwZV9jaGFyID0gdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcDpbXSB+ZXNjYXBlX2NoYXJcblxuICBsZXQgcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IHJlYyBsb29wIHAgY250ID1cbiAgICAgIGlmIHAgPCAwIHx8IENoYXIuKCA8PiApIHN0ci5bcF0gZXNjYXBlX2NoYXIgdGhlbiBjbnQgZWxzZSBsb29wIChwIC0gMSkgKGNudCArIDEpXG4gICAgaW5cbiAgICBsb29wIChwb3MgLSAxKSAwXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgb2RkID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBtb2QgMiA9IDEgaW5cbiAgICBtYXRjaCBvZGQsIENoYXIuZXF1YWwgc3RyLltwb3NdIGVzY2FwZV9jaGFyIHdpdGhcbiAgICB8IHRydWUsICh0cnVlIHwgZmFsc2UpIC0+IGBFc2NhcGVkXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiBgRXNjYXBpbmdcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBjaGVja19ib3VuZCBzdHIgcG9zIGZ1bmN0aW9uX25hbWUgPVxuICAgIGlmIHBvcyA+PSBsZW5ndGggc3RyIHx8IHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCIlczogb3V0IG9mIGJvdW5kc1wiIGZ1bmN0aW9uX25hbWUgKClcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGluZyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBpbmdcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGluZyAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBlZCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBlZFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwZWQgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwaW5nIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9saXRlcmFsIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9saXRlcmFsXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpbmRleF9mcm9tXCI7XG4gICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzID1cbiAgICAgIGlmIGkgPj0gcG9zXG4gICAgICAmJiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgJiYgQ2hhci5lcXVhbCBzdHIuW2ldIGNoYXJcbiAgICAgIHRoZW4gU29tZSBpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGkgPSBpICsgMSBpblxuICAgICAgICBpZiBpID49IGxlbmd0aCBzdHJcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgbG9vcCBpICh1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgc3RhdHVzKSlcbiAgICBpblxuICAgIGxvb3AgcG9zIChlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zKVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuICBsZXQgaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG5cbiAgbGV0IHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJyaW5kZXhfZnJvbVwiO1xuICAgICgqIGlmIHRoZSB0YXJnZXQgY2hhciBpcyB0aGUgc2FtZSBhcyBbZXNjYXBlX2NoYXJdLCB3ZSBoYXZlIG5vIHdheSB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICBlc2NhcGVfY2hhciBpcyBsaXRlcmFsLCBzbyBqdXN0IHJldHVybiBOb25lICopXG4gICAgaWYgQ2hhci5lcXVhbCBjaGFyIGVzY2FwZV9jaGFyXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgcG9zID1cbiAgICAgICAgaWYgcG9zIDwgMFxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGVzY2FwZV9jaGFycyA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgaW5cbiAgICAgICAgICBpZiBlc2NhcGVfY2hhcnMgbW9kIDIgPSAwICYmIENoYXIuZXF1YWwgc3RyLltwb3NdIGNoYXJcbiAgICAgICAgICB0aGVuIFNvbWUgcG9zXG4gICAgICAgICAgZWxzZSBsb29wIChwb3MgLSBlc2NhcGVfY2hhcnMgLSAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIHBvcylcbiAgOztcblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwicmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIGlmIGlzX2VtcHR5IHN0ciB0aGVuIE5vbmUgZWxzZSByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gIGxldCByaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgKCogW3NwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbl0gd29ya3Mgc2ltaWxhcmx5IHRvIFtTdHJpbmcuc3BsaXRfZ2VuXSwgd2l0aCBhblxuICAgICBhZGRpdGlvbmFsIHJlcXVpcmVtZW50OiBvbmx5IHNwbGl0IG9uIGxpdGVyYWwgY2hhcnMsIG5vdCBlc2NhcGluZyBvciBlc2NhcGVkICopXG4gIGxldCBzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b24gPVxuICAgIGxldCBpc19kZWxpbSA9XG4gICAgICBtYXRjaCBvbiB3aXRoXG4gICAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgICAgfCBgY2hhcl9saXN0IGwgLT4gZnVuIGMgLT4gY2hhcl9saXN0X21lbSBsIGNcbiAgICBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyBzdGF0dXMgbGFzdF9wb3MgcG9zID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBMaXN0LnJldiAoc3ViIHN0ciB+cG9zOmxhc3RfcG9zIH5sZW46KGxlbiAtIGxhc3RfcG9zKSA6OiBhY2MpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHN0YXR1cyBpblxuICAgICAgICBpZiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgICAmJiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoocG9zIC0gbGFzdF9wb3MpIGluXG4gICAgICAgICAgbG9vcCAoc3ViX3N0ciA6OiBhY2MpIHN0YXR1cyAocG9zICsgMSkgKHBvcyArIDEpKVxuICAgICAgICBlbHNlIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyAocG9zICsgMSkpXG4gICAgaW5cbiAgICBsb29wIFtdIGBMaXRlcmFsIDAgMFxuICA7O1xuXG4gIGxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxuICBsZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG4gIGxldCBzcGxpdF9hdCBzdHIgcG9zID1cbiAgICBzdWIgc3RyIH5wb3M6MCB+bGVuOnBvcywgc3ViIHN0ciB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggc3RyIC0gcG9zIC0gMSlcbiAgOztcblxuICBsZXQgbHNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAoaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCByc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChyaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCBsc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAoaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG4gIGxldCByc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAocmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuXG4gICgqIFtsYXN0X25vbl9kcm9wX2xpdGVyYWxdIGFuZCBbZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYXJlIGVpdGhlciBib3RoIFtOb25lXSBvciBib3RoXG4gICAgIFtTb21lXS4gSWYgW1NvbWVdLCB0aGVuIHRoZSBmb3JtZXIgaXMgPj0gdGhlIGxhdHRlci4gKilcbiAgbGV0IGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgcmZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKVxuICA7O1xuXG4gIGxldCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICBsZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJ5dGVzIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChieXRlc19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ieXRlcyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBieXRlc19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQnl0ZXMwXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJ5dGVzXCJcbiAgbGV0IHBwIGZtdCB0ID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlU1wiICh0b19zdHJpbmcgdClcbmVuZFxuXG5pbmNsdWRlIFRcblxubW9kdWxlIFRvX2J5dGVzID0gQmxpdC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFQpIChUb19ieXRlcylcblxubW9kdWxlIEZyb21fc3RyaW5nID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIGVuZClcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgbiAwXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIkJ5dGVzLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gc2V0IHQgaSBjKTtcbiAgdFxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgKGkgLSAxKSAodW5zYWZlX2dldCB0IGkgOjogYWNjKVxuICBpblxuICBsb29wIHQgKGxlbmd0aCB0IC0gMSkgW11cbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcbmxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gbWFwaSB0IH5mXG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBwb3MgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzIGkpIHRhcmdldCB0aGVuIHVuc2FmZV9zZXQgcyBpIHJlcGxhY2VtZW50XG4gIGRvbmVcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAwXG4gIHRoZW4gc3RhZ2UgaWdub3JlXG4gIGVsc2UgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgMFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGk6IHJlcGxhY2VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgaWdub3JlXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IHMgaSAoU3RyaW5nLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCAodW5zYWZlX2dldCBzIGkpKSlcbiAgICAgICAgZG9uZSkpXG47O1xuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgY29udGFpbnMgP3BvcyA/bGVuIHQgY2hhciA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbGFzdCA9IHBvcyArIGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIGxhc3RcbiAgICAmJiAoQ2hhci5lcXVhbCAoZ2V0IHQgaSkgY2hhciB8fCBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIjIDEgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gXG50eXBlIHJlc3VsdCA9XG58IE5lZyBvZiBzdHJpbmdcbnwgUG9zIG9mIHN0cmluZ1xuXG4jIDggXCJzcmMvaGV4X2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMjdcXDAwMFxcMDgyXFwwMDBcXDEwNVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyBwYXJzZV9oZXggbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxMzUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAzKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOZWcgYm9keSApXG4jIDEzOSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDE0NSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDIpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE1IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBvcyBib2R5IClcbiMgMTQ5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBjb252ZXJ0X2ZhaWx1cmUgeCBhIGIgdG9fc3RyaW5nID1cbiAgUHJpbnRmLmZhaWx3aXRoZlxuICAgIFwiY29udmVyc2lvbiBmcm9tICVzIHRvICVzIGZhaWxlZDogJXMgaXMgb3V0IG9mIHJhbmdlXCJcbiAgICBhXG4gICAgYlxuICAgICh0b19zdHJpbmcgeClcbiAgICAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBudW1fYml0c19pbnQgPSBTeXMuaW50X3NpemVfaW5fYml0c1xubGV0IG51bV9iaXRzX2ludDMyID0gMzJcbmxldCBudW1fYml0c19pbnQ2NCA9IDY0XG5sZXQgbnVtX2JpdHNfbmF0aXZlaW50ID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50ID0gNjMgfHwgbnVtX2JpdHNfaW50ID0gMzEgfHwgbnVtX2JpdHNfaW50ID0gMzIpXG5sZXQgbWluX2ludDMyID0gQ2FtbC5JbnQzMi5taW5faW50XG5sZXQgbWF4X2ludDMyID0gQ2FtbC5JbnQzMi5tYXhfaW50XG5sZXQgbWluX2ludDY0ID0gQ2FtbC5JbnQ2NC5taW5faW50XG5sZXQgbWF4X2ludDY0ID0gQ2FtbC5JbnQ2NC5tYXhfaW50XG5sZXQgbWluX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm1pbl9pbnRcbmxldCBtYXhfbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQubWF4X2ludFxubGV0IGludF90b19zdHJpbmcgPSBDYW1sLnN0cmluZ19vZl9pbnRcbmxldCBpbnQzMl90b19zdHJpbmcgPSBDYW1sLkludDMyLnRvX3N0cmluZ1xubGV0IGludDY0X3RvX3N0cmluZyA9IENhbWwuSW50NjQudG9fc3RyaW5nXG5sZXQgbmF0aXZlaW50X3RvX3N0cmluZyA9IENhbWwuTmF0aXZlaW50LnRvX3N0cmluZ1xuXG4oKiBpbnQgPC0+IGludDMyICopXG5cbmxldCBpbnRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnRcIiBcImludDMyXCIgaW50X3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDMyXCIgXCJpbnRcIiBpbnQzMl90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfdHJ1bmMgPSBDYW1sLkludDMyLnRvX2ludFxubGV0IGludF90b19pbnQzMl90cnVuYyA9IENhbWwuSW50MzIub2ZfaW50XG5cbmxldCBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX2ludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX2ludF90cnVuYyBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9faW50X3RydW5jIG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX2ludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQzMiBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50MzIgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnRfdG9faW50MzIgeCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50MzJfdG9faW50IHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50MzJfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBpbnRfdG9faW50MzJfdHJ1bmMgeCBlbHNlIGludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbmxldCBpbnQzMl90b19pbnRfZXhuIHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50MzJfdG9faW50X3RydW5jIHggZWxzZSBpbnQzMl90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfaW50XG5sZXQgaW50NjRfdG9faW50X3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludFxubGV0IG5hdGl2ZWludF90b19pbnRfdHJ1bmMgPSBDYW1sLk5hdGl2ZWludC50b19pbnRcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9fbmF0aXZlaW50IEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX25hdGl2ZWludCBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50X3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQzMlwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludDMyX3RvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnQzMlxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGxldCBtaW4gPSBpbnQzMl90b19pbnQ2NCBtaW5faW50MzIgaW5cbiAgbGV0IG1heCA9IGludDMyX3RvX2ludDY0IG1heF9pbnQzMiBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzIgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIFNvbWUgKGludDY0X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gaW50NjRfdG9faW50MzJfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9XG4gIGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnQzMlwiIG5hdGl2ZWludF90b19zdHJpbmdcbjs7XG5cbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPD0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludDMyX3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludDMyXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX3RydW5jID0gQ2FtbC5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBDYW1sLkludDY0LnRvX25hdGl2ZWludFxubGV0IG5hdGl2ZWludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfbmF0aXZlaW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCA9XG4gIGlmIG51bV9iaXRzX2ludDY0IDw9IG51bV9iaXRzX25hdGl2ZWludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IG5hdGl2ZWludF90b19pbnQ2NCBtaW5fbmF0aXZlaW50IGluXG4gICAgbGV0IG1heCA9IG5hdGl2ZWludF90b19pbnQ2NCBtYXhfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBTb21lIChpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgeFxuICB0aGVuIGludDY0X3RvX25hdGl2ZWludF90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IGludDYzICopXG5cbmxldCBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQ2M1wiIGludDY0X3RvX3N0cmluZ1xuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyA9XG4gIGxldCBtaW4gPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1heF9pbnQ2NCAxIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF9maXRfb25faW50NjNfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiAoKSBlbHNlIGludDY0X3RvX2ludDYzX2ZhaWx1cmUgeFxuOztcblxuKCogc3RyaW5nIGNvbnZlcnNpb25zICopXG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgPVxuICBsZXQgaW5wdXRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpbnB1dCBpblxuICBpZiBpbnB1dF9sZW5ndGggPD0gY2hhcnNfcGVyX2RlbGltaXRlclxuICB0aGVuIGlucHV0XG4gIGVsc2UgKFxuICAgIGxldCBoYXNfc2lnbiA9XG4gICAgICBtYXRjaCBpbnB1dC5bMF0gd2l0aFxuICAgICAgfCAnKycgfCAnLScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgbnVtX2RpZ2l0cyA9IGlmIGhhc19zaWduIHRoZW4gaW5wdXRfbGVuZ3RoIC0gMSBlbHNlIGlucHV0X2xlbmd0aCBpblxuICAgIGxldCBudW1fZGVsaW1pdGVycyA9IChudW1fZGlnaXRzIC0gMSkgLyBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IG91dHB1dF9sZW5ndGggPSBpbnB1dF9sZW5ndGggKyBudW1fZGVsaW1pdGVycyBpblxuICAgIGxldCBvdXRwdXQgPSBCeXRlcy5jcmVhdGUgb3V0cHV0X2xlbmd0aCBpblxuICAgIGxldCBpbnB1dF9wb3MgPSByZWYgKGlucHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG91dHB1dF9wb3MgPSByZWYgKG91dHB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gcmVmIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgZmlyc3RfZGlnaXRfcG9zID0gaWYgaGFzX3NpZ24gdGhlbiAxIGVsc2UgMCBpblxuICAgIHdoaWxlICFpbnB1dF9wb3MgPj0gZmlyc3RfZGlnaXRfcG9zIGRvXG4gICAgICBpZiAhbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGRlbGltaXRlcjtcbiAgICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgICBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIDo9IGNoYXJzX3Blcl9kZWxpbWl0ZXIpO1xuICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBpbnB1dC5bIWlucHV0X3Bvc107XG4gICAgICBkZWNyIGlucHV0X3BvcztcbiAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgIGRlY3IgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlclxuICAgIGRvbmU7XG4gICAgaWYgaGFzX3NpZ24gdGhlbiBCeXRlcy5zZXQgb3V0cHV0IDAgaW5wdXQuWzBdO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0cHV0KVxuOztcblxubGV0IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlciA9XG4gIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlcjozXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzIGlucHV0ID0gaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyOidfJ1xubGV0IHNleHBfb2ZfaW50X3N0eWxlID0gU2V4cC5vZl9pbnRfc3R5bGVcblxubW9kdWxlIE1ha2UgKEkgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBvcGVuIElcblxuICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDNcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBzID0gdG9fc3RyaW5nIHQgaW5cbiAgICBTZXhwLkF0b21cbiAgICAgIChtYXRjaCAhc2V4cF9vZl9pbnRfc3R5bGUgd2l0aFxuICAgICAgIHwgYFVuZGVyc2NvcmVzIC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgcyB+Y2hhcnNfcGVyX2RlbGltaXRlciB+ZGVsaW1pdGVyOidfJ1xuICAgICAgIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaGV4IChJIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgICB2YWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgICB2YWwgemVybyA6IHRcbiAgICB2YWwgKCA8ICkgOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBuZWcgOiB0IC0+IHRcbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFRfaGV4ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gSS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoSS5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gNFxuXG4gICAgbGV0IHRvX3N0cmluZycgP2RlbGltaXRlciB0ID1cbiAgICAgIGxldCBtYWtlX3N1ZmZpeCA9XG4gICAgICAgIG1hdGNoIGRlbGltaXRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBJLnRvX3N0cmluZ1xuICAgICAgICB8IFNvbWUgZGVsaW1pdGVyIC0+XG4gICAgICAgICAgZnVuIHQgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAoSS50b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICAgICAgaW5cbiAgICAgIGlmIEkuKCA8ICkgdCBJLnplcm8gdGhlbiBcIi0weFwiIF4gbWFrZV9zdWZmaXggKEkubmVnIHQpIGVsc2UgXCIweFwiIF4gbWFrZV9zdWZmaXggdFxuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nIHQgPSB0b19zdHJpbmcnIHQgP2RlbGltaXRlcjpOb25lXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPSB0b19zdHJpbmcnIHQgfmRlbGltaXRlclxuXG4gICAgbGV0IGludmFsaWQgc3RyID1cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCIlcy5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiBJLm1vZHVsZV9uYW1lIHN0ciAoKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIHN0ciA9XG4gICAgICBJLm9mX3N0cmluZyAoU3RyaW5nLmZpbHRlciBzdHIgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgJ18nKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgICAgbGV0IG1vZHVsZSBMID0gSGV4X2xleGVyIGluXG4gICAgICBsZXQgbGV4ID0gQ2FtbC5MZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgcmVzdWx0ID0gT3B0aW9uLnRyeV93aXRoIChmdW4gKCkgLT4gTC5wYXJzZV9oZXggbGV4KSBpblxuICAgICAgaWYgbGV4LmxleF9jdXJyX3BvcyA9IGxleC5sZXhfYnVmZmVyX2xlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbnZhbGlkIHN0clxuICAgICAgICB8IFNvbWUgKE5lZyBib2R5KSAtPiBJLm5lZyAob2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICAgIHwgU29tZSAoUG9zIGJvZHkpIC0+IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgZWxzZSBpbnZhbGlkIHN0clxuICAgIDs7XG5cbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgSGV4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBUX2hleFxuICAgIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoVF9oZXgpXG4gIGVuZFxuZW5kXG4iLCIoKiBUaGlzIGZpbGUgd2FzIGF1dG9nZW5lcmF0ZWQgYnkgLi4vZ2VuZXJhdGUvZ2VuZXJhdGVfcG93X292ZXJmbG93X2JvdW5kcy5leGUgKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBoYXZlIHRvIHVzZSBJbnQ2NC50b19pbnRfZXhuIGluc3RlYWQgb2YgaW50IGNvbnN0YW50cyB0byBtYWtlXG4gICBzdXJlIHRoYXQgZmlsZSBjYW4gYmUgcHJlcHJvY2Vzc2VkIG9uIDMyLWJpdCBtYWNoaW5lcy4gKilcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSA6IGludDMyID1cbiAgMjE0NzQ4MzY0N2xcblxubGV0IGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDMyIGFycmF5ID1cbiAgW3wgMjE0NzQ4MzY0N2xcbiAgOyAgMjE0NzQ4MzY0N2xcbiAgOyAgNDYzNDBsXG4gIDsgIDEyOTBsXG4gIDsgIDIxNWxcbiAgOyAgNzNsXG4gIDsgIDM1bFxuICA7ICAyMWxcbiAgOyAgMTRsXG4gIDsgIDEwbFxuICA7ICA4bFxuICA7ICA3bFxuICA7ICA1bFxuICA7ICA1bFxuICA7ICA0bFxuICA7ICA0bFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSA6IGludCA9XG4gICgtMSkgbHNyIDFcblxubGV0IGludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQgYXJyYXkgPVxuICBtYXRjaCBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50IHdpdGhcbiAgfCAzMiAtPiBBcnJheS5tYXAgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIH5mOkNhbWwuSW50MzIudG9faW50XG4gIHwgNjMgLT5cbiAgICBbfCBDYW1sLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgIDsgIENhbWwuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgOyAgQ2FtbC5JbnQ2NC50b19pbnQgMjE0NzQ4MzY0N0xcbiAgICA7ICAxNjY0NTEwXG4gICAgOyAgNDYzNDBcbiAgICA7ICA1NDA0XG4gICAgOyAgMTI5MFxuICAgIDsgIDQ2M1xuICAgIDsgIDIxNVxuICAgIDsgIDExOFxuICAgIDsgIDczXG4gICAgOyAgNDlcbiAgICA7ICAzNVxuICAgIDsgIDI3XG4gICAgOyAgMjFcbiAgICA7ICAxN1xuICAgIDsgIDE0XG4gICAgOyAgMTJcbiAgICA7ICAxMFxuICAgIDsgIDlcbiAgICA7ICA4XG4gICAgOyAgN1xuICAgIDsgIDdcbiAgICA7ICA2XG4gICAgOyAgNVxuICAgIDsgIDVcbiAgICA7ICA1XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIHxdXG4gIHwgMzEgLT5cbiAgICBbfCAxMDczNzQxODIzXG4gICAgOyAgMTA3Mzc0MTgyM1xuICAgIDsgIDMyNzY3XG4gICAgOyAgMTAyM1xuICAgIDsgIDE4MVxuICAgIDsgIDYzXG4gICAgOyAgMzFcbiAgICA7ICAxOVxuICAgIDsgIDEzXG4gICAgOyAgMTBcbiAgICA7ICA3XG4gICAgOyAgNlxuICAgIDsgIDVcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICB8XVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW50NjRfdmFsdWUgOiBpbnQ2NCA9XG4gIDQ2MTE2ODYwMTg0MjczODc5MDNMXG5cbmxldCBpbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDIxNDc0ODM2NDdMXG4gIDsgIDE2NjQ1MTBMXG4gIDsgIDQ2MzQwTFxuICA7ICA1NDA0TFxuICA7ICAxMjkwTFxuICA7ICA0NjNMXG4gIDsgIDIxNUxcbiAgOyAgMTE4TFxuICA7ICA3M0xcbiAgOyAgNDlMXG4gIDsgIDM1TFxuICA7ICAyN0xcbiAgOyAgMjFMXG4gIDsgIDE3TFxuICA7ICAxNExcbiAgOyAgMTJMXG4gIDsgIDEwTFxuICA7ICA5TFxuICA7ICA4TFxuICA7ICA3TFxuICA7ICA3TFxuICA7ICA2TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAxTFxuICA7ICAxTFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDY0X3ZhbHVlIDogaW50NjQgPVxuICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuXG5sZXQgaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAzMDM3MDAwNDk5TFxuICA7ICAyMDk3MTUxTFxuICA7ICA1NTEwOExcbiAgOyAgNjIwOExcbiAgOyAgMTQ0OExcbiAgOyAgNTExTFxuICA7ICAyMzRMXG4gIDsgIDEyN0xcbiAgOyAgNzhMXG4gIDsgIDUyTFxuICA7ICAzOExcbiAgOyAgMjhMXG4gIDsgIDIyTFxuICA7ICAxOExcbiAgOyAgMTVMXG4gIDsgIDEzTFxuICA7ICAxMUxcbiAgOyAgOUxcbiAgOyAgOExcbiAgOyAgN0xcbiAgOyAgN0xcbiAgOyAgNkxcbiAgOyAgNkxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMUxcbiAgfF1cblxubGV0IGludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAtMzAzNzAwMDQ5OUxcbiAgOyAgLTIwOTcxNTFMXG4gIDsgIC01NTEwOExcbiAgOyAgLTYyMDhMXG4gIDsgIC0xNDQ4TFxuICA7ICAtNTExTFxuICA7ICAtMjM0TFxuICA7ICAtMTI3TFxuICA7ICAtNzhMXG4gIDsgIC01MkxcbiAgOyAgLTM4TFxuICA7ICAtMjhMXG4gIDsgIC0yMkxcbiAgOyAgLTE4TFxuICA7ICAtMTVMXG4gIDsgIC0xM0xcbiAgOyAgLTExTFxuICA7ICAtOUxcbiAgOyAgLThMXG4gIDsgIC03TFxuICA7ICAtN0xcbiAgOyAgLTZMXG4gIDsgIC02TFxuICA7ICAtNUxcbiAgOyAgLTVMXG4gIDsgIC01TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0xTFxuICB8XVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgbmVnYXRpdmVfZXhwb25lbnQgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiZXhwb25lbnQgY2FuIG5vdCBiZSBuZWdhdGl2ZVwiICgpXG5sZXQgb3ZlcmZsb3cgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiaW50ZWdlciBvdmVyZmxvdyBpbiBwb3dcIiAoKVxuXG4oKiBUbyBpbXBsZW1lbnQgW2ludDY0X3Bvd10sIHdlIHVzZSBDIGNvZGUgcmF0aGVyIHRoYW4gT0NhbWwgdG8gZWxpbWluYXRlIGFsbG9jYXRpb24uICopXG5leHRlcm5hbCBpbnRfbWF0aF9pbnRfcG93IDogaW50IC0+IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3BvdyA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViXCJcblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDYW1sLkludDY0XG5cbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZW5kXG5cbigqIHdlIGRvbid0IGRvIFthYnNdIGluIGludDY0IGNhc2UgdG8gYXZvaWQgYWxsb2NhdGlvbiAqKVxubGV0IGludDY0X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIChiYXNlID4gMUwgfHwgYmFzZSA8IC0xTClcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCAoYmFzZSA+PSAwTFxuICAgICAgICAgICYmIGJhc2UgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKVxuICAgICAgfHwgKGJhc2UgPCAwTFxuICAgICAgICAgICYmIGJhc2UgPCBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50NjRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbmxldCBpbnQ2M19wb3dfb25faW50NjQgYmFzZSBleHBvbmVudCA9XG4gIGxldCBvcGVuIEludDY0X3dpdGhfY29tcGFyaXNvbnMgaW5cbiAgaWYgZXhwb25lbnQgPCAwTCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFMXG4gICYmIChleHBvbmVudCA+IDYzTFxuICAgICAgfHwgYWJzIGJhc2VcbiAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBzaWdcbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBGbG9hdGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgU3RyaW5nYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAqICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAvICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCB+LSApIDogdCAtPiB0XG5cbiAgaW5jbHVkZSBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgb2ZfaW50X2V4biA6IGludCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuZW5kXG5cbm1vZHVsZSBNYWtlIChYIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG9wZW4gWFxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IFgucmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0IG9uZSA9IG9mX2ludF9leG4gMVxuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICAoKiogZmxvYXQgZGl2aXNpb24gb2YgaW50ZWdlcnMgKilcbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBsZXQgcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID0gaSAtIChpICUgbW9kdWx1cylcblxuICBsZXQgcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IGkgJSBtb2R1bHVzIGluXG4gICAgaWYgcmVtYWluZGVyID0gemVybyB0aGVuIGkgZWxzZSBpICsgbW9kdWx1cyAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIGlmIGkgPSB6ZXJvXG4gICAgdGhlbiB6ZXJvXG4gICAgZWxzZSBpZiBpID4gemVyb1xuICAgIHRoZW4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIGVsc2Ugcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcblxuICBsZXQgcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBsZXQgbW9kdWx1c19taW51c19yZW1haW5kZXIgPSBtb2R1bHVzIC0gcmVtYWluZGVyIGluXG4gICAgaWYgbW9kdWx1c19taW51c19yZW1haW5kZXIgPD0gcmVtYWluZGVyXG4gICAgdGhlbiBpICsgbW9kdWx1c19taW51c19yZW1haW5kZXJcbiAgICBlbHNlIGkgLSByZW1haW5kZXJcbiAgOztcblxuICBsZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqIEMgc3R1YiBmb3IgaW50IHBvcGNvdW50IHRvIHVzZSB0aGUgUE9QQ05UIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG5leHRlcm5hbCBpbnRfcG9wY291bnQgOiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudFwiIFtAQG5vYWxsb2NdXG5cbigqIFRvIG1haW50YWluIGphdmFzY3JpcHQgY29tcGF0aWJpbGl0eSBhbmQgZW5hYmxlIHVuYm94aW5nLCB3ZSBpbXBsZW1lbnQgcG9wY291bnQgaW5cbiAgIE9DYW1sIHJhdGhlciB0aGFuIHVzZSBDIHN0dWJzLiBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb206XG4gICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYW1taW5nX3dlaWdodCNFZmZpY2llbnRfaW1wbGVtZW50YXRpb24gKilcbmxldCBpbnQ2NF9wb3Bjb3VudCA9XG4gIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgbGV0ICggKyApID0gYWRkIGluXG4gIGxldCAoIC0gKSA9IHN1YiBpblxuICBsZXQgKCAqICkgPSBtdWwgaW5cbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGluXG4gIGxldCAoIGxhbmQgKSA9IGxvZ2FuZCBpblxuICBsZXQgbTEgPSAweDU1NTU1NTU1NTU1NTU1NTVMIGluXG4gICgqIDBiMDEwMTAxMDEuLi4gKilcbiAgbGV0IG0yID0gMHgzMzMzMzMzMzMzMzMzMzMzTCBpblxuICAoKiAwYjAwMTEwMDExLi4uICopXG4gIGxldCBtNCA9IDB4MGYwZjBmMGYwZjBmMGYwZkwgaW5cbiAgKCogMGIwMDAwMTExMS4uLiAqKVxuICBsZXQgaDAxID0gMHgwMTAxMDEwMTAxMDEwMTAxTCBpblxuICAoKiAxIGJpdCBzZXQgcGVyIGJ5dGUgKilcbiAgZnVuIFtAaW5saW5lXSB4IC0+XG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IHBhaXIgb2YgYml0cyAqKVxuICAgIGxldCB4ID0geCAtICgoeCBsc3IgMSkgbGFuZCBtMSkgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgNCBiaXRzICopXG4gICAgbGV0IHggPSAoeCBsYW5kIG0yKSArICgoeCBsc3IgMikgbGFuZCBtMikgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgYnl0ZSAqKVxuICAgIGxldCB4ID0gKHggKyAoeCBsc3IgNCkpIGxhbmQgbTQgaW5cbiAgICAoKiBzdW0gdGhlIGJpdCBjb3VudHMgaW4gdGhlIHRvcCBieXRlIGFuZCBzaGlmdCBpdCBkb3duICopXG4gICAgdG9faW50ICgoeCAqIGgwMSkgbHNyIDU2KVxuOztcblxubGV0IGludDMyX3BvcGNvdW50ID1cbiAgKCogT24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXMgZmFzdGVyIHRoYW4gaW1wbGVtZW50aW5nIHVzaW5nIFtpbnQzMl0gYXJpdGhtZXRpYy4gKilcbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZkwgaW5cbiAgZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChDYW1sLkludDY0LmxvZ2FuZCAoQ2FtbC5JbnQ2NC5vZl9pbnQzMiB4KSBtYXNrKVxuOztcblxubGV0IG5hdGl2ZWludF9wb3Bjb3VudCA9XG4gIG1hdGNoIENhbWwuTmF0aXZlaW50LnNpemUgd2l0aFxuICB8IDMyIC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQzMl9wb3Bjb3VudCAoQ2FtbC5OYXRpdmVpbnQudG9faW50MzIgeClcbiAgfCA2NCAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKENhbWwuSW50NjQub2ZfbmF0aXZlaW50IHgpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2lnbjBcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFNpZ24wKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTEuXG4gIHwgWmVybyAtPiAwLlxuICB8IFBvcyAtPiAxLlxuOztcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9IG9mX2ludCAodG9faW50IHQgKiB0b19pbnQgdCcpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGF0IHRoZSBlbmQsIGFmdGVyIGFueVxuICAgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc29cbiAgIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpc1xuICAgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnRfaW50ZlxuaW5jbHVkZSBJbnQwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSB4IHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgeCB5XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICB0cnkgb2Zfc3RyaW5nIHMgd2l0aFxuICAgIHwgXyAtPiBQcmludGYuZmFpbHdpdGhmIFwiSW50Lm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuZW5kXG5cbmxldCBudW1fYml0cyA9IEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHRvX2Zsb2F0ID0gQ2FtbC5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBDYW1sLmludF9vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBDYW1sLmludF9vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIleFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyX3RydW5jIDogaW50MzIgLT4gdCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9pbnQ2NF90cnVuYyA6IGludDY0IC0+IHQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcblxubGV0IHByZWQgaSA9IGkgLSAxXG5sZXQgc3VjYyBpID0gaSArIDFcbmxldCB0b19pbnQgaSA9IGlcbmxldCB0b19pbnRfZXhuID0gdG9faW50XG5sZXQgb2ZfaW50IGkgPSBpXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IG1heF92YWx1ZSA9IENhbWwubWF4X2ludFxubGV0IG1pbl92YWx1ZSA9IENhbWwubWluX2ludFxubGV0IG1heF92YWx1ZV8zMF9iaXRzID0gMHgzRkZGX0ZGRkZcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgb2ZfaW50MzJfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50MzIgPSBDb252LmludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCB0b19pbnQ2NCA9IENvbnYuaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgYWJzIHggPSBhYnMgeFxuXG4oKiBub3RlIHRoYXQgcmVtIGlzIG5vdCBzYW1lIGFzICUgKilcbmxldCByZW0gYSBiID0gYSBtb2QgYlxubGV0IGluY3IgPSBDYW1sLmluY3JcbmxldCBkZWNyID0gQ2FtbC5kZWNyXG5sZXQgc2hpZnRfcmlnaHQgYSBiID0gYSBhc3IgYlxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYSBiID0gYSBsc3IgYlxubGV0IHNoaWZ0X2xlZnQgYSBiID0gYSBsc2wgYlxubGV0IGJpdF9ub3QgYSA9IGxub3QgYVxubGV0IGJpdF9vciBhIGIgPSBhIGxvciBiXG5sZXQgYml0X2FuZCBhIGIgPSBhIGxhbmQgYlxubGV0IGJpdF94b3IgYSBiID0gYSBseG9yIGJcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludF9wb3dcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCAtIDEgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggKyAxXG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4IC0gKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCAoeCAtIDEpID0gMFxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoKiBOb3RlIHRoYXQgd2UgcGFzcyB0aGUgdGFnZ2VkIGludCBoZXJlLiBTZWUgaW50X21hdGhfc3R1YnMuYyBmb3IgZGV0YWlscyBvbiB3aHlcbiAgICAgICAgICB0aGlzIGlzIGNvcnJlY3QuICopXG4gICAgaW50XG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50X2Nsel91bnRhZ2dlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludFtAdW50YWdnZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jdHpfdW50YWdnZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBpZiBpID0gMSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoaSAtIDEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBzaWduID0gU2lnbi5vZl9pbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludF9wb3Bjb3VudFxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG4gIGV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuICBleHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbiAgZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG4gIGV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogdCAtPiB0ID0gXCIlbmVnaW50XCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIG1vZHVsZSBGID0gSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBGXG5cbiAgZXh0ZXJuYWwgYnN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcblxuICAoKiBUaGVzZSBpbmxpbmVkIHZlcnNpb25zIG9mICglKSwgKC8lKSwgYW5kICgvLykgcGVyZm9ybSBiZXR0ZXIgdGhhbiB0aGVpciBmdW5jdG9yaXplZFxuICAgICBjb3VudGVycGFydHMgaW4gW0ZdIChzZWUgYmVuY2htYXJrcyBiZWxvdykuXG5cbiAgICAgVGhlIHJlYXNvbiB0aGVzZSBmdW5jdGlvbnMgYXJlIGlubGluZWQgaW4gW0ludF0gYnV0IG5vdCBpbiBhbnkgb2YgdGhlIG90aGVyIGludGVnZXJcbiAgICAgbW9kdWxlcyBpcyB0aGF0IHRoZXkgZXhpc3RlZCBpbiBbSW50XSBhbmQgW0ludF0gYWxvbmUgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZlxuICAgICB0aGUgW0ludF9tYXRoLk1ha2VdIGZ1bmN0b3IsIGFuZCB3ZSBkaWRuJ3Qgd2FudCB0byBkZWdyYWRlIHRoZWlyIHBlcmZvcm1hbmNlLlxuXG4gICAgIFdlIHdvbid0IHByZS1lbXB0aXZlbHkgZG8gdGhlIHNhbWUgZm9yIG5ldyBmdW5jdGlvbnMsIHVubGVzcyBzb21lb25lIGNhcmVzLCBvbiBhIGNhc2VcbiAgICAgYnkgY2FzZSBmYXNoaW9uLiAgKilcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gcmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuICBleHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG4gIGV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG4gIGxldCBsbm90ID0gbG5vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG4gIGV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG4gIGV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnRdIGFuZCBbSW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE9fRiA9IE8uRlxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBpbmNsdWRpbmcgZnVuY3RvclxuICAgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIFVjaGFyMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhclwiXG4gIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gSGFzaC5mb2xkX2ludCBzdGF0ZSAodG9faW50IHQpXG4gIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGxldCB0b19zdHJpbmcgdCA9IFByaW50Zi5zcHJpbnRmIFwiVSslMDRYXCIgKHRvX2ludCB0KVxuXG4gICgqIERvIG5vdCBhY3R1YWxseSBleHBvcnQgdGhpcy4gU2VlIGRpc2N1c3Npb24gaW4gdGhlIC5tbGkgKilcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IENhbWwuU2NhbmYuc3NjYW5mIHMgXCJVKyVYXCIgKGZ1biBpIC0+IFVjaGFyMC5vZl9pbnQgaSkgd2l0aFxuICAgICAgIHwgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG9mIHRoZSBmb3JtIFUrWFhYWCBuZWVkZWRcIiBzZXhwKVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGludF9pc19zY2FsYXIgPSBpc192YWxpZFxuXG5sZXQgc3VjY19leG4gYyA9XG4gIHRyeSBVY2hhcjAuc3VjYyBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5zdWNjX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBzdWNjIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnN1Y2MgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgcHJlZF9leG4gYyA9XG4gIHRyeSBVY2hhcjAucHJlZCBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5wcmVkX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBwcmVkIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnByZWQgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgb2Zfc2NhbGFyIGkgPSBpZiBpbnRfaXNfc2NhbGFyIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2Zfc2NhbGFyX2V4biBpID1cbiAgaWYgaW50X2lzX3NjYWxhciBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIub2ZfaW50X2V4biBnb3QgYSBpbnZhbGlkIFVuaWNvZGUgc2NhbGFyIHZhbHVlOiAlMDRYXCIgaSAoKVxuOztcblxubGV0IHRvX3NjYWxhciB0ID0gVWNoYXIwLnRvX2ludCB0XG5sZXQgdG9fY2hhciBjID0gaWYgaXNfY2hhciBjIHRoZW4gU29tZSAodW5zYWZlX3RvX2NoYXIgYykgZWxzZSBOb25lXG5cbmxldCB0b19jaGFyX2V4biBjID1cbiAgaWYgaXNfY2hhciBjXG4gIHRoZW4gdW5zYWZlX3RvX2NoYXIgY1xuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLnRvX2NoYXJfZXhuIGdvdCBhIG5vbiBsYXRpbi0xIGNoYXJhY3RlcjogVSslMDRYXCIgKHRvX2ludCBjKSAoKVxuOztcblxubGV0IHV0ZjhfYnl0ZV9sZW5ndGggdWNoYXIgPVxuICBsZXQgY29kZXBvaW50ID0gdG9fc2NhbGFyIHVjaGFyIGluXG4gIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHg4MFxuICB0aGVuIDFcbiAgZWxzZSBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4ODAwXG4gIHRoZW4gMlxuICBlbHNlIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHgxMDAwMFxuICB0aGVuIDNcbiAgZWxzZSA0XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdiKSB0ID0gVCA6ICgnYSwgJ2EpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDAzXyBiX18wMDRfKVxuICAgICAgOiAgKChhX18wMDNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMDNfLCBiX18wMDRfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gVCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCJcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmxldCByZWZsID0gVFxubGV0IHN5bSAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGIsIGEpIHQgPSBUXG5sZXQgdHJhbnMgKHR5cGUgYSBiIGMpIChUIDogKGEsIGIpIHQpIChUIDogKGIsIGMpIHQpIDogKGEsIGMpIHQgPSBUXG5sZXQgY29udiAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIChhIDogYSkgOiBiID0gYVxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuXG5tb2R1bGUgTGlmdDIgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpXG4gICAgOiAoKGExLCBhMikgWC50LCAoYjEsIGIyKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbm1vZHVsZSBMaWZ0MyAoWCA6IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyLCAnYTMpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIgYTMgYjMpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSAoVCA6IChhMywgYjMpIHQpXG4gICAgOiAoKGExLCBhMiwgYTMpIFgudCwgKGIxLCBiMiwgYjMpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubGV0IGRldHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSAqIGEyLCBiMSAqIGIyKSB0KSA6IChhMSwgYjEpIHQgKiAoYTIsIGIyKSB0ID1cbiAgVCwgVFxuOztcblxubGV0IHR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIDogKGExICogYTIsIGIxICogYjIpIHQgPSBUXG5cbm1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgc3RyaXAgOiAoJ2EgdCwgJ2IgdCkgZXF1YWwgLT4gKCdhLCAnYikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gIHR5cGUgKCdhMSwgJ2EyKSB0XG5cbiAgdmFsIHN0cmlwIDogKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBlcXVhbCAtPiAoJ2ExLCAnYjEpIGVxdWFsICogKCdhMiwgJ2IyKSBlcXVhbFxuZW5kXG5cbm1vZHVsZSBDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHkgKE0xIDogSW5qZWN0aXZlKSAoTTIgOiBJbmplY3RpdmUpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudFxuXG4gIGxldCBzdHJpcCBlID0gTTEuc3RyaXAgKE0yLnN0cmlwIGUpXG5lbmRcblxubW9kdWxlIElkID0gc3RydWN0XG4gIG1vZHVsZSBVaWQgPSBJbnRcblxuICBtb2R1bGUgV2l0bmVzcyA9IHN0cnVjdFxuICAgIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgXyB0ID0gLi5cbiAgICAgIHR5cGUgdHlwZV93aXRuZXNzX2ludCA9IFsgYHR5cGVfd2l0bmVzcyBvZiBpbnQgXSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgbGV0IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludCA9XG4gICAgICAgIChmdW4gKGB0eXBlX3dpdG5lc3Mgdl9fMDA1XykgLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidHlwZV93aXRuZXNzXCI7IHNleHBfb2ZfaW50IHZfXzAwNV8gXVxuICAgICAgICAgICA6IHR5cGVfd2l0bmVzc19pbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgOztcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgbGV0IHNleHBfb2ZfdCBfc2V4cF9vZl9hIHQgPVxuICAgICAgICBgdHlwZV93aXRuZXNzXG4gICAgICAgICAgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCB0KSlcbiAgICAgICAgfD4gc2V4cF9vZl90eXBlX3dpdG5lc3NfaW50XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIF8gS2V5LnQgKz0gS2V5IDogdCBLZXkudFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICBsZXQgc2V4cF9vZl90ICh0eXBlIGEpIHNleHBfb2ZfYSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgTS5LZXkgfD4gS2V5LnNleHBfb2ZfdCBzZXhwX29mX2FcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSB0KSAoKSA9XG4gICAgICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcbiAgICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdWlkICh0eXBlIGEpIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgICBDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgTS5LZXkpXG4gICAgOztcblxuICAgICgqIFdlIHdhbnQgYSBjb25zdGFudCBhbGxvY2F0ZWQgb25jZSB0aGF0IFtzYW1lXSBjYW4gcmV0dXJuIHdoZW5ldmVyIGl0IGdldHMgdGhlIHNhbWVcbiAgICAgICB3aXRuZXNzZXMuICBJZiB3ZSB3cml0ZSB0aGUgY29uc3RhbnQgaW5zaWRlIHRoZSBib2R5IG9mIFtzYW1lXSwgdGhlIG5hdGl2ZS1jb2RlXG4gICAgICAgY29tcGlsZXIgd2lsbCBkbyB0aGUgcmlnaHQgdGhpbmcgYW5kIGxpZnQgaXQgb3V0LiAgQnV0IGZvciBjbGFyaXR5IGFuZCByb2J1c3RuZXNzLFxuICAgICAgIHdlIGRvIGl0IG91cnNlbHZlcy4gKilcbiAgICBsZXQgc29tZV90ID0gU29tZSBUXG5cbiAgICBsZXQgc2FtZSAodHlwZSBhIGIpIChhIDogYSB0KSAoYiA6IGIgdCkgOiAoYSwgYikgZXF1YWwgb3B0aW9uID1cbiAgICAgIGxldCBtb2R1bGUgQSA9ICh2YWwgYSA6IFMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBCID0gKHZhbCBiIDogUyB3aXRoIHR5cGUgdCA9IGIpIGluXG4gICAgICBtYXRjaCBBLktleSB3aXRoXG4gICAgICB8IEIuS2V5IC0+IHNvbWVfdFxuICAgICAgfCBfIC0+IE5vbmVcbiAgICA7O1xuICBlbmRcblxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyB3aXRuZXNzIDogJ2EgV2l0bmVzcy50XG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgOyB0b19zZXhwIDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgXyB7IHdpdG5lc3M7IG5hbWU7IHRvX3NleHAgfSA6IFNleHAudCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gQXRvbSBuYW1lXG4gICAgZWxzZVxuICAgICAgTGlzdFxuICAgICAgICBbIExpc3QgWyBBdG9tIFwibmFtZVwiOyBBdG9tIG5hbWUgXVxuICAgICAgICA7IExpc3QgWyBBdG9tIFwid2l0bmVzc1wiOyB3aXRuZXNzIHw+IFdpdG5lc3Muc2V4cF9vZl90IHRvX3NleHAgXVxuICAgICAgICBdXG4gIDs7XG5cbiAgbGV0IHRvX3NleHAgdCA9IHQudG9fc2V4cFxuICBsZXQgbmFtZSB0ID0gdC5uYW1lXG4gIGxldCBjcmVhdGUgfm5hbWUgdG9fc2V4cCA9IHsgd2l0bmVzcyA9IFdpdG5lc3MuY3JlYXRlICgpOyBuYW1lOyB0b19zZXhwIH1cbiAgbGV0IHVpZCB0ID0gV2l0bmVzcy51aWQgdC53aXRuZXNzXG4gIGxldCBoYXNoIHQgPSB1aWQgdFxuICBsZXQgaGFzaF9mb2xkX3QgcyB0ID0gaGFzaF9mb2xkX2ludCBzICh1aWQgdClcbiAgbGV0IHNhbWVfd2l0bmVzcyB0MSB0MiA9IFdpdG5lc3Muc2FtZSB0MS53aXRuZXNzIHQyLndpdG5lc3NcbiAgbGV0IHNhbWUgdDEgdDIgPSBPcHRpb24uaXNfc29tZSAoc2FtZV93aXRuZXNzIHQxIHQyKVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIHQxIHQyID1cbiAgICBtYXRjaCBzYW1lX3dpdG5lc3MgdDEgdDIgd2l0aFxuICAgIHwgU29tZSB3IC0+IHdcbiAgICB8IE5vbmUgLT5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIlR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biBnb3QgZGlmZmVyZW50IGlkc1wiXG4gICAgICAgICAgIFsgKCBcIlwiXG4gICAgICAgICAgICAgLCBzZXhwX29mX3BhaXIgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHQxLCB0MilcbiAgICAgICAgICAgICApXG4gICAgICAgICAgIF0pXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogWydhIENoZWFwX29wdGlvbi50XSBpcyBsaWtlIFsnYSBvcHRpb25dLCBidXQgaXQgZG9lc24ndCBib3ggW3NvbWUgX10gdmFsdWVzLlxuXG4gICAgVGhlcmUgYXJlIHNldmVyYWwgdGhpbmdzIHRoYXQgYXJlIHVuc2FmZSBhYm91dCBpdDpcblxuICAgIC0gW2Zsb2F0IHQgYXJyYXldIChvciBhbnkgYXJyYXktYmFja2VkIGNvbnRhaW5lcikgaXMgbm90IG1lbW9yeS1zYWZlXG4gICAgICBiZWNhdXNlIGZsb2F0IGFycmF5IG9wdGltaXphdGlvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB1bmJveGVkIG9wdGlvblxuICAgICAgb3B0aW1pemF0aW9uLiBZb3UgaGF2ZSB0byB1c2UgW1VuaWZvcm1fYXJyYXkudF0gaW5zdGVhZCBvZiBbYXJyYXldLlxuXG4gICAgLSBOZXN0ZWQgb3B0aW9ucyAoWydhIHQgdF0pIGRvbid0IHdvcmsuIFRoZXkgYXJlIGJlbGlldmVkIHRvIGJlXG4gICAgICBtZW1vcnktc2FmZSwgYnV0IG5vdCBwYXJhbWV0cmljLlxuXG4gICAgLSBBIHJlY29yZCB3aXRoIFtmbG9hdCB0XXMgaW4gaXQgc2hvdWxkIGJlIHNhZmUsIGJ1dCBpdCdzIG9ubHkgW3RdIGJlaW5nXG4gICAgICBhYnN0cmFjdCB0aGF0IGdpdmVzIHlvdSBzYWZldHkuIElmIHRoZSBjb21waWxlciB3YXMgc21hcnQgZW5vdWdoIHRvIHBlZWtcbiAgICAgIHRocm91Z2ggdGhlIG1vZHVsZSBzaWduYXR1cmUgdGhlbiBpdCBjb3VsZCBkZWNpZGUgdG8gY29uc3RydWN0IGEgZmxvYXRcbiAgICAgIGFycmF5IGluc3RlYWQuICopXG5tb2R1bGUgQ2hlYXBfb3B0aW9uID0gc3RydWN0XG4gICgqIFRoaXMgaXMgdGFrZW4gZnJvbSBjb3JlLiBSYXRoZXIgdGhhbiBleHBvc2UgaXQgaW4gdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb2YgYmFzZSwganVzdFxuICAgICBrZWVwIGEgY29weSBhcm91bmQgaGVyZS4gKilcbiAgbGV0IHBoeXNfc2FtZSAodHlwZSBhIGIpIChhIDogYSkgKGIgOiBiKSA9IHBoeXNfZXF1YWwgYSAoQ2FtbC5PYmoubWFnaWMgYiA6IGEpXG5cbiAgbW9kdWxlIFQwIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbm9uZSA6IF8gdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBpc19ub25lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfc29tZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgdmFsdWVfdW5zYWZlIDogJ2EgdCAtPiAnYVxuICAgIHZhbCBpdGVyX3NvbWUgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSArJ2EgdFxuXG4gICAgKCogQmVpbmcgYSBwb2ludGVyLCBubyBvbmUgb3V0c2lkZSB0aGlzIG1vZHVsZSBjYW4gY29uc3RydWN0IGEgdmFsdWUgdGhhdCBpc1xuICAgICAgIFtwaHlzX3NhbWVdIGFzIHRoaXMgb25lLlxuXG4gICAgICAgSXQgd291bGQgYmUgc2ltcGxlciB0byB1c2UgdGhpcyB2YWx1ZSBhcyBbbm9uZV0sIGJ1dCB3ZSB1c2UgYW4gaW1tZWRpYXRlIGluc3RlYWRcbiAgICAgICBiZWNhdXNlIGl0IGxldHMgdXMgYXZvaWQgY2FtbF9tb2RpZnkgd2hlbiBzZXR0aW5nIHRvIFtub25lXSwgbWFraW5nIGNlcnRhaW5cbiAgICAgICBiZW5jaG1hcmtzIHNpZ25pZmljYW50bHkgZmFzdGVyIChlLmcuIC4uL2JlbmNoL2FycmF5X3F1ZXVlLmV4ZSkuXG5cbiAgICAgICB0aGlzIGNvZGUgaXMgZHVwbGljYXRlZCBpbiBNb3B0aW9uLCBhbmQgaWYgd2UgZmluZCB5ZXQgYW5vdGhlciBwbGFjZSB3aGVyZSB3ZSB3YW50XG4gICAgICAgaXQgd2Ugc2hvdWxkIHJlY29uc2lkZXIgbWFraW5nIGl0IHNoYXJlZC4gKilcbiAgICBsZXQgbm9uZV9zdWJzdGl0dXRlIDogXyB0ID0gQ2FtbC5PYmoub2JqIChDYW1sLk9iai5uZXdfYmxvY2sgQ2FtbC5PYmouYWJzdHJhY3RfdGFnIDEpXG5cbiAgICBsZXQgbm9uZSA6IF8gdCA9XG4gICAgICAoKiBUaGUgbnVtYmVyIHdhcyBwcm9kdWNlZCBieVxuICAgICAgICAgWzwgL2Rldi91cmFuZG9tIHRyIC1jIC1kICcxMjM0NTY3ODkwYWJjZGVmJyB8IGhlYWQgLWMgMTZdLlxuXG4gICAgICAgICBUaGUgaWRlYSBpcyB0aGF0IGEgcmFuZG9tIG51bWJlciB3aWxsIGhhdmUgbG93ZXIgcHJvYmFiaWxpdHkgdG8gY29sbGlkZSB3aXRoXG4gICAgICAgICBhbnl0aGluZyB0aGFuIGFueSBudW1iZXIgd2UgY2FuIGNob29zZSBvdXJzZWx2ZXMuXG5cbiAgICAgICAgIFdlIGFyZSB1c2luZyBhIHBvbHltb3JwaGljIHZhcmlhbnQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyIGNvbnN0YW50IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgIGlzIGEgY29tcGlsZXIgYnVnIHdoZXJlIGl0IHdyb25nbHkgYXNzdW1lcyB0aGF0IHRoZSByZXN1bHQgb2YgW2lmIF8gdGhlbiBjIGVsc2VcbiAgICAgICAgIHldIGlzIG5vdCBhIHBvaW50ZXIgaWYgW2NdIGlzIGFuIGludGVnZXIgY29tcGlsZS10aW1lIGNvbnN0YW50LiAgVGhpcyBpcyBiZWluZ1xuICAgICAgICAgZml4ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL3B1bGwvNTU1LiAgVGhlIFwibWVtb3J5IGNvcnJ1cHRpb25cIiB0ZXN0XG4gICAgICAgICBiZWxvdyBkZW1vbnN0cmF0ZXMgdGhlIGlzc3VlLiAgKilcbiAgICAgIENhbWwuT2JqLm1hZ2ljIGB4NmU4ZWUzNDc4ZTFkNzQ0OVxuICAgIDs7XG5cbiAgICBsZXQgaXNfbm9uZSB4ID0gcGh5c19lcXVhbCB4IG5vbmVcbiAgICBsZXQgaXNfc29tZSB4ID0gbm90IChwaHlzX2VxdWFsIHggbm9uZSlcblxuICAgIGxldCBzb21lICh0eXBlIGEpICh4IDogYSkgOiBhIHQgPVxuICAgICAgaWYgcGh5c19zYW1lIHggbm9uZSB0aGVuIG5vbmVfc3Vic3RpdHV0ZSBlbHNlIENhbWwuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX3Vuc2FmZSAodHlwZSBhKSAoeCA6IGEgdCkgOiBhID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgeCBub25lX3N1YnN0aXR1dGUgdGhlbiBDYW1sLk9iai5tYWdpYyBub25lIGVsc2UgQ2FtbC5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfZXhuIHggPVxuICAgICAgaWYgaXNfc29tZSB4XG4gICAgICB0aGVuIHZhbHVlX3Vuc2FmZSB4XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiT3B0aW9uX2FycmF5LmdldF9zb21lX2V4bjogdGhlIGVsZW1lbnQgaXMgW05vbmVdXCJcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXJfc29tZSB0IH5mID0gaWYgaXNfc29tZSB0IHRoZW4gZiAodmFsdWVfdW5zYWZlIHQpXG4gIGVuZFxuXG4gIG1vZHVsZSBUMSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcblxuICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IG5vbmVcbiAgICAgIHwgU29tZSB4IC0+IHNvbWUgeFxuICAgIDs7XG5cbiAgICBsZXRbQGlubGluZV0gdG9fb3B0aW9uIHggPSBpZiBpc19zb21lIHggdGhlbiBTb21lICh2YWx1ZV91bnNhZmUgeCkgZWxzZSBOb25lXG4gICAgbGV0IHRvX3NleHBhYmxlID0gdG9fb3B0aW9uXG4gICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfb3B0aW9uXG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKE9wdGlvbi50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuICAgIDs7XG4gIGVuZFxuXG4gIGluY2x1ZGUgVDFcbiAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZTEgKE9wdGlvbikgKFQxKVxuZW5kXG5cbnR5cGUgJ2EgdCA9ICdhIENoZWFwX29wdGlvbi50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMDFfIHhfXzAwM18gLT5cbiAgVW5pZm9ybV9hcnJheS50X29mX3NleHAgKENoZWFwX29wdGlvbi50X29mX3NleHAgX29mX2FfXzAwMV8pIHhfXzAwM19cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwNF8geF9fMDA1XyAtPlxuICBVbmlmb3JtX2FycmF5LnNleHBfb2ZfdCAoQ2hlYXBfb3B0aW9uLnNleHBfb2ZfdCBfb2ZfYV9fMDA0XykgeF9fMDA1X1xuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgVW5pZm9ybV9hcnJheS50X3NleHBfZ3JhbW1hciAoQ2hlYXBfb3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZW1wdHkgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG5sZXQgY3JlYXRlIH5sZW4gPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuIENoZWFwX29wdGlvbi5ub25lXG5sZXQgaW5pdCBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5vZl9vcHRpb24gKGYgaSkpXG5sZXQgaW5pdF9zb21lIG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLnNvbWUgKGYgaSkpXG5sZXQgbGVuZ3RoID0gVW5pZm9ybV9hcnJheS5sZW5ndGhcbmxldFtAaW5saW5lXSBnZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGdldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfbm9uZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBzZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCBzZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCBzZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBzd2FwIHQgaSBqID0gVW5pZm9ybV9hcnJheS5zd2FwIHQgaSBqXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9nZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcblxubGV0IHVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQgaSA9XG4gIENoZWFwX29wdGlvbi52YWx1ZV91bnNhZmUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG47O1xuXG5sZXQgdW5zYWZlX2lzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCB1bnNhZmVfc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHVuc2FmZV9zZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5cbmxldCBjbGVhciB0ID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXRfbm9uZSB0IGlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGlucHV0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBpbnB1dCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgaW5wdXQgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXIgaW5wdXQgfmYgPSBpdGVyaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSB4IC0+IGYgeClcblxubGV0IGZvbGRpIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IGFjYyA6PSBmIGkgIWFjYyBlbGVtKTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgaW5wdXQgfmluaXQgfmYgPSBmb2xkaSBpbnB1dCB+aW5pdCB+ZjooZnVuIChfIDogaW50KSBhY2MgeCAtPiBmIGFjYyB4KVxuXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyLk1ha2VfZ2VuIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2Egb3B0aW9uXG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IG1hcGkgaW5wdXQgfmYgPVxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW46KGxlbmd0aCBpbnB1dCkgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gdW5zYWZlX3NldCBvdXRwdXQgaSAoZiBpIGVsZW0pKTtcbiAgb3V0cHV0XG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSBlbGVtIC0+IGYgZWxlbSlcblxubGV0IG1hcF9zb21lIGlucHV0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dCBpblxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW4gaW5cbiAgbGV0ICgpID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IG9wdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCBpbnB1dCBpIGluXG4gICAgICBDaGVhcF9vcHRpb24uaXRlcl9zb21lIG9wdCB+ZjooZnVuIHggLT4gdW5zYWZlX3NldF9zb21lIG91dHB1dCBpIChmIHgpKVxuICAgIGRvbmVcbiAgaW5cbiAgb3V0cHV0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPSBpbml0IChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG5cbmxldCBvZl9hcnJheV9zb21lIGFycmF5ID1cbiAgaW5pdF9zb21lIChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMV9nZW5lcmljIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgY29weSA9IFVuaWZvcm1fYXJyYXkuY29weVxuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVuc2FmZV9jaGVhcF9vcHRpb24gPSBDaGVhcF9vcHRpb25cbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFN0YWNrX2ludGZcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byBbRGVxdWVdIGluIHRoYXQgaXQgdXNlcyBhbiBhcnJheSBvZiBbJ2FdIGFuZFxuICAgYSBtdXRhYmxlIFtpbnRdIHRvIGluZGljYXRlIHdoYXQgaW4gdGhlIGFycmF5IGlzIHVzZWQuICBXZSBjaG9vc2UgdG8gaW1wbGVtZW50IFtTdGFja11cbiAgIGRpcmVjdGx5IHJhdGhlciB0aGFuIG9uIHRvcCBvZiBbRGVxdWVdIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgRS5nLiBhIHNpbXBsZVxuICAgbWljcm9iZW5jaG1hcmsgc2hvd3MgdGhhdCBwdXNoL3BvcCBpcyBhYm91dCAyMCUgZmFzdGVyLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgZWx0cyA6ICdhIE9wdGlvbl9hcnJheS50XG4gIH1cbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDFfIHsgbGVuZ3RoID0gbGVuZ3RoX18wMDNfOyBlbHRzID0gZWx0c19fMDA1XyB9IC0+XG4gIGxldCBibmRzX18wMDJfID0gW10gaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAwNV8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwM18gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMDRfIF0gOjogYm5kc19fMDAyX1xuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IHNleHBfb2ZfdCA9IGBSZWJvdW5kX2xhdGVyXG5sZXQgXyA9IHNleHBfb2ZfdFxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hICh7IGxlbmd0aDsgZWx0cyB9IGFzIHQpIDogdW5pdCA9XG4gIHRyeVxuICAgIGFzc2VydCAoMCA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICAgIGludmFyaWFudF9hIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgaSlcbiAgICBkb25lO1xuICAgICgqIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB1bnVzZWQgZWxlbWVudHMgYXJlIHVuc2V0IHRvIGF2b2lkIGEgc3BhY2VcbiAgICAgICBsZWFrLiAqKVxuICAgIGZvciBpID0gbGVuZ3RoIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyAtIDEgZG9cbiAgICAgIGFzc2VydCAobm90IChPcHRpb25fYXJyYXkuaXNfc29tZSBlbHRzIGkpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiU3RhY2suaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiZXhuXCIsIGV4biB8PiBFeG4uc2V4cF9vZl90OyBcInN0YWNrXCIsIHQgfD4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2Zfb3BhcXVlIF0pXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpICgpIDogYSB0ID0geyBsZW5ndGggPSAwOyBlbHRzID0gT3B0aW9uX2FycmF5LmVtcHR5IH1cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG4oKiBUaGUgb3JkZXIgaW4gd2hpY2ggZWxlbWVudHMgYXJlIHZpc2l0ZWQgaGFzIGJlZW4gY2hvc2VuIHNvIGFzIHRvIGJlIGJhY2t3YXJkc1xuICAgY29tcGF0aWJsZSB3aXRoIFtDYW1sLlN0YWNrXSAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgIXIgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICBmIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpKVxuICBkb25lXG47O1xuXG5tb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgZW5kKVxuXG5sZXQgbWVtID0gQy5tZW1cbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBDLnRvX2FycmF5XG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5cbmxldCBvZl9saXN0ICh0eXBlIGEpIChsIDogYSBsaXN0KSA9XG4gIGlmIExpc3QuaXNfZW1wdHkgbFxuICB0aGVuIGNyZWF0ZSAoKVxuICBlbHNlIChcbiAgICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBlbHRzID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOigyICogbGVuZ3RoKSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICBmb3IgaSA9IGxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgZWx0cyBpIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgeyBsZW5ndGg7IGVsdHMgfSlcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBMaXN0LnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBvZl9saXN0IChMaXN0LnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgcmVzaXplIHQgc2l6ZSA9XG4gIGxldCBhcnIgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBpblxuICBPcHRpb25fYXJyYXkuYmxpdCB+c3JjOnQuZWx0cyB+ZHN0OmFyciB+c3JjX3BvczowIH5kc3RfcG9zOjAgfmxlbjp0Lmxlbmd0aDtcbiAgdC5lbHRzIDwtIGFyclxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IG5ld19jYXBhY2l0eSA9XG4gIGxldCBuZXdfY2FwYWNpdHkgPSBtYXggbmV3X2NhcGFjaXR5IChsZW5ndGggdCkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHQgdGhlbiByZXNpemUgdCBuZXdfY2FwYWNpdHlcbjs7XG5cbmxldCBwdXNoIHQgYSA9XG4gIGlmIHQubGVuZ3RoID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgdGhlbiByZXNpemUgdCAoMiAqICh0Lmxlbmd0aCArIDEpKTtcbiAgT3B0aW9uX2FycmF5LnNldF9zb21lIHQuZWx0cyB0Lmxlbmd0aCBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBwb3Bfbm9uZW1wdHkgdCA9XG4gIGxldCBpID0gdC5sZW5ndGggLSAxIGluXG4gIGxldCByZXN1bHQgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpIGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSB0LmVsdHMgaTtcbiAgdC5sZW5ndGggPC0gaTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgcG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sucG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCBwb3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAocG9wX25vbmVtcHR5IHQpXG5sZXQgcG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHBvcF9lcnJvciBlbHNlIHBvcF9ub25lbXB0eSB0XG5sZXQgdG9wX25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyAodC5sZW5ndGggLSAxKVxubGV0IHRvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnRvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgdG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHRvcF9ub25lbXB0eSB0KVxubGV0IHRvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSB0b3BfZXJyb3IgZWxzZSB0b3Bfbm9uZW1wdHkgdFxubGV0IGNvcHkgeyBsZW5ndGg7IGVsdHMgfSA9IHsgbGVuZ3RoOyBlbHRzID0gT3B0aW9uX2FycmF5LmNvcHkgZWx0cyB9XG5cbmxldCBjbGVhciB0ID1cbiAgaWYgdC5sZW5ndGggPiAwXG4gIHRoZW4gKFxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIE9wdGlvbl9hcnJheS5zZXRfbm9uZSB0LmVsdHMgaVxuICAgIGRvbmU7XG4gICAgdC5sZW5ndGggPC0gMClcbjs7XG5cbmxldCB1bnRpbF9lbXB0eSB0IGYgPVxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIGlmIHQubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgZiAocG9wX25vbmVtcHR5IHQpO1xuICAgICAgbG9vcCAoKSlcbiAgaW5cbiAgbG9vcCAoKVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgcHVzaCB0IHg7XG4gIHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogVGhpcyBpcyBsaWZ0ZWQgb3V0IG9mIFtNXSBiZWNhdXNlIFtTb3VyY2VfY29kZV9wb3NpdGlvbjBdIGV4cG9ydHMgW1N0cmluZzBdXG4gICBhcyBbU3RyaW5nXSwgd2hpY2ggZG9lcyBub3QgZXhwb3J0IGEgaGFzaCBmdW5jdGlvbi4gKilcbmxldCBoYXNoX292ZXJyaWRlIHsgQ2FtbC5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2JvbDsgcG9zX2NudW0gfSA9XG4gIFN0cmluZy5oYXNoIHBvc19mbmFtZVxuICBseG9yIEludC5oYXNoIHBvc19sbnVtXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2JvbFxuICBseG9yIEludC5oYXNoIHBvc19jbnVtXG47O1xuXG5tb2R1bGUgTSA9IHN0cnVjdFxuICBpbmNsdWRlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMFxuXG4gIGxldCBoYXNoID0gaGFzaF9vdmVycmlkZVxuZW5kXG5cbmluY2x1ZGUgTVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoTSlcblxubGV0IG9mX3BvcyAocG9zX2ZuYW1lLCBwb3NfbG51bSwgcG9zX2NudW0sIF8pID1cbiAgeyBwb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCA9IDAgfVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmVnXG4gICAgfCBaZXJvXG4gICAgfCBQb3NcbiAgICB8IE5hblxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ25fb3JfbmFuLm1sLlQudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgIHwgTmVnIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICB8IE5hbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDNcbiAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3M7IE5hbiBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduX29yX25hblwiXG5lbmRcblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogVC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogVC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogVC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBULnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBvZl9zaWduID0gZnVuY3Rpb25cbiAgfCBTaWduLk5lZyAtPiBOZWdcbiAgfCBTaWduLlplcm8gLT4gWmVyb1xuICB8IFNpZ24uUG9zIC0+IFBvc1xuOztcblxubGV0IHRvX3NpZ25fZXhuID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gU2lnbi5OZWdcbiAgfCBaZXJvIC0+IFNpZ24uWmVyb1xuICB8IFBvcyAtPiBTaWduLlBvc1xuICB8IE5hbiAtPiBpbnZhbGlkX2FyZyBcIkJhc2UuU2lnbl9vcl9uYW4udG9fc2lnbl9leG46IE5hblwiXG47O1xuXG5sZXQgb2ZfaW50IG4gPSBvZl9zaWduIChTaWduLm9mX2ludCBuKVxubGV0IHRvX2ludF9leG4gdCA9IFNpZ24udG9faW50ICh0b19zaWduX2V4biB0KVxuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbiAgfCBOYW4gLT4gTmFuXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOYW4sIF8gfCBfLCBOYW4gLT4gTmFuXG4gIHwgXyAtPiBvZl9zaWduIChTaWduLiggKiApICh0b19zaWduX2V4biB0KSAodG9fc2lnbl9leG4gdCcpKVxuOztcblxuKCogSW5jbHVkZSBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBhbnkgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdFxuICAgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICB8IEluY2wgb2YgJ2FcbiAgfCBFeGNsIG9mICdhXG4gIHwgVW5ib3VuZGVkXG5bQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBhbGwgOiAnYS4gJ2EgbGlzdCAtPiAnYSB0IGxpc3QgPVxuICBmdW4gX2FsbF9vZl9hIC0+XG4gIFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgIHwgZW51bWVyYXRlX18wMDFfIDo6IGwgLT4gbWFwIGwgKEluY2wgZW51bWVyYXRlX18wMDFfIDo6IGFjYylcbiAgICAgaW5cbiAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAoUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgICAgfCBlbnVtZXJhdGVfXzAwMl8gOjogbCAtPiBtYXAgbCAoRXhjbCBlbnVtZXJhdGVfXzAwMl8gOjogYWNjKVxuICAgICAgICBpblxuICAgICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgICAgIFsgVW5ib3VuZGVkIF0pXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAxOF8pIDogKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8gdCkgLT5cbiAgbGV0IGVycm9yX3NvdXJjZV9fMDA2XyA9IFwibWF5YmVfYm91bmQubWwudFwiIGluXG4gIGZ1biBfb2ZfYV9fMDAzXyAtPiBmdW5jdGlvblxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBfdGFnX18wMDlfKSA6OiBzZXhwX2FyZ3NfXzAxMF8pIGFzXG4gICAgICBfc2V4cF9fMDA4XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDEwXyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxMV8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTFfIGluXG4gICAgICAgICBJbmNsIHJlczBfXzAxMl9cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAwOV9cbiAgICAgICAgICAgX3NleHBfXzAwOF8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgIF9zZXhwX18wMTNfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTVfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxNl8gaW5cbiAgICAgICAgIEV4Y2wgcmVzMF9fMDE3X1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDE0X1xuICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIC0+IFVuYm91bmRlZFxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgOjogXykgYXNcbiAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biAodHlwZSBhX18wMjRfKSA6ICgoYV9fMDI0XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyNF8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyAtPiBmdW5jdGlvblxuICAgIHwgSW5jbCBhcmcwX18wMjBfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkluY2xcIjsgcmVzMF9fMDIxXyBdXG4gICAgfCBFeGNsIGFyZzBfXzAyMl8gLT5cbiAgICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhjbFwiOyByZXMwX18wMjNfIF1cbiAgICB8IFVuYm91bmRlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmJvdW5kZWRcIlxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkluY2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkV4Y2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJVbmJvdW5kZWRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxudHlwZSBpbnRlcnZhbF9jb21wYXJpc29uID1cbiAgfCBCZWxvd19sb3dlcl9ib3VuZFxuICB8IEluX3JhbmdlXG4gIHwgQWJvdmVfdXBwZXJfYm91bmRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2hdXG5cbmxldCBpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDI3XyA9IFwibWF5YmVfYm91bmQubWwuaW50ZXJ2YWxfY29tcGFyaXNvblwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgLT4gQmVsb3dfbG93ZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIC0+IEluX3JhbmdlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSAtPiBBYm92ZV91cHBlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBzZXhwX18wMjZfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiBpbnRlcnZhbF9jb21wYXJpc29uKVxuOztcblxubGV0IHNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW5jdGlvblxuICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQmVsb3dfbG93ZXJfYm91bmRcIlxuICAgIHwgSW5fcmFuZ2UgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5fcmFuZ2VcIlxuICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQWJvdmVfdXBwZXJfYm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAoaW50ZXJ2YWxfY29tcGFyaXNvbl9zZXhwX2dyYW1tYXIgOiBpbnRlcnZhbF9jb21wYXJpc29uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiQmVsb3dfbG93ZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkluX3JhbmdlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJBYm92ZV91cHBlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlXG4gICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnQpXG47O1xuXG5sZXQgKGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIDpcbiAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgSW5fcmFuZ2UgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IEluY2wgKGYgaW5jbClcbiAgfCBFeGNsIGV4Y2wgLT4gRXhjbCAoZiBleGNsKVxuICB8IFVuYm91bmRlZCAtPiBVbmJvdW5kZWRcbjs7XG5cbmxldCBpc19sb3dlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGluY2wgYSA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgZXhjbCBhIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgaXNfdXBwZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBhIGluY2wgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGEgZXhjbCA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBtYXRjaCBsb3dlciB3aXRoXG4gIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gIHwgSW5jbCBsb3dlciB8IEV4Y2wgbG93ZXIgLT5cbiAgICAobWF0Y2ggdXBwZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICAgICB8IEluY2wgdXBwZXIgfCBFeGNsIHVwcGVyIC0+IGNvbXBhcmUgbG93ZXIgdXBwZXIgPiAwKVxuOztcblxubGV0IGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgaWYgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZVxuICB0aGVuIGZhaWx3aXRoIFwiTWF5YmVfYm91bmQuY29tcGFyZV90b19pbnRlcnZhbF9leG46IGxvd2VyIGJvdW5kID4gdXBwZXIgYm91bmRcIlxuOztcblxubGV0IGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlO1xuICBpZiBub3QgKGlzX2xvd2VyX2JvdW5kIGxvd2VyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBCZWxvd19sb3dlcl9ib3VuZFxuICBlbHNlIGlmIG5vdCAoaXNfdXBwZXJfYm91bmQgdXBwZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEFib3ZlX3VwcGVyX2JvdW5kXG4gIGVsc2UgSW5fcmFuZ2Vcbjs7XG5cbmxldCBpbnRlcnZhbF9jb250YWluc19leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgbWF0Y2ggY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlIHdpdGhcbiAgfCBJbl9yYW5nZSAtPiB0cnVlXG4gIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgT3JfZHVwbGljYXRlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgT2sgb2YgJ2FcbiAgICB8IGBEdXBsaWNhdGVcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgfCBgT2sgX2xlZnRfXzAwM18sIGBPayBfcmlnaHRfXzAwNF8gLT4gX2NtcF9fYSBfbGVmdF9fMDAzXyBfcmlnaHRfXzAwNF9cbiAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiAwXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNV8gYl9fMDA2XyAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDA1XyBiX18wMDZfXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBhX18wMDVfLCBiX18wMDZfIHdpdGhcbiAgICAgICAgfCBgT2sgX2xlZnRfXzAwN18sIGBPayBfcmlnaHRfXzAwOF8gLT4gX2NtcF9fYSBfbGVmdF9fMDA3XyBfcmlnaHRfXzAwOF9cbiAgICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IHRydWVcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMDlfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBPayB2X18wMTBfIC0+IFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IF9vZl9hX18wMDlfIHZfXzAxMF8gXVxuICAgICAgfCBgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkR1cGxpY2F0ZVwiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gY29tcGFyYXRvcjooJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gKCdrZXksICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdrICd2LiAoJ2sgLT4gJ2sgLT4gaW50KSAtPiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgbGV0IHRfXzAxM18sIHRfXzAxNF8gPSBhX18wMTFfIGluXG4gICAgbGV0IHRfXzAxNV8sIHRfXzAxNl8gPSBiX18wMTJfIGluXG4gICAgbWF0Y2ggX2NtcF9fayB0X18wMTNfIHRfXzAxNV8gd2l0aFxuICAgIHwgMCAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+ICdrIC0+IGJvb2wpIC0+ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAyN18gYl9fMDI4XyAtPlxuICAgICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgICBsZXQgdF9fMDMxXywgdF9fMDMyXyA9IGJfXzAyOF8gaW5cbiAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgICAoaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDMwXyB0X18wMzJfXG4gICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBtYXRjaCB0X18wMzBfLCB0X18wMzJfIHdpdGhcbiAgICAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDMzXywgYExlZnQgX3JpZ2h0X18wMzRfIC0+IF9jbXBfX3YgX2xlZnRfXzAzM18gX3JpZ2h0X18wMzRfXG4gICAgICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMzVfLCBgUmlnaHQgX3JpZ2h0X18wMzZfIC0+IF9jbXBfX3YgX2xlZnRfXzAzNV8gX3JpZ2h0X18wMzZfXG4gICAgICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAzN18sIGBVbmVxdWFsIF9yaWdodF9fMDM4XyAtPlxuICAgICAgICAgICAgIGxldCB0X18wMzlfLCB0X18wNDBfID0gX2xlZnRfXzAzN18gaW5cbiAgICAgICAgICAgICBsZXQgdF9fMDQxXywgdF9fMDQyXyA9IF9yaWdodF9fMDM4XyBpblxuICAgICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX3YgdF9fMDM5XyB0X18wNDFfKSAoX2NtcF9fdiB0X18wNDBfIHRfXzA0Ml8pXG4gICAgICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnayAndi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdrKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdrLCAndikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJtYXBfaW50Zi5tbC5TeW1tZXRyaWNfZGlmZl9lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2Zfa19fMDQzXyBfb2Zfdl9fMDQ0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNjdfOyBhcmcxX18wNjhfIF0gLT5cbiAgICAgICAgbGV0IHJlczBfXzA2OV8gPSBfb2Zfa19fMDQzXyBhcmcwX18wNjdfXG4gICAgICAgIGFuZCByZXMxX18wNzBfID1cbiAgICAgICAgICBsZXQgc2V4cF9fMDY2XyA9IGFyZzFfXzA2OF8gaW5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG1hdGNoIHNleHBfXzA2Nl8gd2l0aFxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyBhcyBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIDo6IHNleHBfYXJnc19fMDUwXykgYXNcbiAgICAgICAgICAgICAgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiBhcyBfdGFnX18wNjNfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2NF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDY1XyA9IF9vZl92X18wNDRfIGFyZzBfXzA2NF8gaW5cbiAgICAgICAgICAgICAgICAgICAgYExlZnQgcmVzMF9fMDY1X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjNfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiBhcyBfdGFnX18wNjBfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2MV8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDYyXyA9IF9vZl92X18wNDRfIGFyZzBfXzA2MV8gaW5cbiAgICAgICAgICAgICAgICAgICAgYFJpZ2h0IHJlczBfXzA2Ml9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiBhcyBfdGFnX18wNTFfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA1OF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU5XyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggYXJnMF9fMDU4XyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNTJfOyBhcmcxX18wNTNfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDUyX1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2Zfdl9fMDQ0XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMwX18wNTRfLCByZXMxX18wNTVfXG4gICAgICAgICAgICAgICAgICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNleHBfXzA1Nl9cbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgYFVuZXF1YWwgcmVzMF9fMDU5X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNTFfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuTm9fdmFyaWFudF9tYXRjaCAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgIHNleHBfXzA2Nl9cbiAgICAgICAgaW5cbiAgICAgICAgcmVzMF9fMDY5XywgcmVzMV9fMDcwX1xuICAgICAgfCBzZXhwX18wNzFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgZXJyb3Jfc291cmNlX18wNTdfIDIgc2V4cF9fMDcxX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdrICd2LlxuICAgICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2Zfa19fMDcyXyBfb2Zfdl9fMDczXyAoYXJnMF9fMDgxXywgYXJnMV9fMDgyXykgLT5cbiAgICAgIGxldCByZXMwX18wODNfID0gX29mX2tfXzA3Ml8gYXJnMF9fMDgxX1xuICAgICAgYW5kIHJlczFfXzA4NF8gPVxuICAgICAgICBtYXRjaCBhcmcxX18wODJfIHdpdGhcbiAgICAgICAgfCBgTGVmdCB2X18wNzRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2Zfdl9fMDczXyB2X18wNzRfIF1cbiAgICAgICAgfCBgUmlnaHQgdl9fMDc1XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl92X18wNzNfIHZfXzA3NV8gXVxuICAgICAgICB8IGBVbmVxdWFsIHZfXzA3Nl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbFwiXG4gICAgICAgICAgICA7IChsZXQgYXJnMF9fMDc3XywgYXJnMV9fMDc4XyA9IHZfXzA3Nl8gaW5cbiAgICAgICAgICAgICAgIGxldCByZXMwX18wNzlfID0gX29mX3ZfXzA3M18gYXJnMF9fMDc3X1xuICAgICAgICAgICAgICAgYW5kIHJlczFfXzA4MF8gPSBfb2Zfdl9fMDczXyBhcmcxX18wNzhfIGluXG4gICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wNzlfOyByZXMxX18wODBfIF0pXG4gICAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDgzXzsgcmVzMV9fMDg0XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8na19zZXhwX2dyYW1tYXIgXyd2X3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgKCBfJ2tfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAgICggVmFyaWFudFxuICAgICAgICAgICAgICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiVW5lcXVhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKSApKVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDg1XyBiX18wODZfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDg1XyBiX18wODZfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wODVfLCBiX18wODZfIHdpdGhcbiAgICAgIHwgYExlZnQgX2xlZnRfXzA4N18sIGBMZWZ0IF9yaWdodF9fMDg4XyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wODdfIF9yaWdodF9fMDg4X1xuICAgICAgfCBgUmlnaHQgX2xlZnRfXzA4OV8sIGBSaWdodCBfcmlnaHRfXzA5MF8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzA4OV8gX3JpZ2h0X18wOTBfXG4gICAgICB8IGBCb3RoIF9sZWZ0X18wOTFfLCBgQm90aCBfcmlnaHRfXzA5Ml8gLT5cbiAgICAgICAgbGV0IHRfXzA5M18sIHRfXzA5NF8gPSBfbGVmdF9fMDkxXyBpblxuICAgICAgICBsZXQgdF9fMDk1XywgdF9fMDk2XyA9IF9yaWdodF9fMDkyXyBpblxuICAgICAgICAobWF0Y2ggX2NtcF9fbGVmdCB0X18wOTNfIHRfXzA5NV8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX3JpZ2h0IHRfXzA5NF8gdF9fMDk2X1xuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDk3XyBiX18wOThfIC0+XG4gICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wOTdfIGJfXzA5OF9cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGFfXzA5N18sIGJfXzA5OF8gd2l0aFxuICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wOTlfLCBgTGVmdCBfcmlnaHRfXzEwMF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDk5XyBfcmlnaHRfXzEwMF9cbiAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzEwMV8sIGBSaWdodCBfcmlnaHRfXzEwMl8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzEwMV8gX3JpZ2h0X18xMDJfXG4gICAgICAgIHwgYEJvdGggX2xlZnRfXzEwM18sIGBCb3RoIF9yaWdodF9fMTA0XyAtPlxuICAgICAgICAgIGxldCB0X18xMDVfLCB0X18xMDZfID0gX2xlZnRfXzEwM18gaW5cbiAgICAgICAgICBsZXQgdF9fMTA3XywgdF9fMTA4XyA9IF9yaWdodF9fMTA0XyBpblxuICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX2xlZnQgdF9fMTA1XyB0X18xMDdfKSAoX2NtcF9fcmlnaHQgdF9fMTA2XyB0X18xMDhfKVxuICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnbGVmdCAncmlnaHQuXG4gICAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2xlZnRfXzEwOV8gX29mX3JpZ2h0X18xMTBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBMZWZ0IHZfXzExMV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2ZfbGVmdF9fMTA5XyB2X18xMTFfIF1cbiAgICAgIHwgYFJpZ2h0IHZfXzExMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3JpZ2h0X18xMTBfIHZfXzExMl8gXVxuICAgICAgfCBgQm90aCB2X18xMTNfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiXG4gICAgICAgICAgOyAobGV0IGFyZzBfXzExNF8sIGFyZzFfXzExNV8gPSB2X18xMTNfIGluXG4gICAgICAgICAgICAgbGV0IHJlczBfXzExNl8gPSBfb2ZfbGVmdF9fMTA5XyBhcmcwX18xMTRfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzExN18gPSBfb2ZfcmlnaHRfXzExMF8gYXJnMV9fMTE1XyBpblxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzExNl87IHJlczFfXzExN18gXSlcbiAgICAgICAgICBdXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5Db250aW51ZV9vcl9zdG9wICopXG5tb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ29udGludWVcbiAgICB8IFN0b3BcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgQ29udGludWU7IFN0b3AgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb250aW51ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJDb250aW51ZVwiXG4gICAgICB8IFN0b3AgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RvcFwiXG4gICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkZpbmlzaGVkX29yX3VuZmluaXNoZWQgKilcbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBGaW5pc2hlZFxuICAgIHwgVW5maW5pc2hlZFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBGaW5pc2hlZDsgVW5maW5pc2hlZCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkZpbmlzaGVkXCJcbiAgICAgIHwgVW5maW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmZpbmlzaGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICB0eXBlICdhIGtleVxuICB0eXBlICdjbXAgY21wXG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgdmFsIGFkZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzZXRcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBhZGRfbXVsdGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YgbGlzdCkgb3B0aW9uc1xuXG4gIHZhbCBjaGFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3Ygb3B0aW9uKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgZmluZF9leG4gOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2KSBvcHRpb25zXG4gIHZhbCByZW1vdmUgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sga2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAgIC0+IHVuaXQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZDJcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYSAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfa2V5c1xuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIGtleSAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcmlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICgnaywgJ2NtcCwgKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCkgb3B0aW9uc1xuXG4gIHZhbCBlcXVhbFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21iaW5lOihrZXk6J2sga2V5IC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KCdhIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAnayBrZXlcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sga2V5ICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFwcGVuZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBsb3dlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgLT4gdXBwZXJfYm91bmQ6J2sga2V5IE1heWJlX2JvdW5kLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbWluOidrIGtleVxuICAgICAgLT4gbWF4OidrIGtleVxuICAgICAgLT4gaW5pdDonYVxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sga2V5IC0+IG1heDonayBrZXkgLT4gKCdrIGtleSAqICd2KSBsaXN0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrIGtleVxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrIGtleSwgJ3YsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonayBrZXlcbiAgICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBzZXQgOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBhZGRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIGxpc3QgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleSAtPiAnYSBsaXN0IHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIGNoYW5nZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHRcbiAgdmFsIHVwZGF0ZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgdFxuICB2YWwgbWVtIDogXyB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiBfIHQgLT4gZjooa2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMiA6ICdhIHQgLT4gJ2IgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG1hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgZm9sZDJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2IgdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogJ2EgdCAtPiBmOihrZXkgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBmaWx0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgcGFydGl0aW9uX21hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAoJ2IsICdjKSBFaXRoZXIudCkgLT4gJ2IgdCAqICdjIHRcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2MpIEVpdGhlci50KSAtPiAnYiB0ICogJ2MgdFxuICB2YWwgcGFydGl0aW9uaV90ZiA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICdhIE9yX2Vycm9yLnQgdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiBfIHQgLT4ga2V5IGxpc3RcbiAgdmFsIGRhdGEgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FsaXN0IDogP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICB2YWwgbWVyZ2UgOiAnYSB0IC0+ICdiIHQgLT4gZjooa2V5OmtleSAtPiAoJ2EsICdiKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Mgb3B0aW9uKSAtPiAnYyB0XG4gIHZhbCBtZXJnZV9za2V3ZWQgOiAndiB0IC0+ICd2IHQgLT4gY29tYmluZTooa2V5OmtleSAtPiAndiAtPiAndiAtPiAndikgLT4gJ3YgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiAoa2V5LCAnYSkgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKGtleSwgJ2EpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3BsaXQgOiAnYSB0IC0+IGtleSAtPiAnYSB0ICogKGtleSAqICdhKSBvcHRpb24gKiAnYSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6J2EgdFxuICAgIC0+IHVwcGVyX3BhcnQ6J2EgdFxuICAgIC0+IFsgYE9rIG9mICdhIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgJ2EgdFxuICAgIC0+IGxvd2VyX2JvdW5kOmtleSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6a2V5IE1heWJlX2JvdW5kLnRcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgJ2EgdFxuICAgIC0+IG1pbjprZXlcbiAgICAtPiBtYXg6a2V5XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYilcbiAgICAtPiAnYlxuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICdhIHQgLT4gbWluOmtleSAtPiBtYXg6a2V5IC0+IChrZXkgKiAnYSkgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICdhIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4ga2V5XG4gICAgLT4gKGtleSAqICdhKSBvcHRpb25cblxuICB2YWwgbnRoIDogJ2EgdCAtPiBpbnQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAnYSB0IC0+IGludCAtPiBrZXkgKiAnYVxuICB2YWwgcmFuayA6IF8gdCAtPiBrZXkgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzprZXlcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOmtleVxuICAgIC0+ICdhIHRcbiAgICAtPiAoa2V5ICogJ2EpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICdhIHRcbiAgICAtPiBjb21wYXJlOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgJ2EgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTprZXkgLT4gZGF0YTonYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYikgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYikgdCAtPiAnYSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZpbHRlcl9tYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnYSwgJ2IgT3JfZXJyb3IudCkgdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG4gIHZhbCB0b19hbGlzdCA6ID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gLT4gKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gKCdhLCAnYikgdCAqICgnYSAqICdiKSBvcHRpb24gKiAoJ2EsICdiKSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2EsICdiKSB0IC0+IG1pbjonYSAtPiBtYXg6J2EgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6ICgnYSwgXykgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXywgJ2NtcCkgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogKCdhLCBfLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IsIF8pIHQgLT4gJ2IgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2EsICdiLCBfKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdhLCAnYiwgXykgdCAtPiBtaW46J2EgLT4gbWF4OidhIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdhLCAnYiwgXykgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYiwgXykgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IsIF8pIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHNldFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIGZpbmRfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAnYiBsaXN0XG5cbiAgdmFsIGNoYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgdXBkYXRlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+IGY6KCdiIG9wdGlvbiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbmQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuXG4gIHZhbCByZW1vdmVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfLCAnY21wKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXNcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdiIC0+ICdiIC0+IGludClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwga2V5cyA6ICgnYSwgXywgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiLCBfKSB0IC0+ICdiIGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EgKiAnYikgb3B0aW9uICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gbG93ZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxuKCoqIENvbnNpc3RlbmN5IGNoZWNrcyAoc2FtZSBhcyBpbiBbQ29udGFpbmVyXSkuICopXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKFQgOiBUMylcbiAgICAoVHJlZSA6IFQzKVxuICAgIChLZXkgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IEFjY2Vzc29yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMzIChNIDogQWNjZXNzb3JzMykgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgKE0gOiBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdFxuICB0eXBlICgnaywgJ3YsICdjbXApIHRyZWVcbiAgdHlwZSAnayBrZXlcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdrLCAnY21wLCAnayBrZXkgLT4gJ3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgICAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpXG4gICAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIga2V5IF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0IC0+IGY6KCdrMSBrZXkgLT4gJ2syIGtleSkgLT4gKCdrMiwgJ3YsICdjbXAyKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgbGVuOmludCAtPiBmOihpbnQgLT4gJ2sga2V5ICogJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBsaXN0IC0+IGluaXQ6J3YyIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdXG4gICAgICApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgIC0+IGluaXQ6J3YyXG4gICAgICAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MilcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KVxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBpdGVyaTooZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2ssICdjbXAsICgnayBrZXksICd2LCAnY21wKSB0cmVlIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6IF8gdFxuICB2YWwgc2luZ2xldG9uIDoga2V5IC0+ICdhIC0+ICdhIHRcbiAgdmFsIG1hcF9rZXlzIDogJ3YgdCAtPiBmOihrZXkgLT4ga2V5KSAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICd2IHQgLT4gZjooa2V5IC0+IGtleSkgLT4gJ3YgdFxuICB2YWwgb2ZfYWxpc3QgOiAoa2V5ICogJ2EpIGxpc3QgLT4gWyBgT2sgb2YgJ2EgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX2FsaXN0X2V4biA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSBsaXN0IHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoa2V5ICogJ2EpIGxpc3QgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlIDogKGtleSAqICdhKSBsaXN0IC0+IGY6KCdhIC0+ICdhIC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoa2V5ICogJ2EpIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IChrZXkgKiAnYSkgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiBrZXkgKiAnYSkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICdhIHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGkgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBmOignYSAtPiAnYSAtPiAnYSkgLT4gJ2EgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6a2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cblxuICB2YWwgb2ZfaXRlcmlfZXhuIDogaXRlcmk6KGY6KGtleTprZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAndiB0XG4gIHZhbCBvZl90cmVlIDogJ2EgdHJlZSAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAoXywgXykgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2IgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazEsICd2KSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICgnazEsICd2KSB0IC0+IGY6KCdrMSAtPiAnazIpIC0+ICgnazIsICd2KSB0XG4gIHZhbCBvZl9hbGlzdCA6ICgnYSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoJ2EgKiAnYikgbGlzdCAtPiBpbml0OidjIC0+IGY6KCdjIC0+ICdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2UgOiAoJ2EgKiAnYikgbGlzdCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhICogJ2IpIGFycmF5IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICgnYSAqICdiKSBhcnJheSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhICogJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IgbGlzdCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4biA6IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl90cmVlIDogKCdhLCAnYikgdHJlZSAtPiAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsIF8sICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gJ2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogIGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiAoJ2syLCAndiwgJ2NtcDIpIHRcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9hbGlzdF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EgKiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3RyZWVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnNcbiAgICAoVCA6IFQzKVxuICAgIChUcmVlIDogVDMpXG4gICAgKEtleSA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yIChNIDogQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yczFcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGtleSA6PSBrZXlcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMyXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczJcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxuICB2YWwgc2V4cF9vZl9tX190XG4gICAgOiAgKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoJ3YgLT4gU2V4cC50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190XG4gICAgOiAgKG1vZHVsZSBDb21wYXJlX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGludClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoSGFzaC5zdGF0ZSAtPiAndiAtPiBIYXNoLnN0YXRlKVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gSGFzaC5zdGF0ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1hcCA9IHNpZ1xuICAoKiogW01hcF0gaXMgYSBmdW5jdGlvbmFsIGRhdGEgc3RydWN0dXJlIChiYWxhbmNlZCBiaW5hcnkgdHJlZSkgaW1wbGVtZW50aW5nIGZpbml0ZSBtYXBzXG4gICAgICBvdmVyIGEgdG90YWxseS1vcmRlcmVkIGRvbWFpbiwgY2FsbGVkIGEgXCJrZXlcIi4gKilcblxuICB0eXBlICgna2V5LCArJ3ZhbHVlLCAnY21wKSB0XG5cbiAgbW9kdWxlIE9yX2R1cGxpY2F0ZSA9IE9yX2R1cGxpY2F0ZVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IENvbnRpbnVlX29yX3N0b3BcblxuICBtb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA6IHNpZ1xuICAgIHR5cGUgdCA9IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudCA9XG4gICAgICB8IEZpbmlzaGVkXG4gICAgICB8IFVuZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfZW51bWVyYXRlX2xpYi5FbnVtZXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIE1hcHMgW0NvbnRpbnVlXSB0byBbRmluaXNoZWRdIGFuZCBbU3RvcF0gdG8gW1VuZmluaXNoZWRdLiAqKVxuICAgIHZhbCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHRcblxuICAgICgqKiBNYXBzIFtGaW5pc2hlZF0gdG8gW0NvbnRpbnVlXSBhbmQgW1VuZmluaXNoZWRdIHRvIFtTdG9wXS4gKilcbiAgICB2YWwgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNZXJnZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICAgIF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICB2YWwgY29tcGFyZVxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gaW50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gYm9vbFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBsZWZ0IDogKCdsZWZ0LCBfKSB0IC0+ICdsZWZ0IG9wdGlvblxuICAgIHZhbCByaWdodCA6IChfLCAncmlnaHQpIHQgLT4gJ3JpZ2h0IG9wdGlvblxuICAgIHZhbCBsZWZ0X3ZhbHVlIDogKCdsZWZ0LCBfKSB0IC0+IGRlZmF1bHQ6J2xlZnQgLT4gJ2xlZnRcbiAgICB2YWwgcmlnaHRfdmFsdWUgOiAoXywgJ3JpZ2h0KSB0IC0+IGRlZmF1bHQ6J3JpZ2h0IC0+ICdyaWdodFxuXG4gICAgdmFsIHZhbHVlc1xuICAgICAgOiAgKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGxlZnRfZGVmYXVsdDonbGVmdFxuICAgICAgLT4gcmlnaHRfZGVmYXVsdDoncmlnaHRcbiAgICAgIC0+ICdsZWZ0ICogJ3JpZ2h0XG4gIGVuZFxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIGxldCBtYXAgPSBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgICAgICAgICBbIFwiYVwiLCAxOyBcImFcIiwgMTA7IFwiYlwiLCAyOyBcImJcIiwgMjA7IFwiYlwiLCAyMDAgXVxuICAgICAgICAgICAgICAgICAgICAgIH5pbml0OkludC5TZXQuZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmludF9zIFslc2V4cCAobWFwIDogSW50LlNldC50IFN0cmluZy5NYXAudCldOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaXRlcmkgfml0ZXJpXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0XSwgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB0YWtpbmcgYSBjb25jcmV0ZVxuICAgICAgZGF0YSBzdHJ1Y3R1cmUsIGl0IHRha2VzIGFuIGl0ZXJhdGlvbiBmdW5jdGlvbi4gIEZvciBpbnN0YW5jZSwgdG8gY29udmVydCBhIHN0cmluZyB0YWJsZVxuICAgICAgaW50byBhIG1hcDogW29mX2l0ZXJpIChtb2R1bGUgU3RyaW5nKSB+ZjooSGFzaHRibC5pdGVyaSB0YWJsZSldLiAgSXQgaXMgZmFzdGVyIHRoYW5cbiAgICAgIGFkZGluZyB0aGUgZWxlbWVudHMgb25lIGJ5IG9uZS4gKilcbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogTGlrZSBbb2ZfaXRlcmldIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXkgYyAoU2VxdWVuY2UudG9fYXJyYXlcbiAgICAgIHNlcSldLCBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBhcnJheS5cblxuICAgICAgVGhlIHNlcXVlbmNlIHdpbGwgYmUgZm9sZGVkIG92ZXIgb25jZSwgYW5kIHRoZSBhZGRpdGlvbmFsIHRpbWUgY29tcGxleGl0eSBpcyB7ZSBPKG4pfS5cbiAgKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0IGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG5cbiAgICAgIElmIHlvdXIgc2VxdWVuY2UgaXMgaW5jcmVhc2luZywgdXNlIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXS5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX29yX2Vycm9yIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X29yX2Vycm9yIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9leG4gYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC5cblxuICAgICAgW29mX3NlcXVlbmNlX211bHRpIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX2ZvbGQgYyBzZXEgfmluaXQgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZm9sZCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmluaXQgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfcmVkdWNlIGMgc2VxIH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X3JlZHVjZSBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBUZXN0cyB3aGV0aGVyIGEgbWFwIGlzIGVtcHR5LiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFtsZW5ndGggbWFwXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gW21hcF0uICBPKDEpLCBidXQgW1RyZWUubGVuZ3RoXSBpc1xuICAgICAgTyhuKS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgbmV3IGJpbmRpbmc7IGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgYm91bmQsIGl0c1xuICAgICAgcHJldmlvdXMgYmluZGluZyBkaXNhcHBlYXJzLiAqKVxuICB2YWwgc2V0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthZGQgdCB+a2V5IH5kYXRhXSBhZGRzIGEgbmV3IGVudHJ5IHRvIFt0XSBtYXBwaW5nIFtrZXldIHRvIFtkYXRhXSBhbmQgcmV0dXJucyBbYE9rXVxuICAgICAgd2l0aCB0aGUgbmV3IG1hcCwgb3IgaWYgW2tleV0gaXMgYWxyZWFkeSBwcmVzZW50IGluIFt0XSwgcmV0dXJucyBbYER1cGxpY2F0ZV0uICopXG4gIHZhbCBhZGQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBJZiBba2V5XSBpcyBub3QgcHJlc2VudCB0aGVuIGFkZCBhIHNpbmdsZXRvbiBsaXN0LCBvdGhlcndpc2UsIGNvbnMgZGF0YSBvbnRvIHRoZVxuICAgICAgaGVhZCBvZiB0aGUgZXhpc3RpbmcgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogSWYgdGhlIGtleSBpcyBwcmVzZW50LCB0aGVuIHJlbW92ZSBpdHMgaGVhZCBlbGVtZW50OyBpZiB0aGUgcmVzdWx0IGlzIGVtcHR5LCByZW1vdmVcbiAgICAgIHRoZSBrZXkuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIHRoZSBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vbmUuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICd2IGxpc3RcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gcmV0dXJucyBhIG5ldyBtYXAgW21dIHRoYXQgaXMgdGhlIHNhbWUgYXMgW3RdIG9uIGFsbCBrZXlzIGV4Y2VwdFxuICAgICAgZm9yIFtrZXldLCBhbmQgd2hvc2UgdmFsdWUgZm9yIFtrZXldIGlzIGRlZmluZWQgYnkgW2ZdLCBpLmUuLCBbZmluZCBtIGtleSA9IGYgKGZpbmRcbiAgICAgIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuXG4gICgqKiBSZXR1cm5zIFtTb21lIHZhbHVlXSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciBbTm9uZV0gaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndiBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgcmFpc2luZyBbQ2FtbC5Ob3RfZm91bmRdIG9yIFtOb3RfZm91bmRfc11cbiAgICAgIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYW55IGJpbmRpbmcgZm9yIHRoZSBrZXkgaW4gcXVlc3Rpb24gcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbbWVtIG1hcCBrZXldIHRlc3RzIHdoZXRoZXIgW21hcF0gY29udGFpbnMgYSBiaW5kaW5nIGZvciBba2V5XS4gKilcbiAgdmFsIG1lbSA6ICgnaywgXywgJ2NtcCkgdCAtPiAnayAtPiBib29sXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIFtmXSByZXR1cm5zIFtTdG9wXS4gSWYgW2ZdIHJldHVybnMgW1N0b3BdLCB0aGUgZmluYWxcbiAgICAgIHJlc3VsdCBpcyBbVW5maW5pc2hlZF0uIE90aGVyd2lzZSwgdGhlIGZpbmFsIHJlc3VsdCBpcyBbRmluaXNoZWRdLiAqKVxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyByZXBsYWNlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiopXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIENvbnZlcnQgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHRvIGEgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHVzaW5nIFtmXS4gKilcbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgKCoqIExpa2UgW21hcF9rZXlzXSwgYnV0IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XSwgdW50aWwgdGhlIGZpcnN0XG4gICAgICB0aW1lIHRoYXQgW2ZdIHJldHVybnMgW1N0b3AgX10uIElmIFtmXSByZXR1cm5zIFtTdG9wIGZpbmFsXSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gICAgICBpbW1lZGlhdGVseSB3aXRoIHRoZSB2YWx1ZSBbZmluYWxdLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgYW5kIHRoZSBmaW5hbFxuICAgICAgY2FsbCB0byBbZl0gcmV0dXJucyBbQ29udGludWUgbGFzdF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBbZmluaXNoIGxhc3RdLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gZGVjcmVhc2luZyBvcmRlciBvZiBba2V5XS4gKilcbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgKCoqIEZvbGRzIG92ZXIgdHdvIG1hcHMgc2lkZSBieSBzaWRlLCBsaWtlIFtpdGVyMl0uICopXG4gIHZhbCBmb2xkMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2EgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl9tYXBpXSBydW4gaW4gTyhuICogbGdcbiAgICAgIG4pIHRpbWU7IHRoZXkgc2ltcGx5IGFjY3VtdWxhdGUgZWFjaCBrZXkgJiBkYXRhIHBhaXIgcmV0YWluZWQgYnkgW2ZdIGludG8gYSBuZXcgbWFwXG4gICAgICB1c2luZyBbYWRkXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyBmaWx0ZXJlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXBpIHQgfmZdIHJldHVybnMgdHdvIG5ldyBbdF1zLCB3aXRoIGVhY2gga2V5IGluIFt0XSBhcHBlYXJpbmcgaW5cbiAgICAgIGV4YWN0bHkgb25lIG9mIHRoZSByZXN1bHRpbmcgbWFwcyBkZXBlbmRpbmcgb24gaXRzIG1hcHBpbmcgaW4gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUHJvZHVjZXMgW09rXSBvZiBhIG1hcCBpbmNsdWRpbmcgYWxsIGtleXMgaWYgYWxsIGRhdGEgaXMgW09rXSwgb3IgYW4gW0Vycm9yXVxuICAgICAgaW5jbHVkaW5nIGFsbCBlcnJvcnMgb3RoZXJ3aXNlLiAqKVxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFJldHVybnMgYSB0b3RhbCBvcmRlcmluZyBiZXR3ZWVuIG1hcHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHRvdGFsIG9yZGVyaW5nIHVzZWRcbiAgICAgIHRvIGNvbXBhcmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXF1YWwga2V5cyBpbiB0aGUgdHdvIG1hcHMuICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIG1hcHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgbSkuY29tcGFyZV0gb2YgdGhlIG1hcCBbbV0gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnayBIYXNoLmZvbGRlciAtPiAndiBIYXNoLmZvbGRlciAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCBjbXAgbTEgbTJdIHRlc3RzIHdoZXRoZXIgdGhlIG1hcHMgW20xXSBhbmQgW20yXSBhcmUgZXF1YWwsIHRoYXQgaXMsIGNvbnRhaW5cbiAgICAgIHRoZSBzYW1lIGtleXMgYW5kIGFzc29jaWF0ZSBlYWNoIGtleSB3aXRoIHRoZSBzYW1lIHZhbHVlLiAgW2NtcF0gaXMgdGhlIGVxdWFsaXR5XG4gICAgICBwcmVkaWNhdGUgdXNlZCB0byBjb21wYXJlIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sgbGlzdFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgKCoqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBmcm9tIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gKCoqIGRlZmF1bHQgaXMgW2BJbmNyZWFzaW5nXSAqKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiB7MiBBZGRpdGlvbmFsIG9wZXJhdGlvbnMgb24gbWFwc30gKilcblxuICAoKiogTWVyZ2VzIHR3byBtYXBzLiBUaGUgcnVudGltZSBpcyBPKGxlbmd0aCh0MSkgKyBsZW5ndGgodDIpKS4gWW91IHNob3VsZG4ndCB1c2UgdGhpc1xuICAgICAgZnVuY3Rpb24gdG8gbWVyZ2UgYSBsaXN0IG9mIG1hcHM7IGNvbnNpZGVyIHVzaW5nIFttZXJnZV9za2V3ZWRdIGluc3RlYWQuICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICAgIDogICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gcmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uXG4gICAgICBJdCBpcyBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudFxuICAgICAgb2Ygc3RydWN0dXJlLiBUaGUga2V5cyBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlIHdpbGwgYmUgaW4gc29ydGVkIG9yZGVyLlxuXG4gICAgICBJdCBpcyBhc3N1bWVkIHRoYXQgW2RhdGFfZXF1YWxdIGlzIGF0IGxlYXN0IGFzIGVxdWF0aW5nIGFzIHBoeXNpY2FsIGVxdWFsaXR5OiB0aGF0XG4gICAgICBbcGh5c19lcXVhbCB4IHldIGltcGxpZXMgW2RhdGFfZXF1YWwgeCB5XS4gT3RoZXJ3aXNlLCBbc3ltbWV0cmljX2RpZmZdIG1heSBiZWhhdmUgaW5cbiAgICAgIHVuZXhwZWN0ZWQgd2F5cy4gRm9yIGV4YW1wbGUsIHdpdGggW35kYXRhX2VxdWFsOihmdW4gXyBfIC0+IGZhbHNlKV0gaXQgaXMgTk9UXG4gICAgICBuZWNlc3NhcmlseSB0aGUgY2FzZSB0aGUgcmVzdWx0aW5nIGNoYW5nZSBzZXF1ZW5jZSB3aWxsIGNvbnRhaW4gYW4gZWxlbWVudFxuICAgICAgWyhrLCBgVW5lcXVhbCBfKV0gZm9yIGV2ZXJ5IGtleSBba10gc2hhcmVkIGJ5IGJvdGggbWFwcy5cblxuICAgICAgV2FybmluZzogRmxvYXQgZXF1YWxpdHkgdmlvbGF0ZXMgdGhpcyBwcm9wZXJ0eSEgW3BoeXNfZXF1YWwgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXNcbiAgICAgIHRydWUsIGJ1dCBbRmxvYXQuKD0pIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzIGZhbHNlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW2ZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIGZvbGRzIGFjcm9zcyBhbiBpbXBsaWNpdCBzZXF1ZW5jZSBvZiBjaGFuZ2VzXG4gICAgICBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0sIGluIHNvcnRlZCBvcmRlciBieSBrZXlzLiBFcXVpdmFsZW50IHRvXG4gICAgICBbU2VxdWVuY2UuZm9sZCAoc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwpXSwgYW5kIG1vcmUgZWZmaWNpZW50LiAqKVxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooJ2EgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFttaW5fZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtaW5pbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogW21heF9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1heGltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIFttYXBdIGlzIGVtcHR5LiAqKVxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBUaGVzZSBmdW5jdGlvbnMgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgc2ltaWxhciBmdW5jdGlvbnMgaW4gW0xpc3RdLiAqKVxuXG4gIHZhbCBmb3JfYWxsIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGludFxuXG5cbiAgKCoqIFtzcGxpdCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSwgdGhlIG1hcHBpbmcgb2YgW2tleV0gaWZcbiAgICAgIGFueSwgYW5kIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnRdIHJldHVybnMgW2BPayBtYXBdIHdoZXJlIFttYXBdIGNvbnRhaW5zIGFsbCB0aGVcbiAgICAgIFsoa2V5LCB2YWx1ZSldIHBhaXJzIGZyb20gdGhlIHR3byBpbnB1dCBtYXBzIGlmIGFsbCB0aGUga2V5cyBmcm9tIFtsb3dlcl9wYXJ0XSBhcmVcbiAgICAgIGxlc3MgdGhhbiBhbGwgdGhlIGtleXMgZnJvbSBbdXBwZXJfcGFydF0uICBPdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAgW2BPdmVybGFwcGluZ19rZXlfcmFuZ2VzXS5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBuKSB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBsYXJnZXIgaW5wdXQgbWFwLiAgVGhpcyBjYW4gYmVcbiAgICAgIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gW01hcC5tZXJnZV0gb3IgcmVwZWF0ZWQgW01hcC5hZGRdLlxuXG4gICAgICB7W1xuICAgICAgICBhc3NlcnQgKG1hdGNoIE1hcC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgd2l0aFxuICAgICAgICAgIHwgYE9rIHdob2xlX21hcCAtPlxuICAgICAgICAgICAgTWFwLnRvX2FsaXN0IHdob2xlX21hcFxuICAgICAgICAgICAgPSBMaXN0LmFwcGVuZCAodG9fYWxpc3QgbG93ZXJfcGFydCkgKHRvX2FsaXN0IHVwcGVyX3BhcnQpXG4gICAgICAgICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiB0cnVlKTtcbiAgICAgIF19ICopXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gICgqKiBbc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXSByZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGZyb21cbiAgICAgIFt0XSB3aG9zZSBrZXlzIGxpZSBpbnNpZGUgdGhlIGludGVydmFsIGluZGljYXRlZCBieSBbfmxvd2VyX2JvdW5kXSBhbmRcbiAgICAgIFt+dXBwZXJfYm91bmRdLiAgSWYgdGhpcyBpbnRlcnZhbCBpcyBlbXB0eSwgYW4gZW1wdHkgbWFwIGlzIHJldHVybmVkLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgb3V0cHV0IG1hcC4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgb3V0cHV0IG1hcC4gKilcbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmZdIGZvbGRzIFtmXSAod2l0aCBpbml0aWFsIHZhbHVlIFt+aW5pdF0pXG4gICAgICBvdmVyIGFsbCBrZXlzIChhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMpIHRoYXQgYXJlIGluIHRoZSByYW5nZSBbW21pbiwgbWF4XV1cbiAgICAgIChpbmNsdXNpdmUpLiAgKilcbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IG1pbjona1xuICAgIC0+IG1heDona1xuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXhdIHJldHVybnMgYW4gYXNzb2NpYXRpdmUgbGlzdCBvZiB0aGUgZWxlbWVudHMgd2hvc2Uga2V5c1xuICAgICAgbGllIGluIFtbbWluLCBtYXhdXSAoaW5jbHVzaXZlKSwgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGJlaW5nIGF0IHRoZSBoZWFkIG9mIHRoZVxuICAgICAgbGlzdC4gKilcbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sgLT4gbWF4OidrIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIFtjbG9zZXN0X2tleSB0IGRpciBrXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XSB3aXRoIFtrZXldIGNsb3Nlc3QgdG9cbiAgICAgIFtrXSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gaW5lcXVhbGl0eSBib3VuZC5cblxuICAgICAgRm9yIGV4YW1wbGUsIFtjbG9zZXN0X2tleSB0IGBMZXNzX3RoYW4ga10gd291bGQgYmUgdGhlIHBhaXIgd2l0aCB0aGUgY2xvc2VzdCBrZXkgdG9cbiAgICAgIFtrXSB3aGVyZSBba2V5IDwga10uXG5cbiAgICAgIFt0b19zZXF1ZW5jZV0gY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBzYW1lIHJlc3VsdHMgYXMgW2Nsb3Nlc3Rfa2V5XS4gIEl0IGlzIGxlc3NcbiAgICAgIGVmZmljaWVudCBmb3IgaW5kaXZpZHVhbCBsb29rdXBzIGJ1dCBtb3JlIGVmZmljaWVudCBmb3IgZmluZGluZyBtYW55IGVsZW1lbnRzIHN0YXJ0aW5nXG4gICAgICBhdCBzb21lIHZhbHVlLiAqKVxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdrXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbbnRoIHQgbl0gZmluZHMgdGhlIChrZXksIHZhbHVlKSBwYWlyIG9mIHJhbmsgbiAoaS5lLiwgc3VjaCB0aGF0IHRoZXJlIGFyZSBleGFjdGx5IG5cbiAgICAgIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBmb3VuZCBrZXkpLCBpZiBvbmUgZXhpc3RzLiAgTyhsb2cobGVuZ3RoIHQpICsgbikgdGltZS4gKilcbiAgdmFsIG50aCA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICdrICogJ3ZcblxuICAoKiogW3JhbmsgdCBrXSBJZiBba10gaXMgaW4gW3RdLCByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tdIGluXG4gICAgICBbdF0sIGFuZCBbTm9uZV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgcmFuayA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gaW50IG9wdGlvblxuXG5cblxuICAoKiogW3RvX3NlcXVlbmNlID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdF1cbiAgICAgIGdpdmVzIGEgc2VxdWVuY2Ugb2Yga2V5LXZhbHVlIHBhaXJzIGJldHdlZW4gW2tleXNfbGVzc19vcl9lcXVhbF90b10gYW5kXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBpbmNsdXNpdmUsIHByZXNlbnRlZCBpbiBbb3JkZXJdLiAgSWZcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dLCB0aGUgc2VxdWVuY2UgaXNcbiAgICAgIGVtcHR5LlxuXG4gICAgICBXaGVuIG5laXRoZXIgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gbm9yIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFyZVxuICAgICAgcHJvdmlkZWQsIHRoZSBjb3N0IGlzIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSB0byBwcm9kdWNlXG4gICAgICBlYWNoIGVsZW1lbnQuIElmIGVpdGhlciBpcyBwcm92aWRlZCAoYW5kIGlzIHVzZWQgYnkgdGhlIG9yZGVyIHBhcmFtZXRlclxuICAgICAgcHJvdmlkZWQpLCB0aGVuIHRoZSB0aGUgY29zdCBpcyBPKG4pIHVwIGZyb250LCBhbmQgYW1vcnRpemVkIE8oMSkgdG9cbiAgICAgIHByb2R1Y2UgZWFjaCBlbGVtZW50LiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2tcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgd2hpY2ggZWx0XSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XVxuICAgICAgc3BlY2lmaWVkIGJ5IFtjb21wYXJlXSBhbmQgW3doaWNoXSwgaWYgb25lIGV4aXN0cy5cblxuICAgICAgW3RdIG11c3QgYmUgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIFtjb21wYXJlXSwgd2hlcmUgW2NvbXBhcmVdIGFuZFxuICAgICAgW2VsdF0gZGl2aWRlIFt0XSBpbnRvIHRocmVlIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgIDwgZWx0ICB8ICA9IGVsdCAgfCAgPiBlbHQgIHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSByZXR1cm5zIGFuIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieVxuICAgICAgW3doaWNoXS4gIFNlZSB0aGUgZGlhZ3JhbSBiZWxvdyBuZXh0IHRvIHRoZSBbd2hpY2hdIHZhcmlhbnRzLlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbY29tcGFyZV0gb3JkZXJzIFt0XSwgYW5kIGJlaGF2aW9yIGlzXG4gICAgICB1bnNwZWNpZmllZCBpZiBbY29tcGFyZV0gZG9lc24ndCBvcmRlciBbdF0uICBCZWhhdmlvciBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIG9uIHRoZSBib3VuZGFyeSBvZiB0aGVcbiAgICAgIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlXG4gICAgICBsZWZ0IHNlZ21lbnQsIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC5cbiAgICAgIEl0IHJldHVybnMgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc3VicmFuZ2VdIHRha2VzIGEgW2NvbXBhcmVdIGZ1bmN0aW9uIHRoYXQgZGl2aWRlcyBbdF0gaW50byB0aHJlZVxuICAgICAgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50cyB3aXRoIHJlc3BlY3QgdG8gW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXTpcblxuICAgICAge3ZcbiAgICAgICAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEluX3JhbmdlIHwgQWJvdmVfdXBwZXJfYm91bmQgfFxuICAgICAgdn1cblxuICAgICAgYW5kIHJldHVybnMgYSBtYXAgb2YgdGhlIFtJbl9yYW5nZV0gc2VnbWVudC5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBtICsgbikgd2hlcmUgW21dIGlzIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IG1hcCBhbmQgW25dIGlzIHRoZVxuICAgICAgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuIFRoZSBsaW5lYXIgdGVybSBpbiBbbl0gaXMgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuXG5cbiAgICAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBpZiBbY29tcGFyZV0gZG9lcyBub3Qgc2VnbWVudCBbdF0gYXMgc2hvd24gYWJvdmUsIG9yIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBpdHMgaW5wdXRzLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IGludCBNYXAuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSAoU3RyaW5nLnQsIGludCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgTWFwLnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtpbnQgTWFwLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kIHN5bnRheFxuICAgICAgZG9lc24ndCAoYmVjYXVzZSB0aGVyZSBpcyBubyBzdWNoIHRoaW5nIGFzLCBzYXksIFtTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3NdXG4gICAgICAtLSBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLlxuXG4gICAgICBJbiBhZGRpdGlvbiwgd2hlbiB1c2luZyBbQEBkZXJpdmluZ10sIHRoZSByZXF1aXJlbWVudHMgb24gdGhlIGtleSBtb2R1bGUgYXJlIG9ubHlcbiAgICAgIHRob3NlIG5lZWRlZCB0byBzYXRpc2Z5IHdoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGVyaXZlIG9uIHRoZSBtYXAgaXRzZWxmLiBTYXkgeW91XG4gICAgICB3cml0ZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSB0ID0gaW50IE1hcC5NKFgpLnQgW0BAZGVyaXZpbmcgaGFzaF1cbiAgICAgIF19XG5cbiAgICAgIHRoZW4gdGhpcyB3aWxsIGJlIHdlbGwgdHlwZWQgZXhhY3RseSBpZiBbWF0gY29udGFpbnMgYXQgbGVhc3Q6XG4gICAgICAtIGEgdHlwZSBbdF0gd2l0aCBubyBwYXJhbWV0ZXJzXG4gICAgICAtIGEgY29tcGFyYXRvciB3aXRuZXNzXG4gICAgICAtIGEgW2hhc2hfZm9sZF90XSBmdW5jdGlvbiB3aXRoIHRoZSByaWdodCB0eXBlICopXG4gIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgna2V5LCAndmFsdWUsICdjbXApIHQgOj0gKCdrZXksICd2YWx1ZSwgJ2NtcCkgdFxuXG4gICgqKiBbVXNpbmdfY29tcGFyYXRvcl0gaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW01hcF0sIGV4Y2VwdCB0aGVcbiAgICAgIGZ1bmN0aW9ucyB0YWtlIGEgW35jb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XSwgd2hlcmVhcyB0aGUgZnVuY3Rpb25zIGF0IHRoZVxuICAgICAgdG9wbGV2ZWwgb2YgW01hcF0gdGFrZSBhIFsoJ2ssICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnaywgKyd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgdHlwZSAoKydrLCArJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzM1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAgIHZhbCBoYXNoX2ZvbGRfZGlyZWN0XG4gICAgICA6ICAnayBIYXNoLmZvbGRlclxuICAgICAgLT4gJ3YgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgICgqKiBUbyBnZXQgYXJvdW5kIHRoZSB2YWx1ZSByZXN0cmljdGlvbiwgYXBwbHkgdGhlIGZ1bmN0b3IgYW5kIGluY2x1ZGUgaXQuIFlvdVxuICAgICAgICBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgdGhpcyBpbiB0aGUgW1BvbHldIHN1Ym1vZHVsZSBiZWxvdy4gKilcbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpIDogc2lnXG4gICAgICB2YWwgZW1wdHkgOiAoJ2EgSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgTWFwLiAqKVxuICBtb2R1bGUgUG9seSA6XG4gICAgU19wb2x5XG4gICAgd2l0aCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0ID0gKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICBhbmQgdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdHJlZSA9XG4gICAgICAgICAgICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICAoKiogQ3JlYXRlIGEgbWFwIGZyb20gYSB0cmVlIHVzaW5nIHRoZSBnaXZlbiBjb21wYXJhdG9yLiAqKVxuICB2YWwgb2ZfdHJlZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBFeHRyYWN0IGEgdHJlZSBmcm9tIGEgbWFwLiAqKVxuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcblxuXG4gICgqKiB7MiBNb2R1bGVzIGFuZCBtb2R1bGUgdHlwZXMgZm9yIGV4dGVuZGluZyBbTWFwXX1cblxuICAgICAgRm9yIHVzZSBpbiBleHRlbnNpb25zIG9mIEJhc2UsIGxpa2UgW0NvcmVdLiAqKVxuXG4gIG1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBXaXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbiAgbW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IFdpdGhvdXRfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IEFjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IEFjY2Vzc29yczJcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMyA9IEFjY2Vzc29yczNcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IENyZWF0b3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBDcmVhdG9yczJcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID1cbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSB0eXBlIEVsdF9wbGFpbiA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRob3V0X2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRoX2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IE1hcF9pbnRmLldpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG5tb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA9IFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50XG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLkdlbmVyaWNfcGhhbnRvbVxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgKCoqIFRoZSBbb3B0aW9uc10gdHlwZSBpcyB1c2VkIHRvIG1ha2UgW0FjY2Vzc29yc19nZW5lcmljXSBmbGV4aWJsZSBhcyB0byB3aGV0aGVyIGFcbiAgICAgIGNvbXBhcmF0b3IgaXMgcmVxdWlyZWQgdG8gYmUgcGFzc2VkIHRvIGNlcnRhaW4gZnVuY3Rpb25zLiAqKVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcblxuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG5cbiAgKCoqIG92ZXJyaWRlIFtDb250YWluZXJdJ3MgW21lbV0gKilcbiAgdmFsIG1lbSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiBib29sKSBvcHRpb25zXG5cbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2EgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnQpIG9wdGlvbnNcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgbmFtZWQgLT4gKCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgZWx0IC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgZWx0IC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiBmOihbIGBMZWZ0IG9mICdhIGVsdCB8IGBSaWdodCBvZiAnYSBlbHQgfCBgQm90aCBvZiAnYSBlbHQgKiAnYSBlbHQgXSAtPiB1bml0KVxuICAgICAgLT4gdW5pdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQgKiAnYSBlbHQgb3B0aW9uICogKCdhLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBncm91cF9ieVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgZWx0IC0+ICdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdFxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSBlbHQsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICdhIGVsdCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOignYSBlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhIGVsdCwgJ2EgZWx0KSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMwID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMwXG5cbiAgdHlwZSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcbiAgdmFsIGFkZCA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHVuaW9uIDogdCAtPiB0IC0+IHRcbiAgdmFsIGludGVyIDogdCAtPiB0IC0+IHRcbiAgdmFsIGRpZmYgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiB0IC0+IHQgLT4gKGVsdCwgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6IHQgLT4gb2ZfOnQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogdCAtPiB0IC0+IGJvb2xcblxuICB0eXBlIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6IG5hbWVkIC0+IG9mXzpuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiBuYW1lZCAtPiBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+IGVsdCAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6IHQgLT4gaW5pdDonYiAtPiBmOihlbHQgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgdFxuICAgIC0+IHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mIGVsdCB8IGBSaWdodCBvZiBlbHQgfCBgQm90aCBvZiBlbHQgKiBlbHQgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdFxuICB2YWwgcGFydGl0aW9uX3RmIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdCAqIHRcbiAgdmFsIGVsZW1lbnRzIDogdCAtPiBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgbWF4X2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgY2hvb3NlIDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogdCAtPiBlbHRcbiAgdmFsIHNwbGl0IDogdCAtPiBlbHQgLT4gdCAqIGVsdCBvcHRpb24gKiB0XG4gIHZhbCBncm91cF9ieSA6IHQgLT4gZXF1aXY6KGVsdCAtPiBlbHQgLT4gYm9vbCkgLT4gdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdFxuICB2YWwgbnRoIDogdCAtPiBpbnQgLT4gZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgdG9fdHJlZSA6IHQgLT4gdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+IHRcbiAgICAtPiBlbHQgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgdFxuICAgIC0+IGNvbXBhcmU6KGVsdCAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIHRcbiAgICAtPiBzZWdtZW50X29mOihlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gdFxuICAgIC0+IHRcbiAgICAtPiAoZWx0LCBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMVxuXG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogJ2EgdCAtPiAnYSAtPiAnYSB0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHVuaW9uIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGludGVyIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGRpZmYgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAnYSB0IC0+ICdhIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAnYSB0IC0+IG9mXzonYSB0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgdHlwZSAnYSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiAnYSBuYW1lZCAtPiBvZl86J2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgdmFsIGVxdWFsIDogJ2EgbmFtZWQgLT4gJ2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlciA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgZWxlbWVudHMgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogJ2EgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBzcGxpdCA6ICdhIHQgLT4gJ2EgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgdmFsIGdyb3VwX2J5IDogJ2EgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAnYSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAnYSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzFfcGhhbnRvbV9pbnZhcmlhbnRcblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIG5hbWVkIC0+ICgnYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIHNwbGl0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZ3JvdXBfYnkgOiAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMV9waGFudG9tX2ludmFyaWFudFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCB1bmlvblxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgaW50ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIGRpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaXNfc3Vic2V0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IG9mXzooJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGFyZV9kaXNqb2ludFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdHlwZSAoJ2EsICdjbXApIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gb2ZfOignYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhIC0+ICdhY2N1bSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGdyb3VwX2J5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG5cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gIHZhbCByZW1vdmVfaW5kZXhcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG4oKiogQ29uc2lzdGVuY3kgY2hlY2tzIChzYW1lIGFzIGluIFtDb250YWluZXJdKS4gKilcbm1vZHVsZSBDaGVja19hY2Nlc3NvcnNcbiAgICAoVCA6IFQyKVxuICAgIChUcmVlIDogVDIpXG4gICAgKEVsdCA6IFQxKVxuICAgIChOYW1lZCA6IFQyKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMwIChNIDogQWNjZXNzb3JzMCkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciAoTSA6IEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wLCAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXAsICdhIGVsdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXAsICdhIGVsdCBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2EsICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdhIGVsdCkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfLCAnYSBlbHQgbGlzdCAtPiAnYSBlbHQgbGlzdCkgb3B0aW9uc1xuXG4gICgqKiBUaGUgdHlwZXMgb2YgW21hcF0gYW5kIFtmaWx0ZXJfbWFwXSBhcmUgc3VidGxlLiAgVGhlIGlucHV0IHNldCwgWygnYSwgXykgc2V0XSxcbiAgICAgIHJlZmxlY3RzIHRoZSBmYWN0IHRoYXQgdGhlc2UgZnVuY3Rpb25zIHRha2UgYSBzZXQgb2YgKmFueSogdHlwZSwgd2l0aCBhbnlcbiAgICAgIGNvbXBhcmF0b3IsIHdoaWxlIHRoZSBvdXRwdXQgc2V0LCBbKCdiLCAnY21wKSB0XSwgcmVmbGVjdHMgdGhhdCB0aGUgb3V0cHV0IHNldCBoYXNcbiAgICAgIHRoZSBwYXJ0aWN1bGFyIFsnY21wXSBvZiB0aGUgY3JlYXRpb24gZnVuY3Rpb24uICBUaGUgY29tcGFyYXRvciBjYW4gY29tZSBpbiBvbmUgb2ZcbiAgICAgIHRocmVlIHdheXMsIGRlcGVuZGluZyBvbiB3aGljaCBzZXQgbW9kdWxlIGlzIHVzZWRcblxuICAgICAgLSBbU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBjb21lcyBhcyBhbiBhcmd1bWVudFxuICAgICAgLSBbU2V0LlBvbHkubWFwXSAtLSBjb21wYXJhdG9yIGlzIHBvbHltb3JwaGljIGNvbXBhcmlzb25cbiAgICAgIC0gW0Zvby5TZXQubWFwXSAtLSBjb21wYXJhdG9yIGlzIFtGb28uY29tcGFyYXRvcl0gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0KSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogKCdiLCAnY21wLCAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBlbHQgb3B0aW9uKSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCwgKCdhIGVsdCwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlIHRcbiAgdHlwZSB0cmVlXG4gIHR5cGUgZWx0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogdFxuICB2YWwgc2luZ2xldG9uIDogZWx0IC0+IHRcbiAgdmFsIHVuaW9uX2xpc3QgOiB0IGxpc3QgLT4gdFxuICB2YWwgb2ZfbGlzdCA6IGVsdCBsaXN0IC0+IHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogZWx0IFNlcXVlbmNlLnQgLT4gdFxuICB2YWwgb2ZfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogZWx0IGFycmF5IC0+IHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IGVsdCBhcnJheSAtPiB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+IGVsdCkgLT4gdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiBlbHQgbGlzdCAtPiBlbHQgbGlzdFxuICB2YWwgbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0KSAtPiB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0IG9wdGlvbikgLT4gdFxuICB2YWwgb2ZfdHJlZSA6IHRyZWUgLT4gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCB1bmlvbl9saXN0IDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogJ2EgU2VxdWVuY2UudCAtPiAnYSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgb2ZfdHJlZSA6ICdhIHRyZWUgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhKSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAoJ2IsICdjbXApIHRcbiAgdmFsIG9mX3RyZWUgOiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB1bmlvbl9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0XG5cbiAgdmFsIG1hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdiLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsIF8pIHNldFxuICAgIC0+IGY6KCdhIC0+ICdiKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2IsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgXykgc2V0XG4gICAgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl90cmVlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzXG4gICAgKFQgOiBUMilcbiAgICAoVHJlZSA6IFQyKVxuICAgIChFbHQgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IENyZWF0b3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczAgKE0gOiBDcmVhdG9yczApID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgKE0gOiBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgb3B0aW9uc1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBlbHRcbiAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBjbXBcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczBcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMwXG4gICAgd2l0aCB0eXBlIHQgOj0gdFxuICAgIHdpdGggdHlwZSB0cmVlIDo9IHRyZWVcbiAgICB3aXRoIHR5cGUgZWx0IDo9IGVsdFxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMxXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3QgOiAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCAnY21wKSB0IC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+ICgnZWx0LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdCA6IChtb2R1bGUgQ29tcGFyZV9tKSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsX21fX3QgOiAobW9kdWxlIEVxdWFsX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2VsdClcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdlbHQsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5cbiAgdmFsIGhhc2hfbV9fdCA6IChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KSAtPiAoJ2VsdCwgXykgdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXQgPSBzaWdcbiAgKCoqIFNldHMgYmFzZWQgb24geyFDb21wYXJhdG9yLlN9LlxuXG4gICAgICBDcmVhdG9ycyByZXF1aXJlIGEgY29tcGFyYXRvciBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4sIHdoZXJlYXMgYWNjZXNzb3JzIHVzZSB0aGVcbiAgICAgIGNvbXBhcmF0b3IgcHJvdmlkZWQgYnkgdGhlIGlucHV0IHNldC4gKilcblxuICAoKiogVGhlIHR5cGUgb2YgYSBzZXQuICBUaGUgZmlyc3QgdHlwZSBwYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgYW5kXG4gICAgICB0aGUgc2Vjb25kIGlkZW50aWZpZXMgdGhlIGNvbXBhcmF0b3IsIHdoaWNoIGRldGVybWluZXMgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdFxuICAgICAgaXMgdXNlZCBmb3Igb3JkZXJpbmcgZWxlbWVudHMgaW4gdGhpcyBzZXQuICBNYW55IG9wZXJhdGlvbnMgKGUuZy4sIHshdW5pb259KSxcbiAgICAgIHJlcXVpcmUgdGhhdCB0aGV5IGJlIHBhc3NlZCBzZXRzIHdpdGggdGhlIHNhbWUgZWxlbWVudCB0eXBlIGFuZCB0aGUgc2FtZSBjb21wYXJhdG9yXG4gICAgICB0eXBlLiAqKVxuICB0eXBlICgnZWx0LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnZWx0LCAnY21wKSB0IDo9ICgnZWx0LCAnY21wKSB0XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9ICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjEtMTJdIHVzZSBbQ29tcGFyYXRvci5Nb2R1bGUudF0gaW5zdGVhZFwiXVxuXG4gICgqKiBUZXN0cyBpbnRlcm5hbCBpbnZhcmlhbnRzIG9mIHRoZSBzZXQgZGF0YSBzdHJ1Y3R1cmUuICBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcy4gKilcbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBvdGhlciBtYXAvc2V0L2V0Y1xuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBDcmVhdGVzIGFuIGVtcHR5IHNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gKilcbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yIHRoYXQgY29udGFpbnMgb25seSB0aGUgcHJvdmlkZWRcbiAgICAgIGVsZW1lbnQuICopXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIGNhcmRpbmFsaXR5IG9mIHRoZSBzZXQuIFtPKDEpXS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuXG4gICgqKiBbaXNfZW1wdHkgdF0gaXMgW3RydWVdIGlmZiBbdF0gaXMgZW1wdHkuICBbTygxKV0uICopXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogW21lbSB0IGFdIHJldHVybnMgW3RydWVdIGlmZiBbYV0gaXMgaW4gW3RdLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBib29sXG5cbiAgKCoqIFthZGQgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSBhZGRlZCB0byBbdF0sIG9yIHJldHVybnMgW3RdIGlmIFttZW0gdCBhXS5cbiAgICAgIFtPKGxvZyBuKV0uICopXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtyZW1vdmUgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSByZW1vdmVkIGZyb20gW3RdIGlmIFttZW0gdCBhXSwgb3IgcmV0dXJucyBbdF1cbiAgICAgIG90aGVyd2lzZS4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiB0MSB0Ml0gcmV0dXJucyB0aGUgdW5pb24gb2YgdGhlIHR3byBzZXRzLiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiBjIGxpc3RdIHJldHVybnMgdGhlIHVuaW9uIG9mIGFsbCB0aGUgc2V0cyBpbiBbbGlzdF0uICBUaGVcbiAgICAgIFtjb21wYXJhdG9yXSBhcmd1bWVudCBpcyByZXF1aXJlZCBmb3IgdGhlIGNhc2Ugd2hlcmUgW2xpc3RdIGlzIGVtcHR5LlxuICAgICAgW08obWF4KExpc3QubGVuZ3RoIGxpc3QsIG4gbG9nIG4pKV0sIHdoZXJlIFtuXSBpcyB0aGUgc3VtIG9mIHNpemVzIG9mIHRoZSBpbnB1dCBzZXRzLiAqKVxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ludGVyIHQxIHQyXSBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHNldHMgW3QxXSBhbmQgW3QyXS4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2RpZmYgdDEgdDJdIGNvbXB1dGVzIHRoZSBzZXQgZGlmZmVyZW5jZSBbdDEgLSB0Ml0sIGkuZS4sIHRoZSBzZXQgY29udGFpbmluZyBhbGxcbiAgICAgIGVsZW1lbnRzIGluIFt0MV0gdGhhdCBhcmUgbm90IGluIFt0Ml0uICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDJdIHJldHVybnMgYSBzZXF1ZW5jZSBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS4gSXQgaXNcbiAgICAgIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50IG9mXG4gICAgICBzdHJ1Y3R1cmUuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gICgqKiBbY29tcGFyZV9kaXJlY3QgdDEgdDJdIGNvbXBhcmVzIHRoZSBzZXRzIFt0MV0gYW5kIFt0Ml0uICBJdCByZXR1cm5zIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgYXMgW2NvbXBhcmVdLCBidXQgdW5saWtlIGNvbXBhcmUsIGRvZXNuJ3QgcmVxdWlyZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGluIGZvciB0aGVcbiAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgc2V0LiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBzZXRzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIHMpLmNvbXBhcmVdIG9mIHRoZSBzZXQgW3NdIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2EgSGFzaC5mb2xkZXIgLT4gKCdhLCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZSB0d28gc2V0cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildICopXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbZXhpc3RzIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiB0aGVyZSBleGlzdHMgYW4gW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYV0uICBbTyhuKV0sXG4gICAgICBidXQgcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW2YgYV0uICopXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbZm9yX2FsbCB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgZm9yIGFsbCBbYV0gaW4gW3RdLCBbZiBhXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXNcbiAgICAgIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbbm90IChmIGEpXS4gKilcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbY291bnQgdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgW3RydWVdLlxuICAgICAgW08obildLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFtzdW0gdF0gcmV0dXJucyB0aGUgc3VtIG9mIFtmIHRdIGZvciBlYWNoIFt0XSBpbiB0aGUgc2V0LlxuICAgICAgW08obildLiAqKVxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gICgqKiBbZmluZCB0IGZdIHJldHVybnMgYW4gZWxlbWVudCBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIHRydWUsIHdpdGggbm8gZ3VhcmFudGVlIGFzXG4gICAgICB0byB3aGljaCBlbGVtZW50IGlzIHJldHVybmVkLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGUgZWxlbWVudCBpc1xuICAgICAgZm91bmQuICopXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbZmluZF9tYXAgdCBmXSByZXR1cm5zIFtiXSBmb3Igc29tZSBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhID0gU29tZSBiXS4gIElmIG5vIHN1Y2hcbiAgICAgIFthXSBleGlzdHMsIHRoZW4gW2ZpbmRdIHJldHVybnMgW05vbmVdLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGVcbiAgICAgIGVsZW1lbnQgaXMgZm91bmQuICopXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gICgqKiBMaWtlIFtmaW5kXSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gZmFpbHVyZS4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG5cbiAgKCoqIFtudGggdCBpXSByZXR1cm5zIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IG9mIFt0XSwgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlXG4gICAgICBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbTm9uZV0gaWYgW2kgPCAwXSBvciBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gICgqKiBbcmVtb3ZlX2luZGV4IHQgaV0gcmV0dXJucyBhIHZlcnNpb24gb2YgW3RdIHdpdGggdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgcmVtb3ZlZCxcbiAgICAgIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZSBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbdF0gaWYgW2kgPCAwXSBvclxuICAgICAgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIHRydWUgaWZmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXS4gKilcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2FyZV9kaXNqb2ludCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIFtpc19lbXB0eSAoaW50ZXIgdDEgdDIpXSwgYnV0IGlzIG1vcmVcbiAgICAgIGVmZmljaWVudC4gKilcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbTmFtZWRdIGFsbG93cyB0aGUgdmFsaWRhdGlvbiBvZiBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBzZXRzLiAgQVxuICAgICAgW05hbWVkLnRdIGlzIGEgcmVjb3JkIG9mIGEgc2V0IGFuZCBhIG5hbWUsIHdoZXJlIHRoZSBuYW1lIGlzIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXMsXG4gICAgICBhbmQgW05hbWVkLmlzX3N1YnNldF0gYW5kIFtOYW1lZC5lcXVhbF0gdmFsaWRhdGUgc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzXG4gICAgICByZXNwZWN0aXZlbHkuXG5cbiAgICAgIFRoZSBlcnJvciBtZXNzYWdlIGZvciwgZS5nLixcbiAgICAgIHtbXG4gICAgICAgIE5hbWVkLmlzX3N1YnNldCB7IHNldCA9IHNldDE7IG5hbWUgPSBcInNldDFcIiB9IH5vZl86e3NldCA9IHNldDI7IG5hbWUgPSBcInNldDJcIiB9XG4gICAgICBdfVxuXG4gICAgICBsb29rcyBsaWtlXG4gICAgICB7dlxuICAgICAgICAoXCJzZXQxIGlzIG5vdCBhIHN1YnNldCBvZiBzZXQyXCIgKGludmFsaWRfZWxlbWVudHMgKC4uLmVsZW1lbnRzIG9mIHNldDEgLSBzZXQyLi4uKSkpXG4gICAgIHZ9XG5cbiAgICAgIHNvIFtuYW1lXSBzaG91bGQgYmUgYSBub3VuIHBocmFzZSB0aGF0IGRvZXNuJ3Qgc291bmQgYXdrd2FyZCBpbiB0aGUgYWJvdmUgZXJyb3JcbiAgICAgIG1lc3NhZ2UuICBFdmVuIHRob3VnaCBpdCBhZGRzIHZlcmJvc2l0eSwgY2hvb3NpbmcgW25hbWVdcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHBocmFzZVxuICAgICAgXCJ0aGUgc2V0IG9mXCIgb2Z0ZW4gbWFrZXMgdGhlIGVycm9yIG1lc3NhZ2Ugc291bmQgbW9yZSBuYXR1cmFsLlxuICAqKVxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyBzZXQgOiAoJ2EsICdjbXApIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXSBhbmQgYVxuICAgICAgICBodW1hbi1yZWFkYWJsZSBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGVxdWFsIHRvIFt0Ml0gYW5kIGEgaHVtYW4tcmVhZGFibGVcbiAgICAgICAgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICAoKiogVGhlIGxpc3Qgb3IgYXJyYXkgZ2l2ZW4gdG8gW29mX2xpc3RdIGFuZCBbb2ZfYXJyYXldIG5lZWQgbm90IGJlIHNvcnRlZC4gKilcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdG9fbGlzdF0gYW5kIFt0b19hcnJheV0gcHJvZHVjZSBzZXF1ZW5jZXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICBjb21wYXJhdG9yLiAqKVxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG5cbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfKSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIENyZWF0ZSBzZXQgZnJvbSBzb3J0ZWQgYXJyYXkuICBUaGUgaW5wdXQgbXVzdCBiZSBzb3J0ZWQgKGVpdGhlciBpbiBhc2NlbmRpbmcgb3JcbiAgICAgIGRlc2NlbmRpbmcgb3JkZXIgYXMgZ2l2ZW4gYnkgdGhlIGNvbXBhcmF0b3IpIGFuZCBjb250YWluIG5vIGR1cGxpY2F0ZXMsIG90aGVyd2lzZSB0aGVcbiAgICAgIHJlc3VsdCBpcyBhbiBlcnJvci4gIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgW08obildLiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBTaW1pbGFyIHRvIFtvZl9zb3J0ZWRfYXJyYXldLCBidXQgd2l0aG91dCBjaGVja2luZyB0aGUgaW5wdXQgYXJyYXkuICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIGMgfmxlbiB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGNcbiAgICAgIChBcnJheS5pbml0IGxlbiB+ZildLCB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIHRoYXQgYSBkZWNyZWFzaW5nIG9yZGVyIGlzIG5vdFxuICAgICAgc3VwcG9ydGVkLiAgVGhlIGFkdmFudGFnZSBpcyBub3QgcmVxdWlyaW5nIHlvdSB0byBhbGxvY2F0ZSBhbiBpbnRlcm1lZGlhdGUgYXJyYXkuICBbZl1cbiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggMCwgMSwgLi4uIFtsZW4gLSAxXSwgaW4gb3JkZXIuICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtzdGFibGVfZGVkdXBfbGlzdF0gaXMgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgW0xpc3RdIG1vZHVsZSBiZWNhdXNlIHRoZVxuICAgICAgaW1wbGVtZW50YXRpb24gcmVsaWVzIGNydWNpYWxseSBvbiBzZXRzLCBhbmQgYmVjYXVzZSBkb2luZyBzbyBhbGxvd3Mgb25lIHRvIGF2b2lkIHVzZXNcbiAgICAgIG9mIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYnkgaW5zdGFudGlhdGluZyB0aGUgZnVuY3RvciBhdCBhIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgb2YgW0NvbXBhcmF0b3JdIGFuZCB1c2luZyB0aGUgcmVzdWx0aW5nIFtzdGFibGVfZGVkdXBfbGlzdF0uICopXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICgnYSwgXykgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICAoKiogW21hcCBjIHQgfmZdIHJldHVybnMgYSBuZXcgc2V0IGNyZWF0ZWQgYnkgYXBwbHlpbmcgW2ZdIHRvIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgIFt0XS4gIFRoZSByZXR1cm5lZCBzZXQgaXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIFtjb21wYXJhdG9yXS4gIFtPKG4gbG9nIG4pXS4gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIHshbWFwfSwgZXhjZXB0IGVsZW1lbnRzIGZvciB3aGljaCBbZl0gcmV0dXJucyBbTm9uZV0gd2lsbCBiZSBkcm9wcGVkLiAgKilcbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICAoJ2IsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyB0aGUgc3Vic2V0IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAgW08obiBsb2dcbiAgICAgIG4pXS4gKilcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3QuICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgfmluaXQgfmZdIGZvbGRzIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXQgZnJvbSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdCwgc2hvcnQgY2lyY3VpdGluZyB0aGUgZm9sZCBpZiBbZiBhY2N1bSB4XSBpcyBhbiBbRXJyb3IgX10gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG5cbiAgKCoqIExpa2UgeyFmb2xkfSwgZXhjZXB0IHRoYXQgaXQgZ29lcyBmcm9tIHRoZSBsYXJnZXN0IHRvIHRoZSBzbWFsbGVzdCBlbGVtZW50LiAqKVxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYSAtPiAnYWNjdW0gLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2l0ZXIgdCB+Zl0gY2FsbHMgW2ZdIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgW3RdLCBnb2luZyBpbiBvcmRlciBmcm9tIHRoZSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdC4gICopXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZSB0d28gc2V0cyBzaWRlIGJ5IHNpZGUuICBDb21wbGV4aXR5IGlzIFtPKG0rbildIHdoZXJlIFttXSBhbmQgW25dIGFyZSB0aGUgc2l6ZXNcbiAgICAgIG9mIHRoZSB0d28gaW5wdXQgc2V0cy4gIEFzIGFuIGV4YW1wbGUsIHdpdGggdGhlIGlucHV0cyBbMDsgMV0gYW5kIFsxOyAyXSwgW2ZdIHdpbGwgYmVcbiAgICAgIGNhbGxlZCB3aXRoIFtgTGVmdCAwXTsgW2BCb3RoICgxLCAxKV07IGFuZCBbYFJpZ2h0IDJdLiAqKVxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBpZiBbYSwgYiA9IHBhcnRpdGlvbl90ZiBzZXQgfmZdIHRoZW4gW2FdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZWQgW3RydWVdLFxuICAgICAgYW5kIFtiXSBpcyB0aGUgZWxlbWVudHMgb24gd2hpY2ggW2ZdIHByb2R1Y2VzIFtmYWxzZV0uICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIFNhbWUgYXMgeyF0b19saXN0fS4gKilcbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFtaW5fZWx0fSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBnaXZlbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBSZXR1cm5zIHRoZSBsYXJnZXN0IGVsZW1lbnQgb2YgdGhlIHNldC4gIFtPKGxvZyBuKV0uICAqKVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1heF9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIHJldHVybnMgYW4gYXJiaXRyYXJ5IGVsZW1lbnQsIG9yIFtOb25lXSBpZiB0aGUgc2V0IGlzIGVtcHR5LiAqKVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshY2hvb3NlfSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBbc3BsaXQgdCB4XSBwcm9kdWNlcyBhIHRyaXBsZSBbKHQxLCBtYXliZV94LCB0MildIHdoZXJlIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50c1xuICAgICAgc3RyaWN0bHkgbGVzcyB0aGFuIFt4XSwgW21heWJlX3hdIGlzIHRoZSBtZW1iZXIgKGlmIGFueSkgb2YgW3RdIHdoaWNoIGNvbXBhcmVzIGVxdWFsXG4gICAgICB0byBbeF0sIGFuZCBbdDJdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgc3RyaWN0bHkgbGFyZ2VyIHRoYW4gW3hdLiAqKVxuICB2YWwgc3BsaXQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIGlmIFtlcXVpdl0gaXMgYW4gZXF1aXZhbGVuY2UgcHJlZGljYXRlLCB0aGVuIFtncm91cF9ieSBzZXQgfmVxdWl2XSBwcm9kdWNlcyBhIGxpc3RcbiAgICAgIG9mIGVxdWl2YWxlbmNlIGNsYXNzZXMgKGkuZS4sIGEgc2V0LXRoZW9yZXRpYyBxdW90aWVudCkuICBFLmcuLFxuXG4gICAgICB7W1xuICAgICAgICBsZXQgY2hhcnMgPSBTZXQub2ZfbGlzdCBbJ0EnOyAnYSc7ICdiJzsgJ2MnXSBpblxuICAgICAgICBsZXQgZXF1aXYgYyBjJyA9IENoYXIuZXF1YWwgKENoYXIudXBwZXJjYXNlIGMpIChDaGFyLnVwcGVyY2FzZSBjJykgaW5cbiAgICAgICAgZ3JvdXBfYnkgY2hhcnMgfmVxdWl2XG4gICAgICBdfVxuXG4gICAgICBwcm9kdWNlczpcblxuICAgICAge1tcbiAgICAgICAgW1NldC5vZl9saXN0IFsnQSc7J2EnXTsgU2V0LnNpbmdsZXRvbiAnYic7IFNldC5zaW5nbGV0b24gJ2MnXVxuICAgICAgXX1cblxuICAgICAgW2dyb3VwX2J5XSBydW5zIGluIE8obl4yKSB0aW1lLCBzbyBpZiB5b3UgaGF2ZSBhIGNvbXBhcmlzb24gZnVuY3Rpb24sIGl0J3MgdXN1YWxseVxuICAgICAgbXVjaCBmYXN0ZXIgdG8gdXNlIFtTZXQub2ZfbGlzdF0uICopXG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3RcblxuICAoKiogW3RvX3NlcXVlbmNlIHRdIGNvbnZlcnRzIHRoZSBzZXQgW3RdIHRvIGEgc2VxdWVuY2Ugb2YgdGhlIGVsZW1lbnRzIGJldHdlZW5cbiAgICAgIFtncmVhdGVyX29yX2VxdWFsX3RvXSBhbmQgW2xlc3Nfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSBpbiB0aGUgb3JkZXIgaW5kaWNhdGVkIGJ5XG4gICAgICBbb3JkZXJdLiAgSWYgW2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBsZXNzX29yX2VxdWFsX3RvXSB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuICBDb3N0IGlzXG4gICAgICBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgZm9yIGVhY2ggZWxlbWVudCBwcm9kdWNlZC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIGVsZW1lbnQgaW4gW3RdIHNwZWNpZmllZCBieVxuICAgICAgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgc2VnbWVudHMgYXNcbiAgICAgIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VnbWVudCxcbiAgICAgIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC4gIEl0IHJldHVybnNcbiAgICAgIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBQcm9kdWNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIHR3byBzZXRzIGJldHdlZW4gW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2xlc3Nfb3JfZXF1YWxfdG9dIGluIFtvcmRlcl0sIG5vdGluZyB3aGV0aGVyIGVhY2ggZWxlbWVudCBhcHBlYXJzIGluIHRoZSBsZWZ0IHNldCxcbiAgICAgIHRoZSByaWdodCBzZXQsIG9yIGJvdGguICBJbiB0aGUgYm90aCBjYXNlLCBib3RoIGVsZW1lbnRzIGFyZSByZXR1cm5lZCwgaW4gY2FzZSB0aGVcbiAgICAgIGNhbGxlciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlbiBlbGVtZW50cyB0aGF0IGFyZSBlcXVhbCB0byB0aGUgc2V0cycgY29tcGFyYXRvci4gIFJ1bnNcbiAgICAgIGluIE8obGVuZ3RoIHQgKyBsZW5ndGggdCcpLiAqKVxuICBtb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnQgPVxuICAgICAgfCBMZWZ0IG9mICdhXG4gICAgICB8IFJpZ2h0IG9mICdiXG4gICAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ19zZXQgPSBTZXQuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IChTdHJpbmcudCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgU2V0LnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtTZXQuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzLFxuICAgICAgaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS4gKilcbiAgbW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyB0ID0gKEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAoKiogQSBwb2x5bW9ycGhpYyBTZXQuICopXG4gIG1vZHVsZSBQb2x5IDogU19wb2x5IHdpdGggdHlwZSAnZWx0IHQgPSAoJ2VsdCwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuXG4gICgqKiBVc2luZyBjb21wYXJhdG9yIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtTZXRdLCBleGNlcHQgdGhlIGZ1bmN0aW9uc1xuICAgICAgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XSB3aGVyZSB0aGUgZnVuY3Rpb25zIGF0IHRoZSB0b3BsZXZlbCBvZlxuICAgICAgW1NldF0gdGFrZXMgYSBbKCdlbHQsICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2VsdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnZWx0KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgICgqKiBBIFtUcmVlLnRdIGNvbnRhaW5zIGp1c3QgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhIHNldCBpcyBiYXNlZCBvbiwgd2l0aG91dFxuICAgICAgICAgIGluY2x1ZGluZyB0aGUgY29tcGFyYXRvci4gIEFjY29yZGluZ2x5LCBhbnkgb3BlcmF0aW9uIG9uIGEgW1RyZWUudF0gbXVzdCBhbHNvIHRha2VcbiAgICAgICAgICBhcyBhbiBhcmd1bWVudCB0aGUgY29ycmVzcG9uZGluZyBjb21wYXJhdG9yLiAqKVxuICAgICAgdHlwZSAoJ2EsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICAgICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgICAgICB7IHRyZWUgOiAoJ2EsICdjbXApIHRcbiAgICAgICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFsIGlzX3N1YnNldFxuICAgICAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiBvZl86KCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICAgICAgdmFsIGVxdWFsXG4gICAgICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgICAgZW5kXG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnRcbiAgICAgICAgd2l0aCBtb2R1bGUgTmFtZWQgOj0gTmFtZWRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXykgdFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzMlxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnZWx0IEhhc2guZm9sZGVyIC0+ICgnZWx0LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgOiBzaWdcbiAgICAgIHZhbCBlbXB0eSA6ICgnYSBFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW1NldF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczAgPSBBY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBBY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBBY2Nlc3NvcnMyXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBBY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBDcmVhdG9yczBcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gQ3JlYXRvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IENyZWF0b3JzMlxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yID0gQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9XG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgRWx0X3BsYWluID0gRWx0X3BsYWluXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNldF9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBFbXB0eVxuICAgICgqIChMZWFmIHgpIGlzIHRoZSBzYW1lIGFzIChOb2RlIChFbXB0eSwgeCwgRW1wdHksIDEsIDEpKSBidXQgdXNlcyBsZXNzIHNwYWNlLiAqKVxuICAgIHwgTGVhZiBvZiAnYVxuICAgICgqIGZpcnN0IGludCBpcyBoZWlnaHQsIHNlY29uZCBpcyBzdWItdHJlZSBzaXplICopXG4gICAgfCBOb2RlIG9mICdhIHQgKiAnYSAqICdhIHQgKiBpbnQgKiBpbnRcblxuICB0eXBlICdhIHRyZWUgPSAnYSB0XG5cbiAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGUgY2hpbGRyZW4gZGlmZmVyIGJ5XG4gICAgIGF0IG1vc3QgMi4gKilcbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICA7O1xuXG4gIGxldCBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHYgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBoLCBuKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgbiA9IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSB2KSBjb21wYXJlX2VsdCBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgdikgdXBwZXIgY29tcGFyZV9lbHQgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfZWx0IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfZWx0IHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBfIHwgTm9kZSBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgIGlmIGggPSAxXG4gICAgdGhlbiBMZWFmIHZcbiAgICBlbHNlIChcbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLlNldCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgayA9IGYgaSBpblxuICAgICAgICBMZWFmIGtcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIGtsKSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgKExlYWYga3IpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICAoKiBXZSBkb24ndCBjaGVjayBpZiB0aGUgYXJyYXkgaXMgc29ydGVkIG9yIGtleXMgYXJlIGR1cGxpY2F0ZWQsIGJlY2F1c2UgdGhhdFxuICAgICAgICAgY2hlY2tpbmcgaXMgc2xvd2VyIHRoYW4gdGhlIHdob2xlIFtvZl9zb3J0ZWRfYXJyYXldIGZ1bmN0aW9uICopXG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyIHx8IGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKGkpIGFycmF5LihpICsgMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCkpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gIGxldCBiYWwgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgobCk+aChyKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsciwgXywgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIGxydiAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBsbCk7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBFbXB0eSkgbHJ2IChjcmVhdGUgRW1wdHkgdiByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyciwgXywgXykgLT4gY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChyKT5oKGwpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIChybCwgcnYsIHJyLCBfLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgcmx2IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IHJyKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBFbXB0eSkgcmx2IChjcmVhdGUgRW1wdHkgcnYgcnIpXG4gICAgICAgICAgfCBOb2RlIChybGwsIHJsdiwgcmxyLCBfLCBfKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgaWYgaCA9IDEgdGhlbiBMZWFmIHYgZWxzZSBOb2RlIChsLCB2LCByLCBoLCBzbCArIHNyICsgMSkpXG4gIDs7XG5cbiAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgZXhjZXB0aW9uIFNhbWVcblxuICBsZXQgYWRkIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gTGVhZiB4XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIHJhaXNlIFNhbWVcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGNyZWF0ZSAoTGVhZiB4KSB2IEVtcHR5XG4gICAgICAgIGVsc2UgY3JlYXRlIEVtcHR5IHYgKExlYWYgeClcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByYWlzZSBTYW1lIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmRcbiAgICAgci4gKilcbiAgbGV0IHJlYyBqb2luIGwgdiByIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBhZGQgciB2IH5jb21wYXJlX2VsdFxuICAgIHwgXywgRW1wdHkgLT4gYWRkIGwgdiB+Y29tcGFyZV9lbHRcbiAgICB8IExlYWYgbHYsIF8gLT4gYWRkIChhZGQgciB2IH5jb21wYXJlX2VsdCkgbHYgfmNvbXBhcmVfZWx0XG4gICAgfCBfLCBMZWFmIHJ2IC0+IGFkZCAoYWRkIGwgdiB+Y29tcGFyZV9lbHQpIHJ2IH5jb21wYXJlX2VsdFxuICAgIHwgTm9kZSAobGwsIGx2LCBsciwgbGgsIF8pLCBOb2RlIChybCwgcnYsIHJyLCByaCwgXykgLT5cbiAgICAgIGlmIGxoID4gcmggKyAyXG4gICAgICB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgMlxuICAgICAgdGhlbiBiYWwgKGpvaW4gbCB2IHJsIH5jb21wYXJlX2VsdCkgcnYgcnJcbiAgICAgIGVsc2UgY3JlYXRlIGwgdiByXG4gIDs7XG5cbiAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiB8IE5vZGUgKEVtcHR5LCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgICB8IE5vZGUgKGwsIF8sIF8sIF8sIF8pIC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGFjYyA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AuQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgdmFsdWUgLT4gZiBhY2MgdmFsdWVcbiAgICAgIHwgTm9kZSAobGVmdCwgdmFsdWUsIHJpZ2h0LCBfLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgbGVmdCBhY2Mgd2l0aFxuICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgYWNjIHZhbHVlIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgICAgIHwgQ29udGludWUgYSAtPiBmb2xkX3VudGlsX2hlbHBlciB+ZiByaWdodCBhKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgaW5pdCB3aXRoXG4gICAgfCBDb250aW51ZSB4IC0+IGZpbmlzaCB4XG4gICAgfCBTdG9wIHggLT4geFxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgfCBOb2RlIChfLCB2LCBFbXB0eSwgXywgXykgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCBfLCByLCBfLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgciwgXywgXykgLT4gclxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gYmFsIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG4gIGxldCBjb25jYXQgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+IGpvaW4gdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpIH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzcGxpdCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHNwbGl0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgU29tZSB2LCBFbXB0eVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gRW1wdHksIE5vbmUsIExlYWYgdlxuICAgICAgICBlbHNlIExlYWYgdiwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBsLCBTb21lIHYsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGwsIG1heWJlX2VsdCwgcmwgPSBzcGxpdCBsIGluXG4gICAgICAgICAgbGwsIG1heWJlX2VsdCwgam9pbiBybCB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbHIsIG1heWJlX2VsdCwgcnIgPSBzcGxpdCByIGluXG4gICAgICAgICAgam9pbiBsIHYgbHIgfmNvbXBhcmVfZWx0LCBtYXliZV9lbHQsIHJyKVxuICAgIGluXG4gICAgc3BsaXQgdFxuICA7O1xuXG4gICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IHJlYyBtZW0gdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDBcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDAgfHwgbWVtIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24geCA9IExlYWYgeFxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIHYgLT4gaWYgY29tcGFyZV9lbHQgeCB2ID0gMCB0aGVuIEVtcHR5IGVsc2UgcmFpc2UgU2FtZVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgciBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0Ol8gPVxuICAgIGxldCByZWMgYXV4IHQgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIF8gLT4gaWYgaSA9IDAgdGhlbiBFbXB0eSBlbHNlIHJhaXNlIFNhbWVcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsIGkpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByIChpIC0gbF9zaXplIC0gMSkpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgaSB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgdW5pb24gczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgICAgICB8IExlYWYgdjEsIF8gLT4gdW5pb24gKE5vZGUgKEVtcHR5LCB2MSwgRW1wdHksIDEsIDEpKSBzMlxuICAgICAgICB8IF8sIExlYWYgdjIgLT4gdW5pb24gczEgKE5vZGUgKEVtcHR5LCB2MiwgRW1wdHksIDEsIDEpKVxuICAgICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIGgxLCBfKSwgTm9kZSAobDIsIHYyLCByMiwgaDIsIF8pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDJcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDFcbiAgICAgICAgICAgIHRoZW4gYWRkIHMxIHYyIH5jb21wYXJlX2VsdFxuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIGxldCBsMiwgXywgcjIgPSBzcGxpdCBzMiB2MSB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMikgfmNvbXBhcmVfZWx0KVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgdW5pb24gczEgczJcbiAgOztcblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSB4cyA9XG4gICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBMaXN0LmZvbGQgeHMgfmluaXQ6ZW1wdHkgfmY6KGZ1biBhYyB4IC0+IHVuaW9uIGFjICh0b190cmVlIHgpIH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgaW50ZXIgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSAtPlxuICAgICAgICAgIGlmIG1lbSBvdGhlcl9zZXQgZWx0IH5jb21wYXJlX2VsdCB0aGVuIHNpbmdsZXRvbiBlbHNlIEVtcHR5XG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMikgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgIHwgbDIsIFNvbWUgdjEsIHIyIC0+IGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICBpbnRlciBzMSBzMlxuICA7O1xuXG4gIGxldCBkaWZmIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gRW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIC0+IEVtcHR5XG4gICAgICAgIHwgdDEsIEVtcHR5IC0+IHQxXG4gICAgICAgIHwgTGVhZiB2MSwgdDIgLT4gZGlmZiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHQyXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgfCBsMiwgU29tZSBfLCByMiAtPiBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgZGlmZiBzMSBzMlxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnYSwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdhICogJ2EgdHJlZSAqICgnYSwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHMgKGUgOiAoXywgaW5jcmVhc2luZykgdCkgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHYgLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCBzIChlIDogKF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB2IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc2V0IHMgOiAoXywgaW5jcmVhc2luZykgdCA9IGNvbnMgcyBFbmRcbiAgICBsZXQgb2Zfc2V0X3JpZ2h0IHMgOiAoXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgcyBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgdiAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgRW1wdHksIDEsIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgciwgXywgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHYgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIEVtcHR5LCAxLCAxKSkgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIF8sIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBsb29wIHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgZTEgZTIgPVxuICAgICAgbGV0IHJlYyBsb29wIGUxIGUyID1cbiAgICAgICAgbWF0Y2ggZTEsIGUyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgcjEsIGUxKSwgTW9yZSAodjIsIHIyLCBlMikgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBpZiBwaHlzX2VxdWFsIHIxIHIyXG4gICAgICAgICAgdGhlbiBsb29wIGUxIGUyXG4gICAgICAgICAgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMilcbiAgICAgIGluXG4gICAgICBsb29wIGUxIGUyXG4gICAgOztcblxuICAgIGxldCByZWMgaXRlciB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiAoKVxuICAgICAgfCBNb3JlIChhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBmIGE7XG4gICAgICAgIGl0ZXIgKGNvbnMgdHJlZSBlbnVtKSB+ZlxuICAgIDs7XG5cbiAgICBsZXQgaXRlcjIgY29tcGFyZV9lbHQgdDEgdDIgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAoKVxuICAgICAgICB8IEVuZCwgXyAtPiBpdGVyIHQyIH5mOihmdW4gYSAtPiBmIChgUmlnaHQgYSkpXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKVxuICAgICAgICB8IE1vcmUgKGExLCB0cmVlMSwgZW51bTEpLCBNb3JlIChhMiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBmIChgQm90aCAoYTEsIGEyKSk7XG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBMZWZ0IGExKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgZiAoYFJpZ2h0IGEyKTtcbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA6ICgoXywgXykgRWl0aGVyLnQsIF8pIFNlcXVlbmNlLlN0ZXAudCA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBEb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChlbHQsIHRyZWUsIGVudW0pIC0+IFlpZWxkIChTZWNvbmQgZWx0LCAoRW5kLCBjb25zIHRyZWUgZW51bSkpXG4gICAgICAgIHwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSwgRW5kIC0+IFlpZWxkIChGaXJzdCBlbHQsIChjb25zIHRyZWUgZW51bSwgRW5kKSlcbiAgICAgICAgfCAoTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChhMiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2VsdCBhMSBhMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICAgIHRoZW4gZW51bTEsIGVudW0yXG4gICAgICAgICAgICAgIGVsc2UgY29ucyB0cmVlMSBlbnVtMSwgY29ucyB0cmVlMiBlbnVtMlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFNraXAgbmV4dF9zdGF0ZSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gWWllbGQgKEZpcnN0IGExLCAoY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQpKVxuICAgICAgICAgIGVsc2UgWWllbGQgKFNlY29uZCBhMiwgKGxlZnQsIGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKGssIEVudW0uY29ucyB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkIChrLCBFbnVtLmNvbnNfcmlnaHQgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2VsdCA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2VsdCBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSBlbHQgLT4gYWRkIHQgZWx0IH5jb21wYXJlX2VsdFxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGdyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMClcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB4ID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgICAgIHQnXG4gICAgPVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQpXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCcpXG4gICAgICB+Y29tcGFyZTpcbiAgICAgICAgKG1hdGNoIG9yZGVyIHdpdGhcbiAgICAgICAgIHwgYEluY3JlYXNpbmcgLT4gY29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB8IGBEZWNyZWFzaW5nIC0+IEZuLmZsaXAgY29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHMxIHMyIH5jb21wYXJlX2VsdCA9IEVudW0uaXRlcjIgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIGxldCBlcXVhbCBzMSBzMiB+Y29tcGFyZV9lbHQgPSBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID0gMFxuXG4gIGxldCBpc19zdWJzZXQgczEgfm9mXzpzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaXNfc3Vic2V0IHMxIH5vZl86czIgPVxuICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgIHwgRW1wdHksIF8gLT4gdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBMZWFmIHYxLCB0MiAtPiBtZW0gdDIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCBMZWFmIHYyIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiByYXRoZXIgdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCAoTm9kZSAobDIsIHYyLCByMiwgXywgXykgYXMgdDIpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHBoeXNfZXF1YWwgczEgczIgfHwgKGlzX3N1YnNldCBsMSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnIyKVxuICAgICAgICAgICgqIE5vdGUgdGhhdCBoZWlnaHQgYW5kIHNpemUgZG9uJ3QgbWF0dGVyIGhlcmUuICopXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBpc19zdWJzZXQgKE5vZGUgKGwxLCB2MSwgRW1wdHksIDAsIDApKSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnQyXG4gICAgICAgIGVsc2UgaXNfc3Vic2V0IChOb2RlIChFbXB0eSwgdjEsIHIxLCAwLCAwKSkgfm9mXzpyMiAmJiBpc19zdWJzZXQgbDEgfm9mXzp0MlxuICAgIGluXG4gICAgaXNfc3Vic2V0IHMxIH5vZl86czJcbiAgOztcblxuICBsZXQgcmVjIGFyZV9kaXNqb2ludCBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgZWx0LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgZWx0IC0+IG5vdCAobWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0KVxuICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIGZhbHNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT5cbiAgICAgICAgICBhcmVfZGlzam9pbnQgbDEgbDIgfmNvbXBhcmVfZWx0ICYmIGFyZV9kaXNqb2ludCByMSByMiB+Y29tcGFyZV9lbHRcbiAgICAgICAgfCBfLCBTb21lIF8sIF8gLT4gZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9XG4gICAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgTGVhZiB2IC0+IGYgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IHJlYyBmb2xkIHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHYgLT4gZiBhY2N1IHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpIHYpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfZWxlbSBzdGF0ZSB0ID1cbiAgICBmb2xkIHQgfmluaXQ6KGhhc2hfZm9sZF9pbnQgc3RhdGUgKGxlbmd0aCB0KSkgfmY6aGFzaF9mb2xkX2VsZW1cbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIHYgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIHYgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgcmVjIGZvcl9hbGwgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgdiAtPiBwIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IHAgdiAmJiBmb3JfYWxsIH5mOnAgbCAmJiBmb3JfYWxsIH5mOnAgclxuICA7O1xuXG4gIGxldCByZWMgZXhpc3RzIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2IHx8IGV4aXN0cyB+ZjpwIGwgfHwgZXhpc3RzIH5mOnAgclxuICA7O1xuXG4gIGxldCBmaWx0ZXIgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPiBpZiBwIHYgdGhlbiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdCBlbHNlIGFjY3VcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgZmlsdCAoZmlsdCAoaWYgcCB2IHRoZW4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQgZWxzZSBhY2N1KSBsKSByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGZpbHQgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBmaWx0XG4gICAgICAgICAgKGZpbHRcbiAgICAgICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgICAgbClcbiAgICAgICAgICByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgcGFydCAoKHQsIGYpIGFzIGFjY3UpID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT4gaWYgcCB2IHRoZW4gYWRkIHQgdiB+Y29tcGFyZV9lbHQsIGYgZWxzZSB0LCBhZGQgZiB2IH5jb21wYXJlX2VsdFxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBwYXJ0IChwYXJ0IChpZiBwIHYgdGhlbiBhZGQgdCB2IH5jb21wYXJlX2VsdCwgZiBlbHNlIHQsIGFkZCBmIHYgfmNvbXBhcmVfZWx0KSBsKSByXG4gICAgaW5cbiAgICBwYXJ0IChFbXB0eSwgRW1wdHkpIHNcbiAgOztcblxuICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiB2IDo6IGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG4gIDs7XG5cbiAgbGV0IGVsZW1lbnRzIHMgPSBlbGVtZW50c19hdXggW10gc1xuXG4gIGxldCBjaG9vc2UgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgOztcblxuICBsZXQgY2hvb3NlX2V4biA9XG4gICAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU2V0LmNob29zZV9leG46IGVtcHR5IHNldFwiKSBpblxuICAgIGxldCBjaG9vc2VfZXhuIHQgPVxuICAgICAgbWF0Y2ggY2hvb3NlIHQgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHYgLT4gdlxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGNob29zZV9leG5cbiAgOztcblxuICBsZXQgb2ZfbGlzdCBsc3QgfmNvbXBhcmVfZWx0ID1cbiAgICBMaXN0LmZvbGQgbHN0IH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSB+Y29tcGFyZV9lbHQgPVxuICAgIFNlcXVlbmNlLmZvbGQgc2VxdWVuY2UgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IHRvX2xpc3QgcyA9IGVsZW1lbnRzIHNcblxuICBsZXQgb2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQgPVxuICAgIEFycmF5LmZvbGQgYSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICAoKiBmYXN0ZXIgYnV0IGVxdWl2YWxlbnQgdG8gW0FycmF5Lm9mX2xpc3QgKHRvX2xpc3QgdCldICopXG4gIGxldCB0b19hcnJheSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBbfHxdXG4gICAgfCBMZWFmIHYgLT4gW3wgdiB8XVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGxldCByZXMgPSBBcnJheS5jcmVhdGUgfmxlbjpzIHYgaW5cbiAgICAgIGxldCBwb3NfcmVmID0gcmVmIDAgaW5cbiAgICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICAgICgqIEludmFyaWFudDogb24gZW50cnkgYW5kIG9uIGV4aXQgdG8gW2xvb3BdLCAhcG9zX3JlZiBpcyB0aGUgbmV4dFxuICAgICAgICAgICBhdmFpbGFibGUgY2VsbCBpbiB0aGUgYXJyYXkuICopXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZlxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgICAgbG9vcCBsO1xuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgICAgIGxvb3AgclxuICAgICAgaW5cbiAgICAgIGxvb3AgbDtcbiAgICAgICgqIHJlcy4oIXBvc19yZWYpIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgKGJ5IEFycmF5LmNyZWF0ZSB+bGVuOmFib3ZlKS4gKilcbiAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgIGxvb3AgcjtcbiAgICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiB+Y29tcGFyZV9lbHQgPSBmb2xkIHQgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgKGYgeCkgfmNvbXBhcmVfZWx0KVxuXG4gIGxldCBncm91cF9ieSBzZXQgfmVxdWl2IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHNldCBlcXVpdl9jbGFzc2VzID1cbiAgICAgIGlmIGlzX2VtcHR5IHNldFxuICAgICAgdGhlbiBlcXVpdl9jbGFzc2VzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHggPSBjaG9vc2VfZXhuIHNldCBpblxuICAgICAgICBsZXQgZXF1aXZfeCwgbm90X2VxdWl2X3ggPVxuICAgICAgICAgIHBhcnRpdGlvbl90ZiBzZXQgfmY6KGZ1biBlbHQgLT4gcGh5c19lcXVhbCB4IGVsdCB8fCBlcXVpdiB4IGVsdCkgfmNvbXBhcmVfZWx0XG4gICAgICAgIGluXG4gICAgICAgIGxvb3Agbm90X2VxdWl2X3ggKGVxdWl2X3ggOjogZXF1aXZfY2xhc3NlcykpXG4gICAgaW5cbiAgICBsb29wIHNldCBbXVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIFNvbWUgdlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGZpbmQgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaW5kIHIgfmZcbiAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICA7O1xuXG4gIGxldCByZWMgZmluZF9tYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gZiB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgKG1hdGNoIGYgdiB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICAobWF0Y2ggZmluZF9tYXAgbCB+ZiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIHIgfmZcbiAgICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNldC5maW5kX2V4biBmYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIGVsZW1lbnRcIlxuICAgIHwgU29tZSBlIC0+IGVcbiAgOztcblxuICBsZXQgcmVjIG50aCB0IGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGkgPSAwIHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGlmIGkgPj0gc1xuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPCAwIHRoZW4gbnRoIGwgaSBlbHNlIGlmIGMgPSAwIHRoZW4gU29tZSB2IGVsc2UgbnRoIHIgKGkgLSBsX3NpemUgLSAxKSlcbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGxvb3AgeHMgbGVmdG92ZXJzIGFscmVhZHlfc2VlbiA9XG4gICAgICBtYXRjaCB4cyB3aXRoXG4gICAgICB8IFtdIC0+IExpc3QucmV2IGxlZnRvdmVyc1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBpZiBtZW0gYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdFxuICAgICAgICB0aGVuIGxvb3AgdGwgbGVmdG92ZXJzIGFscmVhZHlfc2VlblxuICAgICAgICBlbHNlIGxvb3AgdGwgKGhkIDo6IGxlZnRvdmVycykgKGFkZCBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0KVxuICAgIGluXG4gICAgbG9vcCB4cyBbXSBlbXB0eVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGFfb2Zfc2V4cCBzZXhwIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgbHN0IC0+XG4gICAgICBsZXQgZWx0X2xzdCA9IExpc3QubWFwIGxzdCB+ZjphX29mX3NleHAgaW5cbiAgICAgIGxldCBzZXQgPSBvZl9saXN0IGVsdF9sc3QgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBsZW5ndGggc2V0ID0gTGlzdC5sZW5ndGggbHN0XG4gICAgICB0aGVuIHNldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzZXQgPSByZWYgZW1wdHkgaW5cbiAgICAgICAgTGlzdC5pdGVyMl9leG4gbHN0IGVsdF9sc3QgfmY6KGZ1biBlbF9zZXhwIGVsIC0+XG4gICAgICAgICAgaWYgbWVtICFzZXQgZWwgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogZHVwbGljYXRlIGVsZW1lbnQgaW4gc2V0XCIgZWxfc2V4cFxuICAgICAgICAgIGVsc2Ugc2V0IDo9IGFkZCAhc2V0IGVsIH5jb21wYXJlX2VsdCk7XG4gICAgICAgIGFzc2VydCBmYWxzZSlcbiAgICB8IHNleHAgLT4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gZWwgYWNjIC0+IHNleHBfb2ZfYSBlbCA6OiBhY2MpKVxuICA7O1xuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHRyZWUgOiAnYSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCBpc19zdWJzZXQgKHN1YnNldCA6IF8gdCkgfm9mXzooc3VwZXJzZXQgOiBfIHQpIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IGludmFsaWRfZWxlbWVudHMgPSBkaWZmIHN1YnNldC50cmVlIHN1cGVyc2V0LnRyZWUgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBpc19lbXB0eSBpbnZhbGlkX2VsZW1lbnRzXG4gICAgICB0aGVuIE9rICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGludmFsaWRfZWxlbWVudHNfc2V4cCA9IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBpbnZhbGlkX2VsZW1lbnRzIGluXG4gICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgKHN1YnNldC5uYW1lIF4gXCIgaXMgbm90IGEgc3Vic2V0IG9mIFwiIF4gc3VwZXJzZXQubmFtZSlcbiAgICAgICAgICAgICBbIFwiaW52YWxpZF9lbGVtZW50c1wiLCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgXSkpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBzMSBzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0ID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXRcbiAgICAgICAgWyBpc19zdWJzZXQgczEgfm9mXzpzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIDsgaXNfc3Vic2V0IHMyIH5vZl86czEgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICBdXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2EsICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogJ2EgVHJlZTAudFxuICB9XG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdHJlZSA9ICdhIFRyZWUwLnRcblxubGV0IGxpa2UgeyB0cmVlID0gXzsgY29tcGFyYXRvciB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3IgfVxubGV0IGNvbXBhcmVfZWx0IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgaW52YXJpYW50cyB0ID0gVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdC50cmVlXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdC50cmVlXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHQudHJlZVxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0LnRyZWVcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdC50cmVlXG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdC50cmVlXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyMiBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhLnRyZWUgYi50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdC50cmVlIH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdC50cmVlIH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdC50cmVlIH5mXG4gIGxldCBtZW0gdCBhID0gVHJlZTAubWVtIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBhZGQgdCBhID0gbGlrZSB0IChUcmVlMC5hZGQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHJlbW92ZSB0IGEgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgdW5pb24gdDEgdDIgPSBsaWtlIHQxIChUcmVlMC51bmlvbiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBpbnRlciB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmludGVyIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfZWx0IHQxKSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGVxdWFsIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIGxldCBpc19zdWJzZXQgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQudHJlZSB+b2ZfOm9mXy50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcblxuICBsZXQgYXJlX2Rpc2pvaW50IHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgc2V0IDogKCdhLCAnY21wKSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCB0b19uYW1lZF90cmVlIHsgc2V0OyBuYW1lIH0gPSB7IFRyZWUwLk5hbWVkLnRyZWUgPSBzZXQudHJlZTsgbmFtZSB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IChzdWJzZXQgOiAoXywgXykgdCkgfm9mXzooc3VwZXJzZXQgOiAoXywgXykgdCkgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgICh0b19uYW1lZF90cmVlIHN1YnNldClcbiAgICAgICAgfm9mXzoodG9fbmFtZWRfdHJlZSBzdXBlcnNldClcbiAgICAgICAgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBzdWJzZXQuc2V0KVxuICAgICAgICB+c2V4cF9vZl9lbHQ6c3Vic2V0LnNldC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgdDEgdDIgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdCBbIGlzX3N1YnNldCB0MSB+b2ZfOnQyOyBpc19zdWJzZXQgdDIgfm9mXzp0MSBdXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsZXQgdHJlZV90LCB0cmVlX2YgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZV90LCBsaWtlIHQgdHJlZV9mXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCBiLCB0cmVlMiA9IFRyZWUwLnNwbGl0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGIsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBncm91cF9ieSB0IH5lcXVpdiA9XG4gICAgTGlzdC5tYXAgKFRyZWUwLmdyb3VwX2J5IHQudHJlZSB+ZXF1aXYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSkgfmY6KGxpa2UgdClcbiAgOztcblxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0LnRyZWUgaVxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlX2luZGV4IHQudHJlZSBpIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSB0LmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICAgICAgdCcudHJlZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgc3RhdGUgdC50cmVlXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNvbXBhcmUgXyBfIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcblxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID0gKCdhLCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBjZSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpIGFfb2Zfc2V4cCBzZXhwXG4gIDs7XG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGUgPSBUcmVlMC5zaW5nbGV0b24gZVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID0gVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdFxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdFxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0XG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHRcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+aW5pdCB+ZlxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBmaWx0ZXIgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlciB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBwYXJ0aXRpb25fdGYgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEgYiB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAubWVtIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuYWRkIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAucmVtb3ZlIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLnVuaW9uIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGludGVyIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuaW50ZXIgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmRpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNlIGNvbXBhcmF0b3IpIHQxIHQyXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdCB+b2ZfIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgYXJlX2Rpc2pvaW50IH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGEgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl8gfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLnVuaW9uX2xpc3QgbCB+dG9fdHJlZTpGbi5pZCB+Y29tcGFyYXRvclxuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBncm91cF9ieSB+Y29tcGFyYXRvciB0IH5lcXVpdiA9IFRyZWUwLmdyb3VwX2J5IHQgfmVxdWl2IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQgaVxuICBsZXQgcmVtb3ZlX2luZGV4IH5jb21wYXJhdG9yIHQgaSA9IFRyZWUwLnJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHRcbiAgbGV0IHRvX3RyZWUgdCA9IHRcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0ID0gdFxuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0J1xuICA7O1xuXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRyZWUwLk5hbWVkXG5cbiAgICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQxIH5vZl86dDIgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgIHQxXG4gICAgICAgIH5vZl86dDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgICAgVHJlZTAuTmFtZWQuZXF1YWxcbiAgICAgICAgdDFcbiAgICAgICAgdDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWVcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5jb21wYXJlIGFfb2Zfc2V4cCBzZXhwKVxuICA7O1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IGNvbXBhcmF0b3IgPSBFbHQuY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cbiAgZW5kXG5cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBlID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGUgfVxuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgfnRvX3RyZWUgbClcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgbGV0IHRyZWUgPVxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IuTW9uYWRfaW5maXguKFxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgPj58IGZ1biB0cmVlIC0+IHsgY29tcGFyYXRvcjsgdHJlZSB9KVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAubWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvclxuICAgIDsgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIH1cbiAgOztcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG50eXBlICgnZWx0LCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCBjb21wYXJhdG9yX3MgKHR5cGUgayBjbXApIHQgOiAoaywgY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBrXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXBcblxuICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gIGVuZClcbjs7XG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGVsdCBjbXApICgobW9kdWxlIE0pIDogKGVsdCwgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcblxubW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBlbHQgY21wKVxuICAgICAgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpFbHQuY29tcGFyYXRvciBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpXG4gIDogKGVsdCwgXykgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBlbHQpIHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBFbHQuaGFzaF9mb2xkX3Qgc3RhdGVcbjs7XG5cbmxldCBoYXNoX21fX3QgZm9sZGVyIHQgPVxuICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfbV9fdCBmb2xkZXIgKEhhc2guY3JlYXRlICgpKSB0IGluXG4gIEhhc2guZ2V0X2hhc2hfdmFsdWUgc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgc2V0ID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAnZWx0IHQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdHJlZSA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRyZWVcbiAgdHlwZSBub25yZWMgJ2VsdCBuYW1lZCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIE5hbWVkLnRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IHVuaW9uX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvciBhXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX3NlcXVlbmNlIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG1hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgZmlsdGVyX21hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZcbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZlxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gcmVmX29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfcmVmXG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiByZWZfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSByZWYgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmQpXG5cbigqIEluIHRoZSBkZWZpbml0aW9uIG9mIFt0XSwgd2UgZG8gbm90IGhhdmUgW1tAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXSBiZWNhdXNlXG4gICBpbiBnZW5lcmFsLCBzeW50YXggZXh0ZW5zaW9ucyB0ZW5kIHRvIHVzZSB0aGUgaW1wbGVtZW50YXRpb24gd2hlbiBhdmFpbGFibGUgcmF0aGVyIHRoYW5cbiAgIHVzaW5nIHRoZSBhbGlhcy4gIEhlcmUgdGhhdCB3b3VsZCBsZWFkIHRvIHVzZSB0aGUgcmVjb3JkIHJlcHJlc2VudGF0aW9uIFsgeyBtdXRhYmxlXG4gICBjb250ZW50cyA6ICdhIH0gXSB3aGljaCB3b3VsZCByZXN1bHQgaW4gZGlmZmVyZW50IChhbmQgdW53YW50ZWQpIGJlaGF2aW9yLiAgKilcbnR5cGUgJ2EgdCA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuZXh0ZXJuYWwgY3JlYXRlIDogJ2EgLT4gJ2EgdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgdCAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSB0IC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG5sZXQgc3dhcCB0MSB0MiA9XG4gIGxldCB0bXAgPSAhdDEgaW5cbiAgdDEgOj0gIXQyO1xuICB0MiA6PSB0bXBcbjs7XG5cbmxldCByZXBsYWNlIHQgZiA9IHQgOj0gZiAhdFxuXG5sZXQgc2V0X3RlbXBvcmFyaWx5IHQgYSB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gIXQgaW5cbiAgdCA6PSBhO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHQgOj0gcmVzdG9yZV90bylcbjs7XG5cbm1vZHVsZSBBbmRfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVCA6ICdhIHJlZiAqICdhIC0+IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgc2V0IChUIChyLCBhKSkgPSByIDo9IGFcbiAgbGV0IHNldHMgdHMgPSBMaXN0Lml0ZXIgdHMgfmY6c2V0XG4gIGxldCBzbmFwc2hvdCAoVCAociwgXykpID0gVCAociwgIXIpXG4gIGxldCBzbmFwc2hvdHMgdHMgPSBMaXN0Lm1hcCB0cyB+ZjpzbmFwc2hvdFxuZW5kXG5cbmxldCBzZXRzX3RlbXBvcmFyaWx5IGFuZF92YWx1ZXMgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9IEFuZF92YWx1ZS5zbmFwc2hvdHMgYW5kX3ZhbHVlcyBpblxuICBBbmRfdmFsdWUuc2V0cyBhbmRfdmFsdWVzO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IEFuZF92YWx1ZS5zZXRzIHJlc3RvcmVfdG8pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cblxuKCogW3RdIHN0b3JlcyB0aGUgW3QubGVuZ3RoXSBxdWV1ZSBlbGVtZW50cyBhdCBjb25zZWN1dGl2ZSBpbmNyZWFzaW5nIGluZGljZXMgb2YgW3QuZWx0c10sXG4gICBtb2QgdGhlIGNhcGFjaXR5IG9mIFt0XSwgd2hpY2ggaXMgW09wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gIFRoZSBjYXBhY2l0eSBpc1xuICAgcmVxdWlyZWQgdG8gYmUgYSBwb3dlciBvZiB0d28gKHVzZXItcmVxdWVzdGVkIGNhcGFjaXRpZXMgYXJlIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3RcbiAgIHBvd2VyKSwgc28gdGhhdCBtb2QgY2FuIHF1aWNrbHkgYmUgY29tcHV0ZWQgdXNpbmcgW2xhbmQgdC5tYXNrXSwgd2hlcmUgW3QubWFzayA9XG4gICBjYXBhY2l0eSB0IC0gMV0uICBTbywgcXVldWUgZWxlbWVudCBbaV0gaXMgYXQgW3QuZWx0cy4oICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKV0uXG5cbiAgIFtudW1fbXV0YXRpb25zXSBpcyB1c2VkIHRvIGRldGVjdCBtb2RpZmljYXRpb24gZHVyaW5nIGl0ZXJhdGlvbi4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBudW1fbXV0YXRpb25zIDogaW50XG4gIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbWFzayA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV9cbiAgICB7IG51bV9tdXRhdGlvbnMgPSBudW1fbXV0YXRpb25zX18wMDNfXG4gICAgOyBmcm9udCA9IGZyb250X18wMDVfXG4gICAgOyBtYXNrID0gbWFza19fMDA3X1xuICAgIDsgbGVuZ3RoID0gbGVuZ3RoX18wMDlfXG4gICAgOyBlbHRzID0gZWx0c19fMDExX1xuICAgIH0gLT5cbiAgICBsZXQgYm5kc19fMDAyXyA9IFtdIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDEyXyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDExXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDlfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2ZfaW50IG1hc2tfXzAwN18gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hc2tcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA2XyA9IHNleHBfb2ZfaW50IGZyb250X18wMDVfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJmcm9udFwiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbnVtX211dGF0aW9uc19fMDAzXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibnVtX211dGF0aW9uc1wiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIHR5cGUgUyA9IFF1ZXVlX2ludGYuU1xuXG5sZXQgaW5jX251bV9tdXRhdGlvbnMgdCA9IHQubnVtX211dGF0aW9ucyA8LSB0Lm51bV9tdXRhdGlvbnMgKyAxXG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcbmxldCBlbHRzX2luZGV4IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2tcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX2lzX3NldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2lzX3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSBhID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKSBhXG5sZXQgdW5zYWZlX3Vuc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcblxubGV0IGNoZWNrX2luZGV4X2V4biB0IGkgPVxuICBpZiBpIDwgMCB8fCBpID49IHQubGVuZ3RoXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlF1ZXVlIGluZGV4IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgWyBcImluZGV4XCIsIGkgfD4gSW50LnNleHBfb2ZfdDsgXCJsZW5ndGhcIiwgdC5sZW5ndGggfD4gSW50LnNleHBfb2ZfdCBdKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICB1bnNhZmVfZ2V0IHQgaVxuOztcblxubGV0IHNldCB0IGkgYSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIHVuc2FmZV9zZXQgdCBpIGFcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5sZXQgbGVuZ3RoIHsgbGVuZ3RoOyBfIH0gPSBsZW5ndGhcblxubGV0IGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMgPVxuICBpZiB0Lm51bV9tdXRhdGlvbnMgPD4gbnVtX211dGF0aW9uc1xuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJtdXRhdGlvbiBvZiBxdWV1ZSBkdXJpbmcgaXRlcmF0aW9uXCJcbiAgICAgICAgIFsgXCJcIiwgdCB8PiBzZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgXSlcbjs7XG5cbmxldCBjb21wYXJlID1cbiAgbGV0IHJlYyB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IHBvcyB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyID1cbiAgICBtYXRjaCBwb3MgPSBsZW4xLCBwb3MgPSBsZW4yIHdpdGhcbiAgICB8IHRydWUsIHRydWUgLT4gMFxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gLTFcbiAgICB8IGZhbHNlLCB0cnVlIC0+IDFcbiAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgbGV0IHggPSBjb21wYXJlX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCAwIC0+IHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgKHBvcyArIDEpIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDJcbiAgICAgICB8IG4gLT4gbilcbiAgaW5cbiAgZnVuIGNvbXBhcmVfZWx0IHQxIHQyIC0+XG4gICAgaWYgcGh5c19lcXVhbCB0MSB0MlxuICAgIHRoZW4gMFxuICAgIGVsc2VcbiAgICAgIHVuc2FmZV9jb21wYXJlX2Zyb21cbiAgICAgICAgY29tcGFyZV9lbHRcbiAgICAgICAgMFxuICAgICAgICB+dDFcbiAgICAgICAgfnQyXG4gICAgICAgIH5sZW4xOnQxLmxlbmd0aFxuICAgICAgICB+bGVuMjp0Mi5sZW5ndGhcbiAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgZXF1YWwgPVxuICBsZXQgcmVjIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCBwb3MgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuID1cbiAgICBwb3MgPSBsZW5cbiAgICB8fFxuICAgIGxldCBiID0gZXF1YWxfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgIGIgJiYgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW5cbiAgaW5cbiAgZnVuIGVxdWFsX2VsdCB0MSB0MiAtPlxuICAgIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB8fFxuICAgIGxldCBsZW4xID0gdDEubGVuZ3RoIGluXG4gICAgbGV0IGxlbjIgPSB0Mi5sZW5ndGggaW5cbiAgICBsZW4xID0gbGVuMlxuICAgICYmIHVuc2FmZV9lcXVhbF9mcm9tXG4gICAgICAgICBlcXVhbF9lbHRcbiAgICAgICAgIDBcbiAgICAgICAgIH50MVxuICAgICAgICAgfnQyXG4gICAgICAgICB+bGVuOmxlbjFcbiAgICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCB7IG51bV9tdXRhdGlvbnM7IG1hc2sgPSBfOyBlbHRzOyBmcm9udDsgbGVuZ3RoIH0gPSB0IGluXG4gIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KTtcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBhc3NlcnQgKGNhcGFjaXR5ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgYXNzZXJ0IChjYXBhY2l0eSA+PSAxKTtcbiAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gIGFzc2VydCAobGVuZ3RoID49IDApO1xuICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSk7XG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSAtIDEgZG9cbiAgICBpZiBpIDwgdC5sZW5ndGhcbiAgICB0aGVuIChcbiAgICAgIGludmFyaWFudF9hICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zKVxuICAgIGVsc2UgYXNzZXJ0IChub3QgKHVuc2FmZV9pc19zZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/Y2FwYWNpdHkgKCkgOiBhIHQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgLT4gMVxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJjYW5ub3QgaGF2ZSBxdWV1ZSB3aXRoIG5lZ2F0aXZlIGNhcGFjaXR5XCJcbiAgICAgICAgICAgICBbIFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkgfD4gSW50LnNleHBfb2ZfdCBdKVxuICAgICAgZWxzZSBpZiBjYXBhY2l0eSA9IDBcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSBJbnQuY2VpbF9wb3cyIGNhcGFjaXR5XG4gIGluXG4gIHsgbnVtX211dGF0aW9ucyA9IDBcbiAgOyBmcm9udCA9IDBcbiAgOyBtYXNrID0gY2FwYWNpdHkgLSAxXG4gIDsgbGVuZ3RoID0gMFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46Y2FwYWNpdHlcbiAgfVxuOztcblxubGV0IGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QgPVxuICBhc3NlcnQgKHNyYy5sZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBkc3QpO1xuICBsZXQgZnJvbnRfbGVuID0gSW50Lm1pbiBzcmMubGVuZ3RoIChjYXBhY2l0eSBzcmMgLSBzcmMuZnJvbnQpIGluXG4gIGxldCByZXN0X2xlbiA9IHNyYy5sZW5ndGggLSBmcm9udF9sZW4gaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpmcm9udF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczpzcmMuZnJvbnQgfmRzdCB+ZHN0X3BvczowO1xuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOnJlc3RfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmZyb250X2xlblxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IGRlc2lyZWRfY2FwYWNpdHkgPVxuICAoKiBXZSBhbGxvdyBhcmd1bWVudHMgbGVzcyB0aGFuIDEgdG8gW3NldF9jYXBhY2l0eV0sIGJ1dCB0cmFuc2xhdGUgdGhlbSB0byAxIHRvIHNpbXBsaWZ5XG4gICAgIHRoZSBjb2RlIHRoYXQgcmVsaWVzIG9uIHRoZSBhcnJheSBsZW5ndGggYmVpbmcgYSBwb3dlciBvZiAyLiAqKVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgbmV3X2NhcGFjaXR5ID0gSW50LmNlaWxfcG93MiAobWF4IDEgKG1heCBkZXNpcmVkX2NhcGFjaXR5IHQubGVuZ3RoKSkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHRcbiAgdGhlbiAoXG4gICAgbGV0IGRzdCA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpuZXdfY2FwYWNpdHkgaW5cbiAgICBibGl0X3RvX2FycmF5IH5zcmM6dCBkc3Q7XG4gICAgdC5mcm9udCA8LSAwO1xuICAgIHQubWFzayA8LSBuZXdfY2FwYWNpdHkgLSAxO1xuICAgIHQuZWx0cyA8LSBkc3QpXG47O1xuXG5sZXQgZW5xdWV1ZSB0IGEgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA9IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHkgdCAoMiAqIHQubGVuZ3RoKTtcbiAgdW5zYWZlX3NldCB0IHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IGRlcXVldWVfbm9uZW1wdHkgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBlbHRzID0gdC5lbHRzIGluXG4gIGxldCBmcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IHJlcyA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBmcm9udCBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgZWx0cyBmcm9udDtcbiAgdC5mcm9udCA8LSBlbHRzX2luZGV4IHQgMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICByZXNcbjs7XG5cbmxldCBkZXF1ZXVlX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBkZXF1ZXVlX25vbmVtcHR5IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGRlcXVldWVfbm9uZW1wdHkgdClcbmxldCBmcm9udF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIHQuZnJvbnRcbmxldCBsYXN0X25vbmVtcHR5IHQgPSB1bnNhZmVfZ2V0IHQgKHQubGVuZ3RoIC0gMSlcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGZyb250X25vbmVtcHR5IHQpXG5sZXQgcGVla19leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgZnJvbnRfbm9uZW1wdHkgdFxubGV0IGxhc3QgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAobGFzdF9ub25lbXB0eSB0KVxubGV0IGxhc3RfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGxhc3Rfbm9uZW1wdHkgdFxuXG5sZXQgY2xlYXIgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICB1bnNhZmVfdW5zZXQgdCBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwO1xuICAgIHQuZnJvbnQgPC0gMClcbjs7XG5cbmxldCBibGl0X3RyYW5zZmVyIH5zcmMgfmRzdCA/bGVuICgpID1cbiAgaW5jX251bV9tdXRhdGlvbnMgc3JjO1xuICBpbmNfbnVtX211dGF0aW9ucyBkc3Q7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IHNyYy5sZW5ndGhcbiAgICB8IFNvbWUgbGVuIC0+XG4gICAgICBpZiBsZW4gPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJRdWV1ZS5ibGl0X3RyYW5zZmVyOiBuZWdhdGl2ZSBsZW5ndGhcIlxuICAgICAgICAgICAgIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gICAgICBtaW4gbGVuIHNyYy5sZW5ndGhcbiAgaW5cbiAgaWYgbGVuID4gMFxuICB0aGVuIChcbiAgICBzZXRfY2FwYWNpdHkgZHN0IChtYXggKGNhcGFjaXR5IGRzdCkgKGRzdC5sZW5ndGggKyBsZW4pKTtcbiAgICBsZXQgZHN0X3N0YXJ0ID0gZHN0LmZyb250ICsgZHN0Lmxlbmd0aCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAoKiBUaGlzIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gc2ltcGx5IFtlbnF1ZXVlIGRzdCAoZGVxdWV1ZV9ub25lbXB0eSBzcmMpXSAqKVxuICAgICAgbGV0IHNyY19pID0gKHNyYy5mcm9udCArIGkpIGxhbmQgc3JjLm1hc2sgaW5cbiAgICAgIGxldCBkc3RfaSA9IChkc3Rfc3RhcnQgKyBpKSBsYW5kIGRzdC5tYXNrIGluXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lXG4gICAgICAgIGRzdC5lbHRzXG4gICAgICAgIGRzdF9pXG4gICAgICAgIChPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biBzcmMuZWx0cyBzcmNfaSk7XG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHNyYy5lbHRzIHNyY19pXG4gICAgZG9uZTtcbiAgICBkc3QubGVuZ3RoIDwtIGRzdC5sZW5ndGggKyBsZW47XG4gICAgc3JjLmZyb250IDwtIChzcmMuZnJvbnQgKyBsZW4pIGxhbmQgc3JjLm1hc2s7XG4gICAgc3JjLmxlbmd0aCA8LSBzcmMubGVuZ3RoIC0gbGVuKVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBzZXRfY2FwYWNpdHkgdCAoSW50Lm1heCAoY2FwYWNpdHkgdCkgKHQubGVuZ3RoICsgTGlzdC5sZW5ndGggbCkpO1xuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICAgIGxldCByID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgICBkb25lO1xuICAgICFyKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBhIC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpXG47O1xuXG5cbigqIFtpdGVyXSBpcyBpbXBsZW1lbnRlZCBkaXJlY3RseSBiZWNhdXNlIGltcGxlbWVudGluZyBpdCBpbiB0ZXJtcyBvZiBbZm9sZF0gaXNcbiAgIHNsb3dlci4gKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBbXSBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHJlc3VsdCA6PSB1bnNhZmVfZ2V0IHQgaSA6OiAhcmVzdWx0XG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbiAgZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxuXG5cbigqIEZvciBbY29uY2F0X21hcF0sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJdLCB3ZSBkb24ndCBjcmVhdGUgW3RfcmVzdWx0XSB3aXRoIFt0XSdzXG4gICBjYXBhY2l0eSBiZWNhdXNlIHdlIGhhdmUgbm8gaWRlYSBob3cgbWFueSBlbGVtZW50cyBbdF9yZXN1bHRdIHdpbGwgdWx0aW1hdGVseSBob2xkLiAqKVxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXIgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXJpIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6c3JjLmxlbmd0aCAoKSBpblxuICBibGl0X3RvX2FycmF5IH5zcmMgZHN0LmVsdHM7XG4gIGRzdC5sZW5ndGggPC0gc3JjLmxlbmd0aDtcbiAgZHN0XG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTooTGlzdC5sZW5ndGggbCkgKCkgaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxuKCogVGhlIHF1ZXVlIFt0XSByZXR1cm5lZCBieSBbY3JlYXRlXSB3aWxsIGhhdmUgW3QubGVuZ3RoID0gMF0sIFt0LmZyb250ID0gMF0sIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBJbnQuY2VpbF9wb3cyIGxlbl0uICBTbywgd2Ugb25seSBoYXZlIHRvIHNldCBbdC5sZW5ndGhdIHRvIFtsZW5dIGFmdGVyXG4gICB0aGUgYmxpdCB0byBtYWludGFpbiBhbGwgdGhlIGludmFyaWFudHM6IFt0Lmxlbmd0aF0gaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgaW4gdGhlIHF1ZXVlLCBbdC5mcm9udF0gaXMgdGhlIGFycmF5IGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBxdWV1ZSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gKilcbmxldCBpbml0IGxlbiB+ZiA9XG4gIGlmIGxlbiA8IDBcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJRdWV1ZS5pbml0OiBuZWdhdGl2ZSBsZW5ndGhcIiBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6bGVuICgpIGluXG4gIGFzc2VydCAoT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgPj0gbGVuKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyBpIChmIGkpXG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIGxlbjtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGEgPSBpbml0IChBcnJheS5sZW5ndGggYSkgfmY6KEFycmF5LnVuc2FmZV9nZXQgYSlcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCB0Lmxlbmd0aCB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBtYXAgdGEgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHRhLm51bV9tdXRhdGlvbnMgaW5cbiAgbGV0IHRiID0gY3JlYXRlIH5jYXBhY2l0eTp0YS5sZW5ndGggKCkgaW5cbiAgdGIubGVuZ3RoIDwtIHRhLmxlbmd0aDtcbiAgZm9yIGkgPSAwIHRvIHRhLmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgYiA9IGYgKHVuc2FmZV9nZXQgdGEgaSkgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdGEgbnVtX211dGF0aW9ucztcbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHRiLmVsdHMgaSBiXG4gIGRvbmU7XG4gIHRiXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBtYXAgdCB+ZjooZnVuIGEgLT5cbiAgICBsZXQgcmVzdWx0ID0gZiAhaSBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgcmVzdWx0KVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IHg7XG4gIHRcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSB0b19saXN0IHQgfD4gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgfD4gb2ZfbGlzdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gfFxuXG4gIGxldCB1bnJlYWNoYWJsZV9jb2RlID0gZnVuY3Rpb25cbiAgICB8IChfIDogdCkgLT4gLlxuICA7O1xuXG4gIGxldCBhbGwgPSBbXVxuICBsZXQgaGFzaF9mb2xkX3QgXyB0ID0gdW5yZWFjaGFibGVfY29kZSB0XG4gIGxldCBoYXNoID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgY29tcGFyZSBhIF8gPSB1bnJlYWNoYWJsZV9jb2RlIGFcbiAgbGV0IHNleHBfb2ZfdCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID0gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X3R5cGUgXCJCYXNlLk5vdGhpbmcudFwiIHNleHBcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxuICBsZXQgdG9fc3RyaW5nID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgb2Zfc3RyaW5nIChfIDogc3RyaW5nKSA9IGZhaWx3aXRoIFwiQmFzZS5Ob3RoaW5nLm9mX3N0cmluZzogbm90IHN1cHBvcnRlZFwiXG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5vdGhpbmdcIlxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuTmF0aXZlaW50XG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAobmF0aXZlaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX25hdGl2ZWludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9uYXRpdmVpbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gbmVnXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVueFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJW54XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50XCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgbnVtX2JpdHMgPSBXb3JkX3NpemUubnVtX2JpdHMgV29yZF9zaXplLndvcmRfc2l6ZVxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiTmF0aXZlaW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5OYXRpdmVpbnQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLk5hdGl2ZWludC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuTmF0aXZlaW50LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiAoeCA6IG5hdGl2ZWludCkgPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLk5hdGl2ZWludC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuTmF0aXZlaW50LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuTmF0aXZlaW50LnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuTmF0aXZlaW50LnByZWQgeCA9IDBuXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgbmF0aXZlaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIGlmIENhbWwuTmF0aXZlaW50LmVxdWFsIGkgQ2FtbC5OYXRpdmVpbnQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5OYXRpdmVpbnQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX25hdGl2ZWludCB0ID0gdFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgdCA9IHRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5uYXRpdmVpbnRfcG9wY291bnRcbmxldCBvZl9pbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgdG9faW50MzJfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW05hdGl2ZWludF0gYW5kIFtOYXRpdmVpbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5leHRlcm5hbCBic3dhcCA6IHQgLT4gdCA9IFwiJWJzd2FwX25hdGl2ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNYXBfaW50ZlxuXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLkZpbmlzaGVkX29yX3VuZmluaXNoZWRcblxuICAoKiBUaGVzZSB0d28gZnVuY3Rpb25zIGFyZSB0ZXN0ZWQgaW4gW3Rlc3RfbWFwLm1sXSB0byBtYWtlIHN1cmUgb3VyIHVzZSBvZlxuICAgICBbQ2FtbC5PYmoubWFnaWNdIGlzIGNvcnJlY3QgYW5kIHNhZmUuICopXG4gIGxldCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHQgPSBDYW1sLk9iai5tYWdpY1xuICBsZXQgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50ID0gQ2FtbC5PYmoubWFnaWNcbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLk1lcmdlX2VsZW1lbnRcblxuICBsZXQgbGVmdCA9IGZ1bmN0aW9uXG4gICAgfCBgUmlnaHQgXyAtPiBOb25lXG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IFNvbWUgbGVmdFxuICA7O1xuXG4gIGxldCByaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gU29tZSByaWdodFxuICA7O1xuXG4gIGxldCBsZWZ0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYFJpZ2h0IF8gLT4gZGVmYXVsdFxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgXyAtPiBkZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHZhbHVlcyB0IH5sZWZ0X2RlZmF1bHQgfnJpZ2h0X2RlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgbGVmdCAtPiBsZWZ0LCByaWdodF9kZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgLT4gbGVmdF9kZWZhdWx0LCByaWdodFxuICAgIHwgYEJvdGggKGxlZnQsIHJpZ2h0KSAtPiBsZWZ0LCByaWdodFxuICA7O1xuZW5kXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmV4Y2VwdGlvbiBEdXBsaWNhdGUgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBEdXBsaWNhdGVdIChmdW5jdGlvblxuICAgIHwgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5EdXBsaWNhdGVcIlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBMZWFmIG9mICdrICogJ3ZcbiAgICB8IE5vZGUgb2YgKCdrLCAndikgdCAqICdrICogJ3YgKiAoJ2ssICd2KSB0ICogaW50XG5cbiAgdHlwZSAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgdFxuXG4gIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIGgpIC0+IGhcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGsgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2tleSBsb3dlciBrIDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfa2V5IGsgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIChrLCBfKSAtPiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrXG4gICAgICB8IE5vZGUgKGwsIGssIF8sIHIsIGgpIC0+XG4gICAgICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICAgIGFicyAoaGwgLSBocikgPD0gMlxuICAgICAgICAmJiBoID0gbWF4IGhsIGhyICsgMVxuICAgICAgICAmJiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrXG4gICAgICAgICYmIGxvb3AgbG93ZXIgKFNvbWUgaykgY29tcGFyZV9rZXkgbFxuICAgICAgICAmJiBsb29wIChTb21lIGspIHVwcGVyIGNvbXBhcmVfa2V5IHJcbiAgICBpblxuICAgIGZ1biB0IH5jb21wYXJlX2tleSAtPiBsb29wIE5vbmUgTm9uZSBjb21wYXJlX2tleSB0XG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAyICopXG4gIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgIGlmIGhsID0gMCAmJiBociA9IDBcbiAgICB0aGVuIExlYWYgKHgsIGQpXG4gICAgZWxzZSBOb2RlIChsLCB4LCBkLCByLCBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSlcbiAgOztcblxuICBsZXQgc2luZ2xldG9uIGtleSBkYXRhID0gTGVhZiAoa2V5LCBkYXRhKVxuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLk1hcCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgOiAoXywgXykgdCA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrLCB2ID0gZiBpIGluXG4gICAgICAgIExlYWYgKGssIHYpXG4gICAgICB8IDIgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBOb2RlIChMZWFmIChrbCwgdmwpLCBrLCB2LCBFbXB0eSwgMilcbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciwgdnIgPSBmIChpICsgMikgaW5cbiAgICAgICAgTm9kZSAoTGVhZiAoa2wsIHZsKSwgaywgdiwgTGVhZiAoa3IsIHZyKSwgMilcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayB2IHJpZ2h0XG4gICAgaW5cbiAgICBsb29wIGxlbiB+ZiAwXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYXJyYXlfbGVuZ3RoID0gQXJyYXkubGVuZ3RoIGFycmF5IGluXG4gICAgbGV0IG5leHQgPVxuICAgICAgaWYgYXJyYXlfbGVuZ3RoIDwgMlxuICAgICAgICAgfHxcbiAgICAgICAgIGxldCBrMCwgXyA9IGFycmF5LigwKSBpblxuICAgICAgICAgbGV0IGsxLCBfID0gYXJyYXkuKDEpIGluXG4gICAgICAgICBjb21wYXJlX2tleSBrMCBrMSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHQsIGFycmF5X2xlbmd0aFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBhcnJheSB3aXRoXG4gICAgfCBbfHxdIHwgW3wgXyB8XSAtPiBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5KVxuICAgIHwgXyAtPlxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBpbmNyZWFzaW5nID1cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LigwKSkgKGZzdCBhcnJheS4oMSkpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPiBpIDwgMFxuICAgICAgICBpblxuICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIGFycmF5IC0gMiBkb1xuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfa2V5IChmc3QgYXJyYXkuKGkpKSAoZnN0IGFycmF5LihpICsgMSkpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPlxuICAgICAgICAgICAgaWYgUG9seS4oIDw+ICkgKGkgPCAwKSBpbmNyZWFzaW5nXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgIHIucmV0dXJuXG4gICAgICAgICAgICAgICAgKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkpKVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMyAqKVxuICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsIGluXG4gICAgbGV0IGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBociArIDIgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsZCwgbHIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKGxydiwgbHJkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBFbXB0eSkgbHJ2IGxyZCAoY3JlYXRlIEVtcHR5IHggZCByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyZCwgbHJyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBobCArIDIgKilcbiAgICAgIHwgTm9kZSAocmwsIHJ2LCByZCwgcnIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmxcbiAgICAgICAgdGhlbiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKHJsdiwgcmxkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBFbXB0eSkgcmx2IHJsZCAoY3JlYXRlIEVtcHR5IHJ2IHJkIHJyKVxuICAgICAgICAgIHwgTm9kZSAocmxsLCBybHYsIHJsZCwgcmxyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKSkpXG4gICAgZWxzZSBjcmVhdGUgbCB4IGQgclxuICA7O1xuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5IH5zZXhwX29mX2tleSA9XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIltNYXAuYWRkX2V4bl0gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIG1vZHVsZSBBZGRfb3Jfc2V0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbFxuICAgICAgfCBBZGRfZXhuXG4gICAgICB8IFNldFxuICBlbmRcblxuXG4gIGxldCByZWMgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgfmxlbmd0aFxuICAgICAgICAgICAgfmtleTp4XG4gICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgICAgIH4oYWRkX29yX3NldCA6IEFkZF9vcl9zZXQudClcbiAgICA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmICh4LCBkYXRhKSwgbGVuZ3RoICsgMVxuICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IExlYWYgKHgsIGRhdGEpLCBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIE5vZGUgKExlYWYgKHgsIGRhdGEpLCB2LCBkLCBFbXB0eSwgMiksIGxlbmd0aCArIDFcbiAgICAgIGVsc2UgTm9kZSAoRW1wdHksIHYsIGQsIExlYWYgKHgsIGRhdGEpLCAyKSwgbGVuZ3RoICsgMVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IE5vZGUgKGwsIHgsIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGwsIGxlbmd0aCA9XG4gICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldCB+bGVuZ3RoIH5rZXk6eCB+ZGF0YSBsIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXRcbiAgICAgICAgaW5cbiAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgciwgbGVuZ3RoID1cbiAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IH5sZW5ndGggfmtleTp4IH5kYXRhIHIgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldFxuICAgICAgICBpblxuICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldDpBZGRfZXhuXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgdFxuICAgICAgfmxlbmd0aFxuICAgICAgfmtleVxuICAgICAgfmRhdGFcbiAgICAgIH5jb21wYXJlX2tleVxuICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICB+YWRkX29yX3NldDpBZGRfZXhuX2ludGVybmFsXG4gIDs7XG5cbiAgbGV0IHNldCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleTooZnVuIF8gLT4gTGlzdCBbXSlcbiAgICAgIH5hZGRfb3Jfc2V0OlNldFxuICA7O1xuXG4gIGxldCBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5ID0gZnN0IChzZXQgdCB+bGVuZ3RoOjAgfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRnJhZ21lbnQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnaywgJ3YpIHQgPVxuICAgICAgICB7IGxlZnRfc3VidHJlZSA6ICgnaywgJ3YpIHRcbiAgICAgICAgOyBrZXkgOiAna1xuICAgICAgICA7IGRhdGEgOiAndlxuICAgICAgICB9XG5cbiAgICAgIGxldCBzaW5nbGV0b25fdG9fdHJlZV9leG4gPSBmdW5jdGlvblxuICAgICAgICB8IHsgbGVmdF9zdWJ0cmVlID0gRW1wdHk7IGtleTsgZGF0YSB9IC0+IHNpbmdsZXRvbiBrZXkgZGF0YVxuICAgICAgICB8IF8gLT4gZmFpbHdpdGggXCJNYXAuc2luZ2xldG9uX3RvX3RyZWVfZXhuOiBub3QgYSBzaW5nbGV0b25cIlxuICAgICAgOztcblxuICAgICAgbGV0IHNpbmdsZXRvbiB+a2V5IH5kYXRhID0geyBsZWZ0X3N1YnRyZWUgPSBFbXB0eTsga2V5OyBkYXRhIH1cblxuICAgICAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwubGVmdF9zdWJ0cmVlKSAtIGhlaWdodChyKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGNvbGxhcHNlIGwgciA9IGNyZWF0ZSBsLmxlZnRfc3VidHJlZSBsLmtleSBsLmRhdGEgclxuXG4gICAgICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobC5sZWZ0X3N1YnRyZWUpIC0gaGVpZ2h0KHIubGVmdF9zdWJ0cmVlKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGpvaW4gbCByID0geyByIHdpdGggbGVmdF9zdWJ0cmVlID0gY29sbGFwc2UgbCByLmxlZnRfc3VidHJlZSB9XG4gICAgICBsZXQgbWF4X2tleSB0ID0gdC5rZXlcbiAgICBlbmRcblxuICAgICgqKiBCdWlsZCB0cmVlcyBmcm9tIHNpbmdsZXRvbnMgaW4gYSBiYWxhbmNlZCB3YXkgYnkgdXNpbmcgc2tldyBiaW5hcnkgZW5jb2RpbmcuXG4gICAgICAgIEVhY2ggbGV2ZWwgY29udGFpbnMgdHJlZXMgb2YgdGhlIHNhbWUgaGVpZ2h0LCBjb25zZWN1dGl2ZSBsZXZlbHMgaGF2ZSBjb25zZWN1dGl2ZVxuICAgICAgICBoZWlnaHRzLiBUaGVyZSBhcmUgbm8gZ2Fwcy4gVGhlIGZpcnN0IGxldmVsIGFyZSBzaW5nbGUga2V5cy5cbiAgICAqKVxuICAgIHR5cGUgKCdrLCAndikgdCA9XG4gICAgICB8IFplcm8gb2YgdW5pdFxuICAgICAgKCogW3VuaXRdIHRvIG1ha2UgcGF0dGVybiBtYXRjaGluZyBmYXN0ZXIgKilcbiAgICAgIHwgT25lIG9mICgnaywgJ3YpIHQgKiAoJ2ssICd2KSBGcmFnbWVudC50XG4gICAgICB8IFR3byBvZiAoJ2ssICd2KSB0ICogKCdrLCAndikgRnJhZ21lbnQudCAqICgnaywgJ3YpIEZyYWdtZW50LnRcblxuICAgIGxldCBlbXB0eSA9IFplcm8gKClcblxuICAgIGxldCBhZGRfdW5jaGVja2VkID1cbiAgICAgIGxldCByZWMgZ28gdCB4ID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgWmVybyAoKSAtPiBPbmUgKHQsIHgpXG4gICAgICAgIHwgT25lICh0LCB5KSAtPiBUd28gKHQsIHksIHgpXG4gICAgICAgIHwgVHdvICh0LCB6LCB5KSAtPiBPbmUgKGdvIHQgKEZyYWdtZW50LmpvaW4geiB5KSwgeClcbiAgICAgIGluXG4gICAgICBmdW4gdCB+a2V5IH5kYXRhIC0+IGdvIHQgKEZyYWdtZW50LnNpbmdsZXRvbiB+a2V5IH5kYXRhKVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZV91bmNoZWNrZWQgPVxuICAgICAgbGV0IHJlYyBnbyB0IHIgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBaZXJvICgpIC0+IHJcbiAgICAgICAgfCBPbmUgKHQsIGwpIC0+IGdvIHQgKEZyYWdtZW50LmNvbGxhcHNlIGwgcilcbiAgICAgICAgfCBUd28gKHQsIGxsLCBsKSAtPiBnbyB0IChGcmFnbWVudC5jb2xsYXBzZSAoRnJhZ21lbnQuam9pbiBsbCBsKSByKVxuICAgICAgaW5cbiAgICAgIGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gRW1wdHlcbiAgICAgIHwgT25lICh0LCByKSAtPiBnbyB0IChGcmFnbWVudC5zaW5nbGV0b25fdG9fdHJlZV9leG4gcilcbiAgICAgIHwgVHdvICh0LCBsLCByKSAtPiBnbyAoT25lICh0LCBsKSkgKEZyYWdtZW50LnNpbmdsZXRvbl90b190cmVlX2V4biByKVxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2tleSA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gTm9uZVxuICAgICAgfCBPbmUgKF8sIHIpIHwgVHdvIChfLCBfLCByKSAtPiBTb21lIChGcmFnbWVudC5tYXhfa2V5IHIpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleSA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBsZXQgYnVpbGRlciwgbGVuZ3RoID1cbiAgICAgICAgU2VxdWVuY2UuZm9sZFxuICAgICAgICAgIHNlcVxuICAgICAgICAgIH5pbml0OihCdWlsZF9pbmNyZWFzaW5nLmVtcHR5LCAwKVxuICAgICAgICAgIH5mOihmdW4gKGJ1aWxkZXIsIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIG1hdGNoIEJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSBidWlsZGVyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmVfa2V5IHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlOiBub24taW5jcmVhc2luZyBrZXlcIilcbiAgICAgICAgICAgIHwgXyAtPiBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgYnVpbGRlciB+a2V5IH5kYXRhLCBsZW5ndGggKyAxKVxuICAgICAgaW5cbiAgICAgIE9rIChCdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWVfdW5jaGVja2VkIGJ1aWxkZXIsIGxlbmd0aCkpXG4gIDs7XG5cbiAgKCogTGlrZSBbYmFsXSBidXQgYWxsb3dzIGFueSBkaWZmZXJlbmNlIGluIGhlaWdodCBiZXR3ZWVuIFtsXSBhbmQgW3JdLlxuXG4gICAgIE8ofGhlaWdodCBsIC0gaGVpZ2h0IHJ8KSAqKVxuICBsZXQgcmVjIGpvaW4gbCBrIGQgciB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gc2V0JyByIGsgZCB+Y29tcGFyZV9rZXlcbiAgICB8IF8sIEVtcHR5IC0+IHNldCcgbCBrIGQgfmNvbXBhcmVfa2V5XG4gICAgfCBMZWFmIChsaywgbGQpLCBfIC0+IHNldCcgKHNldCcgciBrIGQgfmNvbXBhcmVfa2V5KSBsayBsZCB+Y29tcGFyZV9rZXlcbiAgICB8IF8sIExlYWYgKHJrLCByZCkgLT4gc2V0JyAoc2V0JyBsIGsgZCB+Y29tcGFyZV9rZXkpIHJrIHJkIH5jb21wYXJlX2tleVxuICAgIHwgTm9kZSAobGwsIGxrLCBsZCwgbHIsIGxoKSwgTm9kZSAocmwsIHJrLCByZCwgcnIsIHJoKSAtPlxuICAgICAgKCogW2JhbF0gcmVxdWlyZXMgaGVpZ2h0IGRpZmZlcmVuY2UgPD0gMy4gKilcbiAgICAgIGlmIGxoID4gcmggKyAzXG4gICAgICAoKiBbaGVpZ2h0IGxyID49IGhlaWdodCByXSxcbiAgICAgICAgIHRoZXJlZm9yZSBbaGVpZ2h0IChqb2luIGxyIGsgZCByIC4uLildIGlzIFtoZWlnaHQgcmwgKyAxXSBvciBbaGVpZ2h0IHJsXVxuICAgICAgICAgdGhlcmVmb3JlIHRoZSBoZWlnaHQgZGlmZmVyZW5jZSB3aXRoIFtsbF0gd2lsbCBiZSA8PSAzICopXG4gICAgICB0aGVuIGJhbCBsbCBsayBsZCAoam9pbiBsciBrIGQgciB+Y29tcGFyZV9rZXkpXG4gICAgICBlbHNlIGlmIHJoID4gbGggKyAzXG4gICAgICB0aGVuIGJhbCAoam9pbiBsIGsgZCBybCB+Y29tcGFyZV9rZXkpIHJrIHJkIHJyXG4gICAgICBlbHNlIGJhbCBsIGsgZCByXG4gIDs7XG5cbiAgbGV0IHJlYyBzcGxpdCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgIHwgTGVhZiAoaywgZCkgLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSB4IGsgaW5cbiAgICAgIGlmIGNtcCA9IDBcbiAgICAgIHRoZW4gRW1wdHksIFNvbWUgKGssIGQpLCBFbXB0eVxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIEVtcHR5LCBOb25lLCB0XG4gICAgICBlbHNlIHQsIE5vbmUsIEVtcHR5XG4gICAgfCBOb2RlIChsLCBrLCBkLCByLCBfKSAtPlxuICAgICAgbGV0IGNtcCA9IGNvbXBhcmVfa2V5IHggayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBsLCBTb21lIChrLCBkKSwgclxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBtYXliZSwgbHIgPSBzcGxpdCBsIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGxsLCBtYXliZSwgam9pbiBsciBrIGQgciB+Y29tcGFyZV9rZXkpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJsLCBtYXliZSwgcnIgPSBzcGxpdCByIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGpvaW4gbCBrIGQgcmwgfmNvbXBhcmVfa2V5LCBtYXliZSwgcnIpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB0IH5pbnRvIHggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgbGVmdCwgYm91bmRhcnlfb3B0LCByaWdodCA9IHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICBtYXRjaCBib3VuZGFyeV9vcHQgd2l0aFxuICAgIHwgTm9uZSAtPiBsZWZ0LCByaWdodFxuICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPlxuICAgICAgbGV0IGluc2VydF9pbnRvIHRyZWUgPSBmc3QgKHNldCB0cmVlIH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleSkgaW5cbiAgICAgIChtYXRjaCBpbnRvIHdpdGhcbiAgICAgICB8IGBMZWZ0IC0+IGluc2VydF9pbnRvIGxlZnQsIHJpZ2h0XG4gICAgICAgfCBgUmlnaHQgLT4gbGVmdCwgaW5zZXJ0X2ludG8gcmlnaHQpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfihsb3dlcl9ib3VuZCA6ICdhIE1heWJlX2JvdW5kLnQpXG4gICAgICAgIH4odXBwZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICA9XG4gICAgaWYgTWF5YmVfYm91bmQuYm91bmRzX2Nyb3NzZWRcbiAgICAgICAgIH5jb21wYXJlOmNvbXBhcmVfa2V5XG4gICAgICAgICB+bG93ZXI6bG93ZXJfYm91bmRcbiAgICAgICAgIH51cHBlcjp1cHBlcl9ib3VuZFxuICAgIHRoZW4gZW1wdHksIGVtcHR5LCBlbXB0eVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGxlZnQsIG1pZF9hbmRfcmlnaHQgPVxuICAgICAgICBtYXRjaCBsb3dlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IGVtcHR5LCB0XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZXQgbWlkLCByaWdodCA9XG4gICAgICAgIG1hdGNoIHVwcGVyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gbWlkX2FuZF9yaWdodCwgZW1wdHlcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT5cbiAgICAgICAgICBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGVmdCwgbWlkLCByaWdodClcbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmICh2LCBkKSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gU29tZSBkIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZCBlbHNlIGZpbmQgKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBkYXRhID0gZGF0YSA6OiBPcHRpb24udmFsdWUgKGZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5KSB+ZGVmYXVsdDpbXSBpblxuICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBbXVxuICAgIHwgU29tZSBsIC0+IGxcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBpZl9ub3RfZm91bmQga2V5IH5zZXhwX29mX2tleSA9XG4gICAgICByYWlzZSAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiTWFwLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgc2V4cF9vZl9rZXkga2V5IF0pKVxuICAgIGluXG4gICAgbGV0IHJlYyBmaW5kX2V4biB0IHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBkIGVsc2UgaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gZCBlbHNlIGZpbmRfZXhuIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXlcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBmaW5kX2V4blxuICA7O1xuXG4gIGxldCBtZW0gdCB4IH5jb21wYXJlX2tleSA9IE9wdGlvbi5pc19zb21lIChmaW5kIHQgeCB+Y29tcGFyZV9rZXkpXG5cbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIGQpIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChFbXB0eSwgaywgZCwgXywgXykgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKGwsIF8sIF8sIF8sIF8pIC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5UcmVlMC5NYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5UcmVlMC5NYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCBkKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoXywgaywgZCwgRW1wdHksIF8pIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChfLCBfLCBfLCByLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgXywgciwgXykgLT4gclxuICAgIHwgTm9kZSAobCwgeCwgZCwgciwgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB4IGQgclxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBtYXhfZWx0IGxvd2VyX3BhcnQsIG1pbl9lbHQgdXBwZXJfcGFydCB3aXRoXG4gICAgfCBOb25lLCBfIC0+IGBPayB1cHBlcl9wYXJ0XG4gICAgfCBfLCBOb25lIC0+IGBPayBsb3dlcl9wYXJ0XG4gICAgfCBTb21lIChtYXhfbG93ZXIsIF8pLCBTb21lIChtaW5fdXBwZXIsIHYpIHdoZW4gY29tcGFyZV9rZXkgbWF4X2xvd2VyIG1pbl91cHBlciA8IDAgLT5cbiAgICAgIGxldCB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluID0gcmVtb3ZlX21pbl9lbHQgdXBwZXJfcGFydCBpblxuICAgICAgYE9rIChqb2luIH5jb21wYXJlX2tleSBsb3dlcl9wYXJ0IG1pbl91cHBlciB2IHVwcGVyX3BhcnRfd2l0aG91dF9taW4pXG4gICAgfCBfIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlID1cbiAgICAoKiBUaGlzIGFzc3VtZXMgdGhhdCBtaW4gPD0gbWF4LCB3aGljaCBpcyBjaGVja2VkIGJ5IHRoZSBvdXRlciBmdW5jdGlvbi4gKilcbiAgICBsZXQgcmVjIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW5pdFxuICAgICAgfCBMZWFmIChrLCBkKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIG1pbiA8IDAgfHwgY29tcGFyZV9rZXkgayBtYXggPiAwXG4gICAgICAgIHRoZW4gKCogayA8IG1pbiB8fCBrID4gbWF4ICopXG4gICAgICAgICAgaW5pdFxuICAgICAgICBlbHNlIGYgfmtleTprIH5kYXRhOmQgaW5pdFxuICAgICAgfCBOb2RlIChsLCBrLCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgY19taW4gPSBjb21wYXJlX2tleSBrIG1pbiBpblxuICAgICAgICBpZiBjX21pbiA8IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPCBtaW4sIHRoZW4gdGhpcyBub2RlIGFuZCBpdHMgbGVmdCBicmFuY2ggYXJlIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgaWYgY19taW4gPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrID0gbWluLCB0aGVuIHRoaXMgbm9kZSdzIGxlZnQgYnJhbmNoIGlzIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQ6KGYgfmtleTprIH5kYXRhOmQgaW5pdCkgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGsgPiBtaW4gKilcbiAgICAgICAgICBsZXQgeiA9IGdvIGwgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGxldCBjX21heCA9IGNvbXBhcmVfa2V5IGsgbWF4IGluXG4gICAgICAgICAgKCogaWYgayA+IG1heCwgd2UncmUgZG9uZSAqKVxuICAgICAgICAgIGlmIGNfbWF4ID4gMFxuICAgICAgICAgIHRoZW4gelxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHogPSBmIH5rZXk6ayB+ZGF0YTpkIHogaW5cbiAgICAgICAgICAgICgqIGlmIGsgPSBtYXgsIHRoZW4gd2UgZm9sZCBpbiB0aGlzIG9uZSBsYXN0IHZhbHVlIGFuZCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgICBpZiBjX21heCA9IDAgdGhlbiB6IGVsc2UgZ28gciB+bWluIH5tYXggfmluaXQ6eiB+ZiB+Y29tcGFyZV9rZXkpKVxuICAgIGluXG4gICAgZnVuIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgY29tcGFyZV9rZXkgbWluIG1heCA8PSAwIHRoZW4gZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGVsc2UgaW5pdFxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXkgPVxuICAgIExpc3QucmV2XG4gICAgICAoZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgICAgIHRcbiAgICAgICAgIH5taW5cbiAgICAgICAgIH5tYXhcbiAgICAgICAgIH5pbml0OltdXG4gICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgbCAtPiAoa2V5LCBkYXRhKSA6OiBsKVxuICAgICAgICAgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBjb25jYXRfdW5jaGVja2VkIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHgsIGQgPSBtaW5fZWx0X2V4biB0MiBpblxuICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFJlbW92ZV9ub19vcFxuXG4gIGxldCByZW1vdmUgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIHJlbW92ZV9sb29wIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFJlbW92ZV9ub19vcFxuICAgICAgfCBMZWFmICh2LCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSB4IHYgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIGxlbmd0aCAtIDFcbiAgICAgICAgZWxzZSBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gY29uY2F0X3VuY2hlY2tlZCBsIHIsIGxlbmd0aCAtIDFcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gcmVtb3ZlX2xvb3AgbCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHJlbW92ZV9sb29wIHIgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB0cnkgcmVtb3ZlX2xvb3AgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IFJlbW92ZV9ub19vcCAtPiB0LCBsZW5ndGhcbiAgOztcblxuICAoKiBVc2UgZXhjZXB0aW9uIHRvIGF2b2lkIHRyZWUtcmVidWlsZCBpbiBuby1vcCBjYXNlICopXG4gIGV4Y2VwdGlvbiBDaGFuZ2Vfbm9fb3BcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIGNoYW5nZV9jb3JlIHQga2V5IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgIChtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IHJhaXNlIENoYW5nZV9ub19vcCAoKiBlcXVpdmFsZW50IHRvIHJldHVybmluZzogRW1wdHkgKilcbiAgICAgICAgIHwgU29tZSBkYXRhIC0+IExlYWYgKGtleSwgZGF0YSksIGxlbmd0aCArIDEpXG4gICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5LCBsZW5ndGggLSAxXG4gICAgICAgICAgfCBTb21lIGQnIC0+IExlYWYgKHYsIGQnKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCBFbXB0eSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgRW1wdHkgdiBkIHIsIGxlbmd0aClcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0X3VuY2hlY2tlZCBsIHIsIGxlbmd0aCAtIDFcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2RlIChsLCBrZXksIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIGwga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgciBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB0cnkgY2hhbmdlX2NvcmUgdCBrZXkgZiB3aXRoXG4gICAgfCBDaGFuZ2Vfbm9fb3AgLT4gdCwgbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyB1cGRhdGVfY29yZSB0IGtleSBmID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICBsZXQgZGF0YSA9IGYgTm9uZSBpblxuICAgICAgICBMZWFmIChrZXksIGRhdGEpLCBsZW5ndGggKyAxXG4gICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGQnID0gZiAoU29tZSBkKSBpblxuICAgICAgICAgIExlYWYgKHYsIGQnKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSB1cGRhdGVfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCBFbXB0eSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgRW1wdHkgdiBkIHIsIGxlbmd0aClcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZGF0YSA9IGYgKFNvbWUgZCkgaW5cbiAgICAgICAgICBOb2RlIChsLCBrZXksIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIGwga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgciBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB1cGRhdGVfY29yZSB0IGtleSBmXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgY2hhbmdlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIHwgU29tZSAoW10gfCBbIF8gXSkgLT4gTm9uZVxuICAgICAgfCBTb21lIChfIDo6IChfIDo6IF8gYXMgbm9uX2VtcHR5X3RhaWwpKSAtPiBTb21lIG5vbl9lbXB0eV90YWlsKVxuICA7O1xuXG4gIGxldCByZWMgaXRlcl9rZXlzIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKHYsIF8pIC0+IGYgdlxuICAgIHwgTm9kZSAobCwgdiwgXywgciwgXykgLT5cbiAgICAgIGl0ZXJfa2V5cyB+ZiBsO1xuICAgICAgZiB2O1xuICAgICAgaXRlcl9rZXlzIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAoXywgZCkgLT4gZiBkXG4gICAgfCBOb2RlIChsLCBfLCBkLCByLCBfKSAtPlxuICAgICAgaXRlciB+ZiBsO1xuICAgICAgZiBkO1xuICAgICAgaXRlciB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgaXRlcmkgfmYgbDtcbiAgICAgIGYgfmtleTp2IH5kYXRhOmQ7XG4gICAgICBpdGVyaSB+ZiByXG4gIDs7XG5cbiAgbGV0IGl0ZXJpX3VudGlsID1cbiAgICBsZXQgcmVjIGl0ZXJpX3VudGlsX2xvb3AgdCB+ZiA6IENvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggaXRlcmlfdW50aWxfbG9vcCB+ZiBsIHdpdGhcbiAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICB8IENvbnRpbnVlIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICAgICB8IENvbnRpbnVlIC0+IGl0ZXJpX3VudGlsX2xvb3AgfmYgcikpXG4gICAgaW5cbiAgICBmdW4gdCB+ZiAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLm9mX2NvbnRpbnVlX29yX3N0b3AgKGl0ZXJpX3VudGlsX2xvb3AgdCB+ZilcbiAgOztcblxuICBsZXQgcmVjIG1hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmICh2LCBkKSAtPiBMZWFmICh2LCBmIGQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgbGV0IHInID0gbWFwIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBtYXBpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+IExlYWYgKHYsIGYgfmtleTp2IH5kYXRhOmQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwaSB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBtYXBpIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkIHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2xvb3AgdCB+YWNjIH5mIDogKF8sIF8pIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY1xuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9sb29wIGwgfmFjYyB+ZiB3aXRoXG4gICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgYWNjIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBmb2xkX3VudGlsX2xvb3AgciB+YWNjIH5mKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfbG9vcCB0IH5hY2M6aW5pdCB+ZiB3aXRoXG4gICAgfCBDb250aW51ZSBhY2MgLT4gZmluaXNoIGFjY1xuICAgIHwgU3RvcCBzdG9wIC0+IHN0b3BcbiAgOztcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGZvbGRfcmlnaHQgfmYgbCB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIGtleSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cblxuICBsZXQgZmlsdGVyIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYgZGF0YSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiB+a2V5IH5kYXRhIHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBtYXRjaCBmIGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+IGFjY3UsIGxlbmd0aFxuICAgICAgfCBTb21lIGIgLT4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YTpiIGFjY3UgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+IGFjY3UsIGxlbmd0aFxuICAgICAgfCBTb21lIGIgLT4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YTpiIGFjY3UgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZFxuICAgICAgdFxuICAgICAgfmluaXQ6KChFbXB0eSwgMCksIChFbXB0eSwgMCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKHBhaXIxLCBwYWlyMikgLT5cbiAgICAgICAgbWF0Y2ggKGYgfmtleSB+ZGF0YSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCB4IC0+XG4gICAgICAgICAgbGV0IHQsIGxlbmd0aCA9IHBhaXIxIGluXG4gICAgICAgICAgc2V0IHQgfmtleSB+ZGF0YTp4IH5jb21wYXJlX2tleSB+bGVuZ3RoLCBwYWlyMlxuICAgICAgICB8IFNlY29uZCB5IC0+XG4gICAgICAgICAgbGV0IHQsIGxlbmd0aCA9IHBhaXIyIGluXG4gICAgICAgICAgcGFpcjEsIHNldCB0IH5rZXkgfmRhdGE6eSB+Y29tcGFyZV9rZXkgfmxlbmd0aClcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgaWYgZiBkYXRhIHRoZW4gRmlyc3QgZGF0YSBlbHNlIFNlY29uZCBkYXRhKVxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnaywgJ3YsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnayAqICd2ICogKCdrLCAndikgdHJlZSAqICgnaywgJ3YsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyB0IChlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCB0IChlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnNfcmlnaHQgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl90cmVlIHRyZWUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9IGNvbnMgdHJlZSBFbmRcbiAgICBsZXQgb2ZfdHJlZV9yaWdodCB0cmVlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHRyZWUgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgXywgciwgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgXywgXywgXykgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBjID0gY29tcGFyZV9kYXRhIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgICAgZWxzZSBpZiBwaHlzX2VxdWFsIHIxIHIyXG4gICAgICAgICAgICB0aGVuIGxvb3AgZTEgZTJcbiAgICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGRhdGFfZXF1YWwgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiB0cnVlXG4gICAgICAgIHwgRW5kLCBfIHwgXywgRW5kIC0+IGZhbHNlXG4gICAgICAgIHwgTW9yZSAodjEsIGQxLCByMSwgZTEpLCBNb3JlICh2MiwgZDIsIHIyLCBlMikgLT5cbiAgICAgICAgICBjb21wYXJlX2tleSB2MSB2MiA9IDBcbiAgICAgICAgICAmJiBkYXRhX2VxdWFsIGQxIGQyXG4gICAgICAgICAgJiYgaWYgcGh5c19lcXVhbCByMSByMiB0aGVuIGxvb3AgZTEgZTIgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMilcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCByZWMgZm9sZCB+aW5pdCB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiBpbml0XG4gICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgbGV0IG5leHQgPSBmIH5rZXkgfmRhdGEgaW5pdCBpblxuICAgICAgICBmb2xkIChjb25zIHRyZWUgZW51bSkgfmluaXQ6bmV4dCB+ZlxuICAgIDs7XG5cbiAgICBsZXQgZm9sZDIgY29tcGFyZV9rZXkgdDEgdDIgfmluaXQgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyIGN1cnIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IGN1cnJcbiAgICAgICAgfCBFbmQsIF8gLT5cbiAgICAgICAgICBmb2xkIHQyIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBSaWdodCBkYXRhKSBhY2MpXG4gICAgICAgIHwgXywgRW5kIC0+XG4gICAgICAgICAgZm9sZCB0MSB+aW5pdDpjdXJyIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gZiB+a2V5IH5kYXRhOihgTGVmdCBkYXRhKSBhY2MpXG4gICAgICAgIHwgTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpLCBNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBCb3RoICh2MSwgdjIpKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBMZWZ0IHYxKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSB0MiBuZXh0KVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azIgfmRhdGE6KGBSaWdodCB2MikgY3VyciBpblxuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyIGluaXRcbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkICgoa2V5LCBgUmlnaHQgZGF0YSksIChFbmQsIGNvbnMgdHJlZSBlbnVtKSlcbiAgICAgICAgfCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pLCBFbmQgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkICgoa2V5LCBgTGVmdCBkYXRhKSwgKGNvbnMgdHJlZSBlbnVtLCBFbmQpKVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBpZiBkYXRhX2VxdWFsIHYxIHYyXG4gICAgICAgICAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuU2tpcCBuZXh0X3N0YXRlXG4gICAgICAgICAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMSwgYFVuZXF1YWwgKHYxLCB2MikpLCBuZXh0X3N0YXRlKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsxLCBgTGVmdCB2MSksIChjb25zIHRyZWUxIGVudW0xLCByaWdodCkpXG4gICAgICAgICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazIsIGBSaWdodCB2MiksIChsZWZ0LCBjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDoob2ZfdHJlZSB0MSwgb2ZfdHJlZSB0MikgfmY6c3RlcFxuICAgIDs7XG5cbiAgICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICAgbGV0IGFkZCBhY2MgayB2ID0gZiBhY2MgKGssIGBSaWdodCB2KSBpblxuICAgICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgICBsZXQgcmVjIGxvb3AgbGVmdCByaWdodCBhY2MgPVxuICAgICAgICBtYXRjaCBsZWZ0LCByaWdodCB3aXRoXG4gICAgICAgIHwgRW5kLCBlbnVtIC0+IGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IGVudW0sIEVuZCAtPiBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gaWYgZGF0YV9lcXVhbCB2MSB2MiB0aGVuIGFjYyBlbHNlIGYgYWNjIChrMSwgYFVuZXF1YWwgKHYxLCB2MikpIGluXG4gICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICB0aGVuIGxvb3AgZW51bTEgZW51bTIgYWNjXG4gICAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSBhY2MpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsxIHYxIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSByaWdodCBhY2MpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrMiB2MiBpblxuICAgICAgICAgICAgbG9vcCBsZWZ0IChjb25zIHRyZWUyIGVudW0yKSBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAob2ZfdHJlZSB0MSkgKG9mX3RyZWUgdDIpIGluaXRcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoaywgdiksIEVudW0uY29ucyB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlIHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGssIHYpLCBFbnVtLmNvbnNfcmlnaHQgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZV9yaWdodCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZVxuICAgICAgICBjb21wYXJhdG9yXG4gICAgICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZ19rZXkpXG4gICAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2tleSBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPiBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19sZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgRW51bS5lcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MilcbiAgOztcblxuICBsZXQgaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyXG4gICAgICBjb21wYXJlX2tleVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MSlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDIpXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICgpIC0+IGYgfmtleSB+ZGF0YSlcbiAgOztcblxuICBsZXQgZm9sZDIgdDEgdDIgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyIGNvbXBhcmVfa2V5IChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpIH5mIH5pbml0XG4gIDs7XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmID0gRW51bS5zeW1tZXRyaWNfZGlmZlxuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgKCogW0VudW0uZm9sZF9kaWZmc10gaXMgYSBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24sIGJ1dCBpcyBjb25zaWRlcmFibHlcbiAgICAgICBzbG93ZXIsIGFzIHdlIGhhdmUgdG8gYWxsb2NhdGUgcXVpdGUgYSBsb3Qgb2Ygc3RhdGUgdG8gdHJhY2sgZW51bWVyYXRpb24gb2YgYSB0cmVlLlxuICAgICAgIEF2b2lkIGlmIHdlIGNhbi5cbiAgICAqKVxuICAgIGxldCBzbG93IHggeSB+aW5pdCA9IEVudW0uZm9sZF9zeW1tZXRyaWNfZGlmZiB4IHkgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5mIH5pbml0IGluXG4gICAgbGV0IGFkZCBhY2MgayB2ID0gZiBhY2MgKGssIGBSaWdodCB2KSBpblxuICAgIGxldCByZW1vdmUgYWNjIGsgdiA9IGYgYWNjIChrLCBgTGVmdCB2KSBpblxuICAgIGxldCBkZWx0YSBhY2MgayB2IHYnID0gaWYgZGF0YV9lcXVhbCB2IHYnIHRoZW4gYWNjIGVsc2UgZiBhY2MgKGssIGBVbmVxdWFsICh2LCB2JykpIGluXG4gICAgKCogSWYgdHdvIHRyZWVzIGhhdmUgdGhlIHNhbWUgc3RydWN0dXJlIGF0IHRoZSByb290IChhbmQgdGhlIHNhbWUga2V5LCBpZiB0aGV5J3JlXG4gICAgICAgW05vZGVdcykgd2UgY2FuIHRyaXZpYWxseSBkaWZmIGVhY2ggc3VicGFydCBpbiBvYnZpb3VzIHdheXMuICopXG4gICAgbGV0IHJlYyBsb29wIHQgdCcgYWNjID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgdCB0J1xuICAgICAgdGhlbiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0LCB0JyB3aXRoXG4gICAgICAgIHwgRW1wdHksIG5ld192YWxzIC0+XG4gICAgICAgICAgZm9sZCBuZXdfdmFscyB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IG9sZF92YWxzLCBFbXB0eSAtPlxuICAgICAgICAgIGZvbGQgb2xkX3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBMZWFmIChrLCB2KSwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSBrIGsnIHdpdGhcbiAgICAgICAgICAgfCB4IHdoZW4geCA9IDAgLT4gZGVsdGEgYWNjIGsgdiB2J1xuICAgICAgICAgICB8IHggd2hlbiB4IDwgMCAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsgdiBpblxuICAgICAgICAgICAgIGFkZCBhY2MgaycgdidcbiAgICAgICAgICAgfCBfICgqIHdoZW4geCA+IDAgKikgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrJyB2JyBpblxuICAgICAgICAgICAgIHJlbW92ZSBhY2MgayB2KVxuICAgICAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pLCBOb2RlIChsJywgaycsIHYnLCByJywgXykgd2hlbiBjb21wYXJlX2tleSBrIGsnID0gMCAtPlxuICAgICAgICAgIGxldCBhY2MgPSBsb29wIGwgbCcgYWNjIGluXG4gICAgICAgICAgbGV0IGFjYyA9IGRlbHRhIGFjYyBrIHYgdicgaW5cbiAgICAgICAgICBsb29wIHIgcicgYWNjXG4gICAgICAgICgqIE91ciByb290cyBhcmVuJ3QgdGhlIHNhbWUga2V5LiBGYWxsYmFjayB0byB0aGUgc2xvdyBtb2RlLiBUcmVlcyB3aXRoIHNtYWxsXG4gICAgICAgICAgIGRpZmZzIHdpbGwgb25seSBkbyB0aGlzIG9uIHZlcnkgc21hbGwgcGFydHMgb2YgdGhlIHRyZWUgKGhvcGVmdWxseSAtIGlmIHRoZVxuICAgICAgICAgICBvdmVyYWxsIHJvb3QgaXMgcmViYWxhbmNlZCwgd2UnbGwgZWF0IHRoZSB3aG9sZSBjb3N0LCB1bmZvcnR1bmF0ZWx5LikgKilcbiAgICAgICAgfCBOb2RlIF8sIE5vZGUgXyB8IE5vZGUgXywgTGVhZiBfIHwgTGVhZiBfLCBOb2RlIF8gLT4gc2xvdyB0IHQnIH5pbml0OmFjYylcbiAgICBpblxuICAgIGxvb3AgdDEgdDIgaW5pdFxuICA7O1xuXG4gIGxldCByZWMgbGVuZ3RoID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChsLCBfLCBfLCByLCBfKSAtPiBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBmb2xkXG4gICAgICB0XG4gICAgICB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIHN0YXRlIC0+IGhhc2hfZm9sZF9kYXRhIChoYXNoX2ZvbGRfa2V5IHN0YXRlIGtleSkgZGF0YSlcbiAgOztcblxuICBsZXQga2V5cyB0ID0gZm9sZF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6XyBsaXN0IC0+IGtleSA6OiBsaXN0KSB0IH5pbml0OltdXG4gIGxldCBkYXRhIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleTpfIH5kYXRhIGxpc3QgLT4gZGF0YSA6OiBsaXN0KSB0IH5pbml0OltdXG5cbiAgbW9kdWxlIHR5cGUgRm9sZGFibGUgPSBzaWdcbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2JcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2ZvbGRhYmxlIChNIDogRm9sZGFibGUpID0gc3RydWN0XG4gICAgbGV0IG9mX2ZvbGRhYmxlX2ZvbGQgZm9sZGFibGUgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKGFjY3VtLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgIGxldCBwcmV2X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluaXRcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2XG4gICAgICAgIGluXG4gICAgICAgIGxldCBkYXRhID0gZiBwcmV2X2RhdGEgZGF0YSBpblxuICAgICAgICBzZXQgYWNjdW0gfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX3JlZHVjZSBmb2xkYWJsZSB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAoYWNjdW0sIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgbGV0IG5ld19kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YTpuZXdfZGF0YSB+Y29tcGFyZV9rZXkpXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBtYXAgPVxuICAgICAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKHQsIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIGxldCAoKF8sIGxlbmd0aCcpIGFzIGFjYykgPSBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICBpZiBsZW5ndGggPSBsZW5ndGgnIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkgZWxzZSBhY2MpXG4gICAgICAgIGluXG4gICAgICAgIGBPayBtYXApXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9vcl9lcnJvciBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgICAgICAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9vcl9lcnJvcjogZHVwbGljYXRlIGtleVwiKVxuICAgICAgICAgIGtleVxuICAgICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9leG4gZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4geFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX2V4bjogZHVwbGljYXRlIGtleVwiKSBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgT2ZfYWxpc3QgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwiYWxpc3RcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgIGxldCBmb2xkID0gTGlzdC5mb2xkXG4gICAgZW5kKVxuXG4gIGxldCBvZl9hbGlzdF9mb2xkID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9hbGlzdCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9hbGlzdF9leG4gPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9leG5cblxuICAoKiBSZXZlcnNlIHRoZSBpbnB1dCwgdGhlbiBmb2xkIGZyb20gbGVmdCB0byByaWdodC4gVGhlIHJlc3VsdGluZyBtYXAgdXNlcyB0aGUgZmlyc3RcbiAgICAgaW5zdGFuY2Ugb2YgZWFjaCBrZXkgZnJvbSB0aGUgaW5wdXQgbGlzdC4gVGhlIHJlbGF0aXZlIG9yZGVyaW5nIG9mIGVsZW1lbnRzIGluIGVhY2hcbiAgICAgb3V0cHV0IGxpc3QgaXMgdGhlIHNhbWUgYXMgaW4gdGhlIGlucHV0IGxpc3QuICopXG4gIGxldCBvZl9mb2xkYWJsZV9tdWx0aSBmb2xkYWJsZSB+Zm9sZCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhbGlzdCA9IGZvbGQgZm9sZGFibGUgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSBpblxuICAgIG9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5ID1cbiAgICBvZl9mb2xkYWJsZV9tdWx0aSBhbGlzdCB+Zm9sZDpMaXN0LmZvbGQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIE9mX3NlcXVlbmNlID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgICAgbGV0IG5hbWUgPSBcInNlcXVlbmNlXCJcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgICBsZXQgZm9sZCA9IFNlcXVlbmNlLmZvbGRcbiAgICBlbmQpXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX3NlcXVlbmNlID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVcbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX3NlcXVlbmNlX2V4biA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2V4blxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzZXF1ZW5jZSB+Y29tcGFyZV9rZXkgPVxuICAgIG9mX2ZvbGRhYmxlX211bHRpIHNlcXVlbmNlIH5mb2xkOlNlcXVlbmNlLmZvbGQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIG5vdCAoZiBkYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgbm90IChmIH5rZXkgfmRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSlcbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBmIGRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKVxuICA7O1xuXG4gIGxldCBleGlzdHNpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSlcbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG4gIDs7XG5cbiAgbGV0IHRvX2FsaXN0ID8oa2V5X29yZGVyID0gYEluY3JlYXNpbmcpIHQgPVxuICAgIG1hdGNoIGtleV9vcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZyAtPiBmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgICB8IGBEZWNyZWFzaW5nIC0+IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgeCAtPiAoa2V5LCBkYXRhKSA6OiB4KVxuICA7O1xuXG4gIGxldCBtZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBlbHRzID0gVW5pZm9ybV9hcnJheS51bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjoobGVuZ3RoIHQxICsgbGVuZ3RoIHQyKSBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBpdGVyMiB0MSB0MiB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5IH5kYXRhOnZhbHVlcyAtPlxuICAgICAgbWF0Y2ggZiB+a2V5IHZhbHVlcyB3aXRoXG4gICAgICB8IFNvbWUgdmFsdWUgLT5cbiAgICAgICAgVW5pZm9ybV9hcnJheS5zZXQgZWx0cyAhaSAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGluY3IgaVxuICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICBsZXQgbGVuID0gIWkgaW5cbiAgICBsZXQgZ2V0IGkgPSBVbmlmb3JtX2FycmF5LmdldCBlbHRzIGkgaW5cbiAgICBsZXQgdHJlZSA9IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmY6Z2V0IGluXG4gICAgdHJlZSwgbGVuXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCA9XG4gICAgbGV0IG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aF9sYXJnZSB0X2xhcmdlIHRfc21hbGwgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGZvbGQgdF9zbWFsbCB+aW5pdDoodF9sYXJnZSwgbGVuZ3RoX2xhcmdlKSB+ZjooZnVuIH5rZXkgfmRhdGE6ZGF0YScgKHQsIGxlbmd0aCkgLT5cbiAgICAgICAgdXBkYXRlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBkYXRhJ1xuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IGNhbGwgY29tYmluZSB+a2V5IGRhdGEgZGF0YScpKVxuICAgIGluXG4gICAgbGV0IGNhbGwgZiB+a2V5IHggeSA9IGYgfmtleSB4IHkgaW5cbiAgICBsZXQgc3dhcCBmIH5rZXkgeCB5ID0gZiB+a2V5IHkgeCBpblxuICAgIGZ1biB0MSB0MiB+bGVuZ3RoMSB+bGVuZ3RoMiB+Y29tYmluZSB+Y29tcGFyZV9rZXkgLT5cbiAgICAgIGlmIGxlbmd0aDIgPD0gbGVuZ3RoMVxuICAgICAgdGhlbiBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgxIHQxIHQyIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgyIHQyIHQxIH5jYWxsOnN3YXAgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIENsb3Nlc3Rfa2V5X2ltcGwgPSBzdHJ1Y3RcbiAgICAoKiBbbWFya2VyXSBhbmQgW3JlcGFja2FnZV0gYWxsb3cgdXMgdG8gY3JlYXRlIFwibG9naWNhbFwiIG9wdGlvbnMgd2l0aG91dCBhY3R1YWxseVxuICAgICAgIGFsbG9jYXRpbmcgYW55IG9wdGlvbnMuIFBhc3NpbmcgW0ZvdW5kIGtleSB2YWx1ZV0gdG8gYSBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgcGFzc2luZyBbU29tZSAoa2V5LCB2YWx1ZSldOyBwYXNzaW5nIFtNaXNzaW5nICgpICgpXSBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmdcbiAgICAgICBbTm9uZV0uICopXG4gICAgdHlwZSAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyID1cbiAgICAgIHwgTWlzc2luZyA6ICgnaywgJ3YsIHVuaXQsIHVuaXQpIG1hcmtlclxuICAgICAgfCBGb3VuZCA6ICgnaywgJ3YsICdrLCAndikgbWFya2VyXG5cbiAgICBsZXQgcmVwYWNrYWdlXG4gICAgICAgICAgKHR5cGUgayB2IGtfb3B0IHZfb3B0KVxuICAgICAgICAgIChtYXJrZXIgOiAoaywgdiwga19vcHQsIHZfb3B0KSBtYXJrZXIpXG4gICAgICAgICAgKGsgOiBrX29wdClcbiAgICAgICAgICAodiA6IHZfb3B0KVxuICAgICAgOiAoayAqIHYpIG9wdGlvblxuICAgICAgPVxuICAgICAgbWF0Y2ggbWFya2VyIHdpdGhcbiAgICAgIHwgTWlzc2luZyAtPiBOb25lXG4gICAgICB8IEZvdW5kIC0+IFNvbWUgKGssIHYpXG4gICAgOztcblxuICAgICgqIFRoZSB0eXBlIHNpZ25hdHVyZSBpcyBleHBsaWNpdCBoZXJlIHRvIGFsbG93IHBvbHltb3JwaGljIHJlY3Vyc2lvbi4gKilcbiAgICBsZXQgcmVjIGxvb3AgOlxuICAgICAgJ2sgJ3YgJ2tfb3B0ICd2X29wdC5cbiAgICAgICgnaywgJ3YpIHRyZWVcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrXG4gICAgICAtPiBjb21wYXJlX2tleTooJ2sgLT4gJ2sgLT4gaW50KVxuICAgICAgLT4gKCdrLCAndiwgJ2tfb3B0LCAndl9vcHQpIG1hcmtlclxuICAgICAgLT4gJ2tfb3B0XG4gICAgICAtPiAndl9vcHRcbiAgICAgIC0+ICgnayAqICd2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIGZ1biB0IGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIC0+XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgIHwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICAgIGlmIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIC0+IGMgPj0gMFxuICAgICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+IGMgPiAwXG4gICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IGMgPD0gMFxuICAgICAgICAgICAgfCBgTGVzc190aGFuIC0+IGMgPCAwXG4gICAgICAgICAgdGhlbiBTb21lIChrJywgdicpXG4gICAgICAgICAgZWxzZSByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICB8IE5vZGUgKGwsIGsnLCB2JywgciwgXykgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgICBpZiBjID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgKCogVGhpcyBpcyBhIGJhc2UgY2FzZSAobm8gcmVjdXJzaXZlIGNhbGwpLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgTGVzc19vcl9lcXVhbF90byAtPiBTb21lIChrJywgdicpXG4gICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgciB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWluX2VsdCByXG4gICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgbCB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWF4X2VsdCBsKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgKCogV2UgYXJlIGd1YXJhbnRlZWQgaGVyZSB0aGF0IGsnIDw+IGsuICopXG4gICAgICAgICAgICAoKiBUaGlzIGlzIHRoZSBvbmx5IHJlY3Vyc2l2ZSBjYXNlLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGMgPiAwXG4gICAgICAgICAgICAgIHRoZW4gbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBGb3VuZCBrJyB2J1xuICAgICAgICAgICAgICBlbHNlIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgICAgICAgdGhlbiBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIgayB+Y29tcGFyZV9rZXkgPSBsb29wIHQgZGlyIGsgfmNvbXBhcmVfa2V5IE1pc3NpbmcgKCkgKClcbiAgZW5kXG5cbiAgbGV0IGNsb3Nlc3Rfa2V5ID0gQ2xvc2VzdF9rZXlfaW1wbC5jbG9zZXN0X2tleVxuXG4gIGxldCByZWMgcmFuayB0IGsgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGsnLCBfKSAtPiBpZiBjb21wYXJlX2tleSBrJyBrID0gMCB0aGVuIFNvbWUgMCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGsnLCBfLCByLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBTb21lIChsZW5ndGggbClcbiAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgIHRoZW4gcmFuayBsIGsgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIE9wdGlvbi5tYXAgKHJhbmsgciBrIH5jb21wYXJlX2tleSkgfmY6KGZ1biByYW5rIC0+IHJhbmsgKyAxICsgbGVuZ3RoIGwpXG4gIDs7XG5cbiAgKCogdGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbU2VxdWVuY2VdIGludGVyZmFjZSBidXQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICBhbGxvY2F0ZXMgb25seSAyIHdvcmRzIGFuZCBkb2Vzbid0IHJlcXVpcmUgd3JpdGUtYmFycmllciAqKVxuICBsZXQgcmVjIG50aCcgbnVtX3RvX3NlYXJjaCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPlxuICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICBlbHNlIChcbiAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICBOb25lKVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIChtYXRjaCBudGgnIG51bV90b19zZWFyY2ggbCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiBzb21lXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgICAgIG50aCcgbnVtX3RvX3NlYXJjaCByKSlcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IG50aCcgKHJlZiBuKSB0XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgciB+ZlxuICA7O1xuXG4gIGxldCByZWMgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPCAwKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMClcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+IDApXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgfmtleSB+ZGF0YSA9IG5vdCAoaXNfbGVmdCB+a2V5IH5kYXRhKSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0XG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXSBmaW5kcyB0aGUga2V5IGluIFt0XSB3aGljaCBzYXRpc2ZpZXMgW21heWJlX2JvdW5kXVxuICAgICBhbmQgdGhlIHJlbGV2YW50IG9uZSBvZiBbaWZfZXhjbHVzaXZlXSBvciBbaWZfaW5jbHVzaXZlXSwgYXMganVkZ2VkIGJ5IFtjb21wYXJlXS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgfmlmX2V4Y2x1c2l2ZSB+aWZfaW5jbHVzaXZlID1cbiAgICBsZXQgZmluZF9ib3VuZCB0IGhvdyBib3VuZCB+Y29tcGFyZSA6IF8gTWF5YmVfYm91bmQudCBvcHRpb24gPVxuICAgICAgbWF0Y2ggYmluYXJ5X3NlYXJjaCB0IGhvdyBib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICB8IFNvbWUgKGJvdW5kLCBfKSAtPiBTb21lIChJbmNsIGJvdW5kKVxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICBpblxuICAgIG1hdGNoIChtYXliZV9ib3VuZCA6IF8gTWF5YmVfYm91bmQudCkgd2l0aFxuICAgIHwgRXhjbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfZXhjbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBJbmNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9pbmNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IFVuYm91bmRlZCAtPiBTb21lIFVuYm91bmRlZFxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHNdIGZpbmRzIHRoZSAobm90IG5lY2Vzc2FyaWx5IGRpc3RpbmN0KSBrZXlzIGluIFt0XVxuICAgICB3aGljaCBtb3N0IGNsb3NlbHkgYXBwcm9hY2ggKGJ1dCBkbyBub3QgY3Jvc3MpIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF0sIGFzXG4gICAgIGp1ZGdlZCBieSBbY29tcGFyZV0uIEl0IHJldHVybnMgW05vbmVdIGlmIG5vIGtleXMgaW4gW3RdIGFyZSB3aXRoaW4gdGhhdCByYW5nZS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBmaW5kX2xvd2VyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBsZXQgZmluZF91cHBlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIG1hdGNoIGZpbmRfbG93ZXJfYm91bmQgdCBsb3dlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgbG93ZXJfYm91bmQgLT5cbiAgICAgIChtYXRjaCBmaW5kX3VwcGVyX2JvdW5kIHQgdXBwZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIHVwcGVyX2JvdW5kIC0+IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkpXG4gIDs7XG5cbiAgdHlwZSAoJ2ssICd2KSBhY2MgPVxuICAgIHsgbXV0YWJsZSBiYWRfa2V5IDogJ2sgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG1hcF9sZW5ndGggOiAoJ2ssICd2KSB0ICogaW50XG4gICAgfVxuXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWNjID0geyBiYWRfa2V5ID0gTm9uZTsgbWFwX2xlbmd0aCA9IGVtcHR5LCAwIH0gaW5cbiAgICBpdGVyaSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGxldCBtYXAsIGxlbmd0aCA9IGFjYy5tYXBfbGVuZ3RoIGluXG4gICAgICBsZXQgKChfLCBsZW5ndGgnKSBhcyBwYWlyKSA9IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgbWFwIH5jb21wYXJlX2tleSBpblxuICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyAmJiBPcHRpb24uaXNfbm9uZSBhY2MuYmFkX2tleVxuICAgICAgdGhlbiBhY2MuYmFkX2tleSA8LSBTb21lIGtleVxuICAgICAgZWxzZSBhY2MubWFwX2xlbmd0aCA8LSBwYWlyKTtcbiAgICBtYXRjaCBhY2MuYmFkX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IGBPayBhY2MubWFwX2xlbmd0aFxuICAgIHwgU29tZSBrZXkgLT4gYER1cGxpY2F0ZV9rZXkga2V5XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBtYXRjaCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgdiAtPiB2XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIEVycm9yLmNyZWF0ZSBcIk1hcC5vZl9pdGVyaV9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3Qga2V5X29mX3NleHAgdmFsdWVfb2Zfc2V4cCBzZXhwIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga2V5X29mX3NleHAgdmFsdWVfb2Zfc2V4cCkgc2V4cCBpblxuICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIG1hdGNoIG9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBgT2sgdiAtPiB2XG4gICAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICAgIHRoZSB3aG9sZSBtYXAgKilcbiAgICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgICAgTGlzdC5pdGVyMl9vayBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgazIgPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiAhZm91bmRfZmlyc3Rfa1xuICAgICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIk1hcC50X29mX3NleHBfZGlyZWN0OiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICAgIGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWx1ZSB0ID1cbiAgICBsZXQgZiB+a2V5IH5kYXRhIGFjYyA9IFNleHAuTGlzdCBbIHNleHBfb2Zfa2V5IGtleTsgc2V4cF9vZl92YWx1ZSBkYXRhIF0gOjogYWNjIGluXG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IH5mIHQgfmluaXQ6W10pXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgbGV0IG9rcywgKGVycm9yX3RyZWUsIF8pID0gcGFydGl0aW9uX21hcCB0IH5jb21wYXJlX2tleSB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gICAgaWYgaXNfZW1wdHkgZXJyb3JfdHJlZVxuICAgIHRoZW4gT2sgb2tzXG4gICAgZWxzZSBPcl9lcnJvci5lcnJvcl9zIChzZXhwX29mX3Qgc2V4cF9vZl9rZXkgRXJyb3Iuc2V4cF9vZl90IGVycm9yX3RyZWUpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzXG4gICAgICAgIHQxXG4gICAgICAgIH5mXG4gICAgICAgIH5jb21wYXJhdG9yOih7IGNvbXBhcmUgPSBjb21wYXJlX2tleTsgc2V4cF9vZl90ID0gc2V4cF9vZl9rZXkgfSA6IF8gQ29tcGFyYXRvci50KVxuICAgID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGBPa1xuICAgICAgICAoZm9sZCB0MSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gfmtleSB+ZGF0YSAodDIsIGxlbmd0aCkgLT5cbiAgICAgICAgICAgbGV0IGtleSA9IGYga2V5IGluXG4gICAgICAgICAgIHRyeSBhZGRfZXhuX2ludGVybmFsIHQyIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IHdpdGhcbiAgICAgICAgICAgfCBEdXBsaWNhdGUgLT4gcmV0dXJuIChgRHVwbGljYXRlX2tleSBrZXkpKSkpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mIH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBtYXBfa2V5cyB0IH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayByZXN1bHQgLT4gcmVzdWx0XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIGxldCBzZXhwX29mX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QgaW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIk1hcC5tYXBfa2V5c19leG46IGR1cGxpY2F0ZSBrZXlcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuZW5kXG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHQgPVxuICB7ICgqIFtjb21wYXJhdG9yXSBpcyB0aGUgZmlyc3QgZmllbGQgc28gdGhhdCBwb2x5bW9ycGhpYyBlcXVhbGl0eSBmYWlscyBvbiBhIG1hcCBkdWVcbiAgICAgICB0byB0aGUgZnVuY3Rpb25hbCB2YWx1ZSBpbiB0aGUgY29tcGFyYXRvci5cbiAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgcG9seW1vcnBoaWMgW2NvbXBhcmVdOiB0aGF0IHN0aWxsIHByb2R1Y2VzXG4gICAgICAgbm9uc2Vuc2UuICopXG4gICAgY29tcGFyYXRvciA6ICgnaywgJ2NvbXBhcmF0b3IpIENvbXBhcmF0b3IudFxuICA7IHRyZWUgOiAoJ2ssICd2KSBUcmVlMC50XG4gIDsgbGVuZ3RoIDogaW50XG4gIH1cblxudHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcblxubGV0IGNvbXBhcmVfa2V5IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cblxubGV0IGxpa2UgeyB0cmVlID0gXzsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9ICh0cmVlLCBsZW5ndGgpID1cbiAgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IGxpa2UyIHggKHksIHopID0gbGlrZSB4IHksIGxpa2UgeCB6XG5cbmxldCBsaWtlX21heWJlX25vX29wICh7IHRyZWUgPSBvbGRfdHJlZTsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9IGFzIG9sZF90KSAodHJlZSwgbGVuZ3RoKVxuICA9XG4gIGlmIHBoeXNfZXF1YWwgb2xkX3RyZWUgdHJlZSB0aGVuIG9sZF90IGVsc2UgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IHdpdGhfc2FtZV9sZW5ndGggeyB0cmVlID0gXzsgY29tcGFyYXRvcjsgbGVuZ3RoIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cbmxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuKCogRXhwb3NpbmcgdGhpcyBmdW5jdGlvbiB3b3VsZCBtYWtlIGl0IHZlcnkgZWFzeSBmb3IgdGhlIGludmFyaWFudHNcbiAgIG9mIHRoaXMgbW9kdWxlIHRvIGJlIGJyb2tlbi4gKilcbmxldCBvZl90cmVlX3Vuc2FmZSB+Y29tcGFyYXRvciB+bGVuZ3RoIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5cbiAgbGV0IGludmFyaWFudHMgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSAmJiBUcmVlMC5sZW5ndGggdC50cmVlID0gdC5sZW5ndGhcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxuXG4gIGxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlIHQgKFRyZWUwLnNldCB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICAgIG1hdGNoIGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IHJlc3VsdCAtPiBgT2sgcmVzdWx0XG4gICAgfCBleGNlcHRpb24gRHVwbGljYXRlIC0+IGBEdXBsaWNhdGVcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gICAgbGlrZSB0IChUcmVlMC5yZW1vdmVfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGgga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCBrZXkgPSBUcmVlMC5maW5kX211bHRpIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgPVxuICAgIGxpa2UgdCAoVHJlZTAuY2hhbmdlIHQudHJlZSBrZXkgfmYgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgPVxuICAgIGxpa2UgdCAoVHJlZTAudXBkYXRlIHQudHJlZSBrZXkgfmYgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHQudHJlZVxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIHQga2V5ID0gVHJlZTAuZmluZCB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgcmVtb3ZlIHQga2V5ID1cbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlIHQudHJlZSBrZXkgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBtZW0gdCBrZXkgPSBUcmVlMC5tZW0gdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIGxldCBpdGVyX2tleXMgdCB+ZiA9IFRyZWUwLml0ZXJfa2V5cyB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdC50cmVlIH5mXG4gIGxldCBpdGVyaV91bnRpbCB0IH5mID0gVHJlZTAuaXRlcmlfdW50aWwgdC50cmVlIH5mXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiA9IFRyZWUwLml0ZXIyIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICBsZXQgbWFwIHQgfmYgPSB3aXRoX3NhbWVfbGVuZ3RoIHQgKFRyZWUwLm1hcCB0LnRyZWUgfmYpXG4gIGxldCBtYXBpIHQgfmYgPSB3aXRoX3NhbWVfbGVuZ3RoIHQgKFRyZWUwLm1hcGkgdC50cmVlIH5mKVxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0LnRyZWUgfmYgfmluaXRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEudHJlZSB0Mi50cmVlIH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9rZXlzIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcmkgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9tYXBpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbmlfdGYgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGxpa2UgdClcbiAgICAgIChUcmVlMC5jb21iaW5lX2Vycm9yc1xuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICA7O1xuXG4gIGxldCBlcXVhbCBjb21wYXJlX2RhdGEgdDEgdDIgPSBUcmVlMC5lcXVhbCAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdC50cmVlXG4gIGxldCBkYXRhIHQgPSBUcmVlMC5kYXRhIHQudHJlZVxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0LnRyZWVcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MS50cmVlXG4gICAgICB0Mi50cmVlXG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB0MSB0MiB+ZiA9XG4gICAgbGlrZSB0MSAoVHJlZTAubWVyZ2UgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIFRoaXMgaXMgb25seSBhIG5vLW9wIGluIHRoZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgbWFwcyBpcyBlbXB0eS4gKilcbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICAoaWYgdDIubGVuZ3RoIDw9IHQxLmxlbmd0aCB0aGVuIHQxIGVsc2UgdDIpXG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdC50cmVlIH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0LnRyZWUgfmZcblxuICBsZXQgc3BsaXQgdCBrID1cbiAgICBsZXQgbCwgbWF5YmUsIHIgPSBUcmVlMC5zcGxpdCB0LnRyZWUgayB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IGJvdGhfbGVuID0gaWYgT3B0aW9uLmlzX3NvbWUgbWF5YmUgdGhlbiB0Lmxlbmd0aCAtIDEgZWxzZSB0Lmxlbmd0aCBpblxuICAgIGlmIFRyZWUwLmhlaWdodCBsIDwgVHJlZTAuaGVpZ2h0IHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBsID0gb2ZfdHJlZSBsIH5jb21wYXJhdG9yIGluXG4gICAgICBsLCBtYXliZSwgb2ZfdHJlZV91bnNhZmUgciB+Y29tcGFyYXRvciB+bGVuZ3RoOihib3RoX2xlbiAtIGxlbmd0aCBsKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCByID0gb2ZfdHJlZSByIH5jb21wYXJhdG9yIGluXG4gICAgICBvZl90cmVlX3Vuc2FmZSBsIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIHIpLCBtYXliZSwgcilcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgbGVmdCwgbWlkLCByaWdodCA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZSB0LnRyZWUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IG91dGVyX2pvaW5lZF9oZWlnaHQgPVxuICAgICAgbGV0IGhfbCA9IFRyZWUwLmhlaWdodCBsZWZ0XG4gICAgICBhbmQgaF9yID0gVHJlZTAuaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpZiBoX2wgPSBoX3IgdGhlbiBoX2wgKyAxIGVsc2UgbWF4IGhfbCBoX3JcbiAgICBpblxuICAgIGlmIG91dGVyX2pvaW5lZF9oZWlnaHQgPCBUcmVlMC5oZWlnaHQgbWlkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbWlkX2xlbmd0aCA9IHQubGVuZ3RoIC0gKFRyZWUwLmxlbmd0aCBsZWZ0ICsgVHJlZTAubGVuZ3RoIHJpZ2h0KSBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpIH5sZW5ndGg6bWlkX2xlbmd0aClcbiAgICBlbHNlIG9mX3RyZWUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmFwcGVuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IGxvd2VyX3BhcnQpXG4gICAgICAgIH5sb3dlcl9wYXJ0Omxvd2VyX3BhcnQudHJlZVxuICAgICAgICB+dXBwZXJfcGFydDp1cHBlcl9wYXJ0LnRyZWVcbiAgICB3aXRoXG4gICAgfCBgT2sgdHJlZSAtPlxuICAgICAgYE9rXG4gICAgICAgIChvZl90cmVlX3Vuc2FmZVxuICAgICAgICAgICB0cmVlXG4gICAgICAgICAgIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIGxvd2VyX3BhcnQpXG4gICAgICAgICAgIH5sZW5ndGg6KGxvd2VyX3BhcnQubGVuZ3RoICsgdXBwZXJfcGFydC5sZW5ndGgpKVxuICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQudHJlZSB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdC50cmVlIH5taW4gfm1heCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdC50cmVlIGRpciBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQudHJlZSBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIHQga2V5ID0gVHJlZTAucmFuayB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdC50cmVlIH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBsaWtlX21heWJlX25vX29wIHQgKEVtcHR5LCAwKVxuICA7O1xuZW5kXG5cbigqIFswXSBpcyB1c2VkIGFzIHRoZSBbbGVuZ3RoXSBhcmd1bWVudCBldmVyeXdoZXJlIGluIHRoaXMgbW9kdWxlLCBzaW5jZSB0cmVlcyBkbyBub3RcbiAgIGhhdmUgdGhlaXIgbGVuZ3RocyBzdG9yZWQgYXQgdGhlIHJvb3QsIHVubGlrZSBtYXBzLiBUaGUgdmFsdWVzIGFyZSBkaXNjYXJkZWQgYWx3YXlzLiAqKVxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9ICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0cmVlID0gdHJlZVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gayB2ID0gVHJlZTAuc2luZ2xldG9uIGsgdlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBmc3QgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvciB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9IGZzdCAoVHJlZTAub2ZfYWxpc3RfZXhuIGFsaXN0IH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9yZWR1Y2UgYWxpc3QgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPSBmc3QgKFRyZWUwLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl9yZXF1aXJlZF9ieV9pbnRmIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6ZnN0XG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNlcSA9IGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHNlcSB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdG9fdHJlZSB0ID0gdFxuXG4gIGxldCBpbnZhcmlhbnRzIH5jb21wYXJhdG9yIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHRcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHRcblxuICBsZXQgc2V0IH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgZnN0IChUcmVlMC5zZXQgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBmc3RcbiAgICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgICB0XG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmxlbmd0aDowXG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgdHJ5IGBPayAoYWRkX2V4biB0IH5jb21wYXJhdG9yIH5rZXkgfmRhdGEpIHdpdGhcbiAgICB8IF8gLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBUcmVlMC5hZGRfbXVsdGkgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBmc3RcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5yZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB8PiBmc3RcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9tdWx0aSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2hhbmdlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICBmc3QgKFRyZWUwLmNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB1cGRhdGUgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfZXhuXG4gICAgICB0XG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgZmluZCB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLmZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgZnN0IChUcmVlMC5yZW1vdmUgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAubWVtIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdCB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQgfmZcblxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIFRyZWUwLml0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mXG4gIGxldCBtYXBpIHQgfmYgPSBUcmVlMC5tYXBpIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmYgfmluaXQgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIH5jb21wYXJhdG9yIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfa2V5cyB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fbWFwaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fbWFwIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbmlfdGYgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fdGYgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgfmNvbXBhcmF0b3IgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjpmc3RcbiAgICAgIChUcmVlMC5jb21iaW5lX2Vycm9yc1xuICAgICAgICAgdFxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmVxdWFsIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHRcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdFxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDFcbiAgICAgIHQyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIGZzdCAoVHJlZTAubWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgfmNvbXBhcmF0b3IgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIExlbmd0aCBjb21wdXRhdGlvbiBtYWtlcyB0aGlzIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gW21lcmdlX3NrZXdlZF0gb24gYSBtYXBcbiAgICAgICB3aXRoIGEgW2xlbmd0aF0gZmllbGQsIGJ1dCBkb2VzIHByZXNlcnZlIGFtb3VudCBvZiBhbGxvY2F0aW9uLiAqKVxuICAgIGZzdFxuICAgICAgKFRyZWUwLm1lcmdlX3NrZXdlZFxuICAgICAgICAgdDFcbiAgICAgICAgIHQyXG4gICAgICAgICB+bGVuZ3RoMToobGVuZ3RoIHQxKVxuICAgICAgICAgfmxlbmd0aDI6KGxlbmd0aCB0MilcbiAgICAgICAgIH5jb21iaW5lXG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQgfmZcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgayA9IFRyZWUwLnNwbGl0IHQgayB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgYXBwZW5kIH5jb21wYXJhdG9yIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0ID1cbiAgICBUcmVlMC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHN1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IF8sIHJldCwgXyA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZVxuICAgICAgICB0XG4gICAgICAgIH5sb3dlcl9ib3VuZFxuICAgICAgICB+dXBwZXJfYm91bmRcbiAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICByZXRcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgICB0XG4gICAgICB+bWluXG4gICAgICB+bWF4XG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB+Y29tcGFyYXRvciB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IH5jb21wYXJhdG9yIHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdCBkaXIga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQgblxuICBsZXQgbnRoX2V4biB0IG4gPSBPcHRpb24udmFsdWVfZXhuIChudGggdCBuKVxuICBsZXQgcmFuayB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLnJhbmsgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiB0XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3Iga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwID1cbiAgICBmc3QgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaCBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IEVtcHR5XG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG1hdGNoIFRyZWUwLm1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgd2l0aFxuICAgIHwgYE9rICh0LCBfKSAtPiBgT2sgdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID0gZnN0IChUcmVlMC5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZilcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ3cpIHQgPSAoJ2ssICd2KSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRcblxuICAgIGxldCBlbXB0eSA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcblxuICAgIGxldCBhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgdCB3aXRoXG4gICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICBFcnJvci5yYWlzZV9zIChTZXhwLkF0b20gXCJNYXAuQnVpbGRfaW5jcmVhc2luZy5hZGQ6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgfCBfIC0+IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCB0IH5rZXkgfmRhdGFcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWUgdCA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGsgdiA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBrIHY7IGxlbmd0aCA9IDEgfVxuICBsZXQgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKHRyZWUsIGxlbmd0aCkgPSB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSBvZl90cmVlMCB+Y29tcGFyYXRvciAodHJlZSwgVHJlZTAubGVuZ3RoIHRyZWUpXG4gIGxldCB0b190cmVlID0gdG9fdHJlZVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgfmY6KGZ1biB0cmVlIC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBsZW5ndGgpIC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2ZfYWxpc3Rfb3JfZXJyb3IgYWxpc3QgfmNvbXBhcmF0b3IpIH5mOihmdW4gdHJlZSAtPlxuICAgICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfYWxpc3RfZXhuIGFsaXN0IH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9yZWR1Y2UgYWxpc3QgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+aXRlcmkgd2l0aFxuICAgIHwgYE9rIHRyZWVfbGVuZ3RoIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZV9sZW5ndGgpXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSlcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYsIGxlbilcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KG9mX3RyZWUwIH5jb21wYXJhdG9yKVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgbGVuZ3RoKSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3IpIH5mOihmdW4gdHJlZSAtPlxuICAgICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzZXEgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHNlcSB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3Iga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG1hdGNoIFRyZWUwLm1hcF9rZXlzIHQudHJlZSB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcGFpciAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHBhaXIpXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5tYXBfa2V5c19leG4gdC50cmVlIH5mIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChLIDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvciA9IEsuY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGVuZFxuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbnR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuXG5sZXQgY29tcGFyYXRvcl9zICh0eXBlIGsgY21wKSB0IDogKGssIGNtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSB0ID0ga1xuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHQuY29tcGFyYXRvclxuICBlbmQpXG47O1xuXG5sZXQgdG9fY29tcGFyYXRvciAodHlwZSBrIGNtcCkgKChtb2R1bGUgTSkgOiAoaywgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxuXG5sZXQgb2ZfdHJlZSAodHlwZSBrIGNtcCkgKChtb2R1bGUgTSkgOiAoaywgY21wKSBjb21wYXJhdG9yKSB0cmVlID1cbiAgb2ZfdHJlZSB+Y29tcGFyYXRvcjpNLmNvbXBhcmF0b3IgdHJlZVxuOztcblxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX2FsaXN0X2V4biBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3RfbXVsdGkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9mb2xkIG0gYSB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5pbml0IH5mXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVkdWNlIG0gYSB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9pdGVyaSBtIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5cbmxldCBvZl9pdGVyaV9leG4gbSB+aXRlcmkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBtIH5sZW4gfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIG0gc2VxID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNlcVxuOztcblxubGV0IG9mX3NlcXVlbmNlIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZXhuIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX211bHRpIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2ZvbGQgbSBzIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgbSBzIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+ZlxuOztcblxubGV0IG1hcF9rZXlzIG0gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXMgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxubGV0IG1hcF9rZXlzX2V4biBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0IH5mXG5cbm1vZHVsZSBNIChLIDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gaykgc2V4cF9vZl92IHQgPVxuICBzZXhwX29mX3QgSy5zZXhwX29mX3Qgc2V4cF9vZl92IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgICAgICh0eXBlIGsgY21wKVxuICAgICAgKG1vZHVsZSBLIDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICB2X29mX3NleHBcbiAgICAgIHNleHBcbiAgPVxuICBVc2luZ19jb21wYXJhdG9yLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3I6Sy5jb21wYXJhdG9yIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICAgICh0eXBlIGspXG4gICAgICAobW9kdWxlIEsgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGspXG4gICAgICAodl9ncmFtbWFyIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIExpc3RcbiAgICAgICAgKE1hbnkgKExpc3QgKENvbnMgKEsudF9zZXhwX2dyYW1tYXIudW50eXBlZCwgQ29ucyAodl9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSkpKSlcbiAgfVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIGNvbXBhcmVfdiB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfdiB0MSB0MlxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgZXF1YWxfdiB0MSB0MiA9IGVxdWFsIGVxdWFsX3YgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gaykgaGFzaF9mb2xkX3Ygc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEsuaGFzaF9mb2xkX3QgaGFzaF9mb2xkX3Ygc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YpIHQgPSAoJ2ssICd2LCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvclxuICBsZXQgb2ZfdHJlZSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbiAgaW5jbHVkZSBVc2luZ19jb21wYXJhdG9yLkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKENvbXBhcmF0b3IuUG9seSlcblxuICBsZXQgc2luZ2xldG9uIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9leG4gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X211bHRpIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2ZvbGQgYSB+aW5pdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhIH5pbml0IH5mXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGEgfmZcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2l0ZXJpIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJhdG9yXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXFcbiAgbGV0IG9mX3NlcXVlbmNlIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX2V4biBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIHMgfmluaXQgfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzIH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBzIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3IgcyB+ZlxuICBsZXQgbWFwX2tleXMgdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZlxuICBsZXQgbWFwX2tleXNfZXhuIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mXG5lbmRcbiIsIm9wZW4hIEltcG9ydDBcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbC5RdWV1ZS50XG5cbmxldCBjcmVhdGUgPSBDYW1sLlF1ZXVlLmNyZWF0ZVxubGV0IGNsZWFyID0gQ2FtbC5RdWV1ZS5jbGVhclxubGV0IGNvcHkgPSBDYW1sLlF1ZXVlLmNvcHlcbmxldCBpc19lbXB0eSA9IENhbWwuUXVldWUuaXNfZW1wdHlcbmxldCBsZW5ndGggPSBDYW1sLlF1ZXVlLmxlbmd0aFxubGV0IHBlZWsgPSBDYW1sLlF1ZXVlLnBlZWtcbmxldCBwb3AgPSBDYW1sLlF1ZXVlLnBvcFxubGV0IHB1c2ggPSBDYW1sLlF1ZXVlLnB1c2hcbmxldCB0cmFuc2ZlciA9IENhbWwuUXVldWUudHJhbnNmZXJcbmxldCBpdGVyIHQgfmYgPSBDYW1sLlF1ZXVlLml0ZXIgZiB0XG5sZXQgZm9sZCB0IH5pbml0IH5mID0gQ2FtbC5RdWV1ZS5mb2xkIGYgaW5pdCB0XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgTGlua2VkX3F1ZXVlMFxuXG5sZXQgZW5xdWV1ZSB0IHggPSBMaW5rZWRfcXVldWUwLnB1c2ggeCB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBvcCB0KVxubGV0IGRlcXVldWVfZXhuID0gTGlua2VkX3F1ZXVlMC5wb3BcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG4gIGVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9sZGkgPSBDLmZvbGRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5sZXQgaXRlcmkgPSBDLml0ZXJpXG5sZXQgdHJhbnNmZXIgfnNyYyB+ZHN0ID0gTGlua2VkX3F1ZXVlMC50cmFuc2ZlciBzcmMgZHN0XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBlbnF1ZXVlIHJlcyAoZiBhKSk7XG4gIHJlc1xuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBlbnF1ZXVlIHJlcyAoZiBpIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlciBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXJpIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGxpc3QgPSBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBBcnJheS5pdGVyIGFycmF5IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBpbml0IGxlbiB+ZiA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgZW5xdWV1ZSB0IChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggbGVuZ3RoIHQgd2l0aFxuICB8IDAgLT4gW3x8XVxuICB8IGxlbiAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbiAocGVla19leG4gdCkgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlciB0IH5mOihmdW4gdiAtPlxuICAgICAgYXJyLighaSkgPC0gdjtcbiAgICAgIGluY3IgaSk7XG4gICAgYXJyXG47O1xuXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAobGlzdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgc2luZ2xldG9uIGEgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgYTtcbiAgdFxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5JbnQ2NFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50NjRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQ2NF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgY29tcGFyZSA9IEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDY0XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50NjRfcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gQ2FtbC5JbnQ2NC5vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBDYW1sLkludDY0Lm9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5leHRlcm5hbCBic3dhcDY0IDogdCAtPiB0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMTYgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSA0OFxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMzIgeCA9XG4gICgqIFRoaXMgaXMgc3RyaWN0bHkgYmV0dGVyIHRoYW4gY29lcmNpbmcgdG8gYW4gaW50MzIgdG8gcGVyZm9ybSBieXRlc3dhcC4gQ29lcmNpbmdcbiAgICAgZnJvbSBhbiBpbnQzMiB3aWxsIGFkZCB1bm5lY2Vzc2FyeSBzaGlmdCBvcGVyYXRpb25zIHRvIHNpZ24gZXh0ZW5kIHRoZSBudW1iZXJcbiAgICAgYXBwcm9wcmlhdGVseS5cbiAgKilcbiAgQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDMyXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwNDggeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAxNlxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgaW5jciByID0gciA6PSBhZGQgIXIgb25lXG5sZXQgZGVjciByID0gciA6PSBzdWIgIXIgb25lXG5cbmV4dGVybmFsIG9mX2ludDY0IDogdCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRcbmxldCB0b19pbnQ2NCB0ID0gdFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50NjRfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxuZXh0ZXJuYWwgdG9faW50X3RydW5jIDogdCAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbmV4dGVybmFsIHRvX25hdGl2ZWludF90cnVuYyA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcblxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252LmludDY0X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuSW50NjQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5JbnQ2NC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLkludDY0LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5JbnQ2NC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5JbnQ2NC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5JbnQ2NC5wcmVkIHggPSBDYW1sLkludDY0Lnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgaWYgQ2FtbC5JbnQ2NC5lcXVhbCBpIENhbWwuSW50NjQub25lIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLkludDY0LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQ2NCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gbmVnXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVMeFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJUx4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NFwiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9hZGRcIlxuICBleHRlcm5hbCAoIC0gKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfc3ViXCJcbiAgZXh0ZXJuYWwgKCAqICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X211bFwiXG4gIGV4dGVybmFsICggLyApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9kaXZcIlxuICBleHRlcm5hbCAoIH4tICkgOiB0IC0+IHQgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiB0IC0+IHQgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBleHRlcm5hbCAoIGxhbmQgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfYW5kXCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfb3JcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfeG9yXCJcblxuICBsZXQgbG5vdCA9IGJpdF9ub3RcblxuICBleHRlcm5hbCAoIGxzbCApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2xzbFwiXG4gIGV4dGVybmFsICggYXNyICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfYXNyXCJcbiAgZXh0ZXJuYWwgKCBsc3IgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9sc3JcIlxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50NjRdIGFuZCBbSW50NjQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIoKiBBIDYzYml0IGludGVnZXIgaXMgYSA2NGJpdCBpbnRlZ2VyIHdpdGggaXRzIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgYW5kIGl0cyBsb3dlc3QgYml0IHNldCB0byAwLlxuICAgVGhpcyBpcyB0aGUgc2FtZSBraW5kIG9mIGVuY29kaW5nIGFzIE9DYW1sIGludCBvbiA2NGJpdCBhcmNoaXRlY3R1cmUuXG4gICBUaGUgb25seSBkaWZmZXJlbmNlIGJlaW5nIHRoZSBsb3dlc3QgYml0IChpbW1lZGlhdGUgYml0KSBzZXQgdG8gMS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5cbm1vZHVsZSBUMCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDY0IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5lbmRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubW9kdWxlIFcgOiBzaWdcblxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcbiAgZW5kXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICB2YWwgd3JhcF9leG4gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgd3JhcF9tb2R1bG8gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgdW53cmFwIDogdCAtPiBDYW1sLkludDY0LnRcblxuICAoKiogUmV0dXJucyBhIG5vbi1uZWdhdGl2ZSBpbnQ2NCB0aGF0IGlzIGVxdWFsIHRvIHRoZSBpbnB1dCBpbnQ2MyBtb2R1bG8gMl42My4gKilcbiAgdmFsIHVud3JhcF91bnNpZ25lZCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG5cbiAgdmFsIGludmFyaWFudCA6IHQgLT4gdW5pdFxuICB2YWwgYWRkIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN1YiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgc3VjYyA6IHQgLT4gdFxuICB2YWwgcHJlZCA6IHQgLT4gdFxuICB2YWwgbXVsIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvdyA6IHQgLT4gdCAtPiB0XG4gIHZhbCBkaXYgOiB0IC0+IHQgLT4gdFxuICB2YWwgcmVtIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvcGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIGJpdF9ub3QgOiB0IC0+IHRcbiAgdmFsIGJpdF94b3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X29yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9hbmQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc2hpZnRfbGVmdCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIG1pbl92YWx1ZSA6IHRcbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludDY0IDogdCAtPiBDYW1sLkludDY0LnRcbiAgdmFsIG9mX2ludDY0IDogQ2FtbC5JbnQ2NC50IC0+IHQgb3B0aW9uXG4gIHZhbCBvZl9pbnQ2NF9leG4gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGNlaWxfcG93MiA6IHQgLT4gdFxuICB2YWwgZmxvb3JfcG93MiA6IHQgLT4gdFxuICB2YWwgY2VpbF9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGZsb29yX2xvZzIgOiB0IC0+IGludFxuICB2YWwgaXNfcG93MiA6IHQgLT4gYm9vbFxuICB2YWwgY2x6IDogdCAtPiBpbnRcbiAgdmFsIGN0eiA6IHQgLT4gaW50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUMFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgbGV0IHdyYXBfZXhuIHggPVxuICAgICgqIFJhaXNlcyBpZiB0aGUgaW50NjQgdmFsdWUgZG9lcyBub3QgZml0IG9uIGludDYzLiAqKVxuICAgIENvbnYuaW50NjRfZml0X29uX2ludDYzX2V4biB4O1xuICAgIENhbWwuSW50NjQubXVsIHggMkxcbiAgOztcblxuICBsZXQgd3JhcCB4ID1cbiAgICBpZiBDb252LmludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuIFNvbWUgKENhbWwuSW50NjQubXVsIHggMkwpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB3cmFwX21vZHVsbyB4ID0gQ2FtbC5JbnQ2NC5tdWwgeCAyTFxuICBsZXQgdW53cmFwIHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IHggMVxuICBsZXQgdW53cmFwX3Vuc2lnbmVkIHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCAxXG5cbiAgKCogVGhpcyBkb2VzIG5vdCB1c2Ugd3JhcCBvciB1bndyYXAgdG8gYXZvaWQgZ2VuZXJhdGluZyBleGNlcHRpb25zIGluIHRoZSBjYXNlIG9mXG4gICAgIG92ZXJmbG93cy4gVGhpcyBpcyB0byBwcmVzZXJ2ZSB0aGUgc2VtYW50aWNzIG9mIGludCB0eXBlIG9uIDY0IGJpdCBhcmNoaXRlY3R1cmUuICopXG4gIGxldCBmMiBmIGEgYiA9XG4gICAgQ2FtbC5JbnQ2NC5tdWwgKGYgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYSAxKSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpKSAyTFxuICA7O1xuXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZfZmZmZl9mZmZlTFxuICBsZXQgbSB4ID0gQ2FtbC5JbnQ2NC5sb2dhbmQgeCBtYXNrXG4gIGxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAobSB0ID0gdClcbiAgbGV0IGFkZCB4IHkgPSBDYW1sLkludDY0LmFkZCB4IHlcbiAgbGV0IHN1YiB4IHkgPSBDYW1sLkludDY0LnN1YiB4IHlcbiAgbGV0IG5lZyB4ID0gQ2FtbC5JbnQ2NC5uZWcgeFxuICBsZXQgYWJzIHggPSBDYW1sLkludDY0LmFicyB4XG4gIGxldCBvbmUgPSB3cmFwX2V4biAxTFxuICBsZXQgc3VjYyBhID0gYWRkIGEgb25lXG4gIGxldCBwcmVkIGEgPSBzdWIgYSBvbmVcbiAgbGV0IG1pbl92YWx1ZSA9IG0gQ2FtbC5JbnQ2NC5taW5faW50XG4gIGxldCBtYXhfdmFsdWUgPSBtIENhbWwuSW50NjQubWF4X2ludFxuICBsZXQgYml0X25vdCB4ID0gbSAoQ2FtbC5JbnQ2NC5sb2dub3QgeClcbiAgbGV0IGJpdF9hbmQgPSBDYW1sLkludDY0LmxvZ2FuZFxuICBsZXQgYml0X3hvciA9IENhbWwuSW50NjQubG9neG9yXG4gIGxldCBiaXRfb3IgPSBDYW1sLkludDY0LmxvZ29yXG4gIGxldCBzaGlmdF9sZWZ0IHggaSA9IENhbWwuSW50NjQuc2hpZnRfbGVmdCB4IGlcbiAgbGV0IHNoaWZ0X3JpZ2h0IHggaSA9IG0gKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgeCBpKVxuICBsZXQgc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkgPSBtIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCBpKVxuICBsZXQgcG93ID0gZjIgSW50X21hdGguUHJpdmF0ZS5pbnQ2M19wb3dfb25faW50NjRcbiAgbGV0IG11bCBhIGIgPSBDYW1sLkludDY0Lm11bCBhIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSlcbiAgbGV0IGRpdiBhIGIgPSB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5kaXYgYSBiKVxuICBsZXQgcmVtIGEgYiA9IENhbWwuSW50NjQucmVtIGEgYlxuICBsZXQgcG9wY291bnQgeCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50IHhcbiAgbGV0IHRvX2ludDY0IHQgPSB1bndyYXAgdFxuICBsZXQgb2ZfaW50NjQgdCA9IHdyYXAgdFxuICBsZXQgb2ZfaW50NjRfZXhuIHQgPSB3cmFwX2V4biB0XG4gIGxldCBvZl9pbnQ2NF90cnVuYyB0ID0gd3JhcF9tb2R1bG8gdFxuICBsZXQgdF9vZl9zZXhwIHggPSB3cmFwX2V4biAoaW50NjRfb2Zfc2V4cCB4KVxuICBsZXQgc2V4cF9vZl90IHggPSBzZXhwX29mX2ludDY0ICh1bndyYXAgeClcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGlzX3BvdzIgeCA9IEludDY0LmlzX3BvdzIgKHVud3JhcCB4KVxuXG4gIGxldCBjbHogeCA9XG4gICAgKCogV2UgcnVuIEludDY0LmNseiBkaXJlY3RseSBvbiB0aGUgd3JhcHBlZCBpbnQ2MyB2YWx1ZS4gVGhpcyBpcyBjb3JyZWN0IGJlY2F1c2UgdGhlXG4gICAgICAgYml0cyBvZiB0aGUgaW50NjNfZW11bCBhcmUgbGVmdC1hbGlnbmVkIGluIHRoZSBJbnQ2NC4gKilcbiAgICBJbnQ2NC5jbHogeFxuICA7O1xuXG4gIGxldCBjdHogeCA9IEludDY0LmN0eiAodW53cmFwIHgpXG4gIGxldCBmbG9vcl9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGNlaWxfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBmbG9vcl9sb2cyIHggPSBJbnQ2NC5mbG9vcl9sb2cyICh1bndyYXAgeClcbiAgbGV0IGNlaWxfbG9nMiB4ID0gSW50NjQuY2VpbF9sb2cyICh1bndyYXAgeClcbmVuZFxuXG5vcGVuIFdcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVy50IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIFcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBXLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKFcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoVy5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBXLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gVy5jb21wYXJhdG9yXG4gIGxldCBjb21wYXJlID0gVy5jb21wYXJlXG4gIGxldCBpbnZhcmlhbnQgPSBXLmludmFyaWFudFxuXG4gICgqIFdlIGRvbid0IGV4cGVjdCBbaGFzaF0gdG8gZm9sbG93IHRoZSBiZWhhdmlvciBvZiBpbnQgaW4gNjRiaXQgYXJjaGl0ZWN0dXJlICopXG4gIGxldCBfID0gaGFzaFxuICBsZXQgaGFzaCAoeCA6IHQpID0gQ2FtbC5IYXNodGJsLmhhc2ggeFxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBpbnZhbGlkX3N0ciB4ID0gUHJpbnRmLmZhaWx3aXRoZiBcIkludDYzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIHggKClcblxuICAoKlxuICAgICBcInNpZ25cIiByZWZlcnMgdG8gd2hldGhlciB0aGUgbnVtYmVyIHN0YXJ0cyB3aXRoIGEgJy0nXG4gICAgIFwic2lnbmVkbmVzcyA9IGZhbHNlXCIgbWVhbnMgdGhlIHJlc3Qgb2YgdGhlIG51bWJlciBpcyBwYXJzZWQgYXMgdW5zaWduZWQgYW5kIHRoZW4gY2FzdFxuICAgICB0byBzaWduZWQgd2l0aCB3cmFwLWFyb3VuZCBtb2R1bG8gMl5pXG4gICAgIFwic2lnbmVkbmVzcyA9IHRydWVcIiBtZWFucyBubyBzdWNoIGNyYXppbmVzcyBoYXBwZW5zXG5cbiAgICAgVGhlIHRlcm1pbm9sb2d5IGFuZCB0aGUgbG9naWMgaXMgZHVlIHRvIHRoZSBjb2RlIGluIGJ5dGVydW4vaW50cy5jIGluIG9jYW1sIDQuMDNcbiAgICAgKFtwYXJzZV9zaWduX2FuZF9iYXNlXSBmdW5jdGlvbikuXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgdHJ1ZSBmb3IgcGxhaW4gZGVjaW1hbCBudW1iZXIgKGUuZy4gMTIzNSwgLTY3ODkpXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgZmFsc2UgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgLSBbMHhmZmZmXSwgWy0weGZmZmZdIChoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMGIwMTAxXSwgWy0wYjAxMDFdIChiaW5hcnkgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBvMTIzN10sIFstMG8xMjM3XSAob2N0YWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzB1OTgxMl0sIFstMHU5ODEyXSAodW5zaWduZWQgZGVjaW1hbCByZXByZXNlbnRhdGlvbiAtIGF2YWlsYWJsZSBmcm9tIE9DYW1sIDQuMDMpICopXG4gIGxldCBzaWduX2FuZF9zaWduZWRuZXNzIHggPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHBvcywgc2lnbiA9XG4gICAgICBpZiAwIDwgbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggeC5bMF0gd2l0aFxuICAgICAgICB8ICctJyAtPiAxLCBgTmVnXG4gICAgICAgIHwgJysnIC0+IDEsIGBQb3NcbiAgICAgICAgfCBfIC0+IDAsIGBQb3MpXG4gICAgICBlbHNlIDAsIGBQb3NcbiAgICBpblxuICAgIGlmIHBvcyArIDIgPCBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBjMSA9IHguW3Bvc10gaW5cbiAgICAgIGxldCBjMiA9IHguW3BvcyArIDFdIGluXG4gICAgICBtYXRjaCBjMSwgYzIgd2l0aFxuICAgICAgfCAnMCcsICcwJyAuLiAnOScgLT4gc2lnbiwgdHJ1ZVxuICAgICAgfCAnMCcsIF8gLT4gc2lnbiwgZmFsc2VcbiAgICAgIHwgXyAtPiBzaWduLCB0cnVlKVxuICAgIGVsc2Ugc2lnbiwgdHJ1ZVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgeCA9IENhbWwuSW50NjQudG9fc3RyaW5nICh1bndyYXAgeClcblxuICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgdHJ5XG4gICAgICBsZXQgc2lnbiwgc2lnbmVkbmVzcyA9IHNpZ25fYW5kX3NpZ25lZG5lc3Mgc3RyIGluXG4gICAgICBpZiBzaWduZWRuZXNzXG4gICAgICB0aGVuIG9mX2ludDY0X2V4biAoQ2FtbC5JbnQ2NC5vZl9zdHJpbmcgc3RyKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwb3Nfc3RyID1cbiAgICAgICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgICAgICB8IGBOZWcgLT4gU3RyaW5nLnN1YiBzdHIgfnBvczoxIH5sZW46KFN0cmluZy5sZW5ndGggc3RyIC0gMSlcbiAgICAgICAgICB8IGBQb3MgLT4gc3RyXG4gICAgICAgIGluXG4gICAgICAgIGxldCBpbnQ2NCA9IENhbWwuSW50NjQub2Zfc3RyaW5nIHBvc19zdHIgaW5cbiAgICAgICAgKCogdW5zaWduZWQgNjMtYml0IGludCBtdXN0IHBhcnNlIGFzIGEgcG9zaXRpdmUgc2lnbmVkIDY0LWJpdCBpbnQgKilcbiAgICAgICAgaWYgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGludDY0IDBMIHRoZW4gaW52YWxpZF9zdHIgc3RyO1xuICAgICAgICBsZXQgaW50NjMgPSB3cmFwX21vZHVsbyBpbnQ2NCBpblxuICAgICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgICAgfCBgTmVnIC0+IG5lZyBpbnQ2M1xuICAgICAgICB8IGBQb3MgLT4gaW50NjMpXG4gICAgd2l0aFxuICAgIHwgXyAtPiBpbnZhbGlkX3N0ciBzdHJcbiAgOztcblxuICBsZXQgYnN3YXAxNiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMTYgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwMzIgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDMyICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDQ4IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXA0OCAodW53cmFwIHQpKVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbnVtX2JpdHMgPSA2M1xubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gYml0X25vdFxubGV0IGJpdF94b3IgPSBiaXRfeG9yXG5sZXQgYml0X29yID0gYml0X29yXG5sZXQgYml0X2FuZCA9IGJpdF9hbmRcbmxldCBwb3Bjb3VudCA9IHBvcGNvdW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IHBvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1heF92YWx1ZSA9IG1heF92YWx1ZVxubGV0IG1pbl92YWx1ZSA9IG1pbl92YWx1ZVxubGV0IG1pbnVzX29uZSA9IHdyYXBfZXhuIENhbWwuSW50NjQubWludXNfb25lXG5sZXQgb25lID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC5vbmVcbmxldCB6ZXJvID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC56ZXJvXG5sZXQgaXNfcG93MiA9IGlzX3BvdzJcbmxldCBmbG9vcl9wb3cyID0gZmxvb3JfcG93MlxubGV0IGNlaWxfcG93MiA9IGNlaWxfcG93MlxubGV0IGZsb29yX2xvZzIgPSBmbG9vcl9sb2cyXG5sZXQgY2VpbF9sb2cyID0gY2VpbF9sb2cyXG5sZXQgY2x6ID0gY2x6XG5sZXQgY3R6ID0gY3R6XG5sZXQgdG9fZmxvYXQgeCA9IENhbWwuSW50NjQudG9fZmxvYXQgKHVud3JhcCB4KVxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCB4ID0gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQub2ZfZmxvYXQgeClcblxubGV0IG9mX2Zsb2F0IHQgPVxuICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgdCA+PSBmbG9hdF9sb3dlcl9ib3VuZCAmJiB0IDw9IGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQub2ZfZmxvYXQgdClcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjMub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBvZl9pbnQ2NCA9IG9mX2ludDY0XG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBvZl9pbnQ2NF90cnVuY1xubGV0IHRvX2ludDY0ID0gdG9faW50NjRcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5cbigqIFdlIGNhbiByZXVzZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20vdG8gaW50NjQgaGVyZS4gKilcbmxldCBvZl9pbnQgeCA9IHdyYXBfZXhuIChDb252LmludF90b19pbnQ2NCB4KVxubGV0IG9mX2ludF9leG4geCA9IG9mX2ludCB4XG5sZXQgdG9faW50IHggPSBDb252LmludDY0X3RvX2ludCAodW53cmFwIHgpXG5sZXQgdG9faW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50X3RydW5jICh1bndyYXAgeClcbmxldCBvZl9pbnQzMiB4ID0gd3JhcF9leG4gKENvbnYuaW50MzJfdG9faW50NjQgeClcbmxldCBvZl9pbnQzMl9leG4geCA9IG9mX2ludDMyIHhcbmxldCB0b19pbnQzMiB4ID0gQ29udi5pbnQ2NF90b19pbnQzMiAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfZXhuIHggPSBDb252LmludDY0X3RvX2ludDMyX2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX25hdGl2ZWludCB4ID0gb2ZfaW50NjQgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X2V4biB4ID0gd3JhcF9leG4gKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jIHggPSBvZl9pbnQ2NF90cnVuYyAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCB0b19uYXRpdmVpbnQgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50ICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfZXhuIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgKHVud3JhcCB4KVxuXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChULmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgVC5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBULmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG5cbiAgICBsZXQgdG9fc3RyaW5nIGkgPVxuICAgICAgKCogdGhlIHVzZSBvZiBbdW53cmFwX3Vuc2lnbmVkXSBoZXJlIGlzIGltcG9ydGFudCBmb3IgdGhlIGNhc2Ugb2YgW21pbl92YWx1ZV0gKilcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiJUx4XCIgKHVud3JhcF91bnNpZ25lZCBpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmcgKFwiMHhcIiBeIHMpXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzLkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgeCA9IHRvX3N0cmluZyB4XG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzXCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2M10gYW5kIFtJbnQ2My5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgZW11bGF0ZWQgPSB0XG5cbiAgdHlwZSAoJ3VuZGVybHlpbmdfdHlwZSwgJ2ludGVybWVkaWF0ZV90eXBlKSB0ID1cbiAgICB8IEludCA6IChpbnQsIGludCkgdFxuICAgIHwgSW50NjQgOiAoaW50NjQsIGVtdWxhdGVkKSB0XG5lbmRcblxubGV0IHJlcHIgPSBSZXByLkludDY0XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBib29sIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2Jvb2wgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgZmFsc2U7IHRydWUgXSA6IHQgbGlzdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Jvb2xcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Jvb2wgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGJvb2xfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYm9vbCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBib29sX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICAgIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gICAgfCBzIC0+IGludmFsaWRfYXJnZiBcIkJvb2wub2Zfc3RyaW5nOiBleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGJ1dCBnb3QgJXNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IENhbWwuc3RyaW5nX29mX2Jvb2xcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Cb29sXCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IHRvX2ludCB4ID0gYm9vbF90b19pbnQgeFxuXG5tb2R1bGUgTm9uX3Nob3J0X2NpcmN1aXRpbmcgPSBzdHJ1Y3RcbiAgKCogV2UgZG9uJ3QgZXhwb3NlIHRoaXMsIHNpbmNlIHdlIGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIGludmFyaWFudCBtZW50aW9uZWQgYmVsb3cgb2ZcbiAgICAgKHRvX2ludCB0cnVlID0gMSkgYW5kICh0b19pbnQgZmFsc2UgPSAwKS4gKilcbiAgbGV0IHVuc2FmZV9vZl9pbnQgKHggOiBpbnQpIDogYm9vbCA9IENhbWwuT2JqLm1hZ2ljIHhcbiAgbGV0ICggfHwgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsb3IgdG9faW50IGIpXG4gIGxldCAoICYmICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbGFuZCB0b19pbnQgYilcbmVuZFxuXG4oKiBXZSBkbyB0aGlzIGFzIGEgZGlyZWN0IGFzc2VydCBvbiB0aGUgdGhlb3J5IHRoYXQgaXQncyBhIGNoZWFwIHRoaW5nIHRvIHRlc3QgYW5kIGFcbiAgIHJlYWxseSBjb3JlIGludmFyaWFudCB0aGF0IHdlIG5ldmVyIGV4cGVjdCB0byBicmVhaywgYW5kIHdlIHNob3VsZCBiZSBoYXBweSBmb3IgYVxuICAgcHJvZ3JhbSB0byBmYWlsIGltbWVkaWF0ZWx5IGlmIHRoaXMgaXMgdmlvbGF0ZWQuICopXG5sZXQgKCkgPSBhc3NlcnQgKFBvbHkuKCA9ICkgKHRvX2ludCB0cnVlKSAxICYmIFBvbHkuKCA9ICkgKHRvX2ludCBmYWxzZSkgMClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuSW50MzJcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50MzJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50MzIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50MzJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDMyXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgY29tcGFyZSA9IGNvbXBhcmVcbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQzMi5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgSW5maXhfY29tcGFyZSA9IHN0cnVjdFxuICBvcGVuIFBvbHlcblxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IHggPj0geVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IHggPD0geVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IHggPiB5XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSB4IDwgeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IHggPD4geVxuZW5kXG5cbm1vZHVsZSBDb21wYXJlID0gc3RydWN0XG4gIGluY2x1ZGUgSW5maXhfY29tcGFyZVxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfaW50MzIgdCA9IHRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyIHQgPSB0XG5sZXQgdG9faW50MzJfZXhuID0gdG9faW50MzJcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDMyX3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmxldCBvZl9pbnQgPSBDb252LmludF90b19pbnQzMlxubGV0IG9mX2ludF9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnRfdHJ1bmMgPSBDb252LmludF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludCA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYuaW50MzJfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYuaW50MzJfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXAzMiA6IHQgLT4gdCA9IFwiJWJzd2FwX2ludDMyXCJcblxubGV0IGJzd2FwMTYgeCA9IENhbWwuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXAzMiB4KSAxNlxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLkludDMyLmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuSW50MzIubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5JbnQzMi5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIENhbWwuSW50MzIuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIENhbWwuSW50MzIuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuSW50MzIucHJlZCB4ID0gQ2FtbC5JbnQzMi56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50MzIgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQzMi5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgKCogVGhlIFtpID0gMV0gY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgY2x6KDApIGlzIHVuZGVmaW5lZCAqKVxuICAgIGlmIENhbWwuSW50MzIuZXF1YWwgaSBDYW1sLkludDMyLm9uZSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5JbnQzMi5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50MzIgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbHhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVseFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyLkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzJcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChDb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQzMl0gYW5kIFtJbnQzMi5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBSZXByID0gSW50NjNfZW11bC5SZXByXG5cbigqIEluIGEgd29ybGQgd2hlcmUgdGhlIGNvbXBpbGVyIHdvdWxkIHVuZGVyc3RhbmQgW0BAaW1tZWRpYXRlNjRdIGF0dHJpYnV0ZXMgb24gdHlwZVxuICAgZGVjbGFyYXRpb25zLCB0aGlzIG1vZHVsZSBpcyBob3cgb25lIHdvdWxkIHByb2R1Y2UgYSBbdHlwZSB0XSB3aXRoIHRoaXMgYXR0cmlidXRlLiAqKVxubW9kdWxlIEltbWVkaWF0ZTY0IDogc2lnXG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UgKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkgKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cblxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG5cbiAgICB2YWwgcmVwciA6IHQgcmVwclxuICBlbmRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbW1lZGlhdGUgOiBJbW1lZGlhdGUpIChOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuXG4gICAgbGV0IHJlcHIgPVxuICAgICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgICB8IFc2NCAtPiAoQ2FtbC5PYmoubWFnaWMgSW1tZWRpYXRlIDogdCByZXByKVxuICAgICAgfCBXMzIgLT4gKENhbWwuT2JqLm1hZ2ljIE5vbl9pbW1lZGlhdGUgOiB0IHJlcHIpXG4gICAgOztcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBJbW1lZGlhdGU2NC5NYWtlIChJbnQpIChJbnQ2M19lbXVsKVxuXG5tb2R1bGUgQmFja2VuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIEludF9pbnRmLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIHRvX2ludCA6IHQgLT4gaW50IG9wdGlvblxuICAgIHZhbCB0b19pbnRfdHJ1bmMgOiB0IC0+IGludFxuICAgIHZhbCBvZl9pbnQzMiA6IGludDMyIC0+IHRcbiAgICB2YWwgdG9faW50MzIgOiB0IC0+IEludDMyLnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludDMyX3RydW5jIDogdCAtPiBJbnQzMi50XG4gICAgdmFsIG9mX2ludDY0IDogSW50NjQudCAtPiB0IG9wdGlvblxuICAgIHZhbCBvZl9pbnQ2NF90cnVuYyA6IEludDY0LnQgLT4gdFxuICAgIHZhbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gdCBvcHRpb25cbiAgICB2YWwgdG9fbmF0aXZlaW50IDogdCAtPiBuYXRpdmVpbnQgb3B0aW9uXG4gICAgdmFsIG9mX25hdGl2ZWludF90cnVuYyA6IG5hdGl2ZWludCAtPiB0XG4gICAgdmFsIHRvX25hdGl2ZWludF90cnVuYyA6IHQgLT4gbmF0aXZlaW50XG4gICAgdmFsIG9mX2Zsb2F0X3VuY2hlY2tlZCA6IGZsb2F0IC0+IHRcbiAgICB2YWwgcmVwciA6ICh0LCB0KSBJbnQ2M19lbXVsLlJlcHIudFxuICAgIHZhbCBic3dhcDE2IDogdCAtPiB0XG4gICAgdmFsIGJzd2FwMzIgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXA0OCA6IHQgLT4gdFxuICBlbmRcbiAgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIG1vZHVsZSBOYXRpdmUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHRvX2ludCB4ID0gU29tZSB4XG4gICAgbGV0IHRvX2ludF90cnVuYyB4ID0geFxuXG4gICAgKCogW29mX2ludDMyX2V4bl0gaXMgYSBzYWZlIG9wZXJhdGlvbiBvbiBwbGF0Zm9ybXMgd2l0aCA2NC1iaXQgd29yZCBzaXplcy4gKilcbiAgICBsZXQgb2ZfaW50MzIgPSBvZl9pbnQzMl9leG5cbiAgICBsZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSB0b19uYXRpdmVpbnQgeFxuICAgIGxldCB0b19uYXRpdmVpbnQgeCA9IFNvbWUgKHRvX25hdGl2ZWludCB4KVxuICAgIGxldCByZXByID0gSW50NjNfZW11bC5SZXByLkludFxuICAgIGxldCBic3dhcDMyIHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwMzIgKEludDY0Lm9mX2ludCB0KSlcbiAgICBsZXQgYnN3YXA0OCB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDQ4IChJbnQ2NC5vZl9pbnQgdCkpXG4gIGVuZFxuXG4gIGxldCBpbXBsIDogKG1vZHVsZSBTKSA9XG4gICAgbWF0Y2ggcmVwciB3aXRoXG4gICAgfCBJbW1lZGlhdGUgLT4gKG1vZHVsZSBOYXRpdmUgOiBTKVxuICAgIHwgTm9uX2ltbWVkaWF0ZSAtPiAobW9kdWxlIEludDYzX2VtdWwgOiBTKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgKHZhbCBCYWNrZW5kLmltcGwgOiBCYWNrZW5kLlMpXG5cbm1vZHVsZSBPdmVyZmxvd19leG4gPSBzdHJ1Y3RcbiAgbGV0ICggKyApIHQgdSA9XG4gICAgbGV0IHN1bSA9IHQgKyB1IGluXG4gICAgaWYgYml0X29yIChiaXRfeG9yIHQgdSkgKGJpdF94b3IgdCAoYml0X25vdCBzdW0pKSA8IHplcm9cbiAgICB0aGVuIHN1bVxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJzdW1cIiwgc2V4cF9vZl90IHN1bSBdKVxuICA7O1xuXG4gIGxldCAoIC0gKSB0IHUgPVxuICAgIGxldCBkaWZmID0gdCAtIHUgaW5cbiAgICBsZXQgcG9zX2RpZmYgPSB0ID4gdSBpblxuICAgIGlmIHQgPD4gdSAmJiBCb29sLiggPD4gKSBwb3NfZGlmZiAoaXNfcG9zaXRpdmUgZGlmZilcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC0gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwiZGlmZlwiLCBzZXhwX29mX3QgZGlmZiBdKVxuICAgIGVsc2UgZGlmZlxuICA7O1xuXG4gIGxldCBuZWdhdGl2ZV9vbmUgPSBvZl9pbnQgKC0xKVxuICBsZXQgZGl2X3dvdWxkX292ZXJmbG93IHQgdSA9IHQgPSBtaW5fdmFsdWUgJiYgdSA9IG5lZ2F0aXZlX29uZVxuXG4gIGxldCAoICogKSB0IHUgPVxuICAgIGxldCBwcm9kdWN0ID0gdCAqIHUgaW5cbiAgICBpZiB1IDw+IHplcm8gJiYgKGRpdl93b3VsZF9vdmVyZmxvdyBwcm9kdWN0IHUgfHwgcHJvZHVjdCAvIHUgPD4gdClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICogKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgcHJvZHVjdCBdKVxuICAgIGVsc2UgcHJvZHVjdFxuICA7O1xuXG4gIGxldCAoIC8gKSB0IHUgPVxuICAgIGlmIGRpdl93b3VsZF9vdmVyZmxvdyB0IHVcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC8gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgKHQgLyB1KSBdKVxuICAgIGVsc2UgdCAvIHVcbiAgOztcblxuICBsZXQgYWJzIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJhYnMgb3ZlcmZsb3dcIiBlbHNlIGFicyB0XG4gIGxldCBuZWcgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcIm5lZyBvdmVyZmxvd1wiIGVsc2UgbmVnIHRcbmVuZFxuXG5sZXQgKCkgPSBhc3NlcnQgKEludC4oID0gKSBudW1fYml0cyA2MylcblxubGV0IHJhbmRvbV9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludCBzdGF0ZSAodG9faW50X2V4biBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NCBzdGF0ZSAodG9faW50NjQgYm91bmQpKVxuOztcblxubGV0IHJhbmRvbSA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21fb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9vZl9pbnQ2NFxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50X2luY2wgc3RhdGUgKHRvX2ludF9leG4gbG8pICh0b19pbnRfZXhuIGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjRfaW5jbCBzdGF0ZSAodG9faW50NjQgbG8pICh0b19pbnQ2NCBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2wgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX2luY2xfb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9pbmNsX29mX2ludDY0XG47O1xuXG5sZXQgZmxvb3JfbG9nMiB0ID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHQgfD4gdG9faW50X2V4biB8PiBJbnQuZmxvb3JfbG9nMlxuICB8IFczMiAtPlxuICAgIGlmIHQgPD0gemVyb1xuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSk7XG4gICAgbGV0IGZsb29yX2xvZzIgPSByZWYgKEludC4oIC0gKSBudW1fYml0cyAyKSBpblxuICAgIHdoaWxlIGVxdWFsIHplcm8gKGJpdF9hbmQgdCAoc2hpZnRfbGVmdCBvbmUgIWZsb29yX2xvZzIpKSBkb1xuICAgICAgZmxvb3JfbG9nMiA6PSBJbnQuKCAtICkgIWZsb29yX2xvZzIgMVxuICAgIGRvbmU7XG4gICAgIWZsb29yX2xvZzJcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBSZXByID0gUmVwclxuXG4gIGxldCByZXByID0gcmVwclxuXG4gIG1vZHVsZSBFbXVsID0gSW50NjNfZW11bFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsLktleSAqKVxubW9kdWxlIEtleSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBUd28gW3RdcyB0aGF0IFtjb21wYXJlXSBlcXVhbCBtdXN0IGhhdmUgZXF1YWwgaGFzaGVzIGZvciB0aGUgaGFzaHRhYmxlXG4gICAgICAgIHRvIGJlaGF2ZSBwcm9wZXJseS4gKilcbiAgICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuSGFzaHRibC5NZXJnZV9pbnRvX2FjdGlvbiAqKVxubW9kdWxlIE1lcmdlX2ludG9fYWN0aW9uID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBSZW1vdmVcbiAgICB8IFNldF90byBvZiAnYVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IHNpZ1xuICAoKiogezIgQWNjZXNzb3JzfSAqKVxuXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuXG4gIHZhbCBzZXhwX29mX2tleSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gU2V4cC50XG4gIHZhbCBjbGVhciA6IChfLCBfKSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcblxuICAoKiogQXR0ZW1wdGluZyB0byBtb2RpZnkgKFtzZXRdLCBbcmVtb3ZlXSwgZXRjLikgdGhlIGhhc2h0YWJsZSBkdXJpbmcgaXRlcmF0aW9uIChbZm9sZF0sXG4gICAgICBbaXRlcl0sIFtpdGVyX2tleXNdLCBbaXRlcmldKSB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8pIHQgLT4gZjooJ2Ega2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlcyBvdmVyIGJvdGgga2V5cyBhbmQgdmFsdWVzLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgSGFzaHRibC5pdGVyaSBoIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBwcmludF9lbmRsaW5lIChQcmludGYuc3ByaW50ZiBcIiVkLSVkXCIga2V5IGRhdGEpKTs7XG4gICAgICAxLTRcbiAgICAgIDUtNlxuICAgICAgLSA6IHVuaXQgPSAoKVxuICAgICAgdn0gKilcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50IDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gYm9vbFxuICB2YWwgcmVtb3ZlIDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiB1bml0XG4gIHZhbCBjaG9vc2UgOiAoJ2EsICdiKSB0IC0+ICgnYSBrZXkgKiAnYikgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgKiAnYlxuXG4gICgqKiBTZXRzIHRoZSBnaXZlbiBba2V5XSB0byBbZGF0YV0uICopXG4gIHZhbCBzZXQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFthZGRdIGFuZCBbYWRkX2V4bl0gbGVhdmUgdGhlIHRhYmxlIHVuY2hhbmdlZCBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IHByZXNlbnQuICopXG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBbIGBPayB8IGBEdXBsaWNhdGUgXVxuXG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYikgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbY2hhbmdlIHQga2V5IH5mXSBjaGFuZ2VzIFt0XSdzIHZhbHVlIGZvciBba2V5XSB0byBiZSBbZiAoZmluZCB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW3VwZGF0ZV9hbmRfcmV0dXJuIHQga2V5IH5mXSBpcyBbdXBkYXRlXSwgYnV0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBbZiBvXS4gKilcbiAgdmFsIHVwZGF0ZV9hbmRfcmV0dXJuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAnYlxuXG4gICgqKiBbbWFwIHQgZl0gcmV0dXJucyBhIG5ldyB0YWJsZSB3aXRoIHZhbHVlcyByZXBsYWNlZCBieSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFtmXVxuICAgICAgdG8gdGhlIGN1cnJlbnQgdmFsdWVzLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgbGV0IGgnID0gSGFzaHRibC5tYXAgaCB+ZjooZnVuIHggLT4geCAqIDIpIGluXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGgnOztcbiAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWyg1LCAxMik7ICgxLCA4KV1cbiAgICAgIHZ9ICopXG4gIHZhbCBtYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIG1hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IHRhYmxlIGJ5IGZpbHRlcmluZyB0aGUgZ2l2ZW4gdGFibGUncyB2YWx1ZXMgYnkgW2ZdOiB0aGUga2V5cyBmb3Igd2hpY2hcbiAgICAgIFtmXSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHZhbHVlIHJldHVybnMgW1NvbWVdIGFyZSBrZXB0LCBhbmQgdGhvc2UgZm9yIHdoaWNoIGl0XG4gICAgICByZXR1cm5zIFtOb25lXSBhcmUgZGlzY2FyZGVkLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgSGFzaHRibC5maWx0ZXJfbWFwIGggfmY6KGZ1biB4IC0+IGlmIHggPiA1IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbiAgICAgIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDUsIDYpXVxuICAgICAgdn0gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgZmlsdGVyX21hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIGtleSAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIFJldHVybnMgbmV3IHRhYmxlcyB3aXRoIGJvdW5kIHZhbHVlcyBwYXJ0aXRpb25lZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmRcbiAgICAgIHZhbHVlcy4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KSAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgKCoqIFJldHVybnMgYSBwYWlyIG9mIHRhYmxlcyBbKHQxLCB0MildLCB3aGVyZSBbdDFdIGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMgb2YgdGhlXG4gICAgICBpbml0aWFsIHRhYmxlIHdoaWNoIHNhdGlzZnkgdGhlIHByZWRpY2F0ZSBbZl0sIGFuZCBbdDJdIGNvbnRhaW5zIHRoZSByZXN0LiAqKVxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fdGZdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgKCoqIFtmaW5kX29yX2FkZCB0IGsgfmRlZmF1bHRdIHJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGtleSBba10gaWYgaXQgaXMgaW4gdGhlXG4gICAgICB0YWJsZSBbdF0sIGFuZCBvdGhlcndpc2UgYXNzaWducyBba10gdGhlIHZhbHVlIHJldHVybmVkIGJ5IFtkZWZhdWx0ICgpXS4gKilcbiAgdmFsIGZpbmRfb3JfYWRkIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZGVmYXVsdDoodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiogTGlrZSBbZmluZF9vcl9hZGRdIGJ1dCBbZGVmYXVsdF0gdGFrZXMgdGhlIGtleSBhcyBhbiBhcmd1bWVudC4gKilcbiAgdmFsIGZpbmRpX29yX2FkZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGRlZmF1bHQ6KCdhIGtleSAtPiAnYikgLT4gJ2JcblxuICAoKiogW2ZpbmQgdCBrXSByZXR1cm5zIFtTb21lXSAodGhlIGN1cnJlbnQgYmluZGluZykgb2YgW2tdIGluIFt0XSwgb3IgW05vbmVdIGlmIG5vIHN1Y2hcbiAgICAgIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiIG9wdGlvblxuXG4gICgqKiBbZmluZF9leG4gdCBrXSByZXR1cm5zIHRoZSBjdXJyZW50IGJpbmRpbmcgb2YgW2tdIGluIFt0XSwgb3IgcmFpc2VzIFtDYW1sLk5vdF9mb3VuZF1cbiAgICAgIG9yIFtOb3RfZm91bmRfc10gaWYgbm8gc3VjaCBiaW5kaW5nIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2JcblxuICAoKiogW2ZpbmRfYW5kX2NhbGwgdCBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXVxuXG4gICAgICBpcyBlcXVpdmFsZW50IHRvOlxuXG4gICAgICBbbWF0Y2ggZmluZCB0IGsgd2l0aCBTb21lIHYgLT4gaWZfZm91bmQgdiB8IE5vbmUgLT4gaWZfbm90X2ZvdW5kIGtdXG5cbiAgICAgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgdGhlIG9wdGlvbi4gKilcbiAgdmFsIGZpbmRfYW5kX2NhbGxcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgKCoqIEp1c3QgbGlrZSBbZmluZF9hbmRfY2FsbF0sIGJ1dCB0YWtlcyBhbiBleHRyYSBhcmd1bWVudCB3aGljaCBpcyBwYXNzZWQgdG8gW2lmX2ZvdW5kXVxuICAgICAgYW5kIFtpZl9ub3RfZm91bmRdLCBzbyB0aGF0IHRoZSBjbGllbnQgY29kZSBjYW4gYXZvaWQgYWxsb2NhdGluZyBjbG9zdXJlcyBvciB1c2luZ1xuICAgICAgcmVmcyB0byBwYXNzIHRoaXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi4gIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VmdWwgaW4gY29kZVxuICAgICAgd2hpY2ggdHJpZXMgdG8gbWluaW1pemUgaGVhcCBhbGxvY2F0aW9uLiAqKVxuICB2YWwgZmluZF9hbmRfY2FsbDFcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnZCAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kX2FuZF9jYWxsMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gYjonZVxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsMVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnZCAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGI6J2VcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgKCoqIFtmaW5kX2FuZF9yZW1vdmUgdCBrXSByZXR1cm5zIFNvbWUgKHRoZSBjdXJyZW50IGJpbmRpbmcpIG9mIGsgaW4gdCBhbmQgcmVtb3ZlcyBpdCxcbiAgICAgIG9yIE5vbmUgaXMgbm8gc3VjaCBiaW5kaW5nIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfYW5kX3JlbW92ZSA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiIG9wdGlvblxuXG4gICgqKiBNZXJnZXMgdHdvIGhhc2h0YWJsZXMuXG5cbiAgICAgIFRoZSByZXN1bHQgb2YgW21lcmdlIGYgaDEgaDJdIGhhcyBhcyBrZXlzIHRoZSBzZXQgb2YgYWxsIFtrXSBpbiB0aGUgdW5pb24gb2YgdGhlXG4gICAgICBzZXRzIG9mIGtleXMgb2YgW2gxXSBhbmQgW2gyXSBmb3Igd2hpY2ggW2QoayldIGlzIG5vdCBOb25lLCB3aGVyZTpcblxuICAgICAgZChrKSA9XG4gICAgICAtIFtmIH5rZXk6ayAoYExlZnQgZDEpXVxuICAgICAgICBpZiBba10gaW4gW2gxXSBtYXBzIHRvIGQxLCBhbmQgW2gyXSBkb2VzIG5vdCBoYXZlIGRhdGEgZm9yIFtrXTtcblxuICAgICAgLSBbZiB+a2V5OmsgKGBSaWdodCBkMildXG4gICAgICAgIGlmIFtrXSBpbiBbaDJdIG1hcHMgdG8gZDIsIGFuZCBbaDFdIGRvZXMgbm90IGhhdmUgZGF0YSBmb3IgW2tdO1xuXG4gICAgICAtIFtmIH5rZXk6ayAoYEJvdGggKGQxLCBkMikpXVxuICAgICAgICBvdGhlcndpc2UsIHdoZXJlIFtrXSBpbiBbaDFdIG1hcHMgdG8gW2QxXSBhbmQgW2tdIGluIFtoMl0gbWFwcyB0byBbZDJdLlxuXG4gICAgICBFYWNoIGtleSBba10gaXMgbWFwcGVkIHRvIGEgc2luZ2xlIHBpZWNlIG9mIGRhdGEgW3hdLCB3aGVyZSBbZChrKSA9IFNvbWUgeF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaDEgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA1KTsgKDIsIDMyMzIpXSBpblxuICAgICAgbGV0IGgyID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgMyldIGluXG4gICAgICBIYXNodGJsLm1lcmdlIGgxIGgyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgYExlZnQgeCAtPiBTb21lIChgTGVmdCB4KVxuICAgICAgICB8IGBSaWdodCB4IC0+IFNvbWUgKGBSaWdodCB4KVxuICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBpZiB4PXkgdGhlbiBOb25lIGVsc2UgU29tZSAoYEJvdGggKHgseSkpXG4gICAgICApIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBbPiBgQm90aCBvZiBpbnQgKiBpbnQgfCBgTGVmdCBvZiBpbnQgfCBgUmlnaHQgb2YgaW50IF0pIGxpc3QgPVxuICAgICAgWygyLCBgTGVmdCAzMjMyKTsgKDEsIGBCb3RoICg1LCAzKSldXG4gICAgICB2fSAqKVxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2ssICdhKSB0XG4gICAgLT4gKCdrLCAnYikgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYiB8IGBCb3RoIG9mICdhICogJ2IgXSAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdrLCAnYykgdFxuXG5cbiAgKCoqIEV2ZXJ5IFtrZXldIGluIFtzcmNdIHdpbGwgYmUgcmVtb3ZlZCBvciBzZXQgaW4gW2RzdF0gYWNjb3JkaW5nIHRvIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIG9mIFtmXS4gKilcbiAgdmFsIG1lcmdlX2ludG9cbiAgICA6ICBzcmM6KCdrLCAnYSkgdFxuICAgIC0+IGRzdDooJ2ssICdiKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiAnYSAtPiAnYiBvcHRpb24gLT4gJ2IgTWVyZ2VfaW50b19hY3Rpb24udClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGtleXMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgZGF0YSBmb3IgZ2l2ZW4gaGFzaHRhYmxlLiAqKVxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG5cbiAgKCoqIFtmaWx0ZXJfaW5wbGFjZSB0IH5mXSByZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSBbdF0gdGhhdCBkb24ndCBzYXRpc2Z5IFtmXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzX2lucGxhY2UgOiAoJ2EsIF8pIHQgLT4gZjooJ2Ega2V5IC0+IGJvb2wpIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gdW5pdFxuICB2YWwgZmlsdGVyaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gdW5pdFxuXG4gICgqKiBbbWFwX2lucGxhY2UgdCB+Zl0gYXBwbGllcyBbZl0gdG8gYWxsIGVsZW1lbnRzIGluIFt0XSwgdHJhbnNmb3JtaW5nIHRoZW0gaW5cbiAgICAgIHBsYWNlLiAqKVxuICB2YWwgbWFwX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gJ2IpIC0+IHVuaXRcblxuICB2YWwgbWFwaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW2ZpbHRlcl9tYXBfaW5wbGFjZV0gY29tYmluZXMgdGhlIGVmZmVjdHMgb2YgW21hcF9pbnBsYWNlXSBhbmQgW2ZpbHRlcl9pbnBsYWNlXS4gKilcbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChfLCAnYikgdCAtPiBmOignYiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX21hcGlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbZXF1YWwgZiB0MSB0Ml0gYW5kIFtzaW1pbGFyIGYgdDEgdDJdIGJvdGggcmV0dXJuIHRydWUgaWZmIFt0MV0gYW5kIFt0Ml0gaGF2ZSB0aGVcbiAgICAgIHNhbWUga2V5cyBhbmQgZm9yIGFsbCBrZXlzIFtrXSwgW2YgKGZpbmRfZXhuIHQxIGspIChmaW5kX2V4biB0MiBrKV0uICBbZXF1YWxdIGFuZFxuICAgICAgW3NpbWlsYXJdIG9ubHkgZGlmZmVyIGluIHRoZWlyIHR5cGVzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcblxuICB2YWwgc2ltaWxhciA6ICgnYjEgLT4gJ2IyIC0+IGJvb2wpIC0+ICgnYSwgJ2IxKSB0IC0+ICgnYSwgJ2IyKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgKGtleSwgZGF0YSkgcGFpcnMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIHRvX2FsaXN0IDogKCdhLCAnYikgdCAtPiAoJ2Ega2V5ICogJ2IpIGxpc3RcblxuXG4gICgqKiBbcmVtb3ZlX2lmX3plcm9dJ3MgZGVmYXVsdCBpcyBbZmFsc2VdLiAqKVxuICB2YWwgaW5jciA6ID9ieTppbnQgLT4gP3JlbW92ZV9pZl96ZXJvOmJvb2wgLT4gKCdhLCBpbnQpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcblxuICB2YWwgZGVjciA6ID9ieTppbnQgLT4gP3JlbW92ZV9pZl96ZXJvOmJvb2wgLT4gKCdhLCBpbnQpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNdWx0aSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcblxuICAoKiogW2FkZF9tdWx0aSB0IH5rZXkgfmRhdGFdIGlmIFtrZXldIGlzIHByZXNlbnQgaW4gdGhlIHRhYmxlIHRoZW4gY29uc1xuICAgICAgW2RhdGFdIG9uIHRoZSBsaXN0LCBvdGhlcndpc2UgYWRkIFtrZXldIHdpdGggYSBzaW5nbGUgZWxlbWVudCBsaXN0LiAqKVxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFtyZW1vdmVfbXVsdGkgdCBrZXldIHVwZGF0ZXMgdGhlIHRhYmxlLCByZW1vdmluZyB0aGUgaGVhZCBvZiB0aGUgbGlzdCBib3VuZCB0b1xuICAgICAgW2tleV0uIElmIHRoZSBsaXN0IGhhcyBvbmx5IG9uZSBlbGVtZW50IChvciBpcyBlbXB0eSkgdGhlbiB0aGUgYmluZGluZyBpc1xuICAgICAgcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgXyBsaXN0KSB0IC0+ICdhIGtleSAtPiB1bml0XG5cbiAgKCoqIFtmaW5kX211bHRpIHQga2V5XSByZXR1cm5zIHRoZSBlbXB0eSBsaXN0IGlmIFtrZXldIGlzIG5vdCBwcmVzZW50IGluIHRoZSB0YWJsZSxcbiAgICAgIHJldHVybnMgW3RdJ3MgdmFsdWVzIGZvciBba2V5XSBvdGhlcndpc2UuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIGtleSAtPiAnYiBsaXN0XG5lbmRcblxudHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA9XG4gID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gIC0+ICdrZXkgS2V5LnRcbiAgLT4gJ3pcblxudHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gIC0+ICd6XG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlIDogKCdhIGtleSwgJ2IsIHVuaXQgLT4gKCdhLCAnYikgdCkgY3JlYXRlX29wdGlvbnNcblxuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgKCdhIGtleSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBrZXkgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgKCdhIGtleSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2Ega2V5LCAnYiwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhIGtleSwgJ2IsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogKCdhIGtleSwgJ2IgbGlzdCwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IgbGlzdCkgdCkgY3JlYXRlX29wdGlvbnNcblxuXG4gICgqKiB7WyBjcmVhdGVfbWFwcGVkIGdldF9rZXkgZ2V0X2RhdGEgW3gxLC4uLix4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIGdldF9kYXRhIHgxOyAuLi47IGdldF9rZXkgeG4sIGdldF9kYXRhIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX21hcHBlZFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuXG4gICgqKiB7WyBjcmVhdGVfd2l0aF9rZXkgfmdldF9rZXkgW3gxLC4uLix4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIHgxOyAuLi47IGdldF9rZXkgeG4sIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnclxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdhLCAncikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnclxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpIC0+ICdyIGxpc3QgLT4gKCdhLCAncikgdCBPcl9lcnJvci50IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgIDogKCdhIGtleSwgJ3IsIGdldF9rZXk6KCdyIC0+ICdhIGtleSkgLT4gJ3IgbGlzdCAtPiAoJ2EsICdyKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG5cbiAgdmFsIGdyb3VwXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAgICAgLT4gY29tYmluZTooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gKCdhLCAnYikgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgKCoqIHsyIENyZWF0b3JzfSAqKVxuXG4gICgqKiBUaGUgbW9kdWxlIHlvdSBwYXNzIHRvIFtjcmVhdGVdIG11c3QgaGF2ZSBhIHR5cGUgdGhhdCBpcyBoYXNoYWJsZSwgc2V4cGFibGUsIGFuZFxuICAgICAgY29tcGFyYWJsZS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBJbnQpOztcbiAgICAgICAgLSA6IChpbnQsICdfYSkgSGFzaHRibC50ID0gPGFic3RyPjs7XG4gICAgICB2fSAqKVxuICB2YWwgY3JlYXRlXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICAgSGFzaHRibC5vZl9hbGlzdCAobW9kdWxlIEludCkgWygzLCBcInNvbWV0aGluZ1wiKTsgKDIsIFwid2hhdGV2ZXJcIildXG4gICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleSBvZiBpbnQgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBPayA8YWJzdHI+XG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIFdoZXJlYXMgW29mX2FsaXN0XSB3aWxsIHJlcG9ydCBbRHVwbGljYXRlX2tleV0gbm8gbWF0dGVyIGhvdyBtYW55IGR1cHMgdGhlcmUgYXJlIGluXG4gICAgICB5b3VyIGxpc3QsIFtvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNdIHdpbGwgcmVwb3J0IGVhY2ggYW5kIGV2ZXJ5IGR1cGxpY2F0ZSBlbnRyeS5cblxuICAgICAgRm9yIGV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIEhhc2h0Ymwub2ZfYWxpc3QgKG1vZHVsZSBJbnQpIFsoMSwgXCJmb29cIik7ICgxLCBcImJhclwiKTsgKDIsIFwiZm9vXCIpOyAoMiwgXCJiYXJcIildOztcbiAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXkgb2YgaW50IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgRHVwbGljYXRlX2tleSAxXG5cbiAgICAgICAgSGFzaHRibC5vZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgKG1vZHVsZSBJbnQpIFsoMSwgXCJmb29cIik7ICgxLCBcImJhclwiKTsgKDIsIFwiZm9vXCIpOyAoMiwgXCJiYXJcIildOztcbiAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXlzIG9mIGludCBsaXN0IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgRHVwbGljYXRlX2tleXMgWzE7IDJdXG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX2FsaXN0X2V4blxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBDcmVhdGVzIGEge3shTXVsdGl9IFwibXVsdGlcIn0gaGFzaHRhYmxlLCBpLmUuLCBhIGhhc2h0YWJsZSB3aGVyZSBlYWNoIGtleSBwb2ludHMgdG8gYVxuICAgICAgbGlzdCBwb3RlbnRpYWxseSBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy4gU28gaW5zdGVhZCBvZiBzaG9ydC1jaXJjdWl0aW5nIHdpdGggYVxuICAgICAgW2BEdXBsaWNhdGVfa2V5XSB2YXJpYW50IG9uIGR1cGxpY2F0ZXMsIGFzIGluIFtvZl9hbGlzdF0sIFtvZl9hbGlzdF9tdWx0aV0gZm9sZHNcbiAgICAgIHRob3NlIHZhbHVlcyBpbnRvIGEgbGlzdCBmb3IgdGhlIGdpdmVuIGtleTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9tdWx0aSAobW9kdWxlIEludCkgWygxLCBcImFcIik7ICgxLCBcImJcIik7ICgyLCBcImNcIik7ICgyLCBcImRcIildOztcbiAgICAgIHZhbCBoIDogKGludCwgc3RyaW5nIGxpc3QpIEhhc2h0YmwudCA9IDxhYnN0cj5cblxuICAgICAgSGFzaHRibC5maW5kX2V4biBoIDE7O1xuICAgICAgLSA6IHN0cmluZyBsaXN0ID0gW1wiYlwiOyBcImFcIl1cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0KSB0XG5cbiAgKCoqIEFwcGxpZXMgdGhlIFtnZXRfa2V5XSBhbmQgW2dldF9kYXRhXSBmdW5jdGlvbnMgdG8gdGhlIFsnciBsaXN0XSB0byBjcmVhdGUgdGhlXG4gICAgICBpbml0aWFsIGtleXMgYW5kIHZhbHVlcywgcmVzcGVjdGl2ZWx5LCBmb3IgdGhlIG5ldyBoYXNodGFibGUuXG5cbiAgICAgIHtbIGNyZWF0ZV9tYXBwZWQgZ2V0X2tleSBnZXRfZGF0YSBbeDE7Li4uO3huXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgZ2V0X2RhdGEgeDE7IC4uLjsgZ2V0X2tleSB4biwgZ2V0X2RhdGEgeG5dXG4gICAgICBdfVxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBsZXQgaCA9XG4gICAgICAgICAgSGFzaHRibC5jcmVhdGVfbWFwcGVkIChtb2R1bGUgSW50KVxuICAgICAgICAgICAgfmdldF9rZXk6KGZ1biB4IC0+IHgpXG4gICAgICAgICAgICB+Z2V0X2RhdGE6KGZ1biB4IC0+IHggKyAxKVxuICAgICAgICAgICBbMTsgMjsgM107O1xuICAgICAgICB2YWwgaCA6IFsgYER1cGxpY2F0ZV9rZXlzIG9mIGludCBsaXN0IHwgYE9rIG9mIChpbnQsIGludCkgSGFzaHRibC50IF0gPSBgT2sgPGFic3RyPlxuXG4gICAgICAgIGxldCBoID1cbiAgICAgICAgICBtYXRjaCBoIHdpdGhcbiAgICAgICAgICB8IGBPayB4IC0+IHhcbiAgICAgICAgICB8IGBEdXBsaWNhdGVfa2V5cyBfIC0+IGZhaWx3aXRoIFwiXCJcbiAgICAgICAgaW5cbiAgICAgICAgSGFzaHRibC5maW5kX2V4biBoIDE7O1xuICAgICAgICAtIDogaW50ID0gMlxuICAgICAgdn0gKilcbiAgdmFsIGNyZWF0ZV9tYXBwZWRcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgKCoqIHtbIGNyZWF0ZV93aXRoX2tleSB+Z2V0X2tleSBbeDE7Li4uO3huXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgeDE7IC4uLjsgZ2V0X2tleSB4biwgeG5dIF19ICopXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAncikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ3IpIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfZXhuXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ3IpIHRcblxuICAoKiogTGlrZSBbY3JlYXRlX21hcHBlZF0sIGFwcGxpZXMgdGhlIFtnZXRfa2V5XSBhbmQgW2dldF9kYXRhXSBmdW5jdGlvbnMgdG8gdGhlIFsnclxuICAgICAgbGlzdF0gdG8gY3JlYXRlIHRoZSBpbml0aWFsIGtleXMgYW5kIHZhbHVlcywgcmVzcGVjdGl2ZWx5LCBmb3IgdGhlIG5ldyBoYXNodGFibGUgLS1cbiAgICAgIGFuZCB0aGVuLCBsaWtlIFthZGRfbXVsdGldLCBmb2xkcyB0b2dldGhlciB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGtleXMuIEhlcmUsXG4gICAgICB0aG91Z2gsIHRoZSBmdW5jdGlvbiB1c2VkIGZvciB0aGUgZm9sZGluZyBpcyBnaXZlbiBieSBbY29tYmluZV0gKGluc3RlYWQgb2YganVzdFxuICAgICAgYmVpbmcgYSBbY29uc10pLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICAgSGFzaHRibC5ncm91cCAobW9kdWxlIEludClcbiAgICAgICAgICAgfmdldF9rZXk6KGZ1biB4IC0+IHggLyAyKVxuICAgICAgICAgICB+Z2V0X2RhdGE6KGZ1biB4IC0+IHgpXG4gICAgICAgICAgIH5jb21iaW5lOihmdW4geCB5IC0+IHggKiB5KVxuICAgICAgICAgICAgWyAxOyAyOyAzOyA0XVxuICAgICAgICAgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAgICAtIDogKGludCAqIGludCkgbGlzdCA9IFsoMiwgNCk7ICgxLCA2KTsgKDAsIDEpXVxuICAgICAgIHZ9ICopXG4gIHZhbCBncm91cFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAtPiBjb21iaW5lOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfd2l0aG91dF9zdWJtb2R1bGVzID0gc2lnXG4gIHZhbCBoYXNoIDogJ2EgLT4gaW50XG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcblxuICB0eXBlICgnYSwgJ2IpIHRcblxuICAoKiogV2UgcHJvdmlkZSBhIFtzZXhwX29mX3RdIGJ1dCBub3QgYSBbdF9vZl9zZXhwXSBmb3IgdGhpcyB0eXBlIGJlY2F1c2Ugb25lIG5lZWRzIHRvIGJlXG4gICAgICBleHBsaWNpdCBhYm91dCB0aGUgaGFzaCBhbmQgY29tcGFyaXNvbiBmdW5jdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgaGFzaHRhYmxlLlxuICAgICAgTm90ZSB0aGF0IFtIYXNodGJsLlBvbHkudF0gZG9lcyBoYXZlIFtbQEBkZXJpdmluZyBzZXhwXV0sIGFuZCB1c2VzIE9DYW1sJ3MgYnVpbHQtaW5cbiAgICAgIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYW5kIGFuZCBwb2x5bW9ycGhpYyBoYXNoaW5nLiAqKVxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdiIC0+IFNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwLnRcblxuICBpbmNsdWRlIENyZWF0b3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgKCoqIEBpbmxpbmUgKilcblxuICBpbmNsdWRlIEFjY2Vzc29ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgPSAnYVxuICAoKiogQGlubGluZSAqKVxuXG5cbiAgaW5jbHVkZSBNdWx0aSB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gICgqKiBAaW5saW5lICopXG5cbiAgdmFsIGhhc2hhYmxlX3MgOiAoJ2tleSwgXykgdCAtPiAna2V5IEtleS50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5cbiAgdmFsIGhhc2hhYmxlIDogJ2EgSGFzaGFibGUudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgJ2Ega2V5ID0gJ2FcbiAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICBpbmNsdWRlIE11bHRpIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbmVuZFxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2ssICd2KSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIEhhc2h0YmwgPSBzaWdcbiAgKCoqIEEgaGFzaCB0YWJsZSBpcyBhIG11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgaW1wbGVtZW50aW5nIGEgbWFwIGJldHdlZW4ga2V5cyBhbmQgdmFsdWVzLlxuICAgICAgSXQgc3VwcG9ydHMgY29uc3RhbnQtdGltZSBsb29rdXAgYW5kIGluLXBsYWNlIG1vZGlmaWNhdGlvbi5cblxuICAgICAgezEgVXNhZ2V9XG5cbiAgICAgIEFzIGEgc2ltcGxlIGV4YW1wbGUsIHdlJ2xsIGNyZWF0ZSBhIGhhc2ggdGFibGUgd2l0aCBzdHJpbmcga2V5cyB1c2luZyB0aGVcbiAgICAgIHt7IWNyZWF0ZX1bY3JlYXRlXX0gY29uc3RydWN0b3IsIHdoaWNoIGV4cGVjdHMgYSBtb2R1bGUgZGVmaW5pbmcgdGhlIGtleSdzIHR5cGU6XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBoID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBTdHJpbmcpOztcbiAgICAgICAgdmFsIGggOiAoc3RyaW5nLCAnX2EpIEhhc2h0YmwudCA9IDxhYnN0cj5cbiAgICAgIF19XG5cbiAgICAgIFdlIGNhbiBzZXQgdGhlIHZhbHVlcyBvZiBpbmRpdmlkdWFsIGtleXMgd2l0aCB7eyFzZXR9W3NldF19LiBJZiB0aGUga2V5IGFscmVhZHkgaGFzXG4gICAgICBhIHZhbHVlLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiZm9vXCIgfmRhdGE6NTs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImZvb1wiIH5kYXRhOjY7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJiYXJcIiB+ZGF0YTo2OztcbiAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIHZ9XG5cbiAgICAgIFdlIGNhbiBhY2Nlc3MgdmFsdWVzIGJ5IGtleSwgb3IgZHVtcCBhbGwgb2YgdGhlIGhhc2ggdGFibGUncyBkYXRhOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5maW5kIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50IG9wdGlvbiA9IFNvbWUgNlxuXG4gICAgICBIYXNodGJsLmZpbmRfZXhuIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50ID0gNlxuXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGg7O1xuICAgICAgLSA6IChzdHJpbmcgKiBpbnQpIGxpc3QgPSBbKFwiZm9vXCIsIDYpOyAoXCJiYXJcIiwgNildXG4gICAgICB2fVxuXG4gICAgICB7eyFjaGFuZ2V9W2NoYW5nZV19IGxldHMgdXMgY2hhbmdlIGEga2V5J3MgdmFsdWUgYnkgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5jaGFuZ2UgaCBcImZvb1wiIChmdW4geCAtPlxuICAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IFNvbWUgKHggKiAyKVxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICApOztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoOztcbiAgICAgIC0gOiAoc3RyaW5nICogaW50KSBsaXN0ID0gWyhcImZvb1wiLCAxMik7IChcImJhclwiLCA2KV1cbiAgICAgIHZ9XG5cblxuICAgICAgV2UgY2FuIHVzZSB7eyFtZXJnZX1bbWVyZ2VdfSB0byBtZXJnZSB0d28gaGFzaHRhYmxlcyB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICAgIGhvdyB3ZSBjaG9vc2UgdmFsdWVzIHdoZW4gYSBrZXkgaXMgcHJlc2VudCBpbiB0aGUgZmlyc3QgKFwibGVmdFwiKSBoYXNodGFibGUsIHRoZVxuICAgICAgc2Vjb25kIChcInJpZ2h0XCIpLCBvciBib3RoLiBIZXJlLCB3ZSdsbCBjb25zIHRoZSB2YWx1ZXMgd2hlbiBib3RoIGhhc2h0YWJsZXMgaGF2ZSBhXG4gICAgICBrZXk6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaDEgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA1KTsgKDIsIDMyMzIpXSBpblxuICAgICAgbGV0IGgyID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgMyldIGluXG4gICAgICBIYXNodGJsLm1lcmdlIGgxIGgyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgYExlZnQgeCAtPiBTb21lIChgTGVmdCB4KVxuICAgICAgICB8IGBSaWdodCB4IC0+IFNvbWUgKGBSaWdodCB4KVxuICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBpZiB4PXkgdGhlbiBOb25lIGVsc2UgU29tZSAoYEJvdGggKHgseSkpXG4gICAgICApIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBbPiBgQm90aCBvZiBpbnQgKiBpbnQgfCBgTGVmdCBvZiBpbnQgfCBgUmlnaHQgb2YgaW50IF0pIGxpc3QgPVxuICAgICAgWygyLCBgTGVmdCAzMjMyKTsgKDEsIGBCb3RoICg1LCAzKSldXG4gICAgICB2fVxuXG4gICAgICB7MSBJbnRlcmZhY2V9ICopXG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3VibW9kdWxlcyAoKiogQGlubGluZSAqKVxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IEFjY2Vzc29yc1xuICBtb2R1bGUgdHlwZSBDcmVhdG9ycyA9IENyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIE11bHRpID0gTXVsdGlcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zdWJtb2R1bGVzID0gU193aXRob3V0X3N1Ym1vZHVsZXNcbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG5cbiAgbW9kdWxlIEtleSA9IEtleVxuICBtb2R1bGUgTWVyZ2VfaW50b19hY3Rpb24gPSBNZXJnZV9pbnRvX2FjdGlvblxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zID0gKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNcblxuICBtb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG5cbiAgICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuICBlbmRcblxuICBtb2R1bGUgUG9seSA6IFNfcG9seSB3aXRoIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfdGFibGUgPSBpbnQgSGFzaHRibC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X3RhYmxlID0gKFN0cmluZy50LCBpbnQpIEhhc2h0YmwudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBIYXNodGJsLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kXG4gICAgICBzeW50YXggZG9lc24ndCAoYmVjYXVzZSBbdF9vZl9zZXhwXSBkb2Vzbid0IGtub3cgd2hhdCBjb21wYXJpc29uL2hhc2ggZnVuY3Rpb24gdG9cbiAgICAgIHVzZSkuICopXG4gIG1vZHVsZSBNIChLIDogVC5UKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgKCoqLyoqKVxuXG4gICgqXyBTZWUgdGhlIEphbmUgU3RyZWV0IFN0eWxlIEd1aWRlIGZvciBhbiBleHBsYW5hdGlvbiBvZiBbUHJpdmF0ZV0gc3VibW9kdWxlczpcblxuICAgIGh0dHBzOi8vb3BlbnNvdXJjZS5qYW5lc3RyZWV0LmNvbS9zdGFuZGFyZHMvI3ByaXZhdGUtc3VibW9kdWxlcyAqKVxuICBtb2R1bGUgUHJpdmF0ZSA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5cbiAgICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gICAgdmFsIGhhc2hhYmxlIDogKCdrZXksIF8pIHQgLT4gJ2tleSBIYXNoYWJsZS50XG4gIGVuZFxuZW5kXG4iLCIoKiBBIGZldyBzbWFsbCB0aGluZ3MgY29waWVkIGZyb20gb3RoZXIgcGFydHMgb2YgQmFzZSBiZWNhdXNlIHRoZXkgZGVwZW5kIG9uIHVzLCBzbyB3ZVxuICAgY2FuJ3QgdXNlIHRoZW0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBJdHMgaW1wb3J0YW50IHRoYXQgRW1wdHkgaGF2ZSBubyBhcmdzLiBJdCdzIHRlbXB0aW5nIHRvIG1ha2UgdGhpcyB0eXBlIGEgcmVjb3JkXG4gICAoZS5nLiB0byBob2xkIHRoZSBjb21wYXJlIGZ1bmN0aW9uKSwgYnV0IGEgbG90IG9mIG1lbW9yeSBpcyBzYXZlZCBieSBFbXB0eSBiZWluZyBhblxuICAgaW1tZWRpYXRlLCBzaW5jZSBhbGwgdW51c2VkIGJ1Y2tldHMgaW4gdGhlIGhhc2h0YmwgZG9uJ3QgdXNlIGFueSBtZW1vcnkgKGJlc2lkZXMgdGhlXG4gICBhcnJheSBjZWxsKSAqKVxudHlwZSAoJ2ssICd2KSB0ID1cbiAgfCBFbXB0eVxuICB8IE5vZGUgb2ZcbiAgICAgIHsgbXV0YWJsZSBsZWZ0IDogKCdrLCAndikgdFxuICAgICAgOyBrZXkgOiAna1xuICAgICAgOyBtdXRhYmxlIHZhbHVlIDogJ3ZcbiAgICAgIDsgbXV0YWJsZSBoZWlnaHQgOiBpbnRcbiAgICAgIDsgbXV0YWJsZSByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgIH1cbiAgfCBMZWFmIG9mXG4gICAgICB7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgfVxuXG5sZXQgZW1wdHkgPSBFbXB0eVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHRydWVcbiAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBoZWlnaHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IDBcbiAgfCBMZWFmIF8gLT4gMVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQ7IHJpZ2h0ID0gXyB9IC0+IGhlaWdodFxuOztcblxubGV0IGludmFyaWFudCBjb21wYXJlID1cbiAgbGV0IGxlZ2FsX2xlZnRfa2V5IGtleSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBsZWZ0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIGxlZnRfa2V5IGtleSA8IDApXG4gIGluXG4gIGxldCBsZWdhbF9yaWdodF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gcmlnaHRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT5cbiAgICAgIGFzc2VydCAoY29tcGFyZSByaWdodF9rZXkga2V5ID4gMClcbiAgaW5cbiAgbGV0IHJlYyBpbnYgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gKClcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrOyB2YWx1ZSA9IF87IGhlaWdodCA9IGg7IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBobCwgaHIgPSBoZWlnaHQgbGVmdCwgaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpbnYgbGVmdDtcbiAgICAgIGludiByaWdodDtcbiAgICAgIGxlZ2FsX2xlZnRfa2V5IGsgbGVmdDtcbiAgICAgIGxlZ2FsX3JpZ2h0X2tleSBrIHJpZ2h0O1xuICAgICAgYXNzZXJ0IChoID0gSW50Lm1heCBobCBociArIDEpO1xuICAgICAgYXNzZXJ0IChhYnMgKGhsIC0gaHIpIDw9IDIpXG4gIGluXG4gIGludlxuOztcblxubGV0IGludmFyaWFudCB0IH5jb21wYXJlID0gaW52YXJpYW50IGNvbXBhcmUgdFxuXG4oKiBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLFxuICAgJ3QgaXMgYmFsYW5jZWQnIG1lYW5zIHRoYXQgJ2ludmFyaWFudCB0JyBkb2VzIG5vdFxuICAgcmFpc2UgYW4gZXhjZXB0aW9uLiAgVGhpcyBpbXBsaWVzIG9mIGNvdXJzZSB0aGF0IGVhY2ggbm9kZSdzIGhlaWdodCBmaWVsZCBpc1xuICAgY29ycmVjdC5cbiAgICd0IGlzIGJhbGFuY2VhYmxlJyBtZWFucyB0aGF0IGhlaWdodCBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgb2YgdFxuICAgZGlmZmVyIGJ5IGF0IG1vc3QgMy4gKilcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgaGF2ZSBjb3JyZWN0IGhlaWdodHNcbiAgIEBwb3N0OiBvdXRwdXQgaGFzIHRoZSBjb3JyZWN0IGhlaWdodCAqKVxubGV0IHVwZGF0ZV9oZWlnaHQgPSBmdW5jdGlvblxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBvbGRfaGVpZ2h0OyByaWdodCB9IGFzIHgpIC0+XG4gICAgbGV0IG5ld19oZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgbGVmdCkgKGhlaWdodCByaWdodCkgKyAxIGluXG4gICAgaWYgbmV3X2hlaWdodCA8PiBvbGRfaGVpZ2h0IHRoZW4geC5oZWlnaHQgPC0gbmV3X2hlaWdodFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgYXJlIGJhbGFuY2VkXG4gICBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcG9zdDogb3V0cHV0IGlzIGJhbGFuY2VkIChpbiBwYXJ0aWN1bGFyLCBoZWlnaHQgaXMgY29ycmVjdCkgKilcbmxldCBiYWxhbmNlIHRyZWUgPVxuICBtYXRjaCB0cmVlIHdpdGhcbiAgfCBFbXB0eSB8IExlYWYgXyAtPiB0cmVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcm9vdF9ub2RlKSAtPlxuICAgIGxldCBobCA9IGhlaWdodCBsZWZ0XG4gICAgYW5kIGhyID0gaGVpZ2h0IHJpZ2h0IGluXG4gICAgKCogKyAyIGlzIGNyaXRpY2FsbHkgaW1wb3J0YW50LCBsb3dlcmluZyBpdCB0byAxIHdpbGwgYnJlYWsgdGhlIExlYWZcbiAgICAgICBhc3N1bXB0aW9ucyBpbiB0aGUgY29kZSBiZWxvdywgYW5kIHdpbGwgZm9yY2UgdXMgdG8gcHJvbW90ZSBsZWFmIG5vZGVzIGluXG4gICAgICAgdGhlIGJhbGFuY2Ugcm91dGluZS4gSXQncyBhbHNvIGZhc3Rlciwgc2luY2UgaXQgd2lsbCBiYWxhbmNlIGxlc3Mgb2Z0ZW4uXG4gICAgICAgTm90ZSB0aGF0IHRoZSBmb2xsb3dpbmcgY29kZSBpcyBkZWxpY2F0ZS4gIFRoZSB1cGRhdGVfaGVpZ2h0IGNhbGxzIG11c3RcbiAgICAgICBvY2N1ciBpbiB0aGUgY29ycmVjdCBvcmRlciwgc2luY2UgdXBkYXRlX2hlaWdodCBhc3N1bWVzIGl0cyBjaGlsZHJlbiBoYXZlXG4gICAgICAgdGhlIGNvcnJlY3QgaGVpZ2h0cy4gICopXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGxlZnQgd2l0aFxuICAgICAgKCogSXQgY2Fubm90IGJlIGEgbGVhZiwgYmVjYXVzZSBldmVuIGlmIHJpZ2h0IGlzIGVtcHR5LCBhIGxlYWZcbiAgICAgICAgIGlzIG9ubHkgaGVpZ2h0IDEgKilcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gbGVmdF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgbGVmdF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGVmdF9ub2RlX2xlZnQgPj0gaGVpZ2h0IGxlZnRfbm9kZV9yaWdodFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUubGVmdCA8LSBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICBsZWZ0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBpZiByaWdodCBpcyBhIGxlYWYsIHRoZW4gbGVmdCBtdXN0IGJlIGVtcHR5LiBUaGF0IG1lYW5zXG4gICAgICAgICAgICAgaGVpZ2h0IGlzIDIuIEV2ZW4gaWYgaHIgaXMgZW1wdHkgd2Ugc3RpbGwgY2FuJ3QgZ2V0IGhlcmUuICopXG4gICAgICAgICAgbWF0Y2ggbGVmdF9ub2RlX3JpZ2h0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gbHJfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IGxyX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIGxyX25vZGUpIC0+XG4gICAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gbHJfbGVmdDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxyX3JpZ2h0O1xuICAgICAgICAgICAgbHJfbm9kZS5yaWdodCA8LSB0cmVlO1xuICAgICAgICAgICAgbHJfbm9kZS5sZWZ0IDwtIGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICAgIGxlZnRfbm9kZV9yaWdodCkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgcmlnaHQgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgbWF0Y2ggcmlnaHQgd2l0aFxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gcmlnaHRfbm9kZV9yaWdodFxuICAgICAgICAgICB9IGFzIHJpZ2h0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCByaWdodF9ub2RlX3JpZ2h0ID49IGhlaWdodCByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcm9vdF9ub2RlLnJpZ2h0IDwtIHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICByaWdodClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICAgICAgbWF0Y2ggcmlnaHRfbm9kZV9sZWZ0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gcmxfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IHJsX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIHJsX25vZGUpIC0+XG4gICAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gcmxfcmlnaHQ7XG4gICAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmxfbGVmdDtcbiAgICAgICAgICAgIHJsX25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgICAgcmxfbm9kZS5yaWdodCA8LSByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0X25vZGVfbGVmdCkpXG4gICAgZWxzZSAoXG4gICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICB0cmVlKVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5cbigqIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwcmU6IGFicyAoaGVpZ2h0IChyaWdodCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9sZWZ0IG5vZGUgdHJlZSA9XG4gIGxldCB0cmVlID0gYmFsYW5jZSB0cmVlIGluXG4gIG1hdGNoIG5vZGUgd2l0aFxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyByKSAtPlxuICAgIGlmIHBoeXNfZXF1YWwgbGVmdCB0cmVlIHRoZW4gKCkgZWxzZSByLmxlZnQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKGxlZnQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcbmxldCBzZXRfcmlnaHQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCByaWdodCB0cmVlIHRoZW4gKCkgZWxzZSByLnJpZ2h0IDwtIHRyZWU7XG4gICAgdXBkYXRlX2hlaWdodCBub2RlXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbigqIEBwcmU6IHQgaXMgYmFsYW5jZWQuXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VkLCB3aXRoIG5ldyBub2RlIGluc2VydGVkXG4gICBAcG9zdDogIWFkZGVkID0gdHJ1ZSBpZmYgdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0cmVlIGNoYW5nZWQuICAqKVxubGV0IGFkZCA9XG4gIGxldCByZWMgYWRkIHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTGVhZiAoeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gYXMgcikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrJyBrIGluXG4gICAgICAoKiBUaGlzIGNvbXBhcmUgaXMgcmV2ZXJzZWQgb24gcHVycG9zZSwgd2UgYXJlIHByZXRlbmRpbmdcbiAgICAgICAgIHRoYXQgdGhlIGxlYWYgd2FzIGp1c3QgaW5zZXJ0ZWQgaW5zdGVhZCBvZiB0aGUgb3RoZXIgd2F5XG4gICAgICAgICByb3VuZCwgdGhhdCB3YXkgd2Ugb25seSBhbGxvY2F0ZSBvbmUgbm9kZS4gKilcbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHY7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBOb2RlIHsgbGVmdCA9IHQ7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSBFbXB0eSB9XG4gICAgICAgIGVsc2UgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IHQgfSlcbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHYpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIHNldF9sZWZ0IHQgKGFkZCBsZWZ0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrIHYpXG4gICAgICBlbHNlIHNldF9yaWdodCB0IChhZGQgcmlnaHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdik7XG4gICAgICB0XG4gIGluXG4gIGZ1biB0IH5yZXBsYWNlIH5jb21wYXJlIH5hZGRlZCB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IHQgPSBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUga2V5IGRhdGEgaW5cbiAgICBpZiAhYWRkZWQgdGhlbiBiYWxhbmNlIHQgZWxzZSB0XG47O1xuXG5sZXQgcmVjIGZpcnN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBmaXJzdCBsXG47O1xuXG5sZXQgcmVjIGxhc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gciB9IC0+IGxhc3QgclxuOztcblxuXG5sZXRbQGlubGluZSBhbHdheXNdIHJlYyBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAga1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcxXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+aWZfbm90X2ZvdW5kXG4gID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZSBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgIGlmIGMgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZVxuICAgICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgICAoaWYgYyA8IDAgdGhlbiBsZWZ0IGVsc2UgcmlnaHQpXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIGtcbiAgICAgICAgYXJnMVxuICAgICAgICBhcmcyXG4gICAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgICB+aWZfZm91bmRcbiAgICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhICgpICgpID0gaWZfZm91bmQgZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhICgpICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnICgpID0gaWZfZm91bmQgZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSA9XG4gIGxldCBpZl9mb3VuZCBfID0gdHJ1ZSBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBmYWxzZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgcmVtb3ZlID1cbiAgbGV0IHJlYyBtaW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgXyAtPiB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IG1pbl9lbHQgbGVmdFxuICBpblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBMZWFmIF8gLT4gRW1wdHkgKCogVGhpcyBtdXN0IGJlIHRoZSByb290ICopXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT4gcmlnaHRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gRW1wdHkgfSAtPlxuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIEVtcHR5O1xuICAgICAgdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gYXMgbm9kZSAtPlxuICAgICAgc2V0X2xlZnQgbm9kZSAocmVtb3ZlX21pbl9lbHQgbGVmdCk7XG4gICAgICB0cmVlXG4gIGluXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB0cmVlID0gbWluX2VsdCB0MiBpblxuICAgICAgKG1hdGNoIHRyZWUgd2l0aFxuICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICAgICAgIGxldCB0MiA9IGJhbGFuY2UgKHJlbW92ZV9taW5fZWx0IHQyKSBpblxuICAgICAgICAgTm9kZVxuICAgICAgICAgICB7IGxlZnQgPSB0MVxuICAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICAgOyB2YWx1ZSA9IHZcbiAgICAgICAgICAgOyBoZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgdDEpIChoZWlnaHQgdDIpICsgMVxuICAgICAgICAgICA7IHJpZ2h0ID0gdDJcbiAgICAgICAgICAgfVxuICAgICAgIHwgTm9kZSBfIGFzIG5vZGUgLT5cbiAgICAgICAgIHNldF9yaWdodCBub2RlIChyZW1vdmVfbWluX2VsdCB0Mik7XG4gICAgICAgICBzZXRfbGVmdCBub2RlIHQxO1xuICAgICAgICAgbm9kZSlcbiAgaW5cbiAgbGV0IHJlYyByZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgayA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgIEVtcHR5XG4gICAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gXyB9IC0+XG4gICAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBFbXB0eSlcbiAgICAgIGVsc2UgKFxuICAgICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgICB0KVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgbWVyZ2UgbGVmdCByaWdodClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBzZXRfbGVmdCB0IChyZW1vdmUgbGVmdCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgc2V0X3JpZ2h0IHQgKHJlbW92ZSByaWdodCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gIGluXG4gIGZ1biB0IH5yZW1vdmVkIH5jb21wYXJlIGsgLT4gYmFsYW5jZSAocmVtb3ZlIHQgcmVtb3ZlZCBjb21wYXJlIGspXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGluaXRcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGEgaW5pdFxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IEVtcHR5XG4gICAgICB9IC0+IGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH0gfVxuICAgIC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfTsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH1cbiAgICAtPiBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKSB+ZlxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSkgfmZcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBpdGVyIGxlZnQgfmY7XG4gICAgZiB+a2V5IH5kYXRhO1xuICAgIGl0ZXIgcmlnaHQgfmZcbjs7XG5cbmxldCByZWMgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgKHsga2V5OyB2YWx1ZSB9IGFzIHQpIC0+IHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXk7IHZhbHVlOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHQpIC0+XG4gICAgbWFwaV9pbnBsYWNlIH5mIGxlZnQ7XG4gICAgdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWU7XG4gICAgbWFwaV9pbnBsYWNlIH5mIHJpZ2h0XG47O1xuXG5sZXQgY2hvb3NlX2V4biA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0F2bHRyZWUuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlOyBfIH0gfCBOb2RlIHsga2V5OyB2YWx1ZTsgXyB9IC0+IGtleSwgdmFsdWVcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICgqIFtyZWNlbnRseV9hZGRlZF0gaXMgdGhlIHJlZmVyZW5jZSBwYXNzZWQgdG8gW0F2bHRyZWUuYWRkXS4gV2UgcHV0IGl0IGluIHRoZSBoYXNoXG4gICAgIHRhYmxlIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgYXQgZXZlcnkgW3NldF0uICopXG4gIDsgcmVjZW50bHlfYWRkZWQgOiBib29sIHJlZlxuICA7IGdyb3d0aF9hbGxvd2VkIDogYm9vbFxuICA7IGhhc2hhYmxlIDogJ2sgSGFzaGFibGUudFxuICA7IG11dGFibGUgbXV0YXRpb25fYWxsb3dlZCA6IGJvb2wgKCogU2V0IGR1cmluZyBhbGwgaXRlcmF0aW9uIG9wZXJhdGlvbnMgKilcbiAgfVxuXG50eXBlICdhIGtleSA9ICdhXG5cbmxldCBzZXhwX29mX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3RcbmxldCBjb21wYXJlX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5jb21wYXJlXG5cbmxldCBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0ID1cbiAgaWYgbm90IHQubXV0YXRpb25fYWxsb3dlZCB0aGVuIGZhaWx3aXRoIFwiSGFzaHRibDogbXV0YXRpb24gbm90IGFsbG93ZWQgZHVyaW5nIGl0ZXJhdGlvblwiXG47O1xuXG5sZXQgd2l0aG91dF9tdXRhdGluZyB0IGYgPVxuICBpZiB0Lm11dGF0aW9uX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgIG1hdGNoIGYgKCkgd2l0aFxuICAgIHwgeCAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIHRydWU7XG4gICAgICB4XG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHJhaXNlIGV4bilcbiAgZWxzZSBmICgpXG47O1xuXG4oKiogSW50ZXJuYWxseSB1c2UgYSBtYXhpbXVtIHNpemUgdGhhdCBpcyBhIHBvd2VyIG9mIDIuIFJldmVyc2VzIHRoZSBhYm92ZSB0byBmaW5kIHRoZVxuICAgIGZsb29yIHBvd2VyIG9mIDIgYmVsb3cgdGhlIHN5c3RlbSBtYXggYXJyYXkgbGVuZ3RoICopXG5sZXQgbWF4X3RhYmxlX2xlbmd0aCA9IEludC5mbG9vcl9wb3cyIEFycmF5Lm1heF9sZW5ndGhcblxuKCogVGhlIGRlZmF1bHQgc2l6ZSBpcyBjaG9zZW4gdG8gYmUgMCAoYXMgb3Bwb3NlZCB0byAxMjggYXMgaXQgd2FzIGJlZm9yZSkgYmVjYXVzZTpcbiAgIC0gMTI4IGNhbiBjcmVhdGUgc3Vic3RhbnRpYWwgbWVtb3J5IG92ZXJoZWFkICh4MTApIHdoZW4gY3JlYXRpbmcgbWFueSB0YWJsZXMsIG1vc3RcbiAgICAgb2Ygd2hpY2ggYXJlIG5vdCBiaWcgKHNheSwgaWYgeW91IGhhdmUgYSBoYXNodGJsIG9mIGhhc2h0YmwpLiBBbmQgbWVtb3J5IG92ZXJoZWFkIGlzXG4gICAgIG5vdCB0aGF0IGVhc3kgdG8gcHJvZmlsZS5cbiAgIC0gaWYgYSBoYXNodGJsIGlzIGdvaW5nIHRvIGdyb3csIGl0J3Mgbm90IGNsZWFyIHdoeSAxMjggaXMgbWFya2VkbHkgYmV0dGVyIHRoYW4gb3RoZXJcbiAgICAgc2l6ZXMgKGlmIHlvdSBnb2luZyB0byBzdGljayAxMDAwIGVsZW1lbnRzLCB5b3UncmUgZ29pbmcgdG8gZ3JvdyB0aGUgaGFzaHRhYmxlIG9uY2VcbiAgICAgb3IgdHdpY2UgYW55d2F5KVxuICAgLSBpbiBvdGhlciBsYW5ndWFnZXMgKGxpa2UgcnVzdCwgcHl0aG9uLCBhbmQgYXBwYXJlbnRseSBnbyksIHRoZSBkZWZhdWx0IGlzIGFsc28gYVxuICAgICBzbWFsbCBzaXplLiAqKVxubGV0IGNyZWF0ZSA/KGdyb3d0aF9hbGxvd2VkID0gdHJ1ZSkgPyhzaXplID0gMCkgfmhhc2hhYmxlICgpID1cbiAgbGV0IHNpemUgPSBJbnQubWluIChJbnQubWF4IDEgc2l6ZSkgbWF4X3RhYmxlX2xlbmd0aCBpblxuICBsZXQgc2l6ZSA9IEludC5jZWlsX3BvdzIgc2l6ZSBpblxuICB7IHRhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBBdmx0cmVlLmVtcHR5XG4gIDsgbGVuZ3RoID0gMFxuICA7IGdyb3d0aF9hbGxvd2VkXG4gIDsgcmVjZW50bHlfYWRkZWQgPSByZWYgZmFsc2VcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gdC5yZWNlbnRseV9hZGRlZCBpblxuICBhZGRlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICAoKiBUaGUgYXZsIHRyZWUgbWlnaHQgcmVwbGFjZSB0aGUgdmFsdWUgW3JlcGxhY2U9dHJ1ZV0gb3IgZG8gbm90aGluZyBbcmVwbGFjZT1mYWxzZV1cbiAgICAgICB0byB0aGUgZW50cnksIGluIHRoYXQgY2FzZSB0aGUgdGFibGUgZGlkIG5vdCBnZXQgYmlnZ2VyLCBzbyB3ZSBzaG91bGQgbm90XG4gICAgICAgaW5jcmVtZW50IGxlbmd0aCwgd2UgcGFzcyBpbiB0aGUgYm9vbCByZWYgdC5hZGRlZCBzbyB0aGF0IGl0IGNhbiB0ZWxsIHVzIHdoZXRoZXJcbiAgICAgICBpdCBhZGRlZCBvciByZXBsYWNlZC4gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbi4gU2luY2UgdGhlIGJvb2xcbiAgICAgICBpcyBhbiBpbW1lZGlhdGUgaXQgZG9lcyBub3QgZ28gdGhyb3VnaCB0aGUgd3JpdGUgYmFycmllci4gKilcbiAgICBBdmx0cmVlLmFkZCB+cmVwbGFjZSByb290IH5jb21wYXJlOihjb21wYXJlX2tleSB0KSB+YWRkZWQgfmtleSB+ZGF0YVxuICBpblxuICBpZiAhYWRkZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gICgqIFRoaXMgbGl0dGxlIG9wdGltaXphdGlvbiBzYXZlcyBhIGNhbWxfbW9kaWZ5IHdoZW4gdGhlIHRyZWVcbiAgICAgaGFzbid0IGJlZW4gcmViYWxhbmNlZC4gKilcbiAgaWYgbm90IChwaHlzX2VxdWFsIG5ld19yb290IHJvb3QpIHRoZW4gdC50YWJsZS4oaSkgPC0gbmV3X3Jvb3Rcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvbGRfdGFibGUgLSAxIGRvXG4gICAgICAgIEF2bHRyZWUuaXRlciBvbGRfdGFibGUuKGkpIH5mXG4gICAgICBkb25lKSlcbjs7XG5cbmxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YTtcbiAgbWF5YmVfcmVzaXplX3RhYmxlIHRcbjs7XG5cbmxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTpmYWxzZSB0IH5rZXkgfmRhdGE7XG4gIGlmICEodC5yZWNlbnRseV9hZGRlZClcbiAgdGhlbiAoXG4gICAgbWF5YmVfcmVzaXplX3RhYmxlIHQ7XG4gICAgYE9rKVxuICBlbHNlIGBEdXBsaWNhdGVcbjs7XG5cbmxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gIG1hdGNoIGFkZCB0IH5rZXkgfmRhdGEgd2l0aFxuICB8IGBPayAtPiAoKVxuICB8IGBEdXBsaWNhdGUgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleSB0IGluXG4gICAgbGV0IGVycm9yID0gRXJyb3IuY3JlYXRlIFwiSGFzaHRibC5hZGRfZXhuIGdvdCBrZXkgYWxyZWFkeSBwcmVzZW50XCIga2V5IHNleHBfb2Zfa2V5IGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIHQudGFibGUuKGkpIDwtIEF2bHRyZWUuZW1wdHlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gMFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDIgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMlxuICAgICAgdHJlZVxuICAgICAgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gICAgICBrZXlcbiAgICAgIH5hXG4gICAgICB+YlxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQga2V5IC0+IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gdCBrZXkgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBmYWxzZVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gXyB9IC0+IGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwXG4gIHwgdHJlZSAtPiBBdmx0cmVlLm1lbSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXlcbjs7XG5cbmxldCByZW1vdmUgdCBrZXkgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBsZXQgaSA9IHNsb3QgdCBrZXkgaW5cbiAgbGV0IHJvb3QgPSB0LnRhYmxlLihpKSBpblxuICBsZXQgYWRkZWRfb3JfcmVtb3ZlZCA9IHQucmVjZW50bHlfYWRkZWQgaW5cbiAgYWRkZWRfb3JfcmVtb3ZlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICBBdmx0cmVlLnJlbW92ZSByb290IH5yZW1vdmVkOmFkZGVkX29yX3JlbW92ZWQgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuICBpblxuICBpZiBub3QgKHBoeXNfZXF1YWwgcm9vdCBuZXdfcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdDtcbiAgaWYgIWFkZGVkX29yX3JlbW92ZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDFcbjs7XG5cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBhY2MgOj0gZiB+a2V5IH5kYXRhICFhY2NcbiAgICAgICAgfCBidWNrZXQgLT4gYWNjIDo9IEF2bHRyZWUuZm9sZCBidWNrZXQgfmluaXQ6IWFjYyB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgICFhY2NcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiAoKVxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgICAgICAgfCBidWNrZXQgLT4gQXZsdHJlZS5pdGVyIGJ1Y2tldCB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+IHQubXV0YXRpb25fYWxsb3dlZCA8LSBtXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBpdGVyX2tleXMgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5cbmxldCByZWMgY2hvb3NlX25vbmVtcHR5IHRhYmxlIGkgPVxuICBsZXQgYXZsdHJlZSA9IHRhYmxlLihpKSBpblxuICBpZiBBdmx0cmVlLmlzX2VtcHR5IGF2bHRyZWVcbiAgdGhlbiBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgKGkgKyAxKVxuICBlbHNlIEF2bHRyZWUuY2hvb3NlX2V4biBhdmx0cmVlXG47O1xuXG5sZXQgY2hvb3NlX2V4biB0ID1cbiAgaWYgdC5sZW5ndGggPSAwIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMFxuOztcblxubGV0IGNob29zZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9rZXkgaW52YXJpYW50X2RhdGEgdCA9XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICBBdmx0cmVlLmludmFyaWFudCB0LnRhYmxlLihpKSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgZG9uZTtcbiAgbGV0IHJlYWxfbGVuID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgaSAtPlxuICAgICAgaW52YXJpYW50X2tleSBrZXk7XG4gICAgICBpbnZhcmlhbnRfZGF0YSBkYXRhO1xuICAgICAgaSArIDEpXG4gIGluXG4gIGFzc2VydCAocmVhbF9sZW4gPSB0Lmxlbmd0aClcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBpZl9mb3VuZCB2IF8gPSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgayB0ID1cbiAgICByYWlzZVxuICAgICAgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIkhhc2h0YmwuZmluZF9leG46IG5vdCBmb3VuZFwiOyB0Lmhhc2hhYmxlLnNleHBfb2ZfdCBrIF0pKVxuICBpblxuICBsZXQgZmluZF9leG4gdCBrZXkgPSBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YTp0IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxubGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IG5vdCAoZiBkYXRhKSkpXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6KGYgfmtleSB+ZGF0YSkpO1xuICBuZXdfdFxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBjb3B5IHQgPSBtYXAgdCB+ZjpGbi5pZFxuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCBuZXdfdCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IFNvbWUgbmV3X2RhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IE5vbmUgLT4gKCkpO1xuICBuZXdfdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgdDAgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBsZXQgdDEgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBuZXdfZGF0YSAtPiBzZXQgdDAgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgU2Vjb25kIG5ld19kYXRhIC0+IHNldCB0MSB+a2V5IH5kYXRhOm5ld19kYXRhKTtcbiAgdDAsIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmluZF9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGwyXG4gICAgdFxuICAgIGlkXG4gICAgfmE6dFxuICAgIH5iOmRlZmF1bHRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIF8gXyAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgdCBkZWZhdWx0IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQgKCkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpXG47O1xuXG5sZXQgZmluZGlfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsMlxuICAgIHRcbiAgICBpZFxuICAgIH5hOnRcbiAgICB+YjpkZWZhdWx0XG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSBfIF8gLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IHQgZGVmYXVsdCAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0IGtleSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdClcbjs7XG5cbigqIFNvbWUgaGFzaHRibCBpbXBsZW1lbnRhdGlvbnMgbWF5IGJlIGFibGUgdG8gcGVyZm9ybSB0aGlzIG1vcmUgZWZmaWNpZW50bHkgdGhhbiB0d29cbiAgIHNlcGFyYXRlIGxvb2t1cHMgKilcbmxldCBmaW5kX2FuZF9yZW1vdmUgdCBpZCA9XG4gIGxldCByZXN1bHQgPSBmaW5kIHQgaWQgaW5cbiAgaWYgT3B0aW9uLmlzX3NvbWUgcmVzdWx0IHRoZW4gcmVtb3ZlIHQgaWQ7XG4gIHJlc3VsdFxuOztcblxuXG5sZXQgY2hhbmdlIHQgaWQgfmYgPVxuICBtYXRjaCBmIChmaW5kIHQgaWQpIHdpdGhcbiAgfCBOb25lIC0+IHJlbW92ZSB0IGlkXG4gIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXk6aWQgfmRhdGFcbjs7XG5cbmxldCB1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mID1cbiAgbGV0IGRhdGEgPSBmIChmaW5kIHQgaWQpIGluXG4gIHNldCB0IH5rZXk6aWQgfmRhdGE7XG4gIGRhdGFcbjs7XG5cbmxldCB1cGRhdGUgdCBpZCB+ZiA9IGlnbm9yZSAodXBkYXRlX2FuZF9yZXR1cm4gdCBpZCB+ZiA6IF8pXG5cbmxldCBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSBieSA9XG4gIGlmIHJlbW92ZV9pZl96ZXJvXG4gIHRoZW5cbiAgICBjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvcHQgLT5cbiAgICAgIG1hdGNoIGJ5ICsgT3B0aW9uLnZhbHVlIG9wdCB+ZGVmYXVsdDowIHdpdGhcbiAgICAgIHwgMCAtPiBOb25lXG4gICAgICB8IG4gLT4gU29tZSBuKVxuICBlbHNlXG4gICAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IGJ5XG4gICAgICB8IFNvbWUgaSAtPiBieSArIGkpXG47O1xuXG5sZXQgaW5jciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5XG5sZXQgZGVjciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5ICgtYnkpXG5cbmxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBbIGRhdGEgXVxuICAgIHwgU29tZSBsIC0+IGRhdGEgOjogbClcbjs7XG5cbmxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBbXSB8IFNvbWUgWyBfIF0gLT4gcmVtb3ZlIHQga2V5XG4gIHwgU29tZSAoXyA6OiB0bCkgLT4gc2V0IHQgfmtleSB+ZGF0YTp0bFxuOztcblxubGV0IGZpbmRfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBsIC0+IGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSB+c2l6ZSAoKSBpblxuICBsZXQgZHVwZXMgPSByZWYgW10gaW5cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByIC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgciBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgciBpblxuICAgIGlmIG1lbSByZXMga2V5IHRoZW4gZHVwZXMgOj0ga2V5IDo6ICFkdXBlcyBlbHNlIHNldCByZXMgfmtleSB+ZGF0YSk7XG4gIG1hdGNoICFkdXBlcyB3aXRoXG4gIHwgW10gLT4gYE9rIHJlc1xuICB8IGtleXMgLT4gYER1cGxpY2F0ZV9rZXlzIChMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmUga2V5cylcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkX211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIH5oYXNoYWJsZSAoKSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgYWRkX211bHRpIHJlcyB+a2V5IH5kYXRhKTtcbiAgcmVzXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0IHdpdGhcbiAgfCBgT2sgdCAtPiBgT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrIC0+IGBEdXBsaWNhdGVfa2V5IChMaXN0LmhkX2V4biBrKVxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBgT2sgdiAtPiBSZXN1bHQuT2sgdlxuICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yIFwiSGFzaHRibC5vZl9hbGlzdF9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgc2V4cF9vZl9rZXlcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCB3aXRoXG4gIHwgUmVzdWx0Lk9rIHYgLT4gdlxuICB8IFJlc3VsdC5FcnJvciBlIC0+IEVycm9yLnJhaXNlIGVcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCB0b19hbGlzdCB0ID0gZm9sZCB+ZjooZnVuIH5rZXkgfmRhdGEgbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBsaXN0KSB+aW5pdDpbXSB0XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhIHQgPVxuICB0XG4gIHw+IHRvX2FsaXN0XG4gIHw+IExpc3Quc29ydCB+Y29tcGFyZTooZnVuIChrMSwgXykgKGsyLCBfKSAtPiB0Lmhhc2hhYmxlLmNvbXBhcmUgazEgazIpXG4gIHw+IHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSlcbjs7XG5cbmxldCB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9XG4gIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHApIHNleHAgaW5cbiAgbWF0Y2ggb2ZfYWxpc3Qgfmhhc2hhYmxlIGFsaXN0IH5zaXplOihMaXN0Lmxlbmd0aCBhbGlzdCkgd2l0aFxuICB8IGBPayB2IC0+IHZcbiAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICBMaXN0Lml0ZXIyX2V4biBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICBpZiBoYXNoYWJsZS5jb21wYXJlIGsgazIgPSAwXG4gICAgICB0aGVuXG4gICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIkhhc2h0YmwudF9vZl9zZXhwOiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXJcbiAgICAgICh0eXBlIGsgdilcbiAgICAgIChrX2dyYW1tYXIgOiBrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgKHZfZ3JhbW1hciA6IHYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogKGssIHYpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LkFzc29jLnRfc2V4cF9ncmFtbWFyIGtfZ3JhbW1hciB2X2dyYW1tYXIpXG47O1xuXG5sZXQga2V5cyB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YTpfIGFjYyAtPiBrZXkgOjogYWNjKVxubGV0IGRhdGEgdCA9IGZvbGQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IGFkZF90b19ncm91cHMgZ3JvdXBzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cyA9XG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gcm93IC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgcm93IGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByb3cgaW5cbiAgICBsZXQgZGF0YSA9XG4gICAgICBtYXRjaCBmaW5kIGdyb3VwcyBrZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgIHwgU29tZSBvbGQgLT4gY29tYmluZSBvbGQgZGF0YVxuICAgIGluXG4gICAgc2V0IGdyb3VwcyB+a2V5IH5kYXRhKVxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIHJvd3MgPVxuICBsZXQgcmVzID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgYWRkX3RvX2dyb3VwcyByZXMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzO1xuICByZXNcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YTpGbi5pZCByb3dzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIG1hdGNoIGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3Mgd2l0aFxuICB8IGBPayB0IC0+IFJlc3VsdC5PayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGtleXMgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBoYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3QgaW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkhhc2h0YmwuY3JlYXRlX3dpdGhfa2V5OiBkdXBsaWNhdGUga2V5c1wiXG4gICAgICAgICBbIFwia2V5c1wiLCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9rZXkga2V5cyBdKVxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgT3JfZXJyb3Iub2tfZXhuIChjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzKVxuOztcblxubGV0IG1lcmdlID1cbiAgbGV0IG1heWJlX3NldCB0IH5rZXkgfmYgZCA9XG4gICAgbWF0Y2ggZiB+a2V5IGQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB2IC0+IHNldCB0IH5rZXkgfmRhdGE6dlxuICBpblxuICBmdW4gdF9sZWZ0IHRfcmlnaHQgfmYgLT5cbiAgICBpZiBub3QgKEhhc2hhYmxlLmVxdWFsIHRfbGVmdC5oYXNoYWJsZSB0X3JpZ2h0Lmhhc2hhYmxlKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJIYXNodGJsLm1lcmdlOiBkaWZmZXJlbnQgJ2hhc2hhYmxlJyB2YWx1ZXNcIjtcbiAgICBsZXQgbmV3X3QgPVxuICAgICAgY3JlYXRlXG4gICAgICAgIH5ncm93dGhfYWxsb3dlZDp0X2xlZnQuZ3Jvd3RoX2FsbG93ZWRcbiAgICAgICAgfmhhc2hhYmxlOnRfbGVmdC5oYXNoYWJsZVxuICAgICAgICB+c2l6ZTp0X2xlZnQubGVuZ3RoXG4gICAgICAgICgpXG4gICAgaW5cbiAgICB3aXRob3V0X211dGF0aW5nIHRfbGVmdCAoZnVuICgpIC0+XG4gICAgICB3aXRob3V0X211dGF0aW5nIHRfcmlnaHQgKGZ1biAoKSAtPlxuICAgICAgICBpdGVyaSB0X2xlZnQgfmY6KGZ1biB+a2V5IH5kYXRhOmxlZnQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfcmlnaHQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBMZWZ0IGxlZnQpXG4gICAgICAgICAgfCBTb21lIHJpZ2h0IC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgQm90aCAobGVmdCwgcmlnaHQpKSk7XG4gICAgICAgIGl0ZXJpIHRfcmlnaHQgfmY6KGZ1biB+a2V5IH5kYXRhOnJpZ2h0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X2xlZnQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBSaWdodCByaWdodClcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICAgICgqIGFscmVhZHkgZG9uZSBhYm92ZSAqKSkpKTtcbiAgICBuZXdfdFxuOztcblxubGV0IG1lcmdlX2ludG8gfnNyYyB+ZHN0IH5mID1cbiAgaXRlcmkgc3JjIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCBkc3RfZGF0YSA9IGZpbmQgZHN0IGtleSBpblxuICAgIGxldCBhY3Rpb24gPSB3aXRob3V0X211dGF0aW5nIGRzdCAoZnVuICgpIC0+IGYgfmtleSBkYXRhIGRzdF9kYXRhKSBpblxuICAgIG1hdGNoIChhY3Rpb24gOiBfIE1lcmdlX2ludG9fYWN0aW9uLnQpIHdpdGhcbiAgICB8IFJlbW92ZSAtPiByZW1vdmUgZHN0IGtleVxuICAgIHwgU2V0X3RvIGRhdGEgLT5cbiAgICAgIChtYXRjaCBkc3RfZGF0YSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHNldCBkc3QgfmtleSB+ZGF0YVxuICAgICAgIHwgU29tZSBkc3RfZGF0YSAtPiBpZiBub3QgKHBoeXNfZXF1YWwgZHN0X2RhdGEgZGF0YSkgdGhlbiBzZXQgZHN0IH5rZXkgfmRhdGEpKVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHRvX3JlbW92ZSA9XG4gICAgZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhYyBlbHNlIGtleSA6OiBhYylcbiAgaW5cbiAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIGtleSAtPiByZW1vdmUgdCBrZXkpXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9IGZpbHRlcmlfaW5wbGFjZSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmaWx0ZXJfa2V5c19pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCBtYXBfcmVzdWx0cyA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gKGtleSwgZiB+a2V5IH5kYXRhKSA6OiBhYykgaW5cbiAgTGlzdC5pdGVyIG1hcF9yZXN1bHRzIH5mOihmdW4gKGtleSwgcmVzdWx0KSAtPlxuICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgfCBOb25lIC0+IHJlbW92ZSB0IGtleVxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICB3aXRob3V0X211dGF0aW5nIHQgKGZ1biAoKSAtPiBBcnJheS5pdGVyIHQudGFibGUgfmY6KEF2bHRyZWUubWFwaV9pbnBsYWNlIH5mKSlcbjs7XG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID0gbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZXF1YWwgZXF1YWwgdCB0JyA9XG4gIGxlbmd0aCB0ID0gbGVuZ3RoIHQnXG4gICYmIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgbWF0Y2ggZmluZCB0JyBrZXkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgfCBTb21lIGRhdGEnIC0+IGlmIG5vdCAoZXF1YWwgZGF0YSBkYXRhJykgdGhlbiByLnJldHVybiBmYWxzZSkpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgc2ltaWxhciA9IGVxdWFsXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgY2hvb3NlID0gY2hvb3NlXG4gIGxldCBjaG9vc2VfZXhuID0gY2hvb3NlX2V4blxuICBsZXQgY2xlYXIgPSBjbGVhclxuICBsZXQgY29weSA9IGNvcHlcbiAgbGV0IHJlbW92ZSA9IHJlbW92ZVxuICBsZXQgc2V0ID0gc2V0XG4gIGxldCBhZGQgPSBhZGRcbiAgbGV0IGFkZF9leG4gPSBhZGRfZXhuXG4gIGxldCBjaGFuZ2UgPSBjaGFuZ2VcbiAgbGV0IHVwZGF0ZSA9IHVwZGF0ZVxuICBsZXQgdXBkYXRlX2FuZF9yZXR1cm4gPSB1cGRhdGVfYW5kX3JldHVyblxuICBsZXQgYWRkX211bHRpID0gYWRkX211bHRpXG4gIGxldCByZW1vdmVfbXVsdGkgPSByZW1vdmVfbXVsdGlcbiAgbGV0IGZpbmRfbXVsdGkgPSBmaW5kX211bHRpXG4gIGxldCBtZW0gPSBtZW1cbiAgbGV0IGl0ZXJfa2V5cyA9IGl0ZXJfa2V5c1xuICBsZXQgaXRlciA9IGl0ZXJcbiAgbGV0IGl0ZXJpID0gaXRlcmlcbiAgbGV0IGV4aXN0cyA9IGV4aXN0c1xuICBsZXQgZXhpc3RzaSA9IGV4aXN0c2lcbiAgbGV0IGZvcl9hbGwgPSBmb3JfYWxsXG4gIGxldCBmb3JfYWxsaSA9IGZvcl9hbGxpXG4gIGxldCBjb3VudCA9IGNvdW50XG4gIGxldCBjb3VudGkgPSBjb3VudGlcbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGlzX2VtcHR5ID0gaXNfZW1wdHlcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwaSA9IG1hcGlcbiAgbGV0IGZpbHRlcl9tYXAgPSBmaWx0ZXJfbWFwXG4gIGxldCBmaWx0ZXJfbWFwaSA9IGZpbHRlcl9tYXBpXG4gIGxldCBmaWx0ZXJfa2V5cyA9IGZpbHRlcl9rZXlzXG4gIGxldCBmaWx0ZXIgPSBmaWx0ZXJcbiAgbGV0IGZpbHRlcmkgPSBmaWx0ZXJpXG4gIGxldCBwYXJ0aXRpb25fbWFwID0gcGFydGl0aW9uX21hcFxuICBsZXQgcGFydGl0aW9uX21hcGkgPSBwYXJ0aXRpb25fbWFwaVxuICBsZXQgcGFydGl0aW9uX3RmID0gcGFydGl0aW9uX3RmXG4gIGxldCBwYXJ0aXRpb25pX3RmID0gcGFydGl0aW9uaV90ZlxuICBsZXQgZmluZF9vcl9hZGQgPSBmaW5kX29yX2FkZFxuICBsZXQgZmluZGlfb3JfYWRkID0gZmluZGlfb3JfYWRkXG4gIGxldCBmaW5kID0gZmluZFxuICBsZXQgZmluZF9leG4gPSBmaW5kX2V4blxuICBsZXQgZmluZF9hbmRfY2FsbCA9IGZpbmRfYW5kX2NhbGxcbiAgbGV0IGZpbmRfYW5kX2NhbGwxID0gZmluZF9hbmRfY2FsbDFcbiAgbGV0IGZpbmRfYW5kX2NhbGwyID0gZmluZF9hbmRfY2FsbDJcbiAgbGV0IGZpbmRpX2FuZF9jYWxsID0gZmluZGlfYW5kX2NhbGxcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMSA9IGZpbmRpX2FuZF9jYWxsMVxuICBsZXQgZmluZGlfYW5kX2NhbGwyID0gZmluZGlfYW5kX2NhbGwyXG4gIGxldCBmaW5kX2FuZF9yZW1vdmUgPSBmaW5kX2FuZF9yZW1vdmVcbiAgbGV0IHRvX2FsaXN0ID0gdG9fYWxpc3RcbiAgbGV0IG1lcmdlID0gbWVyZ2VcbiAgbGV0IG1lcmdlX2ludG8gPSBtZXJnZV9pbnRvXG4gIGxldCBrZXlzID0ga2V5c1xuICBsZXQgZGF0YSA9IGRhdGFcbiAgbGV0IGZpbHRlcl9rZXlzX2lucGxhY2UgPSBmaWx0ZXJfa2V5c19pbnBsYWNlXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSA9IGZpbHRlcl9pbnBsYWNlXG4gIGxldCBmaWx0ZXJpX2lucGxhY2UgPSBmaWx0ZXJpX2lucGxhY2VcbiAgbGV0IG1hcF9pbnBsYWNlID0gbWFwX2lucGxhY2VcbiAgbGV0IG1hcGlfaW5wbGFjZSA9IG1hcGlfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwaV9pbnBsYWNlID0gZmlsdGVyX21hcGlfaW5wbGFjZVxuICBsZXQgZXF1YWwgPSBlcXVhbFxuICBsZXQgc2ltaWxhciA9IHNpbWlsYXJcbiAgbGV0IGluY3IgPSBpbmNyXG4gIGxldCBkZWNyID0gZGVjclxuICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleVxuZW5kXG5cbm1vZHVsZSBDcmVhdG9ycyAoS2V5IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEtleS50KSAtPiAoU2V4cC50IC0+ICdiKSAtPiBTZXhwLnQgLT4gKCdhLCAnYikgdF9cblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBLZXkuaGFzaGFibGVcblxuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKClcbiAgbGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID0gb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG5cbiAgbGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHBcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gICAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgICBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG4gIDs7XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXkgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IEhhc2hhYmxlLnBvbHlcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEhhc2hhYmxlID0gSGFzaGFibGUuSGFzaGFibGVcblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBsZXQgaGFzaGFibGUgdCA9IHQuaGFzaGFibGVcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgY3JlYXRlIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKVxuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfbXVsdGkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgY3JlYXRlX21hcHBlZCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgZ3JvdXAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG47O1xuXG5sZXQgaGFzaGFibGVfcyB0ID0gSGFzaGFibGUudG9fa2V5IHQuaGFzaGFibGVcblxubW9kdWxlIE0gKEsgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBrKSAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrKSB2X29mX3NleHAgc2V4cCA9XG4gIHRfb2Zfc2V4cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSAobW9kdWxlIEspKSBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGspIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaykgdl9ncmFtbWFyID1cbiAgdF9zZXhwX2dyYW1tYXIgSy50X3NleHBfZ3JhbW1hciB2X2dyYW1tYXJcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaF9zZXRfaW50ZlxuXG5sZXQgaGFzaGFibGVfcyA9IEhhc2h0YmwuaGFzaGFibGVfc1xubGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5sZXQgcG9seV9oYXNoYWJsZSA9IEhhc2h0YmwuUG9seS5oYXNoYWJsZVxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAnYSB0ID0gKCdhLCB1bml0KSBIYXNodGJsLnRcbnR5cGUgJ2EgaGFzaF9zZXQgPSAnYSB0XG50eXBlICdhIGVsdCA9ICdhXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgbGV0IGNsZWFyID0gSGFzaHRibC5jbGVhclxuICBsZXQgbGVuZ3RoID0gSGFzaHRibC5sZW5ndGhcbiAgbGV0IG1lbSA9IEhhc2h0YmwubWVtXG4gIGxldCBpc19lbXB0eSB0ID0gSGFzaHRibC5pc19lbXB0eSB0XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgSGFzaHRibC5pdGVyX2tleXMgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyBhcyBvIC0+IHIucmV0dXJuIG8pO1xuICAgICAgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID0gZmluZF9tYXAgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gU29tZSBhIGVsc2UgTm9uZSlcbiAgbGV0IGFkZCB0IGsgPSBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKVxuXG4gIGxldCBzdHJpY3RfYWRkIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwiZWxlbWVudCBhbHJlYWR5IGV4aXN0c1wiXG4gICAgZWxzZSAoXG4gICAgICBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKTtcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgOztcblxuICBsZXQgc3RyaWN0X2FkZF9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfYWRkIHQgaylcbiAgbGV0IHJlbW92ZSA9IEhhc2h0YmwucmVtb3ZlXG5cbiAgbGV0IHN0cmljdF9yZW1vdmUgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmUgdCBrO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3IgXCJlbGVtZW50IG5vdCBpbiBzZXRcIiBrIChIYXNodGJsLnNleHBfb2Zfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9yZW1vdmVfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X3JlbW92ZSB0IGspXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBIYXNodGJsLmZvbGQgdCB+aW5pdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgYWNjIC0+IGYgYWNjIGtleSlcbiAgbGV0IGl0ZXIgdCB+ZiA9IEhhc2h0YmwuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IHRvX2xpc3QgPSBIYXNodGJsLmtleXNcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZSB0ID1cbiAgICBzZXhwX29mX2xpc3Qgc2V4cF9vZl9lICh0b19saXN0IHQgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihoYXNoYWJsZSB0KS5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXQgaW5kZXggPSByZWYgKGxlbiAtIDEpIGluXG4gICAgZm9sZCB0IH5pbml0Olt8fF0gfmY6KGZ1biBhY2Mga2V5IC0+XG4gICAgICBpZiBBcnJheS5sZW5ndGggYWNjID0gMFxuICAgICAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiBrZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBpbmRleCA6PSAhaW5kZXggLSAxO1xuICAgICAgICBhY2MuKCFpbmRleCkgPC0ga2V5O1xuICAgICAgICBhY2MpKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9IEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IG5vdCAoZiBrZXkpKSlcbiAgbGV0IGVxdWFsIHQxIHQyID0gSGFzaHRibC5lcXVhbCAoZnVuICgpICgpIC0+IHRydWUpIHQxIHQyXG4gIGxldCBjb3B5IHQgPSBIYXNodGJsLmNvcHkgdFxuICBsZXQgZmlsdGVyIHQgfmYgPSBIYXNodGJsLmZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IEhhc2h0YmwubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gXyAtPiBTb21lICgpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGZpbHRlciB0MSB+ZjooZnVuIGtleSAtPiBub3QgKEhhc2h0YmwubWVtIHQyIGtleSkpXG5cbiAgbGV0IGludGVyIHQxIHQyID1cbiAgICBsZXQgc21hbGxlciwgbGFyZ2VyID0gaWYgbGVuZ3RoIHQxID4gbGVuZ3RoIHQyIHRoZW4gdDIsIHQxIGVsc2UgdDEsIHQyIGluXG4gICAgSGFzaHRibC5maWx0ZXJpIHNtYWxsZXIgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IEhhc2h0YmwubWVtIGxhcmdlciBrZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICAgIGxldCB0b19yZW1vdmUgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBhYyB4IC0+IGlmIGYgeCB0aGVuIGFjIGVsc2UgeCA6OiBhYykgaW5cbiAgICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4geCAtPiByZW1vdmUgdCB4KVxuICA7O1xuXG4gIGxldCBvZl9oYXNodGJsX2tleXMgaGFzaHRibCA9IEhhc2h0YmwubWFwIGhhc2h0YmwgfmY6aWdub3JlXG4gIGxldCB0b19oYXNodGJsIHQgfmYgPSBIYXNodGJsLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtXG5cbmxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCBsXG4gIGluXG4gIGxldCB0ID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIG0gaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biBrIC0+IGFkZCB0IGspO1xuICB0XG47O1xuXG5sZXQgdF9vZl9zZXhwIG0gZV9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIHJlcXVpcmVzIGEgbGlzdFwiIHNleHBcbiAgfCBTZXhwLkxpc3QgbGlzdCAtPlxuICAgIGxldCB0ID0gY3JlYXRlIG0gfnNpemU6KExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biBzZXhwIC0+XG4gICAgICBsZXQgZSA9IGVfb2Zfc2V4cCBzZXhwIGluXG4gICAgICBtYXRjaCBzdHJpY3RfYWRkIHQgZSB3aXRoXG4gICAgICB8IE9rICgpIC0+ICgpXG4gICAgICB8IEVycm9yIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCBnb3QgYSBkdXBsaWNhdGUgZWxlbWVudFwiIHNleHApO1xuICAgIHRcbjs7XG5cbm1vZHVsZSBDcmVhdG9ycyAoRWx0IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBFbHQudCkgLT4gU2V4cC50IC0+ICdhIEVsdC50IHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIEVsdC50IHRcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgd2l0aCB0eXBlICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9XG4gICAgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGVfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBlX29mX3NleHAgc2V4cFxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGhhc2hfc2V0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBwb2x5X2hhc2hhYmxlXG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICAgIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG5lbmRcblxubW9kdWxlIE0gKEVsdCA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IEVsdC50IHRcbmVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQpIHNleHAgPVxuICB0X29mX3NleHAgKG1vZHVsZSBFbHQpIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdCkgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFByaW50ZlxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5pbmNsdWRlIEZsb2F0MFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Zsb2F0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9mbG9hdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoZmxvYXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfZmxvYXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gZmxvYXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IHRvX2Zsb2F0IHggPSB4XG5sZXQgb2ZfZmxvYXQgeCA9IHhcblxubGV0IG9mX3N0cmluZyBzID1cbiAgdHJ5IGZsb2F0X29mX3N0cmluZyBzIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcIkZsb2F0Lm9mX3N0cmluZyAlc1wiIHMgKClcbjs7XG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogU3RvbGVuIGZyb20gW3BlcnZhc2l2ZXMubWxdLiAgQWRkcyBhIFwiLlwiIGF0IHRoZSBlbmQgaWYgbmVlZGVkLiAgSXQgaXMgaW5cbiAgIFtwZXJ2YXNpdmVzLm1saV0sIGJ1dCBpdCBhbHNvIHNheXMgbm90IHRvIHVzZSBpdCBkaXJlY3RseSwgc28gd2UgY29weSBhbmQgcGFzdGUgdGhlXG4gICBjb2RlLiBJdCBtYWtlcyB0aGUgYXNzdW1wdGlvbiBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpbiBhcmd1bWVudCB0aGF0IGl0IHdhcyByZXR1cm5lZCBieVxuICAgW2Zvcm1hdF9mbG9hdF0uICopXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBpIGxcbiAgICB0aGVuIHMgXiBcIi5cIlxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBfIC0+IHMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxuKCogTGV0IFt5XSBiZSBhIHBvd2VyIG9mIDIuICBUaGVuIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQgaXM6XG4gICBbeiA9IHkgKiAoMSArIDIgKiogLTUyKV1cbiAgIGFuZCB0aGUgcHJldmlvdXMgb25lIGlzXG4gICBbeCA9IHkgKiAoMSAtIDIgKiogLTUzKV1cblxuICAgSW4gZ2VuZXJhbCwgZXZlcnkgdHdvIGFkamFjZW50IGZsb2F0cyBhcmUgd2l0aGluIGEgZmFjdG9yIG9mIGJldHdlZW4gWzEgKyAyKiotNTNdXG4gICBhbmQgWzEgKyAyKiotNTJdIGZyb20gZWFjaCBvdGhlciwgdGhhdCBpcyB3aXRoaW4gWzEgKyAxLjFlLTE2XSBhbmQgWzEgKyAyLjNlLTE2XS5cblxuICAgU28gaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdCBzdGFydHMgd2l0aCBcIjFcIiwgdGhlbiBpdHMgYWRqYWNlbnQgZmxvYXRzXG4gICB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb20gaXQgYnkgMSwgYW5kIHNvbWV0aW1lcyBieSAyLCBhdCB0aGUgMTd0aCBzaWduaWZpY2FudCBkaWdpdFxuICAgKGNvdW50aW5nIGZyb20gMSkuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdGFydHMgd2l0aCBcIjlcIiwgdGhlbiB0aGUgYWRqYWNlbnRcbiAgIGZsb2F0cyB3aWxsIGJlIG9mZiBieSBubyBtb3JlIHRoYW4gMjMgYXQgdGhlIDE2dGggYW5kIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRzLlxuXG4gICBFLmcuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5OVwiXG4gICB2fVxuICAgUHJpbnRpbmcgYSBjb3VwbGUgb2YgZXh0cmEgZGlnaXRzIHJldmVhbHMgdGhhdCB0aGUgZGlmZmVyZW5jZSBpbmRlZWQgaXMgcm91Z2hseSAxMSBhdFxuICAgZGlnaXRzIDE3dGggYW5kIDE4dGggKHRoYXQgaXMsIDEzdGggYW5kIDE0dGggYWZ0ZXIgXCIuXCIpOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTg4NlwiXG4gICB2fVxuXG4gICBUaGUgdWxwICh0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFkamFjZW50IGZsb2F0cykgaXMgdHdpY2UgYXMgYmlnIG9uIHRoZSBvdGhlciBzaWRlIG9mXG4gICAxMDI0LjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuICsuIDIuKiogKC01Mi4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyNC4wMDAwMDAwMDAwMDAyMjdcIlxuICAgdn1cblxuICAgTm93IHRha2UgYSBwb3dlciBvZiAyIHdoaWNoIHN0YXJ0cyB3aXRoIDk5OlxuXG4gICB7dlxuICAgICAjIDIuKio5My4gOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAxIDIzNDU2Nzg5MDEyMzQ1Njc4XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQyMmUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuICsuIDIuKiogKC01Mi4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQ0NGUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuIC0uIDIuKiogKC01My4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQxMWUrMjdcbiAgIHZ9XG5cbiAgIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMioqOTMgYW5kIGl0cyB0d28gbmVpZ2hib3JzIGlzIHNsaWdodGx5IG1vcmUgdGhhbiwgcmVzcGVjdGl2ZWx5LFxuICAgMSBhbmQgMiBhdCBzaWduaWZpY2FudCBkaWdpdCAxNi5cblxuICAgVGhvc2UgZXhhbXBsZXMgc2hvdyB0aGF0OlxuICAgLSAxNyBzaWduaWZpY2FudCBkaWdpdHMgaXMgYWx3YXlzIHN1ZmZpY2llbnQgdG8gcmVwcmVzZW50IGEgZmxvYXQgd2l0aG91dCBhbWJpZ3VpdHlcbiAgIC0gMTV0aCBzaWduaWZpY2FudCBkaWdpdCBjYW4gYWx3YXlzIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHlcbiAgIC0gY29udmVydGluZyBhIGRlY2ltYWwgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGl0cyBuZWFyZXN0IGZsb2F0IGFuZCBiYWNrXG4gICAgIGNhbiBjaGFuZ2UgdGhlIGxhc3QgZGVjaW1hbCBkaWdpdCBieSBubyBtb3JlIHRoYW4gMVxuXG4gICBUbyBtYWtlIHN1cmUgdGhhdCBmbG9hdHMgb2J0YWluZWQgYnkgY29udmVyc2lvbiBmcm9tIGRlY2ltYWwgZnJhY3Rpb25zIChlLmcuIFwiMy4xNFwiKVxuICAgYXJlIHByaW50ZWQgd2l0aG91dCB0cmFpbGluZyBub24temVybyBkaWdpdHMsIG9uZSBzaG91bGQgY2hvb3NlIHRoZSBmaXJzdCBhbW9uZyB0aGVcbiAgICclLjE1ZycsICclLjE2ZycsIGFuZCAnJS4xN2cnIHJlcHJlc2VudGF0aW9ucyB3aGljaCBkb2VzIHJvdW5kLXRyaXA6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIiAgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lICopXG5cbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjhcIiAgICAgICAgICAgICAgICAgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1kb2VzIG5vdCByb3VuZC10cmlwICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMlwiICAgICAgICAoKiBwcmVmZXIgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAxOFwiICAgICAgICgqIHRoaXMgb25lIGhhcyBvbmUgZGlnaXQgb2YganVuayBhdCB0aGUgZW5kICopXG4gICB2fVxuXG4gICBTa2lwcGluZyB0aGUgJyUuMTZnJyBpbiB0aGUgYWJvdmUgcHJvY2VkdXJlIHNhdmVzIHVzIHNvbWUgdGltZSwgYnV0IGl0IG1lYW5zIHRoYXQsIGFzXG4gICBzZWVuIGluIHRoZSBzZWNvbmQgZXhhbXBsZSBhYm92ZSwgb2NjYXNpb25hbGx5IG51bWJlcnMgd2l0aCBleGFjdGx5IDE2IHNpZ25pZmljYW50XG4gICBkaWdpdHMgd2lsbCBoYXZlIGFuIGVycm9yIGludHJvZHVjZWQgYXQgdGhlIDE3dGggZGlnaXQuICBUaGF0IGlzIHByb2JhYmx5IE9LIGZvclxuICAgdHlwaWNhbCB1c2UsIGJlY2F1c2UgYSBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaXMgXCJ1Z2x5XCIgYWxyZWFkeS4gIEFkZGluZyBvbmVcbiAgIG1vcmUgZG9lc24ndCBtYWtlIGl0IG11Y2ggd29yc2UgZm9yIGEgaHVtYW4gcmVhZGVyLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgd2UgY2Fubm90IHNraXAgJyUuMTVnJyBhbmQgb25seSBsb29rIGF0ICclLjE2ZycgYW5kICclLjE3ZycsIHNpbmNlXG4gICB0aGUgaW5hY2N1cmFjeSBhdCB0aGUgMTZ0aCBkaWdpdCBtaWdodCBpbnRyb2R1Y2UgdGhlIG5vaXNlIHdlIHdhbnQgdG8gYXZvaWQ6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MlwiICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMVwiICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tanVuayBhdCB0aGUgZW5kICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMDlcIlxuICAgdn1cbiopXG5sZXQgdG9fc3RyaW5nIHggPVxuICB2YWxpZF9mbG9hdF9sZXhlbVxuICAgIChsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVnXCIgeCBpblxuICAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN2dcIiB4KVxuOztcblxubGV0IG1heF92YWx1ZSA9IGluZmluaXR5XG5sZXQgbWluX3ZhbHVlID0gbmVnX2luZmluaXR5XG5sZXQgbWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDc0LlxubGV0IG1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTAyMi5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IHBpID0gMHgzLjI0M0Y2QTg4ODVBMzA4RDMxMzE5OEEyRTAzNzA3M1xubGV0IHNxcnRfcGkgPSAweDEuQzVCRjg5MUI0RUY2QUE3OUMzQjA1MjBENURCOTM4XG5sZXQgc3FydF8ycGkgPSAweDIuODFCMjYzRkVDNEUwQjJDQUY5NDgzRjVDRTQ1OURDXG5sZXQgZXVsZXIgPSAweDAuOTNDNDY3RTM3REIwQzdBNEQxQkUzRjgxMDE1MkNCXG5sZXQgb2ZfaW50ID0gSW50LnRvX2Zsb2F0XG5sZXQgdG9faW50ID0gSW50Lm9mX2Zsb2F0XG5sZXQgb2ZfaW50NjMgaSA9IEludDYzLnRvX2Zsb2F0IGlcbmxldCBvZl9pbnQ2NCBpID0gQ2FtbC5JbnQ2NC50b19mbG9hdCBpXG5sZXQgdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX2Zsb2F0XG5sZXQgaXJvdW5kX2xib3VuZCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnQgSW50Lm51bV9iaXRzXG5sZXQgaXJvdW5kX3Vib3VuZCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnQgSW50Lm51bV9iaXRzXG5cbigqIFRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgXCJleG5cIiByb3VuZGluZyBmdW5jdGlvbnMgaXMgaW1wb3J0YW50LCBzbyB0aGV5IGFyZSB3cml0dGVuXG4gICBvdXQgc2VwYXJhdGVseSwgYW5kIHR1bmVkIGluZGl2aWR1YWxseS4gIChXZSBjb3VsZCBoYXZlIHRoZSBvcHRpb24gdmVyc2lvbnMgY2FsbFxuICAgdGhlIFwiZXhuXCIgdmVyc2lvbnMsIGJ1dCB0aGF0IGltcG9zZXMgYXJndWFibHkgZ3JhdHVpdG91cyBvdmVyaGVhZC0tLWVzcGVjaWFsbHlcbiAgIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBjYXB0dXJlIG9mIGJhY2t0cmFjZXMgaXMgZW5hYmxlZCB1cG9uIFwid2l0aFwiLS0tYW5kIHRoYXQgc2VlbXNcbiAgIG5vdCB3b3J0aCBpdCB3aGVuIGNvbXBhcmVkIHRvIHRoZSByZWxhdGl2ZWx5IHNtYWxsIGFtb3VudCBvZiBjb2RlIGR1cGxpY2F0aW9uLikgKilcblxuKCogRXJyb3IgcmVwb3J0aW5nIGJlbG93IGlzIHZlcnkgY2FyZWZ1bGx5IGFycmFuZ2VkIHNvIHRoYXQsIGUuZy4sIFtpcm91bmRfbmVhcmVzdF9leG5dXG4gICBpdHNlbGYgY2FuIGJlIGlubGluZWQgaW50byBjYWxsZXJzIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYSBib3ggZm9yIHRoZVxuICAgW2Zsb2F0XSBhcmd1bWVudC4gIFRoaXMgaXMgZG9uZSB3aXRoIGEgYm94IFtib3hdIGZ1bmN0aW9uIGNhcmVmdWxseSBjaG9zZW4gdG8gYWxsb3cgdGhlXG4gICBjb21waWxlciB0byBjcmVhdGUgYSBzZXBhcmF0ZSBib3ggZm9yIHRoZSBmbG9hdCBvbmx5IGluIGVycm9yIGNhc2VzLiAgU2VlLCBlLmcuLFxuICAgWy4uLy4uL3plcm8vdGVzdC9wcmljZV90ZXN0Lm1sXSBmb3IgYSBtZWNoYW5pY2FsIHRlc3Qgb2YgdGhpcyBwcm9wZXJ0eSB3aGVuIGJ1aWxkaW5nXG4gICB3aXRoIFtYX0xJQlJBUllfSU5MSU5JTkc9dHJ1ZV0uICopXG5cbmxldCBpcm91bmRfdXAgdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpXG47O1xuXG5sZXQgaXJvdW5kX2Rvd24gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW4gaWYgdCA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KSBlbHNlIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldCBpcm91bmRfdG93YXJkc196ZXJvIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3Rvd2FyZHNfemVyb19leG4gdCA9XG4gIGlmIHQgPj0gaXJvdW5kX2xib3VuZCAmJiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pcm91bmRfdG93YXJkc196ZXJvX2V4bjogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChib3ggdClcbiAgICAgICgpXG47O1xuXG4oKiBPdXRzaWRlIG9mIHRoZSByYW5nZSAocm91bmRfbmVhcmVzdF9sYi4ucm91bmRfbmVhcmVzdF91YiksIGFsbCByZXByZXNlbnRhYmxlIGRvdWJsZXNcbiAgIGFyZSBpbnRlZ2VycyBpbiB0aGUgbWF0aGVtYXRpY2FsIHNlbnNlLCBhbmQgW3JvdW5kX25lYXJlc3RdIHNob3VsZCBiZSBpZGVudGl0eS5cblxuICAgSG93ZXZlciwgZm9yIG9kZCBudW1iZXJzIHdpdGggdGhlIGFic29sdXRlIHZhbHVlIGJldHdlZW4gMioqNTIgYW5kIDIqKjUzLCB0aGUgZm9ybXVsYVxuICAgW3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsgMC41KV0gZG9lcyBub3QgaG9sZDpcblxuICAge3ZcbiAgICAgIyBsZXQgbmFpdmVfcm91bmRfbmVhcmVzdCB4ID0gZmxvb3IgKHggKy4gMC41KTs7XG4gICAgICMgbGV0IHggPSAyLiAqKiA1Mi4gKy4gMS47O1xuICAgICB2YWwgeCA6IGZsb2F0ID0gNDUwMzU5OTYyNzM3MDQ5Ny5cbiAgICAgIyBuYWl2ZV9yb3VuZF9uZWFyZXN0IHg7O1xuICAgICAtIDogICAgIGZsb2F0ID0gNDUwMzU5OTYyNzM3MDQ5OC5cbiAgIHZ9XG4qKVxuXG5sZXQgcm91bmRfbmVhcmVzdF9sYiA9IC0uKDIuICoqIDUyLilcbmxldCByb3VuZF9uZWFyZXN0X3ViID0gMi4gKiogNTIuXG5cbigqIEZvciBbeCA9IG9uZV91bHAgYERvd24gMC41XSwgdGhlIGZvcm11bGEgW2Zsb29yICh4ICsuIDAuNSldIGZvciByb3VuZGluZyB0byBuZWFyZXN0XG4gICBkb2VzIG5vdCB3b3JrLCBiZWNhdXNlIHRoZSBleGFjdCByZXN1bHQgaXMgaGFsZndheSBiZXR3ZWVuIFtvbmVfdWxwIGBEb3duIDEuXSBhbmQgWzEuXSxcbiAgIGFuZCBpdCBnZXRzIHJvdW5kZWQgdXAgdG8gWzEuXSBkdWUgdG8gdGhlIHJvdW5kLXRpZXMtdG8tZXZlbiBydWxlLiAqKVxubGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwIGBEb3duIDAuNVxuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgPVxuICB0XG4gICsuXG4gIGlmIHQgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIHRoZW4gb25lX3VscF9sZXNzX3RoYW5faGFsZiAoKiBzaW5jZSB0IDwgMC41LCBtYWtlIHN1cmUgdGhlIHJlc3VsdCBpcyA8IDEuMCAqKVxuICBlbHNlIDAuNVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0XzMyIHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciAodCArLiAwLjUpIGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF82NCB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuXG4gICAgaWYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpKVxuICAgIGVsc2UgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gICAgZWxzZSBOb25lXG4gIGVsc2UgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGJcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChmbG9vciAodCArLiAwLjUpKSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0ID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGlyb3VuZF9uZWFyZXN0XzY0XG4gIHwgVzMyIC0+IGlyb3VuZF9uZWFyZXN0XzMyXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfZXhuXzMyIHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGxcIiAoYm94IHQpICgpKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfbmVhcmVzdF9leG5fNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KVxuICAgIGVsc2UgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpXG4gIGVsc2UgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGJcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChmbG9vciAodCArLiAwLjUpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfZXhuID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGlyb3VuZF9uZWFyZXN0X2V4bl82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF9leG5fMzJcbjs7XG5cbigqIFRoZSBmb2xsb3dpbmcgW2lyb3VuZF9leG5dIGFuZCBbaXJvdW5kXSBmdW5jdGlvbnMgYXJlIHNsb3dlciB0aGFuIHRoZSBvbmVzIGFib3ZlLlxuICAgVGhlaXIgZXF1aXZhbGVuY2UgdG8gdGhvc2UgZnVuY3Rpb25zIGlzIHRlc3RlZCBpbiB0aGUgdW5pdCB0ZXN0cyBiZWxvdy4gKilcblxubGV0W0BpbmxpbmVdIGlyb3VuZF9leG4gPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIG1hdGNoIGRpciB3aXRoXG4gIHwgYFplcm8gLT4gaXJvdW5kX3Rvd2FyZHNfemVyb19leG4gdFxuICB8IGBOZWFyZXN0IC0+IGlyb3VuZF9uZWFyZXN0X2V4biB0XG4gIHwgYFVwIC0+IGlyb3VuZF91cF9leG4gdFxuICB8IGBEb3duIC0+IGlyb3VuZF9kb3duX2V4biB0XG47O1xuXG5sZXQgaXJvdW5kID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICB0cnkgU29tZSAoaXJvdW5kX2V4biB+ZGlyIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCBpc19pbmYgdCA9IDEuIC8uIHQgPSAwLlxubGV0IGlzX2Zpbml0ZSB0ID0gdCAtLiB0ID0gMC5cblxubGV0IG1pbl9pbmFuICh4IDogdCkgeSA9XG4gIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHlcbjs7XG5cbmxldCBtYXhfaW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgYWRkID0gKCArLiApXG5sZXQgc3ViID0gKCAtLiApXG5sZXQgbmVnID0gKCB+LS4gKVxubGV0IGFicyA9IGFic19mbG9hdFxubGV0IHNjYWxlID0gKCAqLiApXG5sZXQgc3F1YXJlIHggPSB4ICouIHhcblxubW9kdWxlIFBhcnRzIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBmcmFjdGlvbmFsIDogdCAtPiBmbG9hdFxuICB2YWwgaW50ZWdyYWwgOiB0IC0+IGZsb2F0XG4gIHZhbCBtb2RmIDogZmxvYXQgLT4gdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0ICogZmxvYXRcblxuICBsZXQgZnJhY3Rpb25hbCB0ID0gZnN0IHRcbiAgbGV0IGludGVncmFsIHQgPSBzbmQgdFxuICBsZXQgbW9kZiA9IG1vZGZcbmVuZFxuXG5sZXQgbW9kZiA9IFBhcnRzLm1vZGZcbmxldCByb3VuZF9kb3duID0gZmxvb3JcbmxldCByb3VuZF91cCA9IGNlaWxcbmxldCByb3VuZF90b3dhcmRzX3plcm8gdCA9IGlmIHQgPj0gMC4gdGhlbiByb3VuZF9kb3duIHQgZWxzZSByb3VuZF91cCB0XG5cbigqIHNlZSB0aGUgY29tbWVudCBhYm92ZSBbcm91bmRfbmVhcmVzdF9sYl0gYW5kIFtyb3VuZF9uZWFyZXN0X3ViXSBmb3IgYW4gZXhwbGFuYXRpb24gKilcbmxldFtAb2NhbWwuaW5saW5lXSByb3VuZF9uZWFyZXN0X2lubGluZSB0ID1cbiAgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGIgJiYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiBmbG9vciAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgZWxzZSB0ICsuIDAuXG47O1xuXG5sZXQgcm91bmRfbmVhcmVzdCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0XG5cbmxldCByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiB0ID1cbiAgaWYgdCA8PSByb3VuZF9uZWFyZXN0X2xiIHx8IHQgPj0gcm91bmRfbmVhcmVzdF91YlxuICB0aGVuIHQgKy4gMC5cbiAgZWxzZSAoXG4gICAgbGV0IGZsb29yID0gZmxvb3IgdCBpblxuICAgICgqIFtjZWlsX29yX3N1Y2MgPSBpZiB0IGlzIGFuIGludGVnZXIgdGhlbiB0ICsuIDEuIGVsc2UgY2VpbCB0XS4gIEZhc3RlciB0aGFuIFtjZWlsXS4gKilcbiAgICBsZXQgY2VpbF9vcl9zdWNjID0gZmxvb3IgKy4gMS4gaW5cbiAgICBsZXQgZGlmZl9mbG9vciA9IHQgLS4gZmxvb3IgaW5cbiAgICBsZXQgZGlmZl9jZWlsID0gY2VpbF9vcl9zdWNjIC0uIHQgaW5cbiAgICBpZiBkaWZmX2Zsb29yIDwgZGlmZl9jZWlsXG4gICAgdGhlbiBmbG9vclxuICAgIGVsc2UgaWYgZGlmZl9mbG9vciA+IGRpZmZfY2VpbFxuICAgIHRoZW4gY2VpbF9vcl9zdWNjXG4gICAgZWxzZSBpZiAoKiBleGFjdCB0aWUsIHBpY2sgdGhlIGV2ZW4gKilcbiAgICAgIG1vZF9mbG9hdCBmbG9vciAyLiA9IDAuXG4gICAgdGhlbiBmbG9vclxuICAgIGVsc2UgY2VpbF9vcl9zdWNjKVxuOztcblxubGV0IGludDYzX3JvdW5kX2xib3VuZCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnQgSW50NjMubnVtX2JpdHNcbmxldCBpbnQ2M19yb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5cbmxldCBpbnQ2M19yb3VuZF91cF9leG4gdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKCkpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IGludDYzX3JvdW5kX2Rvd25fZXhuIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuXG4gICAgaWYgdCA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGludDYzX3JvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuOztcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuIHQwID1cbiAgbGV0IHQgPSAocm91bmRfbmVhcmVzdF9pbmxpbmUgW0BvY2FtbC5pbmxpbmVkIGFsd2F5c10pIHQwIGluXG4gIGlmIHQgPiAwLlxuICB0aGVuXG4gICAgaWYgdCA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKGJveCB0MClcbiAgICAgICAgKClcbiAgZWxzZSBpZiB0ID49IGludDYzX3JvdW5kX2xib3VuZFxuICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoYm94IHQwKVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biBmID0gSW50NjMub2ZfaW50IChpcm91bmRfbmVhcmVzdF9leG4gZilcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfZXhuID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIHwgVzMyIC0+IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG47O1xuXG5sZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIG1hdGNoIGRpciB3aXRoXG4gIHwgYE5lYXJlc3QgLT4gcm91bmRfbmVhcmVzdCB0XG4gIHwgYERvd24gLT4gcm91bmRfZG93biB0XG4gIHwgYFVwIC0+IHJvdW5kX3VwIHRcbiAgfCBgWmVybyAtPiByb3VuZF90b3dhcmRzX3plcm8gdFxuOztcblxubW9kdWxlIENsYXNzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBJbmZpbml0ZVxuICAgIHwgTmFuXG4gICAgfCBOb3JtYWxcbiAgICB8IFN1Ym5vcm1hbFxuICAgIHwgWmVyb1xuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgSW5maW5pdGU7IE5hbjsgTm9ybWFsOyBTdWJub3JtYWw7IFplcm8gXSA6IHQgbGlzdClcblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDA2XyA9IFwiZmxvYXQubWwuQ2xhc3MudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIC0+IEluZmluaXRlXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgLT4gTm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgLT4gU3Vibm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgIHwgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBJbmZpbml0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmZpbml0ZVwiXG4gICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICAgfCBOb3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTm9ybWFsXCJcbiAgICAgIHwgU3Vibm9ybWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlN1Ym5vcm1hbFwiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJJbmZpbml0ZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlN1Ym5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuZW5kXG5cbmxldCBjbGFzc2lmeSB0ID1cbiAgbGV0IG1vZHVsZSBDID0gQ2xhc3MgaW5cbiAgbWF0Y2ggY2xhc3NpZnlfZmxvYXQgdCB3aXRoXG4gIHwgRlBfbm9ybWFsIC0+IEMuTm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsIC0+IEMuU3Vibm9ybWFsXG4gIHwgRlBfemVybyAtPiBDLlplcm9cbiAgfCBGUF9pbmZpbml0ZSAtPiBDLkluZmluaXRlXG4gIHwgRlBfbmFuIC0+IEMuTmFuXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzID8oZGVsaW1pdGVyID0gJ18nKSA/KHN0cmlwX3plcm8gPSBmYWxzZSkgc3RyaW5nID1cbiAgbWF0Y2ggU3RyaW5nLmxzcGxpdDIgc3RyaW5nIH5vbjonLicgd2l0aFxuICB8IE5vbmUgLT4gSW50X2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgc3RyaW5nIH5kZWxpbWl0ZXJcbiAgfCBTb21lIChsZWZ0LCByaWdodCkgLT5cbiAgICBsZXQgbGVmdCA9IEludF9jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIGxlZnQgfmRlbGltaXRlciBpblxuICAgIGxldCByaWdodCA9XG4gICAgICBpZiBzdHJpcF96ZXJvIHRoZW4gU3RyaW5nLnJzdHJpcCByaWdodCB+ZHJvcDooZnVuIGMgLT4gQ2hhci4oID0gKSBjICcwJykgZWxzZSByaWdodFxuICAgIGluXG4gICAgKG1hdGNoIHJpZ2h0IHdpdGhcbiAgICAgfCBcIlwiIC0+IGxlZnRcbiAgICAgfCBfIC0+IGxlZnQgXiBcIi5cIiBeIHJpZ2h0KVxuOztcblxubGV0IHRvX3N0cmluZ19odW0gP2RlbGltaXRlciA/KGRlY2ltYWxzID0gMykgP3N0cmlwX3plcm8gPyhleHBsaWNpdF9wbHVzID0gZmFsc2UpIGYgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGRlY2ltYWxzIDBcbiAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJ0b19zdHJpbmdfaHVtOiBpbnZhbGlkIGFyZ3VtZW50IH5kZWNpbWFscz0lZFwiIGRlY2ltYWxzICgpO1xuICBtYXRjaCBjbGFzc2lmeSBmIHdpdGhcbiAgfCBDbGFzcy5JbmZpbml0ZSAtPiBpZiBmID4gMC4gdGhlbiBcImluZlwiIGVsc2UgXCItaW5mXCJcbiAgfCBDbGFzcy5OYW4gLT4gXCJuYW5cIlxuICB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgcyA9XG4gICAgICBpZiBleHBsaWNpdF9wbHVzIHRoZW4gc3ByaW50ZiBcIiUrLipmXCIgZGVjaW1hbHMgZiBlbHNlIHNwcmludGYgXCIlLipmXCIgZGVjaW1hbHMgZlxuICAgIGluXG4gICAgaW5zZXJ0X3VuZGVyc2NvcmVzIHMgP2RlbGltaXRlciA/c3RyaXBfemVyb1xuOztcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgbGV0IHNleHAgPSBzZXhwX29mX3QgdCBpblxuICBtYXRjaCAhU2V4cC5vZl9mbG9hdF9zdHlsZSB3aXRoXG4gIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHNleHBcbiAgfCBgVW5kZXJzY29yZXMgLT5cbiAgICAobWF0Y2ggc2V4cCB3aXRoXG4gICAgIHwgTGlzdCBfIC0+XG4gICAgICAgcmFpc2Vfc1xuICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgXCJbc2V4cF9vZl9mbG9hdF0gcHJvZHVjZWQgc3RyYW5nZSBzZXhwXCJcbiAgICAgICAgICAgIFsgXCJzZXhwXCIsIFNleHAuc2V4cF9vZl90IHNleHAgXSlcbiAgICAgfCBBdG9tIHN0cmluZyAtPlxuICAgICAgIGlmIFN0cmluZy5jb250YWlucyBzdHJpbmcgJ0UnIHRoZW4gc2V4cCBlbHNlIEF0b20gKGluc2VydF91bmRlcnNjb3JlcyBzdHJpbmcpKVxuOztcblxubGV0IHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCA/KHByZWZpeCA9IFwiXCIpIH5raWxvIH5tZWdhIH5naWdhIH50ZXJhID9wZXRhICgpID1cbiAgKCogUm91bmQgYSByYXRpbyB0b3dhcmQgdGhlIG5lYXJlc3QgaW50ZWdlciwgcmVzb2x2aW5nIHRpZXMgdG93YXJkIHRoZSBuZWFyZXN0IGV2ZW5cbiAgICAgbnVtYmVyLiAgRm9yIHNhbmUgaW5wdXRzIChpbiBwYXJ0aWN1bGFyLCB3aGVuIFtkZW5vbWluYXRvcl0gaXMgYW4gaW50ZWdlciBhbmRcbiAgICAgW2FicyBudW1lcmF0b3IgPCAyZTUyXSkgdGhpcyBzaG91bGQgYmUgYWNjdXJhdGUuICBPdGhlcndpc2UsIHRoZSByZXN1bHQgbWlnaHQgYmUgYVxuICAgICBsaXR0bGUgYml0IG9mZiwgYnV0IHdlIGRvbid0IHJlYWxseSB1c2UgdGhhdCBjYXNlLiAqKVxuICBsZXQgaXJvdW5kX3JhdGlvX2V4biB+bnVtZXJhdG9yIH5kZW5vbWluYXRvciA9XG4gICAgbGV0IGsgPSBmbG9vciAobnVtZXJhdG9yIC8uIGRlbm9taW5hdG9yKSBpblxuICAgICgqIGlmIFthYnMgayA8IDJlNTNdLCB0aGVuIGJvdGggW2tdIGFuZCBbayArLiAxLl0gYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGFuZCBpblxuICAgICAgIHBhcnRpY3VsYXIgW2sgKy4gMS4gPiBrXS4gIElmIFtkZW5vbWluYXRvcl0gaXMgYWxzbyBhbiBpbnRlZ2VyLCBhbmRcbiAgICAgICBbYWJzIChkZW5vbWluYXRvciAqLiAoayArLiAxKSkgPCAyZTUzXSAoYW5kIGluIHNvbWUgb3RoZXIgY2FzZXMsIHRvbyksIHRoZW4gW2xvd2VyXVxuICAgICAgIGFuZCBbaGlnaGVyXSBhcmUgYWN0dWFsbHkgYm90aCBhY2N1cmF0ZS4gIFNpbmNlIChyb3VnaGx5KVxuICAgICAgIFtudW1lcmF0b3IgPSBkZW5vbWluYXRvciAqLiBrXSB0aGVuIGZvciBbYWJzIG51bWVyYXRvciA8IDJlNTJdIHdlIHNob3VsZCBiZVxuICAgICAgIGZpbmUuICopXG4gICAgbGV0IGxvd2VyID0gZGVub21pbmF0b3IgKi4gayBpblxuICAgIGxldCBoaWdoZXIgPSBkZW5vbWluYXRvciAqLiAoayArLiAxLikgaW5cbiAgICAoKiBTdWJ0cmFjdGluZyBudW1iZXJzIHdpdGhpbiBhIGZhY3RvciBvZiB0d28gZnJvbSBlYWNoIG90aGVyIGlzIGFjY3VyYXRlLlxuICAgICAgIFNvIGVpdGhlciB0aGUgdHdvIHN1YnRyYWN0aW9ucyBiZWxvdyBhcmUgYWNjdXJhdGUsIG9yIGsgPSAwLCBvciBrID0gLTEuXG4gICAgICAgSW4gY2FzZSBvZiBhIHRpZSwgcm91bmQgdG8gZXZlbi4gKilcbiAgICBsZXQgZGlmZl9yaWdodCA9IGhpZ2hlciAtLiBudW1lcmF0b3IgaW5cbiAgICBsZXQgZGlmZl9sZWZ0ID0gbnVtZXJhdG9yIC0uIGxvd2VyIGluXG4gICAgbGV0IGsgPSBpcm91bmRfbmVhcmVzdF9leG4gayBpblxuICAgIGlmIGRpZmZfcmlnaHQgPCBkaWZmX2xlZnRcbiAgICB0aGVuIGsgKyAxXG4gICAgZWxzZSBpZiBkaWZmX3JpZ2h0ID4gZGlmZl9sZWZ0XG4gICAgdGhlbiBrXG4gICAgZWxzZSBpZiAoKiBhIHRpZSAqKVxuICAgICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoayBtb2QgMikgMFxuICAgIHRoZW4ga1xuICAgIGVsc2UgayArIDFcbiAgaW5cbiAgbWF0Y2ggY2xhc3NpZnkgdCB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgdCA8IDAuMCB0aGVuIFwiLWluZiAgXCIgZWxzZSBcImluZiAgXCJcbiAgfCBDbGFzcy5OYW4gLT4gXCJuYW4gIFwiXG4gIHwgQ2xhc3MuU3Vibm9ybWFsIHwgQ2xhc3MuTm9ybWFsIHwgQ2xhc3MuWmVybyAtPlxuICAgIGxldCBnbyB0ID1cbiAgICAgIGxldCBjb252X29uZSB0ID1cbiAgICAgICAgYXNzZXJ0ICgwLiA8PSB0ICYmIHQgPCA5OTkuOTUpO1xuICAgICAgICBsZXQgeCA9IHByZWZpeCBeIGZvcm1hdF9mbG9hdCBcIiUuMWZcIiB0IGluXG4gICAgICAgICgqIEZpeCB0aGUgXCIuMFwiIHN1ZmZpeCAqKVxuICAgICAgICBpZiBTdHJpbmcuaXNfc3VmZml4IHggfnN1ZmZpeDpcIi4wXCJcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHggPSBCeXRlcy5vZl9zdHJpbmcgeCBpblxuICAgICAgICAgIGxldCBuID0gQnl0ZXMubGVuZ3RoIHggaW5cbiAgICAgICAgICBCeXRlcy5zZXQgeCAobiAtIDEpICcgJztcbiAgICAgICAgICBCeXRlcy5zZXQgeCAobiAtIDIpICcgJztcbiAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOngpXG4gICAgICAgIGVsc2UgeFxuICAgICAgaW5cbiAgICAgIGxldCBjb252IG1hZyB0IGRlbm9taW5hdG9yID1cbiAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAoZGVub21pbmF0b3IgPSAxMDAuICYmIHQgPj0gOTk5Ljk1KVxuICAgICAgICAgIHx8IChkZW5vbWluYXRvciA+PSAxMDBfMDAwLiAmJiB0ID49IHJvdW5kX25lYXJlc3QgKGRlbm9taW5hdG9yICouIDkuOTk5XzUpKSk7XG4gICAgICAgIGFzc2VydCAodCA8IHJvdW5kX25lYXJlc3QgKGRlbm9taW5hdG9yICouIDlfOTk5LjUpKTtcbiAgICAgICAgbGV0IGksIGQgPVxuICAgICAgICAgIGxldCBrID0gaXJvdW5kX3JhdGlvX2V4biB+bnVtZXJhdG9yOnQgfmRlbm9taW5hdG9yIGluXG4gICAgICAgICAgKCogW21vZF0gaXMgb2theSBoZXJlIGJlY2F1c2Ugd2Uga25vdyBpID49IDAuICopXG4gICAgICAgICAgayAvIDEwLCBrIG1vZCAxMFxuICAgICAgICBpblxuICAgICAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgICAgIGFzc2VydCAoMCA8PSBpICYmIGkgPCAxMDAwKTtcbiAgICAgICAgYXNzZXJ0ICgwIDw9IGQgJiYgZCA8IDEwKTtcbiAgICAgICAgaWYgZCA9IDBcbiAgICAgICAgdGhlbiBzcHJpbnRmIFwiJXMlZCVzIFwiIHByZWZpeCBpIG1hZ1xuICAgICAgICBlbHNlIHNwcmludGYgXCIlcyVkJXMlZFwiIHByZWZpeCBpIG1hZyBkXG4gICAgICBpblxuICAgICAgKCogV2hpbGUgdGhlIHN0YW5kYXJkIG1ldHJpYyBwcmVmaXhlcyAoZS5nLiBjYXBpdGFsIFwiTVwiIHJhdGhlciB0aGFuIFwibVwiLCBbMV0pIGFyZVxuICAgICAgICAgbm9taW5hbGx5IG1vcmUgY29ycmVjdCwgdGhpcyBoaW5kZXJzIHJlYWRhYmlsaXR5IGluIG91ciBjYXNlLiAgRS5nLiwgMTBHNiBhbmRcbiAgICAgICAgIDEwNjYgbG9vayB0b28gc2ltaWxhci4gIFRoYXQncyBhbiBleHRyZW1lIGV4YW1wbGUsIGJ1dCBpbiBnZW5lcmFsIGssbSxnLHQscFxuICAgICAgICAgcHJvYmFibHkgc3RhbmQgb3V0IGJldHRlciB0aGFuIEssTSxHLFQsUCB3aGVuIGludGVyc3BlcnNlZCB3aXRoIGRpZ2l0cy5cblxuICAgICAgICAgWzFdIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWV0cmljX3ByZWZpeCAqKVxuICAgICAgKCogVGhlIHRyaWNrIGhlcmUgaXMgdGhhdDpcbiAgICAgICAgIC0gdGhlIGZpcnN0IGJvdW5kYXJ5ICg5OTkuOTUpIGFzIGEgZmxvYXQgaXMgc2xpZ2h0bHkgb3Zlci1yZXByZXNlbnRlZCAoc28gaXQgaXNcbiAgICAgICAgICAgYmV0dGVyIGFwcHJveGltYXRlZCBhcyBcIjFrXCIgdGhhbiBhcyBcIjk5OS45XCIpLFxuICAgICAgICAgLSB0aGUgb3RoZXIgYm91bmRhcmllcyBhcmUgYWNjdXJhdGVseSByZXByZXNlbnRlZCwgYmVjYXVzZSB0aGV5IGFyZSBpbnRlZ2Vycy5cbiAgICAgICAgICAgVGhhdCdzIHdoeSB0aGUgc3RyaWN0IGVxdWFsaXRpZXMgYmVsb3cgZG8gZXhhY3RseSB3aGF0IHdlIHdhbnQuICopXG4gICAgICBpZiB0IDwgOTk5Ljk1RTBcbiAgICAgIHRoZW4gY29udl9vbmUgdFxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTNcbiAgICAgIHRoZW4gY29udiBraWxvIHQgMTAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTZcbiAgICAgIHRoZW4gY29udiBtZWdhIHQgMTAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU5XG4gICAgICB0aGVuIGNvbnYgZ2lnYSB0IDEwMF8wMDBfMDAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTEyXG4gICAgICB0aGVuIGNvbnYgdGVyYSB0IDEwMF8wMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBwZXRhIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHNwcmludGYgXCIlcyUuMWVcIiBwcmVmaXggdFxuICAgICAgICB8IFNvbWUgcGV0YSAtPlxuICAgICAgICAgIGlmIHQgPCA5OTkuOTVFMTVcbiAgICAgICAgICB0aGVuIGNvbnYgcGV0YSB0IDEwMF8wMDBfMDAwXzAwMF8wMDAuXG4gICAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHQpXG4gICAgaW5cbiAgICBpZiB0ID49IDAuIHRoZW4gZ28gdCBlbHNlIFwiLVwiIF4gZ28gfi0udFxuOztcblxubGV0IHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZyB0ID1cbiAgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvbSB0IH5raWxvOlwia1wiIH5tZWdhOlwibVwiIH5naWdhOlwiZ1wiIH50ZXJhOlwidFwiIH5wZXRhOlwicFwiICgpXG47O1xuXG4oKiBQZXJmb3JtYW5jZSBub3RlOiBJbml0aWFsaXppbmcgdGhlIGFjY3VtdWxhdG9yIHRvIDEgcmVzdWx0cyBpbiBvbmUgZXh0cmFcbiAgIG11bHRpcGx5OyBlLmcuLCB0byBjb21wdXRlIHggKiogNCwgd2UgaW4gcHJpbmNpcGxlIG9ubHkgbmVlZCAyIG11bHRpcGxpZXMsXG4gICBidXQgdGhpcyBmdW5jdGlvbiB3aWxsIGhhdmUgMyBtdWx0aXBsaWVzLiAgSG93ZXZlciwgYXR0ZW1wdHMgdG8gYXZvaWQgdGhpc1xuICAgKGxpa2UgZGVjcmVtZW50aW5nIG4gYW5kIGluaXRpYWxpemluZyBhY2N1bSB0byBiZSB4LCBvciBoYW5kbGluZyBzbWFsbFxuICAgZXhwb25lbnRzIGFzIGEgc3BlY2lhbCBjYXNlKSBoYXZlIG5vdCB5aWVsZGVkIGFueXRoaW5nIHRoYXQgaXMgYSBuZXRcbiAgIGltcHJvdmVtZW50LlxuKilcbmxldCBpbnRfcG93IHggbiA9XG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAxLlxuICBlbHNlIChcbiAgICAoKiBVc2luZyBbeCArLiAoLTAuKV0gb24gdGhlIGZvbGxvd2luZyBsaW5lIGNvbnZpbmNlcyB0aGUgY29tcGlsZXIgdG8gYXZvaWQgYSBjZXJ0YWluXG4gICAgICAgYm94aW5nICh0aGF0IHdvdWxkIHJlc3VsdCBpbiBhbGxvY2F0aW9uIGluIGVhY2ggaXRlcmF0aW9uKS4gIFNvb24sIHRoZSBjb21waWxlclxuICAgICAgIHNob3VsZG4ndCBuZWVkIHRoaXMgXCJoaW50XCIgdG8gYXZvaWQgdGhlIGJveGluZy4gIFRoZSByZWFzb24gd2UgYWRkIC0wIHJhdGhlciB0aGFuIDBcbiAgICAgICBpcyB0aGF0IFt4ICsuICgtMC4pXSBpcyBhcHBhcmVudGx5IGFsd2F5cyB0aGUgc2FtZSBhcyBbeF0sIHdoZXJlYXMgW3ggKy4gMC5dIGlzXG4gICAgICAgbm90LCBpbiB0aGF0IGl0IHNlbmRzIFstMC5dIHRvIFswLl0uICBUaGlzIG1ha2VzIGEgZGlmZmVyZW5jZSBiZWNhdXNlIHdlIHdhbnRcbiAgICAgICBbaW50X3BvdyAoLTAuKSAoLTEpXSB0byByZXR1cm4gbmVnX2luZmluaXR5IGp1c3QgbGlrZSBbLTAuICoqIC0xLl0gd291bGQuICAqKVxuICAgIGxldCB4ID0gcmVmICh4ICsuIC0wLikgaW5cbiAgICBsZXQgbiA9IHJlZiBuIGluXG4gICAgbGV0IGFjY3VtID0gcmVmIDEuIGluXG4gICAgaWYgIW4gPCAwXG4gICAgdGhlbiAoXG4gICAgICAoKiB4ICoqIG4gPSAoMS94KSAqKiAtbiAqKVxuICAgICAgeCA6PSAxLiAvLiAheDtcbiAgICAgIG4gOj0gfi0gKCFuKTtcbiAgICAgIGlmICFuIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgICgqIG4gbXVzdCBoYXZlIGJlZW4gbWluX2ludCwgc28gaXQgaXMgbm93IHNvIGJpZyB0aGF0IGl0IGhhcyB3cmFwcGVkIGFyb3VuZC5cbiAgICAgICAgICAgV2UgZGVjcmVtZW50IGl0IHNvIHRoYXQgaXQgbG9va3MgcG9zaXRpdmUgYWdhaW4sIGJ1dCBhY2NvcmRpbmdseSBoYXZlXG4gICAgICAgICAgIHRvIHB1dCBhbiBleHRyYSBmYWN0b3Igb2YgeCBpbiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICAgICopXG4gICAgICAgIGFjY3VtIDo9ICF4O1xuICAgICAgICBkZWNyIG4pKTtcbiAgICAoKiBMZXR0aW5nIFthXSBkZW5vdGUgKHRoZSBvcmlnaW5hbCB2YWx1ZSBvZikgW3ggKiogbl0sIHdlIG1haW50YWluXG4gICAgICAgdGhlIGludmFyaWFudCB0aGF0IFsoeCAqKiBuKSAqLiBhY2N1bSA9IGFdLiAqKVxuICAgIHdoaWxlICFuID4gMSBkb1xuICAgICAgaWYgIW4gbGFuZCAxIDw+IDAgdGhlbiBhY2N1bSA6PSAheCAqLiAhYWNjdW07XG4gICAgICB4IDo9ICF4ICouICF4O1xuICAgICAgbiA6PSAhbiBsc3IgMVxuICAgIGRvbmU7XG4gICAgKCogbiBpcyBuZWNlc3NhcmlseSAxIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXJlIGlzIG9uZSBhZGRpdGlvbmFsXG4gICAgICAgbXVsdGlwbGljYXRpb24gYnkgeC4gKilcbiAgICAheCAqLiAhYWNjdW0pXG47O1xuXG5sZXQgcm91bmRfZ2VuIHggfmhvdyA9XG4gIGlmIHggPSAwLlxuICB0aGVuIDAuXG4gIGVsc2UgaWYgbm90IChpc19maW5pdGUgeClcbiAgdGhlbiB4XG4gIGVsc2UgKFxuICAgICgqIFNpZ25pZmljYW50IGRpZ2l0cyBhbmQgZGVjaW1hbCBkaWdpdHMuICopXG4gICAgbGV0IHNkLCBkZCA9XG4gICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgfCBgc2lnbmlmaWNhbnRfZGlnaXRzIHNkIC0+XG4gICAgICAgIGxldCBkZCA9IHNkIC0gdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgICAgfCBgZGVjaW1hbF9kaWdpdHMgZGQgLT5cbiAgICAgICAgbGV0IHNkID0gZGQgKyB0b19pbnQgKHJvdW5kX3VwIChsb2cxMCAoYWJzIHgpKSkgaW5cbiAgICAgICAgc2QsIGRkXG4gICAgaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgc2QgPCAwXG4gICAgdGhlbiAwLlxuICAgIGVsc2UgaWYgc2QgPj0gMTdcbiAgICB0aGVuIHhcbiAgICBlbHNlIChcbiAgICAgICgqIENob29zZSB0aGUgb3JkZXIgdGhhdCBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdC4gU21hbGwgcG9zaXRpdmVcbiAgICAgICAgIGludGVnZXJzIGFyZSwgYnV0IHRoZWlyIGludmVyc2VzIGluIG1vc3QgY2FzZXMgYXJlIG5vdC4gKilcbiAgICAgIGxldCBhYnNfZGQgPSBJbnQuYWJzIGRkIGluXG4gICAgICBpZiBhYnNfZGQgPiAyMiB8fCBzZCA+PSAxNlxuICAgICAgKCogMTAqKjIyIGlzIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LCBidXQgMTAqKjIzIGlzIG5vdCwgc28gdXNlIHRoZSBzbG93XG4gICAgICAgICBwYXRoLiAgU2ltaWxhcmx5LCBpZiB3ZSBuZWVkIDE2IHNpZ25pZmljYW50IGRpZ2l0cyBpbiB0aGUgcmVzdWx0LCB0aGVuIHRoZSBpbnRlZ2VyXG4gICAgICAgICBbcm91bmRfbmVhcmVzdCAoeCA8b3A+IG9yZGVyKV0gbWlnaHQgbm90IGJlIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LCBzaW5jZVxuICAgICAgICAgZm9yIHNvbWUgcmFuZ2VzIHdlIG9ubHkgaGF2ZSAxNSBkaWdpdHMgb2YgcHJlY2lzaW9uIGd1YXJhbnRlZWQuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgd2UgYXJlIHN0aWxsIHJvdW5kaW5nIHR3aWNlIGhlcmU6XG5cbiAgICAgICAgIDEpIGZpcnN0IHRpbWUgd2hlbiByb3VuZGluZyBbeCAqLiBvcmRlcl0gb3IgW3ggLy4gb3JkZXJdIHRvIHRoZSBuZWFyZXN0IGZsb2F0XG4gICAgICAgICAoanVzdCB0aGUgbm9ybWFsIHdheSBmbG9hdGluZy1wb2ludCBtdWx0aXBsaWNhdGlvbiBvciBkaXZpc2lvbiB3b3JrcyksXG5cbiAgICAgICAgIDIpIHNlY29uZCB0aW1lIHdoZW4gYXBwbHlpbmcgW3JvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuXSB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgYWJvdmUgb3BlcmF0aW9uXG5cbiAgICAgICAgIFNvIGZvciBhcmd1bWVudHMgd2l0aGluIGFuIHVscCBmcm9tIGEgdGllIHdlIG1pZ2h0IHN0aWxsIHByb2R1Y2UgYW4gb2ZmLWJ5LW9uZVxuICAgICAgICAgcmVzdWx0LiAqKVxuICAgICAgdGhlbiBvZl9zdHJpbmcgKHNwcmludGYgXCIlLipnXCIgc2QgeClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgb3JkZXIgPSBpbnRfcG93IDEwLiBhYnNfZGQgaW5cbiAgICAgICAgaWYgZGQgPj0gMFxuICAgICAgICB0aGVuIHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuICh4ICouIG9yZGVyKSAvLiBvcmRlclxuICAgICAgICBlbHNlIHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuICh4IC8uIG9yZGVyKSAqLiBvcmRlcikpKVxuOztcblxubGV0IHJvdW5kX3NpZ25pZmljYW50IHggfnNpZ25pZmljYW50X2RpZ2l0cyA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIHNpZ25pZmljYW50X2RpZ2l0cyAwXG4gIHRoZW5cbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQucm91bmRfc2lnbmlmaWNhbnQ6IGludmFsaWQgYXJndW1lbnQgc2lnbmlmaWNhbnRfZGlnaXRzOiVkXCJcbiAgICAgIHNpZ25pZmljYW50X2RpZ2l0c1xuICAgICAgKClcbiAgZWxzZSByb3VuZF9nZW4geCB+aG93Oihgc2lnbmlmaWNhbnRfZGlnaXRzIHNpZ25pZmljYW50X2RpZ2l0cylcbjs7XG5cbmxldCByb3VuZF9kZWNpbWFsIHggfmRlY2ltYWxfZGlnaXRzID0gcm91bmRfZ2VuIHggfmhvdzooYGRlY2ltYWxfZGlnaXRzIGRlY2ltYWxfZGlnaXRzKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAoKiBBbHNvIGZhaWxzIGlmIFttaW5dIG9yIFttYXhdIGlzIG5hbiAqKVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAoKiBjbGFtcF91bmNoZWNrZWQgaXMgaW4gZmxvYXQwLm1sICopXG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgaWYgbWluIDw9IG1heFxuICB0aGVuIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIGVsc2VcbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG47O1xuXG5sZXQgKCArICkgPSAoICsuIClcbmxldCAoIC0gKSA9ICggLS4gKVxubGV0ICggKiApID0gKCAqLiApXG5sZXQgKCAqKiApID0gKCAqKiApXG5sZXQgKCAvICkgPSAoIC8uIClcbmxldCAoICUgKSA9ICggJS4gKVxubGV0ICggfi0gKSA9ICggfi0uIClcblxubGV0IHNpZ25fZXhuIHQgOiBTaWduLnQgPVxuICBpZiB0ID4gMC5cbiAgdGhlbiBQb3NcbiAgZWxzZSBpZiB0IDwgMC5cbiAgdGhlbiBOZWdcbiAgZWxzZSBpZiB0ID0gMC5cbiAgdGhlbiBaZXJvXG4gIGVsc2UgRXJyb3IucmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiRmxvYXQuc2lnbl9leG4gb2YgTkFOXCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IHNpZ25fb3JfbmFuIHQgOiBTaWduX29yX25hbi50ID1cbiAgaWYgdCA+IDAuIHRoZW4gUG9zIGVsc2UgaWYgdCA8IDAuIHRoZW4gTmVnIGVsc2UgaWYgdCA9IDAuIHRoZW4gWmVybyBlbHNlIE5hblxuOztcblxubGV0IGllZWVfbmVnYXRpdmUgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgUG9seS4oYml0cyA8IENhbWwuSW50NjQuemVybylcbjs7XG5cbmxldCBleHBvbmVudF9iaXRzID0gMTFcbmxldCBtYW50aXNzYV9iaXRzID0gNTJcbmxldCBleHBvbmVudF9tYXNrNjQgPSBJbnQ2NC4oc2hpZnRfbGVmdCBvbmUgZXhwb25lbnRfYml0cyAtIG9uZSlcbmxldCBleHBvbmVudF9tYXNrID0gSW50NjQudG9faW50X2V4biBleHBvbmVudF9tYXNrNjRcbmxldCBtYW50aXNzYV9tYXNrID0gSW50NjMuKHNoaWZ0X2xlZnQgb25lIG1hbnRpc3NhX2JpdHMgLSBvbmUpXG5sZXQgbWFudGlzc2FfbWFzazY0ID0gSW50NjMudG9faW50NjQgbWFudGlzc2FfbWFza1xuXG5sZXQgaWVlZV9leHBvbmVudCB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBJbnQ2NC4oYml0X2FuZCAoc2hpZnRfcmlnaHRfbG9naWNhbCBiaXRzIG1hbnRpc3NhX2JpdHMpIGV4cG9uZW50X21hc2s2NClcbiAgfD4gQ2FtbC5JbnQ2NC50b19pbnRcbjs7XG5cbmxldCBpZWVlX21hbnRpc3NhIHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDYzLm9mX2ludDY0X2V4biBDYW1sLkludDY0Lihsb2dhbmQgYml0cyBtYW50aXNzYV9tYXNrNjQpXG47O1xuXG5sZXQgY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgaWYgSW50LihiaXRfYW5kIGV4cG9uZW50IGV4cG9uZW50X21hc2sgPD4gZXhwb25lbnQpXG4gIHRoZW4gZmFpbHdpdGhmIFwiZXhwb25lbnQgJWQgb3V0IG9mIHJhbmdlIFswLCAlZF1cIiBleHBvbmVudCBleHBvbmVudF9tYXNrICgpXG4gIGVsc2UgaWYgSW50NjMuKGJpdF9hbmQgbWFudGlzc2EgbWFudGlzc2FfbWFzayA8PiBtYW50aXNzYSlcbiAgdGhlblxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJtYW50aXNzYSAlcyBvdXQgb2YgcmFuZ2UgWzAsICVzXVwiXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhKVxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYV9tYXNrKVxuICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHNpZ25fYml0cyA9IGlmIG5lZ2F0aXZlIHRoZW4gQ2FtbC5JbnQ2NC5taW5faW50IGVsc2UgQ2FtbC5JbnQ2NC56ZXJvIGluXG4gICAgbGV0IGV4cHRfYml0cyA9IENhbWwuSW50NjQuc2hpZnRfbGVmdCAoQ2FtbC5JbnQ2NC5vZl9pbnQgZXhwb25lbnQpIG1hbnRpc3NhX2JpdHMgaW5cbiAgICBsZXQgbWFudF9iaXRzID0gSW50NjMudG9faW50NjQgbWFudGlzc2EgaW5cbiAgICBsZXQgYml0cyA9IENhbWwuSW50NjQuKGxvZ29yIHNpZ25fYml0cyAobG9nb3IgZXhwdF9iaXRzIG1hbnRfYml0cykpIGluXG4gICAgQ2FtbC5JbnQ2NC5mbG9hdF9vZl9iaXRzIGJpdHMpXG47O1xuXG5sZXQgY3JlYXRlX2llZWUgfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSlcbjs7XG5cbm1vZHVsZSBUZXJzZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0X29mX3NleHAgPSB0X29mX3NleHBcbiAgbGV0IHRvX3N0cmluZyB4ID0gUHJpbnRmLnNwcmludGYgXCIlLjhHXCIgeFxuICBsZXQgc2V4cF9vZl90IHggPSBTZXhwLkF0b20gKHRvX3N0cmluZyB4KVxuICBsZXQgb2Zfc3RyaW5nIHggPSBvZl9zdHJpbmcgeFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxuKCogVGhlc2UgYXJlIHBhcnRseSBoZXJlIGFzIGEgcGVyZm9ybWFuY2UgaGFjayB0byBhdm9pZCBzb21lIGJveGluZyB3ZSdyZSBnZXR0aW5nIHdpdGhcbiAgIHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXS4gIFRoZXkgYWxzbyBtYWtlIFtGbG9hdC5pc19uZWdhdGl2ZSBuYW5dIGFuZFxuICAgW0Zsb2F0LmlzX25vbl9wb3NpdGl2ZSBuYW5dIHJldHVybiBbZmFsc2VdOyB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10gcmV0dXJuXG4gICBbdHJ1ZV0uICopXG5sZXQgaXNfcG9zaXRpdmUgdCA9IHQgPiAwLlxubGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gdCA+PSAwLlxubGV0IGlzX25lZ2F0aXZlIHQgPSB0IDwgMC5cbmxldCBpc19ub25fcG9zaXRpdmUgdCA9IHQgPD0gMC5cblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRmxvYXRcIlxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgZW5kKVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCAlICkgPSAoICUgKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludCA9IG9mX2ludFxuICBsZXQgb2ZfZmxvYXQgeCA9IHhcbmVuZFxuXG5tb2R1bGUgT19kb3QgPSBzdHJ1Y3RcbiAgbGV0ICggKi4gKSA9ICggKiApXG4gIGxldCAoICsuICkgPSAoICsgKVxuICBsZXQgKCAtLiApID0gKCAtIClcbiAgbGV0ICggLy4gKSA9ICggLyApXG4gIGxldCAoICUuICkgPSAoICUgKVxuICBsZXQgKCB+LS4gKSA9ICggfi0gKVxuICBsZXQgKCAqKi4gKSA9ICggKiogKVxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBib3ggPSBib3hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCA9IGNsYW1wX3VuY2hlY2tlZFxuICBsZXQgbG93ZXJfYm91bmRfZm9yX2ludCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHVwcGVyX2JvdW5kX2Zvcl9pbnQgPSB1cHBlcl9ib3VuZF9mb3JfaW50XG4gIGxldCBzcGVjaWFsaXplZF9oYXNoID0gaGFzaF9mbG9hdFxuICBsZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgbGV0IGlyb3VuZF9uZWFyZXN0X2V4bl82NCA9IGlyb3VuZF9uZWFyZXN0X2V4bl82NFxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuKCogVGhlc2UgZnVuY3Rpb25zIHNwZWNpZmljYWxseSByZXBsYWNlIGRlZmF1bHRzIGluIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5cblxuICAgVGhlIGRlc2lyZWQgYmVoYXZpb3IgaGVyZSBpcyB0byBwcm9wYWdhdGUgYSBuYW4gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbi4gQmVjYXVzZSB0aGVcbiAgIGZpcnN0IGNvbXBhcmlzb24gd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4sIGl0IHN1ZmZpY2VzIHRvXG4gICBjaGVjayBpZiB4IGlzIG5hbi4gVGhlbiwgd2hlbiB4IGlzIG5hbiBvciBib3RoIHggYW5kIHkgYXJlIG5hbiwgd2UgcmV0dXJuIHggPSBuYW47IGFuZFxuICAgd2hlbiB5IGlzIG5hbiBidXQgbm90IHgsIHdlIHJldHVybiB5ID0gbmFuLlxuXG4gICBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIHRvIGltcGxlbWVudCB0aGVzZSBmdW5jdGlvbnMuICBUaGUgYmVuY2htYXJrIGJlbG93IHNob3dzIGEgZmV3XG4gICBkaWZmZXJlbnQgdmVyc2lvbnMuICBUaGlzIGJlbmNobWFyayB3YXMgcnVuIG92ZXIgYW4gYXJyYXkgb2YgcmFuZG9tIGZsb2F0cyAobm9uZSBvZlxuICAgd2hpY2ggYXJlIG5hbikuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjQydXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAyLjAydXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjg4dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICAgVGhlIGJlbmNobWFyayBiZWxvdyB3YXMgcnVuIHdoZW4geCA+IHkgaXMgYWx3YXlzIHRydWUgKGFnYWluLCBubyBuYW4gdmFsdWVzKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuODN1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuOTd1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuNTZ1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuKilcbmxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxubGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQnVmZmVyX2ludGZcbmluY2x1ZGUgQ2FtbC5CdWZmZXJcblxubGV0IGNvbnRlbnRzX2J5dGVzID0gdG9fYnl0ZXNcbmxldCBhZGRfc3Vic3RyaW5nIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3Vic3RyaW5nIHQgcyBwb3MgbGVuXG5sZXQgYWRkX3N1YmJ5dGVzIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3ViYnl0ZXMgdCBzIHBvcyBsZW5cbmxldCBzZXhwX29mX3QgdCA9IHNleHBfb2Zfc3RyaW5nIChjb250ZW50cyB0KVxuXG5tb2R1bGUgVG9fYnl0ZXMgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEJ5dGVzLnRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gQnl0ZXMuY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aFxuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgICAgICBDYW1sLkJ1ZmZlci5ibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuICAgICAgOztcbiAgICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChDYW1sLkJ1ZmZlcikgKFRvX2J5dGVzKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VcblxubGV0IGVsaWRlID0gcmVmIGZhbHNlXG5sZXQgZWxpZGVkX21lc3NhZ2UgPSBcIjxiYWNrdHJhY2UgZWxpZGVkIGluIHRlc3Q+XCJcblxubGV0IGdldCA/KGF0X21vc3RfbnVtX2ZyYW1lcyA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgQ2FtbC5QcmludGV4Yy5nZXRfY2FsbHN0YWNrIGF0X21vc3RfbnVtX2ZyYW1lc1xuOztcblxubGV0IHRvX3N0cmluZyB0ID1cbiAgaWYgIWVsaWRlIHRoZW4gZWxpZGVkX21lc3NhZ2UgZWxzZSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHRcbjs7XG5cbmxldCB0b19zdHJpbmdfbGlzdCB0ID0gU3RyaW5nLnNwbGl0X2xpbmVzICh0b19zdHJpbmcgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuTGlzdCAoTGlzdC5tYXAgKHRvX3N0cmluZ19saXN0IHQpIH5mOihmdW4geCAtPiBTZXhwLkF0b20geCkpXG5cbm1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgbGV0IHNldF9yZWNvcmRpbmcgPSBDYW1sLlByaW50ZXhjLnJlY29yZF9iYWNrdHJhY2VcbiAgbGV0IGFtX3JlY29yZGluZyA9IENhbWwuUHJpbnRleGMuYmFja3RyYWNlX3N0YXR1c1xuICBsZXQgbW9zdF9yZWNlbnQgKCkgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpXG5cbiAgbGV0IG1vc3RfcmVjZW50X2Zvcl9leG4gZXhuID1cbiAgICBpZiBFeG4uaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCBleG4gdGhlbiBTb21lIChtb3N0X3JlY2VudCAoKSkgZWxzZSBOb25lXG4gIDs7XG5cbiAgKCogV2UgdHVybiBvbiBiYWNrdHJhY2VzIGJ5IGRlZmF1bHQgaWYgT0NBTUxSVU5QQVJBTSBkb2Vzbid0IGV4cGxpY2l0bHkgbWVudGlvbiB0aGVtLiAqKVxuICBsZXQgbWF5YmVfc2V0X3JlY29yZGluZyAoKSA9XG4gICAgbGV0IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyA9XG4gICAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT4gTGlzdC5leGlzdHMgKFN0cmluZy5zcGxpdCB4IH5vbjonLCcpIH5mOihTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCJiXCIpXG4gICAgaW5cbiAgICBpZiBub3Qgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzIHRoZW4gc2V0X3JlY29yZGluZyB0cnVlXG4gIDs7XG5cbiAgKCogdGhlIGNhbGxlciBzZXQgc29tZXRoaW5nLCB0aGV5IGFyZSByZXNwb25zaWJsZSAqKVxuXG4gIGxldCB3aXRoX3JlY29yZGluZyBiIH5mID1cbiAgICBsZXQgc2F2ZWQgPSBhbV9yZWNvcmRpbmcgKCkgaW5cbiAgICBzZXRfcmVjb3JkaW5nIGI7XG4gICAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBzZXRfcmVjb3JkaW5nIHNhdmVkKVxuICA7O1xuZW5kXG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IEV4bi5tYXliZV9zZXRfcmVjb3JkaW5nICgpXG4iLCIoKiogVGhpcyBtb2R1bGUgaXMgdGhlIHRvcGxldmVsIG9mIHRoZSBCYXNlIGxpYnJhcnk7IGl0J3Mgd2hhdCB5b3UgZ2V0IHdoZW4geW91IHdyaXRlXG4gICAgW29wZW4gQmFzZV0uXG5cbiAgICBUaGUgZ29hbCBvZiBCYXNlIGlzIGJvdGggdG8gYmUgYSBtb3JlIGNvbXBsZXRlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggcmljaGVyIEFQSXMsXG4gICAgYW5kIHRvIGJlIG1vcmUgY29uc2lzdGVudCBpbiBpdHMgZGVzaWduLiBGb3IgaW5zdGFuY2UsIGluIHRoZSBzdGFuZGFyZCBsaWJyYXJ5XG4gICAgc29tZSB0aGluZ3MgaGF2ZSBtb2R1bGVzIGFuZCBvdGhlcnMgZG9uJ3Q7IGluIEJhc2UsIGV2ZXJ5dGhpbmcgaXMgYSBtb2R1bGUuXG5cbiAgICBCYXNlIGV4dGVuZHMgc29tZSBtb2R1bGVzIGFuZCBkYXRhIHN0cnVjdHVyZXMgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSwgbGlrZSBbQXJyYXldLFxuICAgIFtCdWZmZXJdLCBbQnl0ZXNdLCBbQ2hhcl0sIFtIYXNodGJsXSwgW0ludDMyXSwgW0ludDY0XSwgW0xhenldLCBbTGlzdF0sIFtNYXBdLFxuICAgIFtOYXRpdmVpbnRdLCBbUHJpbnRmXSwgW1JhbmRvbV0sIFtTZXRdLCBbU3RyaW5nXSwgW1N5c10sIGFuZCBbVWNoYXJdLiBPbmUga2V5XG4gICAgZGlmZmVyZW5jZSBpcyB0aGF0IEJhc2UgZG9lc24ndCB1c2UgZXhjZXB0aW9ucyBhcyBtdWNoIGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGFuZFxuICAgIGluc3RlYWQgbWFrZXMgaGVhdnkgdXNlIG9mIHRoZSBbUmVzdWx0XSB0eXBlLCBhcyBpbjpcblxuICAgIHtbIHR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiIF19XG5cbiAgICBCYXNlIGFsc28gYWRkcyBlbnRpcmVseSBuZXcgbW9kdWxlcywgbW9zdCBub3RhYmx5OlxuXG4gICAgLSBbQ29tcGFyYWJsZV0sIFtDb21wYXJhdG9yXSwgYW5kIFtDb21wYXJpc29uc10gaW4gbGlldSBvZiBwb2x5bW9ycGhpYyBjb21wYXJlLlxuICAgIC0gW0NvbnRhaW5lcl0sIHdoaWNoIHByb3ZpZGVzIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgYWNyb3NzIGNvbnRhaW5lci1saWtlIGRhdGFcbiAgICAgIHN0cnVjdHVyZXMgKGFycmF5cywgbGlzdHMsIHN0cmluZ3MpLlxuICAgIC0gW1Jlc3VsdF0sIFtFcnJvcl0sIGFuZCBbT3JfZXJyb3JdLCBzdXBwb3J0aW5nIHRoZSBvci1lcnJvciBwYXR0ZXJuLlxuKilcblxuKCpfIFdlIGhpZGUgdGhpcyBmcm9tIHRoZSB3ZWIgZG9jcyBiZWNhdXNlIHRoZSBsaW5lIHdyYXBwaW5nIGlzIGJhZCwgbWFraW5nIGl0XG4gIHByZXR0eSBtdWNoIGluc2NydXRhYmxlLiAqKVxuKCoqLyoqKVxuXG4oKiBUaGUgaW50ZW50IGlzIHRvIHNoYWRvdyBhbGwgb2YgSU5SSUEncyBzdGFuZGFyZCBsaWJyYXJ5LiAgTW9kdWxlcyBiZWxvdyB3b3VsZCBjYXVzZVxuICAgY29tcGlsYXRpb24gZXJyb3JzIHdpdGhvdXQgYmVpbmcgcmVtb3ZlZCBmcm9tIFtTaGFkb3dfc3RkbGliXSBiZWZvcmUgaW5jbHVzaW9uLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICAoKiBNb2R1bGVzIGRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbl9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuSW5fY2hhbm5lbFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIE91dF9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuT3V0X2NoYW5uZWxcbiAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gIHdpdGggbW9kdWxlIFF1ZXVlIDo9IFNoYWRvd19zdGRsaWIuUXVldWVcbiAgd2l0aCBtb2R1bGUgUmFuZG9tIDo9IFNoYWRvd19zdGRsaWIuUmFuZG9tXG4gIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICB3aXRoIG1vZHVsZSBTZXQgOj0gU2hhZG93X3N0ZGxpYi5TZXRcbiAgd2l0aCBtb2R1bGUgU3RhY2sgOj0gU2hhZG93X3N0ZGxpYi5TdGFja1xuICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgd2l0aCBtb2R1bGUgU3lzIDo9IFNoYWRvd19zdGRsaWIuU3lzXG4gIHdpdGggbW9kdWxlIFVjaGFyIDo9IFNoYWRvd19zdGRsaWIuVWNoYXJcbiAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXRcbiAgKCogU3VwcG9ydCBmb3IgZ2VuZXJhdGVkIGxleGVycyAqKVxuICB3aXRoIG1vZHVsZSBMZXhpbmcgOj0gU2hhZG93X3N0ZGxpYi5MZXhpbmdcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWYpIFtAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqKi8qKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZVxubW9kdWxlIEFycmF5ID0gQXJyYXlcbm1vZHVsZSBBdmx0cmVlID0gQXZsdHJlZVxubW9kdWxlIEJhY2t0cmFjZSA9IEJhY2t0cmFjZVxubW9kdWxlIEJpbmFyeV9zZWFyY2ggPSBCaW5hcnlfc2VhcmNoXG5tb2R1bGUgQmluYXJ5X3NlYXJjaGFibGUgPSBCaW5hcnlfc2VhcmNoYWJsZVxubW9kdWxlIEJsaXQgPSBCbGl0XG5tb2R1bGUgQm9vbCA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzXG5tb2R1bGUgQ2hhciA9IENoYXJcbm1vZHVsZSBDb21wYXJhYmxlID0gQ29tcGFyYWJsZVxubW9kdWxlIENvbXBhcmF0b3IgPSBDb21wYXJhdG9yXG5tb2R1bGUgQ29tcGFyaXNvbnMgPSBDb21wYXJpc29uc1xubW9kdWxlIENvbnRhaW5lciA9IENvbnRhaW5lclxubW9kdWxlIEVpdGhlciA9IEVpdGhlclxubW9kdWxlIEVxdWFsID0gRXF1YWxcbm1vZHVsZSBFcnJvciA9IEVycm9yXG5tb2R1bGUgRXhuID0gRXhuXG5tb2R1bGUgRmllbGQgPSBGaWVsZFxubW9kdWxlIEZsb2F0ID0gRmxvYXRcbm1vZHVsZSBGbG9hdGFibGUgPSBGbG9hdGFibGVcbm1vZHVsZSBGbiA9IEZuXG5tb2R1bGUgRm9ybWF0dGVyID0gRm9ybWF0dGVyXG5tb2R1bGUgSGFzaCA9IEhhc2hcbm1vZHVsZSBIYXNoX3NldCA9IEhhc2hfc2V0XG5tb2R1bGUgSGFzaGFibGUgPSBIYXNoYWJsZVxubW9kdWxlIEhhc2hlciA9IEhhc2hlclxubW9kdWxlIEhhc2h0YmwgPSBIYXNodGJsXG5tb2R1bGUgSWRlbnRpZmlhYmxlID0gSWRlbnRpZmlhYmxlXG5tb2R1bGUgSW5kZXhlZF9jb250YWluZXIgPSBJbmRleGVkX2NvbnRhaW5lclxubW9kdWxlIEluZm8gPSBJbmZvXG5tb2R1bGUgSW50ID0gSW50XG5tb2R1bGUgSW50X2NvbnZlcnNpb25zID0gSW50X2NvbnZlcnNpb25zXG5tb2R1bGUgSW50MzIgPSBJbnQzMlxubW9kdWxlIEludDYzID0gSW50NjNcbm1vZHVsZSBJbnQ2NCA9IEludDY0XG5tb2R1bGUgSW50YWJsZSA9IEludGFibGVcbm1vZHVsZSBJbnRfbWF0aCA9IEludF9tYXRoXG5tb2R1bGUgSW52YXJpYW50ID0gSW52YXJpYW50XG5tb2R1bGUgTGF6eSA9IExhenlcbm1vZHVsZSBMaXN0ID0gTGlzdFxubW9kdWxlIE1hcCA9IE1hcFxubW9kdWxlIE1heWJlX2JvdW5kID0gTWF5YmVfYm91bmRcbm1vZHVsZSBNb25hZCA9IE1vbmFkXG5tb2R1bGUgTmF0aXZlaW50ID0gTmF0aXZlaW50XG5tb2R1bGUgTm90aGluZyA9IE5vdGhpbmdcbm1vZHVsZSBPcHRpb24gPSBPcHRpb25cbm1vZHVsZSBPcHRpb25fYXJyYXkgPSBPcHRpb25fYXJyYXlcbm1vZHVsZSBPcl9lcnJvciA9IE9yX2Vycm9yXG5tb2R1bGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiA9IE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb25cbm1vZHVsZSBPcmRlcmluZyA9IE9yZGVyaW5nXG5tb2R1bGUgUG9seSA9IFBvbHlcbm1vZHVsZSBQb2x5bW9ycGhpY19jb21wYXJlID0gUG9seSBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMTFdIHVzZSBbUG9seV0gaW5zdGVhZFwiXVxuXG5tb2R1bGUgUG9wY291bnQgPSBQb3Bjb3VudFxuW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE4LTEwXSB1c2UgW3BvcGNvdW50XSBmdW5jdGlvbnMgaW4gdGhlIGluZGl2aWR1YWwgaW50IG1vZHVsZXNcIl1cblxubW9kdWxlIFByZXR0eV9wcmludGVyID0gUHJldHR5X3ByaW50ZXJcbm1vZHVsZSBQcmludGYgPSBQcmludGZcbm1vZHVsZSBMaW5rZWRfcXVldWUgPSBMaW5rZWRfcXVldWVcbm1vZHVsZSBRdWV1ZSA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tID0gUmFuZG9tXG5tb2R1bGUgUmVmID0gUmVmXG5tb2R1bGUgUmVzdWx0ID0gUmVzdWx0XG5tb2R1bGUgU2VxdWVuY2UgPSBTZXF1ZW5jZVxubW9kdWxlIFNldCA9IFNldFxubW9kdWxlIFNleHBhYmxlID0gU2V4cGFibGVcbm1vZHVsZSBTaWduID0gU2lnblxubW9kdWxlIFNpZ25fb3JfbmFuID0gU2lnbl9vcl9uYW5cbm1vZHVsZSBTb3VyY2VfY29kZV9wb3NpdGlvbiA9IFNvdXJjZV9jb2RlX3Bvc2l0aW9uXG5tb2R1bGUgU3RhY2sgPSBTdGFja1xubW9kdWxlIFN0YWdlZCA9IFN0YWdlZFxubW9kdWxlIFN0cmluZyA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ2FibGUgPSBTdHJpbmdhYmxlXG5tb2R1bGUgU3lzID0gU3lzXG5tb2R1bGUgVCA9IFRcbm1vZHVsZSBUeXBlX2VxdWFsID0gVHlwZV9lcXVhbFxubW9kdWxlIFVuaWZvcm1fYXJyYXkgPSBVbmlmb3JtX2FycmF5XG5tb2R1bGUgVW5pdCA9IFVuaXRcbm1vZHVsZSBVY2hhciA9IFVjaGFyXG5tb2R1bGUgVmFyaWFudCA9IFZhcmlhbnRcbm1vZHVsZSBXaXRoX3JldHVybiA9IFdpdGhfcmV0dXJuXG5tb2R1bGUgV29yZF9zaXplID0gV29yZF9zaXplXG5cbigqIEF2b2lkIGEgbGV2ZWwgb2YgaW5kaXJlY3Rpb24gZm9yIHVzZXMgb2YgdGhlIHNpZ25hdHVyZXMgZGVmaW5lZCBpbiBbVF0uICopXG5pbmNsdWRlIFRcblxuKCogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCBvZG9jIGNyZWF0ZXMgYmV0dGVyIGRvY3VtZW50YXRpb24uICopXG5tb2R1bGUgU2V4cCA9IHN0cnVjdFxuICBpbmNsdWRlIFNleHBfd2l0aF9jb21wYXJhYmxlICgqKiBAaW5saW5lICopXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMgPSBzdHJ1Y3RcbiAgbW9kdWxlIEZpZWxkc2xpYiA9IEZpZWxkc2xpYlxuICBtb2R1bGUgUHB4X2hhc2hfbGliID0gUHB4X2hhc2hfbGliXG4gIG1vZHVsZSBWYXJpYW50c2xpYiA9IFZhcmlhbnRzbGliXG4gIG1vZHVsZSBQcHhfY29tcGFyZV9saWIgPSBQcHhfY29tcGFyZV9saWJcbiAgbW9kdWxlIFBweF9lbnVtZXJhdGVfbGliID0gUHB4X2VudW1lcmF0ZV9saWJcblxuICBsZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmdcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCogW2Rlcml2aW5nIGhhc2hdIGlzIG1pc3NpbmcgZm9yIFthcnJheV0gYW5kIFtyZWZdIHNpbmNlIHRoZXNlIHR5cGVzIGFyZSBtdXRhYmxlLiAqKVxuICB0eXBlICdhIGFycmF5ID0gJ2EgQXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBpbnQgPSBBcnJheS5jb21wYXJlXG4gIGxldCBlcXVhbF9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gYm9vbCA9IEFycmF5LmVxdWFsXG5cbiAgbGV0IGFycmF5X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGFycmF5ID1cbiAgICBBcnJheS50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9hcnJheSA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBhcnJheSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIEFycmF5LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAoYXJyYXlfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGFycmF5IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBBcnJheS50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJvb2wgPSBCb29sLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYm9vbCA9IChCb29sLmNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50KVxuICBsZXQgZXF1YWxfYm9vbCA9IChCb29sLmVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfYm9vbCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEJvb2wuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfYm9vbCA6IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEJvb2wuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBib29sX29mX3NleHAgPSAoQm9vbC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYm9vbClcbiAgbGV0IHNleHBfb2ZfYm9vbCA9IChCb29sLnNleHBfb2ZfdCA6IGJvb2wgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCb29sLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNoYXIgPSBDaGFyLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfY2hhciA9IChDaGFyLmNvbXBhcmUgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgZXF1YWxfY2hhciA9IChDaGFyLmVxdWFsIDogY2hhciAtPiBjaGFyIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfY2hhciA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIENoYXIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfY2hhciA6IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IENoYXIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBjaGFyX29mX3NleHAgPSAoQ2hhci50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gY2hhcilcbiAgbGV0IHNleHBfb2ZfY2hhciA9IChDaGFyLnNleHBfb2ZfdCA6IGNoYXIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBDaGFyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGV4biA9IEV4bi50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX2V4biA9IChFeG4uc2V4cF9vZl90IDogZXhuIC0+IFNleHBsaWIwLlNleHAudClcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZmxvYXQgPSBGbG9hdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2Zsb2F0ID0gKEZsb2F0LmNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9mbG9hdCA9IChGbG9hdC5lcXVhbCA6IGZsb2F0IC0+IGZsb2F0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfZmxvYXQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgRmxvYXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfZmxvYXQgOiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gRmxvYXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBmbG9hdF9vZl9zZXhwID0gKEZsb2F0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBmbG9hdClcbiAgbGV0IHNleHBfb2ZfZmxvYXQgPSAoRmxvYXQuc2V4cF9vZl90IDogZmxvYXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEZsb2F0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludCA9IEludC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludCA9IChJbnQuY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50ID0gKEludC5lcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIEludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQgOiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludF9vZl9zZXhwID0gKEludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50KVxuICBsZXQgc2V4cF9vZl9pbnQgPSAoSW50LnNleHBfb2ZfdCA6IGludCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50MzIgPSBJbnQzMi50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDMyID0gKEludDMyLmNvbXBhcmUgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQzMiA9IChJbnQzMi5lcXVhbCA6IGludDMyIC0+IGludDMyIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50MzIgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50MzIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50MzIgOiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50MzIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQzMl9vZl9zZXhwID0gKEludDMyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQzMilcbiAgbGV0IHNleHBfb2ZfaW50MzIgPSAoSW50MzIuc2V4cF9vZl90IDogaW50MzIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDMyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDY0ID0gSW50NjQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQ2NCA9IChJbnQ2NC5jb21wYXJlIDogaW50NjQgLT4gaW50NjQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50NjQgPSAoSW50NjQuZXF1YWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDY0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDY0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDY0IDogaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDY0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50NjRfb2Zfc2V4cCA9IChJbnQ2NC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50NjQpXG4gIGxldCBzZXhwX29mX2ludDY0ID0gKEludDY0LnNleHBfb2ZfdCA6IGludDY0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQ2NF9zZXhwX2dyYW1tYXIgOiBpbnQ2NCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQ2NC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBsaXN0ID0gJ2EgTGlzdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9IExpc3QuY29tcGFyZVxuICBsZXQgZXF1YWxfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2wgPSBMaXN0LmVxdWFsXG5cbiAgbGV0IGhhc2hfZm9sZF9saXN0IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSBsaXN0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIExpc3QuaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgbGlzdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBsaXN0ID1cbiAgICBMaXN0LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2xpc3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgbGlzdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIExpc3Quc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChsaXN0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGxpc3QgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBMaXN0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgbmF0aXZlaW50ID0gTmF0aXZlaW50LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5jb21wYXJlIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LmVxdWFsIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX25hdGl2ZWludCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgTmF0aXZlaW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gTmF0aXZlaW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X29mX3NleHAgPSAoTmF0aXZlaW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBuYXRpdmVpbnQpXG4gIGxldCBzZXhwX29mX25hdGl2ZWludCA9IChOYXRpdmVpbnQuc2V4cF9vZl90IDogbmF0aXZlaW50IC0+IFNleHBsaWIwLlNleHAudClcblxuICBsZXQgKG5hdGl2ZWludF9zZXhwX2dyYW1tYXIgOiBuYXRpdmVpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBOYXRpdmVpbnQudF9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2Egb3B0aW9uID0gJ2EgT3B0aW9uLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfb3B0aW9uIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gaW50ID1cbiAgICBPcHRpb24uY29tcGFyZVxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIG9wdGlvblxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBPcHRpb24uaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIG9wdGlvbiA9XG4gICAgT3B0aW9uLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX29wdGlvbiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBvcHRpb24gLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBPcHRpb24uc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChvcHRpb25fc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIG9wdGlvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gT3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgcmVmID0gJ2EgUmVmLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gaW50ID0gUmVmLmNvbXBhcmVcbiAgbGV0IGVxdWFsX3JlZiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBib29sID0gUmVmLmVxdWFsXG5cbiAgbGV0IHJlZl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSByZWYgPVxuICAgIFJlZi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9yZWYgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgcmVmIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgUmVmLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAocmVmX3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHJlZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IFJlZi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHN0cmluZyA9IFN0cmluZy50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3N0cmluZyA9IChTdHJpbmcuY29tcGFyZSA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgZXF1YWxfc3RyaW5nID0gKFN0cmluZy5lcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9zdHJpbmcgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHN0cmluZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFN0cmluZy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9zdHJpbmcgOiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFN0cmluZy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHN0cmluZ19vZl9zZXhwID0gKFN0cmluZy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gc3RyaW5nKVxuICBsZXQgc2V4cF9vZl9zdHJpbmcgPSAoU3RyaW5nLnNleHBfb2ZfdCA6IHN0cmluZyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYnl0ZXMgPSBCeXRlcy50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2J5dGVzID0gKEJ5dGVzLmNvbXBhcmUgOiBieXRlcyAtPiBieXRlcyAtPiBpbnQpXG4gIGxldCBlcXVhbF9ieXRlcyA9IChCeXRlcy5lcXVhbCA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGJvb2wpXG4gIGxldCBieXRlc19vZl9zZXhwID0gKEJ5dGVzLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBieXRlcylcbiAgbGV0IHNleHBfb2ZfYnl0ZXMgPSAoQnl0ZXMuc2V4cF9vZl90IDogYnl0ZXMgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJ5dGVzLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHVuaXQgPSBVbml0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfdW5pdCA9IChVbml0LmNvbXBhcmUgOiB1bml0IC0+IHVuaXQgLT4gaW50KVxuICBsZXQgZXF1YWxfdW5pdCA9IChVbml0LmVxdWFsIDogdW5pdCAtPiB1bml0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdW5pdCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFVuaXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfdW5pdCA6IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFVuaXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB1bml0X29mX3NleHAgPSAoVW5pdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdW5pdClcbiAgbGV0IHNleHBfb2ZfdW5pdCA9IChVbml0LnNleHBfb2ZfdCA6IHVuaXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBVbml0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICAoKiogRm9ybWF0IHN0dWZmICopXG5cbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcblxuICAoKiogTGlzdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIExpc3QuSW5maXhcblxuICAoKiogSW50IG9wZXJhdG9ycyBhbmQgY29tcGFyaXNvbnMgKilcblxuICBpbmNsdWRlIEludC5PXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICgqKiBGbG9hdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIEZsb2F0Lk9fZG90XG5cbiAgKCogVGhpcyBpcyBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBiZSBvcHRpbWl6ZWQgYXdheSBpbiBtb3JlIGNvbnRleHRzLiAqKVxuXG4gICgqKiBSZXZlcnNlIGFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbeCB8PiBnIHw+IGZdIGlzIGVxdWl2YWxlbnQgdG8gW2YgKGcgKHgpKV0uICopXG4gIGV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbiAgKCoqIEFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbZyBAQCBmIEBAIHhdIGlzIGVxdWl2YWxlbnQgdG8gW2cgKGYgKHgpKV0uICopXG4gIGV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbiAgKCoqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG4gICgqIFRoZXNlIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gZ2V0IHRoZSBsYXp5IGJlaGF2aW9yICopXG4gIGV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIGV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5cbiAgKCogVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseS4gKilcbiAgZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuICAoKiogQ29tbW9uIHN0cmluZyBvcGVyYXRpb25zICopXG4gIGxldCAoIF4gKSA9IFN0cmluZy4oIF4gKVxuXG4gICgqKiBSZWZlcmVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4gICgqIERlY2xhcmVkIGFzIGFuIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZSBhbmRcbiAgICAgdG8ga2VlcCByZWZlcmVuY2UgdW5ib3hpbmcgd29ya2luZyAqKVxuICBleHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG4gIGV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbiAgZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG4gICgqKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuICBsZXQgZnN0ID0gZnN0XG4gIGxldCBzbmQgPSBzbmRcblxuICAoKiogRXhjZXB0aW9ucyBzdHVmZiAqKVxuXG4gICgqIERlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHNvIHRoYXQgdGhlIGNvbXBpbGVyIG1heSByZXdyaXRlICclcmFpc2UnIGFzICclcmVyYWlzZScuICopXG4gIGV4dGVybmFsIHJhaXNlIDogZXhuIC0+IF8gPSBcIiVyYWlzZVwiXG5cbiAgbGV0IGZhaWx3aXRoID0gZmFpbHdpdGhcbiAgbGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgKCoqIE1pc2MgKilcblxuICBsZXQgcGh5c19lcXVhbCA9IHBoeXNfZXF1YWxcblxuICBleHRlcm5hbCBmb3JjZSA6ICdhIExhenkudCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbmluY2x1ZGUgQ29udGFpbmVyX2ludGYuRXhwb3J0ICgqKiBAaW5saW5lICopXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyA9IE5vdF9mb3VuZF9zXG5cbigqIFdlIHBlcmZvcm0gdGhlc2Ugc2lkZSBlZmZlY3RzIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZW0gdG8gcnVuIGZvciBhbnkgY29kZSB0aGF0IHVzZXNcbiAgIFtCYXNlXS4gIElmIHRoaXMgd2VyZSBpbiBhbm90aGVyIG1vZHVsZSBpbiBbQmFzZV0gdGhhdCB3YXMgbm90IHVzZWQgaW4gc29tZSBwcm9ncmFtLFxuICAgdGhlbiB0aGUgc2lkZSBlZmZlY3RzIG1pZ2h0IG5vdCBiZSBydW4gaW4gdGhhdCBwcm9ncmFtLiAgVGhpcyB3aWxsIHJ1biBhcyBsb25nIGFzIHRoZVxuICAgcHJvZ3JhbSByZWZlcnMgdG8gYXQgbGVhc3Qgb25lIHZhbHVlIGRpcmVjdGx5IGluIFtCYXNlXTsgcmVmZXJyaW5nIHRvIHZhbHVlcyBpblxuICAgW0Jhc2UuQm9vbF0sIGZvciBleGFtcGxlLCBpcyBub3Qgc3VmZmljaWVudC4gKilcbmxldCAoKSA9IEJhY2t0cmFjZS5pbml0aWFsaXplX21vZHVsZSAoKVxuIl19
