// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Validate
//# unitInfo: Requires: Assert_failure, Base, Base__Error, Base__Field, Base__Int, Base__List, Base__Maybe_bound, Base__Or_error, Base__Printf, Base__Staged, Base__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Validate = "Validate",
    cst_validate = "validate",
    cst_validate_src_validate_ml = "validate/src/validate.ml",
    cst_value = "value ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_List = global_data.Base__List,
    Base_Int = global_data.Base__Int,
    Base_Staged = global_data.Base__Staged,
    Base_Field = global_data.Base__Field,
    Base_Or_error = global_data.Base__Or_error,
    Base = global_data.Base,
    Base_Error = global_data.Base__Error,
    Base_String = global_data.Base__String,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Validate);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_validate);
   caml_call1(Expect_test_collector[5][1], cst_validate_src_validate_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_validate, cst);
   var pass = 0;
   function fails(message, a, sexp_of_a){
    return [0,
            [0, 0, caml_call5(Base_Error[17], 0, 0, message, a, sexp_of_a)],
            0];
   }
   function fail(message){
    return [0, [0, 0, caml_call1(Base_Error[12], message)], 0];
   }
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function fail_s(sexp){
    return [0, [0, 0, caml_call1(Base_Error[18], sexp)], 0];
   }
   function combine(t1, t2){return caml_call2(Base[178], t1, t2);}
   var
    of_list = Base_List[138],
    cst_Exception_raised_during_va = "Exception raised during validation",
    _a_ = [0, "."],
    cst_validation_errors = "validation errors",
    _b_ = [0, 0],
    cst_snd = "snd",
    cst_fst = "fst",
    _c_ = [0, cst_validate_src_validate_ml, 154, 20],
    _d_ =
      [0,
       [11, cst_value, [2, 0, [11, " < bound ", [2, 0, 0]]]],
       "value %s < bound %s"],
    _e_ =
      [0,
       [11, cst_value, [2, 0, [11, " <= bound ", [2, 0, 0]]]],
       "value %s <= bound %s"],
    _f_ = [0, cst_validate_src_validate_ml, 159, 20],
    _g_ =
      [0,
       [11, cst_value, [2, 0, [11, " > bound ", [2, 0, 0]]]],
       "value %s > bound %s"],
    _h_ =
      [0,
       [11, cst_value, [2, 0, [11, " >= bound ", [2, 0, 0]]]],
       "value %s >= bound %s"];
   function name(name, t){
    return t
            ? caml_call2
              (Base_List[76],
               t,
               function(param){
                var error = param[2], path = param[1];
                return [0, [0, name, path], error];
               })
            : 0;
   }
   function name_list(n, l){return name(n, caml_call1(of_list, l));}
   function fail_fn(message, param){return fail(message);}
   function pass_bool(param){return pass;}
   function pass_unit(param){return pass;}
   function protect(f, v){
    try{var _E_ = caml_call1(f, v); return _E_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _D_ = [0, [0, cst$0, caml_call1(Base[106], exn)], 0];
     return fail_s
             (caml_call2(Base[84][7], cst_Exception_raised_during_va, _D_));
    }
   }
   function try_with(f){
    return protect(function(param){caml_call1(f, 0); return pass;}, 0);
   }
   function path_string(path){return caml_call2(Base_String[54], _a_, path);}
   function errors(t){
    return caml_call2
            (Base_List[76],
             t,
             function(param){
              var
               error = param[2],
               path = param[1],
               _B_ = path_string(path),
               _C_ = caml_call2(Base_Error[20], error, _B_);
              return caml_call1(Base_Error[9], _C_);
             });
   }
   function result(t){
    if(caml_call1(Base_List[8], t)) return _b_;
    var
     _A_ =
       caml_call2
        (Base_List[76],
         t,
         function(param){
          var error = param[2], path = param[1];
          return [0, path_string(path), error];
         });
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_validation_errors,
             _A_,
             function(x_005){
              return caml_call2
                      (Base_List[4],
                       function(param){
                        var
                         arg1_002 = param[2],
                         arg0_001 = param[1],
                         res0_003 = caml_call1(Base[164], arg0_001),
                         res1_004 = caml_call1(Base_Error[6], arg1_002);
                        return [1, [0, res0_003, [0, res1_004, 0]]];
                       },
                       x_005);
             });
   }
   function maybe_raise(t){
    var _z_ = result(t);
    return caml_call1(Base_Or_error[31], _z_);
   }
   function valid_or_error(check, x){
    var _y_ = result(protect(check, x));
    return caml_call2(Base_Or_error[43], _y_, function(param){return x;});
   }
   function field_direct(check, fld, record, v){
    var result = protect(check, v);
    return name(caml_call1(Base_Field[2], fld), result);
   }
   function field(check, record, fld){
    var v = caml_call2(Base_Field[3], fld, record);
    return field_direct(check, fld, record, v);
   }
   function field_folder(check, record){
    return function(acc, fld){return [0, field(check, record, fld), acc];};
   }
   function field_direct_folder(check){
    return caml_call1
            (Base_Staged[1],
             function(acc, fld, record, v){
              var result = field_direct(check, fld, record, v);
              return result ? [0, result, acc] : acc;
             });
   }
   function all(checks, v){
    var checks$0 = checks, errs = 0;
    for(;;){
     if(! checks$0)
      return caml_call1(of_list, caml_call1(Base_List[38], errs));
     var checks$1 = checks$0[2], check = checks$0[1], err = protect(check, v);
     if(err){
      var errs$0 = [0, err, errs];
      checks$0 = checks$1;
      errs = errs$0;
     }
     else
      checks$0 = checks$1;
    }
   }
   function of_result(f){
    function _w_(v){
     var match = caml_call1(f, v);
     if(0 === match[0]) return pass;
     var error = match[1];
     return fail(error);
    }
    return function(_x_){return protect(_w_, _x_);};
   }
   function of_error(f){
    function _u_(v){
     var match = caml_call1(f, v);
     if(0 === match[0]) return pass;
     var error = match[1];
     return [0, [0, 0, error], 0];
    }
    return function(_v_){return protect(_u_, _v_);};
   }
   function booltest(f, if_false){
    function _s_(v){return caml_call1(f, v) ? pass : fail(if_false);}
    return function(_t_){return protect(_s_, _t_);};
   }
   function pair(fst, snd, param){
    var
     snd_value = param[2],
     fst_value = param[1],
     _r_ = [0, name(cst_snd, protect(snd, snd_value)), 0];
    return caml_call1
            (of_list, [0, name(cst_fst, protect(fst, fst_value)), _r_]);
   }
   function list_indexed(check, list){
    return caml_call1
            (of_list,
             caml_call2
              (Base_List[96],
               list,
               function(i, el){
                var _q_ = protect(check, el);
                return name(caml_call1(Base_Int[11], i + 1 | 0), _q_);
               }));
   }
   function list(extract_name, check, list){
    return caml_call1
            (of_list,
             caml_call2
              (Base_List[76],
               list,
               function(el){
                var t = protect(check, el);
                return t
                        ? protect
                          (function(t){return name(caml_call1(extract_name, el), t);},
                           t)
                        : 0;
               }));
   }
   function alist(name, f, list$0){
    return list
            (function(param){
              var key = param[1];
              return caml_call1(name, key);
             },
             function(param){var x = param[2]; return caml_call1(f, x);},
             list$0);
   }
   function first_failure(t1, t2){
    return caml_call1(Base_List[8], t1) ? t2 : t1;
   }
   function of_error_opt(param){
    if(! param) return pass;
    var error = param[1];
    return fail(error);
   }
   function bounded(name, lower, upper, compare, x){
    switch(caml_call4(Base_Maybe_bound[16], lower, upper, x, compare)){
      case 0:
       if(typeof lower === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(0 === lower[0]){
        var
         incl = lower[1],
         _i_ = caml_call1(name, incl),
         _j_ = caml_call1(name, x);
        return fail(caml_call3(Base_Printf[2], _d_, _j_, _i_));
       }
       var
        excl = lower[1],
        _k_ = caml_call1(name, excl),
        _l_ = caml_call1(name, x);
       return fail(caml_call3(Base_Printf[2], _e_, _l_, _k_));
      case 1:
       return pass;
      default:
       if(typeof upper === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
       if(0 === upper[0]){
        var
         incl$0 = upper[1],
         _m_ = caml_call1(name, incl$0),
         _n_ = caml_call1(name, x);
        return fail(caml_call3(Base_Printf[2], _g_, _n_, _m_));
       }
       var
        excl$0 = upper[1],
        _o_ = caml_call1(name, excl$0),
        _p_ = caml_call1(name, x);
       return fail(caml_call3(Base_Printf[2], _h_, _p_, _o_));
    }
   }
   function symbol(t1, t2){return combine(t1, t2);}
   var Infix = [0, symbol];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_validate);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Validate);
   var
    Validate =
      [0,
       pass,
       fail,
       fails,
       fail_s,
       failf,
       combine,
       of_list,
       name,
       name_list,
       fail_fn,
       pass_bool,
       pass_unit,
       protect,
       try_with,
       result,
       errors,
       maybe_raise,
       valid_or_error,
       field,
       field_direct,
       field_folder,
       field_direct_folder,
       all,
       of_result,
       of_error,
       booltest,
       pair,
       list_indexed,
       list,
       first_failure,
       of_error_opt,
       alist,
       bounded,
       Infix];
   runtime.caml_register_global(35, Validate, cst_Validate);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ2YWxpZGF0ZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicGFzcyIsImZhaWxzIiwibWVzc2FnZSIsImEiLCJzZXhwX29mX2EiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJmYWlsX3MiLCJzZXhwIiwiY29tYmluZSIsInQxIiwidDIiLCJvZl9saXN0IiwibmFtZSIsInQiLCJlcnJvciIsInBhdGgiLCJuYW1lX2xpc3QiLCJuIiwibCIsImZhaWxfZm4iLCJwYXNzX2Jvb2wiLCJwYXNzX3VuaXQiLCJwcm90ZWN0IiwiZiIsInYiLCJleG4kMCIsImV4biIsInRyeV93aXRoIiwicGF0aF9zdHJpbmciLCJlcnJvcnMiLCJyZXN1bHQiLCJ4XzAwNSIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwibWF5YmVfcmFpc2UiLCJ2YWxpZF9vcl9lcnJvciIsImNoZWNrIiwieCIsImZpZWxkX2RpcmVjdCIsImZsZCIsInJlY29yZCIsImZpZWxkIiwiZmllbGRfZm9sZGVyIiwiYWNjIiwiZmllbGRfZGlyZWN0X2ZvbGRlciIsImFsbCIsImNoZWNrcyIsImNoZWNrcyQwIiwiZXJycyIsImNoZWNrcyQxIiwiZXJyIiwiZXJycyQwIiwib2ZfcmVzdWx0Iiwib2ZfZXJyb3IiLCJib29sdGVzdCIsImlmX2ZhbHNlIiwicGFpciIsImZzdCIsInNuZCIsInNuZF92YWx1ZSIsImZzdF92YWx1ZSIsImxpc3RfaW5kZXhlZCIsImxpc3QiLCJpIiwiZWwiLCJleHRyYWN0X25hbWUiLCJhbGlzdCIsImxpc3QkMCIsImtleSIsImZpcnN0X2ZhaWx1cmUiLCJvZl9lcnJvcl9vcHQiLCJib3VuZGVkIiwibG93ZXIiLCJ1cHBlciIsImNvbXBhcmUiLCJpbmNsIiwiZXhjbCIsImluY2wkMCIsImV4Y2wkMCIsInN5bWJvbCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9jb3JlL3ZhbGlkYXRlL3Zh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T0FFQUM7T0FNQUk7T0FDQUc7T0FDQUM7T0FDQUM7T0FFQUM7T0FNQUs7T0F5QkFHO09BZkFEO09BaUJBTztPQUNBQztPQU9BTTtPQUxBSDtPQVVBSTtPQUtBRTtPQU9BQztPQVlBTztPQU9BQztPQU9BQztPQUVBRTtPQUlBSztPQUtBQztPQVdBTztPQUVBQztPQUhBSjtPQVFBSzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiBCYXNlXG5cbigqKiBFYWNoIHNpbmdsZV9lcnJvciBpcyBhIHBhdGggaW5kaWNhdGluZyB0aGUgbG9jYXRpb24gd2l0aGluIHRoZSBkYXRhc3RydWN0dXJlIGluXG4gICAgcXVlc3Rpb24gdGhhdCBpcyBiZWluZyB2YWxpZGF0ZWQsIGFsb25nIHdpdGggYW4gZXJyb3IgbWVzc2FnZS4gKilcbnR5cGUgc2luZ2xlX2Vycm9yID1cbiAgeyBwYXRoIDogc3RyaW5nIGxpc3RcbiAgOyBlcnJvciA6IEVycm9yLnRcbiAgfVxuXG50eXBlIHQgPSBzaW5nbGVfZXJyb3IgbGlzdFxudHlwZSAnYSBjaGVjayA9ICdhIC0+IHRcblxubGV0IHBhc3MgOiB0ID0gW11cblxubGV0IGZhaWxzIG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBbIHsgcGF0aCA9IFtdOyBlcnJvciA9IEVycm9yLmNyZWF0ZSBtZXNzYWdlIGEgc2V4cF9vZl9hIH0gXVxuOztcblxubGV0IGZhaWwgbWVzc2FnZSA9IFsgeyBwYXRoID0gW107IGVycm9yID0gRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UgfSBdXG5sZXQgZmFpbGYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGZhaWwgZm9ybWF0XG5sZXQgZmFpbF9zIHNleHAgPSBbIHsgcGF0aCA9IFtdOyBlcnJvciA9IEVycm9yLmNyZWF0ZV9zIHNleHAgfSBdXG5sZXQgY29tYmluZSB0MSB0MiA9IHQxIEAgdDJcbmxldCBvZl9saXN0ID0gTGlzdC5jb25jYXRcblxubGV0IG5hbWUgbmFtZSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gW10gKCogd2hlbiBzdWNjZXNzZnVsLCBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBhIGNsb3N1cmUgZm9yIFt+Zl0sIGJlbG93ICopXG4gIHwgXyAtPiBMaXN0Lm1hcCB0IH5mOihmdW4geyBwYXRoOyBlcnJvciB9IC0+IHsgcGF0aCA9IG5hbWUgOjogcGF0aDsgZXJyb3IgfSlcbjs7XG5cbmxldCBuYW1lX2xpc3QgbiBsID0gbmFtZSBuIChvZl9saXN0IGwpXG5sZXQgZmFpbF9mbiBtZXNzYWdlIF8gPSBmYWlsIG1lc3NhZ2VcbmxldCBwYXNzX2Jvb2wgKF8gOiBib29sKSA9IHBhc3NcbmxldCBwYXNzX3VuaXQgKF8gOiB1bml0KSA9IHBhc3NcblxubGV0IHByb3RlY3QgZiB2ID1cbiAgdHJ5IGYgdiB3aXRoXG4gIHwgZXhuIC0+XG4gICAgZmFpbF9zIChTZXhwLm1lc3NhZ2UgXCJFeGNlcHRpb24gcmFpc2VkIGR1cmluZyB2YWxpZGF0aW9uXCIgWyBcIlwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgcHJvdGVjdFxuICAgIChmdW4gKCkgLT5cbiAgICAgICBmICgpO1xuICAgICAgIHBhc3MpXG4gICAgKClcbjs7XG5cbmxldCBwYXRoX3N0cmluZyBwYXRoID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLlwiIHBhdGhcblxubGV0IGVycm9ycyB0ID1cbiAgTGlzdC5tYXAgdCB+ZjooZnVuIHsgcGF0aDsgZXJyb3IgfSAtPlxuICAgIEVycm9yLnRvX3N0cmluZ19odW0gKEVycm9yLnRhZyBlcnJvciB+dGFnOihwYXRoX3N0cmluZyBwYXRoKSkpXG47O1xuXG5sZXQgcmVzdWx0X2ZhaWwgdCA9XG4gIE9yX2Vycm9yLmVycm9yXG4gICAgXCJ2YWxpZGF0aW9uIGVycm9yc1wiXG4gICAgKExpc3QubWFwIHQgfmY6KGZ1biB7IHBhdGg7IGVycm9yIH0gLT4gcGF0aF9zdHJpbmcgcGF0aCwgZXJyb3IpKVxuICAgIFslc2V4cF9vZjogKHN0cmluZyAqIEVycm9yLnQpIExpc3QudF1cbltAQGNvbGRdXG47O1xuXG4oKiogW3Jlc3VsdF0gaXMgY2FyZWZ1bGx5IGltcGxlbWVudGVkIHNvIHRoYXQgaXQgY2FuIGJlIGlubGluZWQgLS0gY2FsbGluZyBbcmVzdWx0X2ZhaWxdLFxuICAgIHdoaWNoIGlzIG5vdCBpbmxpbmVhYmxlLCBpcyBrZXkgdG8gdGhpcy4gKilcbmxldCByZXN1bHQgdCA9IGlmIExpc3QuaXNfZW1wdHkgdCB0aGVuIE9rICgpIGVsc2UgcmVzdWx0X2ZhaWwgdFxuXG5sZXQgbWF5YmVfcmFpc2UgdCA9IE9yX2Vycm9yLm9rX2V4biAocmVzdWx0IHQpXG5sZXQgdmFsaWRfb3JfZXJyb3IgY2hlY2sgeCA9IE9yX2Vycm9yLm1hcCAocmVzdWx0IChwcm90ZWN0IGNoZWNrIHgpKSB+ZjooZnVuICgpIC0+IHgpXG5cbmxldCBmaWVsZF9kaXJlY3QgY2hlY2sgZmxkIF9yZWNvcmQgdiA9XG4gIGxldCByZXN1bHQgPSBwcm90ZWN0IGNoZWNrIHYgaW5cbiAgbmFtZSAoRmllbGQubmFtZSBmbGQpIHJlc3VsdFxuOztcblxubGV0IGZpZWxkIGNoZWNrIHJlY29yZCBmbGQgPVxuICBsZXQgdiA9IEZpZWxkLmdldCBmbGQgcmVjb3JkIGluXG4gIGZpZWxkX2RpcmVjdCBjaGVjayBmbGQgcmVjb3JkIHZcbjs7XG5cbmxldCBmaWVsZF9mb2xkZXIgY2hlY2sgcmVjb3JkID1cbiAgKCk7XG4gIGZ1biBhY2MgZmxkIC0+IGZpZWxkIGNoZWNrIHJlY29yZCBmbGQgOjogYWNjXG47O1xuXG5sZXQgZmllbGRfZGlyZWN0X2ZvbGRlciBjaGVjayA9XG4gIFN0YWdlZC5zdGFnZSAoZnVuIGFjYyBmbGQgcmVjb3JkIHYgLT5cbiAgICBtYXRjaCBmaWVsZF9kaXJlY3QgY2hlY2sgZmxkIHJlY29yZCB2IHdpdGhcbiAgICB8IFtdIC0+IGFjYyAoKiBBdm9pZCBhbGxvY2F0aW5nIGEgbmV3IGxpc3QgaW4gdGhlIHN1Y2Nlc3MgY2FzZSAqKVxuICAgIHwgcmVzdWx0IC0+IHJlc3VsdCA6OiBhY2MpXG47O1xuXG5sZXQgYWxsIGNoZWNrcyB2ID1cbiAgbGV0IHJlYyBsb29wIGNoZWNrcyB2IGVycnMgPVxuICAgIG1hdGNoIGNoZWNrcyB3aXRoXG4gICAgfCBbXSAtPiBlcnJzXG4gICAgfCBjaGVjayA6OiBjaGVja3MgLT5cbiAgICAgIChtYXRjaCBwcm90ZWN0IGNoZWNrIHYgd2l0aFxuICAgICAgIHwgW10gLT4gbG9vcCBjaGVja3MgdiBlcnJzXG4gICAgICAgfCBlcnIgLT4gbG9vcCBjaGVja3MgdiAoZXJyIDo6IGVycnMpKVxuICBpblxuICBvZl9saXN0IChMaXN0LnJldiAobG9vcCBjaGVja3MgdiBbXSkpXG47O1xuXG5sZXQgb2ZfcmVzdWx0IGYgPVxuICBwcm90ZWN0IChmdW4gdiAtPlxuICAgIG1hdGNoIGYgdiB3aXRoXG4gICAgfCBPayAoKSAtPiBwYXNzXG4gICAgfCBFcnJvciBlcnJvciAtPiBmYWlsIGVycm9yKVxuOztcblxubGV0IG9mX2Vycm9yIGYgPVxuICBwcm90ZWN0IChmdW4gdiAtPlxuICAgIG1hdGNoIGYgdiB3aXRoXG4gICAgfCBPayAoKSAtPiBwYXNzXG4gICAgfCBFcnJvciBlcnJvciAtPiBbIHsgcGF0aCA9IFtdOyBlcnJvciB9IF0pXG47O1xuXG5sZXQgYm9vbHRlc3QgZiB+aWZfZmFsc2UgPSBwcm90ZWN0IChmdW4gdiAtPiBpZiBmIHYgdGhlbiBwYXNzIGVsc2UgZmFpbCBpZl9mYWxzZSlcblxubGV0IHBhaXIgfmZzdCB+c25kIChmc3RfdmFsdWUsIHNuZF92YWx1ZSkgPVxuICBvZl9saXN0IFsgbmFtZSBcImZzdFwiIChwcm90ZWN0IGZzdCBmc3RfdmFsdWUpOyBuYW1lIFwic25kXCIgKHByb3RlY3Qgc25kIHNuZF92YWx1ZSkgXVxuOztcblxubGV0IGxpc3RfaW5kZXhlZCBjaGVjayBsaXN0ID1cbiAgTGlzdC5tYXBpIGxpc3QgfmY6KGZ1biBpIGVsIC0+IG5hbWUgKEludC50b19zdHJpbmcgKGkgKyAxKSkgKHByb3RlY3QgY2hlY2sgZWwpKVxuICB8PiBvZl9saXN0XG47O1xuXG5sZXQgbGlzdCB+bmFtZTpleHRyYWN0X25hbWUgY2hlY2sgbGlzdCA9XG4gIExpc3QubWFwIGxpc3QgfmY6KGZ1biBlbCAtPlxuICAgIG1hdGNoIHByb3RlY3QgY2hlY2sgZWwgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IHQgLT5cbiAgICAgICgqIGV4dHJhIGxldmVsIG9mIHByb3RlY3Rpb24gaW4gY2FzZSBleHRyYWN0X25hbWUgdGhyb3dzIGFuIGV4Y2VwdGlvbiAqKVxuICAgICAgcHJvdGVjdCAoZnVuIHQgLT4gbmFtZSAoZXh0cmFjdF9uYW1lIGVsKSB0KSB0KVxuICB8PiBvZl9saXN0XG47O1xuXG5sZXQgYWxpc3Qgfm5hbWUgZiBsaXN0JyA9IGxpc3QgKGZ1biAoXywgeCkgLT4gZiB4KSBsaXN0JyB+bmFtZTooZnVuIChrZXksIF8pIC0+IG5hbWUga2V5KVxubGV0IGZpcnN0X2ZhaWx1cmUgdDEgdDIgPSBpZiBMaXN0LmlzX2VtcHR5IHQxIHRoZW4gdDIgZWxzZSB0MVxuXG5sZXQgb2ZfZXJyb3Jfb3B0ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IHBhc3NcbiAgfCBTb21lIGVycm9yIC0+IGZhaWwgZXJyb3Jcbjs7XG5cbmxldCBib3VuZGVkIH5uYW1lIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgeCA9XG4gIG1hdGNoIE1heWJlX2JvdW5kLmNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgeCB3aXRoXG4gIHwgSW5fcmFuZ2UgLT4gcGFzc1xuICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+XG4gICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgIHwgSW5jbCBpbmNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPCBib3VuZCAlc1wiIChuYW1lIHgpIChuYW1lIGluY2wpKVxuICAgICB8IEV4Y2wgZXhjbCAtPiBmYWlsIChQcmludGYuc3ByaW50ZiBcInZhbHVlICVzIDw9IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgZXhjbCkpKVxuICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+XG4gICAgKG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgIHwgSW5jbCBpbmNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPiBib3VuZCAlc1wiIChuYW1lIHgpIChuYW1lIGluY2wpKVxuICAgICB8IEV4Y2wgZXhjbCAtPiBmYWlsIChQcmludGYuc3ByaW50ZiBcInZhbHVlICVzID49IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgZXhjbCkpKVxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoICsrICkgdDEgdDIgPSBjb21iaW5lIHQxIHQyXG5lbmRcbiJdfQ==
