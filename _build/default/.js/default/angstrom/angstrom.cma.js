// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Angstrom__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom = [0];
   runtime.caml_register_global(0, Angstrom, "Angstrom__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__More
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom_More = [0];
   runtime.caml_register_global(0, Angstrom_More, "Angstrom__More");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Exported_state
//# unitInfo: Requires: Stdlib, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = " > ",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    _a_ = [1, "incomplete input"];
   function state_to_option(x){
    switch(x[0]){
      case 0:
       return 0;
      case 1:
       var v = x[2]; return [0, v];
      default: return 0;
    }
   }
   function fail_to_string(marks, err){
    var
     _b_ = caml_call2(Stdlib[28], cst, err),
     _c_ = caml_call2(Stdlib_String[6], cst$0, marks);
    return caml_call2(Stdlib[28], _c_, _b_);
   }
   function state_to_result(x){
    switch(x[0]){
      case 0:
       return _a_;
      case 1:
       var v = x[2]; return [0, v];
      default:
       var err = x[3], marks = x[2]; return [1, fail_to_string(marks, err)];
    }
   }
   var
    Angstrom_Exported_state =
      [0, state_to_option, fail_to_string, state_to_result];
   runtime.caml_register_global
    (5, Angstrom_Exported_state, "Angstrom__Exported_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Input
//# unitInfo: Requires: Assert_failure, Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_input_ml = "lib/input.ml",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_input_ml, 60, 2],
    _b_ = [0, cst_lib_input_ml, 59, 2];
   function create(buffer, off, len, committed_bytes){
    return [0, committed_bytes, committed_bytes, off, len, buffer];
   }
   function length(t){return t[2] + t[4] | 0;}
   function client_committed_bytes(t){return t[2];}
   function parser_committed_bytes(t){return t[1];}
   function bytes_for_client_to_commit(t){return t[1] - t[2] | 0;}
   function parser_uncommitted_bytes(t){
    var _f_ = bytes_for_client_to_commit(t);
    return t[4] - _f_ | 0;
   }
   function invariant(t){
    var _c_ = length(t), _d_ = parser_uncommitted_bytes(t);
    if((t[1] + _d_ | 0) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var _e_ = bytes_for_client_to_commit(t);
    if((t[1] - t[2] | 0) === _e_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function offset_in_buffer(t, pos){return (t[3] + pos | 0) - t[2] | 0;}
   function apply(t, pos, len, f){
    var off = offset_in_buffer(t, pos);
    return caml_call3(f, t[5], off, len);
   }
   function unsafe_get_char(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_ba_get_1(t[5], off);
   }
   function unsafe_get_int16_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[30], t[5], off);
   }
   function unsafe_get_int32_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[36], t[5], off);
   }
   function unsafe_get_int64_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[40], t[5], off);
   }
   function unsafe_get_int16_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[31], t[5], off);
   }
   function unsafe_get_int32_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[37], t[5], off);
   }
   function unsafe_get_int64_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[41], t[5], off);
   }
   function count_while(t, pos, f){
    var
     buffer = t[5],
     off = offset_in_buffer(t, pos),
     i = [0, off],
     limit = t[3] + t[4] | 0;
    for(;;){
     if(i[1] < limit && caml_call1(f, caml_ba_get_1(buffer, i[1]))){i[1]++; continue;}
     return i[1] - off | 0;
    }
   }
   function commit(t, pos){t[1] = pos; return 0;}
   var
    Angstrom_Input =
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
   runtime.caml_register_global(4, Angstrom_Input, "Angstrom__Input");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Parser
//# unitInfo: Requires: Angstrom__Exported_state, Angstrom__Input, Bigstringaf, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    State = [0];
   function fail_k(input, pos, param, marks, msg){
    return [3, pos - caml_call1(Angstrom_Input[3], input) | 0, marks, msg];
   }
   function succeed_k(input, pos, param, v){
    return [2, pos - caml_call1(Angstrom_Input[3], input) | 0, v];
   }
   function to_exported_state(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var match = param$0[1], continue$0 = match[2], committed = match[1];
        return [0,
                [0,
                 committed,
                 function(bs, off, len, more){
                  return to_exported_state
                          (caml_call4(continue$0, bs, off, len, more));
                 }]];
       case 1:
        var
         x = param$0[1],
         _c_ = runtime.caml_obj_tag(x),
         param$1 =
           250 === _c_
            ? x[1]
            : 246 === _c_ ? caml_call1(CamlinternalLazy[2], x) : x;
        param$0 = param$1;
        break;
       case 2:
        var x$0 = param$0[2], i = param$0[1]; return [1, i, x$0];
       default:
        var s = param$0[3], sl = param$0[2], i$0 = param$0[1];
        return [2, i$0, sl, s];
     }
   }
   function parse(p){
    var input = caml_call4(Angstrom_Input[1], Bigstringaf[2], 0, 0, 0);
    return to_exported_state(caml_call5(p[1], input, 0, 1, fail_k, succeed_k));
   }
   function parse_bigstring(p, input){
    var
     _a_ = caml_call1(Bigstringaf[6], input),
     input$0 = caml_call4(Angstrom_Input[1], input, 0, _a_, 0),
     _b_ =
       to_exported_state(caml_call5(p[1], input$0, 0, 0, fail_k, succeed_k));
    return caml_call1(Angstrom_Exported_state[3], _b_);
   }
   function return$0(v){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4(succ, input, pos, more, v);
            }];
   }
   function fail(msg){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call5(fail, input, pos, more, 0, msg);
            }];
   }
   function symbol_bind(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call5
                      (caml_call1(f, v)[1], input, pos, more, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol_map(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call4(succ, input, pos, more, caml_call1(f, v));
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol(f, m){return symbol_map(m, f);}
   function symbol$0(f, m){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, f){
              function succ1(input1, pos1, more1, m){
               return caml_call4(succ, input1, pos1, more1, caml_call1(f, m));
              }
              return caml_call5(m[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(f[1], input, pos, more, fail, succ0);
            }];
   }
   function lift(f, m){return symbol_map(m, f);}
   function lift2(f, m1, m2){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               return caml_call4
                       (succ, input2, pos2, more2, caml_call2(f, m1, m2));
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift3(f, m1, m2, m3){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                return caml_call4
                        (succ, input3, pos3, more3, caml_call3(f, m1, m2, m3));
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift4(f, m1, m2, m3, m4){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                function succ4(input4, pos4, more4, m4){
                 return caml_call4
                         (succ, input4, pos4, more4, caml_call4(f, m1, m2, m3, m4));
                }
                return caml_call5(m4[1], input3, pos3, more3, fail, succ4);
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function symbol$1(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, param){
              return caml_call5(b[1], input, pos, more, fail, succ);
             }
             return caml_call5(a[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol$2(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, x){
              function succ1(input1, pos1, more1, param){
               return caml_call4(succ, input1, pos1, more1, x);
              }
              return caml_call5(b[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(a[1], input, pos, more, fail, succ0);
            }];
   }
   var
    Monad =
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
   function symbol$3(p, mark){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos, more, marks, msg){
              return caml_call5(fail, input, pos, more, [0, mark, marks], msg);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   function symbol$4(p, q){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos$0, more$0, marks, msg){
              return pos < caml_call1(Angstrom_Input[4], input)
                      ? caml_call5(fail, input, pos$0, more, marks, msg)
                      : caml_call5(q[1], input, pos, more$0, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   var
    Choice = [0, symbol$3, symbol$4],
    return$1 = Monad[1],
    fail$0 = Monad[2],
    symbol_bind$0 = Monad[3];
   function symbol_map$0(m, f){
    return caml_call2
            (symbol_bind$0,
             m,
             function(x){return caml_call1(return$1, caml_call1(f, x));});
   }
   function symbol$5(f, m){return symbol_map$0(m, f);}
   function symbol$6(f, m){
    return caml_call2
            (symbol_bind$0, f, function(f){return symbol_map$0(m, f);});
   }
   function lift2$0(f, m1, m2){return symbol$6(symbol_map$0(m1, f), m2);}
   function lift3$0(f, m1, m2, m3){
    return symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3);
   }
   function lift4$0(f, m1, m2, m3, m4){
    return symbol$6(symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3), m4);
   }
   function symbol$7(a, b){
    return caml_call2(symbol_bind$0, a, function(param){return b;});
   }
   function symbol$8(a, b){
    return caml_call2
            (symbol_bind$0,
             a,
             function(x){return symbol_map$0(b, function(param){return x;});});
   }
   var
    Monad_use_for_debugging =
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
    Angstrom_Parser =
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       Choice,
       Monad_use_for_debugging];
   runtime.caml_register_global(4, Angstrom_Parser, "Angstrom__Parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Buffering
//# unitInfo: Requires: Assert_failure, Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_buffering_ml = "lib/buffering.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    _a_ = [0, cst_lib_buffering_ml, 8, 2],
    _b_ = [0, cst_lib_buffering_ml, 7, 2],
    _c_ = [0, cst_lib_buffering_ml, 47, 2],
    _d_ = [0, cst_lib_buffering_ml, 46, 2],
    _e_ = [0, cst_lib_buffering_ml, 54, 2],
    _f_ = [0, cst_lib_buffering_ml, 53, 2],
    _g_ = [0, cst_lib_buffering_ml, 64, 2],
    _h_ = [0, cst_lib_buffering_ml, 79, 2];
   function of_bigstring(off, len, buf){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((len - off | 0) <= caml_call1(Bigstringaf[6], buf))
     return [0, buf, off, len];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function create(len){
    return of_bigstring(0, 0, caml_call1(Bigstringaf[1], len));
   }
   function writable_space(t){
    var _m_ = t[3];
    return caml_call1(Bigstringaf[6], t[1]) - _m_ | 0;
   }
   function ensure(t, to_copy){
    var
     _k_ = t[2] + t[3] | 0,
     _l_ = (caml_call1(Bigstringaf[6], t[1]) - _k_ | 0) < to_copy ? 1 : 0;
    if(! _l_) return _l_;
    if(to_copy <= writable_space(t)){
     caml_call5(Bigstringaf[44], t[1], t[2], t[1], 0, t[3]);
     t[2] = 0;
     return;
    }
    var
     old_len = caml_call1(Bigstringaf[6], t[1]),
     new_len = [0, old_len],
     space = writable_space(t);
    for(;;){
     if(((space + new_len[1] | 0) - old_len | 0) >= to_copy){
      var new_buf = caml_call1(Bigstringaf[1], new_len[1]);
      caml_call5(Bigstringaf[44], t[1], t[2], new_buf, 0, t[3]);
      t[1] = new_buf;
      t[2] = 0;
      return;
     }
     new_len[1] = (3 * new_len[1] | 0) / 2 | 0;
    }
   }
   function write_pos(t){return t[2] + t[3] | 0;}
   function feed_string(t, off, len, str){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if((len - off | 0) > caml_ml_string_length(str))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    ensure(t, len);
    var _j_ = write_pos(t);
    caml_call5(Bigstringaf[45], str, off, t[1], _j_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_bigstring(t, off, len, b){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if((len - off | 0) > caml_call1(Bigstringaf[6], b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    ensure(t, len);
    var _i_ = write_pos(t);
    caml_call5(Bigstringaf[44], b, off, t[1], _i_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_input(t, param){
    if(608227697 <= param[1]){
     var b = param[2];
     return feed_bigstring(t, 0, caml_call1(Bigstringaf[6], b), b);
    }
    var s = param[2];
    return feed_string(t, 0, caml_ml_string_length(s), s);
   }
   function shift(t, n){
    if(n > t[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    t[2] = t[2] + n | 0;
    t[3] = t[3] - n | 0;
    return 0;
   }
   function for_reading(param){
    var buf = param[1], off = param[2], len = param[3];
    return caml_call3(Bigstringaf[5], buf, off, len);
   }
   function unconsumed(opt, param){
    if(opt) var sth = opt[1], shift = sth; else var shift = 0;
    var buf = param[1], off = param[2], len = param[3];
    if(shift <= len) return [0, buf, off + shift | 0, len - shift | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function of_unconsumed(param){
    var len = param[3], off = param[2], buf = param[1];
    return [0, buf, off, len];
   }
   var
    Angstrom_Buffering =
      [0,
       create,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
   runtime.caml_register_global(10, Angstrom_Buffering, "Angstrom__Buffering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom
//# unitInfo: Requires: Angstrom__Buffering, Angstrom__Exported_state, Angstrom__Input, Angstrom__Parser, Bigstringaf, CamlinternalLazy, Stdlib, Stdlib__Char, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_count_while1$1 = "count_while1",
    cst_not_enough_input$1 = "not enough input",
    cst_satisfy = "satisfy: ",
    cst_satisfy_C = "satisfy: %C",
    caml_int32_float_of_bits = runtime.caml_int32_float_of_bits,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Stdlib = global_data.Stdlib,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom_Buffering = global_data.Angstrom__Buffering,
    Angstrom_Parser = global_data.Angstrom__Parser,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    Stdlib_Sys = global_data.Stdlib__Sys,
    parse = Angstrom_Parser[5],
    parse_bigstring = Angstrom_Parser[6],
    state_to_option = Angstrom_Exported_state[1],
    fail_to_string = Angstrom_Exported_state[2],
    state_to_result = Angstrom_Exported_state[3],
    _a_ = Angstrom_Parser[7],
    return$0 = _a_[1],
    fail = _a_[2],
    symbol_bind = _a_[3],
    symbol_map = _a_[4],
    symbol = _a_[5],
    symbol$0 = _a_[6],
    lift = _a_[7],
    lift2 = _a_[8],
    lift3 = _a_[9],
    lift4 = _a_[10],
    symbol$1 = _a_[11],
    symbol$2 = _a_[12],
    include = Angstrom_Parser[8],
    symbol$3 = include[1],
    symbol$4 = include[2],
    cst_parse_invalid_argument_ini =
      "parse: invalid argument, initial_buffer_size < 1",
    _b_ = [1, "incomplete input"],
    cst_prompt_input_shrunk = "prompt: input shrunk!",
    cst_not_enough_input = cst_not_enough_input$1,
    cst_not_enough_input$0 = cst_not_enough_input$1;
   function from_unbuffered_state(f, buffering, param){
    switch(param[0]){
      case 0:
       var p = param[1]; return [0, caml_call1(f, p)];
      case 1:
       var
        v = param[2],
        consumed = param[1],
        unconsumed =
          caml_call2(Angstrom_Buffering[8], [0, consumed], buffering);
       return [1, unconsumed, v];
      default:
       var
        msg = param[3],
        marks = param[2],
        consumed$0 = param[1],
        unconsumed$0 =
          caml_call2(Angstrom_Buffering[8], [0, consumed$0], buffering);
       return [2, unconsumed$0, marks, msg];
    }
   }
   function parse$0(opt, p){
    if(opt)
     var sth = opt[1], initial_buffer_size = sth;
    else
     var initial_buffer_size = 4096;
    if(initial_buffer_size < 1)
     caml_call1(Stdlib[2], cst_parse_invalid_argument_ini);
    var buffering = caml_call1(Angstrom_Buffering[1], initial_buffer_size);
    function f(p, input){
     caml_call2(Angstrom_Buffering[6], buffering, p[1]);
     var
      more =
        typeof input === "number"
         ? 0
         : (caml_call2(Angstrom_Buffering[5], buffering, input), 1),
      for_reading = caml_call1(Angstrom_Buffering[7], buffering),
      _P_ = caml_call1(Bigstringaf[6], for_reading);
     return from_unbuffered_state
             (f, buffering, caml_call4(p[2], for_reading, 0, _P_, more));
    }
    return from_unbuffered_state(f, buffering, caml_call1(parse, p));
   }
   function feed(state, input){
    switch(state[0]){
      case 0:
       var k = state[1]; return caml_call1(k, input);
      case 1:
       var v = state[2], unconsumed = state[1];
       if(typeof input === "number") return state;
       var buffering = caml_call1(Angstrom_Buffering[9], unconsumed);
       caml_call2(Angstrom_Buffering[5], buffering, input);
       return [1, caml_call2(Angstrom_Buffering[8], 0, buffering), v];
      default:
       var msg = state[3], marks = state[2], unconsumed$0 = state[1];
       if(typeof input === "number") return state;
       var buffering$0 = caml_call1(Angstrom_Buffering[9], unconsumed$0);
       caml_call2(Angstrom_Buffering[5], buffering$0, input);
       return [2,
               caml_call2(Angstrom_Buffering[8], 0, buffering$0),
               marks,
               msg];
    }
   }
   function state_to_option$0(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var v = param[2]; return [0, v];
      default: return 0;
    }
   }
   function state_to_result$0(param){
    switch(param[0]){
      case 0:
       return _b_;
      case 1:
       var v = param[2]; return [0, v];
      default:
       var msg = param[3], marks = param[2];
       return [1, caml_call2(fail_to_string, marks, msg)];
    }
   }
   function state_to_unconsumed(param){
    if(0 === param[0]) return 0;
    var unconsumed = param[1];
    return [0, unconsumed];
   }
   function prompt(input, pos, fail, succ){
    var
     parser_uncommitted_bytes = caml_call1(Angstrom_Input[5], input),
     parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
    function continue$0(input, off, len, more){
     if(len < parser_uncommitted_bytes)
      caml_call1(Stdlib[2], cst_prompt_input_shrunk);
     var
      input$0 =
        caml_call4(Angstrom_Input[1], input, off, len, parser_committed_bytes);
     return len === parser_uncommitted_bytes
             ? more
               ? prompt(input$0, pos, fail, succ)
               : caml_call3(fail, input$0, pos, 0)
             : caml_call3(succ, input$0, pos, more);
    }
    return [0, [0, caml_call1(Angstrom_Input[6], input), continue$0]];
   }
   var
    demand_input =
      [0,
       function(input, pos, more, fail, succ){
        if(! more)
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input$0);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail$0(input, pos, more){
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input);
        }
        return prompt(input, pos, fail$0, succ$0);
       }];
   function ensure_suspended(n, input, pos, more, fail, succ){
    var go = [];
    caml_update_dummy
     (go,
      [0,
       function(input, pos, more, fail, succ){
        return (pos + n | 0) <= caml_call1(Angstrom_Input[2], input)
                ? caml_call4(succ, input, pos, more, 0)
                : caml_call5
                  (caml_call2(symbol$1, demand_input, go)[1],
                   input,
                   pos,
                   more,
                   fail,
                   succ);
       }]);
    return caml_call5
            (caml_call2(symbol$1, demand_input, go)[1],
             input,
             pos,
             more,
             fail,
             succ);
   }
   function unsafe_apply(len, f){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4
                     (succ,
                      input,
                      pos + len | 0,
                      more,
                      caml_call4(Angstrom_Input[15], input, pos, len, f));
            }];
   }
   function ensure(n, p){
    return [0,
            function(input, pos, more, fail, succ){
             if((pos + n | 0) <= caml_call1(Angstrom_Input[2], input))
              return caml_call5(p[1], input, pos, more, fail, succ);
             function succ$0(input, pos, more, param){
              return caml_call5(p[1], input, pos, more, fail, succ);
             }
             return ensure_suspended(n, input, pos, more, fail, succ$0);
            }];
   }
   var
    at_end_of_input =
      [0,
       function(input, pos, more, param, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4(succ, input, pos, more, 0);
        if(! more) return caml_call4(succ, input, pos, more, 1);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail(input, pos, more){
         return caml_call4(succ, input, pos, more, 1);
        }
        return prompt(input, pos, fail, succ$0);
       }],
    cst_end_of_input = "end_of_input",
    end_of_input =
      caml_call2
       (symbol_bind,
        at_end_of_input,
        function(param){
         return param
                 ? caml_call1(return$0, 0)
                 : caml_call1(fail, cst_end_of_input);
        }),
    cst_advance = "advance";
   function advance(n){
    if(0 > n) return caml_call1(fail, cst_advance);
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call4(succ, input, pos + n | 0, more, 0);
        }];
    return ensure(n, p);
   }
   var
    pos =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4(succ, input, pos, more, pos);
       }],
    available =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call1(Angstrom_Input[2], input) - pos | 0);
       }],
    commit =
      [0,
       function(input, pos, more, fail, succ){
        caml_call2(Angstrom_Input[16], input, pos);
        return caml_call4(succ, input, pos, more, 0);
       }];
   function unsafe_lookahead(p){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, param, more, v){
              return caml_call4(succ, input, pos, more, v);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   var
    peek_char =
      [0,
       function(input, pos, more, fail, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        if(0 === more) return caml_call4(succ, input, pos, more, 0);
        function succ$0(input, pos, more){
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        }
        function fail$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        return prompt(input, pos, fail$0, succ$0);
       }],
    peek_char_fail = [];
   caml_update_dummy
    (peek_char_fail,
     [0,
      function(input, pos, more, fail, succ){
       if(pos < caml_call1(Angstrom_Input[2], input))
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       function succ$0(input, pos, more, param){
        return caml_call5(peek_char_fail[1], input, pos, more, fail, succ);
       }
       return ensure_suspended(1, input, pos, more, fail, succ$0);
      }]);
   var
    _c_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _d_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _e_ = [0, [11, "char ", [1, 0]], "char %C"],
    _f_ = [0, [11, "not char ", [1, 0]], "not char %C"];
   function satisfy(f){
    return [0,
            function(input, pos, more, fail, succ){
             if(pos >= caml_call1(Angstrom_Input[2], input)){
              var
               succ$0 =
                 function(input, pos, more, param){
                  var c = caml_call2(Angstrom_Input[7], input, pos);
                  if(caml_call1(f, c))
                   return caml_call4(succ, input, pos + 1 | 0, more, c);
                  var _O_ = caml_call4(fail, input, pos, more, 0);
                  return caml_call3(Stdlib_Printf[10], _O_, _d_, c);
                 };
              return ensure_suspended(1, input, pos, more, fail, succ$0);
             }
             var c = caml_call2(Angstrom_Input[7], input, pos);
             if(caml_call1(f, c))
              return caml_call4(succ, input, pos + 1 | 0, more, c);
             var _N_ = caml_call4(fail, input, pos, more, 0);
             return caml_call3(Stdlib_Printf[10], _N_, _c_, c);
            }];
   }
   function char$0(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[7], input, pos) === c
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _e_, c));
        }];
    return ensure(1, p);
   }
   function not_char(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c$0 = caml_call2(Angstrom_Input[7], input, pos);
         return c !== c$0
                 ? caml_call4(succ, input, pos + 1 | 0, more, c$0)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _f_, c));
        }];
    return ensure(1, p);
   }
   var
    p =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos + 1 | 0,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       }],
    any_char = ensure(1, p),
    _g_ = [0, [11, "int8 ", [4, 0, 0, 0, 0]], "int8 %d"];
   function int8(i){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c = caml_call2(Angstrom_Input[7], input, pos);
         return c === (i & 255)
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _g_, i));
        }];
    return ensure(1, p);
   }
   var
    p$0 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c);
       }],
    any_uint8 = ensure(1, p$0),
    s = Stdlib_Sys[10] - 8 | 0,
    p$1 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c << s >> s);
       }],
    any_int8 = ensure(1, p$1),
    cst_skip = "skip",
    cst_count_while1 = cst_count_while1$1,
    cst_count_while1$0 = cst_count_while1$1,
    _h_ = [1, "string"],
    cst_take_n_0 = "take: n < 0",
    cst_take_bigstring_n_0 = "take_bigstring: n < 0",
    cst_no_more_choices = "no more choices";
   function skip(f){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call1(f, caml_call2(Angstrom_Input[7], input, pos))
                 ? caml_call4(succ, input, pos + 1 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_skip);
        }];
    return ensure(1, p);
   }
   function count_while(init, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos + init | 0, f),
              input_len = caml_call1(Angstrom_Input[2], input),
              init$0 = init + len | 0;
             if((pos + init$0 | 0) >= input_len && 0 !== more){
              var
               succ$0 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while(init$0, f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$0 =
                 function(input, pos, more){
                  return caml_call4
                          (succ,
                           input,
                           pos + init$0 | 0,
                           more,
                           caml_call4
                            (Angstrom_Input[15], input, pos, init$0, with_buffer));
                 };
              return prompt(input, pos, fail$0, succ$0);
             }
             return caml_call4
                     (succ,
                      input,
                      pos + init$0 | 0,
                      more,
                      caml_call4
                       (Angstrom_Input[15], input, pos, init$0, with_buffer));
            }];
   }
   function count_while1(f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos, f),
              input_len = caml_call1(Angstrom_Input[2], input);
             if(1 <= len){
              if((pos + len | 0) >= input_len && 0 !== more){
               var
                succ$0 =
                  function(input, pos, more){
                   return caml_call5
                           (count_while(len, f, with_buffer)[1],
                            input,
                            pos,
                            more,
                            fail,
                            succ);
                  },
                fail$0 =
                  function(input, pos, more){
                   return caml_call4
                           (succ,
                            input,
                            pos + len | 0,
                            more,
                            caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
                  };
               return prompt(input, pos, fail$0, succ$0);
              }
              return caml_call4
                      (succ,
                       input,
                       pos + len | 0,
                       more,
                       caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
             }
             if(pos >= input_len && 0 !== more){
              var
               succ$1 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while1(f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$1 =
                 function(input, pos, more){
                  return caml_call5
                          (fail, input, pos, more, 0, cst_count_while1$0);
                 };
              return prompt(input, pos, fail$1, succ$1);
             }
             return caml_call5(fail, input, pos, more, 0, cst_count_while1);
            }];
   }
   function string(f, s){
    var len = caml_ml_string_length(s);
    function f$0(buffer, off, len){
     var i = [0, 0];
     for(;;){
      if(i[1] < len){
       var
        _L_ = caml_call1(f, runtime.caml_string_unsafe_get(s, i[1])),
        _M_ = caml_call1(f, runtime.caml_ba_get_1(buffer, off + i[1] | 0));
       if(caml_call2(Stdlib_Char[8], _M_, _L_)){i[1]++; continue;}
      }
      return len === i[1]
              ? [0, caml_call3(Bigstringaf[7], buffer, off, len)]
              : _h_;
     }
    }
    return ensure
            (len,
             [0,
              function(input, pos, more, fail, succ){
               var
                match = caml_call4(Angstrom_Input[15], input, pos, len, f$0);
               if(0 === match[0]){
                var x = match[1];
                return caml_call4(succ, input, pos + len | 0, more, x);
               }
               var e = match[1];
               return caml_call5(fail, input, pos, more, 0, e);
              }]);
   }
   function string$0(s){return string(function(x){return x;}, s);}
   function string_ci(s){return string(Stdlib_Char[5], s);}
   function skip_while(f){
    return count_while(0, f, function(param, _K_, _J_){return 0;});
   }
   function take(n){
    if(0 > n) return caml_call1(fail, cst_take_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[7]));
   }
   function take_bigstring(n){
    if(0 > n) return caml_call1(fail, cst_take_bigstring_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[4]));
   }
   function take_bigstring_while(f){return count_while(0, f, Bigstringaf[4]);}
   function take_bigstring_while1(f){return count_while1(f, Bigstringaf[4]);}
   function take_bigstring_till(f){
    return take_bigstring_while(function(c){return 1 - caml_call1(f, c);});
   }
   function peek_string(n){return unsafe_lookahead(take(n));}
   function take_while(f){return count_while(0, f, Bigstringaf[7]);}
   function take_while1(f){return count_while1(f, Bigstringaf[7]);}
   function take_till(f){
    return take_while(function(c){return 1 - caml_call1(f, c);});
   }
   function choice(opt, ps){
    if(opt)
     var sth = opt[1], failure_msg = sth;
    else
     var failure_msg = cst_no_more_choices;
    var _I_ = caml_call1(fail, failure_msg);
    return caml_call3(Stdlib_List[26], symbol$4, ps, _I_);
   }
   function fix_direct(f){
    var p = [], r = [];
    caml_update_dummy(p, [246, function(_H_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        var
         _F_ = caml_obj_tag(p),
         _G_ =
           250 === _F_
            ? p[1]
            : 246 === _F_ ? caml_call1(CamlinternalLazy[2], p) : p;
        return caml_call5(_G_[1], buf, pos, more, fail, succ);
       }]);
    return r;
   }
   function fix_lazy(max_steps, f){
    var steps = [0, max_steps], p = [], r = [];
    caml_update_dummy(p, [246, function(_E_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        steps[1]--;
        if(0 <= steps[1]){
         var
          _z_ = caml_obj_tag(p),
          _A_ =
            250 === _z_
             ? p[1]
             : 246 === _z_ ? caml_call1(CamlinternalLazy[2], p) : p;
         return caml_call5(_A_[1], buf, pos, more, fail, succ);
        }
        steps[1] = max_steps;
        return [1,
                [246,
                 function(_B_){
                  var
                   _C_ = caml_obj_tag(p),
                   _D_ =
                     250 === _C_
                      ? p[1]
                      : 246 === _C_ ? caml_call1(CamlinternalLazy[2], p) : p;
                  return caml_call5(_D_[1], buf, pos, more, fail, succ);
                 }]];
       }]);
    return r;
   }
   var
    _i_ = Stdlib_Sys[5],
    cst_LE_int64 = "LE.int64",
    cst_LE_int32 = "LE.int32",
    cst_LE_int16 = "LE.int16",
    cst_BE_int64 = "BE.int64",
    cst_BE_int32 = "BE.int32",
    cst_BE_int16 = "BE.int16",
    cst_consumed_parser_committed = "consumed: parser committed",
    cst_count_n_0 = "count: n < 0",
    cst_end_of_line = "end_of_line",
    fix =
      typeof _i_ === "number"
       ? _i_ ? fix_direct : fix_direct
       : function(f){return fix_lazy(20, f);};
   function option(x, p){
    return caml_call2(symbol$4, p, caml_call1(return$0, x));
   }
   function cons(x, xs){return [0, x, xs];}
   function list(ps){
    if(! ps) return caml_call1(return$0, 0);
    var ps$0 = ps[2], p = ps[1];
    return caml_call3(lift2, cons, p, list(ps$0));
   }
   function count(n, p){
    if(0 > n) return caml_call1(fail, cst_count_n_0);
    function loop(n){
     return 0 === n
             ? caml_call1(return$0, 0)
             : caml_call3(lift2, cons, p, loop(n - 1 | 0));
    }
    return loop(n);
   }
   function many(p){
    return fix
            (function(m){
              var _y_ = caml_call1(return$0, 0);
              return caml_call2(symbol$4, caml_call3(lift2, cons, p, m), _y_);
             });
   }
   function many1(p){return caml_call3(lift2, cons, p, many(p));}
   function many_till(p, t){
    return fix
            (function(m){
              var _x_ = caml_call3(lift2, cons, p, m);
              return caml_call2
                      (symbol$4,
                       caml_call2(symbol$1, t, caml_call1(return$0, 0)),
                       _x_);
             });
   }
   function sep_by1(s, p){
    return fix
            (function(m){
              var _w_ = caml_call1(return$0, 0);
              return caml_call3
                      (lift2,
                       cons,
                       p,
                       caml_call2(symbol$4, caml_call2(symbol$1, s, m), _w_));
             });
   }
   function sep_by(s, p){
    var _u_ = caml_call1(return$0, 0), _v_ = caml_call1(return$0, 0);
    return caml_call2
            (symbol$4,
             caml_call3
              (lift2,
               cons,
               p,
               caml_call2
                (symbol$4, caml_call2(symbol$1, s, sep_by1(s, p)), _v_)),
             _u_);
   }
   function skip_many(p){
    return fix
            (function(m){
              var _t_ = caml_call1(return$0, 0);
              return caml_call2
                      (symbol_bind,
                       caml_call2
                        (symbol$4,
                         caml_call2(symbol_map, p, function(param){return 1;}),
                         _t_),
                       function(param){return param ? m : caml_call1(return$0, 0);});
             });
   }
   function skip_many1(p){return caml_call2(symbol$1, p, skip_many(p));}
   var
    _j_ = caml_call1(return$0, 0),
    _k_ = caml_call2(symbol$1, string$0(cst), _j_),
    _l_ = caml_call1(return$0, 0),
    end_of_line =
      caml_call2
       (symbol$3,
        caml_call2(symbol$4, caml_call2(symbol$1, char$0(10), _l_), _k_),
        cst_end_of_line);
   function scan(state, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              state$0 = [0, state],
              parser =
                caml_call2
                 (symbol_map,
                  count_while
                   (0,
                    function(c){
                     var match = caml_call2(f, state$0[1], c);
                     if(! match) return 0;
                     var state = match[1];
                     state$0[1] = state;
                     return 1;
                    },
                    with_buffer),
                  function(x){return [0, x, state$0[1]];});
             return caml_call5(parser[1], input, pos, more, fail, succ);
            }];
   }
   function scan$0(state, f){return scan(state, f, Bigstringaf[7]);}
   function scan_state(state, f){
    return caml_call2
            (symbol_map,
             scan(state, f, function(param, _s_, _r_){return 0;}),
             function(param){var state = param[2]; return state;});
   }
   function scan_string(state, f){
    return caml_call2
            (symbol_map, scan$0(state, f), function(_q_){return _q_[1];});
   }
   function consume_with(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             var
              parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
             function succ$0(input, pos$0, more, param){
              if
               (parser_committed_bytes
                !== caml_call1(Angstrom_Input[4], input))
               return caml_call5
                       (fail, input, pos$0, more, 0, cst_consumed_parser_committed);
              var
               len = pos$0 - pos | 0,
               consumed = caml_call4(Angstrom_Input[15], input, pos, len, f);
              return caml_call4(succ, input, pos$0, more, consumed);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function consumed(p){return consume_with(p, Bigstringaf[7]);}
   function consumed_bigstring(p){return consume_with(p, Bigstringaf[4]);}
   function both(a, b){
    return caml_call3(lift2, function(a, b){return [0, a, b];}, a, b);
   }
   function map(t, f){return caml_call2(symbol_map, t, f);}
   function bind(t, f){return caml_call2(symbol_bind, t, f);}
   function map2(a, b, f){return caml_call3(lift2, f, a, b);}
   function map3(a, b, c, f){return caml_call4(lift3, f, a, b, c);}
   function map4(a, b, c, d, f){return caml_call5(lift4, f, a, b, c, d);}
   var
    Let_syntax = [0, return$0, map, bind, both, map2, map3, map4],
    Let_syntax$0 = [0, return$0, symbol_map, symbol_bind, Let_syntax];
   function int16(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[11], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int16);
        }];
    return ensure(2, p);
   }
   function int32(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _p_ = caml_call2(Angstrom_Input[12], input, pos);
         return caml_call2(Stdlib_Int32[17], _p_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int32);
        }];
    return ensure(4, p);
   }
   function int64(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _o_ = caml_call2(Angstrom_Input[13], input, pos);
         return caml_call2(Stdlib_Int64[17], _o_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[31], bs, off);
          })),
    any_int16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[33], bs, off);
          })),
    any_int32 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[37], bs, off);
          })),
    any_int64 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[41], bs, off);
          })),
    any_float =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[37], bs, off));
          })),
    any_double =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[41], bs, off));
          }));
   function int16$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[8], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int16);
        }];
    return ensure(2, p);
   }
   function int32$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _n_ = caml_call2(Angstrom_Input[9], input, pos);
         return caml_call2(Stdlib_Int32[17], _n_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int32);
        }];
    return ensure(4, p);
   }
   function int64$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _m_ = caml_call2(Angstrom_Input[10], input, pos);
         return caml_call2(Stdlib_Int64[17], _m_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[30], bs, off);
          })),
    any_int16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[32], bs, off);
          })),
    any_int32$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[36], bs, off);
          })),
    any_int64$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[40], bs, off);
          })),
    any_float$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[36], bs, off));
          })),
    any_double$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[40], bs, off));
          }));
   function take$0(n, f){
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, f));
   }
   function peek(n, f){return unsafe_lookahead(take$0(n, f));}
   function take_while$0(check, f){return count_while(0, check, f);}
   function take_while1$0(check, f){return count_while1(check, f);}
   function take_till$0(check, f){
    return take_while$0(function(c){return 1 - caml_call1(check, c);}, f);
   }
   var Consume = [0];
   function parse_bigstring$0(consume, p, bs){
    var p$0 = consume ? caml_call2(symbol$2, p, end_of_input) : p;
    return caml_call2(parse_bigstring, p$0, bs);
   }
   function parse_string(consume, p, s){
    var len = caml_ml_string_length(s), bs = caml_call1(Bigstringaf[1], len);
    caml_call5(Bigstringaf[45], s, 0, bs, 0, len);
    return parse_bigstring$0(consume, p, bs);
   }
   var
    Angstrom =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol$4,
       choice,
       symbol$3,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$0,
       symbol,
       symbol$1,
       symbol$2,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map,
       symbol_bind,
       both,
       [0, take$0, take_while$0, take_while1$0, take_till$0, peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0, parse, state_to_option, state_to_result],
       pos,
       available];
   runtime.caml_register_global(42, Angstrom, "Angstrom");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RhdGVfdG9fb3B0aW9uIiwieCIsInYiLCJmYWlsX3RvX3N0cmluZyIsIm1hcmtzIiwiZXJyIiwic3RhdGVfdG9fcmVzdWx0IiwiY3JlYXRlIiwiYnVmZmVyIiwib2ZmIiwibGVuIiwiY29tbWl0dGVkX2J5dGVzIiwibGVuZ3RoIiwidCIsImNsaWVudF9jb21taXR0ZWRfYnl0ZXMiLCJwYXJzZXJfY29tbWl0dGVkX2J5dGVzIiwiYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQiLCJwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMiLCJpbnZhcmlhbnQiLCJvZmZzZXRfaW5fYnVmZmVyIiwicG9zIiwiYXBwbHkiLCJmIiwidW5zYWZlX2dldF9jaGFyIiwidW5zYWZlX2dldF9pbnQxNl9sZSIsInVuc2FmZV9nZXRfaW50MzJfbGUiLCJ1bnNhZmVfZ2V0X2ludDY0X2xlIiwidW5zYWZlX2dldF9pbnQxNl9iZSIsInVuc2FmZV9nZXRfaW50MzJfYmUiLCJ1bnNhZmVfZ2V0X2ludDY0X2JlIiwiY291bnRfd2hpbGUiLCJpIiwibGltaXQiLCJjb21taXQiLCJmYWlsX2siLCJpbnB1dCIsIm1zZyIsInN1Y2NlZWRfayIsInRvX2V4cG9ydGVkX3N0YXRlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsImJzIiwibW9yZSIsIngkMCIsInMiLCJzbCIsImkkMCIsInBhcnNlIiwicCIsInBhcnNlX2JpZ3N0cmluZyIsImlucHV0JDAiLCJyZXR1cm4kMCIsImZhaWwiLCJzdWNjIiwic3ltYm9sX2JpbmQiLCJzdWNjJDAiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibSIsInN5bWJvbCQwIiwic3VjYzAiLCJpbnB1dDAiLCJwb3MwIiwibW9yZTAiLCJzdWNjMSIsImlucHV0MSIsInBvczEiLCJtb3JlMSIsImxpZnQiLCJsaWZ0MiIsIm0xIiwibTIiLCJzdWNjMiIsImlucHV0MiIsInBvczIiLCJtb3JlMiIsImxpZnQzIiwibTMiLCJzdWNjMyIsImlucHV0MyIsInBvczMiLCJtb3JlMyIsImxpZnQ0IiwibTQiLCJzdWNjNCIsImlucHV0NCIsInBvczQiLCJtb3JlNCIsInN5bWJvbCQxIiwiYSIsImIiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwibWFyayIsImZhaWwkMCIsInN5bWJvbCQ0IiwicSIsInBvcyQwIiwibW9yZSQwIiwicmV0dXJuJDEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsImxpZnQyJDAiLCJsaWZ0MyQwIiwibGlmdDQkMCIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJvZl9iaWdzdHJpbmciLCJidWYiLCJ3cml0YWJsZV9zcGFjZSIsImVuc3VyZSIsInRvX2NvcHkiLCJvbGRfbGVuIiwibmV3X2xlbiIsInNwYWNlIiwibmV3X2J1ZiIsIndyaXRlX3BvcyIsImZlZWRfc3RyaW5nIiwic3RyIiwiZmVlZF9iaWdzdHJpbmciLCJmZWVkX2lucHV0Iiwic2hpZnQiLCJuIiwiZm9yX3JlYWRpbmciLCJ1bmNvbnN1bWVkIiwib3B0Iiwic3RoIiwib2ZfdW5jb25zdW1lZCIsImZyb21fdW5idWZmZXJlZF9zdGF0ZSIsImJ1ZmZlcmluZyIsImNvbnN1bWVkIiwiY29uc3VtZWQkMCIsInVuY29uc3VtZWQkMCIsInBhcnNlJDAiLCJpbml0aWFsX2J1ZmZlcl9zaXplIiwiZmVlZCIsInN0YXRlIiwiayIsImJ1ZmZlcmluZyQwIiwic3RhdGVfdG9fb3B0aW9uJDAiLCJzdGF0ZV90b19yZXN1bHQkMCIsInN0YXRlX3RvX3VuY29uc3VtZWQiLCJwcm9tcHQiLCJkZW1hbmRfaW5wdXQiLCJlbnN1cmVfc3VzcGVuZGVkIiwiZ28iLCJ1bnNhZmVfYXBwbHkiLCJhdF9lbmRfb2ZfaW5wdXQiLCJlbmRfb2ZfaW5wdXQiLCJhZHZhbmNlIiwiYXZhaWxhYmxlIiwidW5zYWZlX2xvb2thaGVhZCIsInBlZWtfY2hhciIsInBlZWtfY2hhcl9mYWlsIiwic2F0aXNmeSIsImMiLCJjaGFyJDAiLCJub3RfY2hhciIsImMkMCIsImFueV9jaGFyIiwiaW50OCIsInAkMCIsImFueV91aW50OCIsInAkMSIsImFueV9pbnQ4Iiwic2tpcCIsImluaXQiLCJ3aXRoX2J1ZmZlciIsImlucHV0X2xlbiIsImluaXQkMCIsImNvdW50X3doaWxlMSIsInN1Y2MkMSIsImZhaWwkMSIsInN0cmluZyIsImYkMCIsImUiLCJzdHJpbmckMCIsInN0cmluZ19jaSIsInNraXBfd2hpbGUiLCJ0YWtlIiwibiQwIiwidGFrZV9iaWdzdHJpbmciLCJ0YWtlX2JpZ3N0cmluZ193aGlsZSIsInRha2VfYmlnc3RyaW5nX3doaWxlMSIsInRha2VfYmlnc3RyaW5nX3RpbGwiLCJwZWVrX3N0cmluZyIsInRha2Vfd2hpbGUiLCJ0YWtlX3doaWxlMSIsInRha2VfdGlsbCIsImNob2ljZSIsInBzIiwiZmFpbHVyZV9tc2ciLCJmaXhfZGlyZWN0IiwiciIsImZpeF9sYXp5IiwibWF4X3N0ZXBzIiwic3RlcHMiLCJmaXgiLCJvcHRpb24iLCJjb25zIiwieHMiLCJsaXN0IiwicHMkMCIsImNvdW50IiwibG9vcCIsIm1hbnkiLCJtYW55MSIsIm1hbnlfdGlsbCIsInNlcF9ieTEiLCJzZXBfYnkiLCJza2lwX21hbnkiLCJza2lwX21hbnkxIiwiZW5kX29mX2xpbmUiLCJzY2FuIiwic3RhdGUkMCIsInBhcnNlciIsInNjYW4kMCIsInNjYW5fc3RhdGUiLCJzY2FuX3N0cmluZyIsImNvbnN1bWVfd2l0aCIsImNvbnN1bWVkX2JpZ3N0cmluZyIsImJvdGgiLCJtYXAiLCJiaW5kIiwibWFwMiIsIm1hcDMiLCJtYXA0IiwiZCIsImludDE2IiwiaW50MzIiLCJpbnQ2NCIsImFueV91aW50MTYiLCJhbnlfaW50MTYiLCJhbnlfaW50MzIiLCJhbnlfaW50NjQiLCJhbnlfZmxvYXQiLCJhbnlfZG91YmxlIiwiaW50MTYkMCIsImludDMyJDAiLCJpbnQ2NCQwIiwiYW55X3VpbnQxNiQwIiwiYW55X2ludDE2JDAiLCJhbnlfaW50MzIkMCIsImFueV9pbnQ2NCQwIiwiYW55X2Zsb2F0JDAiLCJhbnlfZG91YmxlJDAiLCJ0YWtlJDAiLCJwZWVrIiwidGFrZV93aGlsZSQwIiwiY2hlY2siLCJ0YWtlX3doaWxlMSQwIiwidGFrZV90aWxsJDAiLCJwYXJzZV9iaWdzdHJpbmckMCIsImNvbnN1bWUiLCJwYXJzZV9zdHJpbmciXSwic291cmNlcyI6WyIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYW5nc3Ryb20vZXhwb3J0ZWRfc3RhdGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYW5nc3Ryb20vaW5wdXQubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYW5nc3Ryb20vcGFyc2VyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FuZ3N0cm9tL2J1ZmZlcmluZy5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hbmdzdHJvbS9hbmdzdHJvbS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7OztZQVVJQSxnQkFBZ0JDO0lBQUksT0FBSkE7O09BR0Y7O1dBRk5DLElBRFFELE1BQ0YsV0FBTkM7ZUFDTTs7R0FDSTtZQUVsQkMsZUFBZUMsT0FBTUM7SUFDdkI7S0FBNEIsTUFBQSw0QkFETEE7S0FDdkIsTUFBQSxvQ0FEaUJEO0lBQ1csT0FBQTtHQUFVO1lBRXBDRSxnQkFBZ0JMO0lBQUksT0FBSkE7O09BRU87O1dBRGZDLElBRFFELE1BQ08sV0FBZkM7O1dBRU9HLE1BSENKLE1BR1JHLFFBSFFILE1BR08sV0FOdkJFLGVBTVFDLE9BQU9DOztHQUF3Qzs7O1VBWHZETCxpQkFLQUcsZ0JBR0FHOzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7WUN1QkFDLE9BQU9DLFFBQVFDLEtBQUtDLEtBQUtDO0lBQzNCLFdB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QU1FO1lBRTdCdU4sYUFBY0QsU0FBUS9NLEdBQUVKO0lBQzFCLElBQUlsQyw0QkFEc0JrQyxJQUV0QkgsS0FBTSwyQkFETi9CO0lBRUosNEJBSDBCa0MsTUFFdEJILE9BREEvQjtJQUVKLE9BWEVvUCxrQkFRY0MsU0FBUS9NLEdBRXBCUDtHQUV5Qjs7OztPQWpmM0JpSDtPQWVJQztPQWtMSmdDO09BekpBN0I7T0FTQUM7T0FVQUU7T0FuQ0FMO09BNElBc0I7T0FDQUM7T0F2RUFaO09BeUVBYTtPQUdBQztPQTBCQU87T0FHQUM7T0FHQUM7T0EwSEExRDtPQW5KQW1EO09BT0FDO09BR0FDO09BR0FDO09BdUlBb0M7T0FqV0F2RTtPQXVUQStEO09BelVBakU7T0FZQUM7T0E2VUFvRTtPQUdBQztPQUlBQztPQWhQQTFEO09BVUFFO09BUUFFOztRQXFSRWdFO1FBVUFDO1FBVUFDO1FBYUFFO1FBR0FDO1FBR0FDO1FBVEFIO1FBWUFJO1FBR0FDOztRQUtBQztRQVVBQztRQVVBQztRQWNBRTtRQUdBQztRQUdBQztRQVRBSDtRQVlBSTtRQUdBQztPQTlORi9DO09BNEZBdUI7T0F2RklwQjtPQUtKRTtPQVVBRTtPQUlBQztPQUdBQztPQVFBRTtPQUpBRDtPQU9BRTtPQU9BQztPQWxEQWQ7T0FmQUg7O09BVkFMOztPQXhOQTlKOzs7O09Bb1ZBZ007Ozs7Ozs7Ozs7T0FEQUQ7T0FFQUU7T0FDQUM7T0FDQUM7Ozs7T0FMQUw7V0F1SUV5QixRQU9BRSxjQUdBRSxlQUdBQyxhQVRBSjs7T0FtQkZLO09BUUFFOztRQXRwQkV6SDtRQW9CQUU7UUFvQkFJO1FBS0FDO1FBS0FDOztPQW9HRjNIO09BR0FvSTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlICdhIHN0YXRlID1cbiAgfCBQYXJ0aWFsIG9mICdhIHBhcnRpYWxcbiAgfCBEb25lICAgIG9mIGludCAqICdhXG4gIHwgRmFpbCAgICBvZiBpbnQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG5hbmQgJ2EgcGFydGlhbCA9XG4gIHsgY29tbWl0dGVkIDogaW50XG4gIDsgY29udGludWUgIDogQmlnc3RyaW5nYWYudCAtPiBvZmY6aW50IC0+IGxlbjppbnQgLT4gTW9yZS50IC0+ICdhIHN0YXRlIH1cblxuXG5sZXQgc3RhdGVfdG9fb3B0aW9uIHggPSBtYXRjaCB4IHdpdGhcbiAgfCBEb25lKF8sIHYpIC0+IFNvbWUgdlxuICB8IEZhaWwgXyAgICAgLT4gTm9uZVxuICB8IFBhcnRpYWwgXyAgLT4gTm9uZVxuXG5sZXQgZmFpbF90b19zdHJpbmcgbWFya3MgZXJyID1cbiAgU3RyaW5nLmNvbmNhdCBcIiA+IFwiIG1hcmtzIF4gXCI6IFwiIF4gZXJyXG5cbmxldCBzdGF0ZV90b19yZXN1bHQgeCA9IG1hdGNoIHggd2l0aFxuICB8IERvbmUoXywgdikgICAgICAgICAgLT4gT2sgdlxuICB8IFBhcnRpYWwgXyAgICAgICAgICAgLT4gRXJyb3IgXCJpbmNvbXBsZXRlIGlucHV0XCJcbiAgfCBGYWlsKF8sIG1hcmtzLCBlcnIpIC0+IEVycm9yIChmYWlsX3RvX3N0cmluZyBtYXJrcyBlcnIpXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIDogaW50XG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyAgICAgICAgIDogaW50XG4gIDsgb2ZmICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgbGVuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIDogQmlnc3RyaW5nYWYudFxuICB9XG5cbmxldCBjcmVhdGUgYnVmZmVyIH5vZmYgfmxlbiB+Y29tbWl0dGVkX2J5dGVzID1cbiAgeyBwYXJzZXJfY29tbWl0dGVkX2J5dGVzID0gY29tbWl0dGVkX2J5dGVzXG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyA9IGNvbW1pdHRlZF9ieXRlc1xuICA7IG9mZlxuICA7IGxlblxuICA7IGJ1ZmZlciB9XG5cbmxldCBsZW5ndGggICAgICAgICAgICAgICAgIHQgPSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgKyB0LmxlblxubGV0IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgdCA9IHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xubGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCA9IHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlc1xuXG5sZXQgY29tbWl0dGVkX2J5dGVzX2Rpc2NyZXBhbmN5IHQgPSB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgLSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcbmxldCBieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCAgdCA9IGNvbW1pdHRlZF9ieXRlc19kaXNjcmVwYW5jeSB0XG5cbmxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdCA9IHQubGVuIC0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdFxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCArIHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0ID0gbGVuZ3RoIHQpO1xuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCAtIGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgICB0ID0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdCk7XG47O1xuXG5sZXQgb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyA9XG4gIHQub2ZmICsgcG9zIC0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5cbmxldCBhcHBseSB0IHBvcyBsZW4gfmYgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBmIHQuYnVmZmVyIH5vZmYgfmxlblxuXG5sZXQgdW5zYWZlX2dldF9jaGFyIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IGNvdW50X3doaWxlIHQgcG9zIH5mID1cbiAgbGV0IGJ1ZmZlciA9IHQuYnVmZmVyIGluXG4gIGxldCBvZmYgICAgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIGxldCBpICAgICAgPSByZWYgb2ZmIGluXG4gIGxldCBsaW1pdCAgPSB0Lm9mZiArIHQubGVuIGluXG4gIHdoaWxlICFpIDwgbGltaXQgJiYgZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gICFpIC0gb2ZmXG47O1xuXG5sZXQgY29tbWl0IHQgcG9zID1cbiAgdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIDwtIHBvc1xuOztcbiIsIm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgUGFydGlhbCBvZiAnYSBwYXJ0aWFsXG4gICAgfCBMYXp5ICAgIG9mICdhIHQgTGF6eS50XG4gICAgfCBEb25lICAgIG9mIGludCAqICdhXG4gICAgfCBGYWlsICAgIG9mIGludCAqIHN0cmluZyBsaXN0ICogc3RyaW5nXG5cbiAgYW5kICdhIHBhcnRpYWwgPVxuICAgIHsgY29tbWl0dGVkIDogaW50XG4gICAgOyBjb250aW51ZSAgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiBNb3JlLnQgLT4gJ2EgdCB9XG5cbmVuZFxudHlwZSAnYSB3aXRoX3N0YXRlID0gSW5wdXQudCAtPiAgaW50IC0+IE1vcmUudCAtPiAnYVxuXG50eXBlICdhIGZhaWx1cmUgPSAoc3RyaW5nIGxpc3QgLT4gc3RyaW5nIC0+ICdhIFN0YXRlLnQpIHdpdGhfc3RhdGVcbnR5cGUgKCdhLCAncikgc3VjY2VzcyA9ICgnYSAtPiAnciBTdGF0ZS50KSB3aXRoX3N0YXRlXG5cbnR5cGUgJ2EgdCA9XG4gIHsgcnVuIDogJ3IuICgnciBmYWlsdXJlIC0+ICgnYSwgJ3IpIHN1Y2Nlc3MgLT4gJ3IgU3RhdGUudCkgd2l0aF9zdGF0ZSB9XG5cbmxldCBmYWlsX2sgICAgaW5wdXQgcG9zIF8gbWFya3MgbXNnID1cbiAgU3RhdGUuRmFpbChwb3MgLSBJbnB1dC5jbGllbnRfY29tbWl0dGVkX2J5dGVzIGlucHV0LCBtYXJrcywgbXNnKVxubGV0IHN1Y2NlZWRfayBpbnB1dCBwb3MgXyAgICAgICB2ICAgPVxuICBTdGF0ZS5Eb25lKHBvcyAtIElucHV0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgaW5wdXQsIHYpXG5cbmxldCByZWMgdG9fZXhwb3J0ZWRfc3RhdGUgPSBmdW5jdGlvblxuICB8IFN0YXRlLlBhcnRpYWwge2NvbW1pdHRlZDtjb250aW51ZX0gLT5cbiAgICAgRXhwb3J0ZWRfc3RhdGUuUGFydGlhbFxuICAgICAgIHsgY29tbWl0dGVkXG4gICAgICAgOyBjb250aW51ZSA9XG4gICAgICAgICAgIGZ1biBicyB+b2ZmIH5sZW4gbW9yZSAtPlxuICAgICAgICAgICB0b19leHBvcnRlZF9zdGF0ZSAoY29udGludWUgYnMgfm9mZiB+bGVuIG1vcmUpfVxuICB8IFN0YXRlLkRvbmUgKGkseCkgLT4gRXhwb3J0ZWRfc3RhdGUuRG9uZSAoaSx4KVxuICB8IFN0YXRlLkZhaWwgKGksIHNsLCBzKSAtPiBFeHBvcnRlZF9zdGF0ZS5GYWlsIChpLCBzbCwgcylcbiAgfCBTdGF0ZS5MYXp5IHggLT4gdG9fZXhwb3J0ZWRfc3RhdGUgKExhenkuZm9yY2UgeClcblxubGV0IHBhcnNlIHAgPVxuICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgQmlnc3RyaW5nYWYuZW1wdHkgfmNvbW1pdHRlZF9ieXRlczowIH5vZmY6MCB+bGVuOjAgaW5cbiAgdG9fZXhwb3J0ZWRfc3RhdGUgKHAucnVuIGlucHV0IDAgSW5jb21wbGV0ZSBmYWlsX2sgc3VjY2VlZF9rKVxuXG5sZXQgcGFyc2VfYmlnc3RyaW5nIHAgaW5wdXQgPVxuICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgaW5wdXQgfmNvbW1pdHRlZF9ieXRlczowIH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggaW5wdXQpIGluXG4gIEV4cG9ydGVkX3N0YXRlLnN0YXRlX3RvX3Jlc3VsdCAodG9fZXhwb3J0ZWRfc3RhdGUgKHAucnVuIGlucHV0IDAgQ29tcGxldGUgZmFpbF9rIHN1Y2NlZWRfaykpXG5cbm1vZHVsZSBNb25hZCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuIHYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgdlxuICAgIH1cblxuICBsZXQgZmFpbCBtc2cgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgX3N1Y2MgLT5cbiAgICAgIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gbXNnXG4gICAgfVxuXG4gIGxldCAoPj49KSBwIGYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIHYgPSAoZiB2KS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gICAgfVxuXG4gIGxldCAoPj58KSBwIGYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIHYgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIChmIHYpIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gICAgfVxuXG4gIGxldCAoPCQ+KSBmIG0gPVxuICAgIG0gPj58IGZcblxuICBsZXQgKDwqPikgZiBtID1cbiAgICAoKiBmID4+PSBmdW4gZiAtPiBtID4+fCBmICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzAgaW5wdXQwIHBvczAgbW9yZTAgZiA9XG4gICAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtID0gc3VjYyBpbnB1dDEgcG9zMSBtb3JlMSAoZiBtKSBpblxuICAgICAgICBtLnJ1biBpbnB1dDAgcG9zMCBtb3JlMCBmYWlsIHN1Y2MxXG4gICAgICBpblxuICAgICAgZi5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMCB9XG5cbiAgbGV0IGxpZnQgZiBtID1cbiAgICBmIDwkPiBtXG5cbiAgbGV0IGxpZnQyIGYgbTEgbTIgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID0gc3VjYyBpbnB1dDIgcG9zMiBtb3JlMiAoZiBtMSBtMikgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0IGxpZnQzIGYgbTEgbTIgbTMgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID1cbiAgICAgICAgICBsZXQgc3VjYzMgaW5wdXQzIHBvczMgbW9yZTMgbTMgPVxuICAgICAgICAgICAgc3VjYyBpbnB1dDMgcG9zMyBtb3JlMyAoZiBtMSBtMiBtMykgaW5cbiAgICAgICAgICBtMy5ydW4gaW5wdXQyIHBvczIgbW9yZTIgZmFpbCBzdWNjMyBpblxuICAgICAgICBtMi5ydW4gaW5wdXQxIHBvczEgbW9yZTEgZmFpbCBzdWNjMlxuICAgICAgaW5cbiAgICAgIG0xLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MxIH1cblxuICBsZXQgbGlmdDQgZiBtMSBtMiBtMyBtNCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbTEgPVxuICAgICAgICBsZXQgc3VjYzIgaW5wdXQyIHBvczIgbW9yZTIgbTIgPVxuICAgICAgICAgIGxldCBzdWNjMyBpbnB1dDMgcG9zMyBtb3JlMyBtMyA9XG4gICAgICAgICAgICBsZXQgc3VjYzQgaW5wdXQ0IHBvczQgbW9yZTQgbTQgPVxuICAgICAgICAgICAgICBzdWNjIGlucHV0NCBwb3M0IG1vcmU0IChmIG0xIG0yIG0zIG00KSBpblxuICAgICAgICAgICAgbTQucnVuIGlucHV0MyBwb3MzIG1vcmUzIGZhaWwgc3VjYzQgaW5cbiAgICAgICAgICBtMy5ydW4gaW5wdXQyIHBvczIgbW9yZTIgZmFpbCBzdWNjMyBpblxuICAgICAgICBtMi5ydW4gaW5wdXQxIHBvczEgbW9yZTEgZmFpbCBzdWNjMlxuICAgICAgaW5cbiAgICAgIG0xLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MxIH1cblxuICBsZXQgKCAqPikgYSBiID1cbiAgICAoKiBhID4+PSBmdW4gXyAtPiBiICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgXyA9IGIucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgYS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKDwqICkgYSBiID1cbiAgICAoKiBhID4+PSBmdW4geCAtPiBiID4+fCBmdW4gXyAtPiB4ICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzAgaW5wdXQwIHBvczAgbW9yZTAgeCA9XG4gICAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBfID0gc3VjYyBpbnB1dDEgcG9zMSBtb3JlMSB4IGluXG4gICAgICAgIGIucnVuIGlucHV0MCBwb3MwIG1vcmUwIGZhaWwgc3VjYzFcbiAgICAgIGluXG4gICAgICBhLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MwIH1cbmVuZFxuXG5tb2R1bGUgQ2hvaWNlID0gc3RydWN0XG4gIGxldCAoPD8+KSBwIG1hcmsgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnIG1hcmtzIG1zZyA9XG4gICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgKG1hcms6Om1hcmtzKSBtc2cgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwnIHN1Y2NcbiAgICB9XG5cbiAgbGV0ICg8fD4pIHAgcSA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgbWFya3MgbXNnID1cbiAgICAgICAgKCogVGhlIG9ubHkgdHdvIGNvbnN0cnVjdG9ycyB0aGF0IGludHJvZHVjZSBuZXcgZmFpbHVyZSBjb250aW51YXRpb25zIGFyZVxuICAgICAgICAgKiBbPD8+XSBhbmQgWzx8Pl0uIElmIHRoZSBpbml0aWFsIGlucHV0IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gICAgICAgICAqIG9mIHRoZSBjb21taXR0ZWQgaW5wdXQsIHRoZW4gY2FsbGluZyB0aGUgZmFpbHVyZSBjb250aW51YXRpb24gd2lsbFxuICAgICAgICAgKiBoYXZlIHRoZSBlZmZlY3Qgb2YgdW53aW5kaW5nIGFsbCBjaG9pY2VzIGFuZCBjb2xsZWN0aW5nIG1hcmtzIGFsb25nXG4gICAgICAgICAqIHRoZSB3YXkuICopXG4gICAgICAgIGlmIHBvcyA8IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQnIHRoZW5cbiAgICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUgbWFya3MgbXNnXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBxLnJ1biBpbnB1dCcgcG9zIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCcgc3VjY1xuICAgIH1cbmVuZFxuXG5tb2R1bGUgTW9uYWRfdXNlX2Zvcl9kZWJ1Z2dpbmcgPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IE1vbmFkLnJldHVyblxuICBsZXQgZmFpbCAgID0gTW9uYWQuZmFpbFxuICBsZXQgKD4+PSkgID0gTW9uYWQuKD4+PSlcblxuICBsZXQgKD4+fCkgbSBmID0gbSA+Pj0gZnVuIHggLT4gcmV0dXJuIChmIHgpXG5cbiAgbGV0ICg8JD4pIGYgbSA9IG0gPj58IGZcbiAgbGV0ICg8Kj4pIGYgbSA9IGYgPj49IGZ1biBmIC0+IG0gPj58IGZcblxuICBsZXQgbGlmdCAgPSAoPj58KVxuICBsZXQgbGlmdDIgZiBtMSBtMiAgICAgICA9IGYgPCQ+IG0xIDwqPiBtMlxuICBsZXQgbGlmdDMgZiBtMSBtMiBtMyAgICA9IGYgPCQ+IG0xIDwqPiBtMiA8Kj4gbTNcbiAgbGV0IGxpZnQ0IGYgbTEgbTIgbTMgbTQgPSBmIDwkPiBtMSA8Kj4gbTIgPCo+IG0zIDwqPiBtNFxuXG4gIGxldCAoICo+KSBhIGIgPSBhID4+PSBmdW4gXyAtPiBiXG4gIGxldCAoPCogKSBhIGIgPSBhID4+PSBmdW4geCAtPiBiID4+fCBmdW4gXyAtPiB4XG5lbmRcbiIsInR5cGUgdCA9XG4gIHsgbXV0YWJsZSBidWYgOiBCaWdzdHJpbmdhZi50XG4gIDsgbXV0YWJsZSBvZmYgOiBpbnRcbiAgOyBtdXRhYmxlIGxlbiA6IGludCB9XG5cbmxldCBvZl9iaWdzdHJpbmcgfm9mZiB+bGVuIGJ1ZiA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBidWYgPj0gbGVuIC0gb2ZmKTtcbiAgeyBidWY7IG9mZjsgbGVuIH1cblxubGV0IGNyZWF0ZSBsZW4gPVxuICBvZl9iaWdzdHJpbmcgfm9mZjowIH5sZW46MCAoQmlnc3RyaW5nYWYuY3JlYXRlIGxlbilcblxubGV0IHdyaXRhYmxlX3NwYWNlIHQgPVxuICBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgLSB0LmxlblxuXG5sZXQgdHJhaWxpbmdfc3BhY2UgdCA9XG4gIEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiAtICh0Lm9mZiArIHQubGVuKVxuXG5sZXQgY29tcHJlc3MgdCA9XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IHQuYnVmIH5zcmNfb2ZmOnQub2ZmIHQuYnVmIH5kc3Rfb2ZmOjAgfmxlbjp0LmxlbjtcbiAgdC5vZmYgPC0gMFxuXG5sZXQgZ3JvdyB0IHRvX2NvcHkgPVxuICBsZXQgb2xkX2xlbiA9IEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIGxldCBzcGFjZSA9IHdyaXRhYmxlX3NwYWNlIHQgaW5cbiAgd2hpbGUgc3BhY2UgKyAhbmV3X2xlbiAtIG9sZF9sZW4gPCB0b19jb3B5IGRvXG4gICAgbmV3X2xlbiA6PSAoMyAqICFuZXdfbGVuKSAvIDJcbiAgZG9uZTtcbiAgbGV0IG5ld19idWYgPSBCaWdzdHJpbmdhZi5jcmVhdGUgIW5ld19sZW4gaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgdC5idWYgfnNyY19vZmY6dC5vZmYgbmV3X2J1ZiB+ZHN0X29mZjowIH5sZW46dC5sZW47XG4gIHQuYnVmIDwtIG5ld19idWY7XG4gIHQub2ZmIDwtIDBcblxubGV0IGVuc3VyZSB0IHRvX2NvcHkgPVxuICBpZiB0cmFpbGluZ19zcGFjZSB0IDwgdG9fY29weSB0aGVuXG4gICAgaWYgd3JpdGFibGVfc3BhY2UgdCA+PSB0b19jb3B5XG4gICAgdGhlbiBjb21wcmVzcyB0XG4gICAgZWxzZSBncm93IHQgdG9fY29weVxuXG5sZXQgd3JpdGVfcG9zIHQgPVxuICB0Lm9mZiArIHQubGVuXG5cbmxldCBmZWVkX3N0cmluZyB0IH5vZmYgfmxlbiBzdHIgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChTdHJpbmcubGVuZ3RoIHN0ciA+PSBsZW4gLSBvZmYpO1xuICBlbnN1cmUgdCBsZW47XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIHN0ciB+c3JjX29mZjpvZmYgdC5idWYgfmRzdF9vZmY6KHdyaXRlX3BvcyB0KSB+bGVuO1xuICB0LmxlbiA8LSB0LmxlbiArIGxlblxuXG5sZXQgZmVlZF9iaWdzdHJpbmcgdCB+b2ZmIH5sZW4gYiA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBiID49IGxlbiAtIG9mZik7XG4gIGVuc3VyZSB0IGxlbjtcbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgYiB+c3JjX29mZjpvZmYgdC5idWYgfmRzdF9vZmY6KHdyaXRlX3BvcyB0KSB+bGVuO1xuICB0LmxlbiA8LSB0LmxlbiArIGxlblxuXG5sZXQgZmVlZF9pbnB1dCB0ID0gZnVuY3Rpb25cbiAgfCBgU3RyaW5nICAgIHMgLT4gZmVlZF9zdHJpbmcgICAgdCB+b2ZmOjAgfmxlbjooU3RyaW5nICAgICAubGVuZ3RoIHMpIHNcbiAgfCBgQmlnc3RyaW5nIGIgLT4gZmVlZF9iaWdzdHJpbmcgdCB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGIpIGJcblxubGV0IHNoaWZ0IHQgbiA9XG4gIGFzc2VydCAodC5sZW4gPj0gbik7XG4gIHQub2ZmIDwtIHQub2ZmICsgbjtcbiAgdC5sZW4gPC0gdC5sZW4gLSBuXG5cbmxldCBmb3JfcmVhZGluZyB7IGJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIEJpZ3N0cmluZ2FmLnN1YiB+b2ZmIH5sZW4gYnVmXG5cbm1vZHVsZSBVbmNvbnN1bWVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBidWYgOiBCaWdzdHJpbmdhZi50XG4gICAgOyBvZmYgOiBpbnRcbiAgICA7IGxlbiA6IGludCB9XG5lbmRcblxubGV0IHVuY29uc3VtZWQgPyhzaGlmdD0wKSB7IGJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIGFzc2VydCAobGVuID49IHNoaWZ0KTtcbiAgeyBVbmNvbnN1bWVkLmJ1Zjsgb2ZmID0gb2ZmICsgc2hpZnQ7IGxlbiA9IGxlbiAtIHNoaWZ0IH1cblxubGV0IG9mX3VuY29uc3VtZWQgeyBVbmNvbnN1bWVkLmJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIHsgYnVmOyBvZmY7IGxlbiB9XG5cbnR5cGUgdW5jb25zdW1lZCA9IFVuY29uc3VtZWQudCA9XG4gIHsgYnVmIDogQmlnc3RyaW5nYWYudFxuICA7IG9mZiA6IGludFxuICA7IGxlbiA6IGludCB9XG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTYgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBCaWdhcnJheSA9IHN0cnVjdFxuICAoKiBEbyBub3QgYWNjZXNzIEJpZ2FycmF5IG9wZXJhdGlvbnMgZGlyZWN0bHkuIElmIGFueXRoaW5nJ3MgbmVlZGVkLCByZWZlciB0b1xuICAgKiB0aGUgaW50ZXJuYWwgQmlnc3RyaW5nIG1vZHVsZS4gKilcbmVuZFxuXG50eXBlIGJpZ3N0cmluZyA9IEJpZ3N0cmluZ2FmLnRcblxuXG5tb2R1bGUgVW5idWZmZXJlZCA9IHN0cnVjdFxuICBpbmNsdWRlIFBhcnNlclxuXG4gIGluY2x1ZGUgRXhwb3J0ZWRfc3RhdGVcblxuICB0eXBlIG1vcmUgPSBNb3JlLnQgPVxuICAgIHwgQ29tcGxldGVcbiAgICB8IEluY29tcGxldGVcbmVuZFxuXG5pbmNsdWRlIFVuYnVmZmVyZWRcbmluY2x1ZGUgUGFyc2VyLk1vbmFkXG5pbmNsdWRlIFBhcnNlci5DaG9pY2VcblxubW9kdWxlIEJ1ZmZlcmVkID0gc3RydWN0XG4gIHR5cGUgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkID1cbiAgICB7IGJ1ZiA6IGJpZ3N0cmluZ1xuICAgIDsgb2ZmIDogaW50XG4gICAgOyBsZW4gOiBpbnQgfVxuXG4gIHR5cGUgaW5wdXQgPVxuICAgIFsgYEJpZ3N0cmluZyBvZiBiaWdzdHJpbmdcbiAgICB8IGBTdHJpbmcgICAgb2Ygc3RyaW5nIF1cblxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFBhcnRpYWwgb2YgKFsgaW5wdXQgfCBgRW9mIF0gLT4gJ2Egc3RhdGUpXG4gICAgfCBEb25lICAgIG9mIHVuY29uc3VtZWQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiB1bmNvbnN1bWVkICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuICBsZXQgZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIH5mIGJ1ZmZlcmluZyA9IGZ1bmN0aW9uXG4gICAgfCBVbmJ1ZmZlcmVkLlBhcnRpYWwgcCAgICAgICAgIC0+IFBhcnRpYWwgKGYgcClcbiAgICB8IFVuYnVmZmVyZWQuRG9uZShjb25zdW1lZCwgdikgLT5cbiAgICAgIGxldCB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgfnNoaWZ0OmNvbnN1bWVkIGJ1ZmZlcmluZyBpblxuICAgICAgRG9uZSh1bmNvbnN1bWVkLCB2KVxuICAgIHwgVW5idWZmZXJlZC5GYWlsKGNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgbGV0IHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCB+c2hpZnQ6Y29uc3VtZWQgYnVmZmVyaW5nIGluXG4gICAgICBGYWlsKHVuY29uc3VtZWQsIG1hcmtzLCBtc2cpXG5cbiAgbGV0IHBhcnNlID8oaW5pdGlhbF9idWZmZXJfc2l6ZT0weDEwMDApIHAgPVxuICAgIGlmIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxIHRoZW5cbiAgICAgIGZhaWx3aXRoIFwicGFyc2U6IGludmFsaWQgYXJndW1lbnQsIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxXCI7XG4gICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5jcmVhdGUgaW5pdGlhbF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCByZWMgZiBwIGlucHV0ID1cbiAgICAgIEJ1ZmZlcmluZy5zaGlmdCBidWZmZXJpbmcgcC5jb21taXR0ZWQ7XG4gICAgICBsZXQgbW9yZSA6IE1vcmUudCA9XG4gICAgICAgIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgICAgfCBgRW9mICAgICAgICAgICAgLT4gQ29tcGxldGVcbiAgICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgICAgSW5jb21wbGV0ZVxuICAgICAgaW5cbiAgICAgIGxldCBmb3JfcmVhZGluZyA9IEJ1ZmZlcmluZy5mb3JfcmVhZGluZyBidWZmZXJpbmcgaW5cbiAgICAgIHAuY29udGludWUgZm9yX3JlYWRpbmcgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBmb3JfcmVhZGluZykgbW9yZVxuICAgICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuICAgIGluXG4gICAgVW5idWZmZXJlZC5wYXJzZSBwXG4gICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuXG4gIGxldCBmZWVkIHN0YXRlIGlucHV0ID1cbiAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgfCBQYXJ0aWFsIGsgLT4gayBpbnB1dFxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgfCBgRW9mICAgLT4gc3RhdGVcbiAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcub2ZfdW5jb25zdW1lZCB1bmNvbnN1bWVkIGluXG4gICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgRmFpbChCdWZmZXJpbmcudW5jb25zdW1lZCBidWZmZXJpbmcsIG1hcmtzLCBtc2cpXG4gICAgICBlbmRcbiAgICB8IERvbmUodW5jb25zdW1lZCwgdikgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgIHwgYEVvZiAgIC0+IHN0YXRlXG4gICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLm9mX3VuY29uc3VtZWQgdW5jb25zdW1lZCBpblxuICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgIERvbmUoQnVmZmVyaW5nLnVuY29uc3VtZWQgYnVmZmVyaW5nLCB2KVxuICAgICAgZW5kXG5cbiAgbGV0IHN0YXRlX3RvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgfCBEb25lKF8sIHYpIC0+IFNvbWUgdlxuICAgIHwgUGFydGlhbCBfICAtPiBOb25lXG4gICAgfCBGYWlsIF8gICAgIC0+IE5vbmVcblxuICBsZXQgc3RhdGVfdG9fcmVzdWx0ID0gZnVuY3Rpb25cbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgLT4gRXJyb3IgXCJpbmNvbXBsZXRlIGlucHV0XCJcbiAgICB8IERvbmUoXywgdikgICAgICAgICAgLT4gT2sgdlxuICAgIHwgRmFpbChfLCBtYXJrcywgbXNnKSAtPiBFcnJvciAoVW5idWZmZXJlZC5mYWlsX3RvX3N0cmluZyBtYXJrcyBtc2cpXG5cbiAgbGV0IHN0YXRlX3RvX3VuY29uc3VtZWQgPSBmdW5jdGlvblxuICAgIHwgRG9uZSh1bmNvbnN1bWVkLCBfKVxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBfLCBfKSAtPiBTb21lIHVuY29uc3VtZWRcbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgICAgLT4gTm9uZVxuXG5lbmRcblxuKCoqIEJFR0lOOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCByZWMgcHJvbXB0IGlucHV0IHBvcyBmYWlsIHN1Y2MgPVxuICAoKiBbcHJvbXB0XSBzaG91bGQgb25seSBjYWxsIFtzdWNjXSBpZiBpdCBoYXMgcmVjZWl2ZWQgbW9yZSBpbnB1dC4gSWYgdGhlcmVcbiAgICogaXMgbm8gY2hhbmNlIHRoYXQgdGhlIGlucHV0IHdpbGwgZ3JvdywgaS5lLiwgW21vcmUgPSBDb21wbGV0ZV0sIHRoZW5cbiAgICogW3Byb21wdF0gc2hvdWxkIGNhbGwgW2ZhaWxdLiBPdGhlcndpc2UgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBpbnB1dFxuICAgKiBoYXNuJ3QgZ3Jvd24gYnV0IFttb3JlID0gSW5jb21wbGV0ZV0ganVzdCBwcm9tcHQgYWdhaW4uICopXG4gIGxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgPSBJbnB1dC5wYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgaW5wdXQgaW5cbiAgbGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICA9IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICBpbnB1dCBpblxuICAoKiBUaGUgY29udGludWF0aW9uIHNob3VsZCBub3QgaG9sZCBhbnkgcmVmZXJlbmNlcyB0byBpbnB1dCBhYm92ZS4gKilcbiAgbGV0IGNvbnRpbnVlIGlucHV0IH5vZmYgfmxlbiBtb3JlID1cbiAgICBpZiBsZW4gPCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdGhlblxuICAgICAgZmFpbHdpdGggXCJwcm9tcHQ6IGlucHV0IHNocnVuayFcIjtcbiAgICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgaW5wdXQgfm9mZiB+bGVuIH5jb21taXR0ZWRfYnl0ZXM6cGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpblxuICAgIGlmIGxlbiA9IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0aGVuXG4gICAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgICAgfCBDb21wbGV0ZSAgIC0+IGZhaWwgaW5wdXQgcG9zIE1vcmUuQ29tcGxldGVcbiAgICAgIHwgSW5jb21wbGV0ZSAtPiBwcm9tcHQgaW5wdXQgcG9zIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmVcbiAgaW5cbiAgU3RhdGUuUGFydGlhbCB7IGNvbW1pdHRlZCA9IElucHV0LmJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IGlucHV0OyBjb250aW51ZSB9XG5cbmxldCBkZW1hbmRfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgIHwgQ29tcGxldGUgICAtPiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwibm90IGVub3VnaCBpbnB1dFwiXG4gICAgfCBJbmNvbXBsZXRlIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPSBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwibm90IGVub3VnaCBpbnB1dFwiIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IGVuc3VyZV9zdXNwZW5kZWQgbiBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgPVxuICBsZXQgcmVjIGdvID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJyAtPlxuICAgICAgaWYgcG9zJyArIG4gPD0gSW5wdXQubGVuZ3RoIGlucHV0JyB0aGVuXG4gICAgICAgIHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBlbHNlXG4gICAgICAgIChkZW1hbmRfaW5wdXQgKj4gZ28pLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJ1xuICAgIH1cbiAgaW5cbiAgKGRlbWFuZF9pbnB1dCAqPiBnbykucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuXG5sZXQgdW5zYWZlX2FwcGx5IGxlbiB+ZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmYpXG4gIH1cblxubGV0IHVuc2FmZV9hcHBseV9vcHQgbGVuIH5mID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbWF0Y2ggSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+ZiB3aXRoXG4gICAgfCBFcnJvciBlIC0+IGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gZVxuICAgIHwgT2sgICAgeCAtPiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgeFxuICB9XG5cbmxldCBlbnN1cmUgbiBwID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zICsgbiA8PSBJbnB1dC5sZW5ndGggaW5wdXRcbiAgICB0aGVuIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9IHAucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCBuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG4oKiogRU5EOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCBhdF9lbmRfb2ZfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBmYWxzZVxuICAgIGVsc2UgbWF0Y2ggbW9yZSB3aXRoXG4gICAgfCBDb21wbGV0ZSAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHRydWVcbiAgICB8IEluY29tcGxldGUgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgZmFsc2VcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgdHJ1ZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBlbmRfb2ZfaW5wdXQgPVxuICBhdF9lbmRfb2ZfaW5wdXRcbiAgPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlICAtPiByZXR1cm4gKClcbiAgICB8IGZhbHNlIC0+IGZhaWwgXCJlbmRfb2ZfaW5wdXRcIlxuXG5sZXQgYWR2YW5jZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwiYWR2YW5jZVwiXG4gIGVsc2VcbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+IHN1Y2MgaW5wdXQgKHBvcyArIG4pIG1vcmUgKCkgfVxuICAgIGluXG4gICAgZW5zdXJlIG4gcFxuXG5sZXQgcG9zID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHBvcyB9XG5cbmxldCBhdmFpbGFibGUgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQubGVuZ3RoIGlucHV0IC0gcG9zKVxuICB9XG5cbmxldCBjb21taXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgSW5wdXQuY29tbWl0IGlucHV0IHBvcztcbiAgICBzdWNjIGlucHV0IHBvcyBtb3JlICgpIH1cblxuKCogRG8gbm90IHVzZSB0aGlzIGlmIFtwXSBjb250YWlucyBhIFtjb21taXRdLiAqKVxubGV0IHVuc2FmZV9sb29rYWhlYWQgcCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdWNjJyBpbnB1dCcgXyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zIG1vcmUnIHYgaW5cbiAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IHBlZWtfY2hhciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykpXG4gICAgZWxzZSBpZiBtb3JlID0gQ29tcGxldGUgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0JyBwb3MnKSlcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgTm9uZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbigqIFRoaXMgcGFyc2VyIGlzIHRvbyBpbXBvcnRhbnQgdG8gbm90IGJlIG9wdGltaXplZC4gRG8gYSBjdXN0b20gam9iLiAqKVxubGV0IHJlYyBwZWVrX2NoYXJfZmFpbCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dFxuICAgIHRoZW4gc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBwZWVrX2NoYXJfZmFpbC5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIDEgaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBzYXRpc2Z5IGYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIFByaW50Zi5rc3ByaW50ZiAoZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSkgXCJzYXRpc2Z5OiAlQ1wiIGNcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCcgcG9zJyBpblxuICAgICAgICBpZiBmIGNcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0JyAocG9zJyArIDEpIG1vcmUnIGNcbiAgICAgICAgZWxzZSBQcmludGYua3NwcmludGYgKGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10pIFwic2F0aXNmeTogJUNcIiBjXG4gICAgICBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCAxIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgY2hhciBjID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyA9IGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwiY2hhciAlQ1wiIGMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgbm90X2NoYXIgYyA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjJyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIGlmIGMgPD4gYydcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjJ1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcIm5vdCBjaGFyICVDXCIgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfY2hhciA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSAgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBpbnQ4IGkgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IENoYXIuY29kZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykgaW5cbiAgICAgIGlmIGMgPSBpIGxhbmQgMHhmZlxuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJpbnQ4ICVkXCIgaSkgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfdWludDggPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChDaGFyLmNvZGUgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfaW50OCA9XG4gICgqIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWwjVmFyaWFibGVTaWduRXh0ZW5kUmlza3kgKilcbiAgbGV0IHMgPSBTeXMuaW50X3NpemUgLSA4IGluXG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKChDaGFyLmNvZGUgYyBsc2wgcykgYXNyIHMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgc2tpcCBmID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgZiAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoKVxuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwic2tpcFwiIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgcmVjIGNvdW50X3doaWxlIH5pbml0IH5mIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBsZW4gICAgICAgICA9IElucHV0LmNvdW50X3doaWxlIGlucHV0IChwb3MgKyBpbml0KSB+ZiBpblxuICAgIGxldCBpbnB1dF9sZW4gICA9IElucHV0Lmxlbmd0aCBpbnB1dCBpblxuICAgIGxldCBpbml0JyAgICAgICA9IGluaXQgKyBsZW4gaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBwb3MgKyBpbml0JyA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGluaXQnKSBtb3JlIChJbnB1dC5hcHBseSBpbnB1dCBwb3MgaW5pdCcgfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmluaXQnIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgKHBvcycgKyBpbml0JykgbW9yZScgKElucHV0LmFwcGx5IGlucHV0JyBwb3MnIGluaXQnIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgcmVjIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgbGVuICAgICAgICAgPSBJbnB1dC5jb3VudF93aGlsZSBpbnB1dCBwb3MgfmYgaW5cbiAgICBsZXQgaW5wdXRfbGVuICAgPSBJbnB1dC5sZW5ndGggaW5wdXQgaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBsZW4gPCAxXG4gICAgdGhlblxuICAgICAgaWYgcG9zIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgICAgdGhlbiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiY291bnRfd2hpbGUxXCJcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgICAoY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJjb3VudF93aGlsZTFcIlxuICAgICAgICBpblxuICAgICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gICAgZWxzZSBpZiBwb3MgKyBsZW4gPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmxlbiB+ZiB+d2l0aF9idWZmZXIpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2NcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIChwb3MnICsgbGVuKSBtb3JlJyAoSW5wdXQuYXBwbHkgaW5wdXQnIHBvcycgbGVuIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgc3RyaW5nXyBmIHMgPVxuICAoKiBYWFgoc2VsaW9wb3UpOiBJbmVmZmljaWVudC4gQ291bGQgY2hlY2sgcHJlZml4IGVxdWFsaXR5IHRvIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIGlvLiAqKVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVuc3VyZSAgbGVuICh1bnNhZmVfYXBwbHlfb3B0IGxlbiB+ZjooZnVuIGJ1ZmZlciB+b2ZmIH5sZW4gLT5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgd2hpbGUgIWkgPCBsZW4gJiYgQ2hhci5lcXVhbCAoZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgKG9mZiArICFpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZiAoU3RyaW5nLnVuc2FmZV9nZXQgcyAhaSkpXG4gICAgZG9cbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgbGVuID0gIWlcbiAgICB0aGVuIE9rIChCaWdzdHJpbmdhZi5zdWJzdHJpbmcgYnVmZmVyIH5vZmYgfmxlbilcbiAgICBlbHNlIEVycm9yIFwic3RyaW5nXCIpKVxuXG5sZXQgc3RyaW5nIHMgICAgPSBzdHJpbmdfIChmdW4geCAtPiB4KSBzXG5sZXQgc3RyaW5nX2NpIHMgPSBzdHJpbmdfIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IHNraXBfd2hpbGUgZiA9XG4gIGNvdW50X3doaWxlIH5pbml0OjAgfmYgfndpdGhfYnVmZmVyOihmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuXG5sZXQgdGFrZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwidGFrZTogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLnN1YnN0cmluZylcblxubGV0IHRha2VfYmlnc3RyaW5nIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJ0YWtlX2JpZ3N0cmluZzogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLmNvcHkpXG5cbmxldCB0YWtlX2JpZ3N0cmluZ193aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuY29weVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfd2hpbGUxIGYgPVxuICBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IHRha2VfYmlnc3RyaW5nX3RpbGwgZiA9XG4gIHRha2VfYmlnc3RyaW5nX3doaWxlIChmdW4gYyAtPiBub3QgKGYgYykpXG5cbmxldCBwZWVrX3N0cmluZyBuID1cbiAgdW5zYWZlX2xvb2thaGVhZCAodGFrZSBuKVxuXG5sZXQgdGFrZV93aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCB0YWtlX3doaWxlMSBmID1cbiAgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHRha2VfdGlsbCBmID1cbiAgdGFrZV93aGlsZSAoZnVuIGMgLT4gbm90IChmIGMpKVxuXG5sZXQgY2hvaWNlID8oZmFpbHVyZV9tc2c9XCJubyBtb3JlIGNob2ljZXNcIikgcHMgPVxuICBMaXN0LmZvbGRfcmlnaHQgKDx8PikgcHMgKGZhaWwgZmFpbHVyZV9tc2cpXG5cbmxldCBmaXhfZGlyZWN0IGYgPVxuICBsZXQgcmVjIHAgPSBsYXp5IChmIHIpXG4gIGFuZCByID0geyBydW4gPSBmdW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIH1cbiAgaW5cbiAgclxuXG5sZXQgZml4X2xhenkgfm1heF9zdGVwcyBmID1cbiAgbGV0IHN0ZXBzID0gcmVmIG1heF9zdGVwcyBpblxuICBsZXQgcmVjIHAgPSBsYXp5IChmIHIpXG4gIGFuZCByID0geyBydW4gPSBmdW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGRlY3Igc3RlcHM7XG4gICAgaWYgIXN0ZXBzIDwgMFxuICAgIHRoZW4gKFxuICAgICAgc3RlcHMgOj0gbWF4X3N0ZXBzO1xuICAgICAgU3RhdGUuTGF6eSAobGF6eSAoKExhenkuZm9yY2UgcCkucnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MpKSlcbiAgICBlbHNlXG4gICAgICAoTGF6eS5mb3JjZSBwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjY1xuICAgICAgICAgIH1cbiAgaW5cbiAgclxuXG5sZXQgZml4ID0gbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgTmF0aXZlIC0+IGZpeF9kaXJlY3RcbiAgfCBCeXRlY29kZSAtPiBmaXhfZGlyZWN0XG4gIHwgT3RoZXIgXyAtPiBmdW4gZiAtPiBmaXhfbGF6eSB+bWF4X3N0ZXBzOjIwIGZcblxubGV0IG9wdGlvbiB4IHAgPVxuICBwIDx8PiByZXR1cm4geFxuXG5sZXQgY29ucyB4IHhzID0geCA6OiB4c1xuXG5sZXQgcmVjIGxpc3QgcHMgPVxuICBtYXRjaCBwcyB3aXRoXG4gIHwgW10gICAgLT4gcmV0dXJuIFtdXG4gIHwgcDo6cHMgLT4gbGlmdDIgY29ucyBwIChsaXN0IHBzKVxuXG5sZXQgY291bnQgbiBwID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwiY291bnQ6IG4gPCAwXCJcbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gcmV0dXJuIFtdXG4gICAgICB8IG4gLT4gbGlmdDIgY29ucyBwIChsb29wIChuIC0gMSkpXG4gICAgaW5cbiAgICBsb29wIG5cblxubGV0IG1hbnkgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAobGlmdDIgY29ucyBwIG0pIDx8PiByZXR1cm4gW10pXG5cbmxldCBtYW55MSBwID1cbiAgbGlmdDIgY29ucyBwIChtYW55IHApXG5cbmxldCBtYW55X3RpbGwgcCB0ID1cbiAgZml4IChmdW4gbSAtPlxuICAgICh0ICo+IHJldHVybiBbXSkgPHw+IChsaWZ0MiBjb25zIHAgbSkpXG5cbmxldCBzZXBfYnkxIHMgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICBsaWZ0MiBjb25zIHAgKChzICo+IG0pIDx8PiByZXR1cm4gW10pKVxuXG5sZXQgc2VwX2J5IHMgcCA9XG4gIChsaWZ0MiBjb25zIHAgKChzICo+IHNlcF9ieTEgcyBwKSA8fD4gcmV0dXJuIFtdKSkgPHw+IHJldHVybiBbXVxuXG5sZXQgc2tpcF9tYW55IHAgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgICAoKHAgPj58IGZ1biBfIC0+IHRydWUpIDx8PiByZXR1cm4gZmFsc2UpID4+PSBmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IG1cbiAgICAgIHwgZmFsc2UgLT4gcmV0dXJuICgpXG4gICAgKVxuXG5sZXQgc2tpcF9tYW55MSBwID1cbiAgcCAqPiBza2lwX21hbnkgcFxuXG5sZXQgZW5kX29mX2xpbmUgPVxuICAoY2hhciAnXFxuJyAqPiByZXR1cm4gKCkpIDx8PiAoc3RyaW5nIFwiXFxyXFxuXCIgKj4gcmV0dXJuICgpKSA8Pz4gXCJlbmRfb2ZfbGluZVwiXG5cbmxldCBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdGF0ZSA9IHJlZiBzdGF0ZSBpblxuICAgIGxldCBwYXJzZXIgPVxuICAgICAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZjooZnVuIGMgLT5cbiAgICAgICAgbWF0Y2ggZiAhc3RhdGUgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgICB8IFNvbWUgc3RhdGUnIC0+IHN0YXRlIDo9IHN0YXRlJzsgdHJ1ZSlcbiAgICAgIH53aXRoX2J1ZmZlclxuICAgICAgPj58IGZ1biB4IC0+IHgsICFzdGF0ZVxuICAgIGluXG4gICAgcGFyc2VyLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgfVxuXG5sZXQgc2NhbiBzdGF0ZSBmID1cbiAgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCBzY2FuX3N0YXRlIHN0YXRlIGYgPVxuICBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlcjooZnVuIF8gfm9mZjpfIH5sZW46XyAtPiAoKSlcbiAgPj58IGZ1biAoKCksIHN0YXRlKSAtPiBzdGF0ZVxuXG5sZXQgc2Nhbl9zdHJpbmcgc3RhdGUgZiA9XG4gIHNjYW4gc3RhdGUgZiA+PnwgZnN0XG5cbmxldCBjb25zdW1lX3dpdGggcCBmID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN0YXJ0ID0gcG9zIGluXG4gICAgbGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPSBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0ICBpblxuICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyBfID1cbiAgICAgIGlmIHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPD4gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpbnB1dCdcbiAgICAgIHRoZW4gZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSBcImNvbnN1bWVkOiBwYXJzZXIgY29tbWl0dGVkXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbGVuID0gcG9zJyAtIHN0YXJ0IGluXG4gICAgICAgIGxldCBjb25zdW1lZCA9IElucHV0LmFwcGx5IGlucHV0JyBzdGFydCBsZW4gfmYgaW5cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBjb25zdW1lZClcbiAgICBpblxuICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgfVxuXG5sZXQgY29uc3VtZWQgICAgICAgICAgIHAgPSBjb25zdW1lX3dpdGggcCBCaWdzdHJpbmdhZi5zdWJzdHJpbmdcbmxldCBjb25zdW1lZF9iaWdzdHJpbmcgcCA9IGNvbnN1bWVfd2l0aCBwIEJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IGJvdGggYSBiID0gbGlmdDIgKGZ1biBhIGIgLT4gYSwgYikgYSBiXG5sZXQgbWFwIHQgfmYgPSB0ID4+fCBmXG5sZXQgYmluZCB0IH5mID0gdCA+Pj0gZlxubGV0IG1hcDIgYSBiIH5mID0gbGlmdDIgZiBhIGJcbmxldCBtYXAzIGEgYiBjIH5mID0gbGlmdDMgZiBhIGIgY1xubGV0IG1hcDQgYSBiIGMgZCB+ZiA9IGxpZnQ0IGYgYSBiIGMgZFxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBsZXQgKCA+Pj0gKSA9ICggPj49IClcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG4gICAgbGV0IG1hcDIgPSBtYXAyXG4gICAgbGV0IG1hcDMgPSBtYXAzXG4gICAgbGV0IG1hcDQgPSBtYXA0XG4gIGVuZFxuZW5kXG5cbmxldCAoIGxldCsgKSA9ICggPj58IClcbmxldCAoIGxldCogKSA9ICggPj49IClcbmxldCAoIGFuZCsgKSA9IGJvdGhcblxubW9kdWxlIEJFID0gc3RydWN0XG4gICgqIFhYWChzZWxpb3BvdSk6IFRoZSBwYXR0ZXJuIGluIGJvdGggdGhpcyBtb2R1bGUgYW5kIFtMRV0gYXJlIGEgY29tcHJvbWlzZVxuICAgKiBiZXR3ZWVuIGVmZmljaWVuY3kgYW5kIGNvZGUgcmV1c2UuIEJ5IGlubGluaW5nIFtlbnN1cmVdIHlvdSBjYW4gcmVjb3ZlclxuICAgKiBhYm91dCAyIG5hbm9zZWNvbmRzIG9uIGF2ZXJhZ2UuIFRoYXQgbWF5IGFkZCB1cCBpbiBjZXJ0YWluIGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogVGhpcyBwYXR0ZXJuIGRvZXMgbm90IGFsbG9jYXRlIGluIHRoZSBmYXN0IChzdWNjZXNzKSBwYXRoLlxuICAgKiAqKVxuICBsZXQgaW50MTYgbiA9XG4gICAgbGV0IGJ5dGVzID0gMiBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2ludDE2X2JlIGlucHV0IHBvcyA9IChuIGxhbmQgMHhmZmZmKVxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDE2XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50MzIgbiA9XG4gICAgbGV0IGJ5dGVzID0gNCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQzMi5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQzMl9iZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQzMlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDY0IG4gPVxuICAgIGxldCBieXRlcyA9IDggaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50NjQuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50NjRfYmUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50NjRcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBhbnlfdWludDE2ID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQxNiAgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfc2lnbl9leHRlbmRlZF9iZSAgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDMyICA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50NjQgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2Zsb2F0ID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQzMi5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIGJzIG9mZikpKVxuXG4gIGxldCBhbnlfZG91YmxlID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQ2NC5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2JlIGJzIG9mZikpKVxuZW5kXG5cbm1vZHVsZSBMRSA9IHN0cnVjdFxuICBsZXQgaW50MTYgbiA9XG4gICAgbGV0IGJ5dGVzID0gMiBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2ludDE2X2xlIGlucHV0IHBvcyA9IChuIGxhbmQgMHhmZmZmKVxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDE2XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50MzIgbiA9XG4gICAgbGV0IGJ5dGVzID0gNCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQzMi5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQzMl9sZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQzMlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDY0IG4gPVxuICAgIGxldCBieXRlcyA9IDggaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50NjQuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50NjRfbGUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50NjRcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG5cbiAgbGV0IGFueV91aW50MTYgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDE2ICA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9zaWduX2V4dGVuZGVkX2xlICBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MzIgID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQ2NCA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfZmxvYXQgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDMyLmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgYnMgb2ZmKSkpXG5cbiAgbGV0IGFueV9kb3VibGUgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDY0LmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgYnMgb2ZmKSkpXG5lbmRcblxubW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICBsZXQgdGFrZSBuIGYgPVxuICAgIGxldCBuID0gbWF4IG4gMCBpblxuICAgIGVuc3VyZSBuICh1bnNhZmVfYXBwbHkgbiB+ZilcblxuICBsZXQgcGVlayBuIGYgPVxuICAgIHVuc2FmZV9sb29rYWhlYWQgKHRha2UgbiBmKVxuXG4gIGxldCB0YWtlX3doaWxlIGNoZWNrIGYgPVxuICAgIGNvdW50X3doaWxlIH5pbml0OjAgfmY6Y2hlY2sgfndpdGhfYnVmZmVyOmZcblxuICBsZXQgdGFrZV93aGlsZTEgY2hlY2sgZiA9XG4gICAgY291bnRfd2hpbGUxIH5mOmNoZWNrIH53aXRoX2J1ZmZlcjpmXG5cbiAgbGV0IHRha2VfdGlsbCBjaGVjayBmID1cbiAgICB0YWtlX3doaWxlIChmdW4gYyAtPiBub3QgKGNoZWNrIGMpKSBmXG5lbmRcblxubW9kdWxlIENvbnN1bWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFByZWZpeFxuICAgIHwgQWxsXG5lbmRcblxubGV0IHBhcnNlX2JpZ3N0cmluZyB+Y29uc3VtZSBwIGJzID1cbiAgbGV0IHAgPVxuICAgIG1hdGNoIChjb25zdW1lIDogQ29uc3VtZS50KSB3aXRoXG4gICAgfCBQcmVmaXggLT4gcFxuICAgIHwgQWxsIC0+IHAgPCogZW5kX29mX2lucHV0XG4gIGluXG4gIFVuYnVmZmVyZWQucGFyc2VfYmlnc3RyaW5nIHAgYnNcblxubGV0IHBhcnNlX3N0cmluZyB+Y29uc3VtZSBwIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBicyAgPSBCaWdzdHJpbmdhZi5jcmVhdGUgbGVuIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIHMgfnNyY19vZmY6MCBicyB+ZHN0X29mZjowIH5sZW47XG4gIHBhcnNlX2JpZ3N0cmluZyB+Y29uc3VtZSBwIGJzXG4iXX0=
