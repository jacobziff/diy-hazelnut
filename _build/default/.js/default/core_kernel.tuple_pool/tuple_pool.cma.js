// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Tuple_pool__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Tuple_pool = [0];
   runtime.caml_register_global(0, Tuple_pool, "Tuple_pool__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Import = "Tuple_pool__Import",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][1], "tuple_pool/src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Import);
   var Tuple_pool_Import = [0];
   runtime.caml_register_global(11, Tuple_pool_Import, cst_Tuple_pool_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_type_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_type_intf = "Tuple_pool__Tuple_type_intf",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_type_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1
    (Expect_test_collector[5][1], "tuple_pool/src/tuple_type_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_type_intf);
   var Tuple_pool_Tuple_type_intf = [0];
   runtime.caml_register_global
    (11, Tuple_pool_Tuple_type_intf, cst_Tuple_pool_Tuple_type_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_type
//# unitInfo: Requires: Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool__Tuple_type_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_type = "Tuple_pool__Tuple_type",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    t1 = [0, 301584533, [0, 1]],
    t2 = [0, 301584533, [0, 2]],
    t3 = [0, 301584533, [0, 3]],
    t4 = [0, 301584533, [0, 4]],
    t5 = [0, 301584533, [0, 5]],
    t6 = [0, 301584533, [0, 6]],
    t7 = [0, 301584533, [0, 7]],
    t8 = [0, 301584533, [0, 8]],
    t9 = [0, 301584533, [0, 9]],
    t10 = [0, 301584533, [0, 10]],
    t11 = [0, 301584533, [0, 11]],
    t12 = [0, 301584533, [0, 12]],
    t13 = [0, 301584533, [0, 13]],
    t14 = [0, 301584533, [0, 14]],
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_type);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][1], "tuple_pool/src/tuple_type.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   var _a_ = [0, "slots_per_tuple"], _b_ = [0, "Slots"];
   function sexp_of_t(param){
    var
     v_006 = param[2],
     slots_per_tuple_002 = v_006[1],
     arg_003 = caml_call1(Core[356], slots_per_tuple_002),
     bnds_001 = [0, [1, [0, _a_, [0, arg_003, 0]]], 0];
    return [1, [0, _b_, [0, [1, bnds_001], 0]]];
   }
   function sexp_of_t$0(of_tuple_007, of_variant_008){return sexp_of_t;}
   function slots_per_tuple(param){var n = param[2][1]; return n;}
   function sexp_of_t1(of_a0_009){return sexp_of_t;}
   function sexp_of_t2(of_a0_010, of_a1_011){return sexp_of_t;}
   function sexp_of_t3(of_a0_012, of_a1_013, of_a2_014){return sexp_of_t;}
   function sexp_of_t4(of_a0_015, of_a1_016, of_a2_017, of_a3_018){return sexp_of_t;
   }
   function sexp_of_t5(of_a0_019, of_a1_020, of_a2_021, of_a3_022, of_a4_023){return sexp_of_t;
   }
   function sexp_of_t6
   (of_a0_024, of_a1_025, of_a2_026, of_a3_027, of_a4_028, of_a5_029){return sexp_of_t;
   }
   function sexp_of_t7
   (of_a0_030,
    of_a1_031,
    of_a2_032,
    of_a3_033,
    of_a4_034,
    of_a5_035,
    of_a6_036){
    return sexp_of_t;
   }
   function sexp_of_t8
   (of_a0_037,
    of_a1_038,
    of_a2_039,
    of_a3_040,
    of_a4_041,
    of_a5_042,
    of_a6_043,
    of_a7_044){
    return sexp_of_t;
   }
   function sexp_of_t9
   (of_a0_045,
    of_a1_046,
    of_a2_047,
    of_a3_048,
    of_a4_049,
    of_a5_050,
    of_a6_051,
    of_a7_052,
    of_a8_053){
    return sexp_of_t;
   }
   function sexp_of_t10
   (of_a0_054,
    of_a1_055,
    of_a2_056,
    of_a3_057,
    of_a4_058,
    of_a5_059,
    of_a6_060,
    of_a7_061,
    of_a8_062,
    of_a9_063){
    return sexp_of_t;
   }
   function sexp_of_t11
   (of_a0_064,
    of_a1_065,
    of_a2_066,
    of_a3_067,
    of_a4_068,
    of_a5_069,
    of_a6_070,
    of_a7_071,
    of_a8_072,
    of_a9_073,
    of_a10_074){
    return sexp_of_t;
   }
   function sexp_of_t12
   (of_a0_075,
    of_a1_076,
    of_a2_077,
    of_a3_078,
    of_a4_079,
    of_a5_080,
    of_a6_081,
    of_a7_082,
    of_a8_083,
    of_a9_084,
    of_a10_085,
    of_a11_086){
    return sexp_of_t;
   }
   function sexp_of_t13
   (of_a0_087,
    of_a1_088,
    of_a2_089,
    of_a3_090,
    of_a4_091,
    of_a5_092,
    of_a6_093,
    of_a7_094,
    of_a8_095,
    of_a9_096,
    of_a10_097,
    of_a11_098,
    of_a12_099){
    return sexp_of_t;
   }
   function sexp_of_t14
   (of_a0_100,
    of_a1_101,
    of_a2_102,
    of_a3_103,
    of_a4_104,
    of_a5_105,
    of_a6_106,
    of_a7_107,
    of_a8_108,
    of_a9_109,
    of_a10_110,
    of_a11_111,
    of_a12_112,
    of_a13_113){
    return sexp_of_t;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_type);
   var
    Tuple_pool_Tuple_type =
      [0,
       [0,
        sexp_of_t$0,
        slots_per_tuple,
        sexp_of_t1,
        sexp_of_t2,
        sexp_of_t3,
        sexp_of_t4,
        sexp_of_t5,
        sexp_of_t6,
        sexp_of_t7,
        sexp_of_t8,
        sexp_of_t9,
        sexp_of_t10,
        sexp_of_t11,
        sexp_of_t12,
        sexp_of_t13,
        sexp_of_t14,
        t1,
        t2,
        t3,
        t4,
        t5,
        t6,
        t7,
        t8,
        t9,
        t10,
        t11,
        t12,
        t13,
        t14]];
   runtime.caml_register_global
    (28, Tuple_pool_Tuple_type, cst_Tuple_pool_Tuple_type);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_pool_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_pool_intf = "Tuple_pool__Tuple_pool_intf",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_pool_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1
    (Expect_test_collector[5][1], "tuple_pool/src/tuple_pool_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_pool_intf);
   var Tuple_pool_Tuple_pool_intf = [0];
   runtime.caml_register_global
    (11, Tuple_pool_Tuple_pool_intf, cst_Tuple_pool_Tuple_pool_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool
//# unitInfo: Requires: Assert_failure, Base__Field, Base__String, Bin_prot__Shape, Core, Core__Array, Core__Core_sys, Core__Debug, Core__Error, Core__Int, Core__Int63, Core__List, Core__Printf, Core__Result, Core__Uniform_array, Expect_test_collector, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool__Tuple_type, Typerep_lib__Make_typename, Typerep_lib__Std, Typerep_lib__Typename, Typerep_lib__Typerep_obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Tuple_pool$0 = "Tuple_pool",
    cst$0 = "_",
    cst_capacity$1 = "capacity",
    cst_dummy$0 = "dummy",
    cst_first_free$0 = "first_free",
    cst_is_valid$0 = "is_valid",
    cst_length$0 = "length",
    cst_next_id$0 = "next_id",
    cst_pointer$0 = "pointer",
    cst_slots_per_tuple$0 = "slots_per_tuple",
    cst_t$1 = "t",
    cst_tuple_pool$0 = "tuple_pool",
    cst_tuple_pool_src_tuple_pool_$8 = "tuple_pool/src/tuple_pool.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   function caml_call13
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    return (f.l >= 0 ? f.l : f.l = f.length) == 13
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   function caml_call15
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14){
    return (f.l >= 0 ? f.l : f.l = f.length) == 15
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    name$1 = "tuple_pool/src/tuple_pool.ml.Error_check.Pointer.t",
    prefix = "Pool.",
    name$0 = "tuple_pool/src/tuple_pool.ml.Debug.Pointer.t",
    cst = cst$1,
    name = "tuple_pool/src/tuple_pool.ml.Pool.Pointer.t",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Core = global_data.Core,
    Typerep_lib_Std = global_data.Typerep_lib__Std,
    Typerep_lib_Typerep_obj = global_data.Typerep_lib__Typerep_obj,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename,
    Core_Int63 = global_data.Core__Int63,
    Core_Result = global_data.Core__Result,
    Core_List = global_data.Core__List,
    Core_Debug = global_data.Core__Debug,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Core_Uniform_array = global_data.Core__Uniform_array,
    Tuple_pool_Tuple_type = global_data.Tuple_pool__Tuple_type,
    Assert_failure = global_data.Assert_failure,
    Core_Array = global_data.Core__Array,
    Base_Field = global_data.Base__Field,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_String = global_data.Base__String,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Error = global_data.Core__Error,
    Core_Core_sys = global_data.Core__Core_sys,
    Core_Int = global_data.Core__Int,
    Core_Printf = global_data.Core__Printf,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool$0);
   caml_call1(Expect_test_collector[5][1], cst_tuple_pool_src_tuple_pool_$8);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool$0, cst);
   var
    failwiths = Core_Error[41],
    arch_sixtyfour = caml_call2(Core[90], Core_Core_sys[9], 64),
    num_bits = Core_Int[40],
    max_value = Core[1][19],
    to_string = Core[22],
    sprintf = Core_Printf[2],
    _a_ = [0, cst$1];
   function concat(l){return caml_call2(Base_String[54], _a_, l);}
   function sexp_of_t(of_slots_007, of_a_008){return Core[356];}
   function equal(t1, t2){return caml_call2(Core[90], t1, t2);}
   var t13 = 14, max_slot = 14;
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     "<<t13 = max_slot>>",
     0,
     cst_tuple_pool_src_tuple_pool_$8,
     87,
     4,
     31,
     function(param){return caml_call2(Core[90], t13, max_slot);});
   var
    Slot =
      [0, sexp_of_t, equal, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, t13],
    _as_ = [0, cst$0],
    cst_attempt_to_use_invalid_poi = "attempt to use invalid pointer",
    _at_ = [0, cst_tuple_pool_src_tuple_pool_$8, 1150, 38369, 38396],
    cst_is_valid = cst_is_valid$0,
    cst_pointer = cst_pointer$0,
    _aq_ = [0, cst_pointer$0],
    _ar_ = [0, cst_is_valid$0],
    cst_unsafe_set = "unsafe_set",
    cst_set = "set",
    _ap_ = [0, cst$0],
    cst_unsafe_get = "unsafe_get",
    cst_get = "get",
    _ao_ = [0, cst$0],
    _an_ = [0, cst$0],
    _am_ = [0, cst$0],
    _al_ = [0, cst$0],
    cst_get_tuple = "get_tuple",
    _ak_ = [0, cst$0],
    cst_new = "new",
    _aj_ = [0, cst$0],
    cst_free = "free",
    _ai_ = [0, cst$0],
    cst_unsafe_free = "unsafe_free",
    _ah_ = [0, cst$0],
    cst_is_full = "is_full",
    _ag_ = [0, cst_capacity$1],
    _af_ = [0, cst$0],
    cst_grow = "grow",
    _ae_ = [0, cst$0],
    cst_capacity$0 = cst_capacity$1,
    cst_max_capacity = "max_capacity",
    _ad_ = [0, cst$0],
    cst_create = "create",
    _ac_ = [0, cst$0],
    cst_pointer_is_valid = "pointer_is_valid",
    _ab_ = [0, cst$0],
    cst_pointer_of_id_exn = "pointer_of_id_exn",
    _aa_ = [0, cst$0],
    cst_id_of_pointer = "id_of_pointer",
    cst_Pointer_Id_to_int63 = "Pointer.Id.to_int63",
    cst_Pointer_Id_of_int63 = "Pointer.Id.of_int63",
    _$_ = [0, cst$0],
    cst_Pointer_is_null = "Pointer.is_null",
    ___ = [0, cst$0],
    _Z_ = [0, cst$0],
    cst_Pointer_phys_equal = "Pointer.phys_equal",
    _Y_ = [0, cst$0],
    _X_ = [0, cst$0],
    cst_Pointer_phys_compare = "Pointer.phys_compare",
    _W_ = [0, " result", 0],
    cst_t = cst_t$1,
    cst_tuple_pool_src_tuple_pool_$7 = "tuple_pool/src/tuple_pool.ml:986:6",
    cst_t$0 = cst_t$1,
    _U_ = [0, cst$0],
    _T_ = [0, cst$0],
    cst_Pool_free_of_invalid_point = "Pool.free of invalid pointer",
    _V_ = [0, cst_tuple_pool_src_tuple_pool_$8, 700, 23089, 23103],
    _R_ = [0, cst$0],
    cst_Pool_malloc_of_full_pool = "Pool.malloc of full pool",
    _S_ = [0, cst_tuple_pool_src_tuple_pool_$8, 657, 21456, 21476],
    cst_Pool_grow_cannot_grow_pool =
      "Pool.grow cannot grow pool; capacity already at maximum",
    _Q_ = [0, cst_tuple_pool_src_tuple_pool_$8, 625, 20520, 20534],
    _O_ = [0, "max"],
    cst_Pool_create_got_invalid_ca = "Pool.create got invalid capacity",
    _N_ = [0, cst_tuple_pool_src_tuple_pool_$8, 540, 17887, 17909],
    cst_Pool_create_got_too_large_ = "Pool.create got too large capacity",
    _P_ = [0, cst_tuple_pool_src_tuple_pool_$8, 546, 18147, 18161],
    _B_ = [0, cst$0],
    _M_ = [0, cst_tuple_pool_src_tuple_pool_$8, 450, 56],
    _L_ = [0, cst_tuple_pool_src_tuple_pool_$8, 453, 13],
    _K_ = [0, cst_tuple_pool_src_tuple_pool_$8, 454, 13],
    _J_ = [0, cst_tuple_pool_src_tuple_pool_$8, 457, 13],
    _I_ = [0, cst_tuple_pool_src_tuple_pool_$8, 458, 13],
    _H_ = [0, cst_tuple_pool_src_tuple_pool_$8, 466, 15],
    _G_ = [0, cst_tuple_pool_src_tuple_pool_$8, 468, 15],
    cst_cycle_in_free_list = "cycle in free list",
    _F_ = [0, cst_tuple_pool_src_tuple_pool_$8, 472, 15394, 15427],
    _D_ = [0, cst_tuple_pool_src_tuple_pool_$8, 479, 15],
    _E_ = [0, cst_tuple_pool_src_tuple_pool_$8, 488, 21],
    cst_Pool_invariant_failed = "Pool.invariant failed",
    _C_ = [0, cst_tuple_pool_src_tuple_pool_$8, 493, 16348, 16370],
    _y_ = [0, cst$0],
    cst_invalid_header_index = "invalid header index",
    _A_ = [0, cst_tuple_pool_src_tuple_pool_$8, 433, 13853, 13882],
    cst_pointer_not_live = "pointer not live",
    cst_Pool_pointer_of_id_exn_got = "Pool.pointer_of_id_exn got invalid id",
    _z_ = [0, cst_tuple_pool_src_tuple_pool_$8, 439, 14080, 14094],
    _s_ = [0, cst_dummy$0],
    _t_ = [0, cst_first_free$0],
    _u_ = [0, cst_next_id$0],
    _v_ = [0, cst_length$0],
    _w_ = [0, cst_capacity$1],
    _x_ = [0, cst_slots_per_tuple$0],
    _r_ = [0, cst_tuple_pool_src_tuple_pool_$8, 329, 6],
    _o_ = [0, "null"],
    _p_ = [0, "Free"],
    _q_ = [0, "Used"],
    _n_ = [0, cst_tuple_pool_src_tuple_pool_$8, 307, 8],
    _m_ = [0, cst_tuple_pool_src_tuple_pool_$8, 308, 8],
    _j_ = [0, cst$0],
    cst_should_equal = "should equal",
    _k_ = [0, cst_tuple_pool_src_tuple_pool_$8, 251, 7700, 7731],
    cst_Pointer_of_id_exn_got_stra = "Pointer.of_id_exn got strange id",
    _i_ = [0, cst_tuple_pool_src_tuple_pool_$8, 255, 7828, 7844],
    _h_ = [0, cst_tuple_pool_src_tuple_pool_$8, 219, 48],
    _g_ =
      [0,
       [11, "<Pool.Pointer.t: 0x", [4, 6, [0, 2, 8], 0, [12, 62, 0]]],
       "<Pool.Pointer.t: 0x%08x>"],
    cst_Tuple_id_of_int_got_negati = "Tuple_id.of_int got negative int",
    _f_ = [0, cst_tuple_pool_src_tuple_pool_$8, 145, 4421, 4448],
    _e_ = [0, cst_tuple_pool_src_tuple_pool_$8, 136, 22],
    _b_ = [0, cst_capacity$1],
    _c_ = [0, "old_capacity"],
    cst_Pool_grow_got_too_small_ca = "Pool.grow got too small capacity",
    _d_ = [0, cst_tuple_pool_src_tuple_pool_$8, 29, 638, 654],
    _au_ = [0, cst_tuple_pool_src_tuple_pool_$8, 104, 6],
    _av_ = [0, cst_tuple_pool_src_tuple_pool_$8, 107, 6],
    cst_tuple_pool_src_tuple_pool_ = cst_tuple_pool_src_tuple_pool_$8,
    cst_array_index_num_bits_0 = "<<array_index_num_bits > 0>>",
    cst_tuple_pool_src_tuple_pool_$0 = cst_tuple_pool_src_tuple_pool_$8,
    cst_masked_tuple_id_num_bits_0 = "<<masked_tuple_id_num_bits > 0>>",
    cst_tuple_pool_src_tuple_pool_$1 = cst_tuple_pool_src_tuple_pool_$8,
    cst_array_index_num_bits_maske =
      "<<(array_index_num_bits + masked_tuple_id_num_b[...]>>",
    cst_tuple_pool_src_tuple_pool_$2 = cst_tuple_pool_src_tuple_pool_$8,
    cst_null_max_slot_0 = "<<((null ()) + max_slot) < 0>>",
    cst_tuple_pool_src_tuple_pool_$3 = cst_tuple_pool_src_tuple_pool_$8,
    cst_invariant_ignore_null = "<<invariant ignore (null ())>>",
    cst_tuple_pool_src_tuple_pool_$4 = cst_tuple_pool_src_tuple_pool_$8,
    cst_List_iter_Tuple_id_example =
      "<<List.iter Tuple_id.examples   ~f:(fun tuple_i[...]>>",
    cst_tuple_pool_src_tuple_pool_$5 = cst_tuple_pool_src_tuple_pool_$8,
    cst_List_iter_Tuple_id_example$0 =
      "<<List.iter Tuple_id.examples   ~f:(fun id ->  [...]>>",
    cst_tuple_pool_src_tuple_pool_$6 = cst_tuple_pool_src_tuple_pool_$8,
    cst_for_slots_per_tuple_1_to_m =
      "<<for slots_per_tuple = 1 to max_slot do   asse[...]>>",
    cst_dummy = cst_dummy$0,
    cst_first_free = cst_first_free$0,
    cst_next_id = cst_next_id$0,
    cst_length = cst_length$0,
    cst_capacity = cst_capacity$1,
    cst_slots_per_tuple = cst_slots_per_tuple$0,
    cst_tuple_pool = cst_tuple_pool$0,
    cst_Tuple_pool = cst_Tuple_pool$0;
   if(arch_sixtyfour){
    if(! caml_call2(Core[90], num_bits, 63))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
    var array_index_num_bits = 30;
   }
   else{
    if
     (!
      caml_call2(Core[90], num_bits, 31)
      && ! caml_call2(Core[90], num_bits, 32))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var array_index_num_bits = 22;
   }
   var masked_tuple_id_num_bits = num_bits - array_index_num_bits | 0;
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_array_index_num_bits_0,
     0,
     cst_tuple_pool_src_tuple_pool_,
     113,
     2,
     39,
     function(param){return caml_call2(Core[91], array_index_num_bits, 0);});
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_masked_tuple_id_num_bits_0,
     0,
     cst_tuple_pool_src_tuple_pool_$0,
     114,
     2,
     43,
     function(param){
      return caml_call2(Core[91], masked_tuple_id_num_bits, 0);
     });
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_array_index_num_bits_maske,
     0,
     cst_tuple_pool_src_tuple_pool_$1,
     115,
     2,
     78,
     function(param){
      return caml_call2
              (Core[89],
               array_index_num_bits + masked_tuple_id_num_bits | 0,
               num_bits);
     });
   var max_array_length = 1 << array_index_num_bits, sexp_of_t$0 = Core[356];
   function of_int(i){
    if(caml_call2(Core[92], i, 0))
     caml_call5
      (failwiths, 0, _f_, cst_Tuple_id_of_int_got_negati, i, Core[356]);
    return i;
   }
   var
    examples = [0, 0, [0, 1, [0, 536870911, [0, max_value, 0]]]],
    tuple_id_mask = (1 << masked_tuple_id_num_bits) - 1 | 0,
    Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name]),
    typename_of_t = Typename_of_t[2];
   function typerep_of_t(of_slots){
    var name_of_t = caml_call1(Typename_of_t[1], of_slots);
    return [9, [0, name_of_t, [0, Core[359]]]];
   }
   function sexp_of_t$1(param, t){return [0, caml_call2(sprintf, _g_, t)];}
   function phys_equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var phys_compare = Core[95];
   function null$0(param){return -15;}
   function is_null(t1){return t1 === -15 ? 1 : 0;}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_null_max_slot_0,
     0,
     cst_tuple_pool_src_tuple_pool_$2,
     209,
     4,
     39,
     function(param){return caml_call2(Core[92], -1, 0);});
   function create(header_index, tuple_id){
    return header_index | (tuple_id & tuple_id_mask) << array_index_num_bits;
   }
   var header_index_mask = (1 << array_index_num_bits) - 1 | 0;
   function invariant(param, t1){
    var _bC_ = 1 - (t1 === -15 ? 1 : 0);
    if(! _bC_) return _bC_;
    if(caml_call2(Core[91], t1 & header_index_mask, 0)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_invariant_ignore_null,
     0,
     cst_tuple_pool_src_tuple_pool_$3,
     221,
     4,
     48,
     function(param){invariant(function(_bB_){return 0;}, -15); return 0;});
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_List_iter_Tuple_id_example,
     0,
     cst_tuple_pool_src_tuple_pool_$4,
     223,
     4,
     135,
     function(param){
      caml_call2
       (Core_List[9],
        examples,
        function(tuple_id){
         return invariant(function(_bA_){return 0;}, create(1, tuple_id));
        });
      return 0;
     });
   function slot_index(t, slot){return (t & header_index_mask) + slot | 0;}
   function first_slot_index(t){return slot_index(t, Slot[3]);}
   var
    to_int_exn = Core_Int63[5],
    of_int$0 = Core_Int63[69],
    bin_size_t = Core_Int63[90],
    bin_write_t = Core_Int63[91],
    bin_read_t = Core_Int63[92],
    bin_read_t$0 = Core_Int63[93],
    bin_shape_t = Core_Int63[94],
    bin_writer_t = Core_Int63[95],
    bin_reader_t = Core_Int63[96],
    bin_t = Core_Int63[97],
    t_of_sexp = Core_Int63[98],
    sexp_of_t$2 = Core_Int63[99];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   var
    _l_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t$2,
       to_int63,
       of_int63],
    null$1 = 0;
   function is_null$0(t){return caml_call2(Core[90], t, 0);}
   function is_free(t){return caml_call2(Core[91], t, 0);}
   function is_used(t){return caml_call2(Core[92], t, 0);}
   function tuple_id(t){return of_int(- (t + 1 | 0) | 0);}
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_List_iter_Tuple_id_example$0,
     0,
     cst_tuple_pool_src_tuple_pool_$5,
     304,
     4,
     173,
     function(param){
      caml_call2
       (Core_List[9],
        examples,
        function(tuple_id$0){
         var t = -1 - tuple_id$0 | 0;
         if(! is_used(t))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
         var t1 = tuple_id(t);
         if(caml_call2(Core[90], t1, tuple_id$0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
        });
      return 0;
     });
   var metadata_index = 0, start_of_tuples_index = 1;
   function max_capacity(slots_per_tuple){
    return caml_div(max_array_length - 1 | 0, 1 + slots_per_tuple | 0);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_for_slots_per_tuple_1_to_m,
     0,
     cst_tuple_pool_src_tuple_pool_$6,
     327,
     2,
     203,
     function(param){
      var slots_per_tuple = 1;
      for(;;){
       var
        _by_ =
          1 + caml_mul(1 + slots_per_tuple | 0, max_capacity(slots_per_tuple))
          | 0;
       if(! caml_call2(Core[89], _by_, max_array_length))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
       var _bz_ = slots_per_tuple + 1 | 0;
       if(14 === slots_per_tuple) return 0;
       slots_per_tuple = _bz_;
      }
     });
   function dummy(r){return r[6];}
   function first_free(r){return r[5];}
   function set_first_free(r, v){r[5] = v; return 0;}
   function next_id(r){return r[4];}
   function set_next_id(r, v){r[4] = v; return 0;}
   function length(r){return r[3];}
   function set_length(r, v){r[3] = v; return 0;}
   function capacity(r){return r[2];}
   function slots_per_tuple(r){return r[1];}
   var
    dummy$0 =
      [0,
       function(param){return 0;},
       cst_dummy,
       0,
       dummy,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v];}],
    first_free$0 =
      [0,
       function(param){return 0;},
       cst_first_free,
       [0, set_first_free],
       first_free,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}],
    next_id$0 =
      [0,
       function(param){return 0;},
       cst_next_id,
       [0, set_next_id],
       next_id,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}],
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}],
    capacity$0 =
      [0,
       function(param){return 0;},
       cst_capacity,
       0,
       capacity,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6]];}],
    slots_per_tuple$0 =
      [0,
       function(param){return 0;},
       cst_slots_per_tuple,
       0,
       slots_per_tuple,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}],
    init = 0;
   function array_indices_per_tuple(t){return 1 + t[1] | 0;}
   function array_length(t){
    var _bx_ = array_indices_per_tuple(t);
    return 1 + caml_mul(t[2], _bx_) | 0;
   }
   function tuple_num_to_header_index(t, tuple_num){
    return 1 + caml_mul(tuple_num, array_indices_per_tuple(t)) | 0;
   }
   function tuple_num_to_first_slot_index(t, tuple_num){
    return tuple_num_to_header_index(t, tuple_num) + 1 | 0;
   }
   function metadata(t){
    return caml_call2(Core_Uniform_array[20], t, metadata_index);
   }
   function length$1(t){return metadata(t)[3];}
   function sexp_of_t$3(sexp_of_ty, t){
    var
     param = metadata(t),
     capacity_018 = param[2],
     slots_per_tuple_016 = param[1],
     length_020 = param[3],
     next_id_022 = param[4],
     first_free_024 = param[5],
     dummy_026 = param[6],
     arg_027 = caml_call2(Core[454], Sexplib0_Sexp_conv[23], dummy_026),
     bnds_015 = [0, [1, [0, _s_, [0, arg_027, 0]]], 0],
     arg_025 =
       is_null$0(first_free_024)
        ? _o_
        : is_free
           (first_free_024)
          ? [1, [0, _p_, [0, [0, caml_call1(to_string, first_free_024)], 0]]]
          : [1,
            [0,
             _q_,
             [0, [0, caml_call1(to_string, tuple_id(first_free_024))], 0]]],
     bnds_015$0 = [0, [1, [0, _t_, [0, arg_025, 0]]], bnds_015],
     arg_023 = caml_call1(sexp_of_t$0, next_id_022),
     bnds_015$1 = [0, [1, [0, _u_, [0, arg_023, 0]]], bnds_015$0],
     arg_021 = caml_call1(Core[356], length_020),
     bnds_015$2 = [0, [1, [0, _v_, [0, arg_021, 0]]], bnds_015$1],
     arg_019 = caml_call1(Core[356], capacity_018),
     bnds_015$3 = [0, [1, [0, _w_, [0, arg_019, 0]]], bnds_015$2],
     arg_017 = caml_call1(Core[356], slots_per_tuple_016),
     bnds_015$4 = [0, [1, [0, _x_, [0, arg_017, 0]]], bnds_015$3];
    return [1, bnds_015$4];
   }
   function unsafe_header(t, header_index){
    return caml_call2(Core_Uniform_array[20], t, header_index);
   }
   function unsafe_set_header(t, header_index, header){
    return caml_call3(Core_Uniform_array[45], t, header_index, header);
   }
   function header_index_is_in_bounds(t, header_index){
    var _bv_ = caml_call2(Core[88], header_index, start_of_tuples_index);
    if(! _bv_) return _bv_;
    var _bw_ = caml_call1(Core_Uniform_array[18], t);
    return caml_call2(Core[92], header_index, _bw_);
   }
   function unsafe_pointer_is_live(t, pointer){
    var
     header_index = pointer & header_index_mask,
     header = unsafe_header(t, header_index),
     _bu_ = is_used(header);
    if(! _bu_) return _bu_;
    var t$0 = tuple_id(header);
    return caml_call2
            (Core[90],
             t$0 & tuple_id_mask,
             pointer >>> array_index_num_bits | 0);
   }
   function pointer_is_valid(t, pointer){
    var _bt_ = header_index_is_in_bounds(t, pointer & header_index_mask);
    return _bt_ ? unsafe_pointer_is_live(t, pointer) : _bt_;
   }
   function id_of_pointer(t, pointer){return caml_call1(of_int$0, pointer);}
   function is_valid_header_index(t, header_index){
    var
     metadata$0 = metadata(t),
     _br_ = header_index_is_in_bounds(t, header_index);
    if(! _br_) return _br_;
    var
     _bs_ =
       runtime.caml_mod
        (header_index - 1 | 0, array_indices_per_tuple(metadata$0));
    return caml_call2(Core[90], 0, _bs_);
   }
   function pointer_of_id_exn(t$1, id){
    try{
     try{
      var t1 = caml_call1(to_int_exn, id);
      if(t1 === -15)
       var t = t1;
      else
       var
        should_equal =
          create
           (t1 & header_index_mask, of_int(t1 >>> array_index_num_bits | 0)),
        t$0 =
          t1 === should_equal
           ? t1
           : caml_call5
             (failwiths,
              0,
              _k_,
              cst_should_equal,
              should_equal,
              function(x_009){
               return sexp_of_t$1(function(param){return _j_;}, x_009);
              }),
        t = t$0;
      var pointer = t;
     }
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       pointer =
         caml_call5
          (failwiths,
           0,
           _i_,
           cst_Pointer_of_id_exn_got_stra,
           [0, id, exn],
           function(param){
            var
             arg1_011 = param[2],
             arg0_010 = param[1],
             res0_012 = caml_call1(sexp_of_t$2, arg0_010),
             res1_013 = caml_call1(Core[537], arg1_011);
            return [1, [0, res0_012, [0, res1_013, 0]]];
           });
     }
     if(1 - (pointer === -15 ? 1 : 0)){
      var header_index = pointer & header_index_mask;
      if(1 - is_valid_header_index(t$1, header_index))
       caml_call5
        (failwiths, 0, _A_, cst_invalid_header_index, header_index, Core[356]);
      if(1 - unsafe_pointer_is_live(t$1, pointer))
       caml_call1(Core[6], cst_pointer_not_live);
     }
     return pointer;
    }
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     return caml_call5
             (failwiths,
              0,
              _z_,
              cst_Pool_pointer_of_id_exn_got,
              [0, id, t$1, exn$0],
              function(param){
               var
                arg2_030 = param[3],
                arg1_029 = param[2],
                arg0_028 = param[1],
                res0_031 = caml_call1(_l_[10], arg0_028),
                res1_032 = sexp_of_t$3(function(param){return _y_;}, arg1_029),
                res2_033 = caml_call1(Core[537], arg2_030);
               return [1, [0, res0_031, [0, res1_032, [0, res2_033, 0]]]];
              });
    }
   }
   function invariant$0(invariant_a, t){
    try{
     var
      metadata$0 = metadata(t),
      slots_per_tuple =
        caml_call2(Base_Field[3], slots_per_tuple$0, metadata$0);
     if(! caml_call2(Core[91], slots_per_tuple, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
     var capacity = caml_call2(Base_Field[3], capacity$0, metadata$0);
     if(! caml_call2(Core[88], capacity, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
     var
      _bo_ = array_length(metadata$0),
      _bp_ = caml_call1(Core_Uniform_array[18], t);
     if(! caml_call2(Core[90], _bp_, _bo_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
     var length = caml_call2(Base_Field[3], length$0, metadata$0);
     if(! caml_call2(Core[88], length, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
     if(! caml_call2(Core[89], length, metadata$0[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
     var t$0 = caml_call2(Base_Field[3], next_id$0, metadata$0);
     if(! caml_call2(Core[88], t$0, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var
      first_free = caml_call2(Base_Field[3], first_free$0, metadata$0),
      free = caml_call2(Core_Array[38], metadata$0[2], 0),
      r = [0, first_free];
     for(;;){
      if(is_null$0(r[1])) break;
      var header_index$0 = r[1];
      if(! is_free(header_index$0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
      if(! is_valid_header_index(t, header_index$0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
      var
       tuple_num =
         caml_div(header_index$0 - 1 | 0, array_indices_per_tuple(metadata$0));
      if(caml_check_bound(free, tuple_num)[1 + tuple_num])
       caml_call5
        (failwiths, 0, _F_, cst_cycle_in_free_list, tuple_num, Core[356]);
      caml_check_bound(free, tuple_num)[1 + tuple_num] = 1;
      r[1] = unsafe_header(t, header_index$0);
     }
     var param = caml_call2(Base_Field[3], dummy$0, metadata$0);
     if(param){
      var
       dummy = param[1],
       _bg_ = metadata$0[1],
       _bh_ = caml_call1(Core_Uniform_array[18], dummy);
      if(! caml_call2(Core[90], _bh_, _bg_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
      var _bq_ = 0;
     }
     else{
      var _bj_ = metadata$0[2] - 1 | 0, _bi_ = 0;
      if(_bj_ >= 0){
       var tuple_num$0 = _bi_;
       for(;;){
        var
         header_index = tuple_num_to_header_index(metadata$0, tuple_num$0),
         header = unsafe_header(t, header_index);
        if(is_free(header)){
         var
          first_slot = tuple_num_to_first_slot_index(metadata$0, tuple_num$0),
          _bl_ = metadata$0[1] - 1 | 0,
          _bk_ = 0;
         if(_bl_ >= 0){
          var slot = _bk_;
          for(;;){
           if
            (typeof
             caml_call2(Core_Uniform_array[19], t, first_slot + slot | 0)
             !== "number")
            throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
           var _bn_ = slot + 1 | 0;
           if(_bl_ === slot) break;
           slot = _bn_;
          }
         }
        }
        var _bm_ = tuple_num$0 + 1 | 0;
        if(_bj_ === tuple_num$0) break;
        tuple_num$0 = _bm_;
       }
      }
      var _bq_ = 0;
     }
     return _bq_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return caml_call5
             (failwiths,
              0,
              _C_,
              cst_Pool_invariant_failed,
              [0, exn, t],
              function(param){
               var
                arg1_035 = param[2],
                arg0_034 = param[1],
                res0_036 = caml_call1(Core[537], arg0_034),
                res1_037 = sexp_of_t$3(function(param){return _B_;}, arg1_035);
               return [1, [0, res0_036, [0, res1_037, 0]]];
              });
    }
   }
   function capacity$1(t){return metadata(t)[2];}
   function is_full(t){
    var t$0 = metadata(t);
    return caml_call2(Core[90], t$0[3], t$0[2]);
   }
   function unsafe_add_to_free_list(t, metadata, next_free_header_index){
    unsafe_set_header(t, next_free_header_index, metadata[5]);
    metadata[5] = next_free_header_index;
    return;
   }
   function set_metadata(t, metadata){
    return caml_call3(Core_Uniform_array[21], t, metadata_index, metadata);
   }
   function create_array(metadata){
    var
     _bf_ = array_length(metadata),
     t = caml_call1(Core_Uniform_array[43], _bf_);
    set_metadata(t, metadata);
    return t;
   }
   function unsafe_init_range(t, metadata, lo, hi){
    var match = metadata[6];
    if(match){
     var dummy = match[1], _a$_ = hi - 1 | 0;
     if(_a$_ >= lo){
      var tuple_num$0 = lo;
      for(;;){
       var
        _bc_ = metadata[1],
        _bd_ = tuple_num_to_first_slot_index(metadata, tuple_num$0);
       caml_call5(Core_Uniform_array[36], dummy, 0, t, _bd_, _bc_);
       var _be_ = tuple_num$0 + 1 | 0;
       if(_a$_ === tuple_num$0) break;
       tuple_num$0 = _be_;
      }
     }
    }
    var _ba_ = hi - 1 | 0;
    if(_ba_ >= lo){
     var tuple_num = _ba_;
     for(;;){
      unsafe_add_to_free_list
       (t, metadata, tuple_num_to_header_index(metadata, tuple_num));
      var _bb_ = tuple_num - 1 | 0;
      if(lo === tuple_num) break;
      tuple_num = _bb_;
     }
    }
    return;
   }
   function create_with_dummy(slots, capacity, dummy){
    if(caml_call2(Core[92], capacity, 0))
     caml_call5
      (failwiths, 0, _N_, cst_Pool_create_got_invalid_ca, capacity, Core[356]);
    var
     slots_per_tuple = caml_call1(Tuple_pool_Tuple_type[1][2], slots),
     max_capacity$0 = max_capacity(slots_per_tuple);
    if(caml_call2(Core[91], capacity, max_capacity$0))
     caml_call5
      (failwiths,
       0,
       _P_,
       cst_Pool_create_got_too_large_,
       [0, capacity, [0, 5442212, max_capacity$0]],
       function(param){
        var
         arg1_040 = param[2],
         arg0_039 = param[1],
         res0_041 = caml_call1(Core[356], arg0_039),
         v_038 = arg1_040[2],
         res1_042 = [1, [0, _O_, [0, caml_call1(Core[356], v_038), 0]]];
        return [1, [0, res0_041, [0, res1_042, 0]]];
       });
    var
     metadata = [0, slots_per_tuple, capacity, 0, init, null$1, dummy],
     t = create_array(metadata);
    unsafe_init_range(t, metadata, 0, capacity);
    return t;
   }
   function create$0(slots, capacity, dummy){
    var
     _a__ = caml_call1(Tuple_pool_Tuple_type[1][2], slots),
     dummy$0 =
       caml_call2(Core[90], _a__, 1)
        ? caml_call1(Core_Uniform_array[16], dummy)
        : dummy;
    return create_with_dummy(slots, capacity, [0, dummy$0]);
   }
   function grow(capacity$0, t){
    var
     match$0 = metadata(t),
     old_capacity = match$0[2],
     slots_per_tuple = match$0[1],
     length = match$0[3],
     next_id = match$0[4],
     dummy$0 = match$0[6];
    if(capacity$0){
     var capacity = capacity$0[1];
     if(caml_call2(Core[89], capacity, old_capacity))
      caml_call5
       (failwiths,
        0,
        _d_,
        cst_Pool_grow_got_too_small_ca,
        [0, [0, -1011154630, capacity], [0, 138253074, old_capacity]],
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          v_001 = arg0_003[2],
          res0_005 = [1, [0, _b_, [0, caml_call1(Core[356], v_001), 0]]],
          v_002 = arg1_004[2],
          res1_006 = [1, [0, _c_, [0, caml_call1(Core[356], v_002), 0]]];
         return [1, [0, res0_005, [0, res1_006, 0]]];
        });
     var _a5_ = capacity;
    }
    else
     var
      _a5_ = caml_call2(Core[90], old_capacity, 0) ? 1 : old_capacity * 2 | 0;
    var
     _a6_ = max_capacity(slots_per_tuple),
     capacity$1 = caml_call2(Core[96], _a6_, _a5_);
    if(caml_call2(Core[90], capacity$1, old_capacity))
     caml_call5
      (failwiths,
       0,
       _Q_,
       cst_Pool_grow_cannot_grow_pool,
       capacity$1,
       Core[356]);
    var
     metadata$2 =
       [0, slots_per_tuple, capacity$1, length, next_id, null$1, dummy$0],
     t$0 = create_array(metadata$2),
     _a7_ = caml_mul(old_capacity, array_indices_per_tuple(metadata$2));
    caml_call5
     (Core_Uniform_array[36],
      t,
      start_of_tuples_index,
      t$0,
      start_of_tuples_index,
      _a7_);
    var metadata$0 = metadata(t), match = metadata$0[6];
    if(match){
     var dummy = match[1], _a1_ = metadata$0[2] - 1 | 0, _a0_ = 0;
     if(_a1_ >= 0){
      var tuple_num = _a0_;
      for(;;){
       var header_index = tuple_num_to_header_index(metadata$0, tuple_num);
       unsafe_set_header(t, header_index, null$1);
       caml_call5
        (Core_Uniform_array[36],
         dummy,
         0,
         t,
         header_index + 1 | 0,
         metadata$0[1]);
       var _a2_ = tuple_num + 1 | 0;
       if(_a1_ === tuple_num) break;
       tuple_num = _a2_;
      }
     }
    }
    else{
     var _a3_ = caml_call1(Core_Uniform_array[18], t) - 1 | 0;
     if(_a3_ >= 1){
      var i = start_of_tuples_index;
      for(;;){
       caml_call3(Core_Uniform_array[22], t, i, 0);
       var _a4_ = i + 1 | 0;
       if(_a3_ === i) break;
       i = _a4_;
      }
     }
    }
    var
     metadata$1 =
       [0, metadata$0[1], 0, 0, metadata$0[4], null$1, metadata$0[6]];
    set_metadata(t, metadata$1);
    unsafe_init_range(t$0, metadata$2, old_capacity, capacity$1);
    var _a8_ = old_capacity - 1 | 0;
    if(_a8_ >= 0){
     var tuple_num$0 = _a8_;
     for(;;){
      var
       header_index$0 = tuple_num_to_header_index(metadata$2, tuple_num$0),
       header = unsafe_header(t$0, header_index$0);
      if(1 - is_used(header))
       unsafe_add_to_free_list(t$0, metadata$2, header_index$0);
      var _a9_ = tuple_num$0 - 1 | 0;
      if(0 === tuple_num$0) break;
      tuple_num$0 = _a9_;
     }
    }
    return t$0;
   }
   function malloc(t){
    var metadata$0 = metadata(t), header_index = metadata$0[5];
    if(is_null$0(header_index))
     caml_call5
      (failwiths,
       0,
       _S_,
       cst_Pool_malloc_of_full_pool,
       t,
       function(x_043){
        return sexp_of_t$3(function(param){return _R_;}, x_043);
       });
    metadata$0[5] = unsafe_header(t, header_index);
    metadata$0[3] = metadata$0[3] + 1 | 0;
    var tuple_id = metadata$0[4];
    unsafe_set_header(t, header_index, -1 - tuple_id | 0);
    var
     _aZ_ =
       arch_sixtyfour
        ? tuple_id + 1 | 0
        : caml_call2(Core[90], tuple_id, max_value) ? 0 : tuple_id + 1 | 0;
    metadata$0[4] = _aZ_;
    return create(header_index, tuple_id);
   }
   function unsafe_free(t, pointer){
    var metadata$0 = metadata(t);
    metadata$0[3] = metadata$0[3] - 1 | 0;
    unsafe_add_to_free_list(t, metadata$0, pointer & header_index_mask);
    var match = metadata$0[6];
    if(match){
     var
      dummy = match[1],
      _aU_ = metadata$0[1],
      _aV_ = first_slot_index(pointer);
     return caml_call5(Core_Uniform_array[38], dummy, 0, t, _aV_, _aU_);
    }
    var
     pos = first_slot_index(pointer),
     _aX_ = metadata$0[1] - 1 | 0,
     _aW_ = 0;
    if(_aX_ >= 0){
     var i = _aW_;
     for(;;){
      caml_call2(Core_Uniform_array[47], t, pos + i | 0);
      var _aY_ = i + 1 | 0;
      if(_aX_ === i) break;
      i = _aY_;
     }
    }
    return 0;
   }
   function free(t, pointer){
    if(1 - pointer_is_valid(t, pointer))
     caml_call5
      (failwiths,
       0,
       _V_,
       cst_Pool_free_of_invalid_point,
       [0, pointer, t],
       function(param){
        var
         arg1_045 = param[2],
         arg0_044 = param[1],
         res0_046 = sexp_of_t$1(function(param){return _T_;}, arg0_044),
         res1_047 = sexp_of_t$3(function(param){return _U_;}, arg1_045);
        return [1, [0, res0_046, [0, res1_047, 0]]];
       });
    return unsafe_free(t, pointer);
   }
   function new1(t, a0){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    return pointer;
   }
   function new2(t, a0, a1){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    return pointer;
   }
   function new3(t, a0, a1, a2){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    return pointer;
   }
   function new4(t, a0, a1, a2, a3){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    return pointer;
   }
   function new5(t, a0, a1, a2, a3, a4){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    return pointer;
   }
   function new6(t, a0, a1, a2, a3, a4, a5){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    return pointer;
   }
   function new7(t, a0, a1, a2, a3, a4, a5, a6){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    return pointer;
   }
   function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    return pointer;
   }
   function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    return pointer;
   }
   function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    return pointer;
   }
   function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    return pointer;
   }
   function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    return pointer;
   }
   function new13(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    caml_call3(Core_Uniform_array[22], t, offset + 13 | 0, a12);
    return pointer;
   }
   function new14
   (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    var pointer = malloc(t), offset = pointer & header_index_mask;
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    caml_call3(Core_Uniform_array[22], t, offset + 13 | 0, a12);
    caml_call3(Core_Uniform_array[22], t, offset + 14 | 0, a13);
    return pointer;
   }
   function get(t, p, slot){
    var _aT_ = slot_index(p, slot);
    return caml_call2(Core_Uniform_array[19], t, _aT_);
   }
   function unsafe_get(t, p, slot){
    var _aS_ = slot_index(p, slot);
    return caml_call2(Core_Uniform_array[20], t, _aS_);
   }
   function set(t, p, slot, x){
    var _aR_ = slot_index(p, slot);
    return caml_call3(Core_Uniform_array[21], t, _aR_, x);
   }
   function unsafe_set(t, p, slot, x){
    var _aQ_ = slot_index(p, slot);
    return caml_call3(Core_Uniform_array[22], t, _aQ_, x);
   }
   function get_tuple(t, pointer){
    var metadata$0 = metadata(t), len = metadata$0[1];
    if(caml_call2(Core[90], len, 1)) return get(t, pointer, Slot[3]);
    var _aP_ = first_slot_index(pointer);
    return caml_call3(Core_Uniform_array[39], t, _aP_, len);
   }
   function create$1(slots, capacity){
    return create_with_dummy(slots, capacity, 0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool);
   var
    Tuple_pool =
      [0,
       Tuple_pool_Tuple_type[1],
       Slot,
       [0,
        sexp_of_t$1,
        typerep_of_t,
        typename_of_t,
        null$0,
        is_null,
        phys_compare,
        phys_equal,
        _l_],
       sexp_of_t$3,
       invariant$0,
       pointer_is_valid,
       id_of_pointer,
       pointer_of_id_exn,
       create$0,
       max_capacity,
       capacity$1,
       length$1,
       grow,
       is_full,
       free,
       unsafe_free,
       new1,
       new2,
       new3,
       new4,
       new5,
       new6,
       new7,
       new8,
       new9,
       new10,
       new11,
       new12,
       new13,
       new14,
       get_tuple,
       get,
       unsafe_get,
       set,
       unsafe_set,
       [0,
        Tuple_pool_Tuple_type[1],
        Slot,
        [0,
         sexp_of_t$1,
         typerep_of_t,
         typename_of_t,
         null$0,
         is_null,
         phys_compare,
         phys_equal,
         _l_],
        sexp_of_t$3,
        invariant$0,
        pointer_is_valid,
        id_of_pointer,
        pointer_of_id_exn,
        max_capacity,
        capacity$1,
        length$1,
        grow,
        is_full,
        free,
        unsafe_free,
        new1,
        new2,
        new3,
        new4,
        new5,
        new6,
        new7,
        new8,
        new9,
        new10,
        new11,
        new12,
        new13,
        new14,
        get_tuple,
        get,
        unsafe_get,
        set,
        unsafe_set,
        create$1],
       function(Pool){
        var check_invariant = [0, 1], show_messages = [0, 1];
        function debug(name, ts, arg, sexp_of_arg, sexp_of_result, f){
         if(check_invariant[1]){
          var _aL_ = caml_call1(Pool[5], function(_aO_){return 0;});
          caml_call2(Core_List[9], ts, _aL_);
         }
         if(show_messages[1]){
          var _aM_ = concat([0, prefix, [0, name, 0]]);
          caml_call3(Core_Debug[2], _aM_, arg, sexp_of_arg);
         }
         var result_or_exn = caml_call1(Core_Result[47], f);
         if(show_messages[1]){
          var _aN_ = concat([0, prefix, [0, name, _W_]]);
          caml_call3
           (Core_Debug[2],
            _aN_,
            result_or_exn,
            function(x_048){
             return caml_call3
                     (Core_Result[10], sexp_of_result, Core[537], x_048);
            });
         }
         return caml_call1(Core_Result[32], result_or_exn);
        }
        var
         Slots = Pool[1],
         Slot = Pool[2],
         sexp_of_t = Pool[3][1],
         Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name$0]),
         typename_of_t = Typename_of_t[2];
        function typerep_of_t(of_slots){
         var name_of_t = caml_call1(Typename_of_t[1], of_slots);
         return [9,
                 [0,
                  name_of_t,
                  [0,
                   [246,
                    function(_aK_){return caml_call1(Pool[3][2], of_slots);}]]]];
        }
        function phys_compare(t1, t2){
         return debug
                 (cst_Pointer_phys_compare,
                  0,
                  [0, t1, t2],
                  function(param){
                   var
                    arg1_052 = param[2],
                    arg0_051 = param[1],
                    res0_053 =
                      caml_call2
                       (sexp_of_t, function(param){return _X_;}, arg0_051),
                    res1_054 =
                      caml_call2
                       (sexp_of_t, function(param){return _Y_;}, arg1_052);
                   return [1, [0, res0_053, [0, res1_054, 0]]];
                  },
                  Core[356],
                  function(param){return caml_call2(Pool[3][6], t1, t2);});
        }
        function phys_equal(t1, t2){
         return debug
                 (cst_Pointer_phys_equal,
                  0,
                  [0, t1, t2],
                  function(param){
                   var
                    arg1_056 = param[2],
                    arg0_055 = param[1],
                    res0_057 =
                      caml_call2
                       (sexp_of_t, function(param){return _Z_;}, arg0_055),
                    res1_058 =
                      caml_call2
                       (sexp_of_t, function(param){return ___;}, arg1_056);
                   return [1, [0, res0_057, [0, res1_058, 0]]];
                  },
                  Core[305],
                  function(param){return caml_call2(Pool[3][7], t1, t2);});
        }
        function is_null(t){
         return debug
                 (cst_Pointer_is_null,
                  0,
                  t,
                  function(x_059){
                   return caml_call2
                           (sexp_of_t, function(param){return _$_;}, x_059);
                  },
                  Core[305],
                  function(param){return caml_call1(Pool[3][5], t);});
        }
        var
         null$0 = Pool[3][4],
         _aG_ = Pool[3][8][5],
         _aH_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _aG_], 0],
         _aI_ =
           caml_call1(Bin_prot_Shape[4][1], cst_tuple_pool_src_tuple_pool_$7),
         group = caml_call2(Bin_prot_Shape[6], _aI_, _aH_),
         _aJ_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0),
         bin_shape_t =
           caml_call1(caml_call2(Bin_prot_Shape[14], group, _aJ_), 0),
         bin_size_t = Pool[3][8][1],
         bin_write_t = Pool[3][8][2],
         bin_writer_t = [0, bin_size_t, bin_write_t],
         bin_read_t = Pool[3][8][4],
         bin_read_t$0 = Pool[3][8][3],
         bin_reader_t = [0, bin_read_t$0, bin_read_t],
         bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
         t_of_sexp = Pool[3][8][9],
         sexp_of_t$0 = Pool[3][8][10];
        function of_int63(i){
         return debug
                 (cst_Pointer_Id_of_int63,
                  0,
                  i,
                  Core_Int63[99],
                  sexp_of_t$0,
                  function(param){return caml_call1(Pool[3][8][12], i);});
        }
        function to_int63(t){
         return debug
                 (cst_Pointer_Id_to_int63,
                  0,
                  t,
                  sexp_of_t$0,
                  Core_Int63[99],
                  function(param){return caml_call1(Pool[3][8][11], t);});
        }
        var sexp_of_t$1 = Pool[4], invariant = Pool[5], length = Pool[12];
        function id_of_pointer(t, pointer){
         return debug
                 (cst_id_of_pointer,
                  [0, t, 0],
                  pointer,
                  function(x_063){
                   return caml_call2
                           (sexp_of_t, function(param){return _aa_;}, x_063);
                  },
                  sexp_of_t$0,
                  function(param){return caml_call2(Pool[7], t, pointer);});
        }
        function pointer_of_id_exn(t, id){
         return debug
                 (cst_pointer_of_id_exn,
                  [0, t, 0],
                  id,
                  sexp_of_t$0,
                  function(x_064){
                   return caml_call2
                           (sexp_of_t, function(param){return _ab_;}, x_064);
                  },
                  function(param){return caml_call2(Pool[8], t, id);});
        }
        function pointer_is_valid(t, pointer){
         return debug
                 (cst_pointer_is_valid,
                  [0, t, 0],
                  pointer,
                  function(x_065){
                   return caml_call2
                           (sexp_of_t, function(param){return _ac_;}, x_065);
                  },
                  Core[305],
                  function(param){return caml_call2(Pool[6], t, pointer);});
        }
        function create(slots, capacity, dummy){
         return debug
                 (cst_create,
                  0,
                  capacity,
                  Core[356],
                  function(x_066){
                   return caml_call2
                           (sexp_of_t$1, function(param){return _ad_;}, x_066);
                  },
                  function(param){
                   return caml_call3(Pool[9], slots, capacity, dummy);
                  });
        }
        function max_capacity(slots_per_tuple){
         return debug
                 (cst_max_capacity,
                  0,
                  slots_per_tuple,
                  Core[356],
                  Core[356],
                  function(param){
                   return caml_call1(Pool[10], slots_per_tuple);
                  });
        }
        function capacity(t){
         return debug
                 (cst_capacity$0,
                  [0, t, 0],
                  t,
                  function(x_067){
                   return caml_call2
                           (sexp_of_t$1, function(param){return _ae_;}, x_067);
                  },
                  Core[356],
                  function(param){return caml_call1(Pool[11], t);});
        }
        function grow(capacity, t){
         return debug
                 (cst_grow,
                  [0, t, 0],
                  [0, -1011154630, capacity],
                  function(param){
                   var v_068 = param[2];
                   return [1,
                           [0, _ag_, [0, caml_call2(Core[454], Core[356], v_068), 0]]];
                  },
                  function(x_069){
                   return caml_call2
                           (sexp_of_t$1, function(param){return _af_;}, x_069);
                  },
                  function(param){return caml_call2(Pool[13], capacity, t);});
        }
        function is_full(t){
         return debug
                 (cst_is_full,
                  [0, t, 0],
                  t,
                  function(x_070){
                   return caml_call2
                           (sexp_of_t$1, function(param){return _ah_;}, x_070);
                  },
                  Core[305],
                  function(param){return caml_call1(Pool[14], t);});
        }
        function unsafe_free(t, p){
         return debug
                 (cst_unsafe_free,
                  [0, t, 0],
                  p,
                  function(x_071){
                   return caml_call2
                           (sexp_of_t, function(param){return _ai_;}, x_071);
                  },
                  Core[518],
                  function(param){return caml_call2(Pool[16], t, p);});
        }
        function free(t, p){
         return debug
                 (cst_free,
                  [0, t, 0],
                  p,
                  function(x_072){
                   return caml_call2
                           (sexp_of_t, function(param){return _aj_;}, x_072);
                  },
                  Core[518],
                  function(param){return caml_call2(Pool[15], t, p);});
        }
        function debug_new(t, f){
         return debug
                 (cst_new,
                  [0, t, 0],
                  0,
                  Core[518],
                  function(x_073){
                   return caml_call2
                           (sexp_of_t, function(param){return _ak_;}, x_073);
                  },
                  f);
        }
        function new1(t, a0){
         return debug_new
                 (t, function(param){return caml_call2(Pool[17], t, a0);});
        }
        function new2(t, a0, a1){
         return debug_new
                 (t, function(param){return caml_call3(Pool[18], t, a0, a1);});
        }
        function new3(t, a0, a1, a2){
         return debug_new
                 (t,
                  function(param){return caml_call4(Pool[19], t, a0, a1, a2);});
        }
        function new4(t, a0, a1, a2, a3){
         return debug_new
                 (t,
                  function(param){
                   return caml_call5(Pool[20], t, a0, a1, a2, a3);
                  });
        }
        function new5(t, a0, a1, a2, a3, a4){
         return debug_new
                 (t,
                  function(param){
                   return caml_call6(Pool[21], t, a0, a1, a2, a3, a4);
                  });
        }
        function new6(t, a0, a1, a2, a3, a4, a5){
         return debug_new
                 (t,
                  function(param){
                   return caml_call7(Pool[22], t, a0, a1, a2, a3, a4, a5);
                  });
        }
        function new7(t, a0, a1, a2, a3, a4, a5, a6){
         return debug_new
                 (t,
                  function(param){
                   return caml_call8(Pool[23], t, a0, a1, a2, a3, a4, a5, a6);
                  });
        }
        function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
         return debug_new
                 (t,
                  function(param){
                   return caml_call9
                           (Pool[24], t, a0, a1, a2, a3, a4, a5, a6, a7);
                  });
        }
        function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
         return debug_new
                 (t,
                  function(param){
                   return caml_call10
                           (Pool[25], t, a0, a1, a2, a3, a4, a5, a6, a7, a8);
                  });
        }
        function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
         return debug_new
                 (t,
                  function(param){
                   return caml_call11
                           (Pool[26], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
                  });
        }
        function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
         return debug_new
                 (t,
                  function(param){
                   return caml_call12
                           (Pool[27], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                  });
        }
        function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
         return debug_new
                 (t,
                  function(param){
                   return caml_call13
                           (Pool[28],
                            t,
                            a0,
                            a1,
                            a2,
                            a3,
                            a4,
                            a5,
                            a6,
                            a7,
                            a8,
                            a9,
                            a10,
                            a11);
                  });
        }
        function new13
        (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
         return debug_new
                 (t,
                  function(param){
                   return caml_call14
                           (Pool[29],
                            t,
                            a0,
                            a1,
                            a2,
                            a3,
                            a4,
                            a5,
                            a6,
                            a7,
                            a8,
                            a9,
                            a10,
                            a11,
                            a12);
                  });
        }
        function new14
        (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
         return debug_new
                 (t,
                  function(param){
                   return caml_call15
                           (Pool[30],
                            t,
                            a0,
                            a1,
                            a2,
                            a3,
                            a4,
                            a5,
                            a6,
                            a7,
                            a8,
                            a9,
                            a10,
                            a11,
                            a12,
                            a13);
                  });
        }
        function get_tuple(t, pointer){
         return debug
                 (cst_get_tuple,
                  [0, t, 0],
                  pointer,
                  function(x_074){
                   return caml_call2
                           (sexp_of_t, function(param){return _am_;}, x_074);
                  },
                  function(param){return _al_;},
                  function(param){return caml_call2(Pool[31], t, pointer);});
        }
        function debug_get(name, f, t, pointer){
         return debug
                 (name,
                  [0, t, 0],
                  pointer,
                  function(x_075){
                   return caml_call2
                           (sexp_of_t, function(param){return _ao_;}, x_075);
                  },
                  function(param){return _an_;},
                  function(param){return caml_call2(f, t, pointer);});
        }
        function get(t, pointer, slot){
         return caml_call1(debug_get(cst_get, Pool[32], t, pointer), slot);
        }
        function unsafe_get(t, pointer, slot){
         return caml_call1
                 (debug_get(cst_unsafe_get, Pool[33], t, pointer), slot);
        }
        function debug_set(name, f, t, pointer, slot, a){
         return debug
                 (name,
                  [0, t, 0],
                  pointer,
                  function(x_076){
                   return caml_call2
                           (sexp_of_t, function(param){return _ap_;}, x_076);
                  },
                  Core[518],
                  function(param){return caml_call4(f, t, pointer, slot, a);});
        }
        function set(t, pointer, slot, a){
         return debug_set(cst_set, Pool[34], t, pointer, slot, a);
        }
        function unsafe_set(t, pointer, slot, a){
         return debug_set(cst_unsafe_set, Pool[35], t, pointer, slot, a);
        }
        return [0,
                Slots,
                Slot,
                [0,
                 sexp_of_t,
                 typerep_of_t,
                 typename_of_t,
                 null$0,
                 is_null,
                 phys_compare,
                 phys_equal,
                 [0,
                  bin_size_t,
                  bin_write_t,
                  bin_read_t$0,
                  bin_read_t,
                  bin_shape_t,
                  bin_writer_t,
                  bin_reader_t,
                  bin_t,
                  t_of_sexp,
                  sexp_of_t$0,
                  to_int63,
                  of_int63]],
                sexp_of_t$1,
                invariant,
                pointer_is_valid,
                id_of_pointer,
                pointer_of_id_exn,
                create,
                max_capacity,
                capacity,
                length,
                grow,
                is_full,
                free,
                unsafe_free,
                new1,
                new2,
                new3,
                new4,
                new5,
                new6,
                new7,
                new8,
                new9,
                new10,
                new11,
                new12,
                new13,
                new14,
                get_tuple,
                get,
                unsafe_get,
                set,
                unsafe_set,
                check_invariant,
                show_messages];
       },
       function(Pool){
        var Slots = Pool[1], Slot = Pool[2];
        function sexp_of_t(of_slots_077, param){
         var
          is_valid_079 = param[1],
          pointer_081 = param[2],
          arg_082 = caml_call2(Pool[3][1], of_slots_077, pointer_081),
          bnds_078 = [0, [1, [0, _aq_, [0, arg_082, 0]]], 0],
          arg_080 = caml_call1(Core[305], is_valid_079),
          bnds_078$0 = [0, [1, [0, _ar_, [0, arg_080, 0]]], bnds_078];
         return [1, bnds_078$0];
        }
        var
         Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name$1]),
         typename_of_t = Typename_of_t[2];
        function typerep_of_t(of_slots){
         var name_of_t = caml_call1(Typename_of_t[1], of_slots);
         return [9,
                 [0,
                  name_of_t,
                  [0,
                   [246,
                    function(param){
                     var
                      _aD_ = caml_call2(Typerep_lib_Typename[1], 0, 0),
                      field0 =
                        caml_call1
                         (Typerep_lib_Std[1][8][7],
                          [0,
                           cst_is_valid,
                           Core[308],
                           0,
                           _aD_,
                           function(t){return t[1];},
                           1]),
                      _aE_ = caml_call2(Typerep_lib_Typename[1], 0, 0),
                      _aF_ =
                        [0,
                         cst_pointer,
                         caml_call1(Pool[3][2], of_slots),
                         1,
                         _aE_,
                         function(t){return t[2];},
                         0],
                      field1 = caml_call1(Typerep_lib_Std[1][8][7], _aF_),
                      typename = caml_call1(Typerep_lib_Std[1][1][2], name_of_t),
                      has_double_array_tag =
                        caml_call1
                         (Typerep_lib_Typerep_obj[4],
                          [0, Typerep_lib_Typerep_obj[3], Typerep_lib_Typerep_obj[3]]),
                      fields = [0, [0, field0], [0, field1]];
                     function create(param){
                      var
                       get = param[1],
                       is_valid = caml_call1(get, field0),
                       pointer = caml_call1(get, field1);
                      return [0, is_valid, pointer];
                     }
                     return [7,
                             caml_call1
                              (Typerep_lib_Std[1][10][7],
                               [0, typename, fields, has_double_array_tag, create])];
                    }]]]];
        }
        function create(pointer){return [0, 1, pointer];}
        function null$0(param){return [0, 0, caml_call1(Pool[3][4], 0)];}
        function phys_compare(t1, t2){
         return caml_call2(Pool[3][6], t1[2], t2[2]);
        }
        function phys_equal(t1, t2){
         return caml_call2(Pool[3][7], t1[2], t2[2]);
        }
        function is_null(t){return caml_call1(Pool[3][5], t[2]);}
        function follow(t){
         if(1 - t[1])
          caml_call5
           (failwiths,
            0,
            _at_,
            cst_attempt_to_use_invalid_poi,
            t,
            function(x_083){
             return sexp_of_t(function(param){return _as_;}, x_083);
            });
         return t[2];
        }
        function invalidate(t){t[1] = 0; return 0;}
        var
         Id = Pool[3][8],
         sexp_of_t$0 = Pool[4],
         invariant = Pool[5],
         length = Pool[12];
        function pointer_is_valid(t, param){
         var is_valid = param[1], pointer = param[2];
         return is_valid ? caml_call2(Pool[6], t, pointer) : is_valid;
        }
        function id_of_pointer(t, pointer){
         return caml_call2(Pool[7], t, pointer[2]);
        }
        function pointer_of_id_exn(t, id){
         var
          pointer = caml_call2(Pool[8], t, id),
          is_valid = caml_call2(Pool[6], t, pointer);
         return [0, is_valid, pointer];
        }
        var
         create$0 = Pool[9],
         capacity = Pool[11],
         max_capacity = Pool[10],
         grow = Pool[13],
         is_full = Pool[14];
        function get_tuple(t, p){
         var _aC_ = follow(p);
         return caml_call2(Pool[31], t, _aC_);
        }
        function get(t, p){
         var _aB_ = follow(p);
         return caml_call2(Pool[32], t, _aB_);
        }
        function unsafe_get(t, p){
         var _aA_ = follow(p);
         return caml_call2(Pool[33], t, _aA_);
        }
        function set(t, p, slot, v){
         var _az_ = follow(p);
         return caml_call4(Pool[34], t, _az_, slot, v);
        }
        function unsafe_set(t, p, slot, v){
         var _ay_ = follow(p);
         return caml_call4(Pool[35], t, _ay_, slot, v);
        }
        function unsafe_free(t, p){
         var _ax_ = follow(p);
         caml_call2(Pool[16], t, _ax_);
         return invalidate(p);
        }
        function free(t, p){
         var _aw_ = follow(p);
         caml_call2(Pool[15], t, _aw_);
         return invalidate(p);
        }
        function new1(t, a0){return create(caml_call2(Pool[17], t, a0));}
        function new2(t, a0, a1){
         return create(caml_call3(Pool[18], t, a0, a1));
        }
        function new3(t, a0, a1, a2){
         return create(caml_call4(Pool[19], t, a0, a1, a2));
        }
        function new4(t, a0, a1, a2, a3){
         return create(caml_call5(Pool[20], t, a0, a1, a2, a3));
        }
        function new5(t, a0, a1, a2, a3, a4){
         return create(caml_call6(Pool[21], t, a0, a1, a2, a3, a4));
        }
        function new6(t, a0, a1, a2, a3, a4, a5){
         return create(caml_call7(Pool[22], t, a0, a1, a2, a3, a4, a5));
        }
        function new7(t, a0, a1, a2, a3, a4, a5, a6){
         return create(caml_call8(Pool[23], t, a0, a1, a2, a3, a4, a5, a6));
        }
        function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
         return create
                 (caml_call9(Pool[24], t, a0, a1, a2, a3, a4, a5, a6, a7));
        }
        function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
         return create
                 (caml_call10(Pool[25], t, a0, a1, a2, a3, a4, a5, a6, a7, a8));
        }
        function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
         return create
                 (caml_call11
                   (Pool[26], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
        }
        function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
         return create
                 (caml_call12
                   (Pool[27], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
        }
        function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
         return create
                 (caml_call13
                   (Pool[28],
                    t,
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11));
        }
        function new13
        (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
         return create
                 (caml_call14
                   (Pool[29],
                    t,
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12));
        }
        function new14
        (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
         return create
                 (caml_call15
                   (Pool[30],
                    t,
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13));
        }
        return [0,
                Slots,
                Slot,
                [0,
                 sexp_of_t,
                 typerep_of_t,
                 typename_of_t,
                 null$0,
                 is_null,
                 phys_compare,
                 phys_equal,
                 Id],
                sexp_of_t$0,
                invariant,
                pointer_is_valid,
                id_of_pointer,
                pointer_of_id_exn,
                create$0,
                max_capacity,
                capacity,
                length,
                grow,
                is_full,
                free,
                unsafe_free,
                new1,
                new2,
                new3,
                new4,
                new5,
                new6,
                new7,
                new8,
                new9,
                new10,
                new11,
                new12,
                new13,
                new14,
                get_tuple,
                get,
                unsafe_get,
                set,
                unsafe_set];
       }];
   runtime.caml_register_global(178, Tuple_pool, cst_Tuple_pool$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0dXBsZV9wb29sLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJ0MSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJ0MTAiLCJ0MTEiLCJ0MTIiLCJ0MTMiLCJ0MTQiLCJzZXhwX29mX3QiLCJ2XzAwNiIsInNsb3RzX3Blcl90dXBsZV8wMDIiLCJhcmdfMDAzIiwiYm5kc18wMDEiLCJzZXhwX29mX3QkMCIsIm9mX3R1cGxlXzAwNyIsIm9mX3ZhcmlhbnRfMDA4Iiwic2xvdHNfcGVyX3R1cGxlIiwibiIsInNleHBfb2ZfdDEiLCJvZl9hMF8wMDkiLCJzZXhwX29mX3QyIiwib2ZfYTBfMDEwIiwib2ZfYTFfMDExIiwic2V4cF9vZl90MyIsIm9mX2EwXzAxMiIsIm9mX2ExXzAxMyIsIm9mX2EyXzAxNCIsInNleHBfb2ZfdDQiLCJvZl9hMF8wMTUiLCJvZl9hMV8wMTYiLCJvZl9hMl8wMTciLCJvZl9hM18wMTgiLCJzZXhwX29mX3Q1Iiwib2ZfYTBfMDE5Iiwib2ZfYTFfMDIwIiwib2ZfYTJfMDIxIiwib2ZfYTNfMDIyIiwib2ZfYTRfMDIzIiwic2V4cF9vZl90NiIsIm9mX2EwXzAyNCIsIm9mX2ExXzAyNSIsIm9mX2EyXzAyNiIsIm9mX2EzXzAyNyIsIm9mX2E0XzAyOCIsIm9mX2E1XzAyOSIsInNleHBfb2ZfdDciLCJvZl9hMF8wMzAiLCJvZl9hMV8wMzEiLCJvZl9hMl8wMzIiLCJvZl9hM18wMzMiLCJvZl9hNF8wMzQiLCJvZl9hNV8wMzUiLCJvZl9hNl8wMzYiLCJzZXhwX29mX3Q4Iiwib2ZfYTBfMDM3Iiwib2ZfYTFfMDM4Iiwib2ZfYTJfMDM5Iiwib2ZfYTNfMDQwIiwib2ZfYTRfMDQxIiwib2ZfYTVfMDQyIiwib2ZfYTZfMDQzIiwib2ZfYTdfMDQ0Iiwic2V4cF9vZl90OSIsIm9mX2EwXzA0NSIsIm9mX2ExXzA0NiIsIm9mX2EyXzA0NyIsIm9mX2EzXzA0OCIsIm9mX2E0XzA0OSIsIm9mX2E1XzA1MCIsIm9mX2E2XzA1MSIsIm9mX2E3XzA1MiIsIm9mX2E4XzA1MyIsInNleHBfb2ZfdDEwIiwib2ZfYTBfMDU0Iiwib2ZfYTFfMDU1Iiwib2ZfYTJfMDU2Iiwib2ZfYTNfMDU3Iiwib2ZfYTRfMDU4Iiwib2ZfYTVfMDU5Iiwib2ZfYTZfMDYwIiwib2ZfYTdfMDYxIiwib2ZfYThfMDYyIiwib2ZfYTlfMDYzIiwic2V4cF9vZl90MTEiLCJvZl9hMF8wNjQiLCJvZl9hMV8wNjUiLCJvZl9hMl8wNjYiLCJvZl9hM18wNjciLCJvZl9hNF8wNjgiLCJvZl9hNV8wNjkiLCJvZl9hNl8wNzAiLCJvZl9hN18wNzEiLCJvZl9hOF8wNzIiLCJvZl9hOV8wNzMiLCJvZl9hMTBfMDc0Iiwic2V4cF9vZl90MTIiLCJvZl9hMF8wNzUiLCJvZl9hMV8wNzYiLCJvZl9hMl8wNzciLCJvZl9hM18wNzgiLCJvZl9hNF8wNzkiLCJvZl9hNV8wODAiLCJvZl9hNl8wODEiLCJvZl9hN18wODIiLCJvZl9hOF8wODMiLCJvZl9hOV8wODQiLCJvZl9hMTBfMDg1Iiwib2ZfYTExXzA4NiIsInNleHBfb2ZfdDEzIiwib2ZfYTBfMDg3Iiwib2ZfYTFfMDg4Iiwib2ZfYTJfMDg5Iiwib2ZfYTNfMDkwIiwib2ZfYTRfMDkxIiwib2ZfYTVfMDkyIiwib2ZfYTZfMDkzIiwib2ZfYTdfMDk0Iiwib2ZfYThfMDk1Iiwib2ZfYTlfMDk2Iiwib2ZfYTEwXzA5NyIsIm9mX2ExMV8wOTgiLCJvZl9hMTJfMDk5Iiwic2V4cF9vZl90MTQiLCJvZl9hMF8xMDAiLCJvZl9hMV8xMDEiLCJvZl9hMl8xMDIiLCJvZl9hM18xMDMiLCJvZl9hNF8xMDQiLCJvZl9hNV8xMDUiLCJvZl9hNl8xMDYiLCJvZl9hN18xMDciLCJvZl9hOF8xMDgiLCJvZl9hOV8xMDkiLCJvZl9hMTBfMTEwIiwib2ZfYTExXzExMSIsIm9mX2ExMl8xMTIiLCJvZl9hMTNfMTEzIiwibmFtZSQxIiwicHJlZml4IiwibmFtZSQwIiwibmFtZSIsImZhaWx3aXRocyIsImFyY2hfc2l4dHlmb3VyIiwibnVtX2JpdHMiLCJtYXhfdmFsdWUiLCJ0b19zdHJpbmciLCJzcHJpbnRmIiwiY29uY2F0IiwibCIsIm9mX3Nsb3RzXzAwNyIsIm9mX2FfMDA4IiwiZXF1YWwiLCJtYXhfc2xvdCIsImFycmF5X2luZGV4X251bV9iaXRzIiwibWFza2VkX3R1cGxlX2lkX251bV9iaXRzIiwibWF4X2FycmF5X2xlbmd0aCIsIm9mX2ludCIsImkiLCJleGFtcGxlcyIsInR1cGxlX2lkX21hc2siLCJ0eXBlbmFtZV9vZl90IiwidHlwZXJlcF9vZl90Iiwib2Zfc2xvdHMiLCJuYW1lX29mX3QiLCJzZXhwX29mX3QkMSIsInQiLCJwaHlzX2VxdWFsIiwicGh5c19jb21wYXJlIiwibnVsbCQwIiwiaXNfbnVsbCIsImNyZWF0ZSIsImhlYWRlcl9pbmRleCIsInR1cGxlX2lkIiwiaGVhZGVyX2luZGV4X21hc2siLCJpbnZhcmlhbnQiLCJzbG90X2luZGV4Iiwic2xvdCIsImZpcnN0X3Nsb3RfaW5kZXgiLCJ0b19pbnQ2MyIsIm9mX2ludDYzIiwibnVsbCQxIiwiaXNfbnVsbCQwIiwiaXNfZnJlZSIsImlzX3VzZWQiLCJ0dXBsZV9pZCQwIiwibWV0YWRhdGFfaW5kZXgiLCJzdGFydF9vZl90dXBsZXNfaW5kZXgiLCJtYXhfY2FwYWNpdHkiLCJkdW1teSIsInIiLCJmaXJzdF9mcmVlIiwic2V0X2ZpcnN0X2ZyZWUiLCJ2IiwibmV4dF9pZCIsInNldF9uZXh0X2lkIiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsImNhcGFjaXR5IiwiZHVtbXkkMCIsImZpcnN0X2ZyZWUkMCIsIm5leHRfaWQkMCIsImxlbmd0aCQwIiwiY2FwYWNpdHkkMCIsInNsb3RzX3Blcl90dXBsZSQwIiwiaW5pdCIsImFycmF5X2luZGljZXNfcGVyX3R1cGxlIiwiYXJyYXlfbGVuZ3RoIiwidHVwbGVfbnVtX3RvX2hlYWRlcl9pbmRleCIsInR1cGxlX251bSIsInR1cGxlX251bV90b19maXJzdF9zbG90X2luZGV4IiwibWV0YWRhdGEiLCJsZW5ndGgkMSIsInNleHBfb2ZfdCQzIiwic2V4cF9vZl90eSIsImNhcGFjaXR5XzAxOCIsInNsb3RzX3Blcl90dXBsZV8wMTYiLCJsZW5ndGhfMDIwIiwibmV4dF9pZF8wMjIiLCJmaXJzdF9mcmVlXzAyNCIsImR1bW15XzAyNiIsImFyZ18wMjciLCJibmRzXzAxNSIsImFyZ18wMjUiLCJibmRzXzAxNSQwIiwiYXJnXzAyMyIsImJuZHNfMDE1JDEiLCJhcmdfMDIxIiwiYm5kc18wMTUkMiIsImFyZ18wMTkiLCJibmRzXzAxNSQzIiwiYXJnXzAxNyIsImJuZHNfMDE1JDQiLCJ1bnNhZmVfaGVhZGVyIiwidW5zYWZlX3NldF9oZWFkZXIiLCJoZWFkZXIiLCJoZWFkZXJfaW5kZXhfaXNfaW5fYm91bmRzIiwidW5zYWZlX3BvaW50ZXJfaXNfbGl2ZSIsInBvaW50ZXIiLCJ0JDAiLCJwb2ludGVyX2lzX3ZhbGlkIiwiaWRfb2ZfcG9pbnRlciIsImlzX3ZhbGlkX2hlYWRlcl9pbmRleCIsIm1ldGFkYXRhJDAiLCJwb2ludGVyX29mX2lkX2V4biIsInQkMSIsImlkIiwic2hvdWxkX2VxdWFsIiwieF8wMDkiLCJleG4kMCIsImV4biIsImFyZzFfMDExIiwiYXJnMF8wMTAiLCJyZXMwXzAxMiIsInJlczFfMDEzIiwiYXJnMl8wMzAiLCJhcmcxXzAyOSIsImFyZzBfMDI4IiwicmVzMF8wMzEiLCJyZXMxXzAzMiIsInJlczJfMDMzIiwiaW52YXJpYW50JDAiLCJpbnZhcmlhbnRfYSIsImZyZWUiLCJoZWFkZXJfaW5kZXgkMCIsInR1cGxlX251bSQwIiwiZmlyc3Rfc2xvdCIsImFyZzFfMDM1IiwiYXJnMF8wMzQiLCJyZXMwXzAzNiIsInJlczFfMDM3IiwiY2FwYWNpdHkkMSIsImlzX2Z1bGwiLCJ1bnNhZmVfYWRkX3RvX2ZyZWVfbGlzdCIsIm5leHRfZnJlZV9oZWFkZXJfaW5kZXgiLCJzZXRfbWV0YWRhdGEiLCJjcmVhdGVfYXJyYXkiLCJ1bnNhZmVfaW5pdF9yYW5nZSIsImxvIiwiaGkiLCJjcmVhdGVfd2l0aF9kdW1teSIsInNsb3RzIiwibWF4X2NhcGFjaXR5JDAiLCJhcmcxXzA0MCIsImFyZzBfMDM5IiwicmVzMF8wNDEiLCJ2XzAzOCIsInJlczFfMDQyIiwiY3JlYXRlJDAiLCJncm93Iiwib2xkX2NhcGFjaXR5IiwiYXJnMV8wMDQiLCJhcmcwXzAwMyIsInZfMDAxIiwicmVzMF8wMDUiLCJ2XzAwMiIsInJlczFfMDA2IiwibWV0YWRhdGEkMiIsIm1ldGFkYXRhJDEiLCJtYWxsb2MiLCJ4XzA0MyIsInVuc2FmZV9mcmVlIiwicG9zIiwiYXJnMV8wNDUiLCJhcmcwXzA0NCIsInJlczBfMDQ2IiwicmVzMV8wNDciLCJuZXcxIiwiYTAiLCJvZmZzZXQiLCJuZXcyIiwiYTEiLCJuZXczIiwiYTIiLCJuZXc0IiwiYTMiLCJuZXc1IiwiYTQiLCJuZXc2IiwiYTUiLCJuZXc3IiwiYTYiLCJuZXc4IiwiYTciLCJuZXc5IiwiYTgiLCJuZXcxMCIsImE5IiwibmV3MTEiLCJhMTAiLCJuZXcxMiIsImExMSIsIm5ldzEzIiwiYTEyIiwibmV3MTQiLCJhMTMiLCJnZXQiLCJwIiwidW5zYWZlX2dldCIsInNldCIsIngiLCJ1bnNhZmVfc2V0IiwiZ2V0X3R1cGxlIiwibGVuIiwiY3JlYXRlJDEiLCJjaGVja19pbnZhcmlhbnQiLCJzaG93X21lc3NhZ2VzIiwiZGVidWciLCJ0cyIsImFyZyIsInNleHBfb2ZfYXJnIiwic2V4cF9vZl9yZXN1bHQiLCJmIiwicmVzdWx0X29yX2V4biIsInhfMDQ4IiwiYXJnMV8wNTIiLCJhcmcwXzA1MSIsInJlczBfMDUzIiwicmVzMV8wNTQiLCJhcmcxXzA1NiIsImFyZzBfMDU1IiwicmVzMF8wNTciLCJyZXMxXzA1OCIsInhfMDU5IiwiZ3JvdXAiLCJiaW5fc2hhcGVfdCIsImJpbl9zaXplX3QiLCJiaW5fd3JpdGVfdCIsImJpbl93cml0ZXJfdCIsImJpbl9yZWFkX3QiLCJiaW5fcmVhZF90JDAiLCJiaW5fcmVhZGVyX3QiLCJiaW5fdCIsInRfb2Zfc2V4cCIsInhfMDYzIiwieF8wNjQiLCJ4XzA2NSIsInhfMDY2IiwieF8wNjciLCJ2XzA2OCIsInhfMDY5IiwieF8wNzAiLCJ4XzA3MSIsInhfMDcyIiwiZGVidWdfbmV3IiwieF8wNzMiLCJ4XzA3NCIsImRlYnVnX2dldCIsInhfMDc1IiwiZGVidWdfc2V0IiwiYSIsInhfMDc2Iiwib2Zfc2xvdHNfMDc3IiwiaXNfdmFsaWRfMDc5IiwicG9pbnRlcl8wODEiLCJhcmdfMDgyIiwiYm5kc18wNzgiLCJhcmdfMDgwIiwiYm5kc18wNzgkMCIsImZpZWxkMCIsImZpZWxkMSIsInR5cGVuYW1lIiwiaGFzX2RvdWJsZV9hcnJheV90YWciLCJmaWVsZHMiLCJpc192YWxpZCIsImZvbGxvdyIsInhfMDgzIiwiaW52YWxpZGF0ZSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9jb3JlX2tlcm5lbC90dXBsZV9wb29sL3R1cGxlX3R5cGUubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvY29yZV9rZXJuZWwvdHVwbGVfcG9vbC90dXBsZV9wb29sLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7OztJQW1DTUE7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7Ozs7Ozs7Ozs7OztZQXpDSkM7SUFBQTtLQUFVQztLQUZFQyxzQkFFRkQ7S0FGRUUsVUFBQSxzQkFBQUQ7S0FBWkUsZ0NBQVlEO2dDQUFaQztHQUUrQztZQUMvQ0MsWUFBTUMsY0FBUUMsZ0JBQWQsT0FEQVAsVUFDbUQ7WUFFL0NRLDJCQUE0Q0MsaUJBQU8sT0FBUEE7WUFFaERDLFdBQUtDLFdBQUwsT0FMQVgsVUFLcUM7WUFDckNZLFdBQU1DLFdBQUtDLFdBQVgs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QUdFO29CQUFHRTtvQkFBR0U7b0JBQUdFO29CQUFHRTtvQkFBR0U7b0JBQUlFO29CQUFJRTtRQUN1QjtpQkFHckVDO1NBQU14SyxHQUFFOEksSUFBR0csSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsSUFBR0UsS0FBSUUsS0FBSUUsS0FBSUU7U0FDcEQsT0ExRklwSztrQkEwRlc7O29CQURQTDtvQkFBRThJO29CQUFHRztvQkFBR0U7b0JBQUdFO29CQUFHRTtvQkFBR0U7b0JBQUdFO29CQUFHRTtvQkFBR0U7b0JBQUdFO29CQUFHRTtvQkFBSUU7b0JBQUlFO29CQUFJRTtRQUN1Qjs7Ozs7aUJBaEczRXRVO2lCQUFBeUo7aUJBQUFEO2lCQU9JUTtpQkFHQUM7aUJBRkFGO2lCQUNBRDs7Z0JBY056SjtnQkFFSWlLO2dCQUdBaUU7Z0JBTUFDO2dCQUVBRztnQkFNQTRDO2dCQUVBcEc7Z0JBREFVO2dCQWpCQUY7Z0JBbUJBNkY7Z0JBQ0FqQjtnQkFZQVQ7Z0JBTEFzQztnQkFVQU07Z0JBQ0FHO2dCQUNBRTtnQkFDQUU7Z0JBQ0FFO2dCQUNBRTtnQkFDQUU7Z0JBRUFFO2dCQUlBRTtnQkFJQUU7Z0JBSUFFO2dCQUlBRTtnQkFJQUU7Z0JBSUFFO2dCQWhEQVE7Z0JBQ0FOO2dCQUNBRTtnQkFDQUM7Z0JBQ0FFOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgVHVwbGVfdHlwZV9pbnRmXG5cbm1vZHVsZSBTbG90cyA9IHN0cnVjdFxuICB0eXBlIHVfID0geyBzbG90c19wZXJfdHVwbGUgOiBpbnQgfSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICgndHVwbGUsICd2YXJpYW50KSB1ID0gdV8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSB0XyA9IFsgYFNsb3RzIG9mIHVfIF0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ3R1cGxlLCAndmFyaWFudCkgdCA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHNsb3RzX3Blcl90dXBsZSAoYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gbiB9KSA9IG5cblxuICB0eXBlICdhMCB0MSA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExKSB0MiA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIpIHQzID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzKSB0NCA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0KSB0NSA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUpIHQ2ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2KSB0NyA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUsICdhNiwgJ2E3KSB0OCA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUsICdhNiwgJ2E3LCAnYTgpIHQ5ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcsICdhOCwgJ2E5KSB0MTAgPSB0XyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUsICdhNiwgJ2E3LCAnYTgsICdhOSwgJ2ExMCkgdDExID0gdF9cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICgnYTAsICdhMSwgJ2EyLCAnYTMsICdhNCwgJ2E1LCAnYTYsICdhNywgJ2E4LCAnYTksICdhMTAsICdhMTEpIHQxMiA9IHRfXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcsICdhOCwgJ2E5LCAnYTEwLCAnYTExLCAnYTEyKSB0MTMgPSB0X1xuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUsICdhNiwgJ2E3LCAnYTgsICdhOSwgJ2ExMCwgJ2ExMSwgJ2ExMiwgJ2ExMykgdDE0ID0gdF9cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgdDEgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxIH1cbiAgbGV0IHQyID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMiB9XG4gIGxldCB0MyA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDMgfVxuICBsZXQgdDQgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSA0IH1cbiAgbGV0IHQ1ID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gNSB9XG4gIGxldCB0NiA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDYgfVxuICBsZXQgdDcgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSA3IH1cbiAgbGV0IHQ4ID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gOCB9XG4gIGxldCB0OSA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDkgfVxuICBsZXQgdDEwID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMTAgfVxuICBsZXQgdDExID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMTEgfVxuICBsZXQgdDEyID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMTIgfVxuICBsZXQgdDEzID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMTMgfVxuICBsZXQgdDE0ID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMTQgfVxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHVwbGVfcG9vbF9pbnRmXG5tb2R1bGUgVHVwbGVfdHlwZSA9IFR1cGxlX3R5cGVcblxubGV0IGZhaWx3aXRocyA9IEVycm9yLmZhaWx3aXRoc1xubGV0IHBoeXNfZXF1YWwgPSBDYW1sLiggPT0gKVxubGV0IGFyY2hfc2l4dHlmb3VyID0gU3lzLndvcmRfc2l6ZV9pbl9iaXRzID0gNjRcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICBsZXQgbnVtX2JpdHMgPSBJbnQubnVtX2JpdHNcbiAgbGV0IG1heF92YWx1ZSA9IENhbWwubWF4X2ludFxuICBsZXQgdG9fc3RyaW5nID0gc3RyaW5nX29mX2ludFxuZW5kXG5cbmxldCBzcHJpbnRmID0gUHJpbnRmLnNwcmludGZcbmxldCBjb25jYXQgbCA9IEJhc2UuU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgbFxuXG5tb2R1bGUgdHlwZSBTID0gU1xuXG5tb2R1bGUgUG9vbCA9IHN0cnVjdFxuICBsZXQgZ3Jvd19jYXBhY2l0eSB+Y2FwYWNpdHkgfm9sZF9jYXBhY2l0eSA9XG4gICAgbWF0Y2ggY2FwYWNpdHkgd2l0aFxuICAgIHwgTm9uZSAtPiBpZiBvbGRfY2FwYWNpdHkgPSAwIHRoZW4gMSBlbHNlIG9sZF9jYXBhY2l0eSAqIDJcbiAgICB8IFNvbWUgY2FwYWNpdHkgLT5cbiAgICAgIGlmIGNhcGFjaXR5IDw9IG9sZF9jYXBhY2l0eVxuICAgICAgdGhlblxuICAgICAgICBmYWlsd2l0aHNcbiAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgXCJQb29sLmdyb3cgZ290IHRvbyBzbWFsbCBjYXBhY2l0eVwiXG4gICAgICAgICAgKGBjYXBhY2l0eSBjYXBhY2l0eSwgYG9sZF9jYXBhY2l0eSBvbGRfY2FwYWNpdHkpXG4gICAgICAgICAgWyVzZXhwX29mOiBbIGBjYXBhY2l0eSBvZiBpbnQgXSAqIFsgYG9sZF9jYXBhY2l0eSBvZiBpbnQgXV07XG4gICAgICBjYXBhY2l0eVxuICA7O1xuXG4gIG1vZHVsZSBTbG90cyA9IFR1cGxlX3R5cGUuU2xvdHNcblxuICBsZXQgbWF4X3Nsb3QgPSAxNFxuXG4gICgqIFRoZSBwb29sIGlzIHJlcHJlc2VudGVkIGFzIGEgc2luZ2xlIFtVbmlmb3JtX2FycmF5LnRdLCB3aGVyZSBpbmRleCB6ZXJvIGhhcyB0aGVcbiAgICAgbWV0YWRhdGEgYWJvdXQgdGhlIHBvb2wgYW5kIHRoZSByZW1haW5pbmcgaW5kaWNlcyBhcmUgdGhlIHR1cGxlcyBsYXllZCBvdXQgb25lIGFmdGVyXG4gICAgIHRoZSBvdGhlci4gIEVhY2ggdHVwbGUgdGFrZXMgWzEgKyBzbG90c19wZXJfdHVwbGVdIGluZGljZXMgaW4gdGhlIHBvb2wsIHdoZXJlIHRoZVxuICAgICBmaXJzdCBpbmRleCBob2xkcyBhIGhlYWRlciBhbmQgdGhlIHJlbWFpbmluZyBpbmRpY2VzIGhvbGQgdGhlIHR1cGxlJ3Mgc2xvdHM6XG5cbiAgICAge3ZcbiAgICAgfCBoZWFkZXIgfCBzMCB8IHMxIHwgLi4uIHwgczxOLTE+IHxcbiAgICAgdn1cblxuICAgICBBIFtQb2ludGVyLnRdIHRvIGEgdHVwbGUgY29udGFpbnMgdGhlIGludGVnZXIgaW5kZXggd2hlcmUgaXRzIGhlYWRlciBpcywgYXMgd2VsbCBhc1xuICAgICAoYSBtYXNrIG9mKSB0aGUgdHVwbGUncyB1bmlxdWUgaWQuXG5cbiAgICAgVGhlIGZyZWUgdHVwbGVzIGFyZSBzaW5nbHkgbGlua2VkIHZpYSB0aGUgaGVhZGVycy5cblxuICAgICBXaGVuIGEgdHVwbGUgaXMgaW4gdXNlLCBpdHMgaGVhZGVyIGlzIG1hcmtlZCB0byBpbmRpY2F0ZSBzbywgYW5kIGFsc28gdG8gaW5jbHVkZSB0aGVcbiAgICAgdHVwbGUncyB1bmlxdWUgaWQuICBUaGlzIGFsbG93cyB1cyB0byBjaGVjayBpbiBjb25zdGFudCB0aW1lIHdoZXRoZXIgYSBwb2ludGVyIGlzXG4gICAgIHZhbGlkLCBieSBjb21wYXJpbmcgdGhlIGlkIGluIHRoZSBwb2ludGVyIHdpdGggdGhlIGlkIGluIHRoZSBoZWFkZXIuXG5cbiAgICAgV2hlbiBhIHR1cGxlIGlzIG5vdCBpbiB1c2UsIGl0cyBoZWFkZXIgaXMgcGFydCBvZiB0aGUgZnJlZSBsaXN0LCBhbmQgaXRzIHR1cGxlIHNsb3RzXG4gICAgIGhhdmUgZHVtbXkgdmFsdWVzIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcywgZnJvbSB0aGUgW2R1bW15XSB0dXBsZSBzdXBwbGllZCB0b1xuICAgICBbY3JlYXRlXS4gIFdlIG11c3QgaGF2ZSBkdW1teSB2YWx1ZXMgb2YgdGhlIGNvcnJlY3QgdHlwZSB0byBwcmV2ZW50IGEgc2VnZmF1bHQgaW5cbiAgICAgY29kZSB0aGF0IChtaXN0YWtlbmx5KSB1c2VzIGEgcG9pbnRlciB0byBhIGZyZWUgdHVwbGUuXG5cbiAgICAgRm9yIFtQb29sLlVuc2FmZV0sIGEgc2xvdCBpbiBhIGZyZWUgb2JqZWN0IGlzIGd1YXJhbnRlZWQgdG8gYmUgYW4gaW50OyBpdCBtdXN0IG5vdCBiZVxuICAgICBwb2ludGVyIHRvIHByZXZlbnQgYSBzcGFjZSBsZWFrLiAgSG93ZXZlciwgdGhlIGludCBpbiB0aGUgc2xvdCBtYXkgbm90IHJlcHJlc2VudCBhXG4gICAgIHZhbGlkIHZhbHVlIG9mIHRoZSB0eXBlLlxuICAqKVxuXG4gIG1vZHVsZSBTbG90ID0gc3RydWN0XG4gICAgdHlwZSAoJ3Nsb3RzLCAnYSkgdCA9IGludCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IGVxdWFsICh0MSA6IChfLCBfKSB0KSB0MiA9IHQxID0gdDJcbiAgICBsZXQgdDAgPSAxXG4gICAgbGV0IHQxID0gMlxuICAgIGxldCB0MiA9IDNcbiAgICBsZXQgdDMgPSA0XG4gICAgbGV0IHQ0ID0gNVxuICAgIGxldCB0NSA9IDZcbiAgICBsZXQgdDYgPSA3XG4gICAgbGV0IHQ3ID0gOFxuICAgIGxldCB0OCA9IDlcbiAgICBsZXQgdDkgPSAxMFxuICAgIGxldCB0MTAgPSAxMVxuICAgIGxldCB0MTEgPSAxMlxuICAgIGxldCB0MTIgPSAxM1xuICAgIGxldCB0MTMgPSAxNFxuXG4gICAgbGV0JXRlc3QgXyA9IHQxMyA9IG1heF9zbG90XG4gIGVuZFxuXG4gICgqIFdlIG9ubHkgaGF2ZSBbSW50Lm51bV9iaXRzXSBiaXRzIGF2YWlsYWJsZSBmb3IgcG9vbCBwb2ludGVycy4gIFRoZSBiaXRzIG9mIGEgcG9vbFxuICAgICBwb2ludGVyIGVuY29kZSB0d28gdGhpbmdzOlxuXG4gICAgIC0gdGhlIHR1cGxlJ3MgYXJyYXkgaW5kZXggaW4gdGhlIHBvb2xcbiAgICAgLSB0aGUgdHVwbGUncyBpZGVudGlmaWVyIChub3QgbmVjZXNzYXJpbHkgdW5pcXVlKVxuXG4gICAgIFdlIGNob29zZSBbYXJyYXlfaW5kZXhfbnVtX2JpdHNdIGFzIGxhcmdlIGFzIG5lZWRlZCBmb3IgdGhlIG1heGltdW0gcG9vbCBjYXBhY2l0eVxuICAgICB0aGF0IHdlIHdhbnQgdG8gc3VwcG9ydCwgYW5kIHVzZSB0aGUgcmVtYWluaW5nIFttYXNrZWRfdHVwbGVfaWRfbnVtX2JpdHNdIGJpdHMgZm9yXG4gICAgIHRoZSBpZGVudGlmaWVyLiAgNjQtYml0IGFuZCAzMi1iaXQgYXJjaGl0ZWN0dXJlcyB0eXBpY2FsbHkgaGF2ZSB2ZXJ5IGRpZmZlcmVudFxuICAgICBhZGRyZXNzLXNwYWNlIHNpemVzLCBzbyB3ZSBjaG9vc2UgW2FycmF5X2luZGV4X251bV9iaXRzXSBkaWZmZXJlbnRseS4gKilcblxuICBsZXQgYXJyYXlfaW5kZXhfbnVtX2JpdHMgPVxuICAgIGlmIGFyY2hfc2l4dHlmb3VyXG4gICAgdGhlbiAoXG4gICAgICBhc3NlcnQgKEludC5udW1fYml0cyA9IDYzKTtcbiAgICAgIDMwKVxuICAgIGVsc2UgKFxuICAgICAgYXNzZXJ0IChJbnQubnVtX2JpdHMgPSAzMSB8fCBJbnQubnVtX2JpdHMgPSAzMik7XG4gICAgICAyMilcbiAgOztcblxuICBsZXQgbWFza2VkX3R1cGxlX2lkX251bV9iaXRzID0gSW50Lm51bV9iaXRzIC0gYXJyYXlfaW5kZXhfbnVtX2JpdHNcblxuICBsZXQldGVzdCBfID0gYXJyYXlfaW5kZXhfbnVtX2JpdHMgPiAwXG4gIGxldCV0ZXN0IF8gPSBtYXNrZWRfdHVwbGVfaWRfbnVtX2JpdHMgPiAwXG4gIGxldCV0ZXN0IF8gPSBhcnJheV9pbmRleF9udW1fYml0cyArIG1hc2tlZF90dXBsZV9pZF9udW1fYml0cyA8PSBJbnQubnVtX2JpdHNcblxuICBsZXQgbWF4X2FycmF5X2xlbmd0aCA9IDEgbHNsIGFycmF5X2luZGV4X251bV9iaXRzXG5cbiAgbW9kdWxlIFR1cGxlX2lkIDogc2lnXG4gICAgdHlwZSB0ID0gcHJpdmF0ZSBpbnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaW5pdCA6IHRcbiAgICB2YWwgbmV4dCA6IHQgLT4gdFxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICAgIHZhbCBleGFtcGxlcyA6IHQgbGlzdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICgqIFdlIGd1YXJhbnRlZSB0aGF0IHR1cGxlIGlkcyBhcmUgbm9ubmVnYXRpdmUgc28gdGhhdCB0aGV5IGNhbiBiZSBlbmNvZGVkIGluXG4gICAgICAgaGVhZGVycy4gKilcbiAgICBsZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKHQgPj0gMClcbiAgICBsZXQgdG9fc3RyaW5nID0gSW50LnRvX3N0cmluZ1xuICAgIGxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHQxID0gdDJcbiAgICBsZXQgaW5pdCA9IDBcbiAgICBsZXQgbmV4dCB0ID0gaWYgYXJjaF9zaXh0eWZvdXIgdGhlbiB0ICsgMSBlbHNlIGlmIHQgPSBJbnQubWF4X3ZhbHVlIHRoZW4gMCBlbHNlIHQgKyAxXG4gICAgbGV0IHRvX2ludCB0ID0gdFxuXG4gICAgbGV0IG9mX2ludCBpID1cbiAgICAgIGlmIGkgPCAwXG4gICAgICB0aGVuIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiVHVwbGVfaWQub2ZfaW50IGdvdCBuZWdhdGl2ZSBpbnRcIiBpIFslc2V4cF9vZjogaW50XTtcbiAgICAgIGlcbiAgICA7O1xuXG4gICAgbGV0IGV4YW1wbGVzID0gWyAwOyAxOyAweDFGRkZfRkZGRjsgSW50Lm1heF92YWx1ZSBdXG4gIGVuZFxuXG4gIGxldCB0dXBsZV9pZF9tYXNrID0gKDEgbHNsIG1hc2tlZF90dXBsZV9pZF9udW1fYml0cykgLSAxXG5cbiAgbW9kdWxlIFBvaW50ZXIgOiBzaWdcbiAgICAoKiBbUG9pbnRlci50XSBpcyBhbiBlbmNvZGluZyBhcyBhbiBbaW50XSBvZiB0aGUgZm9sbG93aW5nIHN1bSB0eXBlOlxuXG4gICAgICAge1tcbiAgICAgICAgIHwgTnVsbFxuICAgICAgICAgfCBOb3JtYWwgb2YgeyBoZWFkZXJfaW5kZXggOiBpbnQ7IG1hc2tlZF90dXBsZV9pZCA6IGludCB9XG4gICAgICAgXX1cblxuICAgICAgIFRoZSBlbmNvZGluZyBpcyBjaG9zZW4gdG8gb3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIG9wZXJhdGlvbiwgbmFtZWx5IHR1cGxlLXNsb3RcbiAgICAgICBhY2Nlc3MsIHRoZSBbc2xvdF9pbmRleF0gZnVuY3Rpb24uICBUaGUgZW5jb2RpbmcgaXMgZGVzaWduZWQgc28gdGhhdCBbc2xvdF9pbmRleF1cbiAgICAgICBwcm9kdWNlcyBhIG5lZ2F0aXZlIG51bWJlciBmb3IgW051bGxdLCB3aGljaCB3aWxsIGNhdXNlIHRoZSBzdWJzZXF1ZW50IGFycmF5IGJvdW5kc1xuICAgICAgIGNoZWNrIHRvIGZhaWwuICopXG5cbiAgICB0eXBlICdzbG90cyB0ID0gcHJpdmF0ZSBpbnQgW0BAZGVyaXZpbmcgc2V4cF9vZiwgdHlwZXJlcF1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBwaHlzX2NvbXBhcmUgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIHBoeXNfZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuXG4gICAgKCogVGhlIG51bGwgcG9pbnRlci4gIFtudWxsXSBpcyBhIGZ1bmN0aW9uIGR1ZSB0byBpc3N1ZXMgd2l0aCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24uICopXG5cbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gXyB0XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuXG4gICAgKCogTm9ybWFsIHBvaW50ZXJzLiAqKVxuXG4gICAgdmFsIGNyZWF0ZSA6IGhlYWRlcl9pbmRleDppbnQgLT4gVHVwbGVfaWQudCAtPiBfIHRcbiAgICB2YWwgaGVhZGVyX2luZGV4IDogXyB0IC0+IGludFxuICAgIHZhbCBtYXNrZWRfdHVwbGVfaWQgOiBfIHQgLT4gaW50XG4gICAgdmFsIHNsb3RfaW5kZXggOiBfIHQgLT4gKF8sIF8pIFNsb3QudCAtPiBpbnRcbiAgICB2YWwgZmlyc3Rfc2xvdF9pbmRleCA6IF8gdCAtPiBpbnRcblxuICAgIG1vZHVsZSBJZCA6IHNpZ1xuICAgICAgdHlwZSB0IFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cblxuICAgICAgdmFsIHRvX2ludDYzIDogdCAtPiBJbnQ2My50XG4gICAgICB2YWwgb2ZfaW50NjMgOiBJbnQ2My50IC0+IHRcbiAgICBlbmRcblxuICAgIHZhbCB0b19pZCA6IF8gdCAtPiBJZC50XG4gICAgdmFsIG9mX2lkX2V4biA6IElkLnQgLT4gXyB0XG4gIGVuZCA9IHN0cnVjdFxuICAgICgqIEEgcG9pbnRlciBpcyBlaXRoZXIgW251bGxdIG9yIHRoZSAocG9zaXRpdmUpIGluZGV4IGluIHRoZSBwb29sIG9mIHRoZSBuZXh0LWZyZWVcbiAgICAgICBmaWVsZCBwcmVjZWVkaW5nIHRoZSB0dXBsZSdzIHNsb3RzLiAqKVxuICAgIHR5cGUgJ3Nsb3RzIHQgPSBpbnQgW0BAZGVyaXZpbmcgdHlwZXJlcF1cblxuICAgIGxldCBzZXhwX29mX3QgXyB0ID0gU2V4cC5BdG9tIChzcHJpbnRmIFwiPFBvb2wuUG9pbnRlci50OiAweCUwOHg+XCIgdClcbiAgICBsZXQgcGh5c19lcXVhbCAodDEgOiBfIHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxuICAgIGxldCBwaHlzX2NvbXBhcmUgPSBjb21wYXJlXG4gICAgbGV0IG51bGwgKCkgPSAtbWF4X3Nsb3QgLSAxXG4gICAgbGV0IGlzX251bGwgdCA9IHBoeXNfZXF1YWwgdCAobnVsbCAoKSlcblxuICAgICgqIFtudWxsXSBtdXN0IGJlIHN1Y2ggdGhhdCBbbnVsbCArIHNsb3RdIGlzIGFuIGludmFsaWQgYXJyYXkgaW5kZXggZm9yIGFsbCBzbG90cy5cbiAgICAgICBPdGhlcndpc2UgZ2V0L3NldCBvbiB0aGUgbnVsbCBwb2ludGVyIG1heSBsZWFkIHRvIGEgc2VnZmF1bHQuICopXG4gICAgbGV0JXRlc3QgXyA9IG51bGwgKCkgKyBtYXhfc2xvdCA8IDBcblxuICAgIGxldCBjcmVhdGUgfmhlYWRlcl9pbmRleCAodHVwbGVfaWQgOiBUdXBsZV9pZC50KSA9XG4gICAgICBoZWFkZXJfaW5kZXhcbiAgICAgIGxvciAoKFR1cGxlX2lkLnRvX2ludCB0dXBsZV9pZCBsYW5kIHR1cGxlX2lkX21hc2spIGxzbCBhcnJheV9pbmRleF9udW1fYml0cylcbiAgICA7O1xuXG4gICAgbGV0IGhlYWRlcl9pbmRleF9tYXNrID0gKDEgbHNsIGFycmF5X2luZGV4X251bV9iaXRzKSAtIDFcbiAgICBsZXQgbWFza2VkX3R1cGxlX2lkIHQgPSB0IGxzciBhcnJheV9pbmRleF9udW1fYml0c1xuICAgIGxldCBoZWFkZXJfaW5kZXggdCA9IHQgbGFuZCBoZWFkZXJfaW5kZXhfbWFza1xuICAgIGxldCBpbnZhcmlhbnQgXyB0ID0gaWYgbm90IChpc19udWxsIHQpIHRoZW4gYXNzZXJ0IChoZWFkZXJfaW5kZXggdCA+IDApXG5cbiAgICBsZXQldGVzdF91bml0IF8gPSBpbnZhcmlhbnQgaWdub3JlIChudWxsICgpKVxuXG4gICAgbGV0JXRlc3RfdW5pdCBfID1cbiAgICAgIExpc3QuaXRlciBUdXBsZV9pZC5leGFtcGxlcyB+ZjooZnVuIHR1cGxlX2lkIC0+XG4gICAgICAgIGludmFyaWFudCBpZ25vcmUgKGNyZWF0ZSB+aGVhZGVyX2luZGV4OjEgdHVwbGVfaWQpKVxuICAgIDs7XG5cbiAgICBsZXQgc2xvdF9pbmRleCB0IHNsb3QgPSBoZWFkZXJfaW5kZXggdCArIHNsb3RcbiAgICBsZXQgZmlyc3Rfc2xvdF9pbmRleCB0ID0gc2xvdF9pbmRleCB0IFNsb3QudDBcblxuICAgIG1vZHVsZSBJZCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgIGVuZFxuXG4gICAgbGV0IHRvX2lkIHQgPSBJZC5vZl9pbnQgdFxuXG4gICAgbGV0IG9mX2lkX2V4biBpZCA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IHQgPSBJZC50b19pbnRfZXhuIGlkIGluXG4gICAgICAgIGlmIGlzX251bGwgdFxuICAgICAgICB0aGVuIHRcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHNob3VsZF9lcXVhbCA9XG4gICAgICAgICAgICBjcmVhdGUgfmhlYWRlcl9pbmRleDooaGVhZGVyX2luZGV4IHQpIChUdXBsZV9pZC5vZl9pbnQgKG1hc2tlZF90dXBsZV9pZCB0KSlcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdCBzaG91bGRfZXF1YWxcbiAgICAgICAgICB0aGVuIHRcbiAgICAgICAgICBlbHNlIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwic2hvdWxkIGVxdWFsXCIgc2hvdWxkX2VxdWFsIFslc2V4cF9vZjogXyB0XSlcbiAgICAgIHdpdGhcbiAgICAgIHwgZXhuIC0+XG4gICAgICAgIGZhaWx3aXRoc1xuICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICBcIlBvaW50ZXIub2ZfaWRfZXhuIGdvdCBzdHJhbmdlIGlkXCJcbiAgICAgICAgICAoaWQsIGV4bilcbiAgICAgICAgICBbJXNleHBfb2Y6IElkLnQgKiBleG5dXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEhlYWRlciA6IHNpZ1xuICAgICgqIEEgW0hlYWRlci50XSBpcyBhbiBlbmNvZGluZyBhcyBhbiBbaW50XSBvZiB0aGUgZm9sbG93aW5nIHR5cGU6XG5cbiAgICAgICB7W1xuICAgICAgICAgfCBOdWxsXG4gICAgICAgICB8IEZyZWUgb2YgeyBuZXh0X2ZyZWVfaGVhZGVyX2luZGV4IDogaW50IH1cbiAgICAgICAgIHwgVXNlZCBvZiB7IHR1cGxlX2lkIDogaW50IH1cbiAgICAgICBdfVxuXG4gICAgICAgSWYgYSB0dXBsZSBpcyBmcmVlLCBpdHMgaGVhZGVyIGlzIHNldCB0byBlaXRoZXIgW051bGxdIG9yIFtGcmVlXSB3aXRoXG4gICAgICAgW25leHRfZnJlZV9oZWFkZXJfaW5kZXhdIGluZGljYXRpbmcgdGhlIGhlYWRlciBvZiB0aGUgbmV4dCB0dXBsZSBvbiB0aGUgZnJlZSBsaXN0LlxuICAgICAgIElmIGEgdHVwbGUgaXMgaW4gdXNlLCBpdCBoZWFkZXIgaXMgc2V0IHRvIFtVc2VkXS4gKilcblxuICAgIHR5cGUgdCA9IHByaXZhdGUgaW50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgbnVsbCA6IHRcbiAgICB2YWwgaXNfbnVsbCA6IHQgLT4gYm9vbFxuICAgIHZhbCBmcmVlIDogbmV4dF9mcmVlX2hlYWRlcl9pbmRleDppbnQgLT4gdFxuICAgIHZhbCBpc19mcmVlIDogdCAtPiBib29sXG4gICAgdmFsIG5leHRfZnJlZV9oZWFkZXJfaW5kZXggOiB0IC0+IGludFxuXG4gICAgKCogb25seSB2YWxpZCBpZiBbaXNfZnJlZSB0XSAqKVxuXG4gICAgdmFsIHVzZWQgOiBUdXBsZV9pZC50IC0+IHRcbiAgICB2YWwgaXNfdXNlZCA6IHQgLT4gYm9vbFxuICAgIHZhbCB0dXBsZV9pZCA6IHQgLT4gVHVwbGVfaWQudFxuXG4gICAgKCogb25seSB2YWxpZCBpZiBbaXNfdXNlZCB0XSAqKVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcblxuICAgIGxldCBudWxsID0gMFxuICAgIGxldCBpc19udWxsIHQgPSB0ID0gMFxuXG4gICAgKCogV2Uga25vdyB0aGF0IGhlYWRlciBpbmRpY2VzIGFyZSBbPiAwXSwgYmVjYXVzZSBpbmRleCBbMF0gaG9sZHMgdGhlIG1ldGFkYXRhLiAqKVxuICAgIGxldCBmcmVlIH5uZXh0X2ZyZWVfaGVhZGVyX2luZGV4ID0gbmV4dF9mcmVlX2hlYWRlcl9pbmRleFxuICAgIGxldCBpc19mcmVlIHQgPSB0ID4gMFxuICAgIGxldCBuZXh0X2ZyZWVfaGVhZGVyX2luZGV4IHQgPSB0XG4gICAgbGV0IHVzZWQgKHR1cGxlX2lkIDogVHVwbGVfaWQudCkgPSAtMSAtICh0dXBsZV9pZCA6PiBpbnQpXG4gICAgbGV0IGlzX3VzZWQgdCA9IHQgPCAwXG4gICAgbGV0IHR1cGxlX2lkIHQgPSBUdXBsZV9pZC5vZl9pbnQgKC0odCArIDEpKVxuXG4gICAgbGV0JXRlc3RfdW5pdCBfID1cbiAgICAgIExpc3QuaXRlciBUdXBsZV9pZC5leGFtcGxlcyB+ZjooZnVuIGlkIC0+XG4gICAgICAgIGxldCB0ID0gdXNlZCBpZCBpblxuICAgICAgICBhc3NlcnQgKGlzX3VzZWQgdCk7XG4gICAgICAgIGFzc2VydCAoVHVwbGVfaWQuZXF1YWwgKHR1cGxlX2lkIHQpIGlkKSlcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICAgIGlmIGlzX251bGwgdFxuICAgICAgdGhlbiBTZXhwLkF0b20gXCJudWxsXCJcbiAgICAgIGVsc2UgaWYgaXNfZnJlZSB0XG4gICAgICB0aGVuIFNleHAuKExpc3QgWyBBdG9tIFwiRnJlZVwiOyBBdG9tIChJbnQudG9fc3RyaW5nIChuZXh0X2ZyZWVfaGVhZGVyX2luZGV4IHQpKSBdKVxuICAgICAgZWxzZSBTZXhwLihMaXN0IFsgQXRvbSBcIlVzZWRcIjsgQXRvbSAoVHVwbGVfaWQudG9fc3RyaW5nICh0dXBsZV9pZCB0KSkgXSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgbWV0YWRhdGFfaW5kZXggPSAwXG4gIGxldCBzdGFydF9vZl90dXBsZXNfaW5kZXggPSAxXG5cbiAgbGV0IG1heF9jYXBhY2l0eSB+c2xvdHNfcGVyX3R1cGxlID1cbiAgICAobWF4X2FycmF5X2xlbmd0aCAtIHN0YXJ0X29mX3R1cGxlc19pbmRleCkgLyAoMSArIHNsb3RzX3Blcl90dXBsZSlcbiAgOztcblxuICBsZXQldGVzdF91bml0IF8gPVxuICAgIGZvciBzbG90c19wZXJfdHVwbGUgPSAxIHRvIG1heF9zbG90IGRvXG4gICAgICBhc3NlcnQgKFxuICAgICAgICBzdGFydF9vZl90dXBsZXNfaW5kZXggKyAoKDEgKyBzbG90c19wZXJfdHVwbGUpICogbWF4X2NhcGFjaXR5IH5zbG90c19wZXJfdHVwbGUpXG4gICAgICAgIDw9IG1heF9hcnJheV9sZW5ndGgpXG4gICAgZG9uZVxuICA7O1xuXG4gIG1vZHVsZSBNZXRhZGF0YSA9IHN0cnVjdFxuICAgIHR5cGUgJ3Nsb3RzIHQgPVxuICAgICAgeyAoKiBbc2xvdHNfcGVyX3R1cGxlXSBpcyBudW1iZXIgb2Ygc2xvdHMgaW4gYSB0dXBsZSBhcyBzZWVuIGJ5IHRoZSB1c2VyOyBpLmUuIG5vdFxuICAgICAgICAgICBjb3VudGluZyB0aGUgbmV4dC1mcmVlIHBvaW50ZXIuICopXG4gICAgICAgIHNsb3RzX3Blcl90dXBsZSA6IGludFxuICAgICAgOyBjYXBhY2l0eSA6IGludFxuICAgICAgOyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgICAgOyBtdXRhYmxlIG5leHRfaWQgOiBUdXBsZV9pZC50XG4gICAgICA7IG11dGFibGUgZmlyc3RfZnJlZSA6IEhlYWRlci50XG4gICAgICAoKiBbZHVtbXldIGlzIFtOb25lXSBpbiBhbiB1bnNhZmUgcG9vbC4gIEluIGEgc2FmZSBwb29sLCBbZHVtbXldIGlzIFtTb21lIGFdLCB3aXRoXG4gICAgICAgICBbVW5pZm9ybV9hcnJheS5sZW5ndGggYSA9IHNsb3RzX3Blcl90dXBsZV0uICBbZHVtbXldIGlzIGFjdHVhbGx5IGEgdHVwbGUgdmFsdWVcbiAgICAgICAgIHdpdGggdGhlIGNvcnJlY3QgdHlwZSAoY29ycmVzcG9uZGluZyB0byBbJ3Nsb3RzXSksIGJ1dCB3ZSBtYWtlIHRoZSB0eXBlIG9mXG4gICAgICAgICBbZHVtbXldIGJlIFtPYmoudCBVbmlmb3JtX2FycmF5LnRdIGJlY2F1c2Ugd2UgY2FuJ3Qgd3JpdGUgdGhhdCB0eXBlIGhlcmUuICBBbHNvLFxuICAgICAgICAgdGhlIHB1cnBvc2Ugb2YgW2R1bW15XSBpcyB0byBpbml0aWFsaXplIGEgcG9vbCBlbGVtZW50LCBtYWtpbmcgW2R1bW15XSBhbiBbT2JqLnRcbiAgICAgICAgIFVuaWZvcm1fYXJyYXkudF0gbGV0cyB1cyBpbml0aWFsaXplIGEgcG9vbCBlbGVtZW50IHVzaW5nIFtVbmlmb3JtX2FycmF5LmJsaXRdXG4gICAgICAgICBmcm9tIFtkdW1teV0gdG8gdGhlIHBvb2wsIHdoaWNoIGlzIGFuIFtPYmoudCBVbmlmb3JtX2FycmF5LnRdLiAqKVxuICAgICAgOyBkdW1teSA6IChPYmoudCBVbmlmb3JtX2FycmF5LnRbQHNleHAub3BhcXVlXSkgb3B0aW9uXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IGFycmF5X2luZGljZXNfcGVyX3R1cGxlIHQgPSAxICsgdC5zbG90c19wZXJfdHVwbGVcbiAgICBsZXQgYXJyYXlfbGVuZ3RoIHQgPSBzdGFydF9vZl90dXBsZXNfaW5kZXggKyAodC5jYXBhY2l0eSAqIGFycmF5X2luZGljZXNfcGVyX3R1cGxlIHQpXG5cbiAgICBsZXQgaGVhZGVyX2luZGV4X3RvX3R1cGxlX251bSB0IH5oZWFkZXJfaW5kZXggPVxuICAgICAgKGhlYWRlcl9pbmRleCAtIHN0YXJ0X29mX3R1cGxlc19pbmRleCkgLyBhcnJheV9pbmRpY2VzX3Blcl90dXBsZSB0XG4gICAgOztcblxuICAgIGxldCB0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IHQgdHVwbGVfbnVtID1cbiAgICAgIHN0YXJ0X29mX3R1cGxlc19pbmRleCArICh0dXBsZV9udW0gKiBhcnJheV9pbmRpY2VzX3Blcl90dXBsZSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdHVwbGVfbnVtX3RvX2ZpcnN0X3Nsb3RfaW5kZXggdCB0dXBsZV9udW0gPVxuICAgICAgdHVwbGVfbnVtX3RvX2hlYWRlcl9pbmRleCB0IHR1cGxlX251bSArIDFcbiAgICA7O1xuXG4gICAgbGV0IGlzX2Z1bGwgdCA9IHQubGVuZ3RoID0gdC5jYXBhY2l0eVxuICBlbmRcblxuICBvcGVuIE1ldGFkYXRhXG5cbiAgKCogV2UgdXNlIHR5cGUgW09iai50XSBiZWNhdXNlIHRoZSBhcnJheSBob2xkcyBhIG1peCBvZiBpbnRlZ2VycyBhcyB3ZWxsIGFzIE9DYW1sIHZhbHVlc1xuICAgICBvZiBhcmJpdHJhcnkgdHlwZS4gKilcbiAgdHlwZSAnc2xvdHMgdCA9IE9iai50IFVuaWZvcm1fYXJyYXkudFxuXG4gIGxldCBtZXRhZGF0YSAodHlwZSBzbG90cykgKHQgOiBzbG90cyB0KSA9XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgbWV0YWRhdGFfaW5kZXggfD4gKE9iai5vYmogOiBfIC0+IHNsb3RzIE1ldGFkYXRhLnQpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCB0ID0gKG1ldGFkYXRhIHQpLmxlbmd0aFxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfdHkgdCA9IE1ldGFkYXRhLnNleHBfb2ZfdCBzZXhwX29mX3R5IChtZXRhZGF0YSB0KVxuXG4gICgqIEJlY2F1c2UgW3Vuc2FmZV9oZWFkZXJdIGFuZCBbdW5zYWZlX3NldF9oZWFkZXJdIGRvIG5vdCBkbyBhIGJvdW5kcyBjaGVjaywgb25lIG11c3QgYmVcbiAgICAgc3VyZSB0aGF0IG9uZSBoYXMgYSB2YWxpZCBbaGVhZGVyX2luZGV4XSBiZWZvcmUgY2FsbGluZyB0aGVtLiAqKVxuICBsZXQgdW5zYWZlX2hlYWRlciB0IH5oZWFkZXJfaW5kZXggPVxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGhlYWRlcl9pbmRleCB8PiAoT2JqLm9iaiA6IF8gLT4gSGVhZGVyLnQpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCAoaGVhZGVyIDogSGVhZGVyLnQpID1cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBoZWFkZXJfaW5kZXggKGhlYWRlciA6PiBpbnQpXG4gIDs7XG5cbiAgbGV0IGhlYWRlcl9pbmRleF9pc19pbl9ib3VuZHMgdCB+aGVhZGVyX2luZGV4ID1cbiAgICBoZWFkZXJfaW5kZXggPj0gc3RhcnRfb2ZfdHVwbGVzX2luZGV4ICYmIGhlYWRlcl9pbmRleCA8IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHRcbiAgOztcblxuICBsZXQgdW5zYWZlX3BvaW50ZXJfaXNfbGl2ZSB0IHBvaW50ZXIgPVxuICAgIGxldCBoZWFkZXJfaW5kZXggPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgbGV0IGhlYWRlciA9IHVuc2FmZV9oZWFkZXIgdCB+aGVhZGVyX2luZGV4IGluXG4gICAgSGVhZGVyLmlzX3VzZWQgaGVhZGVyXG4gICAgJiYgVHVwbGVfaWQudG9faW50IChIZWFkZXIudHVwbGVfaWQgaGVhZGVyKSBsYW5kIHR1cGxlX2lkX21hc2tcbiAgICAgICA9IFBvaW50ZXIubWFza2VkX3R1cGxlX2lkIHBvaW50ZXJcbiAgOztcblxuICBsZXQgcG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXIgPVxuICAgIGhlYWRlcl9pbmRleF9pc19pbl9ib3VuZHMgdCB+aGVhZGVyX2luZGV4OihQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyKVxuICAgICgqIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhlIHBvaW50ZXIgaXNuJ3QgW251bGxdIGFuZCBpcyBpbiBib3VuZHMsIHNvIHdlIGtub3cgaXQgaXNcbiAgICAgICB0aGUgaW5kZXggb2YgYSBoZWFkZXIsIHNpbmNlIHdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCBhbGwgcG9pbnRlcnMgb3RoZXIgdGhhblxuICAgICAgIFtudWxsXSBhcmUuICopXG4gICAgJiYgdW5zYWZlX3BvaW50ZXJfaXNfbGl2ZSB0IHBvaW50ZXJcbiAgOztcblxuICBsZXQgaWRfb2ZfcG9pbnRlciBfdCBwb2ludGVyID0gUG9pbnRlci50b19pZCBwb2ludGVyXG5cbiAgbGV0IGlzX3ZhbGlkX2hlYWRlcl9pbmRleCB0IH5oZWFkZXJfaW5kZXggPVxuICAgIGxldCBtZXRhZGF0YSA9IG1ldGFkYXRhIHQgaW5cbiAgICBoZWFkZXJfaW5kZXhfaXNfaW5fYm91bmRzIHQgfmhlYWRlcl9pbmRleFxuICAgICYmIDBcbiAgICAgICA9IChoZWFkZXJfaW5kZXggLSBzdGFydF9vZl90dXBsZXNfaW5kZXgpXG4gICAgICAgICBtb2QgTWV0YWRhdGEuYXJyYXlfaW5kaWNlc19wZXJfdHVwbGUgbWV0YWRhdGFcbiAgOztcblxuICBsZXQgcG9pbnRlcl9vZl9pZF9leG4gdCBpZCA9XG4gICAgdHJ5XG4gICAgICBsZXQgcG9pbnRlciA9IFBvaW50ZXIub2ZfaWRfZXhuIGlkIGluXG4gICAgICBpZiBub3QgKFBvaW50ZXIuaXNfbnVsbCBwb2ludGVyKVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBoZWFkZXJfaW5kZXggPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgICAgIGlmIG5vdCAoaXNfdmFsaWRfaGVhZGVyX2luZGV4IHQgfmhlYWRlcl9pbmRleClcbiAgICAgICAgdGhlbiBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImludmFsaWQgaGVhZGVyIGluZGV4XCIgaGVhZGVyX2luZGV4IFslc2V4cF9vZjogaW50XTtcbiAgICAgICAgaWYgbm90ICh1bnNhZmVfcG9pbnRlcl9pc19saXZlIHQgcG9pbnRlcikgdGhlbiBmYWlsd2l0aCBcInBvaW50ZXIgbm90IGxpdmVcIik7XG4gICAgICBwb2ludGVyXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+XG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIlBvb2wucG9pbnRlcl9vZl9pZF9leG4gZ290IGludmFsaWQgaWRcIlxuICAgICAgICAoaWQsIHQsIGV4bilcbiAgICAgICAgWyVzZXhwX29mOiBQb2ludGVyLklkLnQgKiBfIHQgKiBleG5dXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCBfaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgbWV0YWRhdGEpIGluXG4gICAgICBNZXRhZGF0YS5GaWVsZHMuaXRlclxuICAgICAgICB+c2xvdHNfcGVyX3R1cGxlOihjaGVjayAoZnVuIHNsb3RzX3Blcl90dXBsZSAtPiBhc3NlcnQgKHNsb3RzX3Blcl90dXBsZSA+IDApKSlcbiAgICAgICAgfmNhcGFjaXR5OlxuICAgICAgICAgIChjaGVjayAoZnVuIGNhcGFjaXR5IC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChjYXBhY2l0eSA+PSAwKTtcbiAgICAgICAgICAgICBhc3NlcnQgKFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQgPSBNZXRhZGF0YS5hcnJheV9sZW5ndGggbWV0YWRhdGEpKSlcbiAgICAgICAgfmxlbmd0aDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgICBhc3NlcnQgKGxlbmd0aCA+PSAwKTtcbiAgICAgICAgICAgICBhc3NlcnQgKGxlbmd0aCA8PSBtZXRhZGF0YS5jYXBhY2l0eSkpKVxuICAgICAgICB+bmV4dF9pZDooY2hlY2sgVHVwbGVfaWQuaW52YXJpYW50KVxuICAgICAgICB+Zmlyc3RfZnJlZTpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBmaXJzdF9mcmVlIC0+XG4gICAgICAgICAgICAgbGV0IGZyZWUgPSBBcnJheS5jcmVhdGUgfmxlbjptZXRhZGF0YS5jYXBhY2l0eSBmYWxzZSBpblxuICAgICAgICAgICAgIGxldCByID0gcmVmIGZpcnN0X2ZyZWUgaW5cbiAgICAgICAgICAgICB3aGlsZSBub3QgKEhlYWRlci5pc19udWxsICFyKSBkb1xuICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9ICFyIGluXG4gICAgICAgICAgICAgICBhc3NlcnQgKEhlYWRlci5pc19mcmVlIGhlYWRlcik7XG4gICAgICAgICAgICAgICBsZXQgaGVhZGVyX2luZGV4ID0gSGVhZGVyLm5leHRfZnJlZV9oZWFkZXJfaW5kZXggaGVhZGVyIGluXG4gICAgICAgICAgICAgICBhc3NlcnQgKGlzX3ZhbGlkX2hlYWRlcl9pbmRleCB0IH5oZWFkZXJfaW5kZXgpO1xuICAgICAgICAgICAgICAgbGV0IHR1cGxlX251bSA9IGhlYWRlcl9pbmRleF90b190dXBsZV9udW0gbWV0YWRhdGEgfmhlYWRlcl9pbmRleCBpblxuICAgICAgICAgICAgICAgaWYgZnJlZS4odHVwbGVfbnVtKVxuICAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImN5Y2xlIGluIGZyZWUgbGlzdFwiIHR1cGxlX251bSBbJXNleHBfb2Y6IGludF07XG4gICAgICAgICAgICAgICBmcmVlLih0dXBsZV9udW0pIDwtIHRydWU7XG4gICAgICAgICAgICAgICByIDo9IHVuc2FmZV9oZWFkZXIgdCB+aGVhZGVyX2luZGV4XG4gICAgICAgICAgICAgZG9uZSkpXG4gICAgICAgIH5kdW1teTpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBTb21lIGR1bW15IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFVuaWZvcm1fYXJyYXkubGVuZ3RoIGR1bW15ID0gbWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlKVxuICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgZm9yIHR1cGxlX251bSA9IDAgdG8gbWV0YWRhdGEuY2FwYWNpdHkgLSAxIGRvXG4gICAgICAgICAgICAgICAgIGxldCBoZWFkZXJfaW5kZXggPSB0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IG1ldGFkYXRhIHR1cGxlX251bSBpblxuICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gdW5zYWZlX2hlYWRlciB0IH5oZWFkZXJfaW5kZXggaW5cbiAgICAgICAgICAgICAgICAgaWYgSGVhZGVyLmlzX2ZyZWUgaGVhZGVyXG4gICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdF9zbG90ID0gdHVwbGVfbnVtX3RvX2ZpcnN0X3Nsb3RfaW5kZXggbWV0YWRhdGEgdHVwbGVfbnVtIGluXG4gICAgICAgICAgICAgICAgICAgZm9yIHNsb3QgPSAwIHRvIG1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZSAtIDEgZG9cbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoT2JqLmlzX2ludCAoVW5pZm9ybV9hcnJheS5nZXQgdCAoZmlyc3Rfc2xvdCArIHNsb3QpKSlcbiAgICAgICAgICAgICAgICAgICBkb25lKVxuICAgICAgICAgICAgICAgZG9uZSkpXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+XG4gICAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIlBvb2wuaW52YXJpYW50IGZhaWxlZFwiIChleG4sIHQpIFslc2V4cF9vZjogZXhuICogXyB0XVxuICA7O1xuXG4gIGxldCBjYXBhY2l0eSB0ID0gKG1ldGFkYXRhIHQpLmNhcGFjaXR5XG4gIGxldCBpc19mdWxsIHQgPSBNZXRhZGF0YS5pc19mdWxsIChtZXRhZGF0YSB0KVxuXG4gIGxldCB1bnNhZmVfYWRkX3RvX2ZyZWVfbGlzdCB0IG1ldGFkYXRhIH5oZWFkZXJfaW5kZXggPVxuICAgIHVuc2FmZV9zZXRfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCBtZXRhZGF0YS5maXJzdF9mcmVlO1xuICAgIG1ldGFkYXRhLmZpcnN0X2ZyZWUgPC0gSGVhZGVyLmZyZWUgfm5leHRfZnJlZV9oZWFkZXJfaW5kZXg6aGVhZGVyX2luZGV4XG4gIDs7XG5cbiAgbGV0IHNldF9tZXRhZGF0YSAodHlwZSBzbG90cykgKHQgOiBzbG90cyB0KSBtZXRhZGF0YSA9XG4gICAgVW5pZm9ybV9hcnJheS5zZXQgdCBtZXRhZGF0YV9pbmRleCAoT2JqLnJlcHIgKG1ldGFkYXRhIDogc2xvdHMgTWV0YWRhdGEudCkpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9hcnJheSAodHlwZSBzbG90cykgKG1ldGFkYXRhIDogc2xvdHMgTWV0YWRhdGEudCkgOiBzbG90cyB0ID1cbiAgICBsZXQgdCA9IFVuaWZvcm1fYXJyYXkuY3JlYXRlX29ial9hcnJheSB+bGVuOihNZXRhZGF0YS5hcnJheV9sZW5ndGggbWV0YWRhdGEpIGluXG4gICAgc2V0X21ldGFkYXRhIHQgbWV0YWRhdGE7XG4gICAgdFxuICA7O1xuXG4gICgqIEluaXRpYWxpemUgdHVwbGVzIG51bWJlcmVkIGZyb20gW2xvXSAoaW5jbHVzaXZlKSB1cCB0byBbaGldIChleGNsdXNpdmUpLiAgRm9yIGVhY2hcbiAgICAgdHVwbGUsIHRoaXMgcHV0cyBkdW1teSB2YWx1ZXMgaW4gdGhlIHR1cGxlJ3Mgc2xvdHMgYW5kIGFkZHMgdGhlIHR1cGxlIHRvIHRoZSBmcmVlXG4gICAgIGxpc3QuICopXG4gIGxldCB1bnNhZmVfaW5pdF9yYW5nZSB0IG1ldGFkYXRhIH5sbyB+aGkgPVxuICAgIChtYXRjaCBtZXRhZGF0YS5kdW1teSB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKVxuICAgICB8IFNvbWUgZHVtbXkgLT5cbiAgICAgICBmb3IgdHVwbGVfbnVtID0gbG8gdG8gaGkgLSAxIGRvXG4gICAgICAgICBVbmlmb3JtX2FycmF5LmJsaXRcbiAgICAgICAgICAgfnNyYzpkdW1teVxuICAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgIH5kc3Q6dFxuICAgICAgICAgICB+ZHN0X3BvczoodHVwbGVfbnVtX3RvX2ZpcnN0X3Nsb3RfaW5kZXggbWV0YWRhdGEgdHVwbGVfbnVtKVxuICAgICAgICAgICB+bGVuOm1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZVxuICAgICAgIGRvbmUpO1xuICAgIGZvciB0dXBsZV9udW0gPSBoaSAtIDEgZG93bnRvIGxvIGRvXG4gICAgICB1bnNhZmVfYWRkX3RvX2ZyZWVfbGlzdFxuICAgICAgICB0XG4gICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH5oZWFkZXJfaW5kZXg6KHR1cGxlX251bV90b19oZWFkZXJfaW5kZXggbWV0YWRhdGEgdHVwbGVfbnVtKVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfZHVtbXkgc2xvdHMgfmNhcGFjaXR5IH5kdW1teSA9XG4gICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJQb29sLmNyZWF0ZSBnb3QgaW52YWxpZCBjYXBhY2l0eVwiIGNhcGFjaXR5IFslc2V4cF9vZjogaW50XTtcbiAgICBsZXQgc2xvdHNfcGVyX3R1cGxlID0gU2xvdHMuc2xvdHNfcGVyX3R1cGxlIHNsb3RzIGluXG4gICAgbGV0IG1heF9jYXBhY2l0eSA9IG1heF9jYXBhY2l0eSB+c2xvdHNfcGVyX3R1cGxlIGluXG4gICAgaWYgY2FwYWNpdHkgPiBtYXhfY2FwYWNpdHlcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIlBvb2wuY3JlYXRlIGdvdCB0b28gbGFyZ2UgY2FwYWNpdHlcIlxuICAgICAgICAoY2FwYWNpdHksIGBtYXggbWF4X2NhcGFjaXR5KVxuICAgICAgICBbJXNleHBfb2Y6IGludCAqIFsgYG1heCBvZiBpbnQgXV07XG4gICAgbGV0IG1ldGFkYXRhID1cbiAgICAgIHsgTWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICA7IGNhcGFjaXR5XG4gICAgICA7IGxlbmd0aCA9IDBcbiAgICAgIDsgbmV4dF9pZCA9IFR1cGxlX2lkLmluaXRcbiAgICAgIDsgZmlyc3RfZnJlZSA9IEhlYWRlci5udWxsXG4gICAgICA7IGR1bW15XG4gICAgICB9XG4gICAgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZV9hcnJheSBtZXRhZGF0YSBpblxuICAgIHVuc2FmZV9pbml0X3JhbmdlIHQgbWV0YWRhdGEgfmxvOjAgfmhpOmNhcGFjaXR5O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlICh0eXBlIHR1cGxlKSAoc2xvdHMgOiAodHVwbGUsIF8pIFNsb3RzLnQpIH5jYXBhY2l0eSB+ZHVtbXkgPVxuICAgIGxldCBkdW1teSA9XG4gICAgICBpZiBTbG90cy5zbG90c19wZXJfdHVwbGUgc2xvdHMgPSAxXG4gICAgICB0aGVuIFVuaWZvcm1fYXJyYXkuc2luZ2xldG9uIChPYmoucmVwciAoZHVtbXkgOiB0dXBsZSkpXG4gICAgICBlbHNlIChPYmoubWFnaWMgKGR1bW15IDogdHVwbGUpIDogT2JqLnQgVW5pZm9ybV9hcnJheS50KVxuICAgIGluXG4gICAgY3JlYXRlX3dpdGhfZHVtbXkgc2xvdHMgfmNhcGFjaXR5IH5kdW1teTooU29tZSBkdW1teSlcbiAgOztcblxuICAoKiBQdXJnZSBhIHBvb2wgYW5kIG1ha2UgaXQgdW51c2FibGUuICopXG4gIGxldCBkZXN0cm95IHQgPVxuICAgIGxldCBtZXRhZGF0YSA9IG1ldGFkYXRhIHQgaW5cbiAgICAoKiBXZSBjbGVhciBvdXQgYWxsIHRoZSBwb29sJ3MgZW50cmllcywgd2hpY2ggY2F1c2VzIGFsbCBwb2ludGVycyB0byBiZSBpbnZhbGlkLiAgVGhpc1xuICAgICAgIGFsc28gcHJldmVudHMgdGhlIGRlc3Ryb3llZCBwb29sIGZyb20gdW5uZWNlc3NhcmlseSBrZWVwaW5nIGhlYXAgYmxvY2tzIGFsaXZlLlxuICAgICAgIFRoaXMgaXMgc2ltaWxhciB0byBbZnJlZV1pbmcgYWxsIHRoZSBlbnRyaWVzIHdpdGggdGhlIGRpZmZlcmVuY2UgdGhhdCB3ZSBtYWtlIHRoZVxuICAgICAgIGZyZWUgbGlzdCBlbXB0eSBhcyB3ZWxsLiAqKVxuICAgIChtYXRjaCBtZXRhZGF0YS5kdW1teSB3aXRoXG4gICAgIHwgTm9uZSAtPlxuICAgICAgIGZvciBpID0gc3RhcnRfb2ZfdHVwbGVzX2luZGV4IHRvIFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQgLSAxIGRvXG4gICAgICAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChPYmoucmVwciAwKVxuICAgICAgIGRvbmVcbiAgICAgfCBTb21lIGR1bW15IC0+XG4gICAgICAgZm9yIHR1cGxlX251bSA9IDAgdG8gbWV0YWRhdGEuY2FwYWNpdHkgLSAxIGRvXG4gICAgICAgICBsZXQgaGVhZGVyX2luZGV4ID0gdHVwbGVfbnVtX3RvX2hlYWRlcl9pbmRleCBtZXRhZGF0YSB0dXBsZV9udW0gaW5cbiAgICAgICAgIHVuc2FmZV9zZXRfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCBIZWFkZXIubnVsbDtcbiAgICAgICAgIFVuaWZvcm1fYXJyYXkuYmxpdFxuICAgICAgICAgICB+c3JjOmR1bW15XG4gICAgICAgICAgIH5zcmNfcG9zOjBcbiAgICAgICAgICAgfmRzdDp0XG4gICAgICAgICAgIH5kc3RfcG9zOihoZWFkZXJfaW5kZXggKyAxKVxuICAgICAgICAgICB+bGVuOm1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZVxuICAgICAgIGRvbmUpO1xuICAgIGxldCBtZXRhZGF0YSA9XG4gICAgICB7IE1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZSA9IG1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZVxuICAgICAgOyBjYXBhY2l0eSA9IDBcbiAgICAgIDsgbGVuZ3RoID0gMFxuICAgICAgOyBuZXh0X2lkID0gbWV0YWRhdGEubmV4dF9pZFxuICAgICAgOyBmaXJzdF9mcmVlID0gSGVhZGVyLm51bGxcbiAgICAgIDsgZHVtbXkgPSBtZXRhZGF0YS5kdW1teVxuICAgICAgfVxuICAgIGluXG4gICAgc2V0X21ldGFkYXRhIHQgbWV0YWRhdGFcbiAgOztcblxuICBsZXRbQGNvbGRdIGdyb3cgP2NhcGFjaXR5IHQgPVxuICAgIGxldCB7IE1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZVxuICAgICAgICA7IGNhcGFjaXR5ID0gb2xkX2NhcGFjaXR5XG4gICAgICAgIDsgbGVuZ3RoXG4gICAgICAgIDsgbmV4dF9pZFxuICAgICAgICA7IGZpcnN0X2ZyZWUgPSBfXG4gICAgICAgIDsgZHVtbXlcbiAgICAgICAgfVxuICAgICAgPVxuICAgICAgbWV0YWRhdGEgdFxuICAgIGluXG4gICAgbGV0IGNhcGFjaXR5ID1cbiAgICAgIG1pbiAobWF4X2NhcGFjaXR5IH5zbG90c19wZXJfdHVwbGUpIChncm93X2NhcGFjaXR5IH5jYXBhY2l0eSB+b2xkX2NhcGFjaXR5KVxuICAgIGluXG4gICAgaWYgY2FwYWNpdHkgPSBvbGRfY2FwYWNpdHlcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIlBvb2wuZ3JvdyBjYW5ub3QgZ3JvdyBwb29sOyBjYXBhY2l0eSBhbHJlYWR5IGF0IG1heGltdW1cIlxuICAgICAgICBjYXBhY2l0eVxuICAgICAgICBbJXNleHBfb2Y6IGludF07XG4gICAgbGV0IG1ldGFkYXRhID1cbiAgICAgIHsgTWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICA7IGNhcGFjaXR5XG4gICAgICA7IGxlbmd0aFxuICAgICAgOyBuZXh0X2lkXG4gICAgICA7IGZpcnN0X2ZyZWUgPSBIZWFkZXIubnVsbFxuICAgICAgOyBkdW1teVxuICAgICAgfVxuICAgIGluXG4gICAgbGV0IHQnID0gY3JlYXRlX2FycmF5IG1ldGFkYXRhIGluXG4gICAgVW5pZm9ybV9hcnJheS5ibGl0XG4gICAgICB+c3JjOnRcbiAgICAgIH5zcmNfcG9zOnN0YXJ0X29mX3R1cGxlc19pbmRleFxuICAgICAgfmRzdDp0J1xuICAgICAgfmRzdF9wb3M6c3RhcnRfb2ZfdHVwbGVzX2luZGV4XG4gICAgICB+bGVuOihvbGRfY2FwYWNpdHkgKiBNZXRhZGF0YS5hcnJheV9pbmRpY2VzX3Blcl90dXBsZSBtZXRhZGF0YSk7XG4gICAgZGVzdHJveSB0O1xuICAgIHVuc2FmZV9pbml0X3JhbmdlIHQnIG1ldGFkYXRhIH5sbzpvbGRfY2FwYWNpdHkgfmhpOmNhcGFjaXR5O1xuICAgIGZvciB0dXBsZV9udW0gPSBvbGRfY2FwYWNpdHkgLSAxIGRvd250byAwIGRvXG4gICAgICBsZXQgaGVhZGVyX2luZGV4ID0gdHVwbGVfbnVtX3RvX2hlYWRlcl9pbmRleCBtZXRhZGF0YSB0dXBsZV9udW0gaW5cbiAgICAgIGxldCBoZWFkZXIgPSB1bnNhZmVfaGVhZGVyIHQnIH5oZWFkZXJfaW5kZXggaW5cbiAgICAgIGlmIG5vdCAoSGVhZGVyLmlzX3VzZWQgaGVhZGVyKVxuICAgICAgdGhlbiB1bnNhZmVfYWRkX3RvX2ZyZWVfbGlzdCB0JyBtZXRhZGF0YSB+aGVhZGVyX2luZGV4XG4gICAgZG9uZTtcbiAgICB0J1xuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfbWFsbG9jX2Z1bGwgdCA9XG4gICAgZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJQb29sLm1hbGxvYyBvZiBmdWxsIHBvb2xcIiB0IFslc2V4cF9vZjogXyB0XVxuICA7O1xuXG4gIGxldCBtYWxsb2MgKHR5cGUgc2xvdHMpICh0IDogc2xvdHMgdCkgOiBzbG90cyBQb2ludGVyLnQgPVxuICAgIGxldCBtZXRhZGF0YSA9IG1ldGFkYXRhIHQgaW5cbiAgICBsZXQgZmlyc3RfZnJlZSA9IG1ldGFkYXRhLmZpcnN0X2ZyZWUgaW5cbiAgICBpZiBIZWFkZXIuaXNfbnVsbCBmaXJzdF9mcmVlIHRoZW4gcmFpc2VfbWFsbG9jX2Z1bGwgdDtcbiAgICBsZXQgaGVhZGVyX2luZGV4ID0gSGVhZGVyLm5leHRfZnJlZV9oZWFkZXJfaW5kZXggZmlyc3RfZnJlZSBpblxuICAgIG1ldGFkYXRhLmZpcnN0X2ZyZWUgPC0gdW5zYWZlX2hlYWRlciB0IH5oZWFkZXJfaW5kZXg7XG4gICAgbWV0YWRhdGEubGVuZ3RoIDwtIG1ldGFkYXRhLmxlbmd0aCArIDE7XG4gICAgbGV0IHR1cGxlX2lkID0gbWV0YWRhdGEubmV4dF9pZCBpblxuICAgIHVuc2FmZV9zZXRfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCAoSGVhZGVyLnVzZWQgdHVwbGVfaWQpO1xuICAgIG1ldGFkYXRhLm5leHRfaWQgPC0gVHVwbGVfaWQubmV4dCB0dXBsZV9pZDtcbiAgICBQb2ludGVyLmNyZWF0ZSB+aGVhZGVyX2luZGV4IHR1cGxlX2lkXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9mcmVlICh0eXBlIHNsb3RzKSAodCA6IHNsb3RzIHQpIChwb2ludGVyIDogc2xvdHMgUG9pbnRlci50KSA9XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgIG1ldGFkYXRhLmxlbmd0aCA8LSBtZXRhZGF0YS5sZW5ndGggLSAxO1xuICAgIHVuc2FmZV9hZGRfdG9fZnJlZV9saXN0IHQgbWV0YWRhdGEgfmhlYWRlcl9pbmRleDooUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlcik7XG4gICAgbWF0Y2ggbWV0YWRhdGEuZHVtbXkgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IHBvcyA9IFBvaW50ZXIuZmlyc3Rfc2xvdF9pbmRleCBwb2ludGVyIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlIC0gMSBkb1xuICAgICAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIHQgKHBvcyArIGkpXG4gICAgICBkb25lXG4gICAgfCBTb21lIGR1bW15IC0+XG4gICAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9ibGl0XG4gICAgICAgIH5zcmM6ZHVtbXlcbiAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICB+bGVuOm1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZVxuICAgICAgICB+ZHN0OnRcbiAgICAgICAgfmRzdF9wb3M6KFBvaW50ZXIuZmlyc3Rfc2xvdF9pbmRleCBwb2ludGVyKVxuICA7O1xuXG4gIGxldCBmcmVlICh0eXBlIHNsb3RzKSAodCA6IHNsb3RzIHQpIChwb2ludGVyIDogc2xvdHMgUG9pbnRlci50KSA9XG4gICAgKCogQ2hlY2sgW3BvaW50ZXJfaXNfdmFsaWRdIHRvOlxuICAgICAgIC0gYXZvaWQgZnJlZWluZyBhIG51bGwgcG9pbnRlclxuICAgICAgIC0gYXZvaWQgZnJlZWluZyBhIGZyZWUgcG9pbnRlciAodGhpcyB3b3VsZCBsZWFkIHRvIGEgcG9vbCBpbmNvbnNpc3RlbmN5KVxuICAgICAgIC0gYmUgYWJsZSB0byB1c2UgdW5zYWZlIGZ1bmN0aW9ucyBhZnRlci4gKilcbiAgICBpZiBub3QgKHBvaW50ZXJfaXNfdmFsaWQgdCBwb2ludGVyKVxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUG9vbC5mcmVlIG9mIGludmFsaWQgcG9pbnRlclwiXG4gICAgICAgIChwb2ludGVyLCB0KVxuICAgICAgICBbJXNleHBfb2Y6IF8gUG9pbnRlci50ICogXyB0XTtcbiAgICB1bnNhZmVfZnJlZSB0IHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MSB0IGEwID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzIgdCBhMCBhMSA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXczIHQgYTAgYTEgYTIgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3NCB0IGEwIGExIGEyIGEzID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzUgdCBhMCBhMSBhMiBhMyBhNCA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXc2IHQgYTAgYTEgYTIgYTMgYTQgYTUgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3NyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2ID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNikgKE9iai5yZXByIGE1KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNykgKE9iai5yZXByIGE2KTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzggdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXc5IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA3KSAoT2JqLnJlcHIgYTYpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA4KSAoT2JqLnJlcHIgYTcpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA5KSAoT2JqLnJlcHIgYTgpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MTAgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDkpIChPYmoucmVwciBhOCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEwKSAoT2JqLnJlcHIgYTkpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MTEgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA3KSAoT2JqLnJlcHIgYTYpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA4KSAoT2JqLnJlcHIgYTcpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA5KSAoT2JqLnJlcHIgYTgpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMCkgKE9iai5yZXByIGE5KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTEpIChPYmoucmVwciBhMTApO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MTIgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNikgKE9iai5yZXByIGE1KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNykgKE9iai5yZXByIGE2KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOCkgKE9iai5yZXByIGE3KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOSkgKE9iai5yZXByIGE4KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTApIChPYmoucmVwciBhOSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDExKSAoT2JqLnJlcHIgYTEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTIpIChPYmoucmVwciBhMTEpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MTMgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMiA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDkpIChPYmoucmVwciBhOCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEwKSAoT2JqLnJlcHIgYTkpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMSkgKE9iai5yZXByIGExMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEyKSAoT2JqLnJlcHIgYTExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTMpIChPYmoucmVwciBhMTIpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MTQgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMiBhMTMgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA3KSAoT2JqLnJlcHIgYTYpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA4KSAoT2JqLnJlcHIgYTcpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA5KSAoT2JqLnJlcHIgYTgpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMCkgKE9iai5yZXByIGE5KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTEpIChPYmoucmVwciBhMTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMikgKE9iai5yZXByIGExMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEzKSAoT2JqLnJlcHIgYTEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTQpIChPYmoucmVwciBhMTMpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgZ2V0IHQgcCBzbG90ID0gT2JqLm9iaiAoVW5pZm9ybV9hcnJheS5nZXQgdCAoUG9pbnRlci5zbG90X2luZGV4IHAgc2xvdCkpXG5cbiAgbGV0IHVuc2FmZV9nZXQgdCBwIHNsb3QgPVxuICAgIE9iai5vYmogKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IChQb2ludGVyLnNsb3RfaW5kZXggcCBzbG90KSlcbiAgOztcblxuICBsZXQgc2V0IHQgcCBzbG90IHggPSBVbmlmb3JtX2FycmF5LnNldCB0IChQb2ludGVyLnNsb3RfaW5kZXggcCBzbG90KSAoT2JqLnJlcHIgeClcblxuICBsZXQgdW5zYWZlX3NldCB0IHAgc2xvdCB4ID1cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAoUG9pbnRlci5zbG90X2luZGV4IHAgc2xvdCkgKE9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IGdldF90dXBsZSAodHlwZSB0dXBsZSkgKHQgOiAodHVwbGUsIF8pIFNsb3RzLnQgdCkgcG9pbnRlciA9XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgIGxldCBsZW4gPSBtZXRhZGF0YS5zbG90c19wZXJfdHVwbGUgaW5cbiAgICBpZiBsZW4gPSAxXG4gICAgdGhlbiBnZXQgdCBwb2ludGVyIFNsb3QudDBcbiAgICBlbHNlXG4gICAgICAoT2JqLm1hZ2ljXG4gICAgICAgICAoVW5pZm9ybV9hcnJheS5zdWIgdCB+cG9zOihQb2ludGVyLmZpcnN0X3Nsb3RfaW5kZXggcG9pbnRlcikgfmxlblxuICAgICAgICAgIDogT2JqLnQgVW5pZm9ybV9hcnJheS50KVxuICAgICAgIDogdHVwbGUpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb29sXG5cbm1vZHVsZSBVbnNhZmUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQb29sXG5cbiAgbGV0IGNyZWF0ZSBzbG90cyB+Y2FwYWNpdHkgPSBjcmVhdGVfd2l0aF9kdW1teSBzbG90cyB+Y2FwYWNpdHkgfmR1bW15Ok5vbmVcbmVuZFxuXG5tb2R1bGUgRGVidWcgKFBvb2wgOiBTKSA9IHN0cnVjdFxuICBvcGVuIFBvb2xcblxuICBsZXQgY2hlY2tfaW52YXJpYW50ID0gcmVmIHRydWVcbiAgbGV0IHNob3dfbWVzc2FnZXMgPSByZWYgdHJ1ZVxuXG4gIGxldCBkZWJ1ZyBuYW1lIHRzIGFyZyBzZXhwX29mX2FyZyBzZXhwX29mX3Jlc3VsdCBmID1cbiAgICBsZXQgcHJlZml4ID0gXCJQb29sLlwiIGluXG4gICAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIExpc3QuaXRlciB0cyB+ZjooaW52YXJpYW50IGlnbm9yZSk7XG4gICAgaWYgIXNob3dfbWVzc2FnZXMgdGhlbiBEZWJ1Zy5lcHJpbnRzIChjb25jYXQgWyBwcmVmaXg7IG5hbWUgXSkgYXJnIHNleHBfb2ZfYXJnO1xuICAgIGxldCByZXN1bHRfb3JfZXhuID0gUmVzdWx0LnRyeV93aXRoIGYgaW5cbiAgICBpZiAhc2hvd19tZXNzYWdlc1xuICAgIHRoZW5cbiAgICAgIERlYnVnLmVwcmludHNcbiAgICAgICAgKGNvbmNhdCBbIHByZWZpeDsgbmFtZTsgXCIgcmVzdWx0XCIgXSlcbiAgICAgICAgcmVzdWx0X29yX2V4blxuICAgICAgICBbJXNleHBfb2Y6IChyZXN1bHQsIGV4bikgUmVzdWx0LnRdO1xuICAgIFJlc3VsdC5va19leG4gcmVzdWx0X29yX2V4blxuICA7O1xuXG4gIG1vZHVsZSBTbG90cyA9IFNsb3RzXG4gIG1vZHVsZSBTbG90ID0gU2xvdFxuXG4gIG1vZHVsZSBQb2ludGVyID0gc3RydWN0XG4gICAgb3BlbiBQb2ludGVyXG5cbiAgICB0eXBlIG5vbnJlYyAnc2xvdHMgdCA9ICdzbG90cyB0IFtAQGRlcml2aW5nIHNleHBfb2YsIHR5cGVyZXBdXG5cbiAgICBsZXQgcGh5c19jb21wYXJlIHQxIHQyID1cbiAgICAgIGRlYnVnXG4gICAgICAgIFwiUG9pbnRlci5waHlzX2NvbXBhcmVcIlxuICAgICAgICBbXVxuICAgICAgICAodDEsIHQyKVxuICAgICAgICBbJXNleHBfb2Y6IF8gdCAqIF8gdF1cbiAgICAgICAgWyVzZXhwX29mOiBpbnRdXG4gICAgICAgIChmdW4gKCkgLT4gcGh5c19jb21wYXJlIHQxIHQyKVxuICAgIDs7XG5cbiAgICBsZXQgcGh5c19lcXVhbCB0MSB0MiA9XG4gICAgICBkZWJ1Z1xuICAgICAgICBcIlBvaW50ZXIucGh5c19lcXVhbFwiXG4gICAgICAgIFtdXG4gICAgICAgICh0MSwgdDIpXG4gICAgICAgIFslc2V4cF9vZjogXyB0ICogXyB0XVxuICAgICAgICBbJXNleHBfb2Y6IGJvb2xdXG4gICAgICAgIChmdW4gKCkgLT4gcGh5c19lcXVhbCB0MSB0MilcbiAgICA7O1xuXG4gICAgbGV0IGlzX251bGwgdCA9XG4gICAgICBkZWJ1ZyBcIlBvaW50ZXIuaXNfbnVsbFwiIFtdIHQgWyVzZXhwX29mOiBfIHRdIFslc2V4cF9vZjogYm9vbF0gKGZ1biAoKSAtPiBpc19udWxsIHQpXG4gICAgOztcblxuICAgIGxldCBudWxsID0gbnVsbFxuXG4gICAgbW9kdWxlIElkID0gc3RydWN0XG4gICAgICBvcGVuIElkXG5cbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cblxuICAgICAgbGV0IG9mX2ludDYzIGkgPVxuICAgICAgICBkZWJ1ZyBcIlBvaW50ZXIuSWQub2ZfaW50NjNcIiBbXSBpIFslc2V4cF9vZjogSW50NjMudF0gWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgb2ZfaW50NjMgaSlcbiAgICAgIDs7XG5cbiAgICAgIGxldCB0b19pbnQ2MyB0ID1cbiAgICAgICAgZGVidWcgXCJQb2ludGVyLklkLnRvX2ludDYzXCIgW10gdCBbJXNleHBfb2Y6IHRdIFslc2V4cF9vZjogSW50NjMudF0gKGZ1biAoKSAtPlxuICAgICAgICAgIHRvX2ludDYzIHQpXG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcblxuICB0eXBlIG5vbnJlYyAnc2xvdHMgdCA9ICdzbG90cyB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgbGV0IGlkX29mX3BvaW50ZXIgdCBwb2ludGVyID1cbiAgICBkZWJ1Z1xuICAgICAgXCJpZF9vZl9wb2ludGVyXCJcbiAgICAgIFsgdCBdXG4gICAgICBwb2ludGVyXG4gICAgICBbJXNleHBfb2Y6IF8gUG9pbnRlci50XVxuICAgICAgWyVzZXhwX29mOiBQb2ludGVyLklkLnRdXG4gICAgICAoZnVuICgpIC0+IGlkX29mX3BvaW50ZXIgdCBwb2ludGVyKVxuICA7O1xuXG4gIGxldCBwb2ludGVyX29mX2lkX2V4biB0IGlkID1cbiAgICBkZWJ1Z1xuICAgICAgXCJwb2ludGVyX29mX2lkX2V4blwiXG4gICAgICBbIHQgXVxuICAgICAgaWRcbiAgICAgIFslc2V4cF9vZjogUG9pbnRlci5JZC50XVxuICAgICAgWyVzZXhwX29mOiBfIFBvaW50ZXIudF1cbiAgICAgIChmdW4gKCkgLT4gcG9pbnRlcl9vZl9pZF9leG4gdCBpZClcbiAgOztcblxuICBsZXQgcG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXIgPVxuICAgIGRlYnVnXG4gICAgICBcInBvaW50ZXJfaXNfdmFsaWRcIlxuICAgICAgWyB0IF1cbiAgICAgIHBvaW50ZXJcbiAgICAgIFslc2V4cF9vZjogXyBQb2ludGVyLnRdXG4gICAgICBbJXNleHBfb2Y6IGJvb2xdXG4gICAgICAoZnVuICgpIC0+IHBvaW50ZXJfaXNfdmFsaWQgdCBwb2ludGVyKVxuICA7O1xuXG4gIGxldCBjcmVhdGUgc2xvdHMgfmNhcGFjaXR5IH5kdW1teSA9XG4gICAgZGVidWcgXCJjcmVhdGVcIiBbXSBjYXBhY2l0eSBbJXNleHBfb2Y6IGludF0gWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgIGNyZWF0ZSBzbG90cyB+Y2FwYWNpdHkgfmR1bW15KVxuICA7O1xuXG4gIGxldCBtYXhfY2FwYWNpdHkgfnNsb3RzX3Blcl90dXBsZSA9XG4gICAgZGVidWcgXCJtYXhfY2FwYWNpdHlcIiBbXSBzbG90c19wZXJfdHVwbGUgWyVzZXhwX29mOiBpbnRdIFslc2V4cF9vZjogaW50XSAoZnVuICgpIC0+XG4gICAgICBtYXhfY2FwYWNpdHkgfnNsb3RzX3Blcl90dXBsZSlcbiAgOztcblxuICBsZXQgY2FwYWNpdHkgdCA9XG4gICAgZGVidWcgXCJjYXBhY2l0eVwiIFsgdCBdIHQgWyVzZXhwX29mOiBfIHRdIFslc2V4cF9vZjogaW50XSAoZnVuICgpIC0+IGNhcGFjaXR5IHQpXG4gIDs7XG5cbiAgbGV0IGdyb3cgP2NhcGFjaXR5IHQgPVxuICAgIGRlYnVnXG4gICAgICBcImdyb3dcIlxuICAgICAgWyB0IF1cbiAgICAgIChgY2FwYWNpdHkgY2FwYWNpdHkpXG4gICAgICBbJXNleHBfb2Y6IFsgYGNhcGFjaXR5IG9mIGludCBvcHRpb24gXV1cbiAgICAgIFslc2V4cF9vZjogXyB0XVxuICAgICAgKGZ1biAoKSAtPiBncm93ID9jYXBhY2l0eSB0KVxuICA7O1xuXG4gIGxldCBpc19mdWxsIHQgPVxuICAgIGRlYnVnIFwiaXNfZnVsbFwiIFsgdCBdIHQgWyVzZXhwX29mOiBfIHRdIFslc2V4cF9vZjogYm9vbF0gKGZ1biAoKSAtPiBpc19mdWxsIHQpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9mcmVlIHQgcCA9XG4gICAgZGVidWcgXCJ1bnNhZmVfZnJlZVwiIFsgdCBdIHAgWyVzZXhwX29mOiBfIFBvaW50ZXIudF0gWyVzZXhwX29mOiB1bml0XSAoZnVuICgpIC0+XG4gICAgICB1bnNhZmVfZnJlZSB0IHApXG4gIDs7XG5cbiAgbGV0IGZyZWUgdCBwID1cbiAgICBkZWJ1ZyBcImZyZWVcIiBbIHQgXSBwIFslc2V4cF9vZjogXyBQb2ludGVyLnRdIFslc2V4cF9vZjogdW5pdF0gKGZ1biAoKSAtPiBmcmVlIHQgcClcbiAgOztcblxuICBsZXQgZGVidWdfbmV3IHQgZiA9IGRlYnVnIFwibmV3XCIgWyB0IF0gKCkgWyVzZXhwX29mOiB1bml0XSBbJXNleHBfb2Y6IF8gUG9pbnRlci50XSBmXG4gIGxldCBuZXcxIHQgYTAgPSBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzEgdCBhMClcbiAgbGV0IG5ldzIgdCBhMCBhMSA9IGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3MiB0IGEwIGExKVxuICBsZXQgbmV3MyB0IGEwIGExIGEyID0gZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXczIHQgYTAgYTEgYTIpXG4gIGxldCBuZXc0IHQgYTAgYTEgYTIgYTMgPSBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzQgdCBhMCBhMSBhMiBhMylcbiAgbGV0IG5ldzUgdCBhMCBhMSBhMiBhMyBhNCA9IGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3NSB0IGEwIGExIGEyIGEzIGE0KVxuICBsZXQgbmV3NiB0IGEwIGExIGEyIGEzIGE0IGE1ID0gZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXc2IHQgYTAgYTEgYTIgYTMgYTQgYTUpXG4gIGxldCBuZXc3IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgPSBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzcgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNilcblxuICBsZXQgbmV3OCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3ID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzggdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNylcbiAgOztcblxuICBsZXQgbmV3OSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4ID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzkgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOClcbiAgOztcblxuICBsZXQgbmV3MTAgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSA9XG4gICAgZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXcxMCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5KVxuICA7O1xuXG4gIGxldCBuZXcxMSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCA9XG4gICAgZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXcxMSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMClcbiAgOztcblxuICBsZXQgbmV3MTIgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzEyIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSlcbiAgOztcblxuICBsZXQgbmV3MTMgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMiA9XG4gICAgZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXcxMyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyKVxuICA7O1xuXG4gIGxldCBuZXcxNCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyIGExMyA9XG4gICAgZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXcxNCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyIGExMylcbiAgOztcblxuICBsZXQgZ2V0X3R1cGxlIHQgcG9pbnRlciA9XG4gICAgZGVidWcgXCJnZXRfdHVwbGVcIiBbIHQgXSBwb2ludGVyIFslc2V4cF9vZjogXyBQb2ludGVyLnRdIFslc2V4cF9vZjogX10gKGZ1biAoKSAtPlxuICAgICAgZ2V0X3R1cGxlIHQgcG9pbnRlcilcbiAgOztcblxuICBsZXQgZGVidWdfZ2V0IG5hbWUgZiB0IHBvaW50ZXIgPVxuICAgIGRlYnVnIG5hbWUgWyB0IF0gcG9pbnRlciBbJXNleHBfb2Y6IF8gUG9pbnRlci50XSBbJXNleHBfb2Y6IF9dIChmdW4gKCkgLT4gZiB0IHBvaW50ZXIpXG4gIDs7XG5cbiAgbGV0IGdldCB0IHBvaW50ZXIgc2xvdCA9IGRlYnVnX2dldCBcImdldFwiIGdldCB0IHBvaW50ZXIgc2xvdFxuICBsZXQgdW5zYWZlX2dldCB0IHBvaW50ZXIgc2xvdCA9IGRlYnVnX2dldCBcInVuc2FmZV9nZXRcIiB1bnNhZmVfZ2V0IHQgcG9pbnRlciBzbG90XG5cbiAgbGV0IGRlYnVnX3NldCBuYW1lIGYgdCBwb2ludGVyIHNsb3QgYSA9XG4gICAgZGVidWcgbmFtZSBbIHQgXSBwb2ludGVyIFslc2V4cF9vZjogXyBQb2ludGVyLnRdIFslc2V4cF9vZjogdW5pdF0gKGZ1biAoKSAtPlxuICAgICAgZiB0IHBvaW50ZXIgc2xvdCBhKVxuICA7O1xuXG4gIGxldCBzZXQgdCBwb2ludGVyIHNsb3QgYSA9IGRlYnVnX3NldCBcInNldFwiIHNldCB0IHBvaW50ZXIgc2xvdCBhXG4gIGxldCB1bnNhZmVfc2V0IHQgcG9pbnRlciBzbG90IGEgPSBkZWJ1Z19zZXQgXCJ1bnNhZmVfc2V0XCIgdW5zYWZlX3NldCB0IHBvaW50ZXIgc2xvdCBhXG5lbmRcblxubW9kdWxlIEVycm9yX2NoZWNrIChQb29sIDogUykgPSBzdHJ1Y3RcbiAgb3BlbiBQb29sXG4gIG1vZHVsZSBTbG90cyA9IFNsb3RzXG4gIG1vZHVsZSBTbG90ID0gU2xvdFxuXG4gIG1vZHVsZSBQb2ludGVyID0gc3RydWN0XG4gICAgdHlwZSAnc2xvdHMgdCA9XG4gICAgICB7IG11dGFibGUgaXNfdmFsaWQgOiBib29sXG4gICAgICA7IHBvaW50ZXIgOiAnc2xvdHMgUG9pbnRlci50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZiwgdHlwZXJlcF1cblxuICAgIGxldCBjcmVhdGUgcG9pbnRlciA9IHsgaXNfdmFsaWQgPSB0cnVlOyBwb2ludGVyIH1cbiAgICBsZXQgbnVsbCAoKSA9IHsgaXNfdmFsaWQgPSBmYWxzZTsgcG9pbnRlciA9IFBvaW50ZXIubnVsbCAoKSB9XG4gICAgbGV0IHBoeXNfY29tcGFyZSB0MSB0MiA9IFBvaW50ZXIucGh5c19jb21wYXJlIHQxLnBvaW50ZXIgdDIucG9pbnRlclxuICAgIGxldCBwaHlzX2VxdWFsIHQxIHQyID0gUG9pbnRlci5waHlzX2VxdWFsIHQxLnBvaW50ZXIgdDIucG9pbnRlclxuICAgIGxldCBpc19udWxsIHQgPSBQb2ludGVyLmlzX251bGwgdC5wb2ludGVyXG5cbiAgICBsZXQgZm9sbG93IHQgPVxuICAgICAgaWYgbm90IHQuaXNfdmFsaWRcbiAgICAgIHRoZW4gZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJhdHRlbXB0IHRvIHVzZSBpbnZhbGlkIHBvaW50ZXJcIiB0IFslc2V4cF9vZjogXyB0XTtcbiAgICAgIHQucG9pbnRlclxuICAgIDs7XG5cbiAgICBsZXQgaW52YWxpZGF0ZSB0ID0gdC5pc192YWxpZCA8LSBmYWxzZVxuXG4gICAgbW9kdWxlIElkID0gUG9pbnRlci5JZFxuICBlbmRcblxuICB0eXBlICdzbG90cyB0ID0gJ3Nsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gIGxldCBwb2ludGVyX2lzX3ZhbGlkIHQgeyBQb2ludGVyLmlzX3ZhbGlkOyBwb2ludGVyIH0gPVxuICAgIGlzX3ZhbGlkICYmIHBvaW50ZXJfaXNfdmFsaWQgdCBwb2ludGVyXG4gIDs7XG5cbiAgKCogV2UgZG9uJ3QgZG8gW1BvaW50ZXIuZm9sbG93IHBvaW50ZXJdLCBiZWNhdXNlIHRoYXQgd291bGQgZGlzYWxsb3cgW2lkX29mX3BvaW50ZXIgdFxuICAgICAoUG9pbnRlci5udWxsICgpKV0uICopXG4gIGxldCBpZF9vZl9wb2ludGVyIHQgcG9pbnRlciA9IGlkX29mX3BvaW50ZXIgdCBwb2ludGVyLlBvaW50ZXIucG9pbnRlclxuXG4gIGxldCBwb2ludGVyX29mX2lkX2V4biB0IGlkID1cbiAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJfb2ZfaWRfZXhuIHQgaWQgaW5cbiAgICBsZXQgaXNfdmFsaWQgPSBQb29sLnBvaW50ZXJfaXNfdmFsaWQgdCBwb2ludGVyIGluXG4gICAgeyBQb2ludGVyLmlzX3ZhbGlkOyBwb2ludGVyIH1cbiAgOztcblxuICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gIGxldCBjYXBhY2l0eSA9IGNhcGFjaXR5XG4gIGxldCBtYXhfY2FwYWNpdHkgPSBtYXhfY2FwYWNpdHlcbiAgbGV0IGdyb3cgPSBncm93XG4gIGxldCBpc19mdWxsID0gaXNfZnVsbFxuICBsZXQgZ2V0X3R1cGxlIHQgcCA9IGdldF90dXBsZSB0IChQb2ludGVyLmZvbGxvdyBwKVxuICBsZXQgZ2V0IHQgcCA9IGdldCB0IChQb2ludGVyLmZvbGxvdyBwKVxuICBsZXQgdW5zYWZlX2dldCB0IHAgPSB1bnNhZmVfZ2V0IHQgKFBvaW50ZXIuZm9sbG93IHApXG4gIGxldCBzZXQgdCBwIHNsb3QgdiA9IHNldCB0IChQb2ludGVyLmZvbGxvdyBwKSBzbG90IHZcbiAgbGV0IHVuc2FmZV9zZXQgdCBwIHNsb3QgdiA9IHVuc2FmZV9zZXQgdCAoUG9pbnRlci5mb2xsb3cgcCkgc2xvdCB2XG5cbiAgbGV0IHVuc2FmZV9mcmVlIHQgcCA9XG4gICAgdW5zYWZlX2ZyZWUgdCAoUG9pbnRlci5mb2xsb3cgcCk7XG4gICAgUG9pbnRlci5pbnZhbGlkYXRlIHBcbiAgOztcblxuICBsZXQgZnJlZSB0IHAgPVxuICAgIGZyZWUgdCAoUG9pbnRlci5mb2xsb3cgcCk7XG4gICAgUG9pbnRlci5pbnZhbGlkYXRlIHBcbiAgOztcblxuICBsZXQgbmV3MSB0IGEwID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3MSB0IGEwKVxuICBsZXQgbmV3MiB0IGEwIGExID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3MiB0IGEwIGExKVxuICBsZXQgbmV3MyB0IGEwIGExIGEyID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3MyB0IGEwIGExIGEyKVxuICBsZXQgbmV3NCB0IGEwIGExIGEyIGEzID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3NCB0IGEwIGExIGEyIGEzKVxuICBsZXQgbmV3NSB0IGEwIGExIGEyIGEzIGE0ID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3NSB0IGEwIGExIGEyIGEzIGE0KVxuICBsZXQgbmV3NiB0IGEwIGExIGEyIGEzIGE0IGE1ID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3NiB0IGEwIGExIGEyIGEzIGE0IGE1KVxuICBsZXQgbmV3NyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2ID0gUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3NyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2KVxuXG4gIGxldCBuZXc4IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzggdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNylcbiAgOztcblxuICBsZXQgbmV3OSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4ID1cbiAgICBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXc5IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTgpXG4gIDs7XG5cbiAgbGV0IG5ldzEwIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzEwIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkpXG4gIDs7XG5cbiAgbGV0IG5ldzExIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwID1cbiAgICBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXcxMSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMClcbiAgOztcblxuICBsZXQgbmV3MTIgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExID1cbiAgICBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXcxMiB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEpXG4gIDs7XG5cbiAgbGV0IG5ldzEzIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzEzIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIpXG4gIDs7XG5cbiAgbGV0IG5ldzE0IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIgYTEzID1cbiAgICBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXcxNCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyIGExMylcbiAgOztcbmVuZFxuIl19
