// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Timing_wheel = [0];
   runtime.caml_register_global(0, Timing_wheel, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Expect_test_collector[5][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst$0 = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits = "bits",
    cst_bits_per_slot = "bits_per_slot",
    cst_capacity = "capacity",
    cst_config = "config",
    cst_diff_max_min_allowed_key = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound = "elt_key_lower_bound",
    cst_index = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot = "keys_per_slot",
    cst_length = "length",
    cst_level_bits = "level_bits",
    cst_levels = "levels",
    cst_max_allowed_alarm_time = "max_allowed_alarm_time",
    cst_max_allowed_key = "max_allowed_key",
    cst_max_interval_num = "max_interval_num",
    cst_min_allowed_key = "min_allowed_key",
    cst_min_elt = "min_elt",
    cst_min_key_in_same_slot_mask = "min_key_in_same_slot_mask",
    cst_now = "now",
    cst_now_interval_num_start = "now_interval_num_start",
    cst_pool = "pool",
    cst_priority_queue = "priority_queue",
    cst_slots = "slots",
    cst_slots_mask = "slots_mask",
    cst_start = "start",
    cst_timing_wheel = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1631:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1628:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1644:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1649:26",
    arg_108 = [0, cst$0],
    pos$5 = "timing_wheel/src/timing_wheel.ml:1006:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:1003:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:902:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:909:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:921:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:939:32",
    pos = "timing_wheel/src/timing_wheel.ml:944:30",
    cst = "",
    error_source_039 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List;
   global_data.Base__Field;
   var
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   var
    max_time = Core_Time_ns_alternate_sexp[45],
    min_time = Core_Time_ns_alternate_sexp[43],
    zero = Core_Int[55],
    to_int = Core_Int[61],
    t_of_sexp = Core_Int[79],
    sexp_of_t = Core_Int[80],
    symbol = Core_Int[84],
    symbol$0 = Core_Int[85],
    symbol$1 = Core_Int[87],
    equal = Core_Int[90],
    max_num_bits = Core_Int63[58] - 1 | 0,
    min_value = 0,
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits";
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[47], Core_Int63[14], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[421], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[10], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[8], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    caml_call2
     (Core_List[9],
      t,
      function(num_key_bits){
       invariant(num_key_bits);
       if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      });
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[422], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    if(opt)
     var sth = opt[1], extend_to_max_num_bits = sth;
    else
     var extend_to_max_num_bits = 0;
    if(caml_call1(Core_List[8], x_008))
     caml_call1(Core[6], cst_Level_bits_create_exn_requ);
    if
     (caml_call2
       (Core_List[13],
        x_008,
        function(bits){return caml_call2(Core[89], bits, 0);})){
     var
      _dS_ = [0, caml_call2(Core[421], Core[356], x_008), 0],
      _dT_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _dS_]];
     caml_call1(Core[253], _dT_);
    }
    var
     num_bits =
       caml_call3
        (Core_List[10],
         x_008,
         0,
         function(_d1_, _d0_){return _d1_ + _d0_ | 0;});
    if(caml_call2(Core[91], num_bits, max_num_bits)){
     var
      _dU_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[356], max_num_bits), 0]]], 0],
      _dV_ = [0, [1, [0, _f_, [0, caml_call1(Core[356], num_bits), 0]]], _dU_],
      _dW_ = [0, caml_call2(Core[421], Core[356], x_008), _dV_],
      _dX_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _dW_]];
     caml_call1(Core[253], _dX_);
    }
    if(extend_to_max_num_bits)
     var
      _dY_ = caml_call1(Core[230], 1),
      _dZ_ = caml_call2(Core_List[119], max_num_bits - num_bits | 0, _dY_),
      ints = caml_call2(Core[157], x_008, _dZ_);
    else
     var ints = x_008;
    return caml_call2(Core_List[72], ints, of_int);
   }
   var
    level_bits_default =
      create_exn
       (0, [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]]),
    compare = Core[352],
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds";
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function to_sexpable(t){
    if(caml_call2(Core[92], t, 0)){
     var
      _dP_ = [0, caml_call1(Core[356], t), 0],
      _dQ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _dP_]];
     caml_call1(Core[253], _dQ_);
    }
    var _dR_ = caml_call1(caml_call1(Core_Int63[47], Core_Int63[14]), t);
    return caml_call1(Core_Time_ns[1][127], _dR_);
   }
   function sexp_of_t$1(t){
    var _dO_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _dO_);
   }
   var
    about_one_microsecond = 10,
    _g_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span";
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _dL_ =
        [0, [1, [0, _g_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _dM_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _dL_]];
     caml_call1(Core[253], _dM_);
    }
    var _dN_ = caml_call1(Core_Time_ns[1][126], span);
    return caml_call1(Core_Int63[86], _dN_);
   }
   var
    _h_ = Core_Time_ns[1],
    _i_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _h_[5], _h_[1], _h_[2], _h_[3], _h_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _i_[1],
    bin_write_t = _i_[2],
    bin_read_t = _i_[3],
    bin_read_t$0 = _i_[4],
    bin_shape_t = _i_[5],
    bin_writer_t = _i_[6],
    bin_reader_t = _i_[7],
    bin_t = _i_[8],
    _j_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _j_[9], _j_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _k_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   var
    level_bits$0 =
      [0,
       function(param){return 0;},
       cst_level_bits,
       0,
       level_bits,
       function(r, v){return [0, r[1], v, r[3]];}],
    _l_ = [0, cst_timing_wheel_src_timing_wh, 235, 2],
    cst_alarm_precision = cst_alarm_precision$0,
    _m_ = [0, cst_capacity],
    _n_ = [0, cst_level_bits],
    _o_ = [0, cst_alarm_precision$0],
    _p_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _q_ = [0, cst_timing_wheel_src_timing_wh, 256, 8261, 8285],
    _r_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]];
   function t_of_sexp$2(sexp_019){
    if(0 === sexp_019[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_039, sexp_019);
    var
     field_sexps_020 = sexp_019[1],
     alarm_precision_021 = [0, 0],
     level_bits_023 = [0, 0],
     capacity_025 = [0, 0],
     duplicates_027 = [0, 0],
     extra_028 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_020;
       for(;;){
        if(! param) break;
        var sexp_019$0 = param[1];
        if(1 !== sexp_019$0[0]) break b;
        var _dI_ = sexp_019$0[1];
        if(! _dI_) break c;
        var _dJ_ = _dI_[1];
        if(0 !== _dJ_[0]) break e;
        var field_sexps_031 = _dI_[2], field_name_029 = _dJ_[1];
        if(field_sexps_031 && field_sexps_031[2]) break d;
        var tail_041 = param[2];
        let field_sexps_031$0 = field_sexps_031;
        var
         field_sexp_030 =
           function(param){
            if(! field_sexps_031$0)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019);
            if(field_sexps_031$0[2])
             throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
            var x_042 = field_sexps_031$0[1];
            return x_042;
           };
        if(field_name_029 !== cst_alarm_precision$0)
         if(field_name_029 !== cst_capacity)
          if(field_name_029 !== cst_level_bits){
           if(Sexplib0_Sexp_conv[26][1])
            extra_028[1] = [0, field_name_029, extra_028[1]];
          }
          else if(level_bits_023[1])
           duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
          else{
           var
            field_sexp_030$0 = field_sexp_030(0),
            fvalue_034 = t_of_sexp$0(field_sexp_030$0);
           level_bits_023[1] = [0, fvalue_034];
          }
         else if(capacity_025[1])
          duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
         else{
          var
           field_sexp_030$1 = field_sexp_030(0),
           fvalue_032 = caml_call1(Core[357], field_sexp_030$1);
          capacity_025[1] = [0, fvalue_032];
         }
        else if(alarm_precision_021[1])
         duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
        else{
         var
          field_sexp_030$2 = field_sexp_030(0),
          fvalue_035 = caml_call1(_k_[10], field_sexp_030$2);
         alarm_precision_021[1] = [0, fvalue_035];
        }
        param = tail_041;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019$0);
    }
    if(duplicates_027[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_039,
              duplicates_027[1],
              sexp_019);
    if(extra_028[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_039,
              extra_028[1],
              sexp_019);
    var
     _dK_ = alarm_precision_021[1],
     level_bits_024 = level_bits_023[1],
     match = capacity_025[1];
    if(! _dK_)
     return caml_call3
             (Sexplib0_Sexp_conv_error[15],
              error_source_039,
              sexp_019,
              [0,
               [0, 0 === alarm_precision_021[1] ? 1 : 0, cst_alarm_precision],
               0]);
    var alarm_precision_022 = _dK_[1];
    if(level_bits_024)
     var v_038 = level_bits_024[1], v_038$0 = v_038;
    else
     var v_038$0 = level_bits_default;
    return [0, alarm_precision_022, v_038$0, match];
   }
   function sexp_of_t$3(param){
    var
     capacity_048 = param[3],
     level_bits_046 = param[2],
     alarm_precision_044 = param[1],
     bnds_043 = 0;
    if(capacity_048)
     var
      v_049 = capacity_048[1],
      arg_051 = caml_call1(Core[356], v_049),
      bnd_050 = [1, [0, _m_, [0, arg_051, 0]]],
      bnds_043$0 = [0, bnd_050, bnds_043];
    else
     var bnds_043$0 = bnds_043;
    var
     arg_047 = sexp_of_t$0(level_bits_046),
     bnds_043$1 = [0, [1, [0, _n_, [0, arg_047, 0]]], bnds_043$0],
     arg_045 = caml_call1(_k_[11], alarm_precision_044),
     bnds_043$2 = [0, [1, [0, _o_, [0, arg_045, 0]]], bnds_043$1];
    return [1, bnds_043$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    invariant(alarm_precision);
    return symbol$3(max_num_bits, alarm_precision);
   }
   function invariant$1(t){
    return caml_call4
            (Base_Invariant[1],
             _q_,
             t,
             sexp_of_t$3,
             function(param){
              var _dH_ = max_num_level_bits(t[1]);
              if(! caml_call2(symbol$0, num_bits_internal(t[2]), _dH_))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              var
               level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
              caml_call1(level_bits_fun, level_bits$0);
              return 0;
             });
   }
   function create(capacity, opt, alarm_precision, param){
    if(opt)
     var sth = opt[1], level_bits = sth;
    else
     var level_bits = level_bits_default;
    var max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _r_)], about_one_microsecond, 0);
   }
   function durations(t){
    var t$0 = t[1];
    invariant(t$0);
    var _dF_ = caml_call1(to_int, t$0);
    return caml_call3
            (Core_List[73],
             t[2],
             _dF_,
             function(num_bits_accum, level_num_bits){
              var
               num_bits_accum$0 =
                 num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
               _dG_ =
                 caml_call2
                   (Core[90], num_bits_accum$0, Core_Int63[58] - 1 | 0)
                  ? Core_Int63[59]
                  : caml_call2
                    (Core_Int63[47], Core_Int63[14], num_bits_accum$0),
               duration = caml_call1(Core_Time_ns[1][127], _dG_);
              return [0, num_bits_accum$0, duration];
             });
   }
   var compare$0 = Core_Int63[110], sexp_of_t$4 = Core_Int63[99];
   function create$0(level_bits){
    var _dD_ = Core_Int63[14], _dE_ = pow2(level_bits);
    return caml_call2(Core_Int63[17], _dE_, _dD_);
   }
   var
    one = Core_Int63[14],
    symbol$4 = Core_Int63[17],
    bit_not = Core_Int63[45],
    sexp_of_t$5 = Core_Int63[99],
    equal$1 = Core_Int63[109];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[13],
    one$0 = Core_Int63[14],
    symbol$5 = Core_Int63[16],
    symbol$6 = Core_Int63[18],
    succ = Core_Int63[39],
    pred = Core_Int63[40],
    max_value = Core_Int63[59],
    of_int$0 = Core_Int63[69],
    sexp_of_t$6 = Core_Int63[99],
    symbol$7 = Core_Int63[103],
    symbol$8 = Core_Int63[104],
    symbol$9 = Core_Int63[105],
    symbol$10 = Core_Int63[106],
    symbol$11 = Core_Int63[107],
    symbol$12 = Core_Int63[108],
    equal$2 = Core_Int63[109],
    compare$1 = Core_Int63[110],
    min = Core_Int63[111],
    max = Core_Int63[112],
    ascending = Core_Int63[113],
    descending = Core_Int63[114],
    between = Core_Int63[115],
    clamp_exn = Core_Int63[116],
    clamp = Core_Int63[117],
    Replace_polymorphic_compare = Core_Int63[118],
    comparator = Core_Int63[119],
    Map = Core_Int63[120],
    Set = Core_Int63[121],
    validate_lbound = Core_Int63[128],
    validate_ubound = Core_Int63[129],
    validate_bound = Core_Int63[130];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[13],
    one$1 = Core_Int63[14],
    symbol$13 = Core_Int63[16],
    symbol$14 = Core_Int63[17],
    rem = Core_Int63[25],
    succ$0 = Core_Int63[39],
    pred$0 = Core_Int63[40],
    bit_and = Core_Int63[42],
    shift_right = Core_Int63[48],
    max_value$0 = Core_Int63[59],
    min_value$0 = Core_Int63[60],
    of_int$1 = Core_Int63[69],
    sexp_of_t$7 = Core_Int63[99],
    symbol$15 = Core_Int63[103],
    symbol$16 = Core_Int63[104],
    symbol$17 = Core_Int63[105],
    symbol$18 = Core_Int63[106],
    symbol$19 = Core_Int63[107],
    symbol$20 = Core_Int63[108],
    equal$3 = Core_Int63[109],
    compare$2 = Core_Int63[110],
    min$0 = Core_Int63[111],
    max$0 = Core_Int63[112],
    ascending$0 = Core_Int63[113],
    descending$0 = Core_Int63[114],
    between$0 = Core_Int63[115],
    clamp_exn$0 = Core_Int63[116],
    clamp$0 = Core_Int63[117],
    Replace_polymorphic_compare$0 = Core_Int63[118],
    comparator$0 = Core_Int63[119],
    Map$0 = Core_Int63[120],
    Set$0 = Core_Int63[121],
    hash_fold_t = Core_Int63[122],
    hash = Core_Int63[123],
    hashable = Core_Int63[124],
    Table = Core_Int63[125],
    Hash_set = Core_Int63[126],
    Hash_queue = Core_Int63[127],
    validate_lbound$0 = Core_Int63[128],
    validate_ubound$0 = Core_Int63[129],
    validate_bound$0 = Core_Int63[130];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   var
    _s_ = Set$0[1],
    _t_ = Map$0[1],
    _u_ = Set[1],
    _v_ = Map[1],
    _w_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _v_[9], _v_[10], _v_[11]],
        Map[2],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45],
        Map[46],
        Map[47],
        Map[48],
        Map[49],
        Map[50],
        Map[51],
        Map[52],
        Map[53],
        Map[54],
        Map[55],
        Map[56],
        Map[57],
        Map[58],
        Map[59],
        Map[60],
        Map[61],
        Map[62],
        Map[63],
        Map[64],
        Map[65],
        Map[66],
        Map[67],
        Map[68],
        Map[69],
        Map[70],
        Map[71],
        Map[72],
        Map[73],
        Map[74],
        Map[75],
        Map[76],
        Map[77],
        Map[78],
        Map[79],
        Map[80],
        Map[81],
        Map[82],
        Map[83],
        Map[84],
        Map[85],
        Map[86],
        Map[87],
        Map[88],
        Map[89],
        Map[90],
        Map[91],
        Map[92],
        Map[93],
        Map[94],
        Map[95],
        Map[96],
        Map[97],
        Map[98],
        Map[99],
        Map[100],
        Map[101],
        Map[102],
        Map[103],
        Map[104],
        Map[105],
        Map[106],
        Map[107]],
       [0,
        [0, _u_[1], _u_[2], _u_[11]],
        Set[2],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28],
        Set[29],
        Set[30],
        Set[31],
        Set[32],
        Set[33],
        Set[34],
        Set[35],
        Set[36],
        Set[37],
        Set[38],
        Set[39],
        Set[40],
        Set[41],
        Set[42],
        Set[43],
        Set[44],
        Set[45],
        Set[46],
        Set[47],
        Set[48],
        Set[49],
        Set[50],
        Set[51],
        Set[52],
        Set[53],
        Set[54],
        Set[55],
        Set[56],
        Set[57],
        Set[58],
        Set[59],
        Set[60],
        Set[61],
        Set[62],
        Set[63],
        Set[64],
        Set[65],
        Set[66],
        Set[67],
        Set[68],
        Set[69],
        Set[70],
        Set[71],
        Set[72],
        Set[73],
        Set[74],
        Set[75]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5];
   function sexp_of_pool_slots(of_a_054, x_055){
    var
     _dz_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dC_){return sexp_of_pool_slots(of_a_054, _dC_);}),
     _dA_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dB_){return sexp_of_pool_slots(of_a_054, _dB_);});
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[92],
             of_a_054,
             Core[356],
             _dA_,
             _dz_,
             x_055);
   }
   function sexp_of_t$8(of_a_056, x_057){
    return caml_call2
            (Tuple_pool[36][3][1],
             function(_dy_){return sexp_of_pool_slots(of_a_056, _dy_);},
             x_057);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var
    grow = Tuple_pool[36][12],
    is_full = Tuple_pool[36][13],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm";
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _dx_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[253], _dx_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   var
    slots$0 =
      [0,
       function(param){return 0;},
       cst_slots,
       0,
       slots,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v];
       }],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       [0, set_max_allowed_key],
       max_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                v,
                r[11]];
       }],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       [0, set_min_allowed_key],
       min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                v,
                r[10],
                r[11]];
       }],
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11]];
       }],
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       0,
       diff_max_min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       0,
       min_key_in_same_slot_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                v,
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       0,
       keys_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       0,
       bits_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    slots_mask$0 =
      [0,
       function(param){return 0;},
       cst_slots_mask,
       0,
       slots_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                v,
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits$0 =
      [0,
       function(param){return 0;},
       cst_bits,
       0,
       bits,
       function(r, v){
        return [0,
                r[1],
                v,
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    index$0 =
      [0,
       function(param){return 0;},
       cst_index,
       0,
       index,
       function(r, v){
        return [0,
                v,
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    _C_ = [0, cst_slots],
    _D_ = [0, cst_max_allowed_key],
    _E_ = [0, cst_min_allowed_key],
    _F_ = [0, cst_length],
    _G_ = [0, cst_diff_max_min_allowed_key],
    _H_ = [0, cst_min_key_in_same_slot_mask],
    _I_ = [0, cst_keys_per_slot],
    _J_ = [0, cst_bits_per_slot],
    _K_ = [0, cst_slots_mask],
    _L_ = [0, cst_bits],
    _M_ = [0, cst_index];
   function sexp_of_t$9(of_a_065, param){
    var
     diff_max_min_allowed_key_079 = param[7],
     min_key_in_same_slot_mask_077 = param[6],
     keys_per_slot_075 = param[5],
     bits_per_slot_073 = param[4],
     slots_mask_071 = param[3],
     bits_069 = param[2],
     index_067 = param[1],
     length_081 = param[8],
     min_allowed_key_083 = param[9],
     max_allowed_key_085 = param[10],
     slots_087 = param[11],
     arg_088 = caml_call1(Sexplib0_Sexp_conv[23], slots_087),
     bnds_066 = [0, [1, [0, _C_, [0, arg_088, 0]]], 0],
     arg_086 = caml_call1(sexp_of_t$7, max_allowed_key_085),
     bnds_066$0 = [0, [1, [0, _D_, [0, arg_086, 0]]], bnds_066],
     arg_084 = caml_call1(sexp_of_t$7, min_allowed_key_083),
     bnds_066$1 = [0, [1, [0, _E_, [0, arg_084, 0]]], bnds_066$0],
     arg_082 = caml_call1(Core[356], length_081),
     bnds_066$2 = [0, [1, [0, _F_, [0, arg_082, 0]]], bnds_066$1],
     arg_080 = caml_call1(_w_[1], diff_max_min_allowed_key_079),
     bnds_066$3 = [0, [1, [0, _G_, [0, arg_080, 0]]], bnds_066$2],
     arg_078 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_077),
     bnds_066$4 = [0, [1, [0, _H_, [0, arg_078, 0]]], bnds_066$3],
     arg_076 = caml_call1(_w_[1], keys_per_slot_075),
     bnds_066$5 = [0, [1, [0, _I_, [0, arg_076, 0]]], bnds_066$4],
     arg_074 = caml_call1(sexp_of_t, bits_per_slot_073),
     bnds_066$6 = [0, [1, [0, _J_, [0, arg_074, 0]]], bnds_066$5],
     arg_072 = caml_call1(sexp_of_t$4, slots_mask_071),
     bnds_066$7 = [0, [1, [0, _K_, [0, arg_072, 0]]], bnds_066$6],
     arg_070 = caml_call1(sexp_of_t, bits_069),
     bnds_066$8 = [0, [1, [0, _L_, [0, arg_070, 0]]], bnds_066$7],
     arg_068 = caml_call1(Core[356], index_067),
     bnds_066$9 = [0, [1, [0, _M_, [0, arg_068, 0]]], bnds_066$8];
    return [1, bnds_066$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot(t, key){
    var min_key_in_same_slot_mask = t[6];
    return caml_call2(bit_and, key, min_key_in_same_slot_mask);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   var
    levels$0 =
      [0,
       function(param){return 0;},
       cst_levels,
       0,
       levels,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v];}],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       [0, set_elt_key_lower_bound],
       elt_key_lower_bound,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5]];}],
    min_elt$0 =
      [0,
       function(param){return 0;},
       cst_min_elt,
       [0, set_min_elt],
       min_elt,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5]];}],
    pool$0 =
      [0,
       function(param){return 0;},
       cst_pool,
       [0, set_pool],
       pool,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5]];}],
    length$2 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length$0],
       length$1,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5]];}],
    _S_ = [0, cst_value],
    _T_ = [0, cst_key],
    _U_ = [0, "elts"],
    _V_ = [0, cst_max_allowed_key],
    _W_ = [0, cst_min_allowed_key],
    _at_ = [0, cst_priority_queue],
    _au_ = [0, "max_allowed_key t"],
    _av_ = [0, "min_allowed_key t"],
    _aw_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _ax_ = [0, cst$0],
    _ay_ = [0, "level"],
    _az_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _aA_ = [0, "max_allowed_alarm_interval_num"],
    _aB_ = [0, "min_allowed_alarm_interval_num"],
    _aC_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num";
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){
    var r = caml_check_bound(t[5], 0)[1];
    return r[9];
   }
   function max_allowed_key$1(t){
    var
     _dw_ = num_levels(t) - 1 | 0,
     r = caml_check_bound(t[5], _dw_)[1 + _dw_];
    return r[10];
   }
   function internal_iter(t, f){
    var _do_ = caml_call2(Core[91], t[1], 0);
    if(_do_){
     var pool = t[2], levels = t[5], _dq_ = levels.length - 2 | 0, _dp_ = 0;
     if(_dq_ >= 0){
      var level_index = _dp_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        var slots = level[11], _dt_ = slots.length - 2 | 0, _ds_ = 0;
        if(_dt_ >= 0){
         var slot_index = _ds_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _dv_ = slot_index + 1 | 0;
          if(_dt_ === slot_index) break;
          slot_index = _dv_;
         }
        }
       }
       var _du_ = level_index + 1 | 0;
       if(_dq_ === level_index) break;
       level_index = _du_;
      }
     }
     var _dr_ = 0;
    }
    else
     var _dr_ = _do_;
    return _dr_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var num_bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, num_bits, max_num_bits)) return _w_[26];
    var _dn_ = pow2(num_bits);
    return caml_call1(_w_[32], _dn_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[92], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _dk_ = level_index[1],
      level = caml_check_bound(t[5], _dk_)[1 + _dk_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[90], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _dl_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _dl_)[1 + _dl_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       var i = level[5], t$0 = slot_min_key[1];
       slot_min_key[1] = caml_call2(symbol$13, t$0, i);
      }
      var _dm_ = slot$0[1], first = caml_check_bound(slots, _dm_)[1 + _dm_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if
          (!
           caml_call2(Core[246], next$0, first)
           && ! caml_call2(Core[90], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_135, to_add){
    var
     pool$0 = x_135[2],
     key$0 = key(pool$0, to_add),
     _dd_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_135)),
     _de_ =
       _dd_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_135)) : _dd_;
    if(1 - _de_){
     var pool = x_135[2], r = [0, 0];
     internal_iter
      (x_135,
       function(elt){
        var _di_ = r[1], _dj_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _dj_], _di_];
        return 0;
       });
     var
      elts_115 = caml_call1(Core_List[34], r[1]),
      max_allowed_key_113 = max_allowed_key$1(x_135),
      min_allowed_key_111 = min_allowed_key$1(x_135),
      arg_116 =
        caml_call2
         (Core[421],
          function(param){
           var
            key_105 = param[1],
            bnds_104 = [0, [1, [0, _S_, [0, arg_108, 0]]], 0],
            arg_106 = caml_call1(sexp_of_t$7, key_105),
            bnds_104$0 = [0, [1, [0, _T_, [0, arg_106, 0]]], bnds_104];
           return [1, bnds_104$0];
          },
          elts_115),
      bnds_110 = [0, [1, [0, _U_, [0, arg_116, 0]]], 0],
      arg_114 = caml_call1(sexp_of_t$7, max_allowed_key_113),
      bnds_110$0 = [0, [1, [0, _V_, [0, arg_114, 0]]], bnds_110],
      arg_112 = caml_call1(sexp_of_t$7, min_allowed_key_111),
      bnds_110$1 = [0, [1, [0, _W_, [0, arg_112, 0]]], bnds_110$0],
      _c8_ =
        [0,
         [1,
          [0, _au_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_135)), 0]]],
         [0, [1, [0, _at_, [0, [1, bnds_110$1], 0]]], 0]],
      _c9_ =
        [0,
         [1,
          [0, _av_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_135)), 0]]],
         _c8_],
      _c__ = [0, [1, [0, _aw_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _c9_],
      _c$_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _c__]];
     caml_call1(Core[253], _c$_);
    }
    var level_index = [0, 0];
    for(;;){
     var
      _df_ = level_index[1],
      r$0 = caml_check_bound(x_135[5], _df_)[1 + _df_];
     if(! caml_call2(symbol$18, key$0, r$0[10])) break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_135[5], level_index$0)[1 + level_index$0],
     _dg_ = caml_call2(symbol$15, key$0, level[9]),
     _dh_ = _dg_ ? caml_call2(symbol$16, key$0, level[10]) : _dg_;
    if(1 - _dh_){
     var
      _da_ =
        [0,
         [1,
          [0, _ay_, [0, sexp_of_t$9(function(param){return _ax_;}, level), 0]]],
         0],
      _db_ = [0, [1, [0, _az_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _da_],
      _dc_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _db_]];
     caml_call1(Core[253], _dc_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _c6_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _c7_ = _c6_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _c7_) return _c7_;
    var
     _c2_ =
       [0,
        [1, [0, _aA_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _c3_ =
       [0,
        [1, [0, _aB_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _c2_],
     _c4_ = [0, [1, [0, _aC_, [0, caml_call1(sexp_of_t$7, key), 0]]], _c3_],
     _c5_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _c4_]];
    return caml_call1(Core[253], _c5_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _c0_ = caml_call1(null$1, 0),
     _c1_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _c1_, _c0_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _cW_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _cW_)[1 + _cW_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0],
     _cX_ = next(pool, elt);
    if(caml_call2(Core[246], elt, _cX_)){
     var _cY_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cY_;
     return;
    }
    if(caml_call2(Core[246], elt, first)){
     var _cZ_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cZ_;
    }
    var _cU_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _cU_);
    var _cV_ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _cV_);
   }
   var
    _aD_ =
      [0,
       _w_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       [0,
        [0, _t_[9], _t_[10], _t_[11]],
        Map$0[2],
        Map$0[3],
        Map$0[4],
        Map$0[5],
        Map$0[6],
        Map$0[7],
        Map$0[8],
        Map$0[9],
        Map$0[10],
        Map$0[11],
        Map$0[12],
        Map$0[13],
        Map$0[14],
        Map$0[15],
        Map$0[16],
        Map$0[17],
        Map$0[18],
        Map$0[19],
        Map$0[20],
        Map$0[21],
        Map$0[22],
        Map$0[23],
        Map$0[24],
        Map$0[25],
        Map$0[26],
        Map$0[27],
        Map$0[28],
        Map$0[29],
        Map$0[30],
        Map$0[31],
        Map$0[32],
        Map$0[33],
        Map$0[34],
        Map$0[35],
        Map$0[36],
        Map$0[37],
        Map$0[38],
        Map$0[39],
        Map$0[40],
        Map$0[41],
        Map$0[42],
        Map$0[43],
        Map$0[44],
        Map$0[45],
        Map$0[46],
        Map$0[47],
        Map$0[48],
        Map$0[49],
        Map$0[50],
        Map$0[51],
        Map$0[52],
        Map$0[53],
        Map$0[54],
        Map$0[55],
        Map$0[56],
        Map$0[57],
        Map$0[58],
        Map$0[59],
        Map$0[60],
        Map$0[61],
        Map$0[62],
        Map$0[63],
        Map$0[64],
        Map$0[65],
        Map$0[66],
        Map$0[67],
        Map$0[68],
        Map$0[69],
        Map$0[70],
        Map$0[71],
        Map$0[72],
        Map$0[73],
        Map$0[74],
        Map$0[75],
        Map$0[76],
        Map$0[77],
        Map$0[78],
        Map$0[79],
        Map$0[80],
        Map$0[81],
        Map$0[82],
        Map$0[83],
        Map$0[84],
        Map$0[85],
        Map$0[86],
        Map$0[87],
        Map$0[88],
        Map$0[89],
        Map$0[90],
        Map$0[91],
        Map$0[92],
        Map$0[93],
        Map$0[94],
        Map$0[95],
        Map$0[96],
        Map$0[97],
        Map$0[98],
        Map$0[99],
        Map$0[100],
        Map$0[101],
        Map$0[102],
        Map$0[103],
        Map$0[104],
        Map$0[105],
        Map$0[106],
        Map$0[107]],
       [0,
        [0, _s_[1], _s_[2], _s_[11]],
        Set$0[2],
        Set$0[3],
        Set$0[4],
        Set$0[5],
        Set$0[6],
        Set$0[7],
        Set$0[8],
        Set$0[9],
        Set$0[10],
        Set$0[11],
        Set$0[12],
        Set$0[13],
        Set$0[14],
        Set$0[15],
        Set$0[16],
        Set$0[17],
        Set$0[18],
        Set$0[19],
        Set$0[20],
        Set$0[21],
        Set$0[22],
        Set$0[23],
        Set$0[24],
        Set$0[25],
        Set$0[26],
        Set$0[27],
        Set$0[28],
        Set$0[29],
        Set$0[30],
        Set$0[31],
        Set$0[32],
        Set$0[33],
        Set$0[34],
        Set$0[35],
        Set$0[36],
        Set$0[37],
        Set$0[38],
        Set$0[39],
        Set$0[40],
        Set$0[41],
        Set$0[42],
        Set$0[43],
        Set$0[44],
        Set$0[45],
        Set$0[46],
        Set$0[47],
        Set$0[48],
        Set$0[49],
        Set$0[50],
        Set$0[51],
        Set$0[52],
        Set$0[53],
        Set$0[54],
        Set$0[55],
        Set$0[56],
        Set$0[57],
        Set$0[58],
        Set$0[59],
        Set$0[60],
        Set$0[61],
        Set$0[62],
        Set$0[63],
        Set$0[64],
        Set$0[65],
        Set$0[66],
        Set$0[67],
        Set$0[68],
        Set$0[69],
        Set$0[70],
        Set$0[71],
        Set$0[72],
        Set$0[73],
        Set$0[74],
        Set$0[75]],
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       [0,
        Table[1],
        Table[2],
        Table[3],
        Table[4],
        Table[5],
        Table[6],
        Table[7],
        Table[8],
        Table[9],
        Table[10],
        Table[11],
        Table[12],
        Table[13],
        Table[14],
        Table[15],
        Table[16],
        Table[17],
        Table[18],
        Table[19],
        Table[20],
        Table[21],
        Table[22],
        Table[23],
        Table[24],
        Table[25],
        Table[26],
        Table[27],
        Table[28],
        Table[29],
        Table[30],
        Table[31],
        Table[32],
        Table[33],
        Table[34],
        Table[35],
        Table[36],
        Table[37],
        Table[38],
        Table[39],
        Table[40],
        Table[41],
        Table[42],
        Table[43],
        Table[44],
        Table[45],
        Table[46],
        Table[47],
        Table[48],
        Table[49],
        Table[50],
        Table[51],
        Table[52],
        Table[53],
        Table[54],
        Table[55],
        Table[56],
        Table[57],
        Table[58],
        Table[59],
        Table[60],
        Table[61],
        Table[62],
        Table[63],
        Table[64],
        Table[65],
        Table[66],
        Table[67],
        Table[68],
        Table[69],
        Table[70],
        Table[71],
        Table[72],
        Table[73],
        Table[74],
        Table[75],
        Table[76],
        Table[77],
        Table[78],
        Table[79],
        Table[80],
        Table[81],
        Table[82],
        Table[83],
        Table[84]],
       [0,
        Hash_set[1],
        Hash_set[2],
        Hash_set[3],
        Hash_set[4],
        Hash_set[5],
        Hash_set[6],
        Hash_set[7]],
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _aD_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   var
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       0,
       priority_queue,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       [0, set_max_allowed_alarm_time],
       max_allowed_alarm_time,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       [0, set_now_interval_num_start],
       now_interval_num_start,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}],
    now$0 =
      [0,
       function(param){return 0;},
       cst_now,
       [0, set_now],
       now,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}],
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       0,
       max_interval_num,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}],
    start$0 =
      [0,
       function(param){return 0;},
       cst_start,
       0,
       start,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}],
    config$0 =
      [0,
       function(param){return 0;},
       cst_config,
       0,
       config,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}],
    _x_ = [0, cst_timing_wheel_src_timing_wh, 653, 8],
    _y_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _z_ = [0, cst_timing_wheel_src_timing_wh, 648, 8],
    _A_ = [0, cst$0],
    _B_ = [0, cst_timing_wheel_src_timing_wh, 647, 23049, 23075],
    _N_ = [0, cst_levels],
    _O_ = [0, cst_elt_key_lower_bound],
    _P_ = [0, cst_min_elt],
    _Q_ = [0, cst_pool],
    _R_ = [0, cst_length],
    _X_ = [0, cst_timing_wheel_src_timing_wh, 969, 21],
    _Y_ = [0, cst_timing_wheel_src_timing_wh, 965, 21],
    _Z_ = [0, cst_timing_wheel_src_timing_wh, 961, 21],
    ___ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _$_ = [0, cst_timing_wheel_src_timing_wh, 936, 15],
    _aa_ = [0, cst_timing_wheel_src_timing_wh, 928, 15],
    _ab_ = [0, cst_timing_wheel_src_timing_wh, 914, 15],
    _ac_ = [0, cst_timing_wheel_src_timing_wh, 906, 15],
    _ad_ = [0, cst_timing_wheel_src_timing_wh, 899, 36],
    _ae_ = [0, cst_timing_wheel_src_timing_wh, 898, 38],
    _af_ = [0, cst$0],
    _ag_ = [0, cst_timing_wheel_src_timing_wh, 895, 31577, 31603],
    _ah_ = [0, cst_timing_wheel_src_timing_wh, 997, 15],
    _ai_ = [0, cst_timing_wheel_src_timing_wh, 995, 13],
    _aj_ = [0, cst_timing_wheel_src_timing_wh, 991, 15],
    _ak_ = [0, cst_timing_wheel_src_timing_wh, 988, 13],
    _al_ = [0, cst_timing_wheel_src_timing_wh, 987, 13],
    _am_ = [0, cst_timing_wheel_src_timing_wh, 984, 15],
    _an_ = [0, cst_timing_wheel_src_timing_wh, 983, 15],
    _ao_ = [0, cst_timing_wheel_src_timing_wh, 977, 38],
    _ap_ = [0, cst_timing_wheel_src_timing_wh, 975, 6],
    _aq_ = [0, cst_timing_wheel_src_timing_wh, 974, 6],
    _ar_ = [0, cst$0],
    _as_ = [0, cst_timing_wheel_src_timing_wh, 972, 34918, 34942],
    _aE_ = [0, cst_value],
    _aF_ = [0, cst_at],
    _aG_ = [0, "alarms"],
    _aH_ = [0, cst_now],
    _aI_ = [0, cst_max_interval_num],
    _aJ_ = [0, cst_start],
    _aK_ = [0, cst_config],
    _aL_ = [0, cst$0],
    _aM_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _aN_ = [0, cst$0],
    _aO_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _aP_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _aQ_ = [0, "min_interval_num"],
    _aR_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _aS_ = [0, "t.max_interval_num"],
    _aT_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 1638, 11],
    _aV_ = [0, cst_timing_wheel_src_timing_wh, 1637, 11],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 1636, 11],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 1625, 11],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 1662, 6],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 1658, 6],
    _a1_ = [0, cst_timing_wheel_src_timing_wh, 1654, 6],
    _a2_ = [0, cst$0],
    _a3_ = [0, cst_timing_wheel_src_timing_wh, 1618, 58357, 58379];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[92], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _cT_ = of_external_exn(p[2], t);
    return at(p[2], _cT_);
   }
   function value$0(tw, t){
    var p = tw[7], _cS_ = of_external_exn(p[2], t);
    return value(p[2], _cS_);
   }
   function interval_num(tw, t){
    var p = tw[7], _cR_ = of_external_exn(p[2], t);
    return key(p[2], _cR_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[101], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_167 = t[3],
     start_165 = t[2],
     config_163 = t[1],
     now_169 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _cQ_ = r[1], _cP_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _cP_], _cQ_];
       return 0;
      });
    var
     alarms_171 = caml_call2(Core_List[58], r[1], compare$3),
     arg_172 =
       caml_call2
        (Core[421],
         function(param){
          var
           value_159 = param[2],
           at_157 = param[1],
           arg_160 = caml_call1(sexp_of_a, value_159),
           bnds_156 = [0, [1, [0, _aE_, [0, arg_160, 0]]], 0],
           arg_158 = caml_call1(Core_Time_ns_alternate_sexp[92], at_157),
           bnds_156$0 = [0, [1, [0, _aF_, [0, arg_158, 0]]], bnds_156];
          return [1, bnds_156$0];
         },
         alarms_171),
     bnds_162 = [0, [1, [0, _aG_, [0, arg_172, 0]]], 0],
     arg_170 = caml_call1(Core_Time_ns_alternate_sexp[92], now_169),
     bnds_162$0 = [0, [1, [0, _aH_, [0, arg_170, 0]]], bnds_162],
     arg_168 = caml_call1(_aD_[2], max_interval_num_167),
     bnds_162$1 = [0, [1, [0, _aI_, [0, arg_168, 0]]], bnds_162$0],
     arg_166 = caml_call1(Core_Time_ns_alternate_sexp[92], start_165),
     bnds_162$2 = [0, [1, [0, _aJ_, [0, arg_166, 0]]], bnds_162$1],
     arg_164 = sexp_of_t$3(config_163),
     bnds_162$3 = [0, [1, [0, _aK_, [0, arg_164, 0]]], bnds_162$2];
    return [1, bnds_162$3];
   }
   function length$3(t){var r = t[7]; return r[1];}
   function is_empty$0(t){
    var _cO_ = length$3(t);
    return caml_call2(Core[90], _cO_, 0);
   }
   function pool$1(t){var r = t[7]; return r[2];}
   function interval_num_internal(time, alarm_precision){
    var
     _cM_ = caml_call1(Core_Time_ns_alternate_sexp[61], time),
     _cN_ = caml_call2(Core_Int63[48], _cM_, alarm_precision);
    return caml_call1(_aD_[35], _cN_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[98], time, min_time)){
     var
      _cK_ =
        [0,
         [1,
          [0, _aP_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], time), 0]]],
         0],
      _cL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _cK_]];
     caml_call1(Core[253], _cL_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_aD_[36], interval_num),
     t$0 = t[1][1],
     _cJ_ = caml_call2(Core_Int63[47], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[62], _cJ_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_aD_[7], interval_num, min_interval_num)){
     var
      _cD_ =
        [0, [1, [0, _aQ_, [0, caml_call1(_aD_[2], min_interval_num), 0]]], 0],
      _cE_ =
        [0, [1, [0, _aR_, [0, caml_call1(_aD_[2], interval_num), 0]]], _cD_],
      _cF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _cE_]];
     caml_call1(Core[253], _cF_);
    }
    if(caml_call2(_aD_[6], interval_num, t[3])){
     var
      _cG_ = [0, [1, [0, _aS_, [0, caml_call1(_aD_[2], t[3]), 0]]], 0],
      _cH_ =
        [0, [1, [0, _aT_, [0, caml_call1(_aD_[2], interval_num), 0]]], _cG_],
      _cI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _cH_]];
     caml_call1(Core[253], _cI_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_aD_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_aD_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_174){
    var elt = min_elt$1(x_174[7]);
    if(caml_call1(is_null, elt)){
     var
      _cz_ =
        [0,
         [1,
          [0,
           _aM_,
           [0, sexp_of_t$10(function(param){return _aL_;}, x_174), 0]]],
         0],
      _cA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _cz_]];
     caml_call1(Core[253], _cA_);
    }
    var key$0 = key(pool$1(x_174), elt);
    if(caml_call2(_aD_[9], key$0, x_174[3])){
     var
      _cB_ =
        [0,
         [1,
          [0,
           _aO_,
           [0, sexp_of_t$10(function(param){return _aN_;}, x_174), 0]]],
         0],
      _cC_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _cB_]];
     caml_call1(Core[253], _cC_);
    }
    return next_alarm_fires_at_internal(x_174, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_aD_[3], max_allowed_key, t[3])) return max_time;
    var
     _cv_ = Core_Time_ns[1][67],
     _cw_ = alarm_precision$0(t),
     _cx_ = caml_call2(Core_Time_ns[1][98], _cw_, _cv_),
     _cy_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[51], _cy_, _cx_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    return caml_call4
            (Base_Invariant[1],
             _a3_,
             t,
             function(x_176){
              return sexp_of_t$10(function(param){return _a2_;}, x_176);
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               priority_queue_fun =
                 check
                  (function(t){
                    var pool = t[2];
                    return caml_call4
                            (Base_Invariant[1],
                             _as_,
                             t,
                             function(x_130){
                              function of_a_089(param){return _ar_;}
                              var
                               length_091 = x_130[1],
                               pool_093 = x_130[2],
                               min_elt_095 = x_130[3],
                               elt_key_lower_bound_097 = x_130[4],
                               levels_099 = x_130[5],
                               arg_100 =
                                 caml_call2
                                  (Core[288],
                                   function(_cu_){return sexp_of_t$9(of_a_089, _cu_);},
                                   levels_099),
                               bnds_090 = [0, [1, [0, _N_, [0, arg_100, 0]]], 0],
                               arg_098 = caml_call1(sexp_of_t$7, elt_key_lower_bound_097),
                               bnds_090$0 = [0, [1, [0, _O_, [0, arg_098, 0]]], bnds_090],
                               arg_096 = sexp_of_t$8(of_a_089, min_elt_095),
                               bnds_090$1 = [0, [1, [0, _P_, [0, arg_096, 0]]], bnds_090$0],
                               arg_094 =
                                 caml_call2
                                  (Tuple_pool[36][4],
                                   function(_ct_){return sexp_of_pool_slots(of_a_089, _ct_);},
                                   pool_093),
                               bnds_090$2 = [0, [1, [0, _Q_, [0, arg_094, 0]]], bnds_090$1],
                               arg_092 = caml_call1(Core[356], length_091),
                               bnds_090$3 = [0, [1, [0, _R_, [0, arg_092, 0]]], bnds_090$2];
                              return [1, bnds_090$3];
                             },
                             function(param){
                              function check(f){
                               return caml_call2(Base_Invariant[2], t, f);
                              }
                              if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _aq_], 1);
                              var _cb_ = min_allowed_key$1(t);
                              if(! caml_call2(symbol$15, max_allowed_key$1(t), _cb_))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _ap_], 1);
                              var
                               levels_fun =
                                 check
                                  (function(levels){
                                    var _cg_ = num_levels(t);
                                    if(caml_call2(Core[91], _cg_, 0))
                                     return caml_call2
                                             (Core_Array[58],
                                              levels,
                                              function(level_index$0, level){
                                               if(! caml_call2(Core[90], level_index$0, level[1]))
                                                throw caml_maybe_attach_backtrace
                                                       ([0, Assert_failure, _ah_], 1);
                                               caml_call4
                                                (Base_Invariant[1],
                                                 _ag_,
                                                 level,
                                                 function(x_119){
                                                  return sexp_of_t$9(function(param){return _af_;}, x_119);
                                                 },
                                                 function(param){
                                                  function check(f){
                                                   return caml_call2(Base_Invariant[2], level, f);
                                                  }
                                                  var
                                                   slots_fun =
                                                     check
                                                      (function(slots){
                                                        return caml_call2
                                                                (Core_Array[22],
                                                                 slots,
                                                                 function(elt){
                                                                  var _cl_ = 1 - caml_call1(is_null, elt);
                                                                  return _cl_
                                                                          ? (caml_call4
                                                                             (Base_Invariant[1],
                                                                              _B_,
                                                                              elt,
                                                                              function(x_062){
                                                                               return sexp_of_t$8(function(param){return _A_;}, x_062);
                                                                              },
                                                                              function(param){
                                                                               if(! is_valid(pool, elt))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _z_], 1);
                                                                               caml_call1(invariant_a, value(pool, elt));
                                                                               var n = next(pool, elt);
                                                                               if(! caml_call1(is_null, n)){
                                                                                var _cn_ = prev(pool, n);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cn_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _y_], 1);
                                                                               }
                                                                               var p = prev(pool, elt);
                                                                               if(! caml_call1(is_null, p)){
                                                                                var _cm_ = next(pool, p);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cm_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _x_], 1);
                                                                               }
                                                                               return 0;
                                                                              }),
                                                                            iter
                                                                             (pool,
                                                                              elt,
                                                                              function(elt){
                                                                               var _co_ = level[9];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _co_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, ___], 1);
                                                                               var _cp_ = level[10];
                                                                               if(! caml_call2(symbol$16, key(pool, elt), _cp_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Z_], 1);
                                                                               var _cq_ = t[4];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _cq_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Y_], 1);
                                                                               var _cr_ = level[1], _cs_ = level_index(pool, elt);
                                                                               if(caml_call2(Core[90], _cs_, _cr_))
                                                                                return caml_call1(invariant_a, value(pool, elt));
                                                                               throw caml_maybe_attach_backtrace
                                                                                      ([0, Assert_failure, _X_], 1);
                                                                              }))
                                                                          : _cl_;
                                                                 });
                                                       }),
                                                   max_allowed_key_fun =
                                                     check
                                                      (function(max_allowed_key){
                                                        var expect = add_clamp_to_max(level[9], level[7]);
                                                        function comparator(a_128, b_129){
                                                         return caml_call2(compare$2, a_128, b_129);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos,
                                                                 sexp_of_t$7,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 max_allowed_key);
                                                       }),
                                                   min_allowed_key_fun =
                                                     check
                                                      (function(min_allowed_key){
                                                        if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                                                         throw caml_maybe_attach_backtrace
                                                                ([0, Assert_failure, _$_], 1);
                                                        var
                                                         _ck_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                                                        if(! _ck_) return _ck_;
                                                        var
                                                         got = caml_call2(rem, min_allowed_key, level[5]),
                                                         expect = _w_[24],
                                                         sexpifier = _w_[1];
                                                        function comparator(a_126, b_127){
                                                         return caml_call2(_w_[9], a_126, b_127);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$0,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 got);
                                                       }),
                                                   length_fun =
                                                     check
                                                      (function(length){
                                                        var
                                                         _cj_ =
                                                           caml_call3
                                                            (Core_Array[23],
                                                             level[11],
                                                             0,
                                                             function(n, first){
                                                              if(caml_call1(is_null, first)) return n;
                                                              var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                                                              for(;;){
                                                               if(! continue$0[1]) return n + r[1] | 0;
                                                               r[1]++;
                                                               var next$0 = next(pool, current[1]);
                                                               if(caml_call2(Core[246], next$0, first))
                                                                continue$0[1] = 0;
                                                               else
                                                                current[1] = next$0;
                                                              }
                                                             });
                                                        if(caml_call2(Core[90], length, _cj_)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _aa_], 1);
                                                       }),
                                                   expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                                                   diff_max_min_allowed_key_fun =
                                                     check
                                                      (function(eta){
                                                        var sexpifier = _w_[1];
                                                        function comparator(a_124, b_125){
                                                         return caml_call2(_w_[9], a_124, b_125);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$1,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 eta);
                                                       }),
                                                   min_key_in_same_slot_mask_fun =
                                                     check
                                                      (function(min_key_in_same_slot_mask){
                                                        if
                                                         (caml_call2
                                                           (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                                                         return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ab_], 1);
                                                       }),
                                                   keys_per_slot_fun =
                                                     check
                                                      (function(keys_per_slot){
                                                        var
                                                         num_bits = level[4],
                                                         expect = pow2(num_bits),
                                                         sexpifier = _w_[1];
                                                        function comparator(a_122, b_123){
                                                         return caml_call2(_w_[9], a_122, b_123);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$2,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 keys_per_slot);
                                                       }),
                                                   bits_per_slot_fun =
                                                     check
                                                      (function(bits_per_slot){
                                                        if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ac_], 1);
                                                       }),
                                                   expect$0 = create$0(level[2]),
                                                   slots_mask_fun =
                                                     check
                                                      (function(eta){
                                                        function comparator(a_120, b_121){
                                                         return caml_call2(compare$0, a_120, b_121);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$3,
                                                                 sexp_of_t$4,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect$0,
                                                                 eta);
                                                       }),
                                                   bits_fun =
                                                     check
                                                      (function(bits){
                                                        if(caml_call2(symbol$1, bits, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ad_], 1);
                                                       }),
                                                   index_fun =
                                                     check
                                                      (function(index){
                                                        if(caml_call2(Core[88], index, 0)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ae_], 1);
                                                       });
                                                  caml_call1(index_fun, index$0);
                                                  caml_call1(bits_fun, bits$0);
                                                  caml_call1(slots_mask_fun, slots_mask$0);
                                                  caml_call1(bits_per_slot_fun, bits_per_slot$0);
                                                  caml_call1(keys_per_slot_fun, keys_per_slot$0);
                                                  caml_call1
                                                   (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                                                  caml_call1
                                                   (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                                                  caml_call1(length_fun, length$0);
                                                  caml_call1(min_allowed_key_fun, min_allowed_key$0);
                                                  caml_call1(max_allowed_key_fun, max_allowed_key$0);
                                                  return caml_call1(slots_fun, slots$0);
                                                 });
                                               var _ch_ = caml_call2(Core[91], level_index$0, 0);
                                               if(! _ch_) return _ch_;
                                               var
                                                _ci_ = level_index$0 - 1 | 0,
                                                prev_level = caml_check_bound(levels, _ci_)[1 + _ci_],
                                                got$0 = level[5],
                                                expect = caml_call1(_w_[33], prev_level[7]),
                                                sexpifier = _w_[1];
                                               function comparator(a_131, b_132){
                                                return caml_call2(_w_[9], a_131, b_132);
                                               }
                                               caml_call8
                                                (Ppx_assert_lib_Runtime[3],
                                                 pos$4,
                                                 sexpifier,
                                                 comparator,
                                                 0,
                                                 0,
                                                 0,
                                                 expect,
                                                 got$0);
                                               var
                                                got = level[9],
                                                expect$0 = compute_min_allowed_key(level, prev_level[10]);
                                               function comparator$0(a_133, b_134){
                                                return caml_call2(compare$2, a_133, b_134);
                                               }
                                               return caml_call8
                                                       (Ppx_assert_lib_Runtime[3],
                                                        pos$5,
                                                        sexp_of_t$7,
                                                        comparator$0,
                                                        0,
                                                        0,
                                                        0,
                                                        expect$0,
                                                        got);
                                              });
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ai_], 1);
                                   }),
                               elt_key_lower_bound_fun =
                                 check
                                  (function(elt_key_lower_bound){
                                    if
                                     (!
                                      caml_call2
                                       (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _al_], 1);
                                    if
                                     (!
                                      caml_call2
                                       (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _ak_], 1);
                                    var _cf_ = 1 - caml_call1(is_null, t[3]);
                                    if(! _cf_) return _cf_;
                                    if
                                     (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                                     return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _aj_], 1);
                                   }),
                               min_elt_fun =
                                 check
                                  (function(elt){
                                    var _cd_ = 1 - caml_call1(is_null, elt);
                                    if(! _cd_) return _cd_;
                                    if(! is_valid(t[2], elt))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _an_], 1);
                                    var _ce_ = key(t[2], elt);
                                    if(caml_call2(equal$3, t[4], _ce_)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _am_], 1);
                                   }),
                               pool_fun =
                                 check
                                  (function(t){
                                    return caml_call2
                                            (Tuple_pool[36][5], function(_cc_){return 0;}, t);
                                   }),
                               length_fun =
                                 check
                                  (function(length){
                                    if(caml_call2(Core[88], length, 0)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ao_], 1);
                                   });
                              caml_call1(length_fun, length$2);
                              caml_call1(pool_fun, pool$0);
                              caml_call1(min_elt_fun, min_elt$0);
                              caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
                              return caml_call1(levels_fun, levels$0);
                             });
                   }),
               max_allowed_alarm_time_fun =
                 check
                  (function(max_allowed_alarm_time){
                    var
                     expect = compute_max_allowed_alarm_time(t),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_183, b_184){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_183, b_184);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$6,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             max_allowed_alarm_time);
                   }),
               now_interval_num_start_fun =
                 check
                  (function(now_interval_num_start){
                    var
                     expect = interval_num_start(t, now_interval_num(t)),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_181, b_182){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_181, b_182);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$7,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             now_interval_num_start);
                   }),
               now_fun =
                 check
                  (function(now){
                    if(! caml_call2(Core_Time_ns_alternate_sexp[94], now, t[2]))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aW_], 1);
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[95], now, max_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aV_], 1);
                    var
                     _b$_ = min_allowed_key$1(t[7]),
                     _ca_ = interval_num$0(t, t[4]);
                    if(caml_call2(_aD_[9], _ca_, _b$_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aU_], 1);
                   }),
               max_interval_num_fun =
                 check
                  (function(max_interval_num){
                    var got = interval_num$0(t, max_time), sexpifier = _aD_[2];
                    function comparator(a_177, b_178){
                     return caml_call2(_aD_[22], a_177, b_178);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos$8,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      max_interval_num,
                      got);
                    var
                     got$0 =
                       interval_num$0(t, interval_num_start(t, max_interval_num)),
                     sexpifier$0 = _aD_[2];
                    function comparator$0(a_179, b_180){
                     return caml_call2(_aD_[22], a_179, b_180);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$9,
                             sexpifier$0,
                             comparator$0,
                             0,
                             0,
                             0,
                             max_interval_num,
                             got$0);
                   }),
               start_fun =
                 check
                  (function(start){
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[94], start, min_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aY_], 1);
                    if
                     (caml_call2
                       (Core_Time_ns_alternate_sexp[95], start, max_time))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aX_], 1);
                   }),
               config_fun = check(invariant$1);
              caml_call1(config_fun, config$0);
              caml_call1(start_fun, start$0);
              caml_call1(max_interval_num_fun, max_interval_num$0);
              caml_call1(now_fun, now$0);
              caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
              caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
              caml_call1(priority_queue_fun, priority_queue$0);
              return iter$0
                      (t,
                       function(alarm){
                        var
                         _b4_ = interval_num$0(t, at$0(t, alarm)),
                         _b5_ = interval_num(t, alarm);
                        if(! caml_call2(_aD_[9], _b5_, _b4_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _a1_], 1);
                        var
                         _b6_ = interval_start(t, t[4]),
                         _b7_ = interval_start(t, at$0(t, alarm));
                        if
                         (! caml_call2(Core_Time_ns_alternate_sexp[94], _b7_, _b6_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _a0_], 1);
                        var
                         _b8_ = alarm_precision$0(t),
                         _b9_ =
                           caml_call2(Core_Time_ns_alternate_sexp[54], t[4], _b8_),
                         _b__ = at$0(t, alarm);
                        if(caml_call2(Core_Time_ns_alternate_sexp[97], _b__, _b9_))
                         return 0;
                        throw caml_maybe_attach_backtrace
                               ([0, Assert_failure, _aZ_], 1);
                       });
             });
   }
   var
    debug = 0,
    _a4_ = [0, cst_start],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _a5_ = [0, cst_timing_wheel_src_timing_wh, 1707, 53],
    _a6_ = [0, cst_max_allowed_alarm_time],
    _a7_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _a8_ = [0, cst_now_interval_num_start],
    _a9_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _a__ = [0, cst$0],
    _a$_ = [0, cst_timing_wheel],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    _ba_ = [0, cst$0],
    _bb_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _bc_ = [0, cst$0],
    _bd_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1;
   function advance_clock(t$0, to, handle_removed){
    var _b2_ = caml_call2(Core_Time_ns_alternate_sexp[97], to, t$0[4]);
    if(_b2_){
     t$0[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t$0, to);
     t$0[5] = interval_num_start_unchecked(t$0, t_min_allowed_key);
     var t$1 = t$0[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$1)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$1[5],
       num_levels$0 = num_levels(t$1);
      for(;;){
       if(! caml_call2(Core[92], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$1[4])){
         t$1[3] = caml_call1(null$1, 0);
         t$1[4] = min_allowed_key$1(t$1);
        }
        var match = result[1];
        break;
       }
       var
        _b1_ = level_index[1],
        level = caml_check_bound(levels, _b1_)[1 + _b1_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$1[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[90], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _bY_ = slot$0[1],
          first = caml_check_bound(slots, _bY_)[1 + _bY_];
         if(1 - caml_call1(is_null, first)){
          var _bZ_ = caml_call1(null$1, 0), _b0_ = slot$0[1];
          caml_check_bound(slots, _b0_)[1 + _b0_] = _bZ_;
          var pool = t$1[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$1, current[1]);
           else{
            t$1[1] = t$1[1] - 1 | 0;
            var t = current[1];
            caml_call1(handle_removed, t);
            caml_call2(free, pool, current[1]);
           }
           if(caml_call2(Core[246], next$0, first))
            continue$0[1] = 0;
           else
            current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t$0[6] = compute_max_allowed_alarm_time(t$0); return 0;}
     var _b3_ = debug;
    }
    else
     var _b3_ = _b2_;
    return _b3_;
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[98],
        start,
        Core_Time_ns_alternate_sexp[43])){
     var
      _bO_ =
        [0,
         [1,
          [0,
           _a4_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[92], start), 0]]],
         0],
      _bP_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _bO_]];
     caml_call1(Core[253], _bP_);
    }
    var
     level_bits = config[2],
     capacity$0 = config[3],
     levels =
       caml_call3
         (Core_List[95],
          level_bits,
          [0, zero, zero$1, 0],
          function(index, param, level_bits){
           var
            levels = param[3],
            max_level_min_allowed_key = param[2],
            bits_per_slot = param[1],
            keys_per_slot = pow2(bits_per_slot),
            diff_max_min_allowed_key =
              compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
            min_key_in_same_slot_mask = create$1(bits_per_slot),
            min_allowed_key =
              caml_call2
               (bit_and, max_level_min_allowed_key, min_key_in_same_slot_mask),
            max_allowed_key =
              add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
            _bS_ = caml_call1(null$1, 0),
            _bT_ = pow2(level_bits),
            _bU_ = caml_call1(Core_Int63[5], _bT_),
            _bV_ = caml_call2(Core_Array[38], _bU_, _bS_),
            level =
              [0,
               index,
               level_bits,
               create$0(level_bits),
               bits_per_slot,
               keys_per_slot,
               min_key_in_same_slot_mask,
               diff_max_min_allowed_key,
               0,
               min_allowed_key,
               max_allowed_key,
               _bV_],
            _bW_ = [0, level, levels],
            _bX_ =
              caml_call2(symbol$17, max_allowed_key, max_value$0)
               ? max_value$0
               : caml_call1(succ$0, max_allowed_key);
           return [0, symbol$2(level_bits, bits_per_slot), _bX_, _bW_];
          })
        [3],
     _bL_ = caml_call1(Core_Array[90], levels),
     _bM_ = caml_call1(null$1, 0);
    if(capacity$0)
     var sth = capacity$0[1], capacity = sth;
    else
     var capacity = 1;
    var
     _bN_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _bM_,
        zero$1,
        _bL_],
     _bQ_ = Core_Time_ns_alternate_sexp[46],
     _bR_ = Core_Time_ns_alternate_sexp[46],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _bR_,
        _bQ_,
        max_time,
        _bN_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var
     _bK_ = interval_num_start(t, at),
     t$0 = internal_add(t[7], at, _bK_, value);
    return t$0;
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[97], at, t[6])){
     var
      _bD_ =
        [0,
         [1,
          [0, _a6_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[6]), 0]]],
         0],
      _bE_ =
        [0,
         [1,
          [0, _a7_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
         _bD_],
      _bF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _bE_]];
     caml_call1(Core[253], _bF_);
    }
    var _bJ_ = caml_call2(Core_Time_ns_alternate_sexp[98], at, t[5]);
    if(! _bJ_) return _bJ_;
    var
     _bG_ =
       [0,
        [1,
         [0, _a8_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[5]), 0]]],
        0],
     _bH_ =
       [0,
        [1,
         [0, _a9_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
        _bG_],
     _bI_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _bH_]];
    return caml_call1(Core[253], _bI_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var
     _bC_ = interval_num_unchecked(t, at),
     t$0 = internal_add(t[7], _bC_, at, value);
    return t$0;
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _bt_ = 1 - is_empty(t$0);
    if(_bt_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _bv_ = levels.length - 2 | 0,
      _bu_ = 0;
     if(_bv_ >= 0){
      var level_index = _bu_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _by_ = slots.length - 2 | 0, _bx_ = 0;
        if(_by_ >= 0){
         var slot_index = _bx_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _bA_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _bA_;
          }
          var _bB_ = slot_index + 1 | 0;
          if(_by_ === slot_index) break;
          slot_index = _bB_;
         }
        }
       }
       var _bz_ = level_index + 1 | 0;
       if(_bv_ === level_index) break;
       level_index = _bz_;
      }
     }
     var _bw_ = 0;
    }
    else
     var _bw_ = _bt_;
    return _bw_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[6], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_185){
    var elt = min_elt$1(x_185[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_185), elt);
    var
     _br_ =
       [0,
        [1,
         [0, _a$_, [0, sexp_of_t$10(function(param){return _a__;}, x_185), 0]]],
        0],
     _bs_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _br_]];
    return caml_call1(Core[253], _bs_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[43]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bp_ = max_alarm_time[1], _bq_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[103], _bq_, _bp_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[45]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bn_ = min_alarm_time[1], _bo_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[102], _bo_, _bn_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_186){
    var elt = min_elt$1(x_186[7]);
    if(caml_call1(is_null, elt)){
     var
      _bl_ =
        [0,
         [1,
          [0,
           _bb_,
           [0, sexp_of_t$10(function(param){return _ba_;}, x_186), 0]]],
         0],
      _bm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _bl_]];
     caml_call1(Core[253], _bm_);
    }
    return max_alarm_time_in_list(x_186, elt);
   }
   function min_alarm_time_in_min_interval$0(x_187){
    var elt = min_elt$1(x_187[7]);
    if(caml_call1(is_null, elt)){
     var
      _bj_ =
        [0,
         [1,
          [0,
           _bd_,
           [0, sexp_of_t$10(function(param){return _bc_;}, x_187), 0]]],
         0],
      _bk_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _bj_]];
     caml_call1(Core[253], _bk_);
    }
    return min_alarm_time_in_list(x_187, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _be_ = caml_call2(Core[91], level[8], 0);
    if(_be_){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _bf_ = 1 - caml_call1(is_null, first[1]);
     if(_bf_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _bh_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(caml_call2(Core[246], next$0, first[1]))
        continue$0[1] = 0;
       else
        current[1] = next$0;
       var _bg_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[95], _bg_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _bh_ = _bf_;
     var _bi_ = _bh_;
    }
    else
     var _bi_ = _be_;
    return _bi_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        0,
        46,
        about_one_microsecond,
        20,
        30,
        mul,
        div,
        _k_],
       sexp_of_t$10,
       sexp_of_t_now,
       _aD_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(219, Timing_wheel, cst_Timing_wheel);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzEwOCIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMzkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImludmFyaWFudCQwIiwibnVtX2tleV9iaXRzIiwidF9vZl9zZXhwJDAiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJlcXVhbCQwIiwieF8wMTIiLCJ4XzAxMyIsInRvX3NleHBhYmxlIiwic2V4cF9vZl90JDEiLCJhYm91dF9vbmVfbWljcm9zZWNvbmQiLCJtdWwiLCJkaXYiLCJvZl9zcGFuX2Zsb29yX3BvdzJfbnMiLCJzcGFuIiwibGV2ZWxfYml0cyIsInIiLCJsZXZlbF9iaXRzJDAiLCJ2IiwidF9vZl9zZXhwJDIiLCJzZXhwXzAxOSIsImZpZWxkX3NleHBzXzAyMCIsImFsYXJtX3ByZWNpc2lvbl8wMjEiLCJsZXZlbF9iaXRzXzAyMyIsImNhcGFjaXR5XzAyNSIsImR1cGxpY2F0ZXNfMDI3IiwiZXh0cmFfMDI4Iiwic2V4cF8wMTkkMCIsImZpZWxkX3NleHBzXzAzMSIsImZpZWxkX25hbWVfMDI5IiwidGFpbF8wNDEiLCJmaWVsZF9zZXhwc18wMzEkMCIsImZpZWxkX3NleHBfMDMwIiwieF8wNDIiLCJmaWVsZF9zZXhwXzAzMCQwIiwiZnZhbHVlXzAzNCIsImZpZWxkX3NleHBfMDMwJDEiLCJmdmFsdWVfMDMyIiwiZmllbGRfc2V4cF8wMzAkMiIsImZ2YWx1ZV8wMzUiLCJsZXZlbF9iaXRzXzAyNCIsIm1hdGNoIiwiYWxhcm1fcHJlY2lzaW9uXzAyMiIsInZfMDM4Iiwidl8wMzgkMCIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDQ4IiwibGV2ZWxfYml0c18wNDYiLCJhbGFybV9wcmVjaXNpb25fMDQ0IiwiYm5kc18wNDMiLCJ2XzA0OSIsImFyZ18wNTEiLCJibmRfMDUwIiwiYm5kc18wNDMkMCIsImFyZ18wNDciLCJibmRzXzA0MyQxIiwiYXJnXzA0NSIsImJuZHNfMDQzJDIiLCJhbGFybV9wcmVjaXNpb24iLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMSIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJsb29wIiwicmVtYWluaW5nIiwidCQwIiwiYiIsIm1pY3Jvc2Vjb25kX3ByZWNpc2lvbiIsImR1cmF0aW9ucyIsIm51bV9iaXRzX2FjY3VtIiwibGV2ZWxfbnVtX2JpdHMiLCJudW1fYml0c19hY2N1bSQwIiwiZHVyYXRpb24iLCJjb21wYXJlJDAiLCJzZXhwX29mX3QkNCIsImNyZWF0ZSQwIiwiY3JlYXRlJDEiLCJiaXRzX3Blcl9zbG90IiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInNleHBfb2ZfdCQ3Iiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDU0IiwieF8wNTUiLCJzZXhwX29mX3QkOCIsIm9mX2FfMDU2IiwieF8wNTciLCJudWxsJDAiLCJudWxsJDEiLCJpc19udWxsIiwiZnJlZSIsImtleSIsInAiLCJhdCIsInZhbHVlIiwibGV2ZWxfaW5kZXgiLCJwcmV2Iiwic2V0X3ByZXYiLCJ4IiwibmV4dCIsInNldF9uZXh0IiwiaXNfdmFsaWQiLCJncm93IiwiaXNfZnVsbCIsIm9mX2V4dGVybmFsX2V4biIsInBvb2wiLCJsaW5rIiwiaXRlciIsImZpcnN0IiwiZiIsImN1cnJlbnQiLCJjb250aW51ZSQwIiwibmV4dCQwIiwic2xvdHMiLCJtYXhfYWxsb3dlZF9rZXkiLCJzZXRfbWF4X2FsbG93ZWRfa2V5IiwibWluX2FsbG93ZWRfa2V5Iiwic2V0X21pbl9hbGxvd2VkX2tleSIsImxlbmd0aCIsInNldF9sZW5ndGgiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIiwia2V5c19wZXJfc2xvdCIsInNsb3RzX21hc2siLCJpbmRleCIsInNsb3RzJDAiLCJtYXhfYWxsb3dlZF9rZXkkMCIsIm1pbl9hbGxvd2VkX2tleSQwIiwibGVuZ3RoJDAiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkkMCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2skMCIsImtleXNfcGVyX3Nsb3QkMCIsImJpdHNfcGVyX3Nsb3QkMCIsInNsb3RzX21hc2skMCIsImJpdHMkMCIsImluZGV4JDAiLCJzZXhwX29mX3QkOSIsIm9mX2FfMDY1IiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XzA3OSIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfMDc3Iiwia2V5c19wZXJfc2xvdF8wNzUiLCJiaXRzX3Blcl9zbG90XzA3MyIsInNsb3RzX21hc2tfMDcxIiwiYml0c18wNjkiLCJpbmRleF8wNjciLCJsZW5ndGhfMDgxIiwibWluX2FsbG93ZWRfa2V5XzA4MyIsIm1heF9hbGxvd2VkX2tleV8wODUiLCJzbG90c18wODciLCJhcmdfMDg4IiwiYm5kc18wNjYiLCJhcmdfMDg2IiwiYm5kc18wNjYkMCIsImFyZ18wODQiLCJibmRzXzA2NiQxIiwiYXJnXzA4MiIsImJuZHNfMDY2JDIiLCJhcmdfMDgwIiwiYm5kc18wNjYkMyIsImFyZ18wNzgiLCJibmRzXzA2NiQ0IiwiYXJnXzA3NiIsImJuZHNfMDY2JDUiLCJhcmdfMDc0IiwiYm5kc18wNjYkNiIsImFyZ18wNzIiLCJibmRzXzA2NiQ3IiwiYXJnXzA3MCIsImJuZHNfMDY2JDgiLCJhcmdfMDY4IiwiYm5kc18wNjYkOSIsInNsb3QiLCJuZXh0X3Nsb3QiLCJtaW5fa2V5X2luX3NhbWVfc2xvdCIsImNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkiLCJsZXZlbHMiLCJlbHRfa2V5X2xvd2VyX2JvdW5kIiwic2V0X2VsdF9rZXlfbG93ZXJfYm91bmQiLCJtaW5fZWx0Iiwic2V0X21pbl9lbHQiLCJzZXRfcG9vbCIsImxlbmd0aCQxIiwic2V0X2xlbmd0aCQwIiwibGV2ZWxzJDAiLCJlbHRfa2V5X2xvd2VyX2JvdW5kJDAiLCJtaW5fZWx0JDAiLCJwb29sJDAiLCJsZW5ndGgkMiIsImlzX2VtcHR5IiwibnVtX2xldmVscyIsIm1pbl9hbGxvd2VkX2tleSQxIiwibWF4X2FsbG93ZWRfa2V5JDEiLCJpbnRlcm5hbF9pdGVyIiwibGV2ZWwiLCJzbG90X2luZGV4IiwiZWx0IiwiY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rIiwibWluX2VsdCQxIiwibWluX2VsdF9hbHJlYWR5X2ZvdW5kIiwibWluX2tleV9hbHJlYWR5X2ZvdW5kIiwibnVtX2xldmVscyQwIiwic2xvdF9taW5fa2V5Iiwic2xvdCQwIiwiY3VycmVudF9rZXkiLCJhZGRfZWx0IiwieF8xMzUiLCJ0b19hZGQiLCJrZXkkMCIsImVsdHNfMTE1IiwibWF4X2FsbG93ZWRfa2V5XzExMyIsIm1pbl9hbGxvd2VkX2tleV8xMTEiLCJhcmdfMTE2Iiwia2V5XzEwNSIsImJuZHNfMTA0IiwiYXJnXzEwNiIsImJuZHNfMTA0JDAiLCJibmRzXzExMCIsImFyZ18xMTQiLCJibmRzXzExMCQwIiwiYXJnXzExMiIsImJuZHNfMTEwJDEiLCJyJDAiLCJsZXZlbF9pbmRleCQwIiwicHJldiQwIiwiaW50ZXJuYWxfYWRkX2VsdCIsImVuc3VyZV92YWxpZF9rZXkiLCJpbnRlcm5hbF9hZGQiLCJpbnRlcm5hbF9yZW1vdmUiLCJtaW5faW50ZXJ2YWxfbnVtIiwicHJpb3JpdHlfcXVldWUiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwic2V0X21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Iiwic2V0X25vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJub3ciLCJzZXRfbm93IiwibWF4X2ludGVydmFsX251bSIsInN0YXJ0IiwiY29uZmlnIiwicHJpb3JpdHlfcXVldWUkMCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUkMCIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQkMCIsIm5vdyQwIiwibWF4X2ludGVydmFsX251bSQwIiwic3RhcnQkMCIsImNvbmZpZyQwIiwic2V4cF9vZl90X25vdyIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXQkMCIsInR3IiwidmFsdWUkMCIsImludGVydmFsX251bSIsIml0ZXIkMCIsImNvbXBhcmUkMyIsInNleHBfb2ZfdCQxMCIsInNleHBfb2ZfYSIsIm1heF9pbnRlcnZhbF9udW1fMTY3Iiwic3RhcnRfMTY1IiwiY29uZmlnXzE2MyIsIm5vd18xNjkiLCJhbGFybSIsImFsYXJtc18xNzEiLCJhcmdfMTcyIiwidmFsdWVfMTU5IiwiYXRfMTU3IiwiYXJnXzE2MCIsImJuZHNfMTU2IiwiYXJnXzE1OCIsImJuZHNfMTU2JDAiLCJibmRzXzE2MiIsImFyZ18xNzAiLCJibmRzXzE2MiQwIiwiYXJnXzE2OCIsImJuZHNfMTYyJDEiLCJhcmdfMTY2IiwiYm5kc18xNjIkMiIsImFyZ18xNjQiLCJibmRzXzE2MiQzIiwibGVuZ3RoJDMiLCJpc19lbXB0eSQwIiwicG9vbCQxIiwiaW50ZXJ2YWxfbnVtX2ludGVybmFsIiwidGltZSIsImludGVydmFsX251bV91bmNoZWNrZWQiLCJpbnRlcnZhbF9udW0kMCIsImludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQiLCJpbnRlcnZhbF9udW1fc3RhcnQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIiwibmV4dF9hbGFybV9maXJlc19hdCIsIm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIiwieF8xNzQiLCJjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtIiwibWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIiwiaW50ZXJ2YWxfc3RhcnQiLCJpbnZhcmlhbnQkMiIsImludmFyaWFudF9hIiwieF8xNzYiLCJjaGVjayIsInByaW9yaXR5X3F1ZXVlX2Z1biIsInhfMTMwIiwib2ZfYV8wODkiLCJsZW5ndGhfMDkxIiwicG9vbF8wOTMiLCJtaW5fZWx0XzA5NSIsImVsdF9rZXlfbG93ZXJfYm91bmRfMDk3IiwibGV2ZWxzXzA5OSIsImFyZ18xMDAiLCJibmRzXzA5MCIsImFyZ18wOTgiLCJibmRzXzA5MCQwIiwiYXJnXzA5NiIsImJuZHNfMDkwJDEiLCJhcmdfMDk0IiwiYm5kc18wOTAkMiIsImFyZ18wOTIiLCJibmRzXzA5MCQzIiwibGV2ZWxzX2Z1biIsInhfMTE5Iiwic2xvdHNfZnVuIiwieF8wNjIiLCJuIiwibWF4X2FsbG93ZWRfa2V5X2Z1biIsImV4cGVjdCIsImNvbXBhcmF0b3IiLCJhXzEyOCIsImJfMTI5IiwibWluX2FsbG93ZWRfa2V5X2Z1biIsImdvdCIsInNleHBpZmllciIsImFfMTI2IiwiYl8xMjciLCJsZW5ndGhfZnVuIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5X2Z1biIsImV0YSIsImFfMTI0IiwiYl8xMjUiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrX2Z1biIsImtleXNfcGVyX3Nsb3RfZnVuIiwiYV8xMjIiLCJiXzEyMyIsImJpdHNfcGVyX3Nsb3RfZnVuIiwiZXhwZWN0JDAiLCJzbG90c19tYXNrX2Z1biIsImFfMTIwIiwiYl8xMjEiLCJiaXRzX2Z1biIsImluZGV4X2Z1biIsInByZXZfbGV2ZWwiLCJnb3QkMCIsImFfMTMxIiwiYl8xMzIiLCJjb21wYXJhdG9yJDAiLCJhXzEzMyIsImJfMTM0IiwiZWx0X2tleV9sb3dlcl9ib3VuZF9mdW4iLCJtaW5fZWx0X2Z1biIsInBvb2xfZnVuIiwibWF4X2FsbG93ZWRfYWxhcm1fdGltZV9mdW4iLCJhXzE4MyIsImJfMTg0Iiwibm93X2ludGVydmFsX251bV9zdGFydF9mdW4iLCJhXzE4MSIsImJfMTgyIiwibm93X2Z1biIsIm1heF9pbnRlcnZhbF9udW1fZnVuIiwiYV8xNzciLCJiXzE3OCIsInNleHBpZmllciQwIiwiYV8xNzkiLCJiXzE4MCIsInN0YXJ0X2Z1biIsImNvbmZpZ19mdW4iLCJkZWJ1ZyIsImFkdmFuY2VfY2xvY2siLCJ0byIsImhhbmRsZV9yZW1vdmVkIiwidF9taW5fYWxsb3dlZF9rZXkiLCJ0JDEiLCJyZXN1bHQiLCJtaW5fYWxsb3dlZF9rZXlfYmVmb3JlIiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkkMCIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5JDAiLCJjcmVhdGUkMiIsImNhcGFjaXR5JDAiLCJtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwiYWRkX2F0X2ludGVydmFsX251bSIsImVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0iLCJhZGQkMCIsInJlbW92ZSIsImNsZWFyIiwiZnJlZV9lbHQiLCJtZW0iLCJyZXNjaGVkdWxlX2dlbiIsInJlc2NoZWR1bGUiLCJyZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSIsIm1pbl9hbGFybV9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biIsInhfMTg1IiwibWF4X2FsYXJtX3RpbWVfaW5fbGlzdCIsIndpdGhfa2V5IiwibWF4X2FsYXJtX3RpbWUiLCJtaW5fYWxhcm1fdGltZV9pbl9saXN0IiwibWluX2FsYXJtX3RpbWUiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwkMCIsInhfMTg2IiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJ4XzE4NyIsImZpcmVfcGFzdF9hbGFybXMiLCJoYW5kbGVfZmlyZWQiXSwic291cmNlcyI6WyIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvY29yZV9rZXJuZWwvdGltaW5nX3doZWVsL3RpbWluZ193aGVlbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUE4bEQwQkE7SUFIQUM7SUFnQkFDO0lBS0FDO0lBL3hCaEJDO0lBNEpzQkM7SUFIQUM7SUFyR0RDO0lBT0RDO0lBWUNDO0lBa0JDQztJQUtGQzs7SUFyc0I1QkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXpMa0Q7SUFJaERDO0lBQ0FDOzs7Ozs7Ozs7SUFzREVDO0lBakNBQzs7Ozs7Ozs7Ozs7OztZQUtBQyxVQUFVQztJQUNaLEtBQU8sbUJBREtBLEdBTFZGO0tBTUYsTUFBQTtJQUNPLEdBQUEscUJBRktFLEdBNEJWSDtJQTFCRixNQUFBO0dBQXVCO1lBR3JCSSxPQUFPQyxHQUxQSCxVQUtPRyxJQUNULE9BRFNBLEVBRVI7WUFHQ0MsU0FBTUMsSUFBR0MsSUFDWCxJQUFJTCxJQURJSSxLQUFHQyxRQVZUTixVQVdFQyxJQUNKLE9BRElBLEVBRUg7WUFHQ00sU0FBTUYsSUFBR0MsSUFDWCxJQUFJTCxJQURJSSxLQUFHQyxRQWhCVE4sVUFpQkVDLElBQ0osT0FESUEsRUFFSDtZQUdDTyxLQUFLUCxHQUFJLE9BQUEsMkNBQUpBLEdBQWdDO1lBSXpDUSxZQUFBQztJQUFBLE9BQUEsaUNB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aUIxSyxLQTVyQkgwSTtRQWd0QlIsV0FsdkJKMUcsTUFvdUJFZSxNQWxzQlUyRjtRQW1zQlZ4Riw0QkFGQUssT0FEQTBGLFlBQUFBOzs7Ozs7Ozs7OztHQStjSTs7Ozs7Ozs7O1FBOWtEUi9NO1FBNUJBSztRQVpBSjtRQTRDSVE7UUFBQUE7UUFDQUw7OztRQS9CSkU7OztRQUlBQztRQUNBQzs7T0F5eENGMlA7T0FyREFSOztXQUlGbkssYUFFSUcsUUFDQWtLLE1BRUFHLGNBREFEO09BZ0tGNkM7O1FBeDlDRXRUO1FBZEpOO1FBMEpjSTtRQXhKVmY7UUFrQkFtQjtRQTBHQU87UUExSEFaOztRQTRISjRCO1FBQUEwQjtRQW9CSWU7UUFhQUU7UUExQkFKO1FBTEEzQztRQTZDQXNEO1FBUEFEO09BcTRDRnNVO09BOU9BMUk7T0FYUWI7T0FIUkc7T0F5RUEwQztPQURBRDtPQTlDQTFCO09Bd0VBZ0M7T0E4RUFRO09BL0NBTjtPQWtEQVE7T0FxREFnRjtPQStKQXNDO09BbFlRdEw7T0EyS1I4RDtPQUVBQztPQWdJQWlHO09BL0JBRjtPQTJDQU07T0FGQUg7T0FXQUs7T0FFQUM7T0FaQUw7T0FnQkFNO09BS0FDO09BcUJBTztPQUtBQztPQUtBQztPQVdBRTtPQTFPQTFIO09BV0FDO1dBbmdEQW5VLFVBZzhDQTJULDJCQXI2Q0V2VDs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBCZSBzdXJlIGFuZCBmaXJzdCByZWFkIHRoZSBpbXBsZW1lbnRhdGlvbiBvdmVydmlldyBpbiB0aW1pbmdfd2hlZWxfaW50Zi5tbC5cblxuICAgQSB0aW1pbmcgd2hlZWwgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgXCJsZXZlbHNcIiwgd2hlcmUgZWFjaCBsZXZlbCBpcyBhbiBhcnJheSBvZlxuICAgXCJzbG90c1wiLiAgRWFjaCBzbG90IHJlcHJlc2VudHMgYSByYW5nZSBvZiBrZXlzLCBhbmQgaG9sZHMgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoXG4gICB0aG9zZSBrZXlzLiAgRWFjaCBsZXZlbCBpcyBkZXRlcm1pbmVkIGJ5IHR3byBwYXJhbWV0ZXJzOiBbYml0c10sIHRoZSBudW1iZXIgb2Yga2V5IGJpdHNcbiAgIHRoYXQgdGhhdCBsZXZlbCBpcyByZXNwb25zaWJsZSBmb3IgZGlzdGluZ3Vpc2hpbmcsIGFuZCBbYml0c19wZXJfc2xvdF0sIHRoZSBzaXplIG9mIHRoZVxuICAgcmFuZ2Ugb2Yga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgc2xvdCBpbiB0aGUgYXJyYXkuICBDb25jZXB0dWFsbHksIGVhY2ggbGV2ZWxcbiAgIGJyZWFrcyB1cCBhbGwgcG9zc2libGUga2V5cyBpbnRvIHJhbmdlcyBvZiBzaXplIFsyXmJpdHNfcGVyX3Nsb3RdLiAgVGhlIGxlbmd0aCBvZiBhXG4gICBsZXZlbCBhcnJheSBpcyBbMl5iaXRzXSwgYW5kIHRoZSBhcnJheSBpcyB1c2VkIGxpa2UgYSBjaXJjdWxhciBidWZmZXIgdG8gdHJhdmVyc2UgdGhlXG4gICByYW5nZXMgYXMgdGhlIHRpbWluZyB3aGVlbCdzIFttaW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcy4gIEEga2V5IFtrXSwgaWYgc3RvcmVkIGluIHRoZVxuICAgbGV2ZWwsIGlzIHN0b3JlZCBhdCBpbmRleCBbKGsgLyAyXmJpdHNfcGVyX3Nsb3QpIG1vZCAyXmJpdHNdLlxuXG4gICBUaGUgc2V0dGluZ3Mgb2YgdGhlIFtiaXRzXSB2YWx1ZXMgYXJlIGNvbmZpZ3VyYWJsZSBieSB1c2VyIGNvZGUgdXNpbmcgW0xldmVsX2JpdHNdLFxuICAgYWx0aG91Z2ggdGhlcmUgaXMgYSByZWFzb25hYmxlIGRlZmF1bHQgc2V0dGluZy4gIEdpdmVuIHRoZSBbYml0c10gdmFsdWVzLCB0aGVcbiAgIFtiaXRzX3Blcl9zbG90XSBhcmUgY2hvc2VuIHNvIHRoYXQgW2JpdHNfcGVyX3Nsb3RdIGF0IGxldmVsIFtpXSBpcyB0aGUgc3VtIG9mIHRoZVxuICAgW2JpdHNdIGF0IGFsbCBsb3dlciBsZXZlbHMuICBUaHVzLCBhIHNsb3QncyByYW5nZSBhdCBsZXZlbCBbaV0gaXMgYXMgbGFyZ2UgYXMgdGhlXG4gICBlbnRpcmUgcmFuZ2Ugb2YgdGhlIGFycmF5IGF0IGxldmVsIFtpIC0gMV0uXG5cbiAgIEVhY2ggbGV2ZWwgaGFzIGEgW21pbl9hbGxvd2VkX2tleV0gYW5kIGEgW21heF9hbGxvd2VkX2tleV0gdGhhdCBkZXRlcm1pbmUgdGhlIHJhbmdlIG9mXG4gICBrZXlzIHRoYXQgaXQgY3VycmVudGx5IHJlcHJlc2VudHMuICBUaGUgY3J1Y2lhbCBpbnZhcmlhbnQgb2YgdGhlIHRpbWluZyB3aGVlbCBkYXRhXG4gICBzdHJ1Y3R1cmUgaXMgdGhhdCB0aGUgW21pbl9hbGxvd2VkX2tleV0gYXQgbGV2ZWwgW2ldIGlzIG5vIG1vcmUgdGhhbiB0aGVcbiAgIFttYXhfYWxsb3dlZF9rZXkgKyAxXSBvZiBsZXZlbCBbaSAtIDFdLiAgVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGxldmVscyBjYW4gcmVwcmVzZW50IGFsbFxuICAga2V5cyBmcm9tIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiB0aGUgbG93ZXN0IGxldmVsIHRvIHRoZSBbbWF4X2FsbG93ZWRfa2V5XSBvZiB0aGVcbiAgIGhpZ2hlc3QgbGV2ZWwuICBUaGUgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHJlc3RvcmluZ1xuICAgdGhpcyBpbnZhcmlhbnQuXG5cbiAgIEF0IGxldmVsIDAsIFtiaXRzX3Blcl9zbG90ID0gMF0sIGFuZCBzbyB0aGUgc2l6ZSBvZiBlYWNoIHNsb3QgaXMgWzFdLiAgVGhhdCBpcywgbGV2ZWwgMFxuICAgcHJlY2lzZWx5IGRpc3Rpbmd1aXNoZXMgYWxsIHRoZSBrZXlzIGJldHdlZW4gaXRzIFttaW5fYWxsb3dlZF9rZXldICh3aGljaCBpcyB0aGUgc2FtZVxuICAgYXMgdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIHRoZSBlbnRpcmUgdGltaW5nIHdoZWVsKSBhbmQgW21heF9hbGxvd2VkX2tleV0uICBBcyB0aGVcbiAgIGxldmVscyBpbmNyZWFzZSwgdGhlIFttaW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcywgdGhlIFtiaXRzX3Blcl9zbG90XSBpbmNyZWFzZXMsIGFuZFxuICAgdGhlIHJhbmdlIG9mIGtleXMgc3RvcmVkIGluIHRoZSBsZXZlbCBpbmNyZWFzZXMgKGRyYW1hdGljYWxseSkuXG5cbiAgIFRoZSBpZGVhIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIHRoZSBoaWVyYXJjaGljYWwgYXBwcm9hY2ggZGVzY3JpYmVkIGluOlxuXG4gICB7dlxuICAgICBIYXNoZWQgYW5kIEhpZXJhcmNoaWNhbCBUaW1pbmcgV2hlZWxzOlxuICAgICBFZmZpY2llbnQgRGF0YSBTdHJ1Y3R1cmVzIGZvciBJbXBsZW1lbnRpbmcgYSBUaW1lciBGYWNpbGl0eVxuXG4gICAgIFZhcmdoZXNlICYgTGF1Y2ssIDE5OTZcbiAgIHZ9XG5cbiAgIEhvd2V2ZXIsIHRoZSBjb2RlIGlzIGNvbXBsZXRlbHkgbmV3LiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIFRpbWluZ193aGVlbF9pbnRmXG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcbm1vZHVsZSBUaW1lX25zID0gQ29yZV9wcml2YXRlLlRpbWVfbnNfYWx0ZXJuYXRlX3NleHBcblxubGV0IHNleHBfb2ZfdF9zdHlsZSA6IFsgYFByZXR0eSB8IGBJbnRlcm5hbCBdIHJlZiA9IHJlZiBgUHJldHR5XG5cbigqIFt7bWF4LG1pbn1fdGltZV0gYXJlIGJvdW5kcyBvbiB0aGUgdGltZXMgc3VwcG9ydGVkIGJ5IGEgdGltaW5nIHdoZWVsLiAqKVxuXG5sZXQgbWF4X3RpbWUgPSBUaW1lX25zLm1heF92YWx1ZV9yZXByZXNlbnRhYmxlXG5sZXQgbWluX3RpbWUgPSBUaW1lX25zLmVwb2NoXG5cbm1vZHVsZSBOdW1fa2V5X2JpdHMgOiBzaWdcbiAgdHlwZSB0ID0gcHJpdmF0ZSBpbnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBpbmNsdWRlIENvbXBhcmFibGUgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIEludmFyaWFudC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgemVybyA6IHRcblxuICAoKiB2YWwgbWluX3ZhbHVlIDogdCAqKVxuXG4gIHZhbCBtYXhfdmFsdWUgOiB0XG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsICggKyApIDogdCAtPiB0IC0+IHRcbiAgdmFsICggLSApIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvdzIgOiB0IC0+IEludDYzLnRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIEludFxuXG4gIGxldCBtaW5fdmFsdWUgPSAwXG5cbiAgKCoqIFdlIHN1cHBvcnQgYWxsIG5vbi1uZWdhdGl2ZSBbVGltZV9ucy50XSB2YWx1ZXMuICopXG4gIGxldCBtYXhfdmFsdWUgPSBJbnQ2My5udW1fYml0cyAtIDFcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIGFzc2VydCAodCA+PSBtaW5fdmFsdWUpO1xuICAgIGFzc2VydCAodCA8PSBtYXhfdmFsdWUpXG4gIDs7XG5cbiAgbGV0IG9mX2ludCBpID1cbiAgICBpbnZhcmlhbnQgaTtcbiAgICBpXG4gIDs7XG5cbiAgbGV0ICggKyApIHQxIHQyID1cbiAgICBsZXQgdCA9IHQxICsgdDIgaW5cbiAgICBpbnZhcmlhbnQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0ICggLSApIHQxIHQyID1cbiAgICBsZXQgdCA9IHQxIC0gdDIgaW5cbiAgICBpbnZhcmlhbnQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IHBvdzIgdCA9IEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIHRcbmVuZFxuXG5tb2R1bGUgTGV2ZWxfYml0cyA9IHN0cnVjdFxuICB0eXBlIHQgPSBOdW1fa2V5X2JpdHMudCBsaXN0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgbGV0IG1heF9udW1fYml0cyA9IChOdW1fa2V5X2JpdHMubWF4X3ZhbHVlIDo+IGludClcbiAgbGV0IG51bV9iaXRzX2ludGVybmFsIHQgPSBMaXN0LmZvbGQgdCB+aW5pdDpOdW1fa2V5X2JpdHMuemVybyB+ZjpOdW1fa2V5X2JpdHMuKCArIClcbiAgbGV0IG51bV9iaXRzIHQgPSAobnVtX2JpdHNfaW50ZXJuYWwgdCA6PiBpbnQpXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBhc3NlcnQgKG5vdCAoTGlzdC5pc19lbXB0eSB0KSk7XG4gICAgTGlzdC5pdGVyIHQgfmY6KGZ1biBudW1fa2V5X2JpdHMgLT5cbiAgICAgIE51bV9rZXlfYml0cy5pbnZhcmlhbnQgbnVtX2tleV9iaXRzO1xuICAgICAgYXNzZXJ0IChOdW1fa2V5X2JpdHMuKCA+ICkgbnVtX2tleV9iaXRzIE51bV9rZXlfYml0cy56ZXJvKSk7XG4gICAgTnVtX2tleV9iaXRzLmludmFyaWFudCAobnVtX2JpdHNfaW50ZXJuYWwgdClcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIGxldCB0ID0gc2V4cCB8PiBbJW9mX3NleHA6IHRdIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBjcmVhdGVfZXhuID8oZXh0ZW5kX3RvX21heF9udW1fYml0cyA9IGZhbHNlKSBpbnRzID1cbiAgICBpZiBMaXN0LmlzX2VtcHR5IGludHMgdGhlbiBmYWlsd2l0aCBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biByZXF1aXJlcyBhIG5vbmVtcHR5IGxpc3RcIjtcbiAgICBpZiBMaXN0LmV4aXN0cyBpbnRzIH5mOihmdW4gYml0cyAtPiBiaXRzIDw9IDApXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJMZXZlbF9iaXRzLmNyZWF0ZV9leG4gZ290IG5vbnBvc2l0aXZlIG51bSBiaXRzXCIgfl86KGludHMgOiBpbnQgbGlzdCldO1xuICAgIGxldCBudW1fYml0cyA9IExpc3QuZm9sZCBpbnRzIH5pbml0OjAgfmY6KCArICkgaW5cbiAgICBpZiBudW1fYml0cyA+IG1heF9udW1fYml0c1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJMZXZlbF9iaXRzLmNyZWF0ZV9leG4gZ290IHRvbyBtYW55IGJpdHNcIlxuICAgICAgICAgICAgfl86KGludHMgOiBpbnQgbGlzdClcbiAgICAgICAgICAgIH5nb3Q6KG51bV9iaXRzIDogaW50KVxuICAgICAgICAgICAgKG1heF9udW1fYml0cyA6IGludCldO1xuICAgIGxldCBpbnRzID1cbiAgICAgIGlmIGV4dGVuZF90b19tYXhfbnVtX2JpdHNcbiAgICAgIHRoZW4gaW50cyBAIExpc3QuaW5pdCAobWF4X251bV9iaXRzIC0gbnVtX2JpdHMpIH5mOihjb25zdCAxKVxuICAgICAgZWxzZSBpbnRzXG4gICAgaW5cbiAgICBMaXN0Lm1hcCBpbnRzIH5mOk51bV9rZXlfYml0cy5vZl9pbnRcbiAgOztcblxuICBsZXQgZGVmYXVsdCA9IGNyZWF0ZV9leG4gWyAxMTsgMTA7IDEwOyAxMDsgMTA7IDEwOyAxIF1cblxuICBsZXQgdHJpbSB0IH5tYXhfbnVtX2JpdHMgPVxuICAgIGlmIE51bV9rZXlfYml0cy4oIDw9ICkgKG51bV9iaXRzX2ludGVybmFsIHQpIG1heF9udW1fYml0c1xuICAgIHRoZW4gdFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIHQgfnJlbWFpbmluZyA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IFtdXG4gICAgICAgIHwgYiA6OiB0IC0+XG4gICAgICAgICAgaWYgTnVtX2tleV9iaXRzLiggPj0gKSBiIHJlbWFpbmluZ1xuICAgICAgICAgIHRoZW4gWyByZW1haW5pbmcgXVxuICAgICAgICAgIGVsc2UgYiA6OiBsb29wIHQgfnJlbWFpbmluZzooTnVtX2tleV9iaXRzLiggLSApIHJlbWFpbmluZyBiKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCB+cmVtYWluaW5nOm1heF9udW1fYml0cylcbiAgOztcbmVuZFxuXG5tb2R1bGUgQWxhcm1fcHJlY2lzaW9uIDogc2lnXG4gIGluY2x1ZGUgQWxhcm1fcHJlY2lzaW9uXG5cbiAgdmFsIG51bV9rZXlfYml0cyA6IHQgLT4gTnVtX2tleV9iaXRzLnRcbiAgdmFsIGludGVydmFsX251bSA6IHQgLT4gVGltZV9ucy50IC0+IEludDYzLnRcbiAgdmFsIGludGVydmFsX251bV9zdGFydCA6IHQgLT4gSW50NjMudCAtPiBUaW1lX25zLnRcbmVuZCA9IHN0cnVjdFxuICAoKiogW3RdIGlzIHJlcHJlc2VudGVkIGFzIHRoZSBsb2cyIG9mIGEgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLiAqKVxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgaGFzaF1cblxuICBsZXQgZXF1YWwgPSBbJWNvbXBhcmUuZXF1YWw6IHRdXG4gIGxldCBudW1fa2V5X2JpdHMgdCA9IHQgfD4gTnVtX2tleV9iaXRzLm9mX2ludFxuXG4gIGxldCB0b19zcGFuIHQgPVxuICAgIGlmIHQgPCAwXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltBbGFybV9wcmVjaXNpb24udG9fc3Bhbl0gb2YgbmVnYXRpdmUgcG93ZXIgb2YgdHdvIG5hbm9zZWNvbmRzXCIgfl86KHQgOiBpbnQpXTtcbiAgICBJbnQ2My4oc2hpZnRfbGVmdCBvbmUpIHQgfD4gVGltZV9ucy5TcGFuLm9mX2ludDYzX25zXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwICh0IHw+IHRvX3NwYW4gOiBUaW1lX25zLlNwYW4udCldXG4gIGxldCBvbmVfbmFub3NlY29uZCA9IDBcbiAgbGV0IGFib3V0X29uZV9taWNyb3NlY29uZCA9IDEwXG4gIGxldCBhYm91dF9vbmVfbWlsbGlzZWNvbmQgPSAyMFxuICBsZXQgYWJvdXRfb25lX3NlY29uZCA9IDMwXG4gIGxldCBhYm91dF9vbmVfZGF5ID0gNDZcbiAgbGV0IG11bCB0IH5wb3cyID0gdCArIHBvdzJcbiAgbGV0IGRpdiB0IH5wb3cyID0gdCAtIHBvdzJcbiAgbGV0IGludGVydmFsX251bSB0IHRpbWUgPSBJbnQ2My5zaGlmdF9yaWdodCAodGltZSB8PiBUaW1lX25zLnRvX2ludDYzX25zX3NpbmNlX2Vwb2NoKSB0XG5cbiAgbGV0IGludGVydmFsX251bV9zdGFydCB0IGludGVydmFsX251bSA9XG4gICAgSW50NjMuc2hpZnRfbGVmdCBpbnRlcnZhbF9udW0gdCB8PiBUaW1lX25zLm9mX2ludDYzX25zX3NpbmNlX2Vwb2NoXG4gIDs7XG5cbiAgbGV0IG9mX3NwYW5fZmxvb3JfcG93Ml9ucyBzcGFuID1cbiAgICBpZiBUaW1lX25zLlNwYW4uKCA8PSApIHNwYW4gVGltZV9ucy5TcGFuLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiW0FsYXJtX3ByZWNpc2lvbi5vZl9zcGFuX2Zsb29yX3BvdzJfbnNdIGdvdCBub24tcG9zaXRpdmUgc3BhblwiXG4gICAgICAgICAgICAoc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV07XG4gICAgc3BhbiB8PiBUaW1lX25zLlNwYW4udG9faW50NjNfbnMgfD4gSW50NjMuZmxvb3JfbG9nMlxuICA7O1xuXG4gIGxldCBvZl9zcGFuID0gb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXG5cbiAgbW9kdWxlIFVuc3RhYmxlID0gc3RydWN0XG4gICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIGNvbXBhcmVdXG5cbiAgICAgIGxldCBvZl9iaW5hYmxlID0gb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXG4gICAgICBsZXQgdG9fYmluYWJsZSA9IHRvX3NwYW5cbiAgICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuICAgICAgbGV0IHRvX3NleHBhYmxlID0gdG9fc3BhblxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBCaW5hYmxlLk9mX2JpbmFibGVfd2l0aG91dF91dWlkIFtAYWxlcnQgXCItbGVnYWN5XCJdIChUaW1lX25zLlNwYW4pIChUKVxuICAgIGluY2x1ZGUgU2V4cGFibGUuT2Zfc2V4cGFibGUgKFRpbWVfbnMuU3BhbikgKFQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBDb25maWcgPSBzdHJ1Y3RcbiAgbGV0IGxldmVsX2JpdHNfZGVmYXVsdCA9IExldmVsX2JpdHMuZGVmYXVsdFxuXG4gIHR5cGUgdCA9XG4gICAgeyBhbGFybV9wcmVjaXNpb24gOiBBbGFybV9wcmVjaXNpb24uVW5zdGFibGUudFxuICAgIDsgbGV2ZWxfYml0cyA6IExldmVsX2JpdHMudCBbQGRlZmF1bHQgbGV2ZWxfYml0c19kZWZhdWx0XVxuICAgIDsgY2FwYWNpdHkgOiBpbnQgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBdXG5cbiAgbGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gQWxhcm1fcHJlY2lzaW9uLnRvX3NwYW4gdC5hbGFybV9wcmVjaXNpb25cblxuICAoKiBbbWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGxldmVsIGJpdHMgbmVlZGVkIGZvciBhXG4gICAgIHRpbWluZyB3aGVlbCB3aXRoIHRoZSBzcGVjaWZpZWQgW2FsYXJtX3ByZWNpc2lvbl0gdG8gYmUgYWJsZSB0byByZXByZXNlbnQgYWxsXG4gICAgIHBvc3NpYmxlIHRpbWVzIGZyb20gW1RpbWVfbnMuZXBvY2hdIG9ud2FyZC4gIFNpbmNlIG5vbi1uZWdhdGl2ZSB0aW1lcyBoYXZlIDYyIGJpdHMsXG4gICAgIHdlIHJlcXVpcmUgW0wgPD0gNjIgLSBBXSwgd2hlcmUgW0FdIGlzIHRoZSBudW1iZXIgb2YgYWxhcm0gYml0cyBhbmQgW0xdIGlzIHRoZVxuICAgICBudW1iZXIgb2YgbGV2ZWwgYml0cy4gKilcbiAgbGV0IG1heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb24gPVxuICAgIE51bV9rZXlfYml0cy4oIC0gKVxuICAgICAgTnVtX2tleV9iaXRzLm1heF92YWx1ZVxuICAgICAgKEFsYXJtX3ByZWNpc2lvbi5udW1fa2V5X2JpdHMgYWxhcm1fcHJlY2lzaW9uKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBOdW1fa2V5X2JpdHMuKCA8PSApXG4gICAgICAgICAgKExldmVsX2JpdHMubnVtX2JpdHNfaW50ZXJuYWwgdC5sZXZlbF9iaXRzKVxuICAgICAgICAgIChtYXhfbnVtX2xldmVsX2JpdHMgdC5hbGFybV9wcmVjaXNpb24pKTtcbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmFsYXJtX3ByZWNpc2lvbjppZ25vcmVcbiAgICAgICAgfmNhcGFjaXR5Omlnbm9yZVxuICAgICAgICB+bGV2ZWxfYml0czooY2hlY2sgTGV2ZWxfYml0cy5pbnZhcmlhbnQpKVxuICA7O1xuXG4gIGxldCBjcmVhdGUgP2NhcGFjaXR5ID8obGV2ZWxfYml0cyA9IGxldmVsX2JpdHNfZGVmYXVsdCkgfmFsYXJtX3ByZWNpc2lvbiAoKSA9XG4gICAgbGV0IGxldmVsX2JpdHMgPVxuICAgICAgTGV2ZWxfYml0cy50cmltIGxldmVsX2JpdHMgfm1heF9udW1fYml0czoobWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbilcbiAgICBpblxuICAgIHsgYWxhcm1fcHJlY2lzaW9uOyBsZXZlbF9iaXRzOyBjYXBhY2l0eSB9XG4gIDs7XG5cbiAgbGV0IG1pY3Jvc2Vjb25kX3ByZWNpc2lvbiAoKSA9XG4gICAgY3JlYXRlXG4gICAgICAoKVxuICAgICAgfmFsYXJtX3ByZWNpc2lvbjpBbGFybV9wcmVjaXNpb24uYWJvdXRfb25lX21pY3Jvc2Vjb25kXG4gICAgICB+bGV2ZWxfYml0czooTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFsgMTA7IDEwOyA2OyA2OyA1IF0pXG4gIDs7XG5cbiAgbGV0IGR1cmF0aW9ucyB0ID1cbiAgICBMaXN0LmZvbGRpbmdfbWFwXG4gICAgICB0LmxldmVsX2JpdHNcbiAgICAgIH5pbml0OihBbGFybV9wcmVjaXNpb24ubnVtX2tleV9iaXRzIHQuYWxhcm1fcHJlY2lzaW9uIHw+IE51bV9rZXlfYml0cy50b19pbnQpXG4gICAgICB+ZjooZnVuIG51bV9iaXRzX2FjY3VtIGxldmVsX251bV9iaXRzIC0+XG4gICAgICAgIGxldCBudW1fYml0c19hY2N1bSA9IG51bV9iaXRzX2FjY3VtICsgKGxldmVsX251bV9iaXRzIHw+IE51bV9rZXlfYml0cy50b19pbnQpIGluXG4gICAgICAgIGxldCBkdXJhdGlvbiA9XG4gICAgICAgICAgVGltZV9ucy5TcGFuLm9mX2ludDYzX25zXG4gICAgICAgICAgICAoaWYgbnVtX2JpdHNfYWNjdW0gPSBJbnQ2My5udW1fYml0cyAtIDFcbiAgICAgICAgICAgICB0aGVuIEludDYzLm1heF92YWx1ZVxuICAgICAgICAgICAgIGVsc2UgSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHNfYWNjdW0pXG4gICAgICAgIGluXG4gICAgICAgIG51bV9iaXRzX2FjY3VtLCBkdXJhdGlvbilcbiAgOztcbmVuZFxuXG5cbigqKiBUaW1pbmcgd2hlZWwgaXMgaW1wbGVtZW50ZWQgYXMgYSBwcmlvcml0eSBxdWV1ZSBpbiB3aGljaCB0aGUga2V5cyBhcmVcbiAgICBub24tbmVnYXRpdmUgaW50ZWdlcnMgY29ycmVzcG9uZGluZyB0byB0aGUgaW50ZXJ2YWxzIG9mIHRpbWUuICBUaGUgcHJpb3JpdHkgcXVldWUgaXNcbiAgICB1bmxpa2UgYSB0eXBpY2FsIHByaW9yaXR5IHF1ZXVlIGluIHRoYXQgcmF0aGVyIHRoYW4gaGF2aW5nIGEgXCJkZWxldGUgbWluXCIgb3BlcmF0aW9uLFxuICAgIGl0IGhhcyBhIG5vbmRlY3JlYXNpbmcgbWluaW11bSBhbGxvd2VkIGtleSwgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgdGltZSxcbiAgICBhbmQgYW4gW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gb3BlcmF0aW9uLCB3aGljaCBpbXBsZW1lbnRzIFthZHZhbmNlX2Nsb2NrXS5cbiAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBhcyBhIHNpZGUgZWZmZWN0IHJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHRpbWluZ1xuICAgIHdoZWVsIHdob3NlIGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG5ldyBtaW5pbXVtLCB3aGljaCBpbXBsZW1lbnRzIGZpcmluZyB0aGUgYWxhcm1zXG4gICAgd2hvc2UgdGltZSBoYXMgZXhwaXJlZC5cblxuICAgIEFkZGluZyBlbGVtZW50cyB0byBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBhIHRpbWluZyB3aGVlbCB0YWtlcyBjb25zdGFudCB0aW1lLFxuICAgIHVubGlrZSBhIGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgd2hpY2ggdGFrZXMgbG9nKE4pLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2ZcbiAgICBlbGVtZW50cyBpbiB0aGUgaGVhcC4gIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIHRoZVxuICAgIGFtb3VudCBvZiBpbmNyZWFzZSBpbiB0aGUgbWluLWFsbG93ZWQga2V5LCBhcyBjb21wYXJlZCB0byBsb2coTikgZm9yIGEgaGVhcC4gIEl0IGlzXG4gICAgdGhlc2UgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZXMgdGhhdCBtb3RpdmF0ZSB0aGUgZXhpc3RlbmNlIG9mIHRpbWluZyB3aGVlbHMgYW5kIG1ha2VcbiAgICB0aGVtIGEgZ29vZCBjaG9pY2UgZm9yIG1haW50YWluZyBhIHNldCBvZiBhbGFybXMuICBXaXRoIGEgdGltaW5nIHdoZWVsLCBvbmUgY2FuXG4gICAgc3VwcG9ydCBhbnkgbnVtYmVyIG9mIGFsYXJtcyBwYXlpbmcgY29uc3RhbnQgb3ZlcmhlYWQgcGVyIGFsYXJtLCB3aGlsZSBwYXlpbmcgYVxuICAgIHNtYWxsIGNvbnN0YW50IG92ZXJoZWFkIHBlciB1bml0IG9mIHRpbWUgcGFzc2VkLlxuXG4gICAgQXMgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgaW5jcmVhc2VzLCB0aGUgdGltaW5nIHdoZWVsIGRvZXMgYSBsYXp5IHJhZGl4IHNvcnQgb2YgdGhlXG4gICAgZWxlbWVudCBrZXlzLCB3aXRoIGxldmVsIDAgaGFuZGxpbmcgdGhlIGxlYXN0IHNpZ25pZmljYW50IFtiXzBdIGJpdHMgaW4gYSBrZXksIGFuZFxuICAgIGVhY2ggc3Vic2VxdWVudCBsZXZlbCBbaV0gaGFuZGxpbmcgdGhlIG5leHQgbW9zdCBzaWduaWZpY2FudCBbYl9pXSBiaXRzLiAgVGhlIGxldmVsc1xuICAgIGhvbGQgaW5jcmVhc2luZ2x5IGxhcmdlciByYW5nZXMgb2Yga2V5cywgd2hlcmUgdGhlIHVuaW9uIG9mIGFsbCB0aGUgbGV2ZWxzIGNhbiBob2xkXG4gICAgYW55IGtleSBmcm9tIFttaW5fYWxsb3dlZF9rZXkgdF0gdG8gW21heF9hbGxvd2VkX2tleSB0XS4gIFdoZW4gYSBrZXkgaXMgYWRkZWQgdG8gdGhlXG4gICAgdGltaW5nIHdoZWVsLCBpdCBpcyBhZGRlZCBhdCB0aGUgbG93ZXN0IHBvc3NpYmxlIGxldmVsIHRoYXQgY2FuIHN0b3JlIHRoZSBrZXkuICBBc1xuICAgIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGluY3JlYXNlcywgdGltaW5nLXdoZWVsIGVsZW1lbnRzIG1vdmUgZG93biBsZXZlbHMgdW50aWwgdGhleVxuICAgIHJlYWNoIGxldmVsIDAsIGFuZCB0aGVuIGFyZSBldmVudHVhbGx5IHJlbW92ZWQuICAqKVxubW9kdWxlIFByaW9yaXR5X3F1ZXVlIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICdhIHByaW9yaXR5X3F1ZXVlID0gJ2EgdFxuXG4gIG1vZHVsZSBLZXkgOiBJbnRlcnZhbF9udW1cblxuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgKCoqIEFuIFtFbHQudF0gcmVwcmVzZW50cyBhbiBlbGVtZW50IHRoYXQgd2FzIGFkZGVkIHRvIGEgdGltaW5nIHdoZWVsLiAqKVxuICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdmFsIGF0IDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiBUaW1lX25zLnRcbiAgICB2YWwga2V5IDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCB2YWx1ZSA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gJ2EgdFxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxfZWx0IDogc2lnXG4gICAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwga2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgbWF4X2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcbiAgICB2YWwgbWluX2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcbiAgICB2YWwgaXNfbnVsbCA6IF8gdCAtPiBib29sXG4gICAgdmFsIHRvX2V4dGVybmFsIDogJ2EgdCAtPiAnYSBFbHQudFxuICBlbmRcblxuICB2YWwgcG9vbCA6ICdhIHQgLT4gJ2EgSW50ZXJuYWxfZWx0LlBvb2wudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAoKiogW2NyZWF0ZSA/bGV2ZWxfYml0cyAoKV0gY3JlYXRlcyBhIG5ldyBlbXB0eSB0aW1pbmcgd2hlZWwsIFt0XSwgd2l0aCBbbGVuZ3RoIHQgPSAwXVxuICAgICAgYW5kIFttaW5fYWxsb3dlZF9rZXkgdCA9IDBdLiAqKVxuICB2YWwgY3JlYXRlIDogP2NhcGFjaXR5OmludCAtPiA/bGV2ZWxfYml0czpMZXZlbF9iaXRzLnQgLT4gdW5pdCAtPiAnYSB0XG5cbiAgKCoqIFtsZW5ndGggdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0aW1pbmcgd2hlZWwuICopXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5cbiAgKCoqIFttaW5fYWxsb3dlZF9rZXkgdF0gaXMgdGhlIG1pbmltdW0ga2V5IHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBbdF0uICBUaGlzIG9ubHlcbiAgICAgIGluZGljYXRlcyB0aGUgcG9zc2liaWxpdHk7IHRoZXJlIG5lZWQgbm90IGJlIGFuIGVsZW1lbnQgW2VsdF0gaW4gW3RdIHdpdGggW0VsdC5rZXlcbiAgICAgIGVsdCA9IG1pbl9hbGxvd2VkX2tleSB0XS4gIFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBcIm1pbl9rZXlcIiBvcGVyYXRpb24gaW4gYVxuICAgICAgdHlwaWNhbCBwcmlvcml0eSBxdWV1ZS5cblxuICAgICAgW21pbl9hbGxvd2VkX2tleSB0XSBjYW4gaW5jcmVhc2Ugb3ZlciB0aW1lLCB2aWEgY2FsbHMgdG9cbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldLiAqKVxuICB2YWwgbWluX2FsbG93ZWRfa2V5IDogXyB0IC0+IEtleS50XG5cbiAgKCoqIFttYXhfYWxsb3dlZF9rZXkgdF0gaXMgdGhlIG1heGltdW0gYWxsb3dlZCBrZXkgdGhhdCBjYW4gYmUgc3RvcmVkIGluIFt0XS4gIEFzXG4gICAgICBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMsIHNvIGRvZXMgW21heF9hbGxvd2VkX2tleV07IGhvd2V2ZXIgaXQgaXMgbm90IHRoZSBjYXNlXG4gICAgICB0aGF0IFttYXhfYWxsb3dlZF9rZXkgdCAtIG1pbl9hbGxvd2VkX2tleSB0XSBpcyBhIGNvbnN0YW50LiAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0XG4gICAgICBbbWF4X2FsbG93ZWRfa2V5IHQgPj0gbWluX2FsbG93ZWRfa2V5IHQgKyAyXkIgLSAxXSxcbiAgICAgIHdoZXJlIFtCXSBpcyB0aGUgc3VtIG9mIHRoZSBiX2kgaW4gW2xldmVsX2JpdHNdLiAqKVxuICB2YWwgbWF4X2FsbG93ZWRfa2V5IDogXyB0IC0+IEtleS50XG5cbiAgdmFsIG1pbl9lbHRfIDogJ2EgdCAtPiAnYSBJbnRlcm5hbF9lbHQudFxuICB2YWwgaW50ZXJuYWxfYWRkIDogJ2EgdCAtPiBrZXk6S2V5LnQgLT4gYXQ6VGltZV9ucy50IC0+ICdhIC0+ICdhIEludGVybmFsX2VsdC50XG5cbiAgKCoqIFtyZW1vdmUgdCBlbHRdIHJlbW92ZXMgW2VsdF0gZnJvbSBbdF0uICBJdCBpcyBhbiBlcnJvciBpZiBbZWx0XSBpcyBub3QgY3VycmVudGx5XG4gICAgICBpbiBbdF0sIGFuZCB0aGlzIGVycm9yIG1heSBvciBtYXkgbm90IGJlIGRldGVjdGVkLiAqKVxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiAnYSBFbHQudCAtPiB1bml0XG5cbiAgdmFsIGNoYW5nZSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4ga2V5OktleS50IC0+IGF0OlRpbWVfbnMudCAtPiB1bml0XG5cbiAgKCoqIFtjbGVhciB0XSByZW1vdmVzIGFsbCBlbHRzIGZyb20gW3RdLiAqKVxuICB2YWwgY2xlYXIgOiBfIHQgLT4gdW5pdFxuXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIEVsdC50IC0+IGJvb2xcblxuICBtb2R1bGUgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdCA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZFxuICBlbmRcblxuICAoKiogW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleSB0IH5rZXkgfmhhbmRsZV9yZW1vdmVkXSBpbmNyZWFzZXMgdGhlIG1pbmltdW0gYWxsb3dlZFxuICAgICAga2V5IGluIFt0XSB0byBba2V5XSwgYW5kIHJlbW92ZXMgYWxsIGVsZW1lbnRzIHdpdGgga2V5cyBsZXNzIHRoYW4gW2tleV0sIGFwcGx5aW5nXG4gICAgICBbaGFuZGxlX3JlbW92ZWRdIHRvIGVhY2ggZWxlbWVudCB0aGF0IGlzIHJlbW92ZWQuICBJZiBba2V5IDw9IG1pbl9hbGxvd2VkX2tleSB0XSxcbiAgICAgIHRoZW4gW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gZG9lcyBub3RoaW5nLiAgT3RoZXJ3aXNlLCBpZlxuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gcmV0dXJucyBzdWNjZXNzZnVsbHksIFttaW5fYWxsb3dlZF9rZXkgdCA9IGtleV0uXG5cbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIFtrZXkgLSBtaW5fYWxsb3dlZF9rZXkgdF0sXG4gICAgICBhbHRob3VnaCBwb3NzaWJseSBsZXNzIHRpbWUuXG5cbiAgICAgIEJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtoYW5kbGVfcmVtb3ZlZF0gYWNjZXNzZXMgW3RdIGluIGFueSB3YXkgb3RoZXIgdGhhblxuICAgICAgW0VsdF0gZnVuY3Rpb25zLiAqKVxuICB2YWwgaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XG4gICAgOiAgJ2EgdFxuICAgIC0+IGtleTpLZXkudFxuICAgIC0+IGhhbmRsZV9yZW1vdmVkOignYSBFbHQudCAtPiB1bml0KVxuICAgIC0+IEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQudFxuXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSBFbHQudCAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGZpcmVfcGFzdF9hbGFybXNcbiAgICA6ICAnYSB0XG4gICAgLT4gaGFuZGxlX2ZpcmVkOignYSBFbHQudCAtPiB1bml0KVxuICAgIC0+IGtleTpLZXkudFxuICAgIC0+IG5vdzpUaW1lX25zLnRcbiAgICAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgKCoqIEVhY2ggc2xvdCBpbiBhIGxldmVsIGlzIGEgKHBvc3NpYmx5IG51bGwpIHBvaW50ZXIgdG8gYSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgIG9mIGVsZW1lbnRzLiAgV2UgcG9vbCB0aGUgZWxlbWVudHMgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlbSBhZnRlciB0aGV5IGFyZSByZW1vdmVkXG4gICAgICBmcm9tIHRoZSB0aW1pbmcgd2hlZWwgKGVpdGhlciB2aWEgW3JlbW92ZV0gb3IgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0pLiAgSW5cbiAgICAgIGFkZGl0aW9uIHRvIHN0b3JpbmcgdGhlIFtrZXldLCBbYXRdLCBhbmQgW3ZhbHVlXSBpbiB0aGUgZWxlbWVudCwgd2Ugc3RvcmUgdGhlXG4gICAgICBbbGV2ZWxfaW5kZXhdIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgZ2V0IHRvIHRoZSBsZXZlbCBob2xkaW5nIGFuIGVsZW1lbnQgd2hlbiB3ZVxuICAgICAgW3JlbW92ZV0gaXQuXG5cbiAgICAgIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gW0V4dGVybmFsX2VsdF0gYW5kIFtJbnRlcm5hbF9lbHRdLCB3aGljaCBhcmUgdGhlIHNhbWVcbiAgICAgIHVuZGVybmVhdGguICBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgYW4gW0ludGVybmFsX2VsdF0gaXMgZWl0aGVyIFtudWxsXSBvciBhXG4gICAgICB2YWxpZCBwb2ludGVyLiAgT24gdGhlIG90aGVyIGhhbmQsIFtFeHRlcm5hbF9lbHRdcyBhcmUgcmV0dXJuZWQgdG8gdXNlciBjb2RlLCBzb1xuICAgICAgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHZhbGlkaXR5IC0tIHdlIGFsd2F5cyB2YWxpZGF0ZSBhbiBbRXh0ZXJuYWxfZWx0XSBiZWZvcmVcbiAgICAgIGRvaW5nIGFueXRoaW5nIHdpdGggaXQuXG5cbiAgICAgIEl0IGlzIHRoZXJlZm9yZSBPSyB0byB1c2UgW1Bvb2wuVW5zYWZlXSwgYmVjYXVzZSB3ZSB3aWxsIG5ldmVyIGF0dGVtcHQgdG8gYWNjZXNzIGFcbiAgICAgIHNsb3Qgb2YgYW4gaW52YWxpZCBwb2ludGVyLiAqKVxuICBtb2R1bGUgUG9vbCA9IFBvb2wuVW5zYWZlXG5cbiAgbW9kdWxlIFBvaW50ZXIgPSBQb29sLlBvaW50ZXJcblxuICBtb2R1bGUgS2V5IDogc2lnXG4gICAgKCoqIFtJbnRlcnZhbF9udW1dIGlzIHRoZSBwdWJsaWMgQVBJLiAgRXZlcnl0aGluZyBmb2xsb3dpbmcgaW4gdGhlIHNpZ25hdHVyZSBpc1xuICAgICAgICBmb3IgaW50ZXJuYWwgdXNlLiAqKVxuICAgIGluY2x1ZGUgVGltaW5nX3doZWVsX2ludGYuSW50ZXJ2YWxfbnVtXG5cbiAgICAoKiogW2FkZF9jbGFtcF90b19tYXhdIGRvZXNuJ3Qgd29yayBhdCBhbGwgd2l0aCBuZWdhdGl2ZSBzcGFucyAqKVxuICAgIHZhbCBhZGRfY2xhbXBfdG9fbWF4IDogdCAtPiBTcGFuLnQgLT4gdFxuXG4gICAgdmFsIHN1Y2NfY2xhbXBfdG9fbWF4IDogdCAtPiB0XG5cbiAgICAoKiogW1Nsb3RzX21hc2tdIGlzIHVzZWQgdG8gcXVpY2tseSBkZXRlcm1pbmUgYSBrZXkncyBzbG90IGluIGEgZ2l2ZW4gbGV2ZWwuICopXG4gICAgbW9kdWxlIFNsb3RzX21hc2sgOiBzaWdcbiAgICAgIHR5cGUgdCA9IHByaXZhdGUgSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICB2YWwgY3JlYXRlIDogbGV2ZWxfYml0czpOdW1fa2V5X2JpdHMudCAtPiB0XG4gICAgICB2YWwgbmV4dF9zbG90IDogdCAtPiBpbnQgLT4gaW50XG4gICAgZW5kXG5cbiAgICAoKiogW01pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tdIGlzIHVzZWQgdG8gcXVpY2tseSBkZXRlcm1pbmUgdGhlIG1pbmltdW0ga2V5IGluIHRoZVxuICAgICAgICBzYW1lIHNsb3QgYXMgYSBnaXZlbiBrZXkuICopXG4gICAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgOiBzaWdcbiAgICAgIHR5cGUgdCA9IHByaXZhdGUgSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgICB2YWwgY3JlYXRlIDogYml0c19wZXJfc2xvdDpOdW1fa2V5X2JpdHMudCAtPiB0XG4gICAgZW5kXG5cbiAgICB2YWwgbnVtX2tleXMgOiBOdW1fa2V5X2JpdHMudCAtPiBTcGFuLnRcbiAgICB2YWwgbWluX2tleV9pbl9zYW1lX3Nsb3QgOiB0IC0+IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sudCAtPiB0XG4gICAgdmFsIHNsb3QgOiB0IC0+IGJpdHNfcGVyX3Nsb3Q6TnVtX2tleV9iaXRzLnQgLT4gc2xvdHNfbWFzazpTbG90c19tYXNrLnQgLT4gaW50XG4gIGVuZCA9IHN0cnVjdFxuICAgIG1vZHVsZSBTbG90c19tYXNrID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIGxldCBjcmVhdGUgfmxldmVsX2JpdHMgPSBJbnQ2My4oIC0gKSAoTnVtX2tleV9iaXRzLnBvdzIgbGV2ZWxfYml0cykgSW50NjMub25lXG4gICAgICBsZXQgbmV4dF9zbG90IHQgc2xvdCA9IChzbG90ICsgMSkgbGFuZCBJbnQ2My50b19pbnRfZXhuIHRcbiAgICBlbmRcblxuICAgIGxldCBudW1fa2V5cyBudW1fYml0cyA9IE51bV9rZXlfYml0cy5wb3cyIG51bV9iaXRzXG5cbiAgICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgY3JlYXRlIH5iaXRzX3Blcl9zbG90ID0gYml0X25vdCAoTnVtX2tleV9iaXRzLnBvdzIgYml0c19wZXJfc2xvdCAtIG9uZSlcbiAgICBlbmRcblxuICAgIG1vZHVsZSBTcGFuID0gc3RydWN0XG4gICAgICBpbmNsdWRlIEludDYzXG5cbiAgICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgICAgbGV0IG9mX2ludDYzIGkgPSBpXG4gICAgICBsZXQgc2NhbGVfaW50IHQgaSA9IHQgKiBvZl9pbnQgaVxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgbGV0IG9mX2ludDYzIGkgPSBpXG4gICAgbGV0IHRvX2ludDYzIHQgPSB0XG4gICAgbGV0IGFkZCB0IGkgPSB0ICsgaVxuICAgIGxldCBhZGRfY2xhbXBfdG9fbWF4IHQgaSA9IGlmIHQgPiBtYXhfdmFsdWUgLSBpIHRoZW4gbWF4X3ZhbHVlIGVsc2UgdCArIGlcbiAgICBsZXQgc3VjY19jbGFtcF90b19tYXggdCA9IGlmIHQgPSBtYXhfdmFsdWUgdGhlbiBtYXhfdmFsdWUgZWxzZSBzdWNjIHRcbiAgICBsZXQgc3ViIHQgaSA9IHQgLSBpXG4gICAgbGV0IGRpZmYgdDEgdDIgPSB0MSAtIHQyXG5cbiAgICBsZXQgc2xvdCB0IH4oYml0c19wZXJfc2xvdCA6IE51bV9rZXlfYml0cy50KSB+c2xvdHNfbWFzayA9XG4gICAgICB0b19pbnRfZXhuIChiaXRfYW5kIChzaGlmdF9yaWdodCB0IChiaXRzX3Blcl9zbG90IDo+IGludCkpIHNsb3RzX21hc2spXG4gICAgOztcblxuICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPVxuICAgICAgYml0X2FuZCB0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9IEtleS5NaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gIG1vZHVsZSBTbG90c19tYXNrID0gS2V5LlNsb3RzX21hc2tcblxuICBtb2R1bGUgRXh0ZXJuYWxfZWx0ID0gc3RydWN0XG5cbiAgICAoKiogVGhlIFtwb29sX3Nsb3RzXSBoZXJlIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggdGhlIHNsb3RzIGluIGEgbGV2ZWwgYXJyYXkuICBUaGlzIGlzXG4gICAgICAgIGZvciB0aGUgc2xvdHMgaW4gdGhlIHBvb2wgdHVwbGUgcmVwcmVzZW50aW5nIGEgbGV2ZWwgZWxlbWVudC4gKilcbiAgICB0eXBlICdhIHBvb2xfc2xvdHMgPVxuICAgICAgKCBLZXkudFxuICAgICAgLCBUaW1lX25zLnRcbiAgICAgICwgJ2FcbiAgICAgICwgaW50XG4gICAgICAsICdhIHBvb2xfc2xvdHMgUG9pbnRlci50XG4gICAgICAsICdhIHBvb2xfc2xvdHMgUG9pbnRlci50IClcbiAgICAgICAgUG9vbC5TbG90cy50NlxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB0eXBlICdhIHQgPSAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IG51bGwgPSBQb2ludGVyLm51bGxcbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsX2VsdCA6IHNpZ1xuICAgIG1vZHVsZSBQb29sIDogc2lnXG4gICAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBJbnZhcmlhbnQuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgY3JlYXRlIDogP2NhcGFjaXR5OmludCAtPiB1bml0IC0+IF8gdFxuICAgICAgdmFsIGlzX2Z1bGwgOiBfIHQgLT4gYm9vbFxuICAgICAgdmFsIGdyb3cgOiA/Y2FwYWNpdHk6aW50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gcHJpdmF0ZSAnYSBFeHRlcm5hbF9lbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdmFsIG51bGwgOiB1bml0IC0+IF8gdFxuICAgIHZhbCBpc19udWxsIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfdmFsaWQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBib29sXG5cbiAgICAoKiogRGVhbGluZyB3aXRoIFtFeHRlcm5hbF9lbHRdcy4gKilcblxuICAgIHZhbCBleHRlcm5hbF9pc192YWxpZCA6ICdhIFBvb2wudCAtPiAnYSBFeHRlcm5hbF9lbHQudCAtPiBib29sXG4gICAgdmFsIHRvX2V4dGVybmFsIDogJ2EgdCAtPiAnYSBFeHRlcm5hbF9lbHQudFxuICAgIHZhbCBvZl9leHRlcm5hbF9leG4gOiAnYSBQb29sLnQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnQgLT4gJ2EgdFxuICAgIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGludmFyaWFudCA6ICdhIFBvb2wudCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogW2NyZWF0ZV0gcmV0dXJucyBhbiBlbGVtZW50IHdob3NlIFtuZXh0XSBhbmQgW3ByZXZdIGFyZSBbbnVsbF0uICopXG4gICAgdmFsIGNyZWF0ZVxuICAgICAgOiAgJ2EgUG9vbC50XG4gICAgICAtPiBrZXk6S2V5LnRcbiAgICAgICgqKiBbYXRdIGlzIHVzZWQgd2hlbiB0aGUgcHJpb3JpdHkgcXVldWUgaXMgdXNlZCB0byBpbXBsZW1lbnQgYSB0aW1pbmcgd2hlZWwuICBJZlxuICAgICAgICAgIHVudXNlZCwgaXQgd2lsbCBiZSBbVGltZV9ucy5lcG9jaF0uICopXG4gICAgICAtPiBhdDpUaW1lX25zLnRcbiAgICAgIC0+IHZhbHVlOidhXG4gICAgICAtPiBsZXZlbF9pbmRleDppbnRcbiAgICAgIC0+ICdhIHRcblxuICAgIHZhbCBmcmVlIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdW5pdFxuXG4gICAgKCoqIGFjY2Vzc29ycyAqKVxuXG4gICAgdmFsIGtleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIGF0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gVGltZV9ucy50XG4gICAgdmFsIGxldmVsX2luZGV4IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIG5leHQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHZhbHVlIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gJ2FcblxuICAgICgqKiBtdXRhdG9ycyAqKVxuXG4gICAgdmFsIHNldF9rZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudCAtPiB1bml0XG4gICAgdmFsIHNldF9hdCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IFRpbWVfbnMudCAtPiB1bml0XG4gICAgdmFsIHNldF9sZXZlbF9pbmRleCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGludCAtPiB1bml0XG5cbiAgICAoKiogW2luc2VydF9hdF9lbmQgcG9vbCB0IH50b19hZGRdIHRyZWF0cyBbdF0gYXMgdGhlIGhlYWQgb2YgdGhlIGxpc3QgYW5kIGFkZHMgW3RvX2FkZF1cbiAgICAgICAgdG8gdGhlIGVuZCBvZiBpdC4gKilcbiAgICB2YWwgaW5zZXJ0X2F0X2VuZCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHRvX2FkZDonYSB0IC0+IHVuaXRcblxuICAgICgqKiBbbGlua190b19zZWxmIHBvb2wgdF0gbWFrZXMgW3RdIGJlIGEgc2luZ2xldG9uIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdC4gKilcbiAgICB2YWwgbGlua190b19zZWxmIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFt1bmxpbmsgcCB0XSB1bmxpbmtzIFt0XSBmcm9tIHRoZSBjaXJjdWxhcmx5IGRvdWJseS1saW5rZWQgbGlzdCB0aGF0IGl0IGlzIGluLiAgSXRcbiAgICAgICAgY2hhbmdlcyB0aGUgcG9pbnRlcnMgb2YgW3RdJ3MgW3ByZXZdIGFuZCBbbmV4dF0gZWx0cywgYnV0IG5vdCBbdF0ncyBbcHJldl0gYW5kXG4gICAgICAgIFtuZXh0XSBwb2ludGVycy4gIFt1bmxpbmtdIGlzIG1lYW5pbmdsZXNzIGlmIFt0XSBpcyBhIHNpbmdsZXRvbi4gKilcbiAgICB2YWwgdW5saW5rIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdW5pdFxuXG4gICAgKCoqIEl0ZXJhdG9ycy4gIFtpdGVyIHAgdCB+aW5pdCB+Zl0gdmlzaXRzIGVhY2ggZWxlbWVudCBpbiB0aGUgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICAgIGNvbnRhaW5pbmcgW3RdLCBzdGFydGluZyBhdCBbdF0sIGFuZCBmb2xsb3dpbmcgW25leHRdIHBvaW50ZXJzLiAgW2xlbmd0aF0gY291bnRzXG4gICAgICAgIGJ5IHZpc2l0aW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgbGlzdC4gKilcbiAgICB2YWwgaXRlciA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGY6KCdhIHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICAgdmFsIGxlbmd0aCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGludFxuXG4gICAgKCoqIFttYXhfYWxhcm1fdGltZSB0IGVsdCB+d2l0aF9rZXldIGZpbmRzIHRoZSBtYXggW2F0XSBpbiBbZWx0XSdzIGxpc3QgYW1vbmcgdGhlIGVsdHNcbiAgICAgICAgd2hvc2Uga2V5IGlzIFt3aXRoX2tleV0sIHJldHVybmluZyBbVGltZV9ucy5lcG9jaF0gaWYgdGhlIGxpc3QgaXMgZW1wdHkuICopXG4gICAgdmFsIG1heF9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG5cbiAgICB2YWwgbWluX2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSAnYSBwb29sX3Nsb3RzID0gJ2EgRXh0ZXJuYWxfZWx0LnBvb2xfc2xvdHMgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICB0eXBlICdhIHQgPSAnYSBFeHRlcm5hbF9lbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IG51bGwgPSBQb2ludGVyLm51bGxcbiAgICBsZXQgaXNfbnVsbCA9IFBvaW50ZXIuaXNfbnVsbFxuICAgIGxldCBlcXVhbCB0MSB0MiA9IFBvaW50ZXIucGh5c19lcXVhbCB0MSB0MlxuXG4gICAgbGV0IGNyZWF0ZSBwb29sIH5rZXkgfmF0IH52YWx1ZSB+bGV2ZWxfaW5kZXggPVxuICAgICAgUG9vbC5uZXc2IHBvb2wga2V5IGF0IHZhbHVlIGxldmVsX2luZGV4IChudWxsICgpKSAobnVsbCAoKSlcbiAgICA7O1xuXG4gICAgbGV0IGZyZWUgPSBQb29sLmZyZWVcbiAgICBsZXQga2V5IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDBcbiAgICBsZXQgc2V0X2tleSBwIHQgayA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDAga1xuICAgIGxldCBhdCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQxXG4gICAgbGV0IHNldF9hdCBwIHQgeCA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDEgeFxuICAgIGxldCB2YWx1ZSBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQyXG4gICAgbGV0IGxldmVsX2luZGV4IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDNcbiAgICBsZXQgc2V0X2xldmVsX2luZGV4IHAgdCBpID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MyBpXG4gICAgbGV0IHByZXYgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50NFxuICAgIGxldCBzZXRfcHJldiBwIHQgeCA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDQgeFxuICAgIGxldCBuZXh0IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDVcbiAgICBsZXQgc2V0X25leHQgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQ1IHhcbiAgICBsZXQgaXNfdmFsaWQgcCB0ID0gUG9vbC5wb2ludGVyX2lzX3ZhbGlkIHAgdFxuICAgIGxldCBleHRlcm5hbF9pc192YWxpZCA9IGlzX3ZhbGlkXG5cbiAgICBsZXQgaW52YXJpYW50IHBvb2wgaW52YXJpYW50X2EgdCA9XG4gICAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgICBhc3NlcnQgKGlzX3ZhbGlkIHBvb2wgdCk7XG4gICAgICAgIGludmFyaWFudF9hICh2YWx1ZSBwb29sIHQpO1xuICAgICAgICBsZXQgbiA9IG5leHQgcG9vbCB0IGluXG4gICAgICAgIGFzc2VydCAoaXNfbnVsbCBuIHx8IFBvaW50ZXIucGh5c19lcXVhbCB0IChwcmV2IHBvb2wgbikpO1xuICAgICAgICBsZXQgcCA9IHByZXYgcG9vbCB0IGluXG4gICAgICAgIGFzc2VydCAoaXNfbnVsbCBwIHx8IFBvaW50ZXIucGh5c19lcXVhbCB0IChuZXh0IHBvb2wgcCkpKVxuICAgIDs7XG5cbiAgICBtb2R1bGUgUG9vbCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcG9vbF9zbG90cyBQb29sLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICAgbGV0IGludmFyaWFudCBfaW52YXJpYW50X2EgdCA9IFBvb2wuaW52YXJpYW50IGlnbm9yZSB0XG4gICAgICBsZXQgY3JlYXRlID8oY2FwYWNpdHkgPSAxKSAoKSA9IFBvb2wuY3JlYXRlIFBvb2wuU2xvdHMudDYgfmNhcGFjaXR5XG4gICAgICBsZXQgZ3JvdyA9IFBvb2wuZ3Jvd1xuICAgICAgbGV0IGlzX2Z1bGwgPSBQb29sLmlzX2Z1bGxcbiAgICBlbmRcblxuICAgIGxldCB0b19leHRlcm5hbCB0ID0gdFxuXG4gICAgbGV0IG9mX2V4dGVybmFsX2V4biBwb29sIHQgPVxuICAgICAgaWYgaXNfdmFsaWQgcG9vbCB0IHRoZW4gdCBlbHNlIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltaW5nX3doZWVsIGdvdCBpbnZhbGlkIGFsYXJtXCJdXG4gICAgOztcblxuICAgIGxldCB1bmxpbmsgcG9vbCB0ID1cbiAgICAgIHNldF9uZXh0IHBvb2wgKHByZXYgcG9vbCB0KSAobmV4dCBwb29sIHQpO1xuICAgICAgc2V0X3ByZXYgcG9vbCAobmV4dCBwb29sIHQpIChwcmV2IHBvb2wgdClcbiAgICA7O1xuXG4gICAgbGV0IGxpbmsgcG9vbCBwcmV2IG5leHQgPVxuICAgICAgc2V0X25leHQgcG9vbCBwcmV2IG5leHQ7XG4gICAgICBzZXRfcHJldiBwb29sIG5leHQgcHJldlxuICAgIDs7XG5cbiAgICBsZXQgbGlua190b19zZWxmIHBvb2wgdCA9IGxpbmsgcG9vbCB0IHRcblxuICAgIGxldCBpbnNlcnRfYXRfZW5kIHBvb2wgdCB+dG9fYWRkID1cbiAgICAgIGxldCBwcmV2ID0gcHJldiBwb29sIHQgaW5cbiAgICAgIGxpbmsgcG9vbCBwcmV2IHRvX2FkZDtcbiAgICAgIGxpbmsgcG9vbCB0b19hZGQgdFxuICAgIDs7XG5cbiAgICBsZXQgaXRlciBwb29sIGZpcnN0IH5mID1cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgICgqIFdlIGdldCBbbmV4dF0gYmVmb3JlIGNhbGxpbmcgW2ZdIHNvIHRoYXQgW2ZdIGNhbiBtb2RpZnkgb3IgW2ZyZWVdIFshY3VycmVudF0uICopXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgIGYgIWN1cnJlbnQ7XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lXG4gICAgOztcblxuICAgIGxldCBsZW5ndGggcG9vbCBmaXJzdCA9XG4gICAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICBpbmNyIHI7XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lO1xuICAgICAgIXJcbiAgICA7O1xuXG4gICAgbGV0IG1heF9hbGFybV90aW1lIHBvb2wgZmlyc3QgfndpdGhfa2V5ID1cbiAgICAgIGxldCBtYXhfYWxhcm1fdGltZSA9IHJlZiBUaW1lX25zLmVwb2NoIGluXG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBpZiBLZXkuZXF1YWwgKGtleSBwb29sICFjdXJyZW50KSB3aXRoX2tleVxuICAgICAgICB0aGVuIG1heF9hbGFybV90aW1lIDo9IFRpbWVfbnMubWF4IChhdCBwb29sICFjdXJyZW50KSAhbWF4X2FsYXJtX3RpbWU7XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lO1xuICAgICAgIW1heF9hbGFybV90aW1lXG4gICAgOztcblxuICAgIGxldCBtaW5fYWxhcm1fdGltZSBwb29sIGZpcnN0IH53aXRoX2tleSA9XG4gICAgICBsZXQgbWluX2FsYXJtX3RpbWUgPSByZWYgVGltZV9ucy5tYXhfdmFsdWVfcmVwcmVzZW50YWJsZSBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgKCogVGhlIFtrZXldIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGZvciBbbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsXSBiZWNhdXNlXG4gICAgICAgICAgIG1heCB0aW1lIHBlciBpbnRlcnZhbCBpcyBub3QgdGhlIHNhbWUgYXMgbWF4IHRpbWUgZ2xvYmFsbHkuXG5cbiAgICAgICAgICAgVGhpcyBpcyBub3Qgc28gZm9yIFttaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxdLCBzbyB0aGlzIGNhbiBwb3RlbnRpYWxseVxuICAgICAgICAgICBiZSBzaW1wbGlmaWVkLlxuXG4gICAgICAgICAgIFByb2JhYmx5IGEgYmV0dGVyIGNoYW5nZSB3b3VsZCBiZSB0byBzaW1wbHkgdHJhbnNmZXIgdGhlIGV2ZW50cyB0byB0aGVcbiAgICAgICAgICAgXCJmaXJlZFwiIGNvbGxlY3Rpb24gKGFuZCByZW5hbWUgaXQgdG8gXCJhYm91dCB0byBmaXJlXCIpLCB3aGljaCBpcyBzb3J0ZWQgYnkgdGltZSxcbiAgICAgICAgICAgc28gZ2V0dGluZyB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoYXQgY29sbGVjdGlvbiBpcyBlZmZpY2llbnQuXG4gICAgICAgICopXG4gICAgICAgIGlmIEtleS5lcXVhbCAoa2V5IHBvb2wgIWN1cnJlbnQpIHdpdGhfa2V5XG4gICAgICAgIHRoZW4gbWluX2FsYXJtX3RpbWUgOj0gVGltZV9ucy5taW4gKGF0IHBvb2wgIWN1cnJlbnQpICFtaW5fYWxhcm1fdGltZTtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhbWluX2FsYXJtX3RpbWVcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgTGV2ZWwgPSBzdHJ1Y3RcbiAgICAoKiogRm9yIGdpdmVuIGxldmVsLCBvbmUgY2FuIGJyZWFrIHRoZSBiaXRzIGludG8gYSBrZXkgaW50byB0aHJlZSByZWdpb25zOlxuXG4gICAgICAgIHt2XG4gICAgICAgICB8IGhpZ2hlciBsZXZlbHMgfCB0aGlzIGxldmVsIHwgbG93ZXIgbGV2ZWxzIHxcbiAgICAgICAgdn1cblxuICAgICAgICBcIkxvd2VyIGxldmVsc1wiIGlzIFtiaXRzX3Blcl9zbG90XSBiaXRzIHdpZGUuICBcIlRoaXMgbGV2ZWxcIiBpcyBbYml0c10gd2lkZS4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyAoKiBUaGUgW2luZGV4XSBpbiB0aGUgdGltaW5nIHdoZWVsJ3MgYXJyYXkgb2YgbGV2ZWxzIHdoZXJlIHRoaXMgbGV2ZWwgaXMuICopXG4gICAgICAgIGluZGV4IDogaW50XG4gICAgICA7ICgqIEhvdyBtYW55IFtiaXRzXSB0aGlzIGxldmVsIGlzIHJlc3BvbnNpYmxlIGZvci4gKilcbiAgICAgICAgYml0cyA6IE51bV9rZXlfYml0cy50XG4gICAgICA7ICgqIFtzbG90c19tYXNrID0gU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHM6dC5iaXRzXS4gKilcbiAgICAgICAgc2xvdHNfbWFzayA6IFNsb3RzX21hc2sudFxuICAgICAgOyAoKiBbYml0c19wZXJfc2xvdF0gaXMgaG93IG1hbnkgYml0cyBlYWNoIHNsb3QgZGlzdGluZ3Vpc2hlcywgYW5kIGlzIHRoZSBzdW0gb2Ygb2ZcbiAgICAgICAgICAgdGhlIFtiaXRzXSBvZiBhbGwgdGhlIGxvd2VyIGxldmVscy4gKilcbiAgICAgICAgYml0c19wZXJfc2xvdCA6IE51bV9rZXlfYml0cy50XG4gICAgICA7IGtleXNfcGVyX3Nsb3QgOiBLZXkuU3Bhbi50XG4gICAgICA7IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgOiBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLnRcbiAgICAgIDsgKCogW2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA9IGtleXNfcGVyX3Nsb3QgKiBBcnJheS5sZW5ndGggc2xvdHMgLSAxXSAqKVxuICAgICAgICBkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgOiBLZXkuU3Bhbi50XG4gICAgICA7ICgqIFtsZW5ndGhdIGlzIHRoZSBudW1iZXIgb2YgZWx0cyBjdXJyZW50bHkgaW4gdGhpcyBsZXZlbC4gKilcbiAgICAgICAgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICAgIDsgKCogQWxsIGVsZW1lbnRzIGF0IHRoaXMgbGV2ZWwgaGF2ZSB0aGVpciBba2V5XSBzYXRpc2Z5IFttaW5fYWxsb3dlZF9rZXkgPD0ga2V5IDw9XG4gICAgICAgICAgIG1heF9hbGxvd2VkX2tleV0uICBBbHNvLCBbbWluX2FsbG93ZWRfa2V5XSBpcyBhIG11bHRpcGxlIG9mIFtrZXlzX3Blcl9zbG90XS4gKilcbiAgICAgICAgbXV0YWJsZSBtaW5fYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyBtdXRhYmxlIG1heF9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7ICgqIFtzbG90c10gaG9sZHMgdGhlIChwb3NzaWJseSBudWxsKSBwb2ludGVycyB0byB0aGUgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0c1xuICAgICAgICAgICBvZiBlbHRzLiAgW0FycmF5Lmxlbmd0aCBzbG90cyA9IDEgbHNsIGJpdHNdLiAqKVxuICAgICAgICBzbG90cyA6ICgnYSBJbnRlcm5hbF9lbHQudCBhcnJheVtAc2V4cC5vcGFxdWVdKVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICAgIGxldCBzbG90IHQgfmtleSA9IEtleS5zbG90IGtleSB+Yml0c19wZXJfc2xvdDp0LmJpdHNfcGVyX3Nsb3QgfnNsb3RzX21hc2s6dC5zbG90c19tYXNrXG4gICAgbGV0IG5leHRfc2xvdCB0IHNsb3QgPSBTbG90c19tYXNrLm5leHRfc2xvdCB0LnNsb3RzX21hc2sgc2xvdFxuXG4gICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgfmtleSA9XG4gICAgICBLZXkubWluX2tleV9pbl9zYW1lX3Nsb3Qga2V5IHQubWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgIDs7XG5cbiAgICBsZXQgY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkgdCB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgPVxuICAgICAgKCogVGhpcyBjb21wdXRhdGlvbiBlbnN1cmVzIHRoYXQgW3RdJ3MgW21pbl9hbGxvd2VkX2tleV0gaXMgYXMgbGFyZ2UgYXMgcG9zc2libGVcbiAgICAgICAgIHN1YmplY3QgdG8gdGhlIGNvbnN0cmFpbnQgdGhhdCB0aGVyZSBpcyBubyBpbnRlci1sZXZlbCBnYXAuICopXG4gICAgICBpZiBLZXkuZXF1YWwgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgS2V5Lm1heF92YWx1ZVxuICAgICAgdGhlbiBLZXkubWF4X3ZhbHVlXG4gICAgICBlbHNlIG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgfmtleTooS2V5LnN1Y2MgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgOyBtdXRhYmxlIHBvb2wgOiAnYSBJbnRlcm5hbF9lbHQuUG9vbC50XG4gICAgOyAoKiBbbWluX2VsdF0gaXMgZWl0aGVyIG51bGwgb3IgYW4gZWxlbWVudCB3aG9zZSBrZXkgaXMgW2VsdF9rZXlfbG93ZXJfYm91bmRdLiAqKVxuICAgICAgbXV0YWJsZSBtaW5fZWx0IDogJ2EgSW50ZXJuYWxfZWx0LnRcbiAgICA7ICgqIEFsbCBlbGVtZW50cyBpbiB0aGUgcHJpb3JpdHkgcXVldWUgaGF2ZSB0aGVpciBrZXkgWz49IGVsdF9rZXlfbG93ZXJfYm91bmRdLiAqKVxuICAgICAgbXV0YWJsZSBlbHRfa2V5X2xvd2VyX2JvdW5kIDogS2V5LnRcbiAgICA7IGxldmVscyA6ICdhIExldmVsLnQgYXJyYXlcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICB0eXBlICdhIHByaW9yaXR5X3F1ZXVlID0gJ2EgdFxuXG4gIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBFeHRlcm5hbF9lbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IG51bGwgPSBFeHRlcm5hbF9lbHQubnVsbFxuICAgIGxldCBhdCBwIHQgPSBJbnRlcm5hbF9lbHQuYXQgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICAgIGxldCBrZXkgcCB0ID0gSW50ZXJuYWxfZWx0LmtleSBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gICAgbGV0IHZhbHVlIHAgdCA9IEludGVybmFsX2VsdC52YWx1ZSBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gIGVuZFxuXG4gIGxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbiAgbGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcbiAgbGV0IG51bV9sZXZlbHMgdCA9IEFycmF5Lmxlbmd0aCB0LmxldmVsc1xuICBsZXQgbWluX2FsbG93ZWRfa2V5IHQgPSBMZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5sZXZlbHMuKDApXG4gIGxldCBtYXhfYWxsb3dlZF9rZXkgdCA9IExldmVsLm1heF9hbGxvd2VkX2tleSB0LmxldmVscy4obnVtX2xldmVscyB0IC0gMSlcblxuICBsZXQgaW50ZXJuYWxfaXRlciB0IH5mID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGZvciBsZXZlbF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIGxldmVscyAtIDEgZG9cbiAgICAgICAgbGV0IGxldmVsID0gbGV2ZWxzLihsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgICAgIGZvciBzbG90X2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggc2xvdHMgLSAxIGRvXG4gICAgICAgICAgICBsZXQgZWx0ID0gc2xvdHMuKHNsb3RfaW5kZXgpIGluXG4gICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdCkgdGhlbiBJbnRlcm5hbF9lbHQuaXRlciBwb29sIGVsdCB+ZlxuICAgICAgICAgIGRvbmUpXG4gICAgICBkb25lKVxuICA7O1xuXG4gIGxldCBpdGVyIHQgfmYgPSBpbnRlcm5hbF9pdGVyIHQgfmY6KGYgOiBfIEVsdC50IC0+IHVuaXQgOj4gXyBJbnRlcm5hbF9lbHQudCAtPiB1bml0KVxuXG4gIG1vZHVsZSBQcmV0dHkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB7IGtleSA6IEtleS50XG4gICAgICAgIDsgdmFsdWUgOiAnYVxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbWluX2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgbWF4X2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgZWx0cyA6ICdhIEVsdC50IGxpc3RcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgcHJldHR5IHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgeyBQcmV0dHkubWluX2FsbG93ZWRfa2V5ID0gbWluX2FsbG93ZWRfa2V5IHRcbiAgICA7IG1heF9hbGxvd2VkX2tleSA9IG1heF9hbGxvd2VkX2tleSB0XG4gICAgOyBlbHRzID1cbiAgICAgICAgKGxldCByID0gcmVmIFtdIGluXG4gICAgICAgICBpbnRlcm5hbF9pdGVyIHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgclxuICAgICAgICAgICA6PSB7IFByZXR0eS5FbHQua2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdFxuICAgICAgICAgICAgICA7IHZhbHVlID0gSW50ZXJuYWxfZWx0LnZhbHVlIHBvb2wgZWx0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOjogIXIpO1xuICAgICAgICAgTGlzdC5yZXYgIXIpXG4gICAgfVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIG1hdGNoICFzZXhwX29mX3Rfc3R5bGUgd2l0aFxuICAgIHwgYEludGVybmFsIC0+IFslc2V4cCAodCA6IGEgdF9pbnRlcm5hbCldXG4gICAgfCBgUHJldHR5IC0+IFslc2V4cCAocHJldHR5IHQgOiBhIFByZXR0eS50KV1cbiAgOztcblxuICBsZXQgY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXkgfmxldmVsX2JpdHMgfmJpdHNfcGVyX3Nsb3QgPVxuICAgIGxldCBiaXRzID0gTnVtX2tleV9iaXRzLiggKyApIGxldmVsX2JpdHMgYml0c19wZXJfc2xvdCBpblxuICAgIGlmIE51bV9rZXlfYml0cy5lcXVhbCBiaXRzIE51bV9rZXlfYml0cy5tYXhfdmFsdWVcbiAgICB0aGVuIEtleS5TcGFuLm1heF92YWx1ZVxuICAgIGVsc2UgS2V5LlNwYW4ucHJlZCAoS2V5Lm51bV9rZXlzIGJpdHMpXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0IDogdW5pdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgbGV2ZWxfaW52YXJpYW50IGxldmVsID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSBsZXZlbCBbJXNleHBfb2Y6IF8gTGV2ZWwudF0gKGZ1biAoKSAtPlxuICAgICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCBsZXZlbCBmIGluXG4gICAgICAgIExldmVsLkZpZWxkcy5pdGVyXG4gICAgICAgICAgfmluZGV4OihjaGVjayAoZnVuIGluZGV4IC0+IGFzc2VydCAoaW5kZXggPj0gMCkpKVxuICAgICAgICAgIH5iaXRzOihjaGVjayAoZnVuIGJpdHMgLT4gYXNzZXJ0IChOdW1fa2V5X2JpdHMuKCA+ICkgYml0cyBOdW1fa2V5X2JpdHMuemVybykpKVxuICAgICAgICAgIH5zbG90c19tYXNrOlxuICAgICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgICAoWyV0ZXN0X3Jlc3VsdDogU2xvdHNfbWFzay50XVxuICAgICAgICAgICAgICAgICAgfmV4cGVjdDooU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHM6bGV2ZWwuYml0cykpKVxuICAgICAgICAgIH5iaXRzX3Blcl9zbG90OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gYml0c19wZXJfc2xvdCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChOdW1fa2V5X2JpdHMuKCA+PSApIGJpdHNfcGVyX3Nsb3QgTnVtX2tleV9iaXRzLnplcm8pKSlcbiAgICAgICAgICB+a2V5c19wZXJfc2xvdDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGtleXNfcGVyX3Nsb3QgLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgIGtleXNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDooS2V5Lm51bV9rZXlzIGxldmVsLmJpdHNfcGVyX3Nsb3QpKSlcbiAgICAgICAgICB+bWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzazpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suZXF1YWxcbiAgICAgICAgICAgICAgICAgICBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgICAgICAgICAgKE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6bGV2ZWwuYml0c19wZXJfc2xvdCkpKSlcbiAgICAgICAgICB+ZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgICAoWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgIChjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgICB+bGV2ZWxfYml0czpsZXZlbC5iaXRzXG4gICAgICAgICAgICAgICAgICAgICAgIH5iaXRzX3Blcl9zbG90OmxldmVsLmJpdHNfcGVyX3Nsb3QpKSlcbiAgICAgICAgICB+bGVuZ3RoOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbGVuZ3RoIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgICAgICAgICAgPSBBcnJheS5mb2xkIGxldmVsLnNsb3RzIH5pbml0OjAgfmY6KGZ1biBuIGVsdCAtPlxuICAgICAgICAgICAgICAgICAgIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICAgICAgICAgICAgICAgICAgIHRoZW4gblxuICAgICAgICAgICAgICAgICAgIGVsc2UgbiArIEludGVybmFsX2VsdC5sZW5ndGggcG9vbCBlbHQpKSkpXG4gICAgICAgICAgfm1pbl9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1pbl9hbGxvd2VkX2tleSAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIG1pbl9hbGxvd2VkX2tleSBLZXkuemVybyk7XG4gICAgICAgICAgICAgICBpZiBLZXkuKCA8ICkgbWluX2FsbG93ZWRfa2V5IEtleS5tYXhfdmFsdWVcbiAgICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgICAoS2V5LnJlbSBtaW5fYWxsb3dlZF9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdClcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OktleS5TcGFuLnplcm8pKVxuICAgICAgICAgIH5tYXhfYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtYXhfYWxsb3dlZF9rZXkgLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS50XVxuICAgICAgICAgICAgICAgICBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAoS2V5LmFkZF9jbGFtcF90b19tYXhcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXkpKSlcbiAgICAgICAgICB+c2xvdHM6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBzbG90cyAtPlxuICAgICAgICAgICAgICAgQXJyYXkuaXRlciBzbG90cyB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdClcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmludmFyaWFudCBwb29sIGludmFyaWFudF9hIGVsdDtcbiAgICAgICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXRlciBwb29sIGVsdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgICAgICAgS2V5LiggPj0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICAgICAgICBLZXkuKCA8PSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubWF4X2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgICAgICAgIEtleS4oID49IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChJbnRlcm5hbF9lbHQubGV2ZWxfaW5kZXggcG9vbCBlbHQgPSBsZXZlbC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICBpbnZhcmlhbnRfYSAoSW50ZXJuYWxfZWx0LnZhbHVlIHBvb2wgZWx0KSkpKSkpKVxuICAgIGluXG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRfaW50ZXJuYWxdIChmdW4gKCkgLT5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChtaW5fYWxsb3dlZF9rZXkgdCkgS2V5Lnplcm8pO1xuICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChtYXhfYWxsb3dlZF9rZXkgdCkgKG1pbl9hbGxvd2VkX2tleSB0KSk7XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+bGVuZ3RoOihjaGVjayAoZnVuIGxlbmd0aCAtPiBhc3NlcnQgKGxlbmd0aCA+PSAwKSkpXG4gICAgICAgIH5wb29sOihjaGVjayAoSW50ZXJuYWxfZWx0LlBvb2wuaW52YXJpYW50IGlnbm9yZSkpXG4gICAgICAgIH5taW5fZWx0OlxuICAgICAgICAgIChjaGVjayAoZnVuIGVsdF8gLT5cbiAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdF8pXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICBhc3NlcnQgKEludGVybmFsX2VsdC5pc192YWxpZCB0LnBvb2wgZWx0Xyk7XG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS5lcXVhbCB0LmVsdF9rZXlfbG93ZXJfYm91bmQgKEludGVybmFsX2VsdC5rZXkgdC5wb29sIGVsdF8pKSkpKVxuICAgICAgICB+ZWx0X2tleV9sb3dlcl9ib3VuZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBlbHRfa2V5X2xvd2VyX2JvdW5kIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIGVsdF9rZXlfbG93ZXJfYm91bmQgKG1pbl9hbGxvd2VkX2tleSB0KSk7XG4gICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA8PSApIGVsdF9rZXlfbG93ZXJfYm91bmQgKG1heF9hbGxvd2VkX2tleSB0KSk7XG4gICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCB0Lm1pbl9lbHQpXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgS2V5LmVxdWFsIGVsdF9rZXlfbG93ZXJfYm91bmQgKEludGVybmFsX2VsdC5rZXkgdC5wb29sIHQubWluX2VsdCkpKSlcbiAgICAgICAgfmxldmVsczpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBsZXZlbHMgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKG51bV9sZXZlbHMgdCA+IDApO1xuICAgICAgICAgICAgIEFycmF5Lml0ZXJpIGxldmVscyB+ZjooZnVuIGxldmVsX2luZGV4IGxldmVsIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKGxldmVsX2luZGV4ID0gTGV2ZWwuaW5kZXggbGV2ZWwpO1xuICAgICAgICAgICAgICAgbGV2ZWxfaW52YXJpYW50IGxldmVsO1xuICAgICAgICAgICAgICAgaWYgbGV2ZWxfaW5kZXggPiAwXG4gICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgbGV0IHByZXZfbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4IC0gMSkgaW5cbiAgICAgICAgICAgICAgICAgbGV0IG1vZHVsZSBMID0gTGV2ZWwgaW5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgICAoTC5rZXlzX3Blcl9zbG90IGxldmVsKVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6KEtleS5TcGFuLnN1Y2MgcHJldl9sZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkudF1cbiAgICAgICAgICAgICAgICAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgICAgKExldmVsLmNvbXB1dGVfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5OnByZXZfbGV2ZWwubWF4X2FsbG93ZWRfa2V5KSkpKSkpXG4gIDs7XG5cbiAgKCoqIFttaW5fZWx0X10gcmV0dXJucyBbbnVsbF0gaWYgaXQgY2FuJ3QgZmluZCB0aGUgZGVzaXJlZCBlbGVtZW50LiAgV2Ugd3JhcCBpdCB1cFxuICAgICAgYWZ0ZXJ3YXJkcyB0byByZXR1cm4gYW4gW29wdGlvbl0uICopXG4gIGxldCBtaW5fZWx0XyB0ID1cbiAgICBpZiBpc19lbXB0eSB0XG4gICAgdGhlbiBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIGVsc2UgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCB0Lm1pbl9lbHQpXG4gICAgdGhlbiB0Lm1pbl9lbHRcbiAgICBlbHNlIChcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgbWluX2VsdF9hbHJlYWR5X2ZvdW5kID0gcmVmIChJbnRlcm5hbF9lbHQubnVsbCAoKSkgaW5cbiAgICAgIGxldCBtaW5fa2V5X2FscmVhZHlfZm91bmQgPSByZWYgS2V5Lm1heF92YWx1ZSBpblxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIGxldCBudW1fbGV2ZWxzID0gbnVtX2xldmVscyB0IGluXG4gICAgICB3aGlsZSAhbGV2ZWxfaW5kZXggPCBudW1fbGV2ZWxzIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLighbGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIEtleS4oID4gKSAoTGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsKSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIGFueSBtb3JlIGxldmVscy4gIFF1aXQgdGhlIGxvb3AuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gbnVtX2xldmVsc1xuICAgICAgICBlbHNlIGlmIGxldmVsLmxlbmd0aCA9IDBcbiAgICAgICAgdGhlbiBpbmNyIGxldmVsX2luZGV4XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIExvb2sgaW4gW2xldmVsXS4gKilcbiAgICAgICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgICAgIGxldCBzbG90X21pbl9rZXkgPVxuICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgIChMZXZlbC5taW5fa2V5X2luX3NhbWVfc2xvdFxuICAgICAgICAgICAgICAgICBsZXZlbFxuICAgICAgICAgICAgICAgICB+a2V5OihLZXkubWF4IGxldmVsLm1pbl9hbGxvd2VkX2tleSB0LmVsdF9rZXlfbG93ZXJfYm91bmQpKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHNsb3QgPSByZWYgKExldmVsLnNsb3QgbGV2ZWwgfmtleTohc2xvdF9taW5fa2V5KSBpblxuICAgICAgICAgICgqIEZpbmQgdGhlIGZpcnN0IG5vbmVtcHR5IHNsb3Qgd2l0aCBhIHNtYWxsIGVub3VnaCBbc2xvdF9taW5fa2V5XS4gKilcbiAgICAgICAgICB3aGlsZVxuICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmlzX251bGwgc2xvdHMuKCFzbG90KVxuICAgICAgICAgICAgJiYgS2V5LiggPCApICFzbG90X21pbl9rZXkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICAgIGRvXG4gICAgICAgICAgICBzbG90IDo9IExldmVsLm5leHRfc2xvdCBsZXZlbCAhc2xvdDtcbiAgICAgICAgICAgIHNsb3RfbWluX2tleSA6PSBLZXkuYWRkICFzbG90X21pbl9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdFxuICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgbGV0IGZpcnN0ID0gc2xvdHMuKCFzbG90KSBpblxuICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAoKiBWaXNpdCBhbGwgb2YgdGhlIGVsdHMgaW4gdGhpcyBzbG90IGFuZCBmaW5kIG9uZSB3aXRoIG1pbmltdW0ga2V5LiAqKVxuICAgICAgICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICAgICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRfa2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sICFjdXJyZW50IGluXG4gICAgICAgICAgICAgIGlmIEtleS4oIDw9ICkgY3VycmVudF9rZXkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICBtaW5fZWx0X2FscmVhZHlfZm91bmQgOj0gIWN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbWluX2tleV9hbHJlYWR5X2ZvdW5kIDo9IGN1cnJlbnRfa2V5KTtcbiAgICAgICAgICAgICAgbGV0IG5leHQgPSBJbnRlcm5hbF9lbHQubmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgICAgICAgICgqIElmIFshbGV2ZWxfaW5kZXggPSAwXSB0aGVuIGFsbCBlbHRzIGluIHRoaXMgc2xvdCBoYXZlIHRoZSBzYW1lIFtrZXldLFxuICAgICAgICAgICAgICAgICBpLmUuIFshc2xvdF9taW5fa2V5XS4gIFNvLCB3ZSBkb24ndCBoYXZlIHRvIGNoZWNrIGFueSBlbGVtZW50cyBhZnRlclxuICAgICAgICAgICAgICAgICBbZmlyc3RdLiAgVGhpcyBpcyBhIHVzZWZ1bCBzaG9ydCBjdXQgaW4gdGhlIGNvbW1vbiBjYXNlIHRoYXQgdGhlcmUgYXJlXG4gICAgICAgICAgICAgICAgIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBzYW1lIG1pbiBzbG90IGluIGxldmVsIDAuICopXG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB8fCAhbGV2ZWxfaW5kZXggPSAwXG4gICAgICAgICAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgICAgICAgICAgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgICAgICAgIGRvbmUpO1xuICAgICAgICAgICgqIEZpbmlzaGVkIGxvb2tpbmcgaW4gW2xldmVsXS4gIE1vdmUgdXAgdG8gdGhlIG5leHQgbGV2ZWwuICopXG4gICAgICAgICAgaW5jciBsZXZlbF9pbmRleClcbiAgICAgIGRvbmU7XG4gICAgICB0Lm1pbl9lbHQgPC0gIW1pbl9lbHRfYWxyZWFkeV9mb3VuZDtcbiAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kO1xuICAgICAgdC5taW5fZWx0KVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2JvdW5kcyB0IGtleSA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiUHJpb3JpdHlfcXVldWUuYWRkX2VsdCBrZXkgb3V0IG9mIGJvdW5kc1wiXG4gICAgICAgICAgKGtleSA6IEtleS50KVxuICAgICAgICAgIChtaW5fYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIChtYXhfYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIH5wcmlvcml0eV9xdWV1ZToodCA6IF8gdCldXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfbGV2ZWxfYm91bmRzIGtleSBsZXZlbCA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiUHJpb3JpdHlfcXVldWUuYWRkX2VsdCBrZXkgb3V0IG9mIGxldmVsIGJvdW5kc1wiIChrZXkgOiBLZXkudCkgKGxldmVsIDogXyBMZXZlbC50KV1cbiAgOztcblxuICBsZXQgYWRkX2VsdCB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCBpblxuICAgIGlmIG5vdCAoS2V5LiggPj0gKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KSAmJiBLZXkuKCA8PSApIGtleSAobWF4X2FsbG93ZWRfa2V5IHQpKVxuICAgIHRoZW4gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2JvdW5kcyB0IGtleTtcbiAgICAoKiBGaW5kIHRoZSBsb3dlc3QgbGV2ZWwgdGhhdCB3aWxsIGhvbGQgW2VsdF0uICopXG4gICAgbGV0IGxldmVsX2luZGV4ID1cbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICB3aGlsZSBLZXkuKCA+ICkga2V5IChMZXZlbC5tYXhfYWxsb3dlZF9rZXkgdC5sZXZlbHMuKCFsZXZlbF9pbmRleCkpIGRvXG4gICAgICAgIGluY3IgbGV2ZWxfaW5kZXhcbiAgICAgIGRvbmU7XG4gICAgICAhbGV2ZWxfaW5kZXhcbiAgICBpblxuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLihsZXZlbF9pbmRleCkgaW5cbiAgICBpZiBub3QgKEtleS4oID49ICkga2V5IGxldmVsLm1pbl9hbGxvd2VkX2tleSAmJiBLZXkuKCA8PSApIGtleSBsZXZlbC5tYXhfYWxsb3dlZF9rZXkpXG4gICAgdGhlbiByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfbGV2ZWxfYm91bmRzIGtleSBsZXZlbDtcbiAgICBsZXZlbC5sZW5ndGggPC0gbGV2ZWwubGVuZ3RoICsgMTtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2xldmVsX2luZGV4IHBvb2wgZWx0IGxldmVsX2luZGV4O1xuICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5IGluXG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICBsZXQgZmlyc3QgPSBzbG90cy4oc2xvdCkgaW5cbiAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgIHRoZW4gSW50ZXJuYWxfZWx0Lmluc2VydF9hdF9lbmQgcG9vbCBmaXJzdCB+dG9fYWRkOmVsdFxuICAgIGVsc2UgKFxuICAgICAgc2xvdHMuKHNsb3QpIDwtIGVsdDtcbiAgICAgIEludGVybmFsX2VsdC5saW5rX3RvX3NlbGYgcG9vbCBlbHQpXG4gIDs7XG5cbiAgbGV0IGludGVybmFsX2FkZF9lbHQgdCBlbHQgPVxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IHQucG9vbCBlbHQgaW5cbiAgICBpZiBLZXkuKCA8ICkga2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZFxuICAgIHRoZW4gKFxuICAgICAgdC5taW5fZWx0IDwtIGVsdDtcbiAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSBrZXkpO1xuICAgIGFkZF9lbHQgdCBlbHQ7XG4gICAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9nb3RfaW52YWxpZF9rZXkgdCBrZXkgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5hZGRfYXRfaW50ZXJ2YWxfbnVtIGdvdCBpbnZhbGlkIGludGVydmFsIG51bVwiXG4gICAgICAgICAgfmludGVydmFsX251bTooa2V5IDogS2V5LnQpXG4gICAgICAgICAgfm1pbl9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bToobWluX2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICB+bWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtOihtYXhfYWxsb3dlZF9rZXkgdCA6IEtleS50KV1cbiAgOztcblxuICBsZXQgZW5zdXJlX3ZhbGlkX2tleSB0IH5rZXkgPVxuICAgIGlmIEtleS4oIDwgKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KSB8fCBLZXkuKCA+ICkga2V5IChtYXhfYWxsb3dlZF9rZXkgdClcbiAgICB0aGVuIHJhaXNlX2dvdF9pbnZhbGlkX2tleSB0IGtleVxuICA7O1xuXG4gIGxldCBpbnRlcm5hbF9hZGQgdCB+a2V5IH5hdCB2YWx1ZSA9XG4gICAgZW5zdXJlX3ZhbGlkX2tleSB0IH5rZXk7XG4gICAgaWYgSW50ZXJuYWxfZWx0LlBvb2wuaXNfZnVsbCB0LnBvb2wgdGhlbiB0LnBvb2wgPC0gSW50ZXJuYWxfZWx0LlBvb2wuZ3JvdyB0LnBvb2w7XG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5jcmVhdGUgdC5wb29sIH5rZXkgfmF0IH52YWx1ZSB+bGV2ZWxfaW5kZXg6KC0xKSBpblxuICAgIGludGVybmFsX2FkZF9lbHQgdCBlbHQ7XG4gICAgZWx0XG4gIDs7XG5cbiAgKCoqIFtyZW1vdmVfb3JfcmVfYWRkX2VsdHNdIHZpc2l0cyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgW2ZpcnN0XS4gIElmIHRoZSBlbGVtZW50J3Mga2V5IGlzIFs+PSB0X21pbl9hbGxvd2VkX2tleV0sIHRoZW4gaXQgYWRkcyB0aGUgZWxlbWVudFxuICAgICAgYmFjayBhdCBhIGxvd2VyIGxldmVsLiAgSWYgbm90LCB0aGVuIGl0IGNhbGxzIFtoYW5kbGVfcmVtb3ZlZF0gYW5kIFtmcmVlXXMgdGhlXG4gICAgICBlbGVtZW50LiAqKVxuICBsZXQgcmVtb3ZlX29yX3JlX2FkZF9lbHRzIHQgKGxldmVsIDogXyBMZXZlbC50KSBmaXJzdCB+dF9taW5fYWxsb3dlZF9rZXkgfmhhbmRsZV9yZW1vdmVkXG4gICAgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgKCogV2UgZXh0cmFjdCBbbmV4dF0gZnJvbSBbY3VycmVudF0gZmlyc3QsIGJlY2F1c2Ugd2Ugd2lsbCBtb2RpZnkgb3IgW2ZyZWVdXG4gICAgICAgICBbY3VycmVudF0gYmVmb3JlIGNvbnRpbnVpbmcgdGhlIGxvb3AuICopXG4gICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggLSAxO1xuICAgICAgaWYgS2V5LiggPj0gKSAoSW50ZXJuYWxfZWx0LmtleSBwb29sICFjdXJyZW50KSB0X21pbl9hbGxvd2VkX2tleVxuICAgICAgdGhlbiBhZGRfZWx0IHQgIWN1cnJlbnRcbiAgICAgIGVsc2UgKFxuICAgICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGhhbmRsZV9yZW1vdmVkIChJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWwgIWN1cnJlbnQpO1xuICAgICAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sICFjdXJyZW50KTtcbiAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgZG9uZVxuICA7O1xuXG4gICgqKiBbaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMgdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIFtsZXZlbF0gdG8gYXNcbiAgICAgIGxhcmdlIGEgdmFsdWUgYXMgcG9zc2libGUsIGJ1dCBubyBtb3JlIHRoYW4gW21heF9sZXZlbF9taW5fYWxsb3dlZF9rZXldLlxuICAgICAgW3RfbWluX2FsbG93ZWRfa2V5XSBpcyB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBmb3IgdGhlIGVudGlyZSB0aW1pbmcgd2hlZWwuICBBc1xuICAgICAgZWxlbWVudHMgYXJlIGVuY291bnRlcmVkLCB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhlIHRpbWluZyB3aGVlbCBpZiB0aGVpciBrZXkgaXNcbiAgICAgIHNtYWxsZXIgdGhhbiBbdF9taW5fYWxsb3dlZF9rZXldLCBvciBhZGRlZCBhdCBhIGxvd2VyIGxldmVsIGlmIG5vdC4gKilcbiAgbGV0IGluY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleVxuICAgICAgICB0XG4gICAgICAgIChsZXZlbCA6IF8gTGV2ZWwudClcbiAgICAgICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgIH50X21pbl9hbGxvd2VkX2tleVxuICAgICAgICB+aGFuZGxlX3JlbW92ZWRcbiAgICA9XG4gICAgbGV0IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgIExldmVsLmNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IGxldmVsIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgIGluXG4gICAgKCogV2UgcmVxdWlyZSB0aGF0IFttb2QgbGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsLmtleXNfcGVyX3Nsb3QgPSAwXS4gIFNvLFxuICAgICAgIHdlIHN0YXJ0IFtsZXZlbF9taW5fYWxsb3dlZF9rZXldIHdoZXJlIHRoYXQgaXMgdHJ1ZSwgYW5kIHRoZW4gaW5jcmVhc2UgaXQgYnlcbiAgICAgICBba2V5c19wZXJfc2xvdF0gZWFjaCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuICopXG4gICAgbGV0IGxldmVsX21pbl9hbGxvd2VkX2tleSA9XG4gICAgICBMZXZlbC5taW5fa2V5X2luX3NhbWVfc2xvdFxuICAgICAgICBsZXZlbFxuICAgICAgICB+a2V5OlxuICAgICAgICAgIChLZXkubWluXG4gICAgICAgICAgICAgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAoS2V5Lm1heCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKSlcbiAgICBpblxuICAgIGxldCBsZXZlbF9taW5fYWxsb3dlZF9rZXkgPSByZWYgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGluXG4gICAgbGV0IHNsb3QgPSByZWYgKExldmVsLnNsb3QgbGV2ZWwgfmtleTohbGV2ZWxfbWluX2FsbG93ZWRfa2V5KSBpblxuICAgIGxldCBrZXlzX3Blcl9zbG90ID0gbGV2ZWwua2V5c19wZXJfc2xvdCBpblxuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgd2hpbGUgS2V5LiggPCApICFsZXZlbF9taW5fYWxsb3dlZF9rZXkgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgZG9cbiAgICAgIGlmIGxldmVsLmxlbmd0aCA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgKCogSWYgbm8gZWxlbWVudHMgcmVtYWluIGF0IHRoaXMgbGV2ZWwsIHdlIGNhbiBqdXN0IHNldCBbbWluX2FsbG93ZWRfa2V5XSB0byB0aGVcbiAgICAgICAgICAgZGVzaXJlZCB2YWx1ZS4gKilcbiAgICAgICAgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IDo9IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGZpcnN0ID0gc2xvdHMuKCFzbG90KSBpblxuICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBzbG90cy4oIXNsb3QpIDwtIEludGVybmFsX2VsdC5udWxsICgpO1xuICAgICAgICAgIHJlbW92ZV9vcl9yZV9hZGRfZWx0cyB0IGxldmVsIGZpcnN0IH50X21pbl9hbGxvd2VkX2tleSB+aGFuZGxlX3JlbW92ZWQpO1xuICAgICAgICBzbG90IDo9IExldmVsLm5leHRfc2xvdCBsZXZlbCAhc2xvdDtcbiAgICAgICAgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IDo9IEtleS5hZGRfY2xhbXBfdG9fbWF4ICFsZXZlbF9taW5fYWxsb3dlZF9rZXkga2V5c19wZXJfc2xvdClcbiAgICBkb25lO1xuICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleSA8LSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleTtcbiAgICBsZXZlbC5tYXhfYWxsb3dlZF9rZXlcbiAgICA8LSBLZXkuYWRkX2NsYW1wX3RvX21heCBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSBsZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgOztcblxuICBtb2R1bGUgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZFxuICBlbmRcblxuICBsZXQgaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5IHQgfmtleSB+aGFuZGxlX3JlbW92ZWQgOiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0LnQgPVxuICAgIGlmIEtleS4oIDw9ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdClcbiAgICB0aGVuIE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgIGVsc2UgKFxuICAgICAgKCogV2UgaW5jcmVhc2UgdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIGxldmVscyBpbiBvcmRlciB0byByZXN0b3JlIHRoZSBpbnZhcmlhbnRcbiAgICAgICAgIHRoYXQgdGhleSBoYXZlIGFzIGxhcmdlIGFzIHBvc3NpYmxlIGEgW21pbl9hbGxvd2VkX2tleV0sIHdoaWxlIGxlYXZpbmcgbm8gZ2Fwc1xuICAgICAgICAgaW4ga2V5cy4gKilcbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICBsZXQgcmVzdWx0ID0gcmVmIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQuTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgaW5cbiAgICAgIGxldCBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA9IHJlZiAoS2V5LnByZWQga2V5KSBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBsZXQgbnVtX2xldmVscyA9IG51bV9sZXZlbHMgdCBpblxuICAgICAgd2hpbGUgIWxldmVsX2luZGV4IDwgbnVtX2xldmVscyBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKCFsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgbGV0IG1pbl9hbGxvd2VkX2tleV9iZWZvcmUgPSBsZXZlbC5taW5fYWxsb3dlZF9rZXkgaW5cbiAgICAgICAgaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgdFxuICAgICAgICAgIGxldmVsXG4gICAgICAgICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5OiFwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgICAgICAgIH50X21pbl9hbGxvd2VkX2tleTprZXlcbiAgICAgICAgICB+aGFuZGxlX3JlbW92ZWQ7XG4gICAgICAgIGlmIEtleS5lcXVhbCAoTGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsKSBtaW5fYWxsb3dlZF9rZXlfYmVmb3JlXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIFRoaXMgbGV2ZWwgZGlkIG5vdCBzaGlmdC4gIERvbid0IHNoaWZ0IGFueSBoaWdoZXIgbGV2ZWxzLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9IG51bV9sZXZlbHM7XG4gICAgICAgICAgcmVzdWx0IDo9IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogTGV2ZWwgW2xldmVsX2luZGV4XSBzaGlmdGVkLiAgQ29uc2lkZXIgc2hpZnRpbmcgaGlnaGVyIGxldmVscy4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSAhbGV2ZWxfaW5kZXggKyAxO1xuICAgICAgICAgIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5IDo9IExldmVsLm1heF9hbGxvd2VkX2tleSBsZXZlbClcbiAgICAgIGRvbmU7XG4gICAgICBpZiBLZXkuKCA+ICkga2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZFxuICAgICAgdGhlbiAoXG4gICAgICAgICgqIFdlIGhhdmUgcmVtb3ZlZCBbdC5taW5fZWx0XSBvciBpdCB3YXMgYWxyZWFkeSBudWxsLCBzbyBqdXN0IHNldCBpdCB0b1xuICAgICAgICAgICBudWxsLiAqKVxuICAgICAgICB0Lm1pbl9lbHQgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCk7XG4gICAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSBtaW5fYWxsb3dlZF9rZXkgdCk7XG4gICAgICAhcmVzdWx0KVxuICA7O1xuXG4gIGxldCBjcmVhdGUgP2NhcGFjaXR5ID9sZXZlbF9iaXRzICgpID1cbiAgICBsZXQgbGV2ZWxfYml0cyA9XG4gICAgICBtYXRjaCBsZXZlbF9iaXRzIHdpdGhcbiAgICAgIHwgU29tZSBsIC0+IGxcbiAgICAgIHwgTm9uZSAtPiBMZXZlbF9iaXRzLmRlZmF1bHRcbiAgICBpblxuICAgIGxldCBfLCBfLCBsZXZlbHMgPVxuICAgICAgTGlzdC5mb2xkaVxuICAgICAgICBsZXZlbF9iaXRzXG4gICAgICAgIH5pbml0OihOdW1fa2V5X2JpdHMuemVybywgS2V5Lnplcm8sIFtdKVxuICAgICAgICB+ZjooZnVuXG4gICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgICAoYml0c19wZXJfc2xvdCwgbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSwgbGV2ZWxzKVxuICAgICAgICAgICAgIChsZXZlbF9iaXRzIDogTnVtX2tleV9iaXRzLnQpXG4gICAgICAgICAgICAgLT5cbiAgICAgICAgICAgICAgIGxldCBrZXlzX3Blcl9zbG90ID0gS2V5Lm51bV9rZXlzIGJpdHNfcGVyX3Nsb3QgaW5cbiAgICAgICAgICAgICAgIGxldCBkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgICAgICAgICAgICBjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSB+bGV2ZWxfYml0cyB+Yml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID1cbiAgICAgICAgICAgICAgICAgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5jcmVhdGUgfmJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBsZXQgbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICAgICAgICAgS2V5Lm1pbl9rZXlfaW5fc2FtZV9zbG90IG1heF9sZXZlbF9taW5fYWxsb3dlZF9rZXkgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBtYXhfYWxsb3dlZF9rZXkgPVxuICAgICAgICAgICAgICAgICBLZXkuYWRkX2NsYW1wX3RvX21heCBtaW5fYWxsb3dlZF9rZXkgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IGxldmVsID1cbiAgICAgICAgICAgICAgICAgeyBMZXZlbC5pbmRleFxuICAgICAgICAgICAgICAgICA7IGJpdHMgPSBsZXZlbF9iaXRzXG4gICAgICAgICAgICAgICAgIDsgc2xvdHNfbWFzayA9IFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzXG4gICAgICAgICAgICAgICAgIDsgYml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICA7IGtleXNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICAgOyBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgICAgICAgIDsgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIDsgbGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgICA7IG1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICA7IG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICA7IHNsb3RzID1cbiAgICAgICAgICAgICAgICAgICAgIEFycmF5LmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICB+bGVuOihJbnQ2My50b19pbnRfZXhuIChOdW1fa2V5X2JpdHMucG93MiBsZXZlbF9iaXRzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5udWxsICgpKVxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgKCBOdW1fa2V5X2JpdHMuKCArICkgbGV2ZWxfYml0cyBiaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAsIEtleS5zdWNjX2NsYW1wX3RvX21heCBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICwgbGV2ZWwgOjogbGV2ZWxzICkpXG4gICAgaW5cbiAgICB7IGxlbmd0aCA9IDBcbiAgICA7IHBvb2wgPSBJbnRlcm5hbF9lbHQuUG9vbC5jcmVhdGUgP2NhcGFjaXR5ICgpXG4gICAgOyBtaW5fZWx0ID0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICA7IGVsdF9rZXlfbG93ZXJfYm91bmQgPSBLZXkuemVyb1xuICAgIDsgbGV2ZWxzID0gQXJyYXkub2ZfbGlzdF9yZXYgbGV2ZWxzXG4gICAgfVxuICA7O1xuXG4gIGxldCBtZW0gdCBlbHQgPSBJbnRlcm5hbF9lbHQuZXh0ZXJuYWxfaXNfdmFsaWQgdC5wb29sIGVsdFxuXG4gIGxldCBpbnRlcm5hbF9yZW1vdmUgdCBlbHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgaWYgSW50ZXJuYWxfZWx0LmVxdWFsIGVsdCB0Lm1pbl9lbHRcbiAgICB0aGVuXG4gICAgICB0Lm1pbl9lbHQgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICAoKiBXZSBrZWVwIFt0LmVsdF9sb3dlcl9ib3VuZF0gc2luY2UgaXQgaXMgdmFsaWQgZXZlbiB0aG91Z2ggW3QubWluX2VsdF0gaXMgYmVpbmdcbiAgICAgICByZW1vdmVkLiAqKTtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKEludGVybmFsX2VsdC5sZXZlbF9pbmRleCBwb29sIGVsdCkgaW5cbiAgICBsZXZlbC5sZW5ndGggPC0gbGV2ZWwubGVuZ3RoIC0gMTtcbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KSBpblxuICAgIGxldCBmaXJzdCA9IHNsb3RzLihzbG90KSBpblxuICAgIGlmIHBoeXNfZXF1YWwgZWx0IChJbnRlcm5hbF9lbHQubmV4dCBwb29sIGVsdClcbiAgICB0aGVuICgqIFtlbHRdIGlzIHRoZSBvbmx5IGVsZW1lbnQgaW4gdGhlIHNsb3QgKilcbiAgICAgIHNsb3RzLihzbG90KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIGVsc2UgKFxuICAgICAgaWYgcGh5c19lcXVhbCBlbHQgZmlyc3QgdGhlbiBzbG90cy4oc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQ7XG4gICAgICBJbnRlcm5hbF9lbHQudW5saW5rIHBvb2wgZWx0KVxuICA7O1xuXG4gIGxldCByZW1vdmUgdCBlbHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcG9vbCBlbHQgaW5cbiAgICBpbnRlcm5hbF9yZW1vdmUgdCBlbHQ7XG4gICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHRcbiAgOztcblxuICBsZXQgZmlyZV9wYXN0X2FsYXJtcyB0IH5oYW5kbGVfZmlyZWQgfmtleSB+bm93ID1cbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oMCkgaW5cbiAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleSBpblxuICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgZmlyc3QgPSByZWYgc2xvdHMuKHNsb3QpIGluXG4gICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsICFmaXJzdClcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgY3VycmVudCA9IHJlZiAhZmlyc3QgaW5cbiAgICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgICAgbGV0IGVsdCA9ICFjdXJyZW50IGluXG4gICAgICAgICAgbGV0IG5leHQgPSBJbnRlcm5hbF9lbHQubmV4dCBwb29sIGVsdCBpblxuICAgICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCAhZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dDtcbiAgICAgICAgICBpZiBUaW1lX25zLiggPD0gKSAoSW50ZXJuYWxfZWx0LmF0IHBvb2wgZWx0KSBub3dcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGhhbmRsZV9maXJlZCAoSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsIGVsdCk7XG4gICAgICAgICAgICBpbnRlcm5hbF9yZW1vdmUgdCBlbHQ7XG4gICAgICAgICAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdDtcbiAgICAgICAgICAgICgqIFdlIHJlY29tcHV0ZSBbZmlyc3RdIGJlY2F1c2UgW2ludGVybmFsX3JlbW92ZV0gbWF5IGhhdmUgY2hhbmdlZCBpdC4gKilcbiAgICAgICAgICAgIGZpcnN0IDo9IHNsb3RzLihzbG90KSlcbiAgICAgICAgZG9uZSkpXG4gIDs7XG5cbiAgbGV0IGNoYW5nZSB0IGVsdCB+a2V5IH5hdCA9XG4gICAgZW5zdXJlX3ZhbGlkX2tleSB0IH5rZXk7XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwb29sIGVsdCBpblxuICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2tleSBwb29sIGVsdCBrZXk7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9hdCBwb29sIGVsdCBhdDtcbiAgICBpbnRlcm5hbF9hZGRfZWx0IHQgZWx0XG4gIDs7XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgICB0aGVuIChcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGZyZWVfZWx0IGVsdCA9IEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0IGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGZvciBsZXZlbF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIGxldmVscyAtIDEgZG9cbiAgICAgICAgbGV0IGxldmVsID0gbGV2ZWxzLihsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXZlbC5sZW5ndGggPC0gMDtcbiAgICAgICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgICAgIGZvciBzbG90X2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggc2xvdHMgLSAxIGRvXG4gICAgICAgICAgICBsZXQgZWx0ID0gc2xvdHMuKHNsb3RfaW5kZXgpIGluXG4gICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdClcbiAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXRlciBwb29sIGVsdCB+ZjpmcmVlX2VsdDtcbiAgICAgICAgICAgICAgc2xvdHMuKHNsb3RfaW5kZXgpIDwtIEludGVybmFsX2VsdC5udWxsICgpKVxuICAgICAgICAgIGRvbmUpXG4gICAgICBkb25lKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBJbnRlcm5hbF9lbHQgPSBQcmlvcml0eV9xdWV1ZS5JbnRlcm5hbF9lbHRcbm1vZHVsZSBLZXkgPSBQcmlvcml0eV9xdWV1ZS5LZXlcbm1vZHVsZSBJbnRlcnZhbF9udW0gPSBLZXlcblxubGV0IG1pbl9pbnRlcnZhbF9udW0gPSBJbnRlcnZhbF9udW0uemVyb1xuXG4oKiBBbGwgdGltZSBmcm9tIHRoZSBlcG9jaCBvbndhcmRzIGlzIGJyb2tlbiBpbnRvIGhhbGYtb3BlbiBpbnRlcnZhbHMgb2Ygc2l6ZVxuICAgW0NvbmZpZy5hbGFybV9wcmVjaXNpb24gY29uZmlnXS4gIFRoZSBpbnRlcnZhbHMgYXJlIG51bWJlcmVkIHN0YXJ0aW5nIGF0IHplcm8sIGFuZCBhXG4gICB0aW1lJ3MgaW50ZXJ2YWwgbnVtYmVyIHNlcnZlcyBhcyBpdHMga2V5IGluIFtwcmlvcml0eV9xdWV1ZV0uICopXG50eXBlICdhIHQgPVxuICB7IGNvbmZpZyA6IENvbmZpZy50XG4gIDsgc3RhcnQgOiBUaW1lX25zLnRcbiAgOyAoKiBbbWF4X2ludGVydmFsX251bV0gaXMgdGhlIGludGVydmFsIG51bWJlciBvZiBbbWF4X3RpbWVdLiAqKVxuICAgIG1heF9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udFxuICA7IG11dGFibGUgbm93IDogVGltZV9ucy50XG4gIDsgbXV0YWJsZSBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDogVGltZV9ucy50XG4gIDsgbXV0YWJsZSBtYXhfYWxsb3dlZF9hbGFybV90aW1lIDogVGltZV9ucy50XG4gIDsgcHJpb3JpdHlfcXVldWUgOiAnYSBQcmlvcml0eV9xdWV1ZS50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxudHlwZSAnYSB0aW1pbmdfd2hlZWwgPSAnYSB0XG50eXBlICdhIHRfbm93ID0gJ2EgdFxuXG5sZXQgc2V4cF9vZl90X25vdyBfIHQgPSBbJXNleHAgKHQubm93IDogVGltZV9ucy50KV1cbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IENvbmZpZy5hbGFybV9wcmVjaXNpb24gdC5jb25maWdcblxubW9kdWxlIEFsYXJtID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFByaW9yaXR5X3F1ZXVlLkVsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IG51bGwgPSBQcmlvcml0eV9xdWV1ZS5FbHQubnVsbFxuICBsZXQgYXQgdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5hdCB0dy5wcmlvcml0eV9xdWV1ZSB0XG4gIGxldCB2YWx1ZSB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LnZhbHVlIHR3LnByaW9yaXR5X3F1ZXVlIHRcbiAgbGV0IGludGVydmFsX251bSB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LmtleSB0dy5wcmlvcml0eV9xdWV1ZSB0XG5lbmRcblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IGl0ZXIgdCB+ZiA9IFByaW9yaXR5X3F1ZXVlLml0ZXIgdC5wcmlvcml0eV9xdWV1ZSB+ZlxuXG5tb2R1bGUgUHJldHR5ID0gc3RydWN0XG4gIG1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IGF0IDogVGltZV9ucy50XG4gICAgICA7IHZhbHVlIDogJ2FcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgY3JlYXRlIHQgYWxhcm0gPSB7IGF0ID0gQWxhcm0uYXQgdCBhbGFybTsgdmFsdWUgPSBBbGFybS52YWx1ZSB0IGFsYXJtIH1cbiAgICBsZXQgY29tcGFyZSB0MSB0MiA9IFRpbWVfbnMuY29tcGFyZSAoYXQgdDEpIChhdCB0MilcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IGNvbmZpZyA6IENvbmZpZy50XG4gICAgOyBzdGFydCA6IFRpbWVfbnMudFxuICAgIDsgbWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50XG4gICAgOyBub3cgOiBUaW1lX25zLnRcbiAgICA7IGFsYXJtcyA6ICdhIEFsYXJtLnQgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgcHJldHR5XG4gICAgICAoeyBjb25maWdcbiAgICAgICA7IHN0YXJ0XG4gICAgICAgOyBtYXhfaW50ZXJ2YWxfbnVtXG4gICAgICAgOyBub3dcbiAgICAgICA7IG5vd19pbnRlcnZhbF9udW1fc3RhcnQgPSBfXG4gICAgICAgOyBtYXhfYWxsb3dlZF9hbGFybV90aW1lID0gX1xuICAgICAgIDsgcHJpb3JpdHlfcXVldWUgPSBfXG4gICAgICAgfSBhcyB0KVxuICA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gciA6PSBQcmV0dHkuQWxhcm0uY3JlYXRlIHQgYSA6OiAhcik7XG4gIGxldCBhbGFybXMgPSBMaXN0LnNvcnQgIXIgfmNvbXBhcmU6UHJldHR5LkFsYXJtLmNvbXBhcmUgaW5cbiAgeyBQcmV0dHkuY29uZmlnOyBzdGFydDsgbWF4X2ludGVydmFsX251bTsgbm93OyBhbGFybXMgfVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gIG1hdGNoICFzZXhwX29mX3Rfc3R5bGUgd2l0aFxuICB8IGBJbnRlcm5hbCAtPiBzZXhwX29mX3RfaW50ZXJuYWwgc2V4cF9vZl9hIHRcbiAgfCBgUHJldHR5IC0+IFslc2V4cCAocHJldHR5IHQgOiBhIFByZXR0eS50KV1cbjs7XG5cbmxldCBsZW5ndGggdCA9IFByaW9yaXR5X3F1ZXVlLmxlbmd0aCB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXRbQGNvbGRdIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfZXhuX29mX2VtcHR5X3RpbWluZ193aGVlbCB0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gb2YgZW1wdHkgdGltaW5nIHdoZWVsXCIgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfd2l0aF9hbGxfYWxhcm1zX2luX21heF9pbnRlcnZhbCB0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gd2l0aCBhbGwgYWxhcm1zIGluIG1heCBpbnRlcnZhbFwiXG4gICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuOztcblxubGV0IHBvb2wgdCA9IFByaW9yaXR5X3F1ZXVlLnBvb2wgdC5wcmlvcml0eV9xdWV1ZVxuXG5sZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lIH5hbGFybV9wcmVjaXNpb24gPVxuICBJbnRlcnZhbF9udW0ub2ZfaW50NjMgKEFsYXJtX3ByZWNpc2lvbi5pbnRlcnZhbF9udW0gYWxhcm1fcHJlY2lzaW9uIHRpbWUpXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRpbWUgPVxuICBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWUgfmFsYXJtX3ByZWNpc2lvbjp0LmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbjs7XG5cbmxldCBpbnRlcnZhbF9udW0gdCB0aW1lID1cbiAgaWYgVGltZV9ucy4oIDwgKSB0aW1lIG1pbl90aW1lXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtIGdvdCB0aW1lIHRvbyBmYXIgaW4gdGhlIHBhc3RcIiAodGltZSA6IFRpbWVfbnMudCldO1xuICBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdGltZVxuOztcblxubGV0IGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBpbnRlcnZhbF9udW0gPVxuICBBbGFybV9wcmVjaXNpb24uaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gICAgdC5jb25maWcuYWxhcm1fcHJlY2lzaW9uXG4gICAgKGludGVydmFsX251bSB8PiBJbnRlcnZhbF9udW0udG9faW50NjMpXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX3NtYWxsIGludGVydmFsX251bSA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bV9zdGFydCBnb3QgdG9vIHNtYWxsIGludGVydmFsX251bVwiXG4gICAgICAgIChpbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udClcbiAgICAgICAgKG1pbl9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX2xhcmdlIHQgaW50ZXJ2YWxfbnVtID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtX3N0YXJ0IGdvdCB0b28gbGFyZ2UgaW50ZXJ2YWxfbnVtXCJcbiAgICAgICAgKGludGVydmFsX251bSA6IEludGVydmFsX251bS50KVxuICAgICAgICAodC5tYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXVxuOztcblxubGV0IGludGVydmFsX251bV9zdGFydCB0IGludGVydmFsX251bSA9XG4gIGlmIEludGVydmFsX251bS4oIDwgKSBpbnRlcnZhbF9udW0gbWluX2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX3NtYWxsIGludGVydmFsX251bTtcbiAgaWYgSW50ZXJ2YWxfbnVtLiggPiApIGludGVydmFsX251bSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19sYXJnZSB0IGludGVydmFsX251bTtcbiAgaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGludGVydmFsX251bVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXkgPVxuICAoKiBbaW50ZXJ2YWxfbnVtX3N0YXJ0IHQga2V5XSBpcyB0aGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lIGludGVydmFsXG4gICAgIGhvbGRpbmcgdGhlIGZpcnN0IGFsYXJtIGluIFt0XS4gIEFkdmFuY2luZyB0byB0aGF0IHdvdWxkIG5vdCBiZSBlbm91Z2gsIHNpbmNlIHRoZVxuICAgICBhbGFybXMgaW4gdGhhdCBpbnRlcnZhbCBkb24ndCBmaXJlIHVudGlsIHRoZSBjbG9jayBpcyBhZHZhbmNlZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgIG5leHQgaW50ZXJ2YWwuICBTbywgd2UgdXNlIFtzdWNjIGtleV0gdG8gYWR2YW5jZSB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgaW50ZXJ2YWwuICopXG4gIGludGVydmFsX251bV9zdGFydCB0IChLZXkuc3VjYyBrZXkpXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQgaW5cbiAgICBpZiBJbnRlcnZhbF9udW0uZXF1YWwga2V5IHQubWF4X2ludGVydmFsX251bVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgU29tZSAobmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleSkpXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdF9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfZXhuX29mX2VtcHR5X3RpbWluZ193aGVlbCB0O1xuICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQgaW5cbiAgaWYgSW50ZXJ2YWxfbnVtLmVxdWFsIGtleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X3dpdGhfYWxsX2FsYXJtc19pbl9tYXhfaW50ZXJ2YWwgdDtcbiAgbmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleVxuOztcblxubGV0IGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0ID1cbiAgbGV0IG1heF9hbGxvd2VkX2tleSA9IFByaW9yaXR5X3F1ZXVlLm1heF9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVydmFsX251bS4oID49ICkgbWF4X2FsbG93ZWRfa2V5IHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIG1heF90aW1lXG4gIGVsc2VcbiAgICBUaW1lX25zLmFkZFxuICAgICAgKGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBtYXhfYWxsb3dlZF9rZXkpXG4gICAgICAoVGltZV9ucy5TcGFuLiggLSApIChhbGFybV9wcmVjaXNpb24gdCkgVGltZV9ucy5TcGFuLm5hbm9zZWNvbmQpXG47O1xuXG5sZXQgbm93X2ludGVydmFsX251bSB0ID0gUHJpb3JpdHlfcXVldWUubWluX2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWVcbmxldCBtaW5fYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gPSBub3dfaW50ZXJ2YWxfbnVtXG5sZXQgbWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIHQgPSBpbnRlcnZhbF9udW0gdCAobWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KVxubGV0IGludGVydmFsX3N0YXJ0IHQgdGltZSA9IGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCAoaW50ZXJ2YWxfbnVtIHQgdGltZSlcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmNvbmZpZzooY2hlY2sgQ29uZmlnLmludmFyaWFudClcbiAgICAgIH5zdGFydDpcbiAgICAgICAgKGNoZWNrIChmdW4gc3RhcnQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPj0gKSBzdGFydCBtaW5fdGltZSk7XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgc3RhcnQgbWF4X3RpbWUpKSlcbiAgICAgIH5tYXhfaW50ZXJ2YWxfbnVtOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfaW50ZXJ2YWxfbnVtIC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEludGVydmFsX251bS50XVxuICAgICAgICAgICAgIH5leHBlY3Q6bWF4X2ludGVydmFsX251bVxuICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCBtYXhfdGltZSk7XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEludGVydmFsX251bS50XVxuICAgICAgICAgICAgIH5leHBlY3Q6bWF4X2ludGVydmFsX251bVxuICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCAoaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgbWF4X2ludGVydmFsX251bSkpKSlcbiAgICAgIH5ub3c6XG4gICAgICAgIChjaGVjayAoZnVuIG5vdyAtPlxuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+PSApIG5vdyB0LnN0YXJ0KTtcbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBub3cgbWF4X3RpbWUpO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIEludGVydmFsX251bS5lcXVhbFxuICAgICAgICAgICAgICAgKGludGVydmFsX251bSB0IHQubm93KVxuICAgICAgICAgICAgICAgKFByaW9yaXR5X3F1ZXVlLm1pbl9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlKSkpKVxuICAgICAgfm5vd19pbnRlcnZhbF9udW1fc3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuIG5vd19pbnRlcnZhbF9udW1fc3RhcnQgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgIG5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgICAgICAgICAgICB+ZXhwZWN0OihpbnRlcnZhbF9udW1fc3RhcnQgdCAobm93X2ludGVydmFsX251bSB0KSkpKVxuICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgIG1heF9hbGxvd2VkX2FsYXJtX3RpbWVcbiAgICAgICAgICAgICB+ZXhwZWN0Oihjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCkpKVxuICAgICAgfnByaW9yaXR5X3F1ZXVlOihjaGVjayAoUHJpb3JpdHlfcXVldWUuaW52YXJpYW50IGludmFyaWFudF9hKSk7XG4gICAgaXRlciB0IH5mOihmdW4gYWxhcm0gLT5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIEludGVydmFsX251bS5lcXVhbFxuICAgICAgICAgIChBbGFybS5pbnRlcnZhbF9udW0gdCBhbGFybSlcbiAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgKEFsYXJtLmF0IHQgYWxhcm0pKSk7XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBUaW1lX25zLiggPj0gKVxuICAgICAgICAgIChpbnRlcnZhbF9zdGFydCB0IChBbGFybS5hdCB0IGFsYXJtKSlcbiAgICAgICAgICAoaW50ZXJ2YWxfc3RhcnQgdCAobm93IHQpKSk7XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBUaW1lX25zLiggPiApIChBbGFybS5hdCB0IGFsYXJtKSAoVGltZV9ucy5zdWIgKG5vdyB0KSAoYWxhcm1fcHJlY2lzaW9uIHQpKSkpKVxuOztcblxubGV0IGRlYnVnID0gZmFsc2VcblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5oYW5kbGVfZmlyZWQgPVxuICBpZiBUaW1lX25zLiggPiApIHRvXyAobm93IHQpXG4gIHRoZW4gKFxuICAgIHQubm93IDwtIHRvXztcbiAgICBsZXQga2V5ID0gaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRvXyBpblxuICAgIHQubm93X2ludGVydmFsX251bV9zdGFydCA8LSBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQga2V5O1xuICAgIG1hdGNoXG4gICAgICBQcmlvcml0eV9xdWV1ZS5pbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgICB+a2V5XG4gICAgICAgIH5oYW5kbGVfcmVtb3ZlZDpoYW5kbGVfZmlyZWRcbiAgICB3aXRoXG4gICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2UgLT5cbiAgICAgIGlmIGRlYnVnXG4gICAgICB0aGVuXG4gICAgICAgIGFzc2VydCAoVGltZV9ucy4oID0gKSB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgKGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KSlcbiAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkIC0+XG4gICAgICB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPC0gY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpXG47O1xuXG5sZXQgY3JlYXRlIH5jb25maWcgfnN0YXJ0ID1cbiAgaWYgVGltZV9ucy4oIDwgKSBzdGFydCBUaW1lX25zLmVwb2NoXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJUaW1pbmdfd2hlZWwuY3JlYXRlIGdvdCBzdGFydCBiZWZvcmUgdGhlIGVwb2NoXCIgKHN0YXJ0IDogVGltZV9ucy50KV07XG4gIGxldCB0ID1cbiAgICB7IGNvbmZpZ1xuICAgIDsgc3RhcnRcbiAgICA7IG1heF9pbnRlcnZhbF9udW0gPVxuICAgICAgICBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWU6bWF4X3RpbWUgfmFsYXJtX3ByZWNpc2lvbjpjb25maWcuYWxhcm1fcHJlY2lzaW9uXG4gICAgOyBub3cgPSBUaW1lX25zLm1pbl92YWx1ZV9mb3JfMXVzX3JvdW5kaW5nICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IG5vd19pbnRlcnZhbF9udW1fc3RhcnQgPVxuICAgICAgICBUaW1lX25zLm1pbl92YWx1ZV9mb3JfMXVzX3JvdW5kaW5nICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPSBtYXhfdGltZSAoKiBzZXQgYnkgW2FkdmFuY2VfY2xvY2tdIGJlbG93ICopXG4gICAgOyBwcmlvcml0eV9xdWV1ZSA9XG4gICAgICAgIFByaW9yaXR5X3F1ZXVlLmNyZWF0ZSA/Y2FwYWNpdHk6Y29uZmlnLmNhcGFjaXR5IH5sZXZlbF9iaXRzOmNvbmZpZy5sZXZlbF9iaXRzICgpXG4gICAgfVxuICBpblxuICB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPC0gY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQ7XG4gIGFkdmFuY2VfY2xvY2sgdCB+dG9fOnN0YXJ0IH5oYW5kbGVfZmlyZWQ6KGZ1biBfIC0+IGFzc2VydCBmYWxzZSk7XG4gIHRcbjs7XG5cbmxldCBhZGRfYXRfaW50ZXJ2YWxfbnVtIHQgfmF0IHZhbHVlID1cbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OmF0XG4gICAgICAgfmF0OihpbnRlcnZhbF9udW1fc3RhcnQgdCBhdClcbiAgICAgICB2YWx1ZSlcbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfdGhhdF9mYXJfaW5fdGhlX2Z1dHVyZSB0IGF0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwgY2Fubm90IHNjaGVkdWxlIGFsYXJtIHRoYXQgZmFyIGluIHRoZSBmdXR1cmVcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV90aW1lOih0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgOiBUaW1lX25zLnQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwgY2Fubm90IHNjaGVkdWxlIGFsYXJtIGJlZm9yZSBzdGFydCBvZiBjdXJyZW50IGludGVydmFsXCJcbiAgICAgICAgKGF0IDogVGltZV9ucy50KVxuICAgICAgICB+bm93X2ludGVydmFsX251bV9zdGFydDoodC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDogVGltZV9ucy50KV1cbjs7XG5cbmxldCBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0ID1cbiAgaWYgVGltZV9ucy4oID4gKSBhdCB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdGhlbiByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQ7XG4gIGlmIFRpbWVfbnMuKCA8ICkgYXQgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gIHRoZW4gcmFpc2VfYmVmb3JlX3N0YXJ0X29mX2N1cnJlbnRfaW50ZXJ2YWwgdCBhdFxuOztcblxubGV0IGFkZCB0IH5hdCB2YWx1ZSA9XG4gIGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQ7XG4gIEludGVybmFsX2VsdC50b19leHRlcm5hbFxuICAgIChQcmlvcml0eV9xdWV1ZS5pbnRlcm5hbF9hZGRcbiAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgfmtleTooaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IGF0KVxuICAgICAgIH5hdFxuICAgICAgIHZhbHVlKVxuOztcblxubGV0IHJlbW92ZSB0IGFsYXJtID0gUHJpb3JpdHlfcXVldWUucmVtb3ZlIHQucHJpb3JpdHlfcXVldWUgYWxhcm1cbmxldCBjbGVhciB0ID0gUHJpb3JpdHlfcXVldWUuY2xlYXIgdC5wcmlvcml0eV9xdWV1ZVxubGV0IG1lbSB0IGFsYXJtID0gUHJpb3JpdHlfcXVldWUubWVtIHQucHJpb3JpdHlfcXVldWUgYWxhcm1cblxubGV0IHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleSB+YXQgPVxuICBpZiBub3QgKG1lbSB0IGFsYXJtKVxuICB0aGVuIGZhaWx3aXRoIFwiVGltaW5nX3doZWVsIGNhbm5vdCByZXNjaGVkdWxlIGFsYXJtIG5vdCBpbiB0aW1pbmcgd2hlZWxcIjtcbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgUHJpb3JpdHlfcXVldWUuY2hhbmdlIHQucHJpb3JpdHlfcXVldWUgYWxhcm0gfmtleSB+YXRcbjs7XG5cbmxldCByZXNjaGVkdWxlIHQgYWxhcm0gfmF0ID0gcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpIH5hdFxuXG5sZXQgcmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0gdCBhbGFybSB+YXQgPVxuICByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6YXQgfmF0OihpbnRlcnZhbF9udW1fc3RhcnQgdCBhdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAoSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX2ludGVydmFsX251bV9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLm1pbl9hbGFybV9pbnRlcnZhbF9udW1fZXhuIG9mIGVtcHR5IHRpbWluZ193aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG4gIGVsc2UgSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHRcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0ID1cbiAgbGV0IHBvb2wgPSBwb29sIHQgaW5cbiAgSW50ZXJuYWxfZWx0Lm1heF9hbGFybV90aW1lIHBvb2wgZWx0IH53aXRoX2tleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0ID1cbiAgbGV0IHBvb2wgPSBwb29sIHQgaW5cbiAgSW50ZXJuYWxfZWx0Lm1pbl9hbGFybV90aW1lIHBvb2wgZWx0IH53aXRoX2tleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWF4X2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gb2YgZW1wdHkgdGltaW5nIHdoZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV07XG4gIG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHRcbjs7XG5cbmxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfmhhbmRsZV9maXJlZCA9XG4gIFByaW9yaXR5X3F1ZXVlLmZpcmVfcGFzdF9hbGFybXNcbiAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgfmhhbmRsZV9maXJlZFxuICAgIH5rZXk6KG5vd19pbnRlcnZhbF9udW0gdClcbiAgICB+bm93OnQubm93XG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgTnVtX2tleV9iaXRzID0gTnVtX2tleV9iaXRzXG5cbiAgbGV0IGludGVydmFsX251bV9pbnRlcm5hbCA9IGludGVydmFsX251bV9pbnRlcm5hbFxuICBsZXQgbWF4X3RpbWUgPSBtYXhfdGltZVxuZW5kXG4iXX0=
