// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Stdio__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdio = [0];
   runtime.caml_register_global(0, Stdio, "Stdio__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__In_channel
//# unitInfo: Requires: Base, Base__Buffer, Base__Char, Base__Exn, Base__List, Base__String, Caml, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    flags = [0, 0, 0],
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Buffer = global_data.Base__Buffer,
    Stdlib = global_data.Stdlib,
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base;
   function equal(t1, t2){return caml_call2(Base[203], t1, t2);}
   var
    seek = Caml[96][4],
    pos = Caml[96][5],
    length = Caml[96][6],
    stdin = Caml[38];
   function create(opt, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    var flags$0 = binary ? [0, 6, flags] : flags;
    return caml_call3(Caml[81], flags$0, 0, file);
   }
   var close = Caml[93];
   function with_file(binary, file, f){
    var _i_ = create(binary, file);
    return caml_call3(Base_Exn[12], f, _i_, close);
   }
   function may_eof(f){
    try{var _g_ = [0, caml_call1(f, 0)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   function input(t, buf, pos, len){
    return caml_call4(Caml[84], t, buf, pos, len);
   }
   function really_input(t, buf, pos, len){
    return may_eof
            (function(param){return caml_call4(Caml[85], t, buf, pos, len);});
   }
   function really_input_exn(t, buf, pos, len){
    return caml_call4(Caml[85], t, buf, pos, len);
   }
   function input_byte(t){
    return may_eof(function(param){return caml_call1(Caml[87], t);});
   }
   function input_char(t){
    return may_eof(function(param){return caml_call1(Caml[82], t);});
   }
   function input_binary_int(t){
    return may_eof(function(param){return caml_call1(Caml[88], t);});
   }
   function unsafe_input_value(t){
    return may_eof(function(param){return caml_call1(Caml[89], t);});
   }
   function input_buffer(t, buf, len){
    return may_eof
            (function(param){
              return caml_call3(Stdlib_Buffer[22], buf, t, len);
             });
   }
   var set_binary_mode = Caml[95];
   function input_all(t){
    var chunk_size = 65536, buffer = caml_call1(Base_Buffer[2], chunk_size);
    try{for(;;) caml_call3(Stdlib_Buffer[22], buffer, t, chunk_size);}
    catch(_e_){
     var _d_ = caml_wrap_exception(_e_);
     if(_d_ === Stdlib[12]) return caml_call1(Base_Buffer[3], buffer);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function trim(fix_win_eol, line){
    if(! fix_win_eol) return line;
    var len = runtime.caml_ml_string_length(line);
    if(0 < len){
     var _c_ = runtime.caml_string_get(line, len - 1 | 0);
     if(caml_call2(Base_Char[15], _c_, 13))
      return caml_call3(Base_String[2], line, 0, len - 1 | 0);
    }
    return line;
   }
   function input_line(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var match = may_eof(function(param){return caml_call1(Caml[83], t);});
    if(! match) return 0;
    var line = match[1];
    return [0, trim(fix_win_eol, line)];
   }
   function input_line_exn(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var line = caml_call1(Caml[83], t);
    return trim(fix_win_eol, line);
   }
   function fold_lines(fix_win_eol, t, init, f){
    var ac = init;
    for(;;){
     var match = input_line(fix_win_eol, t);
     if(! match) return ac;
     var line = match[1], ac$0 = caml_call2(f, ac, line);
     ac = ac$0;
    }
   }
   function input_lines(fix_win_eol, t){
    var
     _b_ =
       fold_lines
        (fix_win_eol, t, 0, function(lines, line){return [0, line, lines];});
    return caml_call1(Base_List[38], _b_);
   }
   function iter_lines(fix_win_eol, t, f){
    return fold_lines
            (fix_win_eol,
             t,
             0,
             function(param, line){return caml_call1(f, line);});
   }
   function read_lines(fix_win_eol, fname){
    return with_file
            (0, fname, function(_a_){return input_lines(fix_win_eol, _a_);});
   }
   function read_all(fname){return with_file(0, fname, input_all);}
   var
    Stdio_In_channel =
      [0,
       equal,
       stdin,
       create,
       with_file,
       close,
       input,
       really_input,
       really_input_exn,
       input_char,
       input_byte,
       input_binary_int,
       unsafe_input_value,
       input_buffer,
       input_all,
       input_line,
       input_line_exn,
       fold_lines,
       input_lines,
       iter_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       read_lines,
       read_all];
   runtime.caml_register_global(10, Stdio_In_channel, "Stdio__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__Out_channel
//# unitInfo: Requires: Base, Base__Exn, Base__List, Caml, Stdlib__Buffer, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\n",
    flags = [0, 1, [0, 3, 0]],
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf;
   function equal(t1, t2){return caml_call2(Base[203], t1, t2);}
   var
    seek = Caml[96][1],
    pos = Caml[96][2],
    length = Caml[96][3],
    stdout = Caml[39],
    stderr = Caml[40],
    _a_ = [0, "<stderr>"],
    _b_ = [0, "<stdout>"],
    _c_ = [0, "<Out_channel.t>"];
   function sexp_of_t(t){
    return caml_call2(Base[203], t, stderr)
            ? _a_
            : caml_call2(Base[203], t, stdout) ? _b_ : _c_;
   }
   function create(opt, _i_, _h_, _g_, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    if(_i_) var sth$0 = _i_[1], append = sth$0; else var append = 0;
    if(_h_)
     var sth$1 = _h_[1], fail_if_exists = sth$1;
    else
     var fail_if_exists = 0;
    if(_g_) var sth$2 = _g_[1], perm = sth$2; else var perm = 438;
    var
     _j_ = binary ? 6 : 7,
     flags$0 = [0, _j_, flags],
     _k_ = append ? 2 : 4,
     flags$1 = [0, _k_, flags$0],
     flags$2 = fail_if_exists ? [0, 5, flags$1] : flags$1;
    return caml_call3(Caml[62], flags$2, perm, file);
   }
   var
    set_binary_mode = Caml[78],
    flush = Caml[63],
    close = Caml[76],
    close_no_err = Caml[77];
   function output(t, buf, pos, len){
    return caml_call4(Caml[68], t, buf, pos, len);
   }
   function output_substring(t, buf, pos, len){
    return caml_call4(Caml[69], t, buf, pos, len);
   }
   var
    output_string = Caml[66],
    output_bytes = Caml[67],
    output_char = Caml[65],
    output_byte = Caml[70],
    output_binary_int = Caml[71],
    output_buffer = Stdlib_Buffer[10],
    output_value = Caml[72];
   function newline(t){return caml_call2(output_string, t, cst);}
   function output_lines(t, lines){
    return caml_call2
            (Base_List[9],
             lines,
             function(line){
              caml_call2(output_string, t, line);
              return caml_call2(output_string, t, cst);
             });
   }
   var
    printf = Stdlib_Printf[2],
    eprintf = Stdlib_Printf[3],
    fprintf = Stdlib_Printf[1],
    kfprintf = Stdlib_Printf[8],
    print_string = Caml[42],
    print_endline = Caml[46],
    prerr_endline = Caml[53];
   function print_s(mach, sexp){
    var
     _f_ =
       mach
        ? caml_call1(Base[84][14], sexp)
        : caml_call2(Base[84][13], 0, sexp);
    return caml_call1(print_endline, _f_);
   }
   function eprint_s(mach, sexp){
    var
     _e_ =
       mach
        ? caml_call1(Base[84][14], sexp)
        : caml_call2(Base[84][13], 0, sexp);
    return caml_call1(prerr_endline, _e_);
   }
   function with_file(binary, append, fail_if_exists, perm, file, f){
    var _d_ = create(binary, append, fail_if_exists, perm, file);
    return caml_call3(Base_Exn[12], f, _d_, close);
   }
   function write_lines(file, lines){
    return with_file
            (0, 0, 0, 0, file, function(t){return output_lines(t, lines);});
   }
   function write_all(file, data){
    return with_file
            (0,
             0,
             0,
             0,
             file,
             function(t){return caml_call2(output_string, t, data);});
   }
   var
    Stdio_Out_channel =
      [0,
       sexp_of_t,
       equal,
       stdout,
       stderr,
       create,
       with_file,
       close,
       close_no_err,
       set_binary_mode,
       flush,
       output,
       output_string,
       output_substring,
       output_bytes,
       output_char,
       output_byte,
       output_binary_int,
       output_buffer,
       output_value,
       newline,
       output_lines,
       fprintf,
       printf,
       print_s,
       eprint_s,
       eprintf,
       kfprintf,
       print_string,
       print_endline,
       prerr_endline,
       seek,
       pos,
       length,
       write_lines,
       write_all];
   runtime.caml_register_global(11, Stdio_Out_channel, "Stdio__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio
//# unitInfo: Requires: Stdio__In_channel, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdio_In_channel = global_data.Stdio__In_channel,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    stdin = Stdio_In_channel[2],
    stdout = Stdio_Out_channel[3],
    stderr = Stdio_Out_channel[4],
    eprintf = Stdio_Out_channel[26],
    printf = Stdio_Out_channel[23],
    print_s = Stdio_Out_channel[24],
    eprint_s = Stdio_Out_channel[25],
    print_string = Stdio_Out_channel[28],
    print_endline = Stdio_Out_channel[29],
    prerr_endline = Stdio_Out_channel[30],
    Stdio =
      [0,
       stdin,
       stdout,
       stderr,
       printf,
       print_s,
       eprint_s,
       eprintf,
       print_string,
       print_endline,
       prerr_endline];
   runtime.caml_register_global(2, Stdio, "Stdio");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRpby5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZmxhZ3MiLCJlcXVhbCIsInQxIiwidDIiLCJzZWVrIiwicG9zIiwibGVuZ3RoIiwic3RkaW4iLCJjcmVhdGUiLCJvcHQiLCJmaWxlIiwic3RoIiwiYmluYXJ5IiwiZmxhZ3MkMCIsImNsb3NlIiwid2l0aF9maWxlIiwiZiIsIm1heV9lb2YiLCJpbnB1dCIsInQiLCJidWYiLCJsZW4iLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfZXhuIiwiaW5wdXRfYnl0ZSIsImlucHV0X2NoYXIiLCJpbnB1dF9iaW5hcnlfaW50IiwidW5zYWZlX2lucHV0X3ZhbHVlIiwiaW5wdXRfYnVmZmVyIiwic2V0X2JpbmFyeV9tb2RlIiwiaW5wdXRfYWxsIiwiY2h1bmtfc2l6ZSIsImJ1ZmZlciIsInRyaW0iLCJmaXhfd2luX2VvbCIsImxpbmUiLCJpbnB1dF9saW5lIiwiaW5wdXRfbGluZV9leG4iLCJmb2xkX2xpbmVzIiwiaW5pdCIsImFjIiwiYWMkMCIsImlucHV0X2xpbmVzIiwibGluZXMiLCJpdGVyX2xpbmVzIiwicmVhZF9saW5lcyIsImZuYW1lIiwicmVhZF9hbGwiLCJzdGRvdXQiLCJzdGRlcnIiLCJzZXhwX29mX3QiLCJzdGgkMCIsImFwcGVuZCIsInN0aCQxIiwiZmFpbF9pZl9leGlzdHMiLCJzdGgkMiIsInBlcm0iLCJmbGFncyQxIiwiZmxhZ3MkMiIsImZsdXNoIiwiY2xvc2Vfbm9fZXJyIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnVmZmVyIiwib3V0cHV0X3ZhbHVlIiwibmV3bGluZSIsIm91dHB1dF9saW5lcyIsInByaW50ZiIsImVwcmludGYiLCJmcHJpbnRmIiwia2ZwcmludGYiLCJwcmludF9zdHJpbmciLCJwcmludF9lbmRsaW5lIiwicHJlcnJfZW5kbGluZSIsInByaW50X3MiLCJtYWNoIiwic2V4cCIsImVwcmludF9zIiwid3JpdGVfbGluZXMiLCJ3cml0ZV9hbGwiLCJkYXRhIl0sInNvdXJjZXMiOlsiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3N0ZGlvL2luX2NoYW5uZWwubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvc3RkaW8vb3V0X2NoYW5uZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUFXTUE7Ozs7Ozs7Ozs7WUFQRkMsTUFBT0MsSUFBUUMsSUFBSyxPQUFBLHNCQUFiRCxJQUFRQyxJQUFxQjs7SUFDcENDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLE9BQVNDLEtBQWVDO0lBQzFCLEdBRFdELFNBQVNFLE1BQVRGLFFBQUFHLFNBQVNELGNBQVRDO0lBRVgsSUFBSUMsVUFGT0QsZ0JBQ1BaLFNBQUFBO0lBRUosT0FBQSxxQkFESWEsWUFGc0JIO0dBR087T0FHL0JJO1lBQ0FDLFVBQVdILFFBQU9GLE1BQU1NO0lBQWlCLFVBUHpDUixPQU9XSSxRQUFPRjtvQ0FBTU0sUUFEeEJGO0dBQ2dGO1lBRWhGRyxRQUFRRDtJQUNWLElBQUksY0FBSyxXQURDQSxRQUNOOzs7NEJBQ2E7OztHQUFJO1lBR25CRSxNQUFNQyxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQUFBLHFCQUFuQkYsR0FBR0MsS0FBS2YsS0FBS2dCO0dBQThCO1lBQ2pEQyxhQUFhSCxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQU5oQ0o7NkJBTW1ELE9BQW5CLHFCQUFuQkUsR0FBR0MsS0FBS2YsS0FBS2dCLEtBQXdEO0dBQUM7WUFDbkZFLGlCQUFpQkosR0FBR0MsS0FBS2YsS0FBS2dCO0lBQU0sT0FBQSxxQkFBbkJGLEdBQUdDLEtBQUtmLEtBQUtnQjtHQUFxQztZQUNuRUcsV0FBV0w7SUFBSSxPQVJm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MUV5QyxVQUFVMUUsTUFBTTJFO0lBQU8sT0FMdkJ0RTs7Ozs7YUFLVUw7c0JBQW9DUyxHQUFLLE9BQTVCLFdBMUN2QjRDLGVBMEM4QzVDLEdBQTlCa0UsTUFBdUQ7R0FBQzs7OztPQXpFeEVuQztPQVBBakQ7T0FJQStDO09BQ0FDO09BYUF6QztPQXlEQU87T0F6Q0FEO09BQ0E4QztPQUhBL0I7T0FDQThCO09BR0FFO09BRUFFO09BREFEO09BRUFFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BUUFHO09BRkFGO09BUUFPO09BT0FHO09BZEFUO09BRUFFO09BQ0FDO09BQ0FDO09BQ0FDO09BMURBMUU7T0FDQUM7T0FDQUM7T0E0RUE2RTtPQUNBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2VcblxudHlwZSB0ID0gQ2FtbC5pbl9jaGFubmVsXG5cbmxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBzZWVrID0gQ2FtbC5MYXJnZUZpbGUuc2Vla19pblxubGV0IHBvcyA9IENhbWwuTGFyZ2VGaWxlLnBvc19pblxubGV0IGxlbmd0aCA9IENhbWwuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgc3RkaW4gPSBDYW1sLnN0ZGluXG5cbmxldCBjcmVhdGUgPyhiaW5hcnkgPSB0cnVlKSBmaWxlID1cbiAgbGV0IGZsYWdzID0gWyBPcGVuX3Jkb25seSBdIGluXG4gIGxldCBmbGFncyA9IGlmIGJpbmFyeSB0aGVuIE9wZW5fYmluYXJ5IDo6IGZsYWdzIGVsc2UgZmxhZ3MgaW5cbiAgQ2FtbC5vcGVuX2luX2dlbiBmbGFncyAwbzAwMCBmaWxlXG47O1xuXG5sZXQgY2xvc2UgPSBDYW1sLmNsb3NlX2luXG5sZXQgd2l0aF9maWxlID9iaW5hcnkgZmlsZSB+ZiA9IEV4bi5wcm90ZWN0eCAoY3JlYXRlID9iaW5hcnkgZmlsZSkgfmYgfmZpbmFsbHk6Y2xvc2VcblxubGV0IG1heV9lb2YgZiA9XG4gIHRyeSBTb21lIChmICgpKSB3aXRoXG4gIHwgRW5kX29mX2ZpbGUgLT4gTm9uZVxuOztcblxubGV0IGlucHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBDYW1sLmlucHV0IHQgYnVmIHBvcyBsZW5cbmxldCByZWFsbHlfaW5wdXQgdCB+YnVmIH5wb3MgfmxlbiA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLnJlYWxseV9pbnB1dCB0IGJ1ZiBwb3MgbGVuKVxubGV0IHJlYWxseV9pbnB1dF9leG4gdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwucmVhbGx5X2lucHV0IHQgYnVmIHBvcyBsZW5cbmxldCBpbnB1dF9ieXRlIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9ieXRlIHQpXG5sZXQgaW5wdXRfY2hhciB0ID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfY2hhciB0KVxubGV0IGlucHV0X2JpbmFyeV9pbnQgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X2JpbmFyeV9pbnQgdClcbmxldCB1bnNhZmVfaW5wdXRfdmFsdWUgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X3ZhbHVlIHQpXG5sZXQgaW5wdXRfYnVmZmVyIHQgYnVmIH5sZW4gPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5CdWZmZXIuYWRkX2NoYW5uZWwgYnVmIHQgbGVuKVxubGV0IHNldF9iaW5hcnlfbW9kZSA9IENhbWwuc2V0X2JpbmFyeV9tb2RlX2luXG5cbmxldCBpbnB1dF9hbGwgdCA9XG4gICgqIFdlIHVzZSA2NTUzNiBiZWNhdXNlIHRoYXQgaXMgdGhlIHNpemUgb2YgT0NhbWwncyBJTyBidWZmZXJzLiAqKVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluXG4gIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIGNodW5rX3NpemUgaW5cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBDYW1sLkJ1ZmZlci5hZGRfY2hhbm5lbCBidWZmZXIgdCBjaHVua19zaXplO1xuICAgIGxvb3AgKClcbiAgaW5cbiAgdHJ5IGxvb3AgKCkgd2l0aFxuICB8IEVuZF9vZl9maWxlIC0+IEJ1ZmZlci5jb250ZW50cyBidWZmZXJcbjs7XG5cbmxldCB0cmltIH5maXhfd2luX2VvbCBsaW5lID1cbiAgaWYgZml4X3dpbl9lb2xcbiAgdGhlbiAoXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggbGluZSBpblxuICAgIGlmIGxlbiA+IDAgJiYgQ2hhci5lcXVhbCAoU3RyaW5nLmdldCBsaW5lIChsZW4gLSAxKSkgJ1xccidcbiAgICB0aGVuIFN0cmluZy5zdWIgbGluZSB+cG9zOjAgfmxlbjoobGVuIC0gMSlcbiAgICBlbHNlIGxpbmUpXG4gIGVsc2UgbGluZVxuOztcblxubGV0IGlucHV0X2xpbmUgPyhmaXhfd2luX2VvbCA9IHRydWUpIHQgPVxuICBtYXRjaCBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9saW5lIHQpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGxpbmUgLT4gU29tZSAodHJpbSB+Zml4X3dpbl9lb2wgbGluZSlcbjs7XG5cbmxldCBpbnB1dF9saW5lX2V4biA/KGZpeF93aW5fZW9sID0gdHJ1ZSkgdCA9XG4gIGxldCBsaW5lID0gQ2FtbC5pbnB1dF9saW5lIHQgaW5cbiAgdHJpbSB+Zml4X3dpbl9lb2wgbGluZVxuOztcblxubGV0IGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWMgPVxuICAgIG1hdGNoIGlucHV0X2xpbmUgP2ZpeF93aW5fZW9sIHQgd2l0aFxuICAgIHwgTm9uZSAtPiBhY1xuICAgIHwgU29tZSBsaW5lIC0+IGxvb3AgKGYgYWMgbGluZSlcbiAgaW5cbiAgbG9vcCBpbml0XG47O1xuXG5sZXQgaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sIHQgPVxuICBMaXN0LnJldiAoZm9sZF9saW5lcyA/Zml4X3dpbl9lb2wgdCB+aW5pdDpbXSB+ZjooZnVuIGxpbmVzIGxpbmUgLT4gbGluZSA6OiBsaW5lcykpXG47O1xuXG5sZXQgaXRlcl9saW5lcyA/Zml4X3dpbl9lb2wgdCB+ZiA9XG4gIGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBsaW5lIC0+IGYgbGluZSlcbjs7XG5cbmxldCByZWFkX2xpbmVzID9maXhfd2luX2VvbCBmbmFtZSA9IHdpdGhfZmlsZSBmbmFtZSB+ZjooaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sKVxubGV0IHJlYWRfYWxsIGZuYW1lID0gd2l0aF9maWxlIGZuYW1lIH5mOmlucHV0X2FsbFxuIiwib3BlbiEgQmFzZVxuXG50eXBlIHQgPSBDYW1sLm91dF9jaGFubmVsXG5cbmxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBzZWVrID0gQ2FtbC5MYXJnZUZpbGUuc2Vla19vdXRcbmxldCBwb3MgPSBDYW1sLkxhcmdlRmlsZS5wb3Nfb3V0XG5sZXQgbGVuZ3RoID0gQ2FtbC5MYXJnZUZpbGUub3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgc3Rkb3V0ID0gQ2FtbC5zdGRvdXRcbmxldCBzdGRlcnIgPSBDYW1sLnN0ZGVyclxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBpZiBwaHlzX2VxdWFsIHQgc3RkZXJyXG4gIHRoZW4gU2V4cC5BdG9tIFwiPHN0ZGVycj5cIlxuICBlbHNlIGlmIHBoeXNfZXF1YWwgdCBzdGRvdXRcbiAgdGhlbiBTZXhwLkF0b20gXCI8c3Rkb3V0PlwiXG4gIGVsc2UgU2V4cC5BdG9tIFwiPE91dF9jaGFubmVsLnQ+XCJcbjs7XG5cbnR5cGUgJ2Egd2l0aF9jcmVhdGVfYXJncyA9XG4gID9iaW5hcnk6Ym9vbCAtPiA/YXBwZW5kOmJvb2wgLT4gP2ZhaWxfaWZfZXhpc3RzOmJvb2wgLT4gP3Blcm06aW50IC0+ICdhXG5cbmxldCBjcmVhdGVcbiAgICAgID8oYmluYXJ5ID0gdHJ1ZSlcbiAgICAgID8oYXBwZW5kID0gZmFsc2UpXG4gICAgICA/KGZhaWxfaWZfZXhpc3RzID0gZmFsc2UpXG4gICAgICA/KHBlcm0gPSAwbzY2NilcbiAgICAgIGZpbGVcbiAgPVxuICBsZXQgZmxhZ3MgPSBbIE9wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0IF0gaW5cbiAgbGV0IGZsYWdzID0gKGlmIGJpbmFyeSB0aGVuIE9wZW5fYmluYXJ5IGVsc2UgT3Blbl90ZXh0KSA6OiBmbGFncyBpblxuICBsZXQgZmxhZ3MgPSAoaWYgYXBwZW5kIHRoZW4gT3Blbl9hcHBlbmQgZWxzZSBPcGVuX3RydW5jKSA6OiBmbGFncyBpblxuICBsZXQgZmxhZ3MgPSBpZiBmYWlsX2lmX2V4aXN0cyB0aGVuIE9wZW5fZXhjbCA6OiBmbGFncyBlbHNlIGZsYWdzIGluXG4gIENhbWwub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0gZmlsZVxuOztcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IENhbWwuc2V0X2JpbmFyeV9tb2RlX291dFxubGV0IGZsdXNoID0gQ2FtbC5mbHVzaFxubGV0IGNsb3NlID0gQ2FtbC5jbG9zZV9vdXRcbmxldCBjbG9zZV9ub19lcnIgPSBDYW1sLmNsb3NlX291dF9ub2VyclxubGV0IG91dHB1dCB0IH5idWYgfnBvcyB+bGVuID0gQ2FtbC5vdXRwdXQgdCBidWYgcG9zIGxlblxubGV0IG91dHB1dF9zdWJzdHJpbmcgdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwub3V0cHV0X3N1YnN0cmluZyB0IGJ1ZiBwb3MgbGVuXG5sZXQgb3V0cHV0X3N0cmluZyA9IENhbWwub3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IENhbWwub3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0X2NoYXIgPSBDYW1sLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBDYW1sLm91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBDYW1sLm91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X2J1ZmZlciA9IENhbWwuQnVmZmVyLm91dHB1dF9idWZmZXJcbmxldCBvdXRwdXRfdmFsdWUgPSBDYW1sLm91dHB1dF92YWx1ZVxubGV0IG5ld2xpbmUgdCA9IG91dHB1dF9zdHJpbmcgdCBcIlxcblwiXG5cbmxldCBvdXRwdXRfbGluZXMgdCBsaW5lcyA9XG4gIExpc3QuaXRlciBsaW5lcyB+ZjooZnVuIGxpbmUgLT5cbiAgICBvdXRwdXRfc3RyaW5nIHQgbGluZTtcbiAgICBuZXdsaW5lIHQpXG47O1xuXG5sZXQgcHJpbnRmID0gQ2FtbC5QcmludGYucHJpbnRmXG5sZXQgZXByaW50ZiA9IENhbWwuUHJpbnRmLmVwcmludGZcbmxldCBmcHJpbnRmID0gQ2FtbC5QcmludGYuZnByaW50ZlxubGV0IGtmcHJpbnRmID0gQ2FtbC5QcmludGYua2ZwcmludGZcbmxldCBwcmludF9zdHJpbmcgPSBDYW1sLnByaW50X3N0cmluZ1xubGV0IHByaW50X2VuZGxpbmUgPSBDYW1sLnByaW50X2VuZGxpbmVcbmxldCBwcmVycl9lbmRsaW5lID0gQ2FtbC5wcmVycl9lbmRsaW5lXG5cbmxldCBwcmludF9zID9tYWNoIHNleHAgPVxuICBwcmludF9lbmRsaW5lXG4gICAgKG1hdGNoIG1hY2ggd2l0aFxuICAgICB8IFNvbWUgKCkgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwXG4gICAgIHwgTm9uZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gc2V4cClcbjs7XG5cbmxldCBlcHJpbnRfcyA/bWFjaCBzZXhwID1cbiAgcHJlcnJfZW5kbGluZVxuICAgIChtYXRjaCBtYWNoIHdpdGhcbiAgICAgfCBTb21lICgpIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cFxuICAgICB8IE5vbmUgLT4gU2V4cC50b19zdHJpbmdfaHVtIHNleHApXG47O1xuXG5sZXQgd2l0aF9maWxlID9iaW5hcnkgP2FwcGVuZCA/ZmFpbF9pZl9leGlzdHMgP3Blcm0gZmlsZSB+ZiA9XG4gIEV4bi5wcm90ZWN0eCAoY3JlYXRlID9iaW5hcnkgP2FwcGVuZCA/ZmFpbF9pZl9leGlzdHMgP3Blcm0gZmlsZSkgfmYgfmZpbmFsbHk6Y2xvc2Vcbjs7XG5cbmxldCB3cml0ZV9saW5lcyBmaWxlIGxpbmVzID0gd2l0aF9maWxlIGZpbGUgfmY6KGZ1biB0IC0+IG91dHB1dF9saW5lcyB0IGxpbmVzKVxubGV0IHdyaXRlX2FsbCBmaWxlIH5kYXRhID0gd2l0aF9maWxlIGZpbGUgfmY6KGZ1biB0IC0+IG91dHB1dF9zdHJpbmcgdCBkYXRhKVxuIl19
