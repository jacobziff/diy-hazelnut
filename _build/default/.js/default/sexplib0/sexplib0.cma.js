// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[9], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     a = xs;
     b = ys;
    }
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Not_found_s = [248, "Sexplib0__Sexp.Not_found_s", caml_fresh_oo_id(0)],
    Of_sexp_error = [248, "Sexplib0__Sexp.Of_sexp_error", caml_fresh_oo_id(0)],
    default_indent = [0, 1],
    cst_n = "\\n",
    _a_ = [0, 0, 0],
    _b_ = [0, [15, [17, 2, 0]], "%a@?"];
   function must_escape(str){
    var len = caml_ml_string_length(str), _w_ = 0 === len ? 1 : 0;
    if(_w_) return _w_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _x_ = 0 < ix ? 1 : 0;
         if(_x_){
          var
           next = ix - 1 | 0,
           _y_ = caml_string_get(str, next),
           _z_ = caml_call2(Stdlib_Char[8], _y_, 35);
          if(! _z_){ix = next; continue;}
          var _A_ = _z_;
         }
         else
          var _A_ = _x_;
         return _A_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _C_ = 0 < ix ? 1 : 0;
            if(_C_){
             var
              next$0 = ix - 1 | 0,
              _D_ = caml_string_get(str, next$0),
              _E_ = caml_call2(Stdlib_Char[8], _D_, 124);
             if(! _E_){ix = next$0; continue;}
             var _F_ = _E_;
            }
            else
             var _F_ = _C_;
            return _F_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _B_ = 0 < ix ? 1 : 0;
       if(! _B_) return _B_;
       var ix$0 = ix - 1 | 0;
       ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _m_ = caml_ml_string_length(s) - 1 | 0, _l_ = 0;
    if(_m_ >= 0){
     var i$0 = _l_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _t_ = match - 34 | 0;
          if(58 < _t_ >>> 0){
           if(93 <= _t_) break c;
          }
          else if(56 < _t_ - 1 >>> 0) break b;
          var _u_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _u_ = 4;
        break a;
       }
       var _u_ = 2;
      }
      n[1] = n[1] + _u_ | 0;
      var _v_ = i$0 + 1 | 0;
      if(_m_ === i$0) break;
      i$0 = _v_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _o_ = caml_ml_string_length(s) - 1 | 0, _n_ = 0;
    if(_o_ >= 0){
     var i = _n_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _q_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _q_);
        n[1]++;
        var
         _r_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _r_);
        n[1]++;
        var _s_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _s_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _p_ = i + 1 | 0;
      if(_o_ === i) break;
      i = _p_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[48], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[48], res);
   }
   function index_of_newline(str, start){
    try{
     var _j_ = [0, caml_call3(Stdlib_StringLabels[31], str, start, 10)];
     return _j_;
    }
    catch(_k_){
     var _i_ = caml_wrap_exception(_k_);
     if(_i_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_i_, 0);
    }
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _f_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _f_ = 1;
     if(_f_){
      var _g_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _g_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[15], str, index$0, end_pos$0 - index$0 | 0),
       _h_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _h_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[34], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0;
      index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0);
     may_need_space$1 = may_need_space$2;
     param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[25], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[111], buf);
    return caml_call4
            (Stdlib_Format[129],
             ppf,
             _b_,
             function(_d_, _e_){return pp_hum_indent(indent, _d_, _e_);},
             sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return fname !== ""
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(26, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment";
   function coerce(t){return t;}
   var Sexplib0_Sexp_grammar = [0, coerce, doc_comment_tag];
   runtime.caml_register_global
    (1, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       unit_sexp_grammar,
       0,
       4,
       4,
       1,
       2,
       3,
       2,
       2,
       2,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (4, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1],
    _a_ = [1, 0],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _e_ = [0, "<opaque>"],
    _f_ = [0, "<fun>"];
   function list_map(f, l){
    var _aM_ = caml_call2(Stdlib_ListLabels[21], f, l);
    return caml_call1(Stdlib_ListLabels[9], _aM_);
   }
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var
     _aK_ = runtime.caml_obj_tag(lv),
     _aL_ =
       250 === _aK_
        ? lv[1]
        : 246 === _aK_ ? caml_call1(CamlinternalLazy[2], lv) : lv;
    return caml_call1(sexp_of_a, _aL_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _aJ_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _aJ_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _aH_ = [0, caml_call1(sexp_of_c, c), 0],
     _aI_ = [0, caml_call1(sexp_of_b, b), _aH_];
    return [1, [0, caml_call1(sexp_of_a, a), _aI_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    var _aG_ = caml_call2(Stdlib_ListLabels[21], sexp_of_a, lst);
    return [1, caml_call1(Stdlib_ListLabels[9], _aG_)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _aD_ = ar.length - 2 | 0;
    if(_aD_ >= 0){
     var i = _aD_;
     for(;;){
      var _aE_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _aE_];
      var _aF_ = i - 1 | 0;
      if(0 === i) break;
      i = _aF_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _aC_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _aC_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_aB_, _aA_){return _aB_ === _aA_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[22][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][14], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[22][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[24], the_exn_table)[1];}
   var For_unit_tests_only = [0, size], _g_ = [0, 2];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _az_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _az_);
   }
   caml_call1
    (Stdlib_Printexc[9],
     function(exn){
      var match = find_auto(1, exn);
      if(! match) return 0;
      var sexp = match[1];
      return [0, caml_call2(Sexplib0_Sexp[13], _g_, sexp)];
     });
   var _h_ = [0, 2];
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _h_, sexp);
   }
   var
    Of_sexp_error = Sexplib0_Sexp[6],
    record_check_extra_fields = [0, 1],
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values";
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ay_ = sexp[1];
    a:
    if(_ay_ !== "False"){
     if(_ay_ !== "True"){
      if(_ay_ === "false") break a;
      if(_ay_ !== "true")
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _ax_ = caml_int_of_string(str); return _ax_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _aw_ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _aw_), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _av_ = caml_float_of_string(str); return _av_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _au_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _au_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _at_ = caml_int_of_string(str); return _at_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _as_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _as_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _ar_ = runtime.caml_int64_of_string(str); return _ar_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _aq_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _aq_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _ap_ = caml_int_of_string(str); return _ap_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _ao_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _ao_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _an_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _an_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _ai_ = sexp[1];
      if(_ai_ !== cst_None && _ai_ !== cst_none)
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aj_ = sexp[1];
     a:
     if(_aj_){
      var _ak_ = _aj_[1];
      if(0 === _ak_[0]){
       var _al_ = _ak_[1];
       if(_al_ !== cst_Some && _al_ !== cst_some) break a;
       var _am_ = _aj_[2];
       if(_am_ && ! _am_[2]){
        var el$0 = _am_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _ad_ = sexp[1];
     if(_ad_ !== cst_None && _ad_ !== cst_none)
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _ae_ = sexp[1];
     if(_ae_){
      var _af_ = _ae_[1];
      a:
      {
       if(_ae_[2]){
        b:
        if(0 === _af_[0]){
         var _ag_ = _af_[1];
         if(_ag_ !== cst_Some && _ag_ !== cst_some) break b;
         var _ah_ = _ae_[2];
         if(! _ah_[2]){var el = _ah_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _af_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _ab_ = sexp[1];
    if(_ab_){
     var _ac_ = _ab_[2];
     if(_ac_ && ! _ac_[2]){
      var
       b_sexp = _ac_[1],
       a_sexp = _ab_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var ___ = sexp[1];
    if(___){
     var _$_ = ___[2];
     if(_$_){
      var _aa_ = _$_[2];
      if(_aa_ && ! _aa_[2]){
       var
        c_sexp = _aa_[1],
        b_sexp = _$_[1],
        a_sexp = ___[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     rev_lst = caml_call2(Stdlib_ListLabels[21], a_of_sexp, lst);
    return caml_call1(Stdlib_ListLabels[9], rev_lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _Z_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _Z_;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _V_ = param[1];
      if(_V_){
       var _W_ = _V_[2];
       if(_W_ && ! _W_[2]){
        var
         v_sexp = _W_[1],
         k_sexp = _V_[1],
         _X_ = caml_call1(val_of_sexp, v_sexp),
         _Y_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _Y_, _X_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[17], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[1],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[2],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    _i_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _i_, name, file, line, chr)];
   }
   var
    _j_ = [0, "Sys.Break"],
    _k_ = [0, cst_src_sexp_conv_ml, 398, 15],
    _l_ = [0, "Stack.Empty"],
    _m_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _n_ = [0, "Scanf.Scan_failure"],
    _o_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _p_ = [0, "Queue.Empty"],
    _q_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _r_ = [0, "Parsing.Parse_error"],
    _s_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _t_ = [0, "Lazy.Undefined"],
    _u_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _v_ = [0, "Arg.Bad"],
    _w_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _x_ = [0, "Arg.Help"],
    _y_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _z_ = [0, "Sys_error"],
    _A_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _B_ = [0, "Not_found_s"],
    _C_ = [0, cst_src_sexp_conv_ml, 362, 15],
    cst_Match_failure = "Match_failure",
    _D_ = [0, cst_src_sexp_conv_ml, 358, 15],
    _E_ = [0, "Invalid_argument"],
    _F_ = [0, cst_src_sexp_conv_ml, 354, 15],
    _G_ = [0, "Not_found"],
    _H_ = [0, cst_src_sexp_conv_ml, 350, 15],
    _I_ = [0, "Failure"],
    _J_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _K_ = [0, "End_of_file"],
    _L_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _M_ = [0, "Exit"],
    _N_ = [0, cst_src_sexp_conv_ml, 338, 15],
    cst_Assert_failure = cst_Assert_failure$0,
    _O_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _P_ = [0, 0],
    _Q_ = [0, 0];
   caml_call2
    (Stdlib_ListLabels[17],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(_Q_, _P_, extension_constructor, handler);
     },
     [0,
      [0,
       Stdlib[5],
       function(param){
        if(param[1] !== Stdlib[5])
         throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
        var arg = param[2];
        return get_flc_error(cst_Assert_failure, arg);
       }],
      [0,
       [0,
        Stdlib[3],
        function(param){
         if(param === Stdlib[3]) return _M_;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
        }],
       [0,
        [0,
         Stdlib[12],
         function(param){
          if(param === Stdlib[12]) return _K_;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
         }],
        [0,
         [0,
          Stdlib[7],
          function(param){
           if(param[1] !== Stdlib[7])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
           var arg = param[2];
           return [1, [0, _I_, [0, [0, arg], 0]]];
          }],
         [0,
          [0,
           Stdlib[8],
           function(param){
            if(param === Stdlib[8]) return _G_;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
           }],
          [0,
           [0,
            Stdlib[6],
            function(param){
             if(param[1] !== Stdlib[6])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
             var arg = param[2];
             return [1, [0, _E_, [0, [0, arg], 0]]];
            }],
           [0,
            [0,
             Stdlib[4],
             function(param){
              if(param[1] !== Stdlib[4])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
              var arg = param[2];
              return get_flc_error(cst_Match_failure, arg);
             }],
            [0,
             [0,
              Sexplib0_Sexp[5],
              function(param){
               if(param[1] !== Sexplib0_Sexp[5])
                throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
               var arg = param[2];
               return [1, [0, _B_, [0, arg, 0]]];
              }],
             [0,
              [0,
               Stdlib[11],
               function(param){
                if(param[1] !== Stdlib[11])
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _A_], 1);
                var arg = param[2];
                return [1, [0, _z_, [0, [0, arg], 0]]];
               }],
              [0,
               [0,
                Stdlib_Arg[7],
                function(param){
                 if(param[1] !== Stdlib_Arg[7])
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _y_], 1);
                 var arg = param[2];
                 return [1, [0, _x_, [0, [0, arg], 0]]];
                }],
               [0,
                [0,
                 Stdlib_Arg[8],
                 function(param){
                  if(param[1] !== Stdlib_Arg[8])
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _w_], 1);
                  var arg = param[2];
                  return [1, [0, _v_, [0, [0, arg], 0]]];
                 }],
                [0,
                 [0,
                  Stdlib_Lazy[1],
                  function(param){
                   if(param === Stdlib_Lazy[1]) return _t_;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _u_], 1);
                  }],
                 [0,
                  [0,
                   Stdlib_Parsing[10],
                   function(param){
                    if(param === Stdlib_Parsing[10]) return _r_;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _s_], 1);
                   }],
                  [0,
                   [0,
                    Stdlib_Queue[1],
                    function(param){
                     if(param === Stdlib_Queue[1]) return _p_;
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _q_], 1);
                    }],
                   [0,
                    [0,
                     Stdlib_Scanf[2],
                     function(param){
                      if(param[1] !== Stdlib_Scanf[2])
                       throw caml_maybe_attach_backtrace
                              ([0, Assert_failure, _o_], 1);
                      var arg = param[2];
                      return [1, [0, _n_, [0, [0, arg], 0]]];
                     }],
                    [0,
                     [0,
                      Stdlib_Stack[1],
                      function(param){
                       if(param === Stdlib_Stack[1]) return _l_;
                       throw caml_maybe_attach_backtrace
                              ([0, Assert_failure, _m_], 1);
                      }],
                     [0,
                      [0,
                       Stdlib_Sys[44],
                       function(param){
                        if(param === Stdlib_Sys[44]) return _j_;
                        throw caml_maybe_attach_backtrace
                               ([0, Assert_failure, _k_], 1);
                       }],
                      0]]]]]]]]]]]]]]]]]);
   var
    _R_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _S_ = [0, cst_src_sexp_conv_ml, 410, 15],
    _T_ = [0, 0],
    _U_ = [0, 1];
   caml_call2
    (Stdlib_ListLabels[17],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(_U_, _T_, extension_constructor, handler);
     },
     [0,
      [0,
       Of_sexp_error,
       function(param){
        if(param[1] !== Of_sexp_error)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
        var sexp = param[3], exc = param[2];
        return [1, [0, _R_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
       }],
      0]);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    _a_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]]],
       "%s_of_sexp: tuple of size %d expected"],
    cst_of_sexp_this_constructor_d =
      "_of_sexp: this constructor does not take arguments",
    _b_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: sum tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: sum tag %S has incorrect number of arguments"],
    cst_of_sexp_this_constructor_r =
      "_of_sexp: this constructor requires arguments",
    cst_of_sexp_expected_a_variant =
      "_of_sexp: expected a variant type, saw a nested list",
    cst_of_sexp_expected_a_variant$0 =
      "_of_sexp: expected a variant type, saw an empty list",
    cst_of_sexp_unexpected_variant =
      "_of_sexp: unexpected variant constructor",
    cst_of_sexp_record_conversion_ =
      "_of_sexp: record conversion: a [sexp.bool] field was given a payload.",
    cst_of_sexp_record_conversion_$0 =
      "_of_sexp: record conversion: only pairs expected, their first element must be an atom",
    _c_ =
      [0,
       [2, 0, [11, "_of_sexp: ", [2, 0, [11, ": ", [2, 0, 0]]]]],
       "%s_of_sexp: %s: %s"],
    cst_duplicate_fields = "duplicate fields",
    cst_extra_fields = "extra fields",
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: the following record elements were undefined: ",
         [2, 0, 0]]],
       "%s_of_sexp: the following record elements were undefined: %s"],
    cst_of_sexp_list_instead_of_at =
      "_of_sexp: list instead of atom for record expected",
    cst_of_sexp_cannot_convert_val =
      "_of_sexp: cannot convert values of types resulting from polymorphic record fields";
   function tuple_of_size_n_expected(loc, n, sexp){
    var _t_ = caml_call3(Stdlib_Printf[4], _a_, loc, n);
    return caml_call2(Sexplib0_Sexp_conv[27], _t_, sexp);
   }
   function stag_no_args(loc, sexp){
    var _s_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_d);
    return caml_call2(Sexplib0_Sexp_conv[27], _s_, sexp);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _b_, loc, tag);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_takes_args(loc, sexp){
    var _r_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_r);
    return caml_call2(Sexplib0_Sexp_conv[27], _r_, sexp);
   }
   function nested_list_invalid_sum(loc, sexp){
    var _q_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _q_, sexp);
   }
   function empty_list_invalid_sum(loc, sexp){
    var _p_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _p_, sexp);
   }
   function unexpected_stag(loc, sexp){
    var _o_ = caml_call2(Stdlib[28], loc, cst_of_sexp_unexpected_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _o_, sexp);
   }
   function record_sexp_bool_with_payload(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_only_pairs_expected(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_superfluous_fields(what, loc, rev_fld_names, sexp){
    var
     _n_ = caml_call1(Stdlib_ListLabels[9], rev_fld_names),
     fld_names_str = caml_call2(Stdlib_StringLabels[6], cst, _n_),
     msg = caml_call4(Stdlib_Printf[4], _c_, loc, what, fld_names_str);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_duplicate_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_duplicate_fields, loc, rev_fld_names, sexp);
   }
   function record_extra_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_extra_fields, loc, rev_fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _m_ = caml_call1(Stdlib_ListLabels[9], fields$0);
      return caml_call2(Stdlib_StringLabels[6], cst$0, _m_);
     }
     var _l_ = param$0[1];
     if(_l_[1]){
      var rest = param$0[2], field = _l_[2], fields$1 = [0, field, fields$0];
      fields$0 = fields$1;
      param$0 = rest;
     }
     else{var rest$0 = param$0[2]; param$0 = rest$0;}
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call3(Stdlib_Printf[4], _d_, loc, undefined$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_list_instead_atom(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_list_instead_of_at);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_poly_field_value(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_cannot_convert_val);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   var
    No_variant_match =
      [248,
       "Sexplib0__Sexp_conv_error.No_variant_match",
       runtime.caml_fresh_oo_id(0)],
    cst_of_sexp_no_matching_varian = "_of_sexp: no matching variant found",
    cst_of_sexp_polymorphic_varian =
      "_of_sexp: polymorphic variant does not take arguments",
    _e_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: polymorphic variant tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"],
    cst_of_sexp_polymorphic_varian$0 =
      "_of_sexp: polymorphic variant tag takes an argument",
    cst_of_sexp_a_nested_list_is_a =
      "_of_sexp: a nested list is an invalid polymorphic variant",
    cst_of_sexp_the_empty_list_is_ =
      "_of_sexp: the empty list is an invalid polymorphic variant",
    cst_of_sexp_trying_to_convert_ =
      "_of_sexp: trying to convert an empty type";
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){
    var _k_ = caml_call2(Stdlib[28], loc, cst_of_sexp_no_matching_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _k_, sexp);
   }
   function ptag_no_args(loc, sexp){
    var _j_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _j_, sexp);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _e_, loc, cnstr);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function ptag_takes_args(loc, sexp){
    var _i_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _i_, sexp);
   }
   function nested_list_invalid_poly_var(loc, sexp){
    var _h_ = caml_call2(Stdlib[28], loc, cst_of_sexp_a_nested_list_is_a);
    return caml_call2(Sexplib0_Sexp_conv[27], _h_, sexp);
   }
   function empty_list_invalid_poly_var(loc, sexp){
    var _g_ = caml_call2(Stdlib[28], loc, cst_of_sexp_the_empty_list_is_);
    return caml_call2(Sexplib0_Sexp_conv[27], _g_, sexp);
   }
   function empty_type(loc, sexp){
    var _f_ = caml_call2(Stdlib[28], loc, cst_of_sexp_trying_to_convert_);
    return caml_call2(Sexplib0_Sexp_conv[27], _f_, sexp);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (30, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsImNvZXJjZSIsInVuaXRfc2V4cF9ncmFtbWFyIiwic2V4cF90X3NleHBfZ3JhbW1hciIsImVtcHR5X3NleHBfZ3JhbW1hciIsInJlZl9zZXhwX2dyYW1tYXIiLCJncmFtbWFyIiwibGF6eV90X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9zZXhwX2dyYW1tYXIiLCJwYXJhbSIsImxpc3Rfc2V4cF9ncmFtbWFyIiwiYXJyYXlfc2V4cF9ncmFtbWFyIiwiZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQiLCJyZWFkX29sZF9vcHRpb25fZm9ybWF0Iiwid3JpdGVfb2xkX29wdGlvbl9mb3JtYXQiLCJsaXN0X21hcCIsImYiLCJsIiwic2V4cF9vZl91bml0Iiwic2V4cF9vZl9ib29sIiwic2V4cF9vZl9zdHJpbmciLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXMiLCJzZXhwX29mX2NoYXIiLCJzZXhwX29mX2ludCIsInNleHBfb2ZfZmxvYXQiLCJzZXhwX29mX2ludDMyIiwic2V4cF9vZl9pbnQ2NCIsInNleHBfb2ZfbmF0aXZlaW50Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX2EiLCJyZiIsInNleHBfb2ZfbGF6eV90IiwibHYiLCJzZXhwX29mX29wdGlvbiIsInNleHBfb2ZfcGFpciIsInNleHBfb2ZfYiIsInNleHBfb2ZfdHJpcGxlIiwic2V4cF9vZl9jIiwic2V4cF9vZl9saXN0Iiwic2V4cF9vZl9hcnJheSIsImFyIiwibHN0X3JlZiIsInNleHBfb2ZfaGFzaHRibCIsInNleHBfb2Zfa2V5Iiwic2V4cF9vZl92YWwiLCJodGJsIiwiY29sbCIsImsiLCJzZXhwX29mX29wYXF1ZSIsInNleHBfb2ZfZnVuIiwiaGFzaCIsInRoZV9leG5fdGFibGUiLCJhZGQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJzZXhwX29mX2V4biIsInByaW50ZXhjIiwiZmluZF9hdXRvIiwiZm9yX3ByaW50ZXhjIiwiZXhuIiwic2V4cF9vZl9leG5fb3B0IiwiZXhuX3RvX3N0cmluZyIsImUiLCJwcmludGV4Y19wcmVmZXJfc2V4cCIsInJlY29yZF9jaGVja19leHRyYV9maWVsZHMiLCJvZl9zZXhwX2Vycm9yX2V4biIsImV4YyIsIm9mX3NleHBfZXJyb3IiLCJ3aGF0IiwidW5pdF9vZl9zZXhwIiwiYm9vbF9vZl9zZXhwIiwic3RyaW5nX29mX3NleHAiLCJieXRlc19vZl9zZXhwIiwiY2hhcl9vZl9zZXhwIiwiaW50X29mX3NleHAiLCJleGMkMCIsImZsb2F0X29mX3NleHAiLCJpbnQzMl9vZl9zZXhwIiwiaW50NjRfb2Zfc2V4cCIsIm5hdGl2ZWludF9vZl9zZXhwIiwicmVmX29mX3NleHAiLCJhX29mX3NleHAiLCJsYXp5X3Rfb2Zfc2V4cCIsIm9wdGlvbl9vZl9zZXhwIiwiZWwkMCIsImVsIiwicGFpcl9vZl9zZXhwIiwiYl9vZl9zZXhwIiwiYl9zZXhwIiwiYV9zZXhwIiwidHJpcGxlX29mX3NleHAiLCJjX29mX3NleHAiLCJjX3NleHAiLCJsaXN0X29mX3NleHAiLCJyZXZfbHN0IiwiYXJyYXlfb2Zfc2V4cCIsImhhc2h0Ymxfb2Zfc2V4cCIsImtleV9vZl9zZXhwIiwidmFsX29mX3NleHAiLCJhY3QiLCJ2X3NleHAiLCJrX3NleHAiLCJvcGFxdWVfb2Zfc2V4cCIsImZ1bl9vZl9zZXhwIiwiZ2V0X2ZsY19lcnJvciIsImNociIsImxpbmUiLCJmaWxlIiwiaGFuZGxlciIsImFyZyIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsImxvYyIsInN0YWdfbm9fYXJncyIsInN0YWdfaW5jb3JyZWN0X25fYXJncyIsInRhZyIsIm1zZyIsInN0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSIsInVuZXhwZWN0ZWRfc3RhZyIsInJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIiwicmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQiLCJyZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIiwicmV2X2ZsZF9uYW1lcyIsImZsZF9uYW1lc19zdHIiLCJyZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyIsInJlY29yZF9leHRyYV9maWVsZHMiLCJyZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIiwiZmllbGRzJDAiLCJmaWVsZCIsInJlc3QkMCIsInJlY29yZF91bmRlZmluZWRfZWxlbWVudHMiLCJ1bmRlZmluZWQkMCIsInJlY29yZF9saXN0X2luc3RlYWRfYXRvbSIsInJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIiwibm9fdmFyaWFudF9tYXRjaCIsIm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQiLCJwdGFnX25vX2FyZ3MiLCJwdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJjbnN0ciIsInB0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV90eXBlIl0sInNvdXJjZXMiOlsiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3NleHBsaWIwL3NleHAubWwiLCIvVXNlcnMvamFjb2J6aWZmLy5vcGFtL2RpeS1oYXplbG51dC9saWIvc2V4cGxpYjAvc2V4cF9ncmFtbWFyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3NleHBsaWIwL3NleHBfY29udl9ncmFtbWFyLm1sIiwiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3NleHBsaWIwL3NleHBfY29udi5tbCIsIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZXJyb3IubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQWVJQSxVQUFVQyxHQUFJLE9BQUpBLEVB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LEtBQUkzSTtJQUNwQixVQUFBLHVCQURnQjJJO0lBQzlCLE9BQUEsd0NBRGtDM0k7R0FDcUQ7WUFHckYySyxXQUFXaEMsS0FBSTNJO0lBQ0gsVUFBQSx1QkFERDJJO0lBQ2IsT0FBQSx3Q0FEaUIzSTtHQUNxRDs7Ozs7T0EvSHBFMEk7T0FNQUU7T0FJQUM7T0FLQUc7T0FJQUM7T0FJQUM7T0FJQUM7T0FNQUM7T0FPQUM7T0FTQUM7T0FNQUc7T0FJQUM7T0FJSUM7T0FNSkk7T0FRQUU7T0FLQUM7O09BWUFDO09BRUFDO09BSUFDO09BSUFDO09BVUFFO09BSUFDO09BSUFDO09BSUFDOzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuKCogYmxpdF9zdHJpbmcgZG9lc24ndCBleGlzdCBpbiBbU3RkTGFiZWxzLkJ5dGVzXS4uLiAgKilcbmxldCBieXRlc19ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuOztcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gRm9ybWF0XG5cbigqKiBUeXBlIG9mIFMtZXhwcmVzc2lvbnMgKilcbnR5cGUgdCA9XG4gIHwgQXRvbSBvZiBzdHJpbmdcbiAgfCBMaXN0IG9mIHQgbGlzdFxuXG5sZXQgc2V4cF9vZl90IHQgPSB0XG5sZXQgdF9vZl9zZXhwIHQgPSB0XG5cbmxldCByZWMgY29tcGFyZV9saXN0IGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCByZXMgPSBjb21wYXJlIHggeSBpblxuICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0IHhzIHlzXG5cbmFuZCBjb21wYXJlIGEgYiA9XG4gIGlmIGEgPT0gYlxuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBBdG9tIGEsIEF0b20gYiAtPiBTdHJpbmcuY29tcGFyZSBhIGJcbiAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICB8IExpc3QgYSwgTGlzdCBiIC0+IGNvbXBhcmVfbGlzdCBhIGIpXG47O1xuXG5sZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyBvZiB0XG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciBvZiBleG4gKiB0XG5cbm1vZHVsZSBQcmludGluZyA9IHN0cnVjdFxuICAoKiBEZWZhdWx0IGluZGVudGF0aW9uIGxldmVsIGZvciBodW1hbi1yZWFkYWJsZSBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCBkZWZhdWx0X2luZGVudCA9IHJlZiAxXG5cbiAgKCogRXNjYXBpbmcgb2Ygc3RyaW5ncyB1c2VkIGFzIGF0b21zIGluIFMtZXhwcmVzc2lvbnMgKilcblxuICBsZXQgbXVzdF9lc2NhcGUgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZW4gPSAwXG4gICAgfHxcbiAgICBsZXQgcmVjIGxvb3Agc3RyIGl4ID1cbiAgICAgIG1hdGNoIHN0ci5baXhdIHdpdGhcbiAgICAgIHwgJ1wiJyB8ICcoJyB8ICcpJyB8ICc7JyB8ICdcXFxcJyAtPiB0cnVlXG4gICAgICB8ICd8JyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICcjJyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICcjJyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICd8JyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICdcXDAwMCcgLi4gJ1xcMDMyJyB8ICdcXDEyNycgLi4gJ1xcMjU1JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gaXggPiAwICYmIGxvb3Agc3RyIChpeCAtIDEpXG4gICAgaW5cbiAgICBsb29wIHN0ciAobGVuIC0gMSlcbiAgOztcblxuICBsZXQgZXNjYXBlZCBzID1cbiAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG5cbiAgICAgIDo9ICFuXG4gICAgICAgICArXG4gICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgICAgfCBfIC0+IDRcbiAgICBkb25lO1xuICAgIGlmICFuID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcycgPSBCeXRlcy5jcmVhdGUgIW4gaW5cbiAgICAgIG4gOj0gMDtcbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIChtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgICAgfCAnICcgLi4gJ34nIGFzIGMgLT4gQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8IGMgLT5cbiAgICAgICAgICAgbGV0IGEgPSBDaGFyLmNvZGUgYyBpblxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwIG1vZCAxMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSBtb2QgMTApKSkpO1xuICAgICAgICBpbmNyIG5cbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMnKVxuICA7O1xuXG4gIGxldCBlc2Nfc3RyIHN0ciA9XG4gICAgbGV0IGVzdHIgPSBlc2NhcGVkIHN0ciBpblxuICAgIGxldCBlbGVuID0gU3RyaW5nLmxlbmd0aCBlc3RyIGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSAoZWxlbiArIDIpIGluXG4gICAgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYzplc3RyIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6MSB+bGVuOmVsZW47XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgMCAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIChlbGVuICsgMSkgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICA7O1xuXG4gIGxldCBpbmRleF9vZl9uZXdsaW5lIHN0ciBzdGFydCA9XG4gICAgdHJ5IFNvbWUgKFN0cmluZy5pbmRleF9mcm9tIHN0ciBzdGFydCAnXFxuJykgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IE5vbmVcbiAgOztcblxuICBsZXQgZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggZW5kX3Bvc19vcHQgPVxuICAgIGxldCBlbmRfcG9zID1cbiAgICAgIG1hdGNoIGVuZF9wb3Nfb3B0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgfCBTb21lIGVuZF9wb3MgLT4gZW5kX3Bvc1xuICAgIGluXG4gICAgU3RyaW5nLnN1YiBzdHIgfnBvczppbmRleCB+bGVuOihlbmRfcG9zIC0gaW5kZXgpXG4gIDs7XG5cbiAgbGV0IGlzX29uZV9saW5lIHN0ciA9XG4gICAgbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgaW5kZXggLT4gaW5kZXggKyAxID0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgOztcblxuICBsZXQgcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0ciA9XG4gICAgaWYgbm90IChtdXN0X2VzY2FwZSBzdHIpXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIHN0clxuICAgIGVsc2UgaWYgaXNfb25lX2xpbmUgc3RyXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIChlc2Nfc3RyIHN0cilcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpbmRleCA9XG4gICAgICAgIGxldCBuZXh0X25ld2xpbmUgPSBpbmRleF9vZl9uZXdsaW5lIHN0ciBpbmRleCBpblxuICAgICAgICBsZXQgbmV4dF9saW5lID0gZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggbmV4dF9uZXdsaW5lIGluXG4gICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY2FwZWQgbmV4dF9saW5lKTtcbiAgICAgICAgbWF0Y2ggbmV4dF9uZXdsaW5lIHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBuZXdsaW5lX2luZGV4IC0+XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxcIjtcbiAgICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKTtcbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXG5cIjtcbiAgICAgICAgICBsb29wIChuZXdsaW5lX2luZGV4ICsgMSlcbiAgICAgIGluXG4gICAgICBwcF9vcGVuX2JveCBwcGYgMDtcbiAgICAgICgqIHRoZSBsZWFkaW5nIHNwYWNlIGlzIHRvIGxpbmUgdXAgdGhlIGxpbmVzICopXG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFxcXCJcIjtcbiAgICAgIGxvb3AgMDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFwiXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpKVxuICA7O1xuXG4gIGxldCBtYWNoX21heWJlX2VzY19zdHIgc3RyID0gaWYgbXVzdF9lc2NhcGUgc3RyIHRoZW4gZXNjX3N0ciBzdHIgZWxzZSBzdHJcblxuICAoKiBPdXRwdXQgb2YgUy1leHByZXNzaW9ucyB0byBmb3JtYXR0ZXJzICopXG5cbiAgbGV0IHJlYyBwcF9odW1faW5kZW50IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0clxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfb3Blbl9ib3ggcHBmIGluZGVudDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgTGlzdCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIlxuXG4gIGFuZCBwcF9odW1fcmVzdCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgcHBfcHJpbnRfc3BhY2UgcHBmICgpO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKVxuICA7O1xuXG4gIGxldCByZWMgcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFwiO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHInO1xuICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0O1xuICAgICAgZmFsc2VcbiAgICB8IExpc3QgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiO1xuICAgICAgZmFsc2VcblxuICBhbmQgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdFxuICAgIHwgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIlxuICA7O1xuXG4gIGxldCBwcF9odW0gcHBmIHNleHAgPSBwcF9odW1faW5kZW50ICFkZWZhdWx0X2luZGVudCBwcGYgc2V4cFxuICBsZXQgcHBfbWFjaCBwcGYgc2V4cCA9IGlnbm9yZSAocHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgc2V4cClcbiAgbGV0IHBwID0gcHBfbWFjaFxuXG4gICgqIFNleHAgc2l6ZSAqKVxuXG4gIGxldCByZWMgc2l6ZV9sb29wICgodiwgYykgYXMgYWNjKSA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiB2ICsgMSwgYyArIFN0cmluZy5sZW5ndGggc3RyXG4gICAgfCBMaXN0IGxzdCAtPiBMaXN0LmZvbGRfbGVmdCBsc3QgfmluaXQ6YWNjIH5mOnNpemVfbG9vcFxuICA7O1xuXG4gIGxldCBzaXplIHNleHAgPSBzaXplX2xvb3AgKDAsIDApIHNleHBcblxuICAoKiBCdWZmZXIgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fYnVmZmVyX2h1bSB+YnVmID8oaW5kZW50ID0gIWRlZmF1bHRfaW5kZW50KSBzZXhwID1cbiAgICBsZXQgcHBmID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gICAgRm9ybWF0LmZwcmludGYgcHBmIFwiJWFAP1wiIChwcF9odW1faW5kZW50IGluZGVudCkgc2V4cFxuICA7O1xuXG4gIGxldCB0b19idWZmZXJfbWFjaCB+YnVmIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gIGxldCB0b19idWZmZXIgPSB0b19idWZmZXJfbWFjaFxuXG4gIGxldCB0b19idWZmZXJfZ2VuIH5idWYgfmFkZF9jaGFyIH5hZGRfc3RyaW5nIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBhZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICAoKiBUaGUgbWF4aW11bSBzaXplIG9mIGEgdGhpbmcgb24gdGhlIG1pbm9yIGhlYXAgaXMgMjU2IHdvcmRzLlxuICAgICBQcmV2aW91c2x5LCB0aGlzIHNpemUgb2YgdGhlIHJldHVybmVkIGJ1ZmZlciBoZXJlIHdhcyA0MDk2IGJ5dGVzLCB3aGljaFxuICAgICBjYXVzZWQgdGhlIEJ1ZmZlciB0byBiZSBhbGxvY2F0ZWQgb24gdGhlICptYWpvciogaGVhcCBldmVyeSB0aW1lLlxuXG4gICAgIEFjY29yZGluZyB0byBhIHNpbXBsZSBiZW5jaG1hcmsgYnkgUm9uLCB3ZSBjYW4gaW1wcm92ZSBwZXJmb3JtYW5jZSBmb3JcbiAgICAgc21hbGwgcy1leHByZXNzaW9ucyBieSBhIGZhY3RvciBvZiB+NCBpZiB3ZSBvbmx5IGFsbG9jYXRlIDEwMjQgYnl0ZXNcbiAgICAgKDEyOCB3b3JkcyArIHNvbWUgc21hbGwgb3ZlcmhlYWQpIHdvcnRoIG9mIGJ1ZmZlciBpbml0aWFsbHkuICBBbmQgb25lXG4gICAgIGNhbiBhcmd1ZSB0aGF0IGlmIGl0J3MgZnJlZSB0byBhbGxvY2F0ZSBzdHJpbmdzIHNtYWxsZXIgdGhhbiAyNTYgd29yZHMsXG4gICAgIGxhcmdlIHMtZXhwcmVzc2lvbnMgcmVxdWlyaW5nIGxhcmdlciBleHBlbnNpdmUgYnVmZmVycyB3b24ndCBub3RpY2VcbiAgICAgdGhlIGV4dHJhIHR3byBkb3VibGluZ3MgZnJvbSAxMDI0IGJ5dGVzIHRvIDIwNDggYW5kIDQwOTYuIEFuZCBlc3BlY2lhbGx5XG4gICAgIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgdG8gYWx3YXlzIHBhc3MgaW4gYSBsYXJnZXIgYnVmZmVyIHRvXG4gICAgIHVzZS4gKilcbiAgbGV0IGJ1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgMTAyNFxuXG4gICgqIFN0cmluZyBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19zdHJpbmdfaHVtID9pbmRlbnQgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHJcbiAgICAgIHdoZW4gbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgIHwgU29tZSBfIC0+IGZhbHNlIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9odW0gP2luZGVudCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ19tYWNoID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9tYWNoIHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nX21hY2hcbmVuZFxuXG5pbmNsdWRlIFByaW50aW5nXG5cbmxldCBvZl9mbG9hdF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xubGV0IG9mX2ludF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBpbmNsdWRlIFByaW50aW5nXG5lbmRcblxubGV0IG1lc3NhZ2UgbmFtZSBmaWVsZHMgPVxuICBsZXQgcmVjIGNvbnZfZmllbGRzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCAoZm5hbWUsIGZzZXhwKSA6OiByZXN0IC0+XG4gICAgICAobWF0Y2ggZm5hbWUgd2l0aFxuICAgICAgIHwgXCJcIiAtPiBmc2V4cCA6OiBjb252X2ZpZWxkcyByZXN0XG4gICAgICAgfCBfIC0+IExpc3QgWyBBdG9tIGZuYW1lOyBmc2V4cCBdIDo6IGNvbnZfZmllbGRzIHJlc3QpXG4gIGluXG4gIExpc3QgKEF0b20gbmFtZSA6OiBjb252X2ZpZWxkcyBmaWVsZHMpXG47O1xuIiwiKCoqIFJlcHJlc2VudGF0aW9uIG9mIFMtZXhwcmVzc2lvbiBncmFtbWFycyAqKVxuXG4oKiogVGhpcyBtb2R1bGUgZGVmaW5lcyBhIHJlcHJlc2VudGF0aW9uIGZvciBzLWV4cHJlc3Npb24gZ3JhbW1hcnMuIFVzaW5nIHBweF9zZXhwX2NvbnZcbiAgICBhbmQgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHByb2R1Y2VzIGEgZ3JhbW1hciB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZGVyaXZlZFxuICAgIFtvZl9zZXhwXSBmb3IgYSBnaXZlbiB0eXBlLlxuXG4gICAgQXMgd2l0aCBvdGhlciBkZXJpdmVkIGRlZmluaXRpb25zLCBwb2x5bW9ycGhpYyB0eXBlcyBkZXJpdmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFcbiAgICBncmFtbWFyIGZvciBlYWNoIHR5cGUgYXJndW1lbnQgYW5kIHByb2R1Y2VzIGEgZ3JhbW1hciBmb3IgdGhlIG1vbm9tb3JwaGl6ZWQgdHlwZS5cblxuICAgIE1vbm9tb3JwaGljIHR5cGVzIGRlcml2ZSBhIGdyYW1tYXIgZGlyZWN0bHkuIFRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMsXG4gICAgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHdyYXBzIGdyYW1tYXJzIGluIHRoZSBbTGF6eV0gY29uc3RydWN0b3IgYXMgbmVlZGVkLlxuXG4gICAgVGhpcyB0eXBlIG1heSBjaGFuZ2Ugb3ZlciB0aW1lIGFzIG91ciBuZWVkcyBmb3IgZXhwcmVzc2l2ZSBncmFtbWFycyBjaGFuZ2UuIFdlIHdpbGxcbiAgICBhdHRlbXB0IHRvIG1ha2UgY2hhbmdlcyBiYWNrd2FyZC1jb21wYXRpYmxlLCBvciBhdCBsZWFzdCBwcm92aWRlIGEgcmVhc29uYWJsZSB1cGdyYWRlXG4gICAgcGF0aC4gKilcblxuW0BAQHdhcm5pbmcgXCItMzBcIl0gKCogYWxsb3cgZHVwbGljYXRlIGZpZWxkIG5hbWVzICopXG5cbigqKiBHcmFtbWFyIG9mIGEgc2V4cC4gKilcbnR5cGUgZ3JhbW1hciA9XG4gIHwgQW55IG9mIHN0cmluZyAoKiogYWNjZXB0cyBhbnkgc2V4cDsgc3RyaW5nIGlzIGEgdHlwZSBuYW1lIGZvciBodW1hbiByZWFkYWJpbGl0eSAqKVxuICB8IEJvb2wgKCoqIGFjY2VwdHMgdGhlIGF0b21zIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIiwgbW9kdWxvIGNhcGl0YWxpemF0aW9uICopXG4gIHwgQ2hhciAoKiogYWNjZXB0cyBhbnkgc2luZ2xlLWNoYXJhY3RlciBhdG9tICopXG4gIHwgSW50ZWdlciAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBpbnRlZ2VyIHN5bnRheCwgcmVnYXJkbGVzcyBvZiBiaXQgd2lkdGggKilcbiAgfCBGbG9hdCAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBmbG9hdCBzeW50YXggKilcbiAgfCBTdHJpbmcgKCoqIGFjY2VwdHMgYW55IGF0b20gKilcbiAgfCBPcHRpb24gb2YgZ3JhbW1hciAoKiogYWNjZXB0cyBhbiBvcHRpb24sIGJvdGggW05vbmVdIHZzIFtTb21lIF9dIGFuZCBbKCldIHZzIFsoXyldLiAqKVxuICB8IExpc3Qgb2YgbGlzdF9ncmFtbWFyICgqKiBhY2NlcHRzIGEgbGlzdCAqKVxuICB8IFZhcmlhbnQgb2YgdmFyaWFudCAoKiogYWNjZXB0cyBjbGF1c2VzIGtleWVkIGJ5IGEgbGVhZGluZyBvciBzb2xlIGF0b20gKilcbiAgfCBVbmlvbiBvZiBncmFtbWFyIGxpc3QgKCoqIGFjY2VwdHMgYSBzZXhwIGlmIGFueSBvZiB0aGUgbGlzdGVkIGdyYW1tYXJzIGFjY2VwdHMgaXQgKilcbiAgfCBUYWdnZWQgb2YgZ3JhbW1hciB3aXRoX3RhZ1xuICAoKiogYW5ub3RhdGVzIGEgZ3JhbW1hciB3aXRoIGEgY2xpZW50LXNwZWNpZmljIGtleS92YWx1ZSBwYWlyICopXG4gIHwgVHl2YXIgb2Ygc3RyaW5nXG4gICgqKiBOYW1lIG9mIGEgdHlwZSB2YXJpYWJsZSwgZS5nLiBbVHl2YXIgXCJhXCJdIGZvciBbJ2FdLiBPbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgYm9keSBvZlxuICAgICAgdGhlIGlubmVybW9zdCBlbmNsb3NpbmcgW2RlZm5dIGRlZmluZXMgYSBjb3JyZXNwb25kaW5nIHR5cGUgdmFyaWFibGUuICopXG4gIHwgVHljb24gb2Ygc3RyaW5nICogZ3JhbW1hciBsaXN0XG4gICgqKiBUeXBlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdG8gYXJndW1lbnRzLiBGb3IgZXhhbXBsZSwgW1R5Y29uIChcImxpc3RcIiwgWyBJbnRlZ2VyIF0pXVxuICAgICAgcmVwcmVzZW50cyBbaW50IGxpc3RdLiBPbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbUmVjdXJzaXZlXVxuICAgICAgZ3JhbW1hciBkZWZpbmVzIGEgY29ycmVzcG9uZGluZyB0eXBlIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlY3Vyc2l2ZSBvZiBncmFtbWFyICogZGVmbiBsaXN0XG4gICgqKiBbUmVjdXJzaXZlIChncmFtbWFyLCBkZWZpbml0aW9ucyldIGFsbG93cyBbZ3JhbW1hcl0gdG8gcmVmZXIgdG8gdHlwZSBjb25zdHJ1Y3RvcnNcbiAgICAgIGZyb20gdGhlIG11dHVhbGx5IHJlY3Vyc2l2ZSBbZGVmaW5pdGlvbnNdLiBUaGUgZGVmaW5pdGlvbnMgbWF5IGFsc28gcmVmZXIgdG8gZWFjaFxuICAgICAgb3RoZXJzJyB0eXBlIGNvbnN0cnVjdG9ycy5cblxuICAgICAgT3JkaW5hcmlseSwgW2dyYW1tYXJdIGl0c2VsZiBpcyBqdXN0IGEgW1R5Y29uXSBhcmd1bWVudCwgYWx0aG91Z2ggdGVjaG5pY2FsbHkgaXQgY2FuXG4gICAgICBiZSBhbnkgZ3JhbW1hci5cblxuICAgICAgRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgZGVmaW5pdGlvbnMgZGVmaW5lIGEgYmluYXJ5IHRyZWUgcGFyYW1ldGVyaXplZCBieSBhIHR5cGVcbiAgICAgIHN0b3JlZCBhdCBpdHMgbGVhdmVzLlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgZGVmbnMgPVxuICAgICAgICAgIFsgeyB0eWNvbiA9IFwidHJlZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICAgICAgVmFyaWFudFxuICAgICAgICAgICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICBbIHsgbmFtZSA9IFwiTm9kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiVHJlZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJub2RlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gTGlzdCAoTWFueSAoVHljb24gXCJ0cmVlXCIsIFtUeXZhciBcImFcIl0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibGVhZlwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IFtUeXZhciBcImFcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIDs7XG4gICAgICBdfVxuXG4gICAgICBOb3JtYWxseSwgdGhlIHR5cGUgb2YgYSB0cmVlIHN0b3JpbmcgaW50ZWdlcnMgd291bGQgYmUgd3JpdHRlbiBsaWtlIHRoaXM6XG5cbiAgICAgIHtbXG4gICAgICAgIFJlY3Vyc2l2ZSAoVHljb24gKFwidHJlZVwiLCBbIEludGVnZXIgXSksIGRlZm5zKVxuICAgICAgXX1cblxuICAgICAgSXQgaXMgZXF1aXZhbGVudCwgdGhvdWdoIG5lZWRsZXNzbHkgdmVyYm9zZSwgdG8gcmVwbGFjZSB0aGUgW1R5Y29uXSByZWZlcmVuY2Ugd2l0aFxuICAgICAgdGhlIGdyYW1tYXIgb2YgW1widHJlZVwiXSwgc3Vic3RpdHV0aW5nIFtJbnRlZ2VyXSBmb3IgW1R5dmFyIFwiYVwiXTpcblxuICAgICAge1tcbiAgICAgICAgUmVjdXJzaXZlXG4gICAgICAgICAgKCBWYXJpYW50XG4gICAgICAgICAgICAgIHsgbmFtZV9raW5kID0gQ2FwaXRhbGl6ZWRcbiAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibm9kZVwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJUcmVlXCJcbiAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICwgZGVmbnMgKVxuICAgICAgXX1cbiAgKilcbiAgfCBMYXp5IG9mIGdyYW1tYXIgbGF6eV90XG4gICgqKiBMYXppbHkgY29tcHV0ZWQgZ3JhbW1hci4gVXNlIFtMYXp5XSB0byBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLiBUbyBkZWZpbmVcbiAgICAgIHJlY3Vyc2l2ZSBncmFtbWFycywgdXNlIFtSZWN1cnNpdmVdIGluc3RlYWQuICopXG5cbigqKiBHcmFtbWFyIG9mIGEgbGlzdCBvZiBzZXhwcy4gKilcbmFuZCBsaXN0X2dyYW1tYXIgPVxuICB8IEVtcHR5ICgqKiBhY2NlcHRzIGFuIGVtcHR5IGxpc3Qgb2Ygc2V4cHMgKilcbiAgfCBDb25zIG9mIGdyYW1tYXIgKiBsaXN0X2dyYW1tYXJcbiAgKCoqIGFjY2VwdHMgYSBub24tZW1wdHkgbGlzdCB3aXRoIGhlYWQgYW5kIHRhaWwgbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXJzICopXG4gIHwgTWFueSBvZiBncmFtbWFyICgqKiBhY2NlcHRzIHplcm8gb3IgbW9yZSBzZXhwcywgZWFjaCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hciAqKVxuICB8IEZpZWxkcyBvZiByZWNvcmQgKCoqIGFjY2VwdHMgc2V4cHMgcmVwcmVzZW50aW5nIGZpZWxkcyBvZiBhIHJlY29yZCAqKVxuXG4oKiogQ2FzZSBzZW5zaXRpdml0eSBvcHRpb25zIGZvciBuYW1lcyBvZiB2YXJpYW50IGNvbnN0cnVjdG9ycy4gKilcbmFuZCBjYXNlX3NlbnNpdGl2aXR5ID1cbiAgfCBDYXNlX2luc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUuIFVzZWQgZm9yIGN1c3RvbSBwYXJzZXJzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLiBVc2VkIGZvciBwb2x5bW9ycGhpYyB2YXJpYW50cy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGNhc2Ugc2Vuc2l0aXZlIGFmdGVyd2FyZC5cbiAgICAgIFVzZWQgZm9yIHJlZ3VsYXIgdmFyaWFudHMuICopXG5cbigqKiBHcmFtbWFyIG9mIHZhcmlhbnRzLiBBY2NlcHRzIGFueSBzZXhwIG1hdGNoaW5nIG9uZSBvZiB0aGUgY2xhdXNlcy4gKilcbmFuZCB2YXJpYW50ID1cbiAgeyBjYXNlX3NlbnNpdGl2aXR5IDogY2FzZV9zZW5zaXRpdml0eVxuICA7IGNsYXVzZXMgOiBjbGF1c2Ugd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UuIEFjY2VwdHMgc2V4cHMgYmFzZWQgb24gdGhlIFtjbGF1c2Vfa2luZF0uICopXG5hbmQgY2xhdXNlID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgY2xhdXNlX2tpbmQgOiBjbGF1c2Vfa2luZFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlJ3MgY29udGVudHMuIFtBdG9tX2NsYXVzZV0gYWNjZXB0cyBhbiBhdG9tIG1hdGNoaW5nXG4gICAgdGhlIGNsYXVzZSdzIG5hbWUuIFtMaXN0X2NsYXVzZV0gYWNjZXB0cyBhIGxpc3Qgd2hvc2UgaGVhZCBpcyBhbiBhdG9tIG1hdGNoaW5nIHRoZVxuICAgIGNsYXVzZSdzIG5hbWUgYW5kIHdob3NlIHRhaWwgbWF0Y2hlcyBbYXJnc10uIFRoZSBjbGF1c2UncyBuYW1lIGlzIG1hdGNoZWQgbW9kdWxvIHRoZVxuICAgIHZhcmlhbnQncyBbbmFtZV9raW5kXS4gKilcbmFuZCBjbGF1c2Vfa2luZCA9XG4gIHwgQXRvbV9jbGF1c2VcbiAgfCBMaXN0X2NsYXVzZSBvZiB7IGFyZ3MgOiBsaXN0X2dyYW1tYXIgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZC4gQWNjZXB0cyBhbnkgbGlzdCBvZiBzZXhwcyBzcGVjaWZ5aW5nIGVhY2ggb2YgdGhlIGZpZWxkcyxcbiAgICByZWdhcmRsZXNzIG9mIG9yZGVyLiBJZiBbYWxsb3dfZXh0cmFfZmllbGRzXSBpcyBzcGVjaWZpZWQsIGlnbm9yZXMgc2V4cHMgd2l0aCBuYW1lc1xuICAgIG5vdCBmb3VuZCBpbiBbZmllbGRzXS4gKilcbmFuZCByZWNvcmQgPVxuICB7IGFsbG93X2V4dHJhX2ZpZWxkcyA6IGJvb2xcbiAgOyBmaWVsZHMgOiBmaWVsZCB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZCBmaWVsZC4gQSBmaWVsZCBtdXN0IHNob3cgdXAgZXhhY3RseSBvbmNlIGluIGEgcmVjb3JkIGlmXG4gICAgW3JlcXVpcmVkXSwgb3IgYXQgbW9zdCBvbmNlIG90aGVyd2lzZS4gQWNjZXB0cyBhIGxpc3QgaGVhZGVkIGJ5IFtuYW1lXSBhcyBhbiBhdG9tLFxuICAgIGZvbGxvd2VkIGJ5IHNleHBzIG1hdGNoaW5nIFthcmdzXS4gKilcbmFuZCBmaWVsZCA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IHJlcXVpcmVkIDogYm9vbFxuICA7IGFyZ3MgOiBsaXN0X2dyYW1tYXJcbiAgfVxuXG4oKiogR3JhbW1hciB0YWdnZWQgd2l0aCBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIuICopXG5hbmQgJ2Egd2l0aF90YWcgPVxuICB7IGtleSA6IHN0cmluZ1xuICA7IHZhbHVlIDogU2V4cC50XG4gIDsgZ3JhbW1hciA6ICdhXG4gIH1cblxuYW5kICdhIHdpdGhfdGFnX2xpc3QgPVxuICB8IFRhZyBvZiAnYSB3aXRoX3RhZ19saXN0IHdpdGhfdGFnXG4gIHwgTm9fdGFnIG9mICdhXG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbi4gTmFtZXMgdGhlIFt0eWNvbl0gYmVpbmcgZGVmaW5lZCwgYW5kIHRoZVxuICAgIFt0eXZhcnNdIGl0IHRha2VzIGFzIHBhcmFtZXRlcnMuIFNwZWNpZmllcyB0aGUgW2dyYW1tYXJdIG9mIHRoZSBbdHljb25dLiBUaGUgZ3JhbW1hclxuICAgIG1heSByZWZlciB0byBhbnkgb2YgdGhlIFt0eXZhcnNdLCBhbmQgdG8gYW55IG9mIHRoZSBbdHljb25dcyBmcm9tIHRoZSBzYW1lIHNldCBvZlxuICAgIFtSZWN1cnNpdmVdIGRlZmluaXRpb25zLiAqKVxuYW5kIGRlZm4gPVxuICB7IHR5Y29uIDogc3RyaW5nXG4gIDsgdHl2YXJzIDogc3RyaW5nIGxpc3RcbiAgOyBncmFtbWFyIDogZ3JhbW1hclxuICB9XG5cbigqKiBUb3AtbGV2ZWwgZ3JhbW1hciB0eXBlLiBIYXMgYSBwaGFudG9tIHR5cGUgcGFyYW1ldGVyIHRvIGFzc29jaWF0ZSBlYWNoIGdyYW1tYXIgd2l0aFxuICAgIHRoZSB0eXBlIGl0cyBzZXhwcyByZXByZXNlbnQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGFwcGx5IGdyYW1tYXJzIHRvIHRoZSB3cm9uZ1xuICAgIHR5cGUsIHdoaWxlIGdyYW1tYXJzIGNhbiBzdGlsbCBiZSBlYXNpbHkgY29lcmNlZCB0byBhIG5ldyB0eXBlIGlmIG5lZWRlZC4gKilcbnR5cGUgXyB0ID0geyB1bnR5cGVkIDogZ3JhbW1hciB9IFtAQHVuYm94ZWRdXG5cbmxldCBjb2VyY2UgKHR5cGUgYSBiKSAoeyB1bnR5cGVkID0gXyB9IGFzIHQgOiBhIHQpIDogYiB0ID0gdFxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaXMgdXNlZCBmb3IgYWxsIHRhZ3MgZ2VuZXJhdGVkIGZyb20gZG9jIGNvbW1lbnRzLiAqKVxubGV0IGRvY19jb21tZW50X3RhZyA9IFwic2V4cF9ncmFtbWFyLmRvY19jb21tZW50XCJcbiIsImxldCB1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBMaXN0IEVtcHR5IH1cbmxldCBib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBCb29sIH1cbmxldCBzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQ2hhciB9XG5sZXQgaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gRmxvYXQgfVxubGV0IGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgc2V4cF90X3NleHBfZ3JhbW1hciA6IFNleHAudCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIlNleHAudFwiIH1cbmxldCByZWZfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcbmxldCBsYXp5X3Rfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcblxubGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIG9wdGlvbiBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IE9wdGlvbiB1bnR5cGVkIH1cbjs7XG5cbmxldCBsaXN0X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gbGlzdCBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGFycmF5X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gYXJyYXkgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBlbXB0eV9zZXhwX2dyYW1tYXIgOiBfIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxubGV0IG9wYXF1ZV9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbmxldCBmdW5fc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG4iLCIoKiBVdGlsaXR5IE1vZHVsZSBmb3IgUy1leHByZXNzaW9uIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIE1vcmVMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBcblxuKCogQ29udmVyc2lvbiBvZiBPQ2FtbC12YWx1ZXMgdG8gUy1leHByZXNzaW9ucyAqKVxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiAnJS4xN2cnIGlzIGd1YXJhbnRlZWQgdG8gYmUgcm91bmQtdHJpcHBhYmxlLlxuXG4gICAnJS4xNWcnIHdpbGwgYmUgcm91bmQtdHJpcHBhYmxlIGFuZCBub3QgaGF2ZSBub2lzZSBhdCB0aGUgbGFzdCBkaWdpdCBvciB0d28gZm9yIGEgZmxvYXRcbiAgIHdoaWNoIHdhcyBjb252ZXJ0ZWQgZnJvbSBhIGRlY2ltYWwgKHN0cmluZykgd2l0aCA8PSAxNSBzaWduaWZpY2FudCBkaWdpdHMuICBTbyBpdCdzXG4gICB3b3J0aCB0cnlpbmcgZmlyc3QgdG8gYXZvaWQgdGhpbmdzIGxpa2UgXCIzLjE0MDAwMDAwMDAwMDAwMDFcIi5cblxuICAgU2VlIGNvbW1lbnQgYWJvdmUgW3RvX3N0cmluZ19yb3VuZF90cmlwcGFibGVdIGluIHshQ29yZS5GbG9hdH0gZm9yXG4gICBkZXRhaWxlZCBleHBsYW5hdGlvbiBhbmQgZXhhbXBsZXMuICopXG5sZXQgZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgPVxuICByZWYgKGZ1biB4IC0+XG4gICAgbGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1R1wiIHggaW5cbiAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN0dcIiB4KVxuOztcblxubGV0IHJlYWRfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IHdyaXRlX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCBsaXN0X21hcCBmIGwgPSBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGwgfmYpXG5sZXQgc2V4cF9vZl91bml0ICgpID0gTGlzdCBbXVxubGV0IHNleHBfb2ZfYm9vbCBiID0gQXRvbSAoc3RyaW5nX29mX2Jvb2wgYilcbmxldCBzZXhwX29mX3N0cmluZyBzdHIgPSBBdG9tIHN0clxubGV0IHNleHBfb2ZfYnl0ZXMgYnl0ZXMgPSBBdG9tIChCeXRlcy50b19zdHJpbmcgYnl0ZXMpXG5sZXQgc2V4cF9vZl9jaGFyIGMgPSBBdG9tIChTdHJpbmcubWFrZSAxIGMpXG5sZXQgc2V4cF9vZl9pbnQgbiA9IEF0b20gKHN0cmluZ19vZl9pbnQgbilcbmxldCBzZXhwX29mX2Zsb2F0IG4gPSBBdG9tICghZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgbilcbmxldCBzZXhwX29mX2ludDMyIG4gPSBBdG9tIChJbnQzMi50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX2ludDY0IG4gPSBBdG9tIChJbnQ2NC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX25hdGl2ZWludCBuID0gQXRvbSAoTmF0aXZlaW50LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfcmVmIHNleHBfb2ZfX2EgcmYgPSBzZXhwX29mX19hICFyZlxubGV0IHNleHBfb2ZfbGF6eV90IHNleHBfb2ZfX2EgbHYgPSBzZXhwX29mX19hIChMYXp5LmZvcmNlIGx2KVxuXG5sZXQgc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9fYSA9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgWyBzZXhwX29mX19hIHggXVxuICB8IFNvbWUgeCAtPiBMaXN0IFsgQXRvbSBcInNvbWVcIjsgc2V4cF9vZl9fYSB4IF1cbiAgfCBOb25lIHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgW11cbiAgfCBOb25lIC0+IEF0b20gXCJub25lXCJcbjs7XG5cbmxldCBzZXhwX29mX3BhaXIgc2V4cF9vZl9fYSBzZXhwX29mX19iIChhLCBiKSA9IExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYiBdXG5cbmxldCBzZXhwX29mX3RyaXBsZSBzZXhwX29mX19hIHNleHBfb2ZfX2Igc2V4cF9vZl9fYyAoYSwgYiwgYykgPVxuICBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGI7IHNleHBfb2ZfX2MgYyBdXG47O1xuXG4oKiBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIC4uLikgaXMgdGFpbCByZWN1cnNpdmUsIHRoZSBPQ2FtbCBzdGFuZGFyZFxuICAgbGlicmFyeSBMaXN0Lm1hcCBpcyBOT1QuICopXG5sZXQgc2V4cF9vZl9saXN0IHNleHBfb2ZfX2EgbHN0ID0gTGlzdCAoTGlzdC5yZXYgKExpc3QucmV2X21hcCBsc3QgfmY6c2V4cF9vZl9fYSkpXG5cbmxldCBzZXhwX29mX2FycmF5IHNleHBfb2ZfX2EgYXIgPVxuICBsZXQgbHN0X3JlZiA9IHJlZiBbXSBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhciAtIDEgZG93bnRvIDAgZG9cbiAgICBsc3RfcmVmIDo9IHNleHBfb2ZfX2EgYXIuKGkpIDo6ICFsc3RfcmVmXG4gIGRvbmU7XG4gIExpc3QgIWxzdF9yZWZcbjs7XG5cbmxldCBzZXhwX29mX2hhc2h0Ymwgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWwgaHRibCA9XG4gIGxldCBjb2xsIH5rZXk6ayB+ZGF0YTp2IGFjYyA9IExpc3QgWyBzZXhwX29mX2tleSBrOyBzZXhwX29mX3ZhbCB2IF0gOjogYWNjIGluXG4gIExpc3QgKEhhc2h0YmwuZm9sZCBodGJsIH5pbml0OltdIH5mOmNvbGwpXG47O1xuXG5sZXQgc2V4cF9vZl9vcGFxdWUgXyA9IEF0b20gXCI8b3BhcXVlPlwiXG5sZXQgc2V4cF9vZl9mdW4gXyA9IEF0b20gXCI8ZnVuPlwiXG5cbigqIEV4Y2VwdGlvbiBjb252ZXJ0ZXIgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgKilcblxubW9kdWxlIEV4bl9jb252ZXJ0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhlc2UgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgY29udGV4dC1zd2l0Y2hlc1xuICAgICBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGVyZSBpcyBhbiBhbGxvY2F0aW9uLiAgSXQgaXMgcmVhc29uYWJsZSB0byBleHBlY3RcbiAgICAgdGhhdCB0aGlzIHdpbGwgcmVtYWluIHRydWUgZm9yIHRoZSBmb3Jlc2VlYWJsZSBmdXR1cmUuICBUaGF0IHdheSB3ZVxuICAgICBhdm9pZCB1c2luZyBtdXRleGVzIGFuZCB0aHVzIGEgZGVwZW5kZW5jeSBvbiB0aGUgdGhyZWFkcyBsaWJyYXJ5LiAqKVxuXG4gICgqIEZhc3QgYW5kIGF1dG9tYXRpYyBleGNlcHRpb24gcmVnaXN0cmF0aW9uICopXG5cbiAgbW9kdWxlIFJlZ2lzdHJhdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IHNleHBfb2ZfZXhuIDogZXhuIC0+IFNleHAudFxuICAgICAgOyAoKiBJZiBbcHJpbnRleGMgPSB0cnVlXSB0aGVuIHRoaXMgc2V4cCBjb252ZXJ0ZXIgaXMgdXNlZCBmb3IgUHJpbnRleGMudG9fc3RyaW5nICopXG4gICAgICAgIHByaW50ZXhjIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgRXhuX3RhYmxlID0gRXBoZW1lcm9uLksxLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG5cbiAgICAgIGxldCBlcXVhbCA9ICggPT0gKVxuICAgICAgbGV0IGhhc2ggPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gICAgZW5kKVxuXG4gIGxldCB0aGVfZXhuX3RhYmxlIDogUmVnaXN0cmF0aW9uLnQgRXhuX3RhYmxlLnQgPSBFeG5fdGFibGUuY3JlYXRlIDE3XG5cbiAgKCogRXBoZW1lcm9ucyBhcmUgdXNlZCBzbyB0aGF0IFtzZXhwX29mX2V4bl0gY2xvc3VyZSBkb24ndCBrZWVwIHRoZVxuICAgICBleHRlbnNpb25fY29uc3RydWN0b3IgbGl2ZS4gKilcbiAgbGV0IGFkZCA/KHByaW50ZXhjID0gdHJ1ZSkgP2ZpbmFsaXNlOl8gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHNleHBfb2ZfZXhuID1cbiAgICBFeG5fdGFibGUuYWRkIHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH1cbiAgOztcblxuICBsZXQgZmluZF9hdXRvIH5mb3JfcHJpbnRleGMgZXhuID1cbiAgICBsZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuIGluXG4gICAgbWF0Y2ggRXhuX3RhYmxlLmZpbmRfb3B0IHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9IC0+XG4gICAgICAobWF0Y2ggZm9yX3ByaW50ZXhjLCBwcmludGV4YyB3aXRoXG4gICAgICAgfCBmYWxzZSwgXyB8IF8sIHRydWUgLT4gU29tZSAoc2V4cF9vZl9leG4gZXhuKVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gTm9uZSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3VuaXRfdGVzdHNfb25seSA9IHN0cnVjdFxuICAgIGxldCBzaXplICgpID0gKEV4bl90YWJsZS5zdGF0c19hbGl2ZSB0aGVfZXhuX3RhYmxlKS5udW1fYmluZGluZ3NcbiAgZW5kXG5lbmRcblxubGV0IHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4Yzp0cnVlIGV4blxubGV0IHNleHBfb2ZfZXhuX29wdCBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOmZhbHNlIGV4blxuXG5sZXQgc2V4cF9vZl9leG4gZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBMaXN0IFsgQXRvbSAoUHJpbnRleGMudG9fc3RyaW5nIGV4bikgXVxuICB8IFNvbWUgc2V4cCAtPiBzZXhwXG47O1xuXG5sZXQgZXhuX3RvX3N0cmluZyBlID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX2V4biBlKVxuXG4oKiB7W2V4Y2VwdGlvbiBCbGFoIFtAQGRlcml2aW5nIHNleHBdXX0gZ2VuZXJhdGVzIGEgY2FsbCB0byB0aGUgZnVuY3Rpb25cbiAgIFtFeG5fY29udmVydGVyLmFkZF0gZGVmaW5lZCBpbiB0aGlzIGZpbGUuICBTbyB3ZSBhcmUgZ3VhcmFudGVkIHRoYXQgYXMgc29vbiBhcyB3ZVxuICAgbWFyayBhbiBleGNlcHRpb24gYXMgc2V4cGFibGUsIHRoaXMgbW9kdWxlIHdpbGwgYmUgbGlua2VkIGluIGFuZCB0aGlzIHByaW50ZXIgd2lsbCBiZVxuICAgcmVnaXN0ZXJlZCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LiAqKVxubGV0ICgpID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuIGV4biAtPlxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBzZXhwIC0+IFNvbWUgKFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cCkpXG47O1xuXG5sZXQgcHJpbnRleGNfcHJlZmVyX3NleHAgZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBQcmludGV4Yy50b19zdHJpbmcgZXhuXG4gIHwgU29tZSBzZXhwIC0+IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cFxuOztcblxuKCogQ29udmVyc2lvbiBvZiBTLWV4cHJlc3Npb25zIHRvIE9DYW1sLXZhbHVlcyAqKVxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IFNleHAuT2Zfc2V4cF9lcnJvclxuXG5sZXQgcmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyA9IHJlZiB0cnVlXG5sZXQgb2Zfc2V4cF9lcnJvcl9leG4gZXhjIHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSlcbmxldCBvZl9zZXhwX2Vycm9yIHdoYXQgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChGYWlsdXJlIHdoYXQsIHNleHApKVxuXG5sZXQgdW5pdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+ICgpXG4gIHwgQXRvbSBfIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJ1bml0X29mX3NleHA6IGVtcHR5IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJvb2xfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSAoXCJ0cnVlXCIgfCBcIlRydWVcIikgLT4gdHJ1ZVxuICB8IEF0b20gKFwiZmFsc2VcIiB8IFwiRmFsc2VcIikgLT4gZmFsc2VcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogdW5rbm93biBzdHJpbmdcIiBzZXhwXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHN0cmluZ19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInN0cmluZ19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBieXRlc19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBCeXRlcy5vZl9zdHJpbmcgc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJieXRlc19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBjaGFyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzdHIgPD4gMVxuICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBzdHJpbmcgbXVzdCBjb250YWluIG9uZSBjaGFyYWN0ZXIgb25seVwiIHNleHA7XG4gICAgc3RyLlswXVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGludF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBmbG9hdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgZmxvYXRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiZmxvYXRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImZsb2F0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDMyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQzMi5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQzMl9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50MzJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50NjRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDY0Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDY0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQ2NF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBuYXRpdmVpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IE5hdGl2ZWludC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJuYXRpdmVpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm5hdGl2ZWludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCByZWZfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSByZWYgKGFfX29mX3NleHAgc2V4cClcbmxldCBsYXp5X3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSBMYXp5LmZyb21fdmFsIChhX19vZl9zZXhwIHNleHApXG5cbmxldCBvcHRpb25fb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBpZiAhcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdFxuICB0aGVuIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IExpc3QgW10gfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgZWwgXSB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IHJlcHJlc2VudCBvcHRpb25hbCB2YWx1ZVwiIHNleHBcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHApXG4gIGVsc2UgKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgYmUgKHNvbWUgZWwpXCIgc2V4cClcbjs7XG5cbmxldCBwYWlyX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgYSwgYlxuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdHdvIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHRyaXBsZV9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBjX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHA7IGNfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBsZXQgYyA9IGNfX29mX3NleHAgY19zZXhwIGluXG4gICAgYSwgYiwgY1xuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0aHJlZSBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGxpc3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCByZXZfbHN0ID0gTGlzdC5yZXZfbWFwIGxzdCB+ZjphX19vZl9zZXhwIGluXG4gICAgTGlzdC5yZXYgcmV2X2xzdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwibGlzdF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBhcnJheV9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gW3x8XVxuICB8IExpc3QgKGggOjogdCkgLT5cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggdCArIDEgaW5cbiAgICBsZXQgcmVzID0gQXJyYXkubWFrZSBsZW4gKGFfX29mX3NleHAgaCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJlc1xuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgcmVzLihpKSA8LSBhX19vZl9zZXhwIGg7XG4gICAgICAgIGxvb3AgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBsb29wIDEgdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYXJyYXlfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaGFzaHRibF9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCBodGJsID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIGxldCBhY3QgPSBmdW5jdGlvblxuICAgICAgfCBMaXN0IFsga19zZXhwOyB2X3NleHAgXSAtPlxuICAgICAgICBIYXNodGJsLmFkZCBodGJsIH5rZXk6KGtleV9vZl9zZXhwIGtfc2V4cCkgfmRhdGE6KHZhbF9vZl9zZXhwIHZfc2V4cClcbiAgICAgIHwgTGlzdCBfIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IHR1cGxlIGxpc3QgbmVlZGVkXCIgc2V4cFxuICAgIGluXG4gICAgTGlzdC5pdGVyIGxzdCB+ZjphY3Q7XG4gICAgaHRibFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBvcGFxdWVfb2Zfc2V4cCBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciBcIm9wYXF1ZV9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBvcGFxdWUgdmFsdWVzXCIgc2V4cFxuOztcblxubGV0IGZ1bl9vZl9zZXhwIHNleHAgPSBvZl9zZXhwX2Vycm9yIFwiZnVuX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IGZ1bmN0aW9uIHZhbHVlc1wiIHNleHBcblxuKCogU2V4cCBHcmFtbWFycyAqKVxuXG5pbmNsdWRlIFNleHBfY29udl9ncmFtbWFyXG5cbigqIFJlZ2lzdGVyaW5nIGRlZmF1bHQgZXhjZXB0aW9uIHByaW50ZXJzICopXG5cbmxldCBnZXRfZmxjX2Vycm9yIG5hbWUgKGZpbGUsIGxpbmUsIGNocikgPSBBdG9tIChzcHJpbnRmIFwiJXMgJXM6JWQ6JWRcIiBuYW1lIGZpbGUgbGluZSBjaHIpXG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4YzpmYWxzZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFzc2VydF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiQXNzZXJ0X2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEV4aXRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRXhpdCAtPiBBdG9tIFwiRXhpdFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFbmRfb2ZfZmlsZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFbmRfb2ZfZmlsZSAtPiBBdG9tIFwiRW5kX29mX2ZpbGVcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBGYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZCAtPiBBdG9tIFwiTm90X2ZvdW5kXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEludmFsaWRfYXJndW1lbnRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBhcmcgLT4gTGlzdCBbIEF0b20gXCJJbnZhbGlkX2FyZ3VtZW50XCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hdGNoX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTWF0Y2hfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIk1hdGNoX2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF9zXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZF9zIGFyZyAtPiBMaXN0IFsgQXRvbSBcIk5vdF9mb3VuZF9zXCI7IGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXNfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzX2Vycm9yIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlN5c19lcnJvclwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuSGVscF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuSGVscCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuSGVscFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuQmFkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5CYWQgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkJhZFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBMYXp5LlVuZGVmaW5lZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBMYXp5LlVuZGVmaW5lZCAtPiBBdG9tIFwiTGF6eS5VbmRlZmluZWRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUGFyc2luZy5QYXJzZV9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBQYXJzaW5nLlBhcnNlX2Vycm9yIC0+IEF0b20gXCJQYXJzaW5nLlBhcnNlX2Vycm9yXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFF1ZXVlLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFF1ZXVlLkVtcHR5IC0+IEF0b20gXCJRdWV1ZS5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTY2FuZi5TY2FuX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU2NhbmYuU2Nhbl9mYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlNjYW5mLlNjYW5fZmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTdGFjay5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTdGFjay5FbXB0eSAtPiBBdG9tIFwiU3RhY2suRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzLkJyZWFrXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5cy5CcmVhayAtPiBBdG9tIFwiU3lzLkJyZWFrXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOnRydWUgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBPZl9zZXhwX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkgLT5cbiAgICAgICAgICBMaXN0IFsgQXRvbSBcIlNleHBsaWIuQ29udi5PZl9zZXhwX2Vycm9yXCI7IHNleHBfb2ZfZXhuIGV4Yzsgc2V4cCBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4iLCIoKiBDb252X2Vycm9yOiBNb2R1bGUgZm9yIEhhbmRsaW5nIEVycm9ycyBkdXJpbmcgQXV0b21hdGVkIFMtZXhwcmVzc2lvblxuICAgQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBfY29udlxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IE9mX3NleHBfZXJyb3JcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgdHVwbGVzICopXG5cbmxldCB0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgbG9jIG4gc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCIlc19vZl9zZXhwOiB0dXBsZSBvZiBzaXplICVkIGV4cGVjdGVkXCIgbG9jIG4pIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHN1bSB0eXBlcyAqKVxuXG5sZXQgc3RhZ19ub19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhpcyBjb25zdHJ1Y3RvciBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgc3RhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyB0YWcgc2V4cCA9XG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogc3VtIHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIiBsb2MgdGFnIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBzdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGlzIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGEgbmVzdGVkIGxpc3RcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGFuIGVtcHR5IGxpc3RcIikgc2V4cFxuOztcblxubGV0IHVuZXhwZWN0ZWRfc3RhZyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHVuZXhwZWN0ZWQgdmFyaWFudCBjb25zdHJ1Y3RvclwiKSBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyByZWNvcmRzICopXG5cbmxldCByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvYyBeIFwiX29mX3NleHA6IHJlY29yZCBjb252ZXJzaW9uOiBhIFtzZXhwLmJvb2xdIGZpZWxkIHdhcyBnaXZlbiBhIHBheWxvYWQuXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jXG4gICAgXiBcIl9vZl9zZXhwOiByZWNvcmQgY29udmVyc2lvbjogb25seSBwYWlycyBleHBlY3RlZCwgdGhlaXIgZmlyc3QgZWxlbWVudCBtdXN0IGJlIGFuIFxcXG4gICAgICAgYXRvbVwiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0IH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgbGV0IGZsZF9uYW1lc19zdHIgPSBTdHJpbmcuY29uY2F0IChMaXN0LnJldiByZXZfZmxkX25hbWVzKSB+c2VwOlwiIFwiIGluXG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogJXM6ICVzXCIgbG9jIHdoYXQgZmxkX25hbWVzX3N0ciBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMgbG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQ6XCJkdXBsaWNhdGUgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWNvcmRfZXh0cmFfZmllbGRzIGxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0OlwiZXh0cmEgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWMgcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IFN0cmluZy5jb25jYXQgKExpc3QucmV2IGZpZWxkcykgfnNlcDpcIiBcIlxuICB8ICh0cnVlLCBmaWVsZCkgOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIChmaWVsZCA6OiBmaWVsZHMpIHJlc3RcbiAgfCBfIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgcmVzdFxuOztcblxubGV0IHJlY29yZF91bmRlZmluZWRfZWxlbWVudHMgbG9jIHNleHAgbHN0ID1cbiAgbGV0IHVuZGVmaW5lZCA9IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgW10gbHN0IGluXG4gIGxldCBtc2cgPVxuICAgIHNwcmludGYgXCIlc19vZl9zZXhwOiB0aGUgZm9sbG93aW5nIHJlY29yZCBlbGVtZW50cyB3ZXJlIHVuZGVmaW5lZDogJXNcIiBsb2MgdW5kZWZpbmVkXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gbG9jIHNleHAgPVxuICBsZXQgbXNnID0gbG9jIF4gXCJfb2Zfc2V4cDogbGlzdCBpbnN0ZWFkIG9mIGF0b20gZm9yIHJlY29yZCBleHBlY3RlZFwiIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfcG9seV9maWVsZF92YWx1ZSBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvY1xuICAgIF4gXCJfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgdmFsdWVzIG9mIHR5cGVzIHJlc3VsdGluZyBmcm9tIHBvbHltb3JwaGljIHJlY29yZCBmaWVsZHNcIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBwb2x5bW9ycGhpYyB2YXJpYW50cyAqKVxuXG5leGNlcHRpb24gTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fdmFyaWFudF9tYXRjaCAoKSA9IHJhaXNlIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBubyBtYXRjaGluZyB2YXJpYW50IGZvdW5kXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX25vX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIGNuc3RyIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmXG4gICAgICBcIiVzX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiXG4gICAgICBsb2NcbiAgICAgIGNuc3RyXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBwdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IHRhZyB0YWtlcyBhbiBhcmd1bWVudFwiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGEgbmVzdGVkIGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGUgZW1wdHkgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X3R5cGUgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0cnlpbmcgdG8gY29udmVydCBhbiBlbXB0eSB0eXBlXCIpIHNleHBcbjs7XG4iXX0=
