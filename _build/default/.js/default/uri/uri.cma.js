// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http = "http",
    cst_https = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    x = cst_http,
    x$0 = cst_https,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result;
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     t$2 = xs;
     t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _dg_ = i + 1 | 0;
     if(10 === i) return a;
     i = _dg_;
    }
   }
   var
    safe_chars = caml_make_vect(256, 0),
    i = 0,
    _au_ = [0, 0],
    _ap_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _ar_ = [0, -1042355253],
    _as_ = [0, 804243368],
    _aq_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _at_ = [1, [0, 3854881, "No scheme present in URI"]],
    _ao_ = [0, cst$34],
    _an_ = [0, 0],
    _v_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _u_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _W_ = [0, 0, 0, 0];
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _av_ = i + 1 | 0;
    if(65 === i) break;
    i = _av_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[8], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[8], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[8], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _c$_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[8], _c$_),
      _db_ = caml_ml_string_length(safe) - 1 | 0,
      _da_ = 0;
     if(_db_ >= 0){
      var i$0 = _da_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _df_ = i$0 + 1 | 0;
       if(_db_ === i$0) break;
       i$0 = _df_;
      }
     }
     var _dd_ = caml_ml_string_length(unsafe) - 1 | 0, _dc_ = 0;
     if(_dd_ >= 0){
      var i = _dc_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _de_ = i + 1 | 0;
       if(_dd_ === i) break;
       i = _de_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[26], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[26], hs);
    return hs$0 == cst_localhost$0 ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[26], s);
    return match !== "file"
            ? match
              !== cst_http
              ? match !== cst_https ? match !== "urn" ? Generic : Urn : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c]){var cur$0 = cur + 1 | 0; cur = cur$0;}
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _c__ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _c__);
      var cur$1 = cur + 1 | 0, start$0 = cur + 1 | 0;
      start = start$0;
      cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[6], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0;
       cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_c9_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        start = start$0;
        cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_c8_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _c6_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _c6_);
          var start_at = cur$0;
          break a;
         }
         var _c7_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _c7_);
         var start_at = cur$0 + 1 | 0;
        }
        start = start_at;
        cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _c5_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _c5_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var x = encode(scheme, [0, component], s);
    return x;
   }
   function pct_encoder(opt, _c4_, _c3_, _c2_, _c1_, _c0_, _cZ_, param){
    if(opt) var sth = opt[1], scheme = sth; else var scheme = -178940859;
    if(_c4_)
     var sth$0 = _c4_[1], userinfo = sth$0;
    else
     var userinfo = -145160103;
    if(_c3_) var sth$1 = _c3_[1], host = sth$1; else var host = 803994504;
    if(_c2_) var sth$2 = _c2_[1], path = sth$2; else var path = 892015045;
    if(_c1_)
     var sth$3 = _c1_[1], query_key = sth$3;
    else
     var query_key = -911188600;
    if(_c0_)
     var sth$4 = _c0_[1], query_value = sth$4;
    else
     var query_value = 795008922;
    if(_cZ_)
     var sth$5 = _cZ_[1], fragment = sth$5;
    else
     var fragment = 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){var x = decode(s); return x;}
   function compare(param, _cY_){
    var
     p = _cY_[2],
     u = _cY_[1],
     p$0 = param[2],
     u$0 = param[1],
     c = caml_call2(Stdlib_String[9], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[9], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(match$0){
     var p = match$0[1], x$0 = decode(p), x = decode(u);
     return [0, x, [0, x$0]];
    }
    var x$1 = decode(u);
    return [0, x$1, 0];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _cV_ = caml_ml_string_length(p); else var _cV_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _cV_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _cW_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _cW_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _cX_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _cX_);
     }
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[19], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[9], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _cR_ = param$0[1];
       c:
       {
        if(_cR_ !== cst$36){
         if(_cR_ !== cst$39){
          if(_cR_ !== cst$33) break a;
          var _cT_ = param$0[2];
          if(! _cT_) break b;
          var _cU_ = _cT_[1];
          if(_cU_ === cst$36){var r$3 = _cT_[2]; break c;}
          if(_cU_ !== cst$39){
           if(_cU_ === cst$33){
            var r$1 = _cT_[2];
            if(0 < ascension){
             var ascension$1 = ascension - 1 | 0;
             ascension = ascension$1;
             param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _cT_[2];
           if(0 >= ascension) break a;
           var ascension$0 = ascension - 1 | 0;
           ascension = ascension$0;
           param$0 = r$0;
           continue;
          }
          var r$2 = _cT_[2];
         }
         else
          var r$2 = param$0[2];
         var ascension$2 = ascension + 1 | 0;
         ascension = ascension$2;
         param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_call1(Stdlib_List[5], p) == cst$33)
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var r = param$0[2], s = param$0[1], outp$0 = [0, s, outp];
     ascension = 0;
     outp = outp$0;
     param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_call1(Stdlib_List[5], outp) == cst$33)
      return caml_call1(Stdlib_List[6], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[11], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _cS_ = acc; break;}
      var xs = param[2], x = param[1], acc$0 = [0, x, [0, cst$0, acc]];
      acc = acc$0;
      param = xs;
     }
    }
    else
     var _cS_ = 0;
    return caml_call2(Stdlib_List[12], [0, cst$1, _cS_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var
      len =
        caml_call3
         (Stdlib_List[25],
          function(c, tok){return caml_ml_string_length(tok) + c | 0;},
          0,
          p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(seg === cst$33) return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _cQ_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
       },
       cst$4,
       buf,
       p);
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[49], s),
      _cO_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _cN_ = 0;
     if(_cO_ >= 0){
      var i = _cN_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _cP_ = i + 1 | 0;
       if(_cO_ === i) break;
       i = _cP_;
      }
     }
     return caml_call1(Stdlib_Bytes[48], s$0);
    }
    if(els){
     var
      acc = 0,
      param =
        caml_call2
         (Stdlib_List[21],
          function(el){return caml_call3(Stringext[3], _h_, el, 61);},
          els);
     for(;;){
      if(! param) break;
      var _cJ_ = param[1];
      if(_cJ_){
       var match = _cJ_[2], k = _cJ_[1];
       if(match){
        var
         tl = param[2],
         v = match[1],
         _cK_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _cK_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc];
        acc = acc$0;
        param = tl;
       }
       else{
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc];
        acc = acc$1;
        param = tl$0;
       }
      }
      else{
       var tl$1 = param[2], acc$2 = [0, _g_, acc];
       acc = acc$2;
       param = tl$1;
      }
     }
     var _cL_ = acc;
    }
    else
     var _cL_ = _i_;
    return caml_call2
            (Stdlib_List[19],
             function(param){
              var
               v = param[2],
               k = param[1],
               _cM_ = caml_call2(Stdlib_List[19], pct_decode, v),
               x = decode(k);
              return [0, x, _cM_];
             },
             _cL_);
   }
   function encoded_of_query(scheme, opt, l){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var
     len =
       caml_call3
        (Stdlib_List[25],
         function(a, param){
          var v = param[2], k = param[1];
          return ((a + caml_ml_string_length(k) | 0)
                 +
                  caml_call3
                   (Stdlib_List[25],
                    function(a, s){
                     return (a + caml_ml_string_length(s) | 0) + 1 | 0;
                    },
                    0,
                    v)
                 | 0)
                 + 2
                 | 0;
         },
         -1,
         l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _cG_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _cG_);
       var _cH_ = 0 !== v ? 1 : 0;
       return _cH_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _cI_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _cI_);
                   },
                   cst$8,
                   buf,
                   v))
               : _cH_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    var
     lazy_query =
       caml_call1
        (Stdlib_Lazy[6], function(param){return query_of_encoded(qs);});
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else
     var
      _cD_ = param[2],
      _cE_ = caml_obj_tag(_cD_),
      _cF_ =
        250 === _cE_
         ? _cD_[1]
         : 246 === _cE_ ? caml_call1(CamlinternalLazy[2], _cD_) : _cD_,
      kv = _cF_;
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_cB_, _cC_){return encoded_of_query(scheme, _cB_, _cC_);};
   }
   var
    _e_ = Stdlib_String[9],
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[9];
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _cA_ = h1[1];
     if(-367671627 === _cA_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[9], ip1, ip2);
      }
     }
     else
      if(267950263 === _cA_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[9], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _cA_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$2 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$2) return c$2;
    var c$3 = compare_opt(compare_decoded, t$0[1], t[1]);
    if(0 !== c$3) return c$3;
    var
     c =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;},
         t$0[4],
         t[4]);
    if(0 !== c) return c;
    var c$0 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$0) return c$0;
    var c$4 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$4) return c$4;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _cs_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _cs_;
      else
       var
        _ct_ = y[2],
        _cu_ = caml_obj_tag(_ct_),
        _cv_ =
          250 === _cu_
           ? _ct_[1]
           : 246 === _cu_ ? caml_call1(CamlinternalLazy[2], _ct_) : _ct_,
        kvl$0 = _cv_,
        kvl = _cs_;
     }
     else{
      var _cw_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$1 = compare_opt(Stdlib_String[9], raw, raw$0);
       break a;
      }
      var
       _cx_ = caml_obj_tag(_cw_),
       _cy_ =
         250 === _cx_
          ? _cw_[1]
          : 246 === _cx_ ? caml_call1(CamlinternalLazy[2], _cw_) : _cw_,
       kvl$0 = y[1],
       kvl = _cy_;
     }
     var
      c$1 =
        compare_list
         (function(param, _cz_){
           var
            vl = _cz_[2],
            k = _cz_[1],
            vl$0 = param[2],
            k$0 = param[1],
            c = caml_call2(Stdlib_String[9], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[9], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$1 ? compare_opt(compare_decoded, t$0[7], t[7]) : c$1;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cm_ = init[3],
     _ci_ = init[7],
     _cj_ = init[6],
     _ck_ = init[5],
     _cl_ = init[4];
    if(_cm_){
     var match = _cm_[1], _cn_ = match[1];
     if(267950263 === _cn_)
      var
       host = match[2],
       _co_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cn_)
      var
       host$0 = match[2],
       x$0 = Scheme[2].call(null, host$0),
       _co_ = [0, [0, 803994504, x$0]];
     else
      var
       host$1 = match[2],
       _co_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cp_ = _co_;
    }
    else
     var _cp_ = 0;
    var param = init[1], f = Stdlib_String[26], _cq_ = init[2];
    if(param)
     var x = param[1], _cr_ = [0, caml_call1(f, x)];
    else
     var _cr_ = 0;
    return [0, _cr_, _cq_, _cp_, _cl_, _ck_, _cj_, _ci_];
   }
   function to_string(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     if(opt)
      var sth = opt[1], component = sth;
     else
      var component = 892015045;
     var x$0 = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, x$0);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _b5_ = uri[3], _b6_ = uri[4];
     if(! uri[2] && ! _b5_ && ! _b6_){var _b7_ = 0; break a;}
     var _b7_ = 1;
    }
    if(_b7_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      x$0 = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, x$0);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _b8_ = uri[3];
    if(_b8_){
     var match$2 = _b8_[1], _b9_ = match$2[1];
     if(267950263 === _b9_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _b9_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _b__ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _b__);
    }
    var _b$_ = uri[5];
    if(_b$_){
     var first_segment = _b$_[1];
     if(first_segment !== cst$33){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _ca_ = uri[5],
       x$1 = encoded_of_path(scheme, pct_encoder$0[4])(_ca_);
      caml_call2(Stdlib_Buffer[16], buf, x$1);
     }
     else{
      var
       _ch_ = uri[5],
       x$2 = encoded_of_path(scheme, pct_encoder$0[4])(_ch_);
      caml_call2(Stdlib_Buffer[16], buf, x$2);
     }
    }
    var _cb_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cb_[0]){
       var _cc_ = _cb_[1];
       if(_cc_){var q = _cc_; break b;}
      }
      else if(_cb_[1]){
       var
        _ce_ = _cb_[2],
        _cf_ = caml_obj_tag(_ce_),
        _cg_ =
          250 === _cf_
           ? _ce_[1]
           : 246 === _cf_ ? caml_call1(CamlinternalLazy[2], _ce_) : _ce_,
        q = _cg_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cd_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cd_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _b4_ = uri[3];
    if(! _b4_) return 0;
    var match = _b4_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    if(opt)
     var sth = opt[1], default$0 = sth;
    else
     var default$0 = cst_localhost;
    var match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      x = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var x = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, x];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _b3_ = uri[2];
    if(! _b3_) return 0;
    var user = _b3_[1][1];
    return [0, user];
   }
   function password(uri){
    var _b2_ = uri[2];
    if(_b2_){
     var match = _b2_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _b1_ = uri[2];
    if(! _b1_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _b1_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match)
     var
      s = match[1],
      _bZ_ = uri[5],
      x = encoded_of_path([0, s], pct_encoder$0[4])(_bZ_);
    else
     var _b0_ = uri[5], x = encoded_of_path(0, pct_encoder$0[4])(_b0_);
    return x;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && path$0[1] !== cst$33)
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _bX_ = [0, caml_call2(Stdlib_List[46], k, q)]; return _bX_;}
    catch(_bY_){
     var _bW_ = caml_wrap_exception(_bY_);
     if(_bW_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_bW_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[6], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    return caml_call2
            (Stdlib_List[19],
             function(param){
              var v = param[2], k = param[1];
              return [0, k, [0, v, 0]];
             },
             q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _bU_ = uri[7], _bV_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bV_, _bU_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _bS_ = uri[7],
     _bT_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bT_, _bS_];
   }
   function add_query_params(uri, ps){
    var
     _bP_ = uri[7],
     _bQ_ = kv(uri[6]),
     _bR_ = [0, caml_call2(Stdlib[37], ps, _bQ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bR_, _bP_];
   }
   function add_query_params$0(uri, ps){
    var
     _bL_ = uri[7],
     _bM_ = kv(uri[6]),
     _bN_ = q_s(ps),
     _bO_ = [0, caml_call2(Stdlib[37], _bN_, _bM_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bO_, _bL_];
   }
   function remove_query_param(uri, k){
    var
     _bI_ = uri[7],
     _bJ_ = kv(uri[6]),
     _bK_ =
       [0,
        caml_call2
         (Stdlib_List[41],
          function(param){var k$0 = param[1]; return k !== k$0 ? 1 : 0;},
          _bJ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bK_, _bI_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(p !== cst$34){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _bG_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _bG_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _bH_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _bH_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bp_ = uri[7],
       _bq_ = uri[6],
       _br_ = remove_dot_segments(uri[5]),
       _bs_ = [0, uri[1], uri[2], uri[3], uri[4], _br_, _bq_, _bp_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(path_str == cst$34)
        var
         _bw_ = init[7],
         _bx_ = init[6][1] ? init[6] : base[6],
         _by_ = [0, init[1], init[2], init[3], init[4], base[5], _bx_, _bw_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _bz_ = init[7],
         _bA_ = init[6],
         _bB_ = remove_dot_segments(init[5]),
         _by_ = [0, init[1], init[2], init[3], init[4], _bB_, _bA_, _bz_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _bC_ = init[7],
         _bD_ = init[6],
         match = caml_call1(Stdlib_List[9], bpath);
        b:
        {
         if(bhost && ! match){var _bE_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(match[1] !== cst$33){
           var _bo_ = match[2];
           if(! _bo_) break c;
           if(_bo_[1] !== cst$33) break c;
           var rbpath = _bo_[2];
          }
          else
           var rbpath = match[2];
          var _bE_ = caml_call2(Stdlib_List[12], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _bE_ = relpath;
        }
        var
         _bF_ = remove_dot_segments(_bE_),
         _by_ = [0, init[1], init[2], init[3], init[4], _bF_, _bD_, _bC_];
       }
       var _bs_ = _by_;
       break a;
      }
      var
       _bt_ = uri[7],
       _bu_ = uri[6],
       _bv_ = remove_dot_segments(uri[5]),
       _bs_ = [0, base[1], uri[2], uri[3], uri[4], _bv_, _bu_, _bt_];
     }
    }
    return normalize(schem$0, _bs_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bk_ = uri$0[7],
     _bl_ = uri$0[6],
     _bm_ = Scheme[4].call(null, uri$0[5]),
     _bn_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bn_, _bm_, _bl_, _bk_];
   }
   function pp(ppf, uri){
    var _bj_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bj_);
   }
   function pp_hum(ppf, uri){
    var _bi_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bi_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bh_ = caml_call2(Stdlib_List[19], string_of_char, chars);
    return caml_call2(Stdlib_String[6], cst$20, _bh_);
   }
   var
    _l_ = caml_call1(Angstrom[51], 0),
    _m_ = caml_call1(Angstrom[4], 58),
    _n_ =
      caml_call1
       (Angstrom[13],
        function(c){
         var _bd_ = 58 !== c ? 1 : 0;
         if(_bd_){
          var _be_ = 47 !== c ? 1 : 0;
          if(_be_)
           var _bf_ = 63 !== c ? 1 : 0, _bg_ = _bf_ ? 35 !== c ? 1 : 0 : _bf_;
          else
           var _bg_ = _be_;
         }
         else
          var _bg_ = _bd_;
         return _bg_;
        }),
    _o_ = caml_call2(Angstrom[59], _n_, _m_),
    _p_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _o_),
    scheme$0 = caml_call2(Angstrom[47], _p_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    hex_digit =
      caml_call1
       (Angstrom[7],
        function(param){
         var _bc_ = param - 48 | 0;
         a:
         {
          if(22 < _bc_ >>> 0){
           if(5 < _bc_ - 49 >>> 0) break a;
          }
          else if(6 >= _bc_ - 10 >>> 0) break a;
          return 1;
         }
         return 0;
        }),
    _q_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _q_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58),
    _r_ =
      caml_call1
       (Angstrom[14], function(param){return 9 < param - 48 >>> 0 ? 0 : 1;}),
    dec_octet =
      caml_call2
       (Angstrom[53],
        _r_,
        function(num){
         return 256 <= caml_int_of_string(num)
                 ? caml_call1(Angstrom[52], cst_invalid_octect)
                 : caml_call1(Angstrom[51], num);
        }),
    _s_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _t_ = caml_call2(Angstrom[37], 3, _s_),
    ipv4_address =
      caml_call3
       (Angstrom[61],
        function(three, one){
         var
          _ba_ = caml_call2(Stdlib[28], cst$21, one),
          _bb_ = caml_call2(Stdlib_String[6], cst$22, three);
         return caml_call2(Stdlib[28], _bb_, _ba_);
        },
        _t_,
        dec_octet),
    after_double_colon =
      caml_call1
       (Angstrom[45],
        function(f){
         var
          _a7_ = caml_call1(Angstrom[51], 0),
          _a8_ = caml_call2(Angstrom[58], c_colon, f),
          _a9_ = caml_call2(Angstrom[47], _a8_, _a7_),
          _a__ =
            caml_call3
             (Angstrom[61],
              function(x, y){return [0, x, y];},
              hexadecimal,
              _a9_),
          _a$_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
         return caml_call2(Angstrom[47], _a$_, _a__);
        });
   function double_colon(count){
    var
     _a5_ = caml_call1(Angstrom[51], _u_),
     _a6_ =
       caml_call2
        (Angstrom[53],
         after_double_colon,
         function(rest){
          var
           filler_length =
             (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
          return 0 < filler_length
                  ? caml_call1(Angstrom[51], [0, cst$23, rest])
                  : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
         });
    return caml_call2(Angstrom[47], _a6_, _a5_);
   }
   function part(n){
    if(6 !== n)
     return 7 === n
             ? caml_call2
               (Angstrom[60], function(x){return [0, x, 0];}, hexadecimal)
             : hex_part(n);
    var
     _a3_ = hex_part(6),
     _a4_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _a4_, _a3_);
   }
   function hex_part(n){
    var
     _aY_ = part(n + 1 | 0),
     _aZ_ = double_colon(n + 1 | 0),
     _a0_ = caml_call2(Angstrom[58], c_colon, _aZ_),
     _a1_ = caml_call2(Angstrom[47], _a0_, _aY_),
     _a2_ = caml_call2(Angstrom[58], c_colon, _a1_);
    return caml_call3
            (Angstrom[61],
             function(x, y){return [0, x, y];},
             hexadecimal,
             _a2_);
   }
   function split_with(f, xs){
    if(! xs) return _v_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return segment !== cst$34 ? 1 : 0;}, segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[6], cst$24, before_double_colon);
    a:
    {
     if(after_double_colon && after_double_colon[1] === cst$34){
      var
       xs = after_double_colon[2],
       _aW_ = caml_call2(Stdlib_String[6], cst$25, xs),
       _aX_ = caml_call2(Stdlib[28], cst$26, _aW_),
       res = caml_call2(Stdlib[28], before, _aX_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _w_ = part(0),
    _x_ = double_colon(0),
    _y_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _z_ = caml_call2(Angstrom[58], _y_, _x_),
    _A_ = caml_call2(Angstrom[47], _z_, _w_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _A_),
    _B_ = caml_call1(Angstrom[4], 93),
    _C_ = caml_call1(Angstrom[4], 91),
    _D_ = caml_call2(Angstrom[58], _C_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _D_, _B_),
    _E_ = caml_call2(Angstrom[37], 2, hex_digit),
    _F_ = caml_call1(Angstrom[4], 37),
    pct_encoded =
      caml_call3
       (Angstrom[61],
        function(pct, digits){return string_of_char_list([0, pct, digits]);},
        _F_,
        _E_),
    sub_delims$0 =
      caml_call1
       (Angstrom[7],
        function(param){
         var _aU_ = param - 59 | 0;
         a:
         {
          if(2 < _aU_ >>> 0){
           var _aV_ = _aU_ + 26 | 0;
           if(11 < _aV_ >>> 0) break a;
           switch(_aV_){case 1:case 2:case 4: break a;
           }
          }
          else if(1 === _aU_) break a;
          return 1;
         }
         return 0;
        }),
    unreserved =
      caml_call1
       (Angstrom[7],
        function(param){
         a:
         {
          if(91 <= param){
           var _aS_ = param - 95 | 0;
           if(27 < _aS_ >>> 0){
            if(31 !== _aS_) break a;
           }
           else if(1 === _aS_) break a;
          }
          else{
           var _aT_ = param - 45 | 0;
           if(12 < _aT_ >>> 0){
            if(20 > _aT_) break a;
           }
           else if(2 === _aT_) break a;
          }
          return 1;
         }
         return 0;
        }),
    _G_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _H_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _G_],
    _I_ = caml_call2(Angstrom[48], 0, _H_),
    _J_ = caml_call1(Angstrom[38], _I_),
    _K_ = caml_call1(Stdlib_String[6], cst$27),
    reg_name = caml_call2(Angstrom[60], _K_, _J_),
    _L_ =
      [0,
       caml_call2
        (Angstrom[55],
         reg_name,
         function(s){return [0, 803994504, decode(s)];}),
       0],
    _M_ =
      [0,
       caml_call2
        (Angstrom[55], ipv6_address, function(h){return [0, 267950263, h];}),
       _L_],
    _N_ =
      [0,
       caml_call2
        (Angstrom[55], ipv4_address, function(h){return [0, -367671627, h];}),
       _M_],
    host$0 = caml_call2(Angstrom[48], 0, _N_),
    _O_ = caml_call1(Angstrom[51], 0),
    _P_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _P_]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call2(Angstrom[59], _T_, c_at),
    _V_ =
      caml_call2
       (Angstrom[60],
        function(x){
         var s = caml_call2(Stdlib_String[6], cst$28, x);
         return [0, userinfo_of_encoded(s)];
        },
        _U_),
    userinfo$0 = caml_call2(Angstrom[47], _V_, _O_),
    port$0 =
      caml_call2
       (Angstrom[53],
        Angstrom[1],
        function(param){
         if(param && 58 === param[1]){
          var
           _aO_ = caml_call1(Angstrom[13], is_digit),
           _aP_ = caml_call2(Angstrom[58], c_colon, _aO_);
          return caml_call2
                  (Angstrom[55],
                   _aP_,
                   function(port){
                    var decoded = decode(port);
                    try{
                     var _aQ_ = [0, caml_int_of_string(decoded)];
                     return _aQ_;
                    }
                    catch(_aR_){return 0;}
                   });
         }
         return caml_call1(Angstrom[51], 0);
        }),
    _X_ = caml_call1(Angstrom[51], _W_),
    _Y_ =
      caml_call4
       (Angstrom[62],
        function(userinfo, host, port){return [0, userinfo, [0, host], port];},
        userinfo$0,
        host$0,
        port$0),
    _Z_ = caml_call1(Angstrom[8], cst$29),
    ___ = caml_call2(Angstrom[58], _Z_, _Y_),
    authority = caml_call2(Angstrom[47], ___, _X_),
    _$_ =
      caml_call1
       (Angstrom[13],
        function(param){if(35 !== param && 63 !== param) return 1; return 0;}),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _$_),
    _aa_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _ab_ = caml_call1(Angstrom[51], _aa_),
    _ac_ =
      caml_call1(Angstrom[15], function(param){return 35 === param ? 1 : 0;}),
    _ad_ = caml_call1(Angstrom[4], 63),
    _ae_ = caml_call2(Angstrom[58], _ad_, _ac_),
    _af_ = caml_call2(Angstrom[60], of_raw, _ae_),
    query$0 = caml_call2(Angstrom[47], _af_, _ab_),
    _ag_ = caml_call1(Angstrom[51], 0),
    _ah_ = caml_call1(Angstrom[13], function(param){return 1;}),
    _ai_ = caml_call1(Angstrom[4], 35),
    _aj_ = caml_call2(Angstrom[58], _ai_, _ah_),
    _ak_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _aj_),
    fragment$0 = caml_call2(Angstrom[47], _ak_, _ag_),
    _al_ =
      caml_call5
       (Angstrom[63],
        function(scheme, param, path, query, fragment){
         var port = param[3], host = param[2], userinfo = param[1];
         return normalize
                 (scheme,
                  [0, scheme, userinfo, host, port, path, query, fragment]);
        },
        scheme$0,
        authority,
        path$0,
        query$0),
    uri_reference = caml_call2(Angstrom[56], _al_, fragment$0),
    _am_ =
      caml_call1(Angstrom[13], function(param){return 10 === param ? 0 : 1;}),
    uri_reference$0 =
      caml_call2
       (Angstrom[55],
        _am_,
        function(s){
         var match = caml_call3(Angstrom[75], 1, uri_reference, s);
         if(0 !== match[0]) return empty;
         var t = match[1];
         return t;
        });
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _ao_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && path$0[1] !== cst$33){var _aL_ = [0, cst$30, path$0]; break a;}
      var _aL_ = path$0;
     }
     var path$1 = _aL_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _an_;
    var scheme$0 = decode(scheme), _aM_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _aN_ = [0, decode_host(host$1)];
    else
     var _aN_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _aN_, port, path$1, query$0, _aM_]);
   }
   function with_host(init, host){
    var _aG_ = init[7], _aH_ = init[6], _aI_ = init[5], _aJ_ = init[4];
    if(host)
     var host$0 = host[1], _aK_ = [0, decode_host(host$0)];
    else
     var _aK_ = 0;
    return [0, init[1], init[2], _aK_, _aJ_, _aI_, _aH_, _aG_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    var
     u$0 =
       with$0
        (with_port,
         port,
         with$0
          (with_host,
           host,
           with$0(with_userinfo, userinfo, with$0(with_scheme, scheme, uri))));
    if(path){
     var x$0 = path[1];
     if(x$0)
      var p = x$0[1], _aF_ = with_path(u$0, p);
     else
      var _aF_ = with_path(u$0, cst$31);
     var u = _aF_;
    }
    else
     var u = u$0;
    if(query){
     var x = query[1];
     if(x)
      var q = x[1], _aE_ = with_query(u, q);
     else
      var _aE_ = with_query(u, 0);
     var _aD_ = _aE_;
    }
    else
     var _aD_ = u;
    return with$0(with_fragment, fragment, _aD_);
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? x : x$0;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aA_(scheme){
     return caml_call2
             (let$0,
              caml_call2(Stdlib_Option[14], _ap_, host),
              function(host){
               return [0,
                       [0, scheme, userinfo, host, port, path, query, fragment]];
              });
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aB_ =
        unsupported_scheme !== cst_http
         ? unsupported_scheme
           !== cst_https
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aq_, unsupported_scheme)]]
           : _ar_
         : _as_,
      _aC_ = _aB_;
    else
     var _aC_ = _at_;
    return caml_call2(let$0, _aC_, _aA_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && path$0[1] !== cst$33){
       var _ay_ = [0, cst$32, path$0];
       break a;
      }
      var _ay_ = path$0;
     }
     var path$1 = _ay_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _au_;
    if(fragment) var x$0 = fragment[1], _az_ = [0, x$0]; else var _az_ = 0;
    var match = decode_host(host$2), _aw_ = match[1];
    if(267950263 === _aw_)
     var
      host = match[2],
      _ax_ = [0, 267950263, caml_call1(Stdlib_String[26], host)];
    else if(803994504 <= _aw_)
     var
      host$0 = match[2],
      x = caml_call1(Stdlib_String[26], host$0),
      _ax_ = [0, 803994504, x];
    else
     var
      host$1 = match[2],
      _ax_ = [0, -367671627, caml_call1(Stdlib_String[26], host$1)];
    return [0, scheme, userinfo$0, _ax_, port, path$1, query$0, _az_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIngiLCJ4JDAiLCJjc3QkMTUiLCJjc3QkMTMiLCJjc3QkMTIiLCJjc3QkMCIsIml0ZXJfY29uY2F0IiwiZm4iLCJzZXAiLCJidWYiLCJsYXN0IiwicmVzdCIsImNvbXBhcmVfb3B0IiwiYyIsInQkMCIsInQiLCJhIiwiYiIsImNvbXBhcmVfbGlzdCIsImYiLCJ0JDIiLCJ0JDEiLCJ4cyIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJpIiwic2FmZV9jaGFycyIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJzYWZlX2NoYXJzJDAiLCJpJDAiLCJjJDAiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQwIiwibm9ybWFsaXplX2hvc3QkMCIsImhzIiwiY2Fub25pY2FsaXplX3BvcnQkMCIsImNhbm9uaWNhbGl6ZV9wYXRoJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJzdGgkMCIsInVzZXJpbmZvIiwic3RoJDEiLCJob3N0Iiwic3RoJDIiLCJzdGgkMyIsInF1ZXJ5X2tleSIsInN0aCQ0IiwicXVlcnlfdmFsdWUiLCJzdGgkNSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInAkMCIsInUkMCIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsIngkMSIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIkMyIsInIkMSIsInIkMCIsInIkMiIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsInMkMCIsImVsIiwiayIsInRsIiwidiIsImwiLCJsJDAiLCJuIiwidGwkMCIsIm4kMCIsInRsJDEiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9ob3N0IiwiaDEiLCJoMiIsImlwMiIsImlwMSIsImlwMiQwIiwiaXAxJDAiLCJoMiQwIiwiaDEkMCIsImNvbXBhcmUkMCIsImMkMiIsImMkMyIsImMkNCIsImt2bCQwIiwia3ZsIiwicmF3IiwicmF3JDAiLCJjJDEiLCJ2bCIsInZsJDAiLCJrJDAiLCJlcXVhbCIsInVuY2FzdF9vcHQiLCJub3JtYWxpemUiLCJzY2hlbSIsImluaXQiLCJob3N0JDAiLCJob3N0JDEiLCJ0b19zdHJpbmciLCJ1cmkiLCJhZGRfcGN0X3N0cmluZyIsImZpcnN0X3NlZ21lbnQiLCJ4JDIiLCJxIiwiZ2V0X2RlY29kZWRfb3B0Iiwid2l0aF9zY2hlbWUiLCJoJDAiLCJob3N0X3dpdGhfZGVmYXVsdCIsImRlZmF1bHQkMCIsIndpdGhfdXNlcmluZm8iLCJ1c2VyaW5mbyQwIiwidXNlciIsInBhc3N3b3JkIiwicGFzcyIsIndpdGhfcGFzc3dvcmQiLCJyZXN1bHQiLCJ3aXRoX3BvcnQiLCJ3aXRoX3BhdGgiLCJwYXRoJDAiLCJ3aXRoX2ZyYWdtZW50IiwiZnJhZyIsInF1ZXJ5IiwidmVyYmF0aW1fcXVlcnkiLCJnZXRfcXVlcnlfcGFyYW0iLCJnZXRfcXVlcnlfcGFyYW0kMCIsIndpdGhfcXVlcnkiLCJxX3MiLCJ3aXRoX3F1ZXJ5JDAiLCJhZGRfcXVlcnlfcGFyYW0iLCJhZGRfcXVlcnlfcGFyYW0kMCIsImFkZF9xdWVyeV9wYXJhbXMiLCJhZGRfcXVlcnlfcGFyYW1zJDAiLCJyZW1vdmVfcXVlcnlfcGFyYW0iLCJwYXRoX2FuZF9xdWVyeSIsIm1hdGNoIiwic2NoZW1lJDAiLCJyZXNvbHZlIiwiYmFzZSIsInNjaGVtZSQxIiwic2NoZW0kMCIsInBhdGhfc3RyIiwicmVscGF0aCIsImJwYXRoIiwiYmhvc3QiLCJyYnBhdGgiLCJjYW5vbmljYWxpemUiLCJ1cmkkMCIsInBwIiwicHBmIiwicHBfaHVtIiwic3RyaW5nX29mX2NoYXIiLCJzdHJpbmdfb2ZfY2hhcl9saXN0IiwiY2hhcnMiLCJpc19kaWdpdCIsImhleF9kaWdpdCIsImhleGFkZWNpbWFsIiwiY19kb3QiLCJjX2F0IiwiY19jb2xvbiIsImRlY19vY3RldCIsIm51bSIsImlwdjRfYWRkcmVzcyIsInRocmVlIiwib25lIiwiYWZ0ZXJfZG91YmxlX2NvbG9uIiwiZG91YmxlX2NvbG9uIiwiY291bnQiLCJmaWxsZXJfbGVuZ3RoIiwicGFydCIsImhleF9wYXJ0Iiwic3BsaXRfd2l0aCIsInRzIiwienMiLCJmb3JtYXRfYWRkciIsInNlZ21lbnRzIiwic2VnbWVudCIsImJlZm9yZV9kb3VibGVfY29sb24iLCJiZWZvcmUiLCJyZXMiLCJpcHY2IiwiaXB2Nl9hZGRyZXNzIiwicGN0X2VuY29kZWQiLCJwY3QiLCJkaWdpdHMiLCJzdWJfZGVsaW1zJDAiLCJ1bnJlc2VydmVkIiwicmVnX25hbWUiLCJwb3J0JDAiLCJkZWNvZGVkIiwiYXV0aG9yaXR5IiwicXVlcnkkMCIsImZyYWdtZW50JDAiLCJ1cmlfcmVmZXJlbmNlIiwidXJpX3JlZmVyZW5jZSQwIiwiZGVjb2RlX2hvc3QiLCJwYXJzZWQiLCJwYXJzZWQkMCIsIm1ha2UiLCJwYXRoJDEiLCJ3aXRoX2hvc3QiLCJ3aXRoX3VyaSIsIndpdGgkMCIsIm8iLCJvZl9zdHJpbmciLCJsZXQkMCIsInRvX3VyaSIsIm9mX3VyaSIsInVuc3VwcG9ydGVkX3NjaGVtZSIsIm9mX3N0cmluZyQwIiwiZXJyb3IiLCJ0b19zdHJpbmckMCIsIm1ha2UkMCIsImhvc3QkMiJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi91cmkvdXJpLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7OztJQXlRbUJBO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFBQUM7SUFBQUM7O0lBQUFDOzs7Ozs7Ozs7OztJQXJOREM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBUlZDLFlBQVlDLElBQUdDLEtBQUlDOzs7bUJBTWpCO1NBTE5DO3NCQUFZLE9BQUEsV0FESUgsSUFBT0UsS0FDdkJDO1NBQ0lDO0tBQ0osV0FIZ0JKLElBQU9FLEtBQ3ZCQztLQUdBLDhCQUp1QkQsS0FB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QTZMO09BN1pBNUY7T0FvQ0E1STtPQUNBcUo7T0FtQkFuRztPQUNBc0c7T0FvRkE0QjtPQUNBRTtXQXlGRThCLE1Bb0lBYztXQXlIQWEsUUFmQUQsUUFrQ0FHLGFBSUFFLGFBYUFDLFFBcUJBbEgsUUFLQXlDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBBbmlsIE1hZGhhdmFwZWRkeSA8YW5pbEByZWNvaWwub3JnPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGF2aWQgU2hlZXRzIDxzaGVldHNAYWx1bS5taXQuZWR1PlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICopXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5cbnR5cGUgY29tcG9uZW50ID0gW1xuICB8IGBTY2hlbWVcbiAgfCBgQXV0aG9yaXR5XG4gIHwgYFVzZXJpbmZvICgqIHN1YmNvbXBvbmVudCBvZiBhdXRob3JpdHkgaW4gc29tZSBzY2hlbWVzICopXG4gIHwgYEhvc3QgKCogc3ViY29tcG9uZW50IG9mIGF1dGhvcml0eSBpbiBzb21lIHNjaGVtZXMgKilcbiAgfCBgUGF0aFxuICB8IGBRdWVyeVxuICB8IGBRdWVyeV9rZXlcbiAgfCBgUXVlcnlfdmFsdWVcbiAgfCBgRnJhZ21lbnRcbiAgfCBgR2VuZXJpY1xuICB8IGBDdXN0b20gb2YgKGNvbXBvbmVudCAqIHN0cmluZyAqIHN0cmluZykgKCogKGNvbXBvbmVudCAqIHNhZmUgY2hhcnMgKiB1bnNhZmUgY2hhcnMpICopXG5dXG5cbnR5cGUgcGN0X2VuY29kZXIgPSB7XG4gICAgc2NoZW1lOiBjb21wb25lbnQ7XG4gICAgdXNlcmluZm86IGNvbXBvbmVudDtcbiAgICBob3N0OiBjb21wb25lbnQ7XG4gICAgcGF0aDogY29tcG9uZW50O1xuICAgIHF1ZXJ5X2tleTogY29tcG9uZW50O1xuICAgIHF1ZXJ5X3ZhbHVlOiBjb21wb25lbnQ7XG4gICAgZnJhZ21lbnQ6IGNvbXBvbmVudDtcbiAgfVxuXG5sZXQgcmVjIGl0ZXJfY29uY2F0IGZuIHNlcCBidWYgPSBmdW5jdGlvblxuICB8IGxhc3Q6OltdIC0+IGZuIGJ1ZiBsYXN0XG4gIHwgZWw6OnJlc3QgLT5cbiAgICBmbiBidWYgZWw7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHNlcDtcbiAgICBpdGVyX2NvbmNhdCBmbiBzZXAgYnVmIHJlc3RcbiAgfCBbXSAtPiAoKVxuXG5sZXQgcmV2X2ludGVyamVjdCBlIGxzdCA9XG4gIGxldCByZWMgYXV4IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgLT4gYWNjXG4gICAgfCB4Ojp4cyAtPiBhdXggKHg6OmU6OmFjYykgeHNcbiAgaW4gbWF0Y2ggbHN0IHdpdGhcbiAgfCBbXSAgLT4gW11cbiAgfCBoOjp0IC0+IGF1eCBbaF0gdFxuXG5sZXQgY29tcGFyZV9vcHQgYyB0IHQnID0gbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsICAgTm9uZSAgIC0+IDBcbiAgfCBTb21lIF8sIE5vbmUgICAtPiAxXG4gIHwgTm9uZSwgICBTb21lIF8gLT4gLTFcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBjIGEgYlxuXG5sZXQgcmVjIGNvbXBhcmVfbGlzdCBmIHQgdCcgPSBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgW10sICAgIFtdICAgIC0+ICAwXG4gIHwgXzo6XywgIFtdICAgIC0+ICAxXG4gIHwgW10sICAgIF86Ol8gIC0+IC0xXG4gIHwgeDo6eHMsIHk6OnlzIC0+XG4gICAgbWF0Y2ggZiB4IHkgd2l0aCAwIC0+IGNvbXBhcmVfbGlzdCBmIHhzIHlzIHwgYyAtPiBjXG5cbigqKiBTYWZlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYWx3YXlzIGFsbG93ZWQgaW4gYSBVUklcbiAgKiBVbmZvcnR1bmF0ZWx5LCB0aGlzIHZhcmllcyBkZXBlbmRpbmcgb24gd2hpY2ggYml0IG9mIHRoZSBVUklcbiAgKiBpcyBiZWluZyBwYXJzZWQsIHNvIHRoZXJlIGFyZSBtdWx0aXBsZSB2YXJpYW50cyAoYW5kIHRoaXNcbiAgKiBzZXQgaXMgcHJvYmFibHkgbm90IGV4aGF1c3RpdmUuIFRPRE86IGNoZWNrLlxuKilcbnR5cGUgc2FmZV9jaGFycyA9IGJvb2wgYXJyYXlcblxubW9kdWxlIHR5cGUgU2NoZW1lID0gc2lnXG4gIHZhbCBzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgOiBjb21wb25lbnQgLT4gc2FmZV9jaGFyc1xuICB2YWwgbm9ybWFsaXplX2hvc3QgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBjYW5vbmljYWxpemVfcG9ydCA6IGludCBvcHRpb24gLT4gaW50IG9wdGlvblxuICB2YWwgY2Fub25pY2FsaXplX3BhdGggOiBzdHJpbmcgbGlzdCAtPiBzdHJpbmcgbGlzdFxuZW5kXG5cbm1vZHVsZSBHZW5lcmljIDogU2NoZW1lID0gc3RydWN0XG4gIGxldCBzdWJfZGVsaW1zIGEgPVxuICAgIGxldCBzdWJkID0gXCIhJCYnKCkqKyw7PVwiIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3ViZCAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIHN1YmQuW2ldIGluXG4gICAgICBhLihjKSA8LSB0cnVlXG4gICAgZG9uZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnMgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5Lm1ha2UgMjU2IGZhbHNlIGluXG4gICAgbGV0IGFsd2F5c19zYWZlID1cbiAgICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLi1+XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBhbHdheXNfc2FmZSAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIGFsd2F5c19zYWZlLltpXSBpblxuICAgICAgYS4oYykgPC0gdHJ1ZVxuICAgIGRvbmU7XG4gICAgYVxuXG4gIGxldCBwY2hhciA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gc3ViX2RlbGltcyAoQXJyYXkuY29weSBzYWZlX2NoYXJzKSBpblxuICAgIGEuKENoYXIuY29kZSAnOicpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICdAJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3NjaGVtZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzIGluXG4gICAgYS4oQ2hhci5jb2RlICcrJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgKCoqIFNhZmUgY2hhcmFjdGVycyBmb3IgdGhlIHBhdGggY29tcG9uZW50IG9mIGEgVVJJICopXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9wYXRoIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBzdWJfZGVsaW1zIChBcnJheS5jb3B5IHBjaGFyKSBpblxuICAgICgqIGRlbGltaXRlcjogbm9uLXNlZ21lbnQgZGVsaW1pdGluZyB1c2VzIHNob3VsZCBiZSBwY3QgZW5jb2RlZCAqKVxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnkgOiBzYWZlX2NoYXJzID1cbiAgICAoKiBUT0RPOiBXaGF0IGFib3V0IHtcIiFcIixcIiRcIixcIixcIn0/IFNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2F2c20vb2NhbWwtdXJpL2NvbW1pdC8xZWYzZjFkZmI0MWJkYjRmMzNmMjIzZmZlMTZlNjJhMzM5NzU2NjFhI2RpZmYtNzQwZjJkZTUzYzllYjM2ZTk2NzBkZGZiZGI5YmE5MTRSMTcxPiAqKVxuICAgIGxldCBhID0gQXJyYXkuY29weSBwY2hhciBpblxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICc/JykgPC0gdHJ1ZTtcbiAgICAoKiAnJicgaXMgc2FmZSBidXQgd2Ugc2hvdWxkIGVuY29kZSBsaXRlcmFscyB0byBhdm9pZCBhbWJpZ3VpdHlcbiAgICAgICB3aXRoIHRoZSBhbHJlYWR5IHBhcnNlZCBxcyBwYXJhbXMgKilcbiAgICBhLihDaGFyLmNvZGUgJyYnKSA8LSBmYWxzZTtcbiAgICAoKiAnOycgaXMgc2FmZSBidXQgc29tZSBzeXN0ZW1zIHRyZWF0IGl0IGxpa2UgJyYnLiAqKVxuICAgIGEuKENoYXIuY29kZSAnOycpIDwtIGZhbHNlO1xuICAgIGEuKENoYXIuY29kZSAnKycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5IDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IGluXG4gICAgYS4oQ2hhci5jb2RlICc9JykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeV92YWx1ZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzX2Zvcl9xdWVyeSBpblxuICAgIGEuKENoYXIuY29kZSAnLCcpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfZnJhZ21lbnQgOiBzYWZlX2NoYXJzID0gc2FmZV9jaGFyc19mb3JfcXVlcnlcblxuICAoKiogU2FmZSBjaGFyYWN0ZXJzIGZvciB0aGUgdXNlcmluZm8gc3ViY29tcG9uZW50IG9mIGEgVVJJLlxuICAgICAgVE9ETzogdGhpcyBuZWVkcyBtb3JlIHJlc2VydmVkIGNoYXJhY3RlcnMgYWRkZWQgKilcbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnMgaW5cbiAgICAoKiBkZWxpbWl0ZXI6IG5vbi1zZWdtZW50IGRlbGltaXRpbmcgdXNlcyBzaG91bGQgYmUgcGN0IGVuY29kZWQgKilcbiAgICBhLihDaGFyLmNvZGUgJzonKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHJlYyBzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgPSBmdW5jdGlvblxuICAgIHwgYFBhdGggLT4gc2FmZV9jaGFyc19mb3JfcGF0aFxuICAgIHwgYFVzZXJpbmZvIC0+IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvXG4gICAgfCBgUXVlcnkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlcbiAgICB8IGBRdWVyeV9rZXkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5XG4gICAgfCBgUXVlcnlfdmFsdWUgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWVcbiAgICB8IGBGcmFnbWVudCAtPiBzYWZlX2NoYXJzX2Zvcl9mcmFnbWVudFxuICAgIHwgYFNjaGVtZSAtPiBzYWZlX2NoYXJzX2Zvcl9zY2hlbWVcbiAgICB8IGBDdXN0b20gKChjb21wb25lbnQgOiBjb21wb25lbnQpLCBzYWZlLCB1bnNhZmUpIC0+XG4gICAgICAgbGV0IHNhZmVfY2hhcnMgPSBBcnJheS5jb3B5IChzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgY29tcG9uZW50KSBpblxuICAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHNhZmUgLSAxIGRvXG4gICAgICAgICBsZXQgYyA9IENoYXIuY29kZSBzYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gdHJ1ZVxuICAgICAgIGRvbmU7XG4gICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggdW5zYWZlIC0gMSBkb1xuICAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgdW5zYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gZmFsc2VcbiAgICAgICBkb25lO1xuICAgICAgIHNhZmVfY2hhcnNcbiAgICB8IGBHZW5lcmljXG4gICAgfCBfIC0+IHNhZmVfY2hhcnNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHNvID0gaHNvXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0IHBvcnQgPSBwb3J0XG4gIGxldCBjYW5vbmljYWxpemVfcGF0aCBwYXRoID0gcGF0aFxuZW5kXG5cbm1vZHVsZSBIdHRwIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBocyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHNcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDgwIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIHhcblxuICBsZXQgY2Fub25pY2FsaXplX3BhdGggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW1wiL1wiXVxuICAgIHwgeCAgLT4geFxuZW5kXG5cbm1vZHVsZSBIdHRwcyA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEh0dHBcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDQ0MyAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSB4XG5lbmRcblxubW9kdWxlIEZpbGUgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzID1cbiAgICBsZXQgaHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhzIGluXG4gICAgaWYgaHM9XCJsb2NhbGhvc3RcIiB0aGVuIFwiXCIgZWxzZSBoc1xuZW5kXG5cbm1vZHVsZSBVcm4gOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbmVuZFxuXG5sZXQgbW9kdWxlX29mX3NjaGVtZSA9IGZ1bmN0aW9uXG4gIHwgU29tZSBzIC0+IGJlZ2luIG1hdGNoIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyB3aXRoXG4gICAgICB8IFwiaHR0cFwiIC0+IChtb2R1bGUgSHR0cCA6IFNjaGVtZSlcbiAgICAgIHwgXCJodHRwc1wiICAtPiAobW9kdWxlIEh0dHBzIDogU2NoZW1lKVxuICAgICAgfCBcImZpbGVcIiAtPiAobW9kdWxlIEZpbGUgOiBTY2hlbWUpXG4gICAgICB8IFwidXJuXCIgIC0+IChtb2R1bGUgVXJuIDogU2NoZW1lKVxuICAgICAgfCBfIC0+IChtb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSlcbiAgICBlbmRcbiAgfCBOb25lIC0+IChtb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSlcblxuKCoqIFBvcnRpb25zIG9mIHRoZSBVUkwgbXVzdCBiZSBjb252ZXJ0ZWQgdG8tYW5kLWZyb20gcGVyY2VudC1lbmNvZGluZ1xuICAqIGFuZCB0aGlzIHJlYWxseSwgcmVhbGx5IHNob3VsZG4ndCBiZSBtaXhlZCB1cC4gU28gdGhpcyBQY3QgbW9kdWxlXG4gICogZGVmaW5lcyBhYnN0cmFjdCBQY3QuZW5jb2RlZCBhbmQgUGN0LmRlY29kZWQgdHlwZXMgd2hpY2ggc2V0cyB0aGVcbiAgKiBzdGF0ZSBvZiB0aGUgdW5kZXJseWluZyBzdHJpbmcuICBUaGVyZSBhcmUgZnVuY3Rpb25zIHRvIFwiY2FzdFwiIHRvXG4gICogYW5kIGZyb20gdGhlc2UgYW5kIG5vcm1hbCBzdHJpbmdzLCBhbmQgdGhpcyBwcm9tb3RlcyBhIGJpdCBvZlxuICAqIGludGVybmFsIHNhZmV0eS4gIFRoZXNlIHR5cGVzIGFyZSBub3QgZXhwb3NlZCB0byB0aGUgZXh0ZXJuYWxcbiAgKiBpbnRlcmZhY2UsIGFzIGNhc3RpbmcgdG8tYW5kLWZyb20gaXMgcXVpdGUgYSBiaXQgb2YgaGFzc2xlIGFuZFxuICAqIHByb2JhYmx5IG5vdCBhIGxvdCBvZiB1c2UgdG8gdGhlIGF2ZXJhZ2UgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5XG4qKVxubW9kdWxlIFBjdCA6IHNpZ1xuICB0eXBlIGVuY29kZWRcbiAgdHlwZSBkZWNvZGVkXG5cbiAgdmFsIGVuY29kZSA6ID9zY2hlbWU6c3RyaW5nIC0+ID9jb21wb25lbnQ6Y29tcG9uZW50IC0+IGRlY29kZWQgLT4gZW5jb2RlZFxuICB2YWwgZGVjb2RlIDogZW5jb2RlZCAtPiBkZWNvZGVkXG5cbiAgKCogVGhlIGVtcHR5IGRlY29kZWQgc3RyaW5nICopXG4gIHZhbCBlbXB0eV9kZWNvZGVkIDogZGVjb2RlZFxuICAoKiBJZGVudGl0eSBmdW5jdGlvbnMgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IGNhc3Qgd2hlbiB1c2luZyB0aGVtIGJlbG93ICopXG4gIHZhbCBjYXN0X2VuY29kZWQgOiBzdHJpbmcgLT4gZW5jb2RlZFxuICB2YWwgY2FzdF9kZWNvZGVkIDogc3RyaW5nIC0+IGRlY29kZWRcbiAgdmFsIHVuY2FzdF9lbmNvZGVkIDogZW5jb2RlZCAtPiBzdHJpbmdcbiAgdmFsIHVuY2FzdF9kZWNvZGVkIDogZGVjb2RlZCAtPiBzdHJpbmdcbiAgKCogTGlmdCBIT0ZzIGZvciBtYXBzIG92ZXIgZW5jb2RpbmdzLCBkZWNvZGluZ3MsIGFuZCBzdHJpbmdzICopXG4gIHZhbCBsaWZ0X2VuY29kZWQgOiAoZW5jb2RlZCAtPiBlbmNvZGVkKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBsaWZ0X2RlY29kZWQgOiAoZGVjb2RlZCAtPiBkZWNvZGVkKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCB1bmxpZnRfZW5jb2RlZCA6IChzdHJpbmcgLT4gc3RyaW5nKSAtPiBlbmNvZGVkIC0+IGVuY29kZWRcbiAgdmFsIHVubGlmdF9kZWNvZGVkIDogKHN0cmluZyAtPiBzdHJpbmcpIC0+IGRlY29kZWQgLT4gZGVjb2RlZFxuICB2YWwgdW5saWZ0X2RlY29kZWQyIDogKHN0cmluZyAtPiBzdHJpbmcgLT4gJ2EpIC0+IGRlY29kZWQgLT4gZGVjb2RlZCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgZW5jb2RlZCA9IHN0cmluZ1xuICB0eXBlIGRlY29kZWQgPSBzdHJpbmdcbiAgbGV0IGNhc3RfZW5jb2RlZCB4ID0geFxuICBsZXQgY2FzdF9kZWNvZGVkIHggPSB4XG4gIGxldCBlbXB0eV9kZWNvZGVkID0gXCJcIlxuICBsZXQgdW5jYXN0X2RlY29kZWQgeCA9IHhcbiAgbGV0IHVuY2FzdF9lbmNvZGVkIHggPSB4XG5cbiAgbGV0IGxpZnRfZW5jb2RlZCBmID0gZlxuICBsZXQgbGlmdF9kZWNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZW5jb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2RlY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9kZWNvZGVkMiBmID0gZlxuXG4gICgqKiBTY2FuIGZvciByZXNlcnZlZCBjaGFyYWN0ZXJzIGFuZCByZXBsYWNlIHRoZW0gd2l0aFxuICAgICAgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzLlxuICAgICAgQHJldHVybiBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IGVuY29kZSA/c2NoZW1lID8oY29tcG9uZW50PWBQYXRoKSBiID1cbiAgICBsZXQgbW9kdWxlIFNjaGVtZSA9ICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgc2NoZW1lKSA6IFNjaGVtZSkgaW5cbiAgICBsZXQgc2FmZV9jaGFycyA9IFNjaGVtZS5zYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgY29tcG9uZW50IGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggYiBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgc2NhbiBzdGFydCBjdXIgPVxuICAgICAgaWYgY3VyID49IGxlbiB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgYi5bY3VyXSBpblxuICAgICAgICBpZiBzYWZlX2NoYXJzLihjKSB0aGVuXG4gICAgICAgICAgc2NhbiBzdGFydCAoY3VyKzEpXG4gICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICBpZiBjdXIgPiBzdGFydCB0aGVuIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUHJpbnRmLnNwcmludGYgXCIlJSUwMlhcIiBjKTtcbiAgICAgICAgICBzY2FuIChjdXIrMSkgKGN1cisxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGluXG4gICAgc2NhbiAwIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4gIGxldCBpbnRfb2ZfaGV4X2NoYXIgYyA9XG4gICAgbGV0IGMgPSBpbnRfb2ZfY2hhciAoQ2hhci51cHBlcmNhc2VfYXNjaWkgYykgLSA0OCBpblxuICAgIGlmIGMgPiA5XG4gICAgdGhlbiBpZiBjID4gMTYgJiYgYyA8IDIzXG4gICAgICB0aGVuIGMgLSA3XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiaW50X29mX2hleF9jaGFyXCJcbiAgICBlbHNlIGlmIGMgPj0gMFxuICAgIHRoZW4gY1xuICAgIGVsc2UgZmFpbHdpdGggXCJpbnRfb2ZfaGV4X2NoYXJcIlxuXG4gICgqKiBTY2FuIGZvciBwZXJjZW50LWVuY29kaW5nIGFuZCBjb252ZXJ0IHRoZW0gaW50byBBU0NJSS5cbiAgICAgIEByZXR1cm4gYSBwZXJjZW50LWRlY29kZWQgc3RyaW5nICopXG4gIGxldCBkZWNvZGUgYiA9XG4gICAgKCogVE9ETzogU2hvdWxkIGJvdGggc3RyaWN0IGFuZCBub24tc3RyaWN0IHZlcnNpb25zIGJlIGV4cG9zZWQ/ICopXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggYiBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgc2NhbiBzdGFydCBjdXIgPVxuICAgICAgaWYgY3VyID49IGxlbiB0aGVuIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpXG4gICAgICBlbHNlIGlmIGIuW2N1cl0gPSAnJScgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgICAgbGV0IGN1ciA9IGN1ciArIDEgaW5cbiAgICAgICAgaWYgY3VyID49IGxlbiB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnXG4gICAgICAgIGVsc2UgbWF0Y2ggaW50X29mX2hleF9jaGFyIGIuW2N1cl0gd2l0aFxuICAgICAgICB8IGV4Y2VwdGlvbiBfIC0+XG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgc2NhbiBjdXIgY3VyXG4gICAgICAgIHwgaGlnaGJpdHMgLT4gYmVnaW5cbiAgICAgICAgICBsZXQgY3VyID0gY3VyICsgMSBpblxuICAgICAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGIuW2N1ci0xXVxuICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICBsZXQgc3RhcnRfYXQgPVxuICAgICAgICAgICAgICBtYXRjaCBpbnRfb2ZfaGV4X2NoYXIgYi5bY3VyXSB3aXRoXG4gICAgICAgICAgICAgIHwgbG93Yml0cyAtPlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgKENoYXIuY2hyIChoaWdoYml0cyBsc2wgNCArIGxvd2JpdHMpKTtcbiAgICAgICAgICAgICAgICBjdXIrMVxuICAgICAgICAgICAgICB8IGV4Y2VwdGlvbiBfIC0+XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBiLltjdXItMV07XG4gICAgICAgICAgICAgICAgY3VyXG4gICAgICAgICAgICBpbiBzY2FuIHN0YXJ0X2F0IHN0YXJ0X2F0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2Ugc2NhbiBzdGFydCAoY3VyKzEpXG4gICAgaW5cbiAgICBzY2FuIDAgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5lbmRcblxuKCogUGVyY2VudCBlbmNvZGUgYSBzdHJpbmcgKilcbmxldCBwY3RfZW5jb2RlID9zY2hlbWUgPyhjb21wb25lbnQ9YFBhdGgpIHMgPVxuICBQY3QuKHVuY2FzdF9lbmNvZGVkIChlbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IChjYXN0X2RlY29kZWQgcykpKVxuXG5sZXQgcGN0X2VuY29kZXJcbiAgICAgID8oc2NoZW1lPWBTY2hlbWUpXG4gICAgICA/KHVzZXJpbmZvPWBVc2VyaW5mbylcbiAgICAgID8oaG9zdD1gSG9zdClcbiAgICAgID8ocGF0aD1gUGF0aClcbiAgICAgID8ocXVlcnlfa2V5PWBRdWVyeV9rZXkpXG4gICAgICA/KHF1ZXJ5X3ZhbHVlPWBRdWVyeV92YWx1ZSlcbiAgICAgID8oZnJhZ21lbnQ9YEZyYWdtZW50KVxuICAgICAgKCkgPVxuICB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBhdGg7IHF1ZXJ5X2tleTsgcXVlcnlfdmFsdWU7IGZyYWdtZW50IH1cblxuKCogUGVyY2VudCBkZWNvZGUgYSBzdHJpbmcgKilcbmxldCBwY3RfZGVjb2RlIHMgPSBQY3QuKHVuY2FzdF9kZWNvZGVkIChkZWNvZGUgKGNhc3RfZW5jb2RlZCBzKSkpXG5cbigqIFVzZXJpbmZvIHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYW4gaWQgKiBjcmVkZW50aWFsIHBhaXIgKilcbm1vZHVsZSBVc2VyaW5mbyA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgKiBzdHJpbmcgb3B0aW9uXG5cbiAgbGV0IGNvbXBhcmUgKHUscCkgKHUnLHAnKSA9XG4gICAgbWF0Y2ggU3RyaW5nLmNvbXBhcmUgdSB1JyB3aXRoXG4gICAgfCAwIC0+IGNvbXBhcmVfb3B0IFN0cmluZy5jb21wYXJlIHAgcCdcbiAgICB8IGMgLT4gY1xuXG4gIGxldCB1c2VyaW5mb19vZl9lbmNvZGVkIHVzID1cbiAgICBtYXRjaCBTdHJpbmdleHQuc3BsaXQgfm1heDoyIH5vbjonOicgdXMgd2l0aFxuICAgIHwgW10gLT4gKFwiXCIsTm9uZSlcbiAgICB8IFt1XSAtPiAocGN0X2RlY29kZSB1LE5vbmUpXG4gICAgfCB1OjpwOjpfIC0+IChwY3RfZGVjb2RlIHUsU29tZSAocGN0X2RlY29kZSBwKSlcblxuICBsZXQgZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQgKHUscG8pID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLihcbiAgICAgIDEgKyAobGVuZ3RoIHUpICsgKG1hdGNoIHBvIHdpdGggTm9uZSAtPiAwIHwgU29tZSBwIC0+IGxlbmd0aCBwKSlcbiAgICBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgdSk7XG4gICAgYmVnaW4gbWF0Y2ggcG8gd2l0aCBOb25lIC0+ICgpO1xuICAgIHwgU29tZSBwIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6JztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgcClcbiAgICBlbmQ7XG4gICAgUGN0LmNhc3RfZW5jb2RlZCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZilcbmVuZFxuXG5sZXQgdXNlcmluZm9fb2ZfZW5jb2RlZCA9IFVzZXJpbmZvLnVzZXJpbmZvX29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudCA9IFVzZXJpbmZvLmVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50XG5cbigqIFBhdGggc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhIGxpc3Qgb2YgcGF0aCB0b2tlbnMgKilcbm1vZHVsZSBQYXRoID0gc3RydWN0XG4gICgqIEludmFyaWFudDogZXZlcnkgZWxlbWVudCBpcyBub24temVybywgc2xhc2hlcyAoLykgb25seSBvY2N1ciBhbG9uZS4gKilcbiAgKCogWWVzLCBpdCdzIGJldHRlciB0aGlzIHdheS4gVGhpcyBtZWFucyB5b3UgY2FuIHJldGFpbiBzZXBhcmF0b3JcbiAgICAgY29udGV4dCBpbiByZWN1cnNpb24gKGUuZy4gcmVtb3ZlX2RvdF9zZWdtZW50cyBmb3IgcmVsYXRpdmUgcmVzb2x1dGlvbikuICopXG5cbiAgdHlwZSB0ID0gc3RyaW5nIGxpc3RcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVfbGlzdCBTdHJpbmcuY29tcGFyZVxuXG4gICgqIE1ha2UgYSBwYXRoIHRva2VuIGxpc3QgZnJvbSBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IHBhdGhfb2ZfZW5jb2RlZCBwcyA9XG4gICAgbGV0IHRva2wgPSBTdHJpbmdleHQuZnVsbF9zcGxpdCBwcyB+b246Jy8nIGluXG4gICAgTGlzdC5tYXAgcGN0X2RlY29kZSB0b2tsXG5cbiAgKCogU3Vicm91dGluZSBmb3IgcmVzb2x2ZSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40PiAqKVxuICBsZXQgcmVtb3ZlX2RvdF9zZWdtZW50cyBwID1cbiAgICBsZXQgcmV2cCA9IExpc3QucmV2IHAgaW5cbiAgICBsZXQgcmVjIGxvb3AgYXNjZW5zaW9uIG91dHAgPSBmdW5jdGlvblxuICAgICAgfCBcIi9cIjo6XCIuLlwiOjpyIHwgXCIuLlwiOjpyIC0+IGxvb3AgKGFzY2Vuc2lvbiArIDEpIG91dHAgclxuICAgICAgfCBcIi9cIjo6XCIuXCI6OnIgIHwgXCIuXCI6OnIgIC0+IGxvb3AgYXNjZW5zaW9uIG91dHAgclxuICAgICAgfCBcIi9cIjo6W10gfCBbXSB3aGVuIExpc3QuKGxlbmd0aCBwID4gMCAmJiBoZCBwID0gXCIvXCIpIC0+IFwiL1wiOjpvdXRwXG4gICAgICB8IFtdIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBMaXN0LnJldl9hcHBlbmRcbiAgICAgICAgKFwiL1wiOjoocmV2X2ludGVyamVjdCBcIi9cIiBBcnJheS4odG9fbGlzdCAobWFrZSBhc2NlbnNpb24gXCIuLlwiKSkpKSBvdXRwXG4gICAgICB8IFtdIC0+IExpc3QuKGlmIGxlbmd0aCBvdXRwID4gMCAmJiBoZCBvdXRwID0gXCIvXCIgdGhlbiB0bCBvdXRwIGVsc2Ugb3V0cClcbiAgICAgIHwgXCIvXCI6OlwiL1wiOjpyIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBsb29wIChhc2NlbnNpb24gLSAxKSBvdXRwIChcIi9cIjo6cilcbiAgICAgIHwgXCIvXCI6Ol86OnIgd2hlbiBhc2NlbnNpb24gPiAwIC0+IGxvb3AgKGFzY2Vuc2lvbiAtIDEpIG91dHAgclxuICAgICAgfCBzOjpyIC0+IGxvb3AgMCAoczo6b3V0cCkgclxuICAgIGluIGxvb3AgMCBbXSByZXZwXG5cbiAgbGV0IGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQgcCA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYyB0b2sgLT4gU3RyaW5nLmxlbmd0aCB0b2sgKyBjKSAwIHAgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiAtPiBmdW5jdGlvblxuICAgIHwgXCIvXCIgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLydcbiAgICB8IHNlZyAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHNlZylcbiAgICApIFwiXCIgYnVmIHA7XG4gICAgUGN0LmNhc3RfZW5jb2RlZCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZilcblxuICAoKiBTdWJyb3V0aW5lIGZvciByZXNvbHZlIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjM+ICopXG4gIGxldCBtZXJnZSBiaG9zdCBicGF0aCByZWxwYXRoID1cbiAgICBtYXRjaCBiaG9zdCwgTGlzdC5yZXYgYnBhdGggd2l0aFxuICAgIHwgU29tZSBfLCBbXSAtPiBcIi9cIjo6cmVscGF0aFxuICAgIHwgXywgKFwiL1wiOjpyYnBhdGggfCBfOjpcIi9cIjo6cmJwYXRoKSAtPiBMaXN0LnJldl9hcHBlbmQgKFwiL1wiOjpyYnBhdGgpIHJlbHBhdGhcbiAgICB8IF8sIF8gLT4gcmVscGF0aFxuZW5kXG5cbmxldCBwYXRoX29mX2VuY29kZWQgPSBQYXRoLnBhdGhfb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQgPSBQYXRoLmVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnRcblxuKCogUXVlcnkgc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhbiBhc3NvYyBsaXN0IG9mIGtleS92YWx1ZXMgKilcbm1vZHVsZSBRdWVyeSA9IHN0cnVjdFxuXG4gIHR5cGUga3YgPSAoc3RyaW5nICogc3RyaW5nIGxpc3QpIGxpc3RcblxuICB0eXBlIHQgPVxuICAgIHwgS1Ygb2Yga3ZcbiAgICB8IFJhdyBvZiBzdHJpbmcgb3B0aW9uICoga3YgTGF6eS50XG5cbiAgbGV0IGNvbXBhcmUgeCB5ID0gbWF0Y2ggeCwgeSB3aXRoXG4gICAgfCBLViBrdmwsIEtWIGt2bCdcbiAgICB8IFJhdyAoXywgbGF6eSBrdmwpLCBLViBrdmwnXG4gICAgfCBLViBrdmwsIFJhdyAoXywgbGF6eSBrdmwnKSAtPlxuICAgICAgY29tcGFyZV9saXN0IChmdW4gKGssdmwpIChrJyx2bCcpIC0+XG4gICAgICAgIG1hdGNoIFN0cmluZy5jb21wYXJlIGsgaycgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9saXN0IFN0cmluZy5jb21wYXJlIHZsIHZsJ1xuICAgICAgICB8IGMgLT4gY1xuICAgICAgKSBrdmwga3ZsJ1xuICAgIHwgUmF3IChyYXcsXyksIFJhdyAocmF3JyxfKSAtPiBjb21wYXJlX29wdCBTdHJpbmcuY29tcGFyZSByYXcgcmF3J1xuXG4gIGxldCBmaW5kIHEgayA9IHRyeSBTb21lIChMaXN0LmFzc29jIGsgcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG4gIGxldCBzcGxpdF9xdWVyeSBxcyA9XG4gICAgbGV0IGVscyA9IFN0cmluZ2V4dC5zcGxpdCB+b246JyYnIHFzIGluXG4gICAgKCogUmVwbGFjZSBhICsgaW4gYSBxdWVyeSBzdHJpbmcgd2l0aCBhIHNwYWNlIGluLXBsYWNlICopXG4gICAgbGV0IHBsdXNfdG9fc3BhY2UgcyA9XG4gICAgICBsZXQgcyA9IEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcyBpblxuICAgICAgZm9yIGkgPSAwIHRvIEJ5dGVzLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBpZiBCeXRlcy5nZXQgcyBpID0gJysnIHRoZW4gQnl0ZXMuc2V0IHMgaSAnICdcbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgICAgfCAoazo6djo6Xyk6OnRsIC0+XG4gICAgICAgIGxldCBuID0gcGx1c190b19zcGFjZSBrLFxuICAgICAgICAgICAgICAgIChtYXRjaCBTdHJpbmdleHQuc3BsaXQgfm9uOicsJyAocGx1c190b19zcGFjZSB2KSB3aXRoXG4gICAgICAgICAgICAgICAgIHwgW10gLT4gW1wiXCJdIHwgbCAtPiBsKSBpblxuICAgICAgICBsb29wIChuOjphY2MpIHRsXG4gICAgICB8IFtrXTo6dGwgLT5cbiAgICAgICAgbGV0IG4gPSBwbHVzX3RvX3NwYWNlIGssIFtdIGluXG4gICAgICAgIGxvb3AgKG46OmFjYykgdGxcbiAgICAgIHwgW106OnRsIC0+IGxvb3AgKChcIlwiLCBbXSk6OmFjYykgdGxcbiAgICAgIHwgW10gLT4gYWNjXG4gICAgaW5cbiAgICBtYXRjaCBlbHMgd2l0aFxuICAgIHwgW10gIC0+IFtcIlwiLFtdXVxuICAgIHwgZWxzIC0+IGxvb3AgW11cbiAgICAgIChMaXN0LnJldl9tYXAgKGZ1biBlbCAtPiBTdHJpbmdleHQuc3BsaXQgfm9uOic9JyBlbCB+bWF4OjIpIGVscylcblxuICAoKiBNYWtlIGEgcXVlcnkgdHVwbGUgbGlzdCBmcm9tIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgcXVlcnlfb2ZfZW5jb2RlZCBxcyA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW4gKGssIHYpIC0+IChwY3RfZGVjb2RlIGssIExpc3QubWFwIHBjdF9kZWNvZGUgdikpXG4gICAgICAoc3BsaXRfcXVlcnkgcXMpXG5cbiAgKCogQXNzZW1ibGUgYSBxdWVyeSBzdHJpbmcgc3VpdGFibGUgZm9yIHB1dHRpbmcgaW50byBhIFVSSS5cbiAgICogVHVwbGUgaW5wdXRzIGFyZSBwZXJjZW50IGRlY29kZWQgYW5kIHdpbGwgYmUgZW5jb2RlZCBieVxuICAgKiB0aGlzIGZ1bmN0aW9uLlxuICAqKVxuICBsZXQgZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIGwgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGEgKGssdikgLT5cbiAgICAgICAgYSArIChTdHJpbmcubGVuZ3RoIGspXG4gICAgICAgICsgKExpc3QuZm9sZF9sZWZ0IChmdW4gYSBzIC0+IGErKFN0cmluZy5sZW5ndGggcykrMSkgMCB2KSArIDIpICgtMSkgbCBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIChrLHYpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucXVlcnlfa2V5IGspO1xuICAgICAgICBpZiB2IDw+IFtdIHRoZW4gKFxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJz0nO1xuICAgICAgICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIHMgLT5cbiAgICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAgICAgICAgICAgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnF1ZXJ5X3ZhbHVlIHMpXG4gICAgICAgICAgICApIFwiLFwiIGJ1ZiB2KVxuICAgICAgKSBcIiZcIiBidWYgbDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IG9mX3JhdyBxcyA9XG4gICAgbGV0IGxhenlfcXVlcnkgPSBMYXp5LmZyb21fZnVuIChmdW4gKCkgLT4gcXVlcnlfb2ZfZW5jb2RlZCBxcykgaW5cbiAgICBSYXcgKFNvbWUgcXMsIGxhenlfcXVlcnkpXG5cbiAgbGV0IGt2ID0gZnVuY3Rpb24gUmF3IChfLCBsYXp5IGt2KSB8IEtWIGt2IC0+IGt2XG5lbmRcblxubGV0IHF1ZXJ5X29mX2VuY29kZWQgPSBRdWVyeS5xdWVyeV9vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lID0gUXVlcnkuZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lXG5cbigqIFR5cGUgb2YgdGhlIFVSSSwgd2l0aCBtb3N0IGJpdHMgYmVpbmcgb3B0aW9uYWwgKilcbnR5cGUgdCA9IHtcbiAgc2NoZW1lOiBQY3QuZGVjb2RlZCBvcHRpb247XG4gIHVzZXJpbmZvOiBVc2VyaW5mby50IG9wdGlvbjtcbiAgaG9zdDogWyBgSXB2NF9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICB8IGBJcHY2X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgIHwgYEhvc3Qgb2YgUGN0LmRlY29kZWRdIG9wdGlvbiA7XG4gIHBvcnQ6IGludCBvcHRpb247XG4gIHBhdGg6IFBhdGgudDtcbiAgcXVlcnk6IFF1ZXJ5LnQ7XG4gIGZyYWdtZW50OiBQY3QuZGVjb2RlZCBvcHRpb247XG59XG5cbmxldCBlbXB0eSA9IHtcbiAgc2NoZW1lID0gTm9uZTtcbiAgdXNlcmluZm8gPSBOb25lO1xuICBob3N0ID0gTm9uZTtcbiAgcG9ydCA9IE5vbmU7XG4gIHBhdGggPSBbXTtcbiAgcXVlcnkgPSBRdWVyeS5SYXcgKE5vbmUsIExhenkuZnJvbV92YWwgW10pO1xuICBmcmFnbWVudCA9IE5vbmU7XG59XG5cbmxldCBjb21wYXJlX2RlY29kZWQgPSBQY3QudW5saWZ0X2RlY29kZWQyIFN0cmluZy5jb21wYXJlXG5sZXQgY29tcGFyZV9kZWNvZGVkX29wdCA9IGNvbXBhcmVfb3B0IGNvbXBhcmVfZGVjb2RlZFxubGV0IGNvbXBhcmVfaG9zdCBoMSBoMiA9XG4gIG1hdGNoIGgxLCBoMiB3aXRoXG4gIHwgYElwdjRfbGl0ZXJhbCBpcDEsIGBJcHY0X2xpdGVyYWwgaXAyIC0+IFN0cmluZy5jb21wYXJlIGlwMSBpcDJcbiAgfCBgSXB2Nl9saXRlcmFsIGlwMSwgYElwdjZfbGl0ZXJhbCBpcDIgLT4gU3RyaW5nLmNvbXBhcmUgaXAxIGlwMlxuICB8IGBIb3N0IGgxLCBgSG9zdCBoMiAtPiBjb21wYXJlX2RlY29kZWQgaDEgaDJcbiAgfCBfIC0+IC0xXG5sZXQgY29tcGFyZV9ob3N0X29wdCA9IGNvbXBhcmVfb3B0IGNvbXBhcmVfaG9zdFxuXG5sZXQgY29tcGFyZSB0IHQnID1cbiAgKG1hdGNoIGNvbXBhcmVfaG9zdF9vcHQgdC5ob3N0IHQnLmhvc3Qgd2l0aFxuICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5zY2hlbWUgdCcuc2NoZW1lIHdpdGhcbiAgICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfb3B0IChmdW4gcCBwJyAtPlxuICAgICAgaWYgcCA8IHAnIHRoZW4gLTEgZWxzZSBpZiBwID4gcCcgdGhlbiAxIGVsc2UgMFxuICAgICkgdC5wb3J0IHQnLnBvcnQgd2l0aFxuICAgICAgfCAwIC0+IChtYXRjaCBjb21wYXJlX29wdCBVc2VyaW5mby5jb21wYXJlIHQudXNlcmluZm8gdCcudXNlcmluZm8gd2l0aFxuICAgICAgICB8IDAgLT4gKG1hdGNoIFBhdGguY29tcGFyZSB0LnBhdGggdCcucGF0aCB3aXRoXG4gICAgICAgICAgfCAwIC0+IChtYXRjaCBRdWVyeS5jb21wYXJlIHQucXVlcnkgdCcucXVlcnkgd2l0aFxuICAgICAgICAgICAgfCAwIC0+IGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5mcmFnbWVudCB0Jy5mcmFnbWVudFxuICAgICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgIHwgYyAtPiBjKVxuICAgICAgfCBjIC0+IGMpXG4gICAgfCBjIC0+IGMpXG4gIHwgYyAtPiBjKVxuXG5sZXQgZXF1YWwgdCB0JyA9IGNvbXBhcmUgdCB0JyA9IDBcblxubGV0IHVuY2FzdF9vcHQgPSBmdW5jdGlvblxuICB8IFNvbWUgaCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgaClcbiAgfCBOb25lIC0+IE5vbmVcblxubGV0IG5vcm1hbGl6ZSBzY2hlbSB1cmkgPVxuICBsZXQgbW9kdWxlIFNjaGVtZSA9XG4gICAgKHZhbCAobW9kdWxlX29mX3NjaGVtZSAodW5jYXN0X29wdCBzY2hlbSkpIDogU2NoZW1lKSBpblxuICBsZXQgZG9iIGYgPSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+IFNvbWUgKFBjdC51bmxpZnRfZGVjb2RlZCBmIHgpXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgaW4ge3VyaSB3aXRoXG4gICAgICBzY2hlbWU9ZG9iIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgdXJpLnNjaGVtZTtcbiAgICAgIGhvc3Q9IG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgICAgICB8IFNvbWUgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBJcHY0X2xpdGVyYWwgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCBob3N0KSlcbiAgICAgICB8IFNvbWUgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBJcHY2X2xpdGVyYWwgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCBob3N0KSlcbiAgICAgICB8IFNvbWUgKGBIb3N0IGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IChQY3QudW5jYXN0X2RlY29kZWQgaG9zdCkpKSlcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB9XG5cbigqKiBDb252ZXJ0IGEgVVJJIHN0cnVjdHVyZSBpbnRvIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZ1xuICAgIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4zPlxuKilcbmxldCB0b19zdHJpbmcgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID1cbiAgbGV0IHNjaGVtZSA9IG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgIHwgU29tZSBzIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBzKVxuICAgIHwgTm9uZSAtPiBOb25lIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDEyOCBpblxuICAoKiBQZXJjZW50IGVuY29kZSBhIGRlY29kZWQgc3RyaW5nIGFuZCBhZGQgaXQgdG8gdGhlIGJ1ZmZlciAqKVxuICBsZXQgYWRkX3BjdF9zdHJpbmcgPyhjb21wb25lbnQ9YFBhdGgpIHggPVxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUGN0LnVuY2FzdF9lbmNvZGVkIChQY3QuZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCB4KSlcbiAgaW5cbiAgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgfE5vbmUgLT4gKClcbiAgIHxTb21lIHggLT5cbiAgICAgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5zY2hlbWUgeDtcbiAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOidcbiAgKTtcbiAgKCogVVJJIGhhcyBhIGhvc3QgaWYgYW55IGhvc3QtcmVsYXRlZCBjb21wb25lbnQgaXMgc2V0LiBEZWZhdWx0cyB0byBcIlwiLiAqKVxuICBpZiAobWF0Y2ggdXJpLnVzZXJpbmZvLCB1cmkuaG9zdCwgdXJpLnBvcnQgd2l0aFxuICB8IFNvbWUgXywgXywgXyB8IF8sIFNvbWUgXywgXyB8IF8sIF8sIFNvbWUgXyAtPiB0cnVlIHwgXyAtPiBmYWxzZSlcbiAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIvL1wiO1xuICAobWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgdXNlcmluZm8gLT5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgIChQY3QudW5jYXN0X2VuY29kZWQgKGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvKSk7XG4gICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnQCdcbiAgKTtcbiAgKG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgKGBIb3N0IGhvc3QpIC0+XG4gICAgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5ob3N0IGhvc3Q7XG4gIHxTb21lIChgSXB2NF9saXRlcmFsIGhvc3QpIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBob3N0XG4gIHxTb21lIChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdbJztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBob3N0O1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXSdcbiAgKTtcbiAgKG1hdGNoIHVyaS5wb3J0IHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgcG9ydCAtPlxuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBwb3J0KVxuICApO1xuICAobWF0Y2ggdXJpLnBhdGggd2l0aCAoKiBIYW5kbGUgcmVsYXRpdmUgcGF0aHMgY29ycmVjdGx5ICopXG4gIHwgW10gLT4gKClcbiAgfCBcIi9cIjo6XyAtPlxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUGN0LnVuY2FzdF9lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKSlcbiAgfCBmaXJzdF9zZWdtZW50OjpfIC0+XG4gICAgKG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgICAgfCBTb21lIF8gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLydcbiAgICAgfCBOb25lIC0+XG4gICAgICAgKCogZW5zdXJlIHJvdW5kdHJpcCBieSBmb3JjaW5nIHJlbGF0aXZlIHBhdGggaW50ZXJwcmV0YXRpb24gbm90IHNjaGVtZSAqKVxuICAgICAgIG1hdGNoIFN0cmluZ2V4dC5maW5kX2Zyb20gZmlyc3Rfc2VnbWVudCB+cGF0dGVybjpcIjpcIiB3aXRoXG4gICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgfCBTb21lIF8gLT4gbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICB8IE5vbmUgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLi9cIlxuICAgICk7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpKVxuICApO1xuICBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICB8IFJhdyAoTm9uZSxfKSB8IEtWIFtdIC0+ICgpXG4gICAgfCBSYXcgKF8sbGF6eSBxKSB8IEtWIHEgLT4gKCogbm9ybWFsaXplIGUuZy4gcGVyY2VudCBjYXBpdGFsaXphdGlvbiAqKVxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSB+cGN0X2VuY29kZXIgcSlcbiAgKTtcbiAgKG1hdGNoIHVyaS5mcmFnbWVudCB3aXRoXG4gICB8Tm9uZSAtPiAoKVxuICAgfFNvbWUgZiAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcjJzsgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5mcmFnbWVudCBmXG4gICk7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxuKCogVmFyaW91cyBhY2Nlc3NvciBmdW5jdGlvbnMsIGFzIHRoZSBleHRlcm5hbCB1cmkgdHlwZSBpcyBhYnN0cmFjdCAgKilcbmxldCBnZXRfZGVjb2RlZF9vcHQgPSBmdW5jdGlvbiBOb25lIC0+IE5vbmUgfFNvbWUgeCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgeClcbmxldCBzY2hlbWUgdXJpID0gZ2V0X2RlY29kZWRfb3B0IHVyaS5zY2hlbWVcbmxldCB3aXRoX3NjaGVtZSB1cmkgPVxuICBmdW5jdGlvblxuICB8U29tZSBzY2hlbWUgLT4geyB1cmkgd2l0aCBzY2hlbWU9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBzY2hlbWUpIH1cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBzY2hlbWU9Tm9uZSB9XG5cbmxldCBob3N0IHVyaSA9XG4gIG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChgSXB2NF9saXRlcmFsIGggfCBgSXB2Nl9saXRlcmFsIGgpIC0+IFNvbWUgaFxuICB8IFNvbWUgKGBIb3N0IGgpIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuXG5sZXQgaG9zdF93aXRoX2RlZmF1bHQgPyhkZWZhdWx0PVwibG9jYWxob3N0XCIpIHVyaSA9XG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfE5vbmUgLT4gZGVmYXVsdFxuICB8U29tZSBoIC0+IGhcblxubGV0IHVzZXJpbmZvID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB1c2VyaW5mbyAtPiBTb21lIChQY3QudW5jYXN0X2VuY29kZWQgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgIHwgTm9uZSAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm9cbiAgICB8IFNvbWUgcyAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvKSlcbmxldCB3aXRoX3VzZXJpbmZvIHVyaSB1c2VyaW5mbyA9XG4gIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgaW5cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgdXNlcmluZm89dXNlcmluZm8gfVxuICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHVzZXJpbmZvPXVzZXJpbmZvIH1cblxubGV0IHVzZXIgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lICh1c2VyLCBfKSAtPiBTb21lIHVzZXJcblxubGV0IHBhc3N3b3JkIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSB8IFNvbWUgKF8sIE5vbmUpIC0+IE5vbmVcbiAgfCBTb21lIChfLCBTb21lIHBhc3MpIC0+IFNvbWUgcGFzc1xubGV0IHdpdGhfcGFzc3dvcmQgdXJpIHBhc3N3b3JkID1cbiAgbGV0IHJlc3VsdCB1c2VyaW5mbyA9IG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgdXNlcmluZm89dXNlcmluZm8gfVxuICAgIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggdXNlcmluZm89dXNlcmluZm8gfVxuICBpblxuICBtYXRjaCB1cmkudXNlcmluZm8sIHBhc3N3b3JkIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHVyaVxuICB8IE5vbmUsIFNvbWUgXyAtPiByZXN1bHQgKFNvbWUgKFwiXCIscGFzc3dvcmQpKVxuICB8IFNvbWUgKHVzZXIsXyksIF8gLT4gcmVzdWx0IChTb21lICh1c2VyLCBwYXNzd29yZCkpXG5cbmxldCBwb3J0IHVyaSA9IHVyaS5wb3J0XG5sZXQgd2l0aF9wb3J0IHVyaSBwb3J0ID1cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHBvcnQ9cG9ydCB9XG4gIHwgTm9uZSAtPiBiZWdpblxuICAgICBtYXRjaCBwb3J0IHdpdGhcbiAgICAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Ob25lOyBwb3J0PU5vbmUgfVxuICAgICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyBwb3J0PXBvcnQgfVxuICBlbmRcblxuKCogUmV0dXJuIHRoZSBwYXRoIGNvbXBvbmVudCAqKVxubGV0IHBhdGggPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gUGN0LnVuY2FzdF9lbmNvZGVkIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgfCBOb25lIC0+IGVuY29kZWRfb2ZfcGF0aCB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGhcbiAgfCBTb21lIHMgLT4gZW5jb2RlZF9vZl9wYXRoIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpXG5sZXQgd2l0aF9wYXRoIHVyaSBwYXRoID1cbiAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcGF0aCBpblxuICBtYXRjaCBob3N0IHVyaSwgcGF0aCB3aXRoXG4gIHwgTm9uZSwgXyB8IFNvbWUgXywgXCIvXCI6Ol8gfCBTb21lIF8sIFtdIC0+IHsgdXJpIHdpdGggcGF0aD1wYXRoIH1cbiAgfCBTb21lIF8sIF8gIC0+IHsgdXJpIHdpdGggcGF0aD1cIi9cIjo6cGF0aCB9XG5cbmxldCBmcmFnbWVudCB1cmkgPSBnZXRfZGVjb2RlZF9vcHQgdXJpLmZyYWdtZW50XG5sZXQgd2l0aF9mcmFnbWVudCB1cmkgPVxuICBmdW5jdGlvblxuICB8Tm9uZSAtPiB7IHVyaSB3aXRoIGZyYWdtZW50PU5vbmUgfVxuICB8U29tZSBmcmFnIC0+IHsgdXJpIHdpdGggZnJhZ21lbnQ9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBmcmFnKSB9XG5cbmxldCBxdWVyeSB1cmkgPSBRdWVyeS5rdiB1cmkucXVlcnlcbmxldCB2ZXJiYXRpbV9xdWVyeSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgfCBSYXcgKHFzLF8pIC0+IHFzXG4gIHwgS1YgW10gLT4gTm9uZVxuICB8IEtWIGt2IC0+IFNvbWUgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZTooc2NoZW1lIHVyaSkgfnBjdF9lbmNvZGVyIGt2KVxuKVxubGV0IGdldF9xdWVyeV9wYXJhbScgdXJpIGsgPSBRdWVyeS4oZmluZCAoa3YgdXJpLnF1ZXJ5KSBrKVxubGV0IGdldF9xdWVyeV9wYXJhbSB1cmkgayA9XG4gIG1hdGNoIGdldF9xdWVyeV9wYXJhbScgdXJpIGsgd2l0aFxuICB8Tm9uZSAtPiBOb25lXG4gIHxTb21lIHYgLT4gU29tZSAoU3RyaW5nLmNvbmNhdCBcIixcIiB2KVxuXG5sZXQgd2l0aF9xdWVyeSB1cmkgcXVlcnkgPSB7IHVyaSB3aXRoIHF1ZXJ5PVF1ZXJ5LktWIHF1ZXJ5IH1cbmxldCBxX3MgcSA9IExpc3QubWFwIChmdW4gKGssdikgLT4gayxbdl0pIHFcbmxldCB3aXRoX3F1ZXJ5JyB1cmkgcXVlcnkgPSB3aXRoX3F1ZXJ5IHVyaSAocV9zIHF1ZXJ5KVxubGV0IGFkZF9xdWVyeV9wYXJhbSB1cmkgcCA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW0nIHVyaSAoayx2KSA9XG4gIFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWICgoayxbdl0pOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zIHVyaSBwcyA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwc0Aoa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zJyB1cmkgcHMgPVxuICBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAoKHFfcyBwcylAKGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgcmVtb3ZlX3F1ZXJ5X3BhcmFtIHVyaSBrID0gUXVlcnkuKFxuICB7IHVyaSB3aXRoIHF1ZXJ5PUtWIChMaXN0LmZpbHRlciAoZnVuIChrJyxfKSAtPiBrPD5rJykgKGt2IHVyaS5xdWVyeSkpIH1cbilcblxuKCogQ29uc3RydWN0IGVuY29kZWQgcGF0aCBhbmQgcXVlcnkgY29tcG9uZW50cyAqKVxubGV0IHBhdGhfYW5kX3F1ZXJ5IHVyaSA9XG4gIG1hdGNoIChwYXRoIHVyaSksIChxdWVyeSB1cmkpIHdpdGhcbiAgfFwiXCIsIFtdIC0+IFwiL1wiICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gIHxcIlwiLCBxIC0+ICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gICAgbGV0IHNjaGVtZSA9IHVuY2FzdF9vcHQgdXJpLnNjaGVtZSBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiLz8lc1wiIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgcSlcbiAgfHAsIFtdIC0+IHBcbiAgfHAsIHEgLT5cbiAgICBsZXQgc2NoZW1lID0gdW5jYXN0X29wdCB1cmkuc2NoZW1lIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlcz8lc1wiIHAgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSBxKVxuXG4oKiBUT0RPOiBmdW5jdGlvbnMgdG8gYWRkIGFuZCByZW1vdmUgZnJvbSBhIFVSSSAqKVxuXG4oKiBSZXNvbHZlIGEgVVJJIHdydCBhIGJhc2UgVVJJIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yPiAqKVxubGV0IHJlc29sdmUgc2NoZW0gYmFzZSB1cmkgPVxuICBsZXQgc2NoZW0gPSBTb21lIChQY3QuY2FzdF9kZWNvZGVkIChtYXRjaCBzY2hlbWUgYmFzZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gIHNjaGVtXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+IHNjaGVtZVxuICAgICkpIGluXG4gIG5vcm1hbGl6ZSBzY2hlbVxuICAgIFBhdGguKG1hdGNoIHNjaGVtZSB1cmksIHVzZXJpbmZvIHVyaSwgaG9zdCB1cmkgd2l0aFxuICAgIHwgU29tZSBfLCBfLCBfIC0+XG4gICAgICB7dXJpIHdpdGggcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgIHwgTm9uZSwgU29tZSBfLCBfXG4gICAgfCBOb25lLCBfLCBTb21lIF8gLT5cbiAgICAgIHt1cmkgd2l0aCBzY2hlbWU9YmFzZS5zY2hlbWU7IHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT5cbiAgICAgIGxldCB1cmkgPSB7dXJpIHdpdGggc2NoZW1lPWJhc2Uuc2NoZW1lOyB1c2VyaW5mbz1iYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0PWJhc2UuaG9zdDsgcG9ydD1iYXNlLnBvcnR9IGluXG4gICAgICBsZXQgcGF0aF9zdHIgPSBwYXRoIHVyaSBpblxuICAgICAgaWYgcGF0aF9zdHI9XCJcIlxuICAgICAgdGhlbiB7IHVyaSB3aXRoXG4gICAgICAgICAgICAgcGF0aD1iYXNlLnBhdGg7XG4gICAgICAgICAgICAgcXVlcnk9bWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICAgICAgICAgICAgIHwgUXVlcnkuUmF3IChOb25lLF8pIHwgUXVlcnkuS1YgW10gLT4gYmFzZS5xdWVyeVxuICAgICAgICAgICAgICAgfCBfIC0+IHVyaS5xdWVyeVxuICAgICAgICAgICB9XG4gICAgICBlbHNlIGlmIHBhdGhfc3RyLlswXT0nLydcbiAgICAgIHRoZW4ge3VyaSB3aXRoIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICAgIGVsc2Uge3VyaSB3aXRoXG4gICAgICAgIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyAobWVyZ2UgYmFzZS5ob3N0IGJhc2UucGF0aCB1cmkucGF0aCk7XG4gICAgICB9XG4gICAgKVxuXG5sZXQgY2Fub25pY2FsaXplIHVyaSA9XG4gIGxldCB1cmkgPSByZXNvbHZlIFwiXCIgZW1wdHkgdXJpIGluXG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHVyaS5zY2hlbWUpKSA6IFNjaGVtZSkgaW5cbiAgeyB1cmkgd2l0aFxuICAgIHBvcnQ9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wb3J0IHVyaS5wb3J0O1xuICAgIHBhdGg9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wYXRoIHVyaS5wYXRoO1xuICB9XG5cbmxldCBwcCBwcGYgdXJpID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyB1cmkpXG5sZXQgcHBfaHVtIHBwZiB1cmkgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nIHVyaSlcblxubW9kdWxlIFBhcnNlciA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IHN0cmluZ19vZl9jaGFyID0gU3RyaW5nLm1ha2UgMVxuXG4gIGxldCBzdHJpbmdfb2ZfY2hhcl9saXN0IGNoYXJzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIHN0cmluZ19vZl9jaGFyIGNoYXJzKVxuXG4gIGxldCBzY2hlbWUgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBTb21lIChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgICh0YWtlX3doaWxlIChmdW4gYyAtPiBjIDw+ICc6JyAmJiBjIDw+ICcvJyAmJiBjIDw+ICc/JyAmJiBjIDw+ICcjJylcbiAgICAgIDwqIGNoYXIgJzonKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBpc19kaWdpdCA9IGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICBsZXQgaGV4X2RpZ2l0ID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IGhleGFkZWNpbWFsID0gbGlmdCBzdHJpbmdfb2ZfY2hhcl9saXN0IChtYW55IGhleF9kaWdpdClcblxuICBsZXQgY19kb3QgPSBjaGFyICcuJ1xuXG4gIGxldCBjX2F0ID0gY2hhciAnQCdcblxuICBsZXQgY19jb2xvbiA9IGNoYXIgJzonXG5cbiAgbGV0IGRlY19vY3RldCA9XG4gICAgdGFrZV93aGlsZTEgKGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpID4+PSBmdW4gbnVtIC0+XG4gICAgaWYgaW50X29mX3N0cmluZyBudW0gPCAyNTYgdGhlblxuICAgICAgcmV0dXJuIG51bVxuICAgIGVsc2VcbiAgICAgIGZhaWwgXCJpbnZhbGlkIG9jdGVjdFwiXG5cbiAgbGV0IGlwdjRfYWRkcmVzcyA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4gdGhyZWUgb25lIC0+IFN0cmluZy5jb25jYXQgXCIuXCIgdGhyZWUgXiBcIi5cIiBeIG9uZSlcbiAgICAgIChjb3VudCAzIChkZWNfb2N0ZXQgPCogY19kb3QpKVxuICAgICAgZGVjX29jdGV0XG5cbiAgKCogLS0gYWZ0ZXIgZG91YmxlIGNvbG9uLCBJUHY0IGRvdHRlZCBub3RhdGlvbiBjb3VsZCBhcHBlYXIgYW55d2hlcmUgKilcbiAgbGV0IGFmdGVyX2RvdWJsZV9jb2xvbiA9XG4gICAgZml4IChmdW4gZiAtPlxuICAgICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF1cbiAgICAgICAgPHw+IGxpZnQyIChmdW4geCB5IC0+IHggOjogeSkgaGV4YWRlY2ltYWwgKGNfY29sb24gKj4gZiA8fD4gcmV0dXJuIFtdKSlcblxuICBsZXQgZG91YmxlX2NvbG9uIGNvdW50ID1cbiAgICBhZnRlcl9kb3VibGVfY29sb24gPj49IChmdW4gcmVzdCAtPlxuICAgIGxldCBmaWxsZXJfbGVuZ3RoID0gOCAtIGNvdW50IC0gTGlzdC5sZW5ndGggcmVzdCBpblxuICAgIGlmIGZpbGxlcl9sZW5ndGggPD0gMCB0aGVuXG4gICAgICBmYWlsIFwidG9vIG1hbnkgcGFydHMgaW4gSVB2NiBhZGRyZXNzXCJcbiAgICBlbHNlXG4gICAgICByZXR1cm4gKFwiXCIgOjogcmVzdCkpXG4gICAgPHw+IHJldHVybiBbXCJcIl1cblxuICBsZXQgcmVjIHBhcnQgPSBmdW5jdGlvblxuICAgIHwgNyAtPlxuICAgICAgKCogbWF4IDggcGFydHMgaW4gYW4gSVB2NiBhZGRyZXNzICopXG4gICAgICBsaWZ0IChmdW4geCAtPiBbIHggXSkgaGV4YWRlY2ltYWxcbiAgICB8IDYgLT5cbiAgICAgICgqIGFmdGVyIDYgcGFydHMgaXQgY291bGQgZW5kIGluIElQdjQgZG90dGVkIG5vdGF0aW9uICopXG4gICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF0gPHw+IGhleF9wYXJ0IDZcbiAgICB8IG4gLT5cbiAgICAgIGhleF9wYXJ0IG5cblxuICBhbmQgaGV4X3BhcnQgbiA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4geCB5IC0+IHggOjogeSlcbiAgICAgIGhleGFkZWNpbWFsXG4gICAgICAoY19jb2xvbiAqPiAoY19jb2xvbiAqPiBkb3VibGVfY29sb24gKG4gKyAxKSA8fD4gcGFydCAobiArIDEpKSlcblxuICBsZXQgcmVjIHNwbGl0X3dpdGggZiB4cyA9XG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIFtdLCBbXVxuICAgIHwgeSA6OiB5cyAtPlxuICAgICAgaWYgZiB5IHRoZW5cbiAgICAgICAgbGV0IHpzLCB0cyA9IHNwbGl0X3dpdGggZiB5cyBpblxuICAgICAgICB5IDo6IHpzLCB0c1xuICAgICAgZWxzZVxuICAgICAgICBbXSwgeHNcblxuICBsZXQgaXB2NiA9XG4gICAgbGV0IGZvcm1hdF9hZGRyIHNlZ21lbnRzID1cbiAgICAgIGxldCBiZWZvcmVfZG91YmxlX2NvbG9uLCBhZnRlcl9kb3VibGVfY29sb24gPVxuICAgICAgICBzcGxpdF93aXRoIChmdW4gc2VnbWVudCAtPiBzZWdtZW50IDw+IFwiXCIpIHNlZ21lbnRzXG4gICAgICBpblxuICAgICAgbGV0IGJlZm9yZSA9IFN0cmluZy5jb25jYXQgXCI6XCIgYmVmb3JlX2RvdWJsZV9jb2xvbiBpblxuICAgICAgbGV0IHJlcyA9XG4gICAgICAgIG1hdGNoIGFmdGVyX2RvdWJsZV9jb2xvbiB3aXRoXG4gICAgICAgIHwgXCJcIiA6OiB4cyAtPlxuICAgICAgICAgIGJlZm9yZSBeIFwiOjpcIiBeIFN0cmluZy5jb25jYXQgXCI6XCIgeHNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgYmVmb3JlXG4gICAgICBpblxuICAgICAgcmVzXG4gICAgaW5cbiAgICBsaWZ0IGZvcm1hdF9hZGRyIChjX2NvbG9uICo+IGNfY29sb24gKj4gZG91YmxlX2NvbG9uIDAgPHw+IHBhcnQgMClcblxuICBsZXQgaXB2Nl9hZGRyZXNzID1cbiAgICAoY2hhciAnWycpICo+IGlwdjYgPCogKGNoYXIgJ10nKVxuXG4gIGxldCBwY3RfZW5jb2RlZCA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4gcGN0IGRpZ2l0cyAtPiBzdHJpbmdfb2ZfY2hhcl9saXN0IChwY3QgOjogZGlnaXRzKSlcbiAgICAgIChjaGFyICclJylcbiAgICAgIChjb3VudCAyIGhleF9kaWdpdClcblxuICBsZXQgc3ViX2RlbGltcyA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnIScgfCAnJCcgfCAnJicgfCAnXFwnJyB8ICcoJyB8ICcpJyB8ICcqJyB8ICcrJyB8ICcsJyB8ICc7JyB8ICc9JyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IHVucmVzZXJ2ZWQgPVxuICAgICgqIFwiW0EtWmEtejAtOS0uX35dXCIgKilcbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIHwgJzAnIC4uICc5JyB8ICctJyB8ICcuJyB8ICdfJyB8ICd+JyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IHJlZ19uYW1lID1cbiAgICBsaWZ0XG4gICAgICAoU3RyaW5nLmNvbmNhdCBcIlwiKVxuICAgICAgKG1hbnlcbiAgICAgICAgIChjaG9pY2VcbiAgICAgICAgICAgIFsgc3RyaW5nX29mX2NoYXIgPCQ+IHVucmVzZXJ2ZWRcbiAgICAgICAgICAgIDsgcGN0X2VuY29kZWRcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IHN1Yl9kZWxpbXNcbiAgICAgICAgICAgIF0pKVxuXG4gIGxldCBob3N0ID1cbiAgICBjaG9pY2VcbiAgICAgIFsgaXB2NF9hZGRyZXNzID4+fCAoZnVuIGggLT4gYElwdjRfbGl0ZXJhbCBoKVxuICAgICAgOyBpcHY2X2FkZHJlc3MgPj58IChmdW4gaCAtPiBgSXB2Nl9saXRlcmFsIGgpXG4gICAgICA7IHJlZ19uYW1lID4+fCAoZnVuIHMgLT4gYEhvc3QgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKCogVE9ETyhkaW5vc2F1cmUpOiBBY2NvcmRpbmcgdG8gUkZDMzk4NjpcblxuICAgICAgICAgaG9zdCAgICAgICAgPSBJUC1saXRlcmFsIC8gSVB2NGFkZHJlc3MgLyByZWctbmFtZVxuICAgICAgICAgSVAtbGl0ZXJhbCAgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG4gICAgICAgICBJUHZGdXR1cmUgICA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcblxuICAgICAgICAgSVB2RnV0dXJlIGlzIG5vdCBpbXBsZW1lbnRlZC4gV2Ugc2hvdWxkIGhhbmRsZSBpdDpcblxuICAgICAgICAgSVB2RnV0dXJlICAgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgICAgKilcbiAgICAgIF1cblxuICBsZXQgdXNlcmluZm8gPVxuICAgIGxpZnRcbiAgICAgIChmdW4geCAtPlxuICAgICAgICBsZXQgcyA9IFN0cmluZy5jb25jYXQgXCJcIiB4IGluXG4gICAgICAgIFNvbWUgKFVzZXJpbmZvLnVzZXJpbmZvX29mX2VuY29kZWQgcykpXG4gICAgICAobWFueVxuICAgICAgICAgKGNob2ljZVxuICAgICAgICAgICAgWyBzdHJpbmdfb2ZfY2hhciA8JD4gdW5yZXNlcnZlZFxuICAgICAgICAgICAgOyBwY3RfZW5jb2RlZFxuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gc3ViX2RlbGltc1xuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gY19jb2xvblxuICAgICAgICAgICAgXSlcbiAgICAgIDwqIGNfYXQpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IHBvcnQgPVxuICAgIHBlZWtfY2hhciA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgJzonIC0+XG4gICAgICBjX2NvbG9uICo+IHRha2Vfd2hpbGUgaXNfZGlnaXQgPj58IGZ1biBwb3J0IC0+XG4gICAgICBsZXQgZGVjb2RlZCA9IFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcG9ydCkgaW5cbiAgICAgICh0cnkgU29tZSAoaW50X29mX3N0cmluZyAoUGN0LnVuY2FzdF9kZWNvZGVkIGRlY29kZWQpKSB3aXRoIF8gLT4gTm9uZSlcbiAgICB8IFNvbWUgXyB8IE5vbmUgLT5cbiAgICAgIHJldHVybiBOb25lXG5cbiAgbGV0IGF1dGhvcml0eSA9XG4gICAgc3RyaW5nIFwiLy9cIlxuICAgICo+IGxpZnQzXG4gICAgICAgICAoZnVuIHVzZXJpbmZvIGhvc3QgcG9ydCAtPlxuICAgICAgICAgICB1c2VyaW5mbywgU29tZSBob3N0LCBwb3J0KVxuICAgICAgICAgdXNlcmluZm9cbiAgICAgICAgIGhvc3RcbiAgICAgICAgIHBvcnRcbiAgICA8fD4gcmV0dXJuIChOb25lLCBOb25lLCBOb25lKVxuXG4gIGxldCBwYXRoID1cbiAgICBsaWZ0XG4gICAgICBQYXRoLnBhdGhfb2ZfZW5jb2RlZFxuICAgICAgKHRha2Vfd2hpbGUgKGZ1bmN0aW9uICc/JyB8ICcjJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZSkpXG5cbiAgbGV0IHF1ZXJ5ID1cbiAgICBsaWZ0XG4gICAgICBRdWVyeS5vZl9yYXdcbiAgICAgIChjaGFyICc/JyAqPiB0YWtlX3RpbGwgKGZ1bmN0aW9uICcjJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkpXG4gICAgPHw+IHJldHVybiAoUXVlcnkuUmF3IChOb25lLCBMYXp5LmZyb21fdmFsIFtdKSlcblxuICBsZXQgZnJhZ21lbnQgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBTb21lIChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgIChjaGFyICcjJyAqPiB0YWtlX3doaWxlIChmdW4gXyAtPiB0cnVlKSlcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgX3VyaV9yZWZlcmVuY2UgPVxuICAgIGxpZnQ0XG4gICAgICAoZnVuIHNjaGVtZSAodXNlcmluZm8sIGhvc3QsIHBvcnQpIHBhdGggcXVlcnkgZnJhZ21lbnQgLT5cbiAgICAgICAgbm9ybWFsaXplIHNjaGVtZSB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9KVxuICAgICAgc2NoZW1lXG4gICAgICBhdXRob3JpdHlcbiAgICAgIHBhdGhcbiAgICAgIHF1ZXJ5XG4gICAgPCo+IGZyYWdtZW50XG5cbiAgKCogWFhYKGFubW9udGVpcm8pOiBGb3IgY29tcGF0aWJpbGl0eSByZWFzb25zIHdpdGggdGhlIG9sZCByZWdleCBwYXJzZXIsIHdlXG4gICAqIG9ubHkgcGFyc2UgdW50aWwgdGhlIGZpcnN0IG5ld2xpbmUgY2hhcmFjdGVyIGFuZCBkcm9wIGV2ZXJ5dGhpbmcgZWxzZVxuICAgKiBhZnRlciB0aGF0ICopXG4gIGxldCB1cmlfcmVmZXJlbmNlID1cbiAgICB0YWtlX3doaWxlIChmdW5jdGlvbiB8ICdcXG4nIC0+IGZhbHNlIHwgXyAtPiB0cnVlKSA+PnwgZnVuIHMgLT5cbiAgICAgIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgX3VyaV9yZWZlcmVuY2UgcyB3aXRoXG4gICAgICB8IE9rIHQgLT4gdFxuICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICgqIFNob3VsZG4ndCByZWFsbHkgaGFwcGVuIGlmIHRoZSBwYXJzZXIgaXMgZm9yZ2l2aW5nLiAqKVxuICAgICAgICBlbXB0eVxuZW5kXG5cbmxldCBkZWNvZGVfaG9zdCBob3N0ID1cbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBQYXJzZXIuaG9zdCBob3N0IHdpdGhcbiAgfCBPayBwYXJzZWQgLT4gcGFyc2VkXG4gIHwgRXJyb3IgXyAtPlxuICAgIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgUGFyc2VyLmlwdjYgaG9zdCB3aXRoXG4gICAgfCBPayBwYXJzZWQgLT4gKGBJcHY2X2xpdGVyYWwgcGFyc2VkKVxuICAgIHwgRXJyb3IgXyAtPiAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgaG9zdCkpXG5cbigqIE1ha2UgYSBVUkkgcmVjb3JkLiBUaGlzIGlzIGEgYml0IG1vcmUgaW5lZmZpY2llbnQgdGhhbiBpdCBuZWVkcyB0byBiZSBkdWUgdG8gdGhlXG4gKiBjYXN0aW5nL3VuY2FzdGluZyAod2hpY2ggaXNuJ3QgZnVsbHkgaWRlbnRpdHkgZHVlIHRvIHRoZSBvcHRpb24gYm94KSwgYnV0IGl0IGlzXG4gKiBubyBiaWcgZGVhbCBmb3Igbm93LlxuKilcbmxldCBtYWtlID9zY2hlbWUgP3VzZXJpbmZvID9ob3N0ID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgKCkgPVxuICBsZXQgZGVjb2RlID0gZnVuY3Rpb25cbiAgICB8U29tZSB4IC0+IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgeCkgfE5vbmUgLT4gTm9uZSBpblxuICBsZXQgaG9zdCA9IG1hdGNoIHVzZXJpbmZvLCBob3N0LCBwb3J0IHdpdGhcbiAgICB8IF8sIFNvbWUgXywgXyB8IE5vbmUsIE5vbmUsIE5vbmUgLT4gaG9zdFxuICAgIHwgU29tZSBfLCBOb25lLCBfIHwgXywgTm9uZSwgU29tZSBfIC0+IFNvbWUgXCJcIlxuICBpblxuICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmUgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KSBpblxuICBsZXQgcGF0aCA9IG1hdGNoIHBhdGggd2l0aFxuICAgIHxOb25lIC0+IFtdIHwgU29tZSBwIC0+XG4gICAgICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwIGluXG4gICAgICBtYXRjaCBob3N0LCBwYXRoIHdpdGhcbiAgICAgIHwgTm9uZSwgXyB8IFNvbWUgXywgXCIvXCI6Ol8gfCBTb21lIF8sIFtdIC0+IHBhdGhcbiAgICAgIHwgU29tZSBfLCBfICAtPiBcIi9cIjo6cGF0aFxuICBpblxuICBsZXQgcXVlcnkgPSBtYXRjaCBxdWVyeSB3aXRoXG4gICAgfCBOb25lIC0+IFF1ZXJ5LktWIFtdXG4gICAgfCBTb21lIHAgLT4gUXVlcnkuS1YgcFxuICBpblxuICBsZXQgc2NoZW1lID0gZGVjb2RlIHNjaGVtZSBpblxuICBub3JtYWxpemUgc2NoZW1lXG4gICAgeyBzY2hlbWU7IHVzZXJpbmZvO1xuICAgICAgaG9zdCA9XG4gICAgICAgIChtYXRjaCBob3N0IHdpdGhcbiAgICAgICAgfCBTb21lIGhvc3QgLT4gU29tZSAoZGVjb2RlX2hvc3QgaG9zdClcbiAgICAgICAgfCBOb25lIC0+IE5vbmUpO1xuICAgICAgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50PWRlY29kZSBmcmFnbWVudCB9XG5cbmxldCB3aXRoX2hvc3QgdXJpIGhvc3QgPVxuICB7IHVyaSB3aXRoXG4gICAgaG9zdCA9IChtYXRjaCBob3N0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBob3N0IC0+IFNvbWUgKGRlY29kZV9ob3N0IGhvc3QpXG4gICAgICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgfVxuXG5sZXQgd2l0aF91cmkgP3NjaGVtZSA/dXNlcmluZm8gP2hvc3QgP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCB1cmkgPVxuICBsZXQgd2l0aF9wYXRoX29wdCB1IG8gPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB3aXRoX3BhdGggdSBcIlwiXG4gICAgfCBTb21lIHAgLT4gd2l0aF9wYXRoIHUgcFxuICBpblxuICBsZXQgd2l0aF9xdWVyeV9vcHQgdSBvID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gd2l0aF9xdWVyeSB1IFtdXG4gICAgfCBTb21lIHEgLT4gd2l0aF9xdWVyeSB1IHFcbiAgaW5cbiAgbGV0IHdpdGhfIGYgbyB1ID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gdVxuICAgIHwgU29tZSB4IC0+IGYgdSB4XG4gIGluXG4gIHdpdGhfIHdpdGhfc2NoZW1lIHNjaGVtZSB1cmlcbiAgfD4gd2l0aF8gd2l0aF91c2VyaW5mbyB1c2VyaW5mb1xuICB8PiB3aXRoXyB3aXRoX2hvc3QgaG9zdFxuICB8PiB3aXRoXyB3aXRoX3BvcnQgcG9ydFxuICB8PiB3aXRoXyB3aXRoX3BhdGhfb3B0IHBhdGhcbiAgfD4gd2l0aF8gd2l0aF9xdWVyeV9vcHQgcXVlcnlcbiAgfD4gd2l0aF8gd2l0aF9mcmFnbWVudCBmcmFnbWVudFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICAoKiBUbyBwcmVzZXJ2ZSB0aGUgb2xkIHJlZ2V4IHBhcnNlcidzIGJlaGF2aW9yLCB3ZSBvbmx5IHBhcnNlIGEgcHJlZml4LCBhbmRcbiAgICogc3RvcCB3aGVuZXZlciB3ZSBjYW4ndCBwYXJzZSBtb3JlLiAqKVxuICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6UHJlZml4IFBhcnNlci51cmlfcmVmZXJlbmNlIHMgd2l0aFxuICB8IE9rIHQgLT4gdFxuICB8IEVycm9yIF8gLT5cbiAgICAoKiBTaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBpZiB0aGUgcGFyc2VyIGlzIGZvcmdpdmluZy4gKilcbiAgICBlbXB0eVxuXG5tb2R1bGUgQWJzb2x1dGVfaHR0cCA9IHN0cnVjdFxuICB0eXBlIHVyaSA9IHRcbiAgdHlwZSB0ID1cbiAgICB7IHNjaGVtZSA6IFsgYEh0dHAgfCBgSHR0cHMgXTtcbiAgICAgIHVzZXJpbmZvOiBVc2VyaW5mby50IG9wdGlvbjtcbiAgICAgIGhvc3Q6IFsgYElwdjRfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgICAgIHwgYElwdjZfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgICAgIHwgYEhvc3Qgb2YgUGN0LmRlY29kZWRdO1xuICAgICAgcG9ydCA6IGludCBvcHRpb247XG4gICAgICBwYXRoIDogUGF0aC50O1xuICAgICAgcXVlcnkgOiBRdWVyeS50O1xuICAgICAgZnJhZ21lbnQgOiBQY3QuZGVjb2RlZCBvcHRpb25cbiAgICB9XG5cbiAgbGV0ICggbGV0KiApID0gUmVzdWx0LmJpbmRcblxuICBsZXQgdG9fdXJpIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH0gPVxuICAgIGxldCBzY2hlbWUgPVxuICAgICAgbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgIHwgYEh0dHAgLT4gUGN0LmNhc3RfZGVjb2RlZCBcImh0dHBcIlxuICAgICAgfCBgSHR0cHMgLT4gUGN0LmNhc3RfZGVjb2RlZCBcImh0dHBzXCJcbiAgICBpblxuICAgICh7IHNjaGVtZSA9IFNvbWUgc2NoZW1lO1xuICAgICAgIHVzZXJpbmZvO1xuICAgICAgIGhvc3QgPSBTb21lIGhvc3Q7XG4gICAgICAgcG9ydDtcbiAgICAgICBwYXRoO1xuICAgICAgIHF1ZXJ5O1xuICAgICAgIGZyYWdtZW50IH0gOiB1cmkpXG4gIDs7XG5cbiAgbGV0IG9mX3VyaSAoeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfTogdXJpKSA9XG4gICAgbGV0KiBzY2hlbWUgPVxuICAgICAgbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFcnJvciAoYE1zZyBcIk5vIHNjaGVtZSBwcmVzZW50IGluIFVSSVwiKVxuICAgICAgfCBTb21lIHNjaGVtZSAtPlxuICAgICAgICAobWF0Y2ggUGN0LnVuY2FzdF9kZWNvZGVkIHNjaGVtZSB3aXRoXG4gICAgICAgICB8IFwiaHR0cFwiIC0+IE9rIGBIdHRwXG4gICAgICAgICB8IFwiaHR0cHNcIiAtPiBPayBgSHR0cHNcbiAgICAgICAgIHwgdW5zdXBwb3J0ZWRfc2NoZW1lIC0+XG4gICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgKGBNc2dcbiAgICAgICAgICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgICBcIk9ubHkgaHR0cCBhbmQgaHR0cHMgVVJJcyBhcmUgc3VwcG9ydGVkLiAlcyBpcyBpbnZhbGlkLlwiXG4gICAgICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWRfc2NoZW1lKSkpXG4gICAgaW5cbiAgICBsZXQqIGhvc3QgPSBPcHRpb24udG9fcmVzdWx0IH5ub25lOihgTXNnIFwiaG9zdCBpcyByZXF1aXJlZCBmb3IgSFRUUChTKSB1cmlzXCIpIGhvc3QgaW5cbiAgICBPayB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9XG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzID0gbWF0Y2ggb2Zfc3RyaW5nIHMgfD4gb2ZfdXJpIHdpdGhcbiAgICB8IE9rIHQgLT4gdFxuICAgIHwgRXJyb3IgKGBNc2cgZXJyb3IpIC0+IGZhaWx3aXRoIGVycm9yXG5cbiAgbGV0IHRvX3N0cmluZyA/cGN0X2VuY29kZXIgdCA9IHRvX3VyaSB0IHw+IHRvX3N0cmluZyA/cGN0X2VuY29kZXJcblxuICBsZXQgbm9ybWFsaXplIHQgPVxuICAgIHsgdCB3aXRoXG4gICAgICBob3N0ID0gbWF0Y2ggdC5ob3N0IHdpdGhcbiAgICAgICB8IChgSXB2NF9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICAoYElwdjRfbGl0ZXJhbCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBob3N0KSlcbiAgICAgICB8IChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICAoYElwdjZfbGl0ZXJhbCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBob3N0KSlcbiAgICAgICB8IChgSG9zdCBob3N0KSAtPlxuICAgICAgICAgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIChQY3QudW5jYXN0X2RlY29kZWQgaG9zdCkpKSlcbiAgICB9XG5cbiAgbGV0IG1ha2UgfnNjaGVtZSB+aG9zdCA/dXNlcmluZm8gP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCAoKSA9XG4gICAgbGV0IGRlY29kZSA9IGZ1bmN0aW9uXG4gICAgICB8U29tZSB4IC0+IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgeCkgfE5vbmUgLT4gTm9uZSBpblxuICAgIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSkgaW5cbiAgICBsZXQgcGF0aCA9IG1hdGNoIHBhdGggd2l0aFxuICAgICAgfE5vbmUgLT4gW10gfCBTb21lIHAgLT5cbiAgICAgICAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcCBpblxuICAgICAgICBtYXRjaCBwYXRoIHdpdGhcbiAgICAgICAgfCAgXCIvXCI6Ol8gfCAgW10gLT4gcGF0aFxuICAgICAgICB8IF8gIC0+IFwiL1wiOjpwYXRoXG4gICAgaW5cbiAgICBsZXQgcXVlcnkgPSBtYXRjaCBxdWVyeSB3aXRoXG4gICAgICB8IE5vbmUgLT4gUXVlcnkuS1YgW11cbiAgICAgIHwgU29tZSBwIC0+IFF1ZXJ5LktWIHBcbiAgICBpblxuICAgIG5vcm1hbGl6ZVxuICAgICAgeyBzY2hlbWU7XG4gICAgICAgIHVzZXJpbmZvO1xuICAgICAgICBob3N0PSBkZWNvZGVfaG9zdCBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQ9ZGVjb2RlIGZyYWdtZW50IH1cblxuICBsZXQgaG9zdCB0ID1cbiAgICBtYXRjaCB0Lmhvc3Qgd2l0aFxuICAgIHwgKGBJcHY0X2xpdGVyYWwgaCB8IGBJcHY2X2xpdGVyYWwgaCkgLT4gaFxuICAgIHwgKGBIb3N0IGgpIC0+IChQY3QudW5jYXN0X2RlY29kZWQgaClcblxuICBsZXQgc2NoZW1lIHQgPSB0LnNjaGVtZVxuZW5kXG4iXX0=
