// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Incr_select__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incr_select = [0];
   runtime.caml_register_global(0, Incr_select, "Incr_select__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_select__Incr_select_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_select_Incr_select_in = "Incr_select__Incr_select_intf",
    cst_incr_select = "incr_select";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_select_Incr_select_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_select);
   caml_call1(Expect_test_collector[5][1], "src/incr_select_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_select, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_select);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_select_Incr_select_in);
   var Incr_select_Incr_select_intf = [0];
   runtime.caml_register_global
    (11, Incr_select_Incr_select_intf, cst_Incr_select_Incr_select_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_select
//# unitInfo: Requires: Core, Core__Fn, Core__Hash_set, Core__Hashtbl, Core__List, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_select = "Incr_select",
    cst_incr_select = "incr_select";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Hash_set = global_data.Core__Hash_set,
    Core_List = global_data.Core__List,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Core_Fn = global_data.Core__Fn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_select);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_select);
   caml_call1(Expect_test_collector[5][1], "src/incr_select.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_select, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_select);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_select);
   var
    Incr_select =
      [0,
       function(Incr){
        var E = Incr[78], hashtbl_size = 10;
        function setup_generator(hashable, compute_output, make_input_node){
         var
          necessary_dependencies =
            caml_call4(Core_Hashtbl[84][1], 0, [0, hashtbl_size], hashable, 0);
         function make_key_stale(key){
          var
           _m_ = E[2][4],
           _n_ = caml_call2(Core_Hashtbl[53], necessary_dependencies, key),
           _o_ = caml_call2(Core_Option[34], _n_, 0);
          return caml_call2(Core_List[9], _o_, _m_);
         }
         var input_node = caml_call1(make_input_node, make_key_stale);
         caml_call2(Incr[58], input_node, Incr[57][6]);
         return caml_call1
                 (Core[258],
                  function(key){
                   var
                    input_dep = caml_call2(E[1][2], 0, input_node),
                    output_node = [];
                   runtime.caml_update_dummy
                    (output_node,
                     [246,
                      function(_h_){
                       return caml_call2
                               (E[2][2],
                                [0,
                                 function(is_now_observable){
                                  if(! is_now_observable)
                                   return caml_call3
                                           (Core_Hashtbl[37],
                                            necessary_dependencies,
                                            key,
                                            function(param){
                                             if(! param) return 0;
                                             var
                                              l = param[1],
                                              _j_ = caml_call1(Core[237], output_node),
                                              _k_ = caml_call1(Core[246], _j_),
                                              _l_ = caml_call1(Core_Fn[2], _k_),
                                              l$0 = caml_call2(Core_List[50], l, _l_);
                                             return l$0 ? [0, l$0] : 0;
                                            });
                                  var _i_ = caml_call1(Core[237], output_node);
                                  return caml_call3
                                          (Core_Hashtbl[78], necessary_dependencies, key, _i_);
                                 }],
                                function(param){return caml_call1(compute_output, key);});
                      }]);
                   var output_node$0 = caml_call1(Core[237], output_node);
                   caml_call2(E[2][6], output_node$0, input_dep);
                   return caml_call1(E[2][3], output_node$0);
                  });
        }
        function update_one(input, selected, make_stale){
         return caml_call2
                 (Incr[9],
                  input,
                  function(inp){
                   caml_call2(Core_Option[41], inp, make_stale);
                   caml_call2(Core_Option[41], selected[1], make_stale);
                   selected[1] = inp;
                   return 0;
                  });
        }
        function select_one(H){
         return function(input){
          var selected = [0, 0];
          function compute_output(key){
           var match = selected[1];
           if(! match) return 0;
           var key$0 = match[1], _g_ = caml_call2(H[1], key, key$0);
           return caml_call2(Core[90], _g_, 0);
          }
          function make_input_node(make_key_stale){
           return update_one(input, selected, make_key_stale);
          }
          return setup_generator(H[4], compute_output, make_input_node);};
        }
        function select_one$0(h, input){
         var _f_ = caml_call2(Incr[9], input, Core_Option[53]);
         return select_one(h)(_f_);
        }
        function select_one_value(H){
         return function(default$0, input){
          var selected = [0, 0];
          function compute_output(key){
           var _d_ = selected[1];
           if(! _d_) return default$0;
           var
            match = _d_[1],
            data = match[2],
            key$0 = match[1],
            _e_ = caml_call2(H[1], key, key$0);
           return caml_call2(Core[90], _e_, 0) ? data : default$0;
          }
          function make_input_node(make_key_stale){
           return update_one
                   (input,
                    selected,
                    function(param){
                     var key = param[1];
                     return caml_call1(make_key_stale, key);
                    });
          }
          return setup_generator(H[4], compute_output, make_input_node);};
        }
        function select_one_value$0(h, default$0, input){
         var _c_ = caml_call2(Incr[9], input, Core_Option[53]);
         return select_one_value(h)(default$0, _c_);
        }
        function select_many_values(H){
         return function(default$0, input){
          var
           hashable = H[4],
           selected =
             caml_call4
              (Core_Hashtbl[84][1], 0, [0, hashtbl_size], hashable, 0);
          function compute_output(key){
           var _b_ = caml_call2(Core_Hashtbl[53], selected, key);
           return caml_call2(Core_Option[34], _b_, default$0);
          }
          function make_input_node(make_key_stale){
           return caml_call2
                   (Incr[9],
                    input,
                    function(inp){
                     caml_call2(Core_Hashtbl[19], selected, make_key_stale);
                     caml_call1(Core_Hashtbl[16], selected);
                     return caml_call2
                             (Core_List[9],
                              inp,
                              function(param){
                               var data = param[2], key = param[1];
                               caml_call1(make_key_stale, key);
                               return caml_call3(Core_Hashtbl[34], selected, key, data);
                              });
                    });
          }
          return setup_generator(hashable, compute_output, make_input_node);};
        }
        function select_many(H){
         return function(input){
          var
           hashable = H[4],
           selected =
             caml_call4
              (Core_Hash_set[38][1], 0, [0, hashtbl_size], hashable, 0);
          function compute_output(key){
           return caml_call2(Core_Hash_set[20], selected, key);
          }
          function make_input_node(make_key_stale){
           return caml_call2
                   (Incr[9],
                    input,
                    function(inp){
                     var old_set = caml_call1(Core_Hash_set[21], selected);
                     caml_call1(Core_Hash_set[28], selected);
                     caml_call2
                      (Core_List[9],
                       inp,
                       function(key){
                        if(1 - caml_call2(Core_Hash_set[20], old_set, key))
                         caml_call1(make_key_stale, key);
                        return caml_call2(Core_Hash_set[22], selected, key);
                       });
                     return caml_call2
                             (Core_Hash_set[6],
                              old_set,
                              function(key){
                               var _a_ = 1 - caml_call2(Core_Hash_set[20], selected, key);
                               return _a_ ? caml_call1(make_key_stale, key) : _a_;
                              });
                    });
          }
          return setup_generator(hashable, compute_output, make_input_node);};
        }
        return [0,
                select_one$0,
                select_one,
                select_one_value$0,
                select_one_value,
                select_many,
                select_many_values];
       }];
   runtime.caml_register_global(17, Incr_select, cst_Incr_select);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX3NlbGVjdC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiaGFzaHRibF9zaXplIiwic2V0dXBfZ2VuZXJhdG9yIiwiaGFzaGFibGUiLCJjb21wdXRlX291dHB1dCIsIm1ha2VfaW5wdXRfbm9kZSIsIm5lY2Vzc2FyeV9kZXBlbmRlbmNpZXMiLCJtYWtlX2tleV9zdGFsZSIsImtleSIsImlucHV0X25vZGUiLCJpbnB1dF9kZXAiLCJvdXRwdXRfbm9kZSIsImlzX25vd19vYnNlcnZhYmxlIiwibCIsImwkMCIsIm91dHB1dF9ub2RlJDAiLCJ1cGRhdGVfb25lIiwiaW5wdXQiLCJzZWxlY3RlZCIsIm1ha2Vfc3RhbGUiLCJpbnAiLCJzZWxlY3Rfb25lIiwiSCIsImtleSQwIiwic2VsZWN0X29uZSQwIiwiaCIsInNlbGVjdF9vbmVfdmFsdWUiLCJkZWZhdWx0JDAiLCJkYXRhIiwic2VsZWN0X29uZV92YWx1ZSQwIiwic2VsZWN0X21hbnlfdmFsdWVzIiwic2VsZWN0X21hbnkiLCJvbGRfc2V0Il0sInNvdXJjZXMiOlsiL1VzZXJzL2phY29iemlmZi8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2luY3Jfc2VsZWN0L2luY3Jfc2VsZWN0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9NQTtpQkFjQUMsZ0JBQ0dDLFVBQ0NDLGdCQUNBQztTQUd1QjtVQUF6QkM7WUFBeUIsdUNBcEIzQkwsZUFlR0U7a0JBT0NJLGVBQWVDO1VBQ2pCOztXQUFBLE1BQUEsNkJBSEFGLHdCQUVpQkU7V0FDakIsTUFBQTtVQUFBLE9BQUE7U0FFaUM7U0FFbkMsSUFOR0MsYUFNSCxXQVZJSixpQkFLQUU7U0FTTixxQkFWS0U7U0FXQyxPQUFBOzsyQkFBS0Q7bUJBQ1Q7b0JB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LDhCQVRKVSxVQU9zQlY7dUJBR0s7cUJBR0YsT0FBQTs7OEJBVHJCd0I7dUNBUzBCeEI7K0JBQ3JCLGNBQUEsOEJBZFRVLFVBYThCVjs0Q0FFMUIsV0FiYUQsZ0JBV2FDOzhCQUVSO29CQUNyQjtVQUFDO1VBRU4sT0F4SUVOLGdCQXFIRUMsVUFFQUMsZ0JBQ0FDLGlCQWdCcUQ7OztnQkFyRXZEbUI7Z0JBaEJBSDtnQkFvQ0FRO2dCQWpCQUg7Z0JBMENBSztnQkF0QkFEOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuIENvcmVcblxubW9kdWxlIE1ha2UgKEluY3IgOiBJbmNyZW1lbnRhbC5TX2dlbikgPSBzdHJ1Y3RcbiAgbW9kdWxlIEUgPSBJbmNyLkV4cGVydFxuXG4gICgqIEhhc2h0Ymwgc3RhcnRzIG91dCBhdCBhIHJpZGljdWxvdXMgc2l6ZSBvZiAxMjguIFRoaXMgaXMgYSBtb3JlIHJlYXNvbmFibGUgbnVtYmVyXG4gICAgIG9mIGJpbnMgdG8gaGF2ZS4gKilcbiAgbGV0IGhhc2h0Ymxfc2l6ZSA9IDEwXG5cbiAgKCoqIFtzZXR1cF9nZW5lcmF0b3JdIHNldHMgdXAgdGhlIHN0YWdlZCBjb252ZXJzaW9uLlxuXG4gICAgICBbaGFzaGFibGVdIGlzIHVzZWQgdG8gYnVpbGQgYSB0YWJsZSBvZiBuZWNlc3NhcnkgZGVwZW5kZW5jaWVzLiBXZSBkcm9wIHVubmVjZXNzYXJ5XG4gICAgICBkZXBlbmRlbmNpZXMgdG8gYWxsb3cgdGhlbSB0byBiZSBjb2xsZWN0ZWQuXG5cbiAgICAgIFtjb21wdXRlX291dHB1dCBrZXldIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBvdXRwdXQgbm9kZSBjb3JyZXNwb25kaW5nIHRvIFtrZXldLlxuICAgICAgW2NvbXB1dGVfb3V0cHV0XSBpcyBjbG9zZWQgb3ZlciB0aGUgbXV0YWJsZSBzdGF0ZSBkZXRlcm1pbmluZyB0aGUgY3VycmVudCB2YWx1ZSBvZlxuICAgICAgdGhlIHNlbGVjdG9yJ3MgaW5wdXQuXG5cbiAgICAgIFttYWtlX2lucHV0X25vZGVdIG1ha2VzIHN1cmUgdGhhdCB3aGVuIHRoZSBtdXRhYmxlIHN0YXRlIGluc2lkZSBbY29tcHV0ZV9vdXRwdXRdIGlzXG4gICAgICB1cGRhdGVkLCB0aGUgY29ycmVzcG9uZGluZyBub2RlcyBpbiB0aGUgW25lY2Vzc2FyeV9kZXBlbmRlbmNpZXNdIHRhYmxlIGFyZSBtYWRlXG4gICAgICBzdGFsZS4gICopXG4gIGxldCBzZXR1cF9nZW5lcmF0b3JcbiAgICAgICAgKGhhc2hhYmxlIDogJ2EgSGFzaHRibF9pbnRmLkhhc2hhYmxlLnQpXG4gICAgICAgIH4oY29tcHV0ZV9vdXRwdXQgOiAnYSAtPiAnYilcbiAgICAgICAgfihtYWtlX2lucHV0X25vZGUgOiBtYWtlX2tleV9zdGFsZTooJ2EgLT4gdW5pdCkgLT4gdW5pdCBJbmNyLnQpXG4gICAgOiAoJ2EgLT4gJ2IgSW5jci50KSBTdGFnZWQudFxuICAgID1cbiAgICBsZXQgbmVjZXNzYXJ5X2RlcGVuZGVuY2llcyA9IEhhc2h0YmwuVXNpbmdfaGFzaGFibGUuY3JlYXRlIH5zaXplOmhhc2h0Ymxfc2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgICBsZXQgKGlucHV0X25vZGUgOiB1bml0IEluY3IudCkgPVxuICAgICAgbGV0IG1ha2Vfa2V5X3N0YWxlIGtleSA9XG4gICAgICAgIEhhc2h0YmwuZmluZCBuZWNlc3NhcnlfZGVwZW5kZW5jaWVzIGtleVxuICAgICAgICB8PiBPcHRpb24udmFsdWUgfmRlZmF1bHQ6W11cbiAgICAgICAgfD4gTGlzdC5pdGVyIH5mOkUuTm9kZS5tYWtlX3N0YWxlXG4gICAgICBpblxuICAgICAgbWFrZV9pbnB1dF9ub2RlIH5tYWtlX2tleV9zdGFsZVxuICAgIGluXG4gICAgKCogU2V0IHRoZSBjdXRvZmYgc28gdGhhdCB3ZSBuZXZlciBwYXNzIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgdXBkYXRlIHRvIHRoZSBub2Rlcy4gV2VcbiAgICAgICB3YW50IGV2ZXJ5dGhpbmcgdG8gZ28gdGhyb3VnaCBbbWFrZV9rZXlfc3RhbGVdICopXG4gICAgSW5jci5zZXRfY3V0b2ZmIGlucHV0X25vZGUgSW5jci5DdXRvZmYuYWx3YXlzO1xuICAgIHN0YWdlIChmdW4ga2V5IC0+XG4gICAgICBsZXQgaW5wdXRfZGVwID0gRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9ub2RlIGluXG4gICAgICBsZXQgcmVjIG91dHB1dF9ub2RlID0gbGF6eSAoXG4gICAgICAgIEUuTm9kZS5jcmVhdGVcbiAgICAgICAgICAoZnVuICgpIC0+IGNvbXB1dGVfb3V0cHV0IGtleSlcbiAgICAgICAgICB+b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2U6KGZ1biB+aXNfbm93X29ic2VydmFibGUgLT5cbiAgICAgICAgICAgIGlmIGlzX25vd19vYnNlcnZhYmxlIHRoZW5cbiAgICAgICAgICAgICAgSGFzaHRibC5hZGRfbXVsdGkgbmVjZXNzYXJ5X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhOihmb3JjZSBvdXRwdXRfbm9kZSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgSGFzaHRibC5jaGFuZ2UgbmVjZXNzYXJ5X2RlcGVuZGVuY2llcyBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICB8IFNvbWUgbCAtPlxuICAgICAgICAgICAgICAgICAgbWF0Y2ggTGlzdC5maWx0ZXIgbCB+ZjooRm4ubm9uIChwaHlzX2VxdWFsIChmb3JjZSBvdXRwdXRfbm9kZSkpKSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgbCcgLT4gU29tZSBsJ1xuICAgICAgICAgICAgICApKSlcbiAgICAgIGluXG4gICAgICBsZXQgb3V0cHV0X25vZGUgPSBmb3JjZSBvdXRwdXRfbm9kZSBpblxuICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IG91dHB1dF9ub2RlIGlucHV0X2RlcDtcbiAgICAgIEUuTm9kZS53YXRjaCBvdXRwdXRfbm9kZVxuICAgIClcblxuICAoKiogVGhpcyBjcmVhdGVzIGEgdW5pdCBpbmNyZW1lbnRhbCB0aGF0IGZpcmVzIHdoZW5ldmVyIHRoZSBpbnB1dCBpbmNyZW1lbnRhbFxuICAgICAgZmlyZXMuIFdoZW4gdGhhdCBvY2N1cnMsIGl0IHVwZGF0ZXMgW3NlbGVjdGVkXSB0byBtYXRjaCB0aGUgY3VycmVudCB2YWx1ZSBvZlxuICAgICAgW2lucHV0XSwgYW5kIGNhbGxzIFttYWtlX2tleV9zdGFsZV0gZm9yIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZhbHVlIG9mIHRoZVxuICAgICAgaW5jcmVtZW50YWwuICopXG4gIGxldCB1cGRhdGVfb25lIH5pbnB1dCB+c2VsZWN0ZWQgfm1ha2Vfc3RhbGUgPVxuICAgIEluY3IubWFwIGlucHV0IH5mOihmdW4gaW5wIC0+XG4gICAgICBPcHRpb24uaXRlciBpbnAgfmY6bWFrZV9zdGFsZTtcbiAgICAgIE9wdGlvbi5pdGVyICFzZWxlY3RlZCB+ZjptYWtlX3N0YWxlO1xuICAgICAgc2VsZWN0ZWQgOj0gaW5wXG4gICAgKVxuXG4gIGxldCBzZWxlY3Rfb25lJ1xuICAgICAgICAodHlwZSBhKVxuICAgICAgICAobW9kdWxlIEggOiBIYXNoYWJsZS5Db21tb24gd2l0aCB0eXBlIHQgPSBhKVxuICAgICAgICAoaW5wdXQgOiBhIG9wdGlvbiBJbmNyLnQpXG4gICAgPVxuICAgIGxldCBzZWxlY3RlZCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGNvbXB1dGVfb3V0cHV0IGtleSA9XG4gICAgICBtYXRjaCAhc2VsZWN0ZWQgd2l0aFxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICB8IFNvbWUga2V5JyAtPiBILmNvbXBhcmUga2V5IGtleScgPSAwXG4gICAgaW5cbiAgICBsZXQgbWFrZV9pbnB1dF9ub2RlIH5tYWtlX2tleV9zdGFsZSA9XG4gICAgICB1cGRhdGVfb25lIH5pbnB1dCB+c2VsZWN0ZWQgfm1ha2Vfc3RhbGU6bWFrZV9rZXlfc3RhbGVcbiAgICBpblxuICAgIHNldHVwX2dlbmVyYXRvciBILmhhc2hhYmxlIH5jb21wdXRlX291dHB1dCB+bWFrZV9pbnB1dF9ub2RlXG5cbiAgbGV0IHNlbGVjdF9vbmUgaCBpbnB1dCA9XG4gICAgc2VsZWN0X29uZScgaCAoSW5jci5tYXAgfmY6T3B0aW9uLnNvbWUgaW5wdXQpXG5cbiAgbGV0IHNlbGVjdF9vbmVfdmFsdWUnXG4gICAgICAgICh0eXBlIGEpXG4gICAgICAgIChtb2R1bGUgSCA6IEhhc2hhYmxlLkNvbW1vbiB3aXRoIHR5cGUgdCA9IGEpXG4gICAgICAgIH5kZWZhdWx0XG4gICAgICAgIGlucHV0XG4gICAgPVxuICAgIGxldCBzZWxlY3RlZCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGNvbXB1dGVfb3V0cHV0IGtleSA9XG4gICAgICBtYXRjaCAhc2VsZWN0ZWQgd2l0aFxuICAgICAgfCBOb25lIC0+IGRlZmF1bHRcbiAgICAgIHwgU29tZSAoa2V5JywgZGF0YSkgLT4gaWYgSC5jb21wYXJlIGtleSBrZXknID0gMCB0aGVuIGRhdGEgZWxzZSBkZWZhdWx0XG4gICAgaW5cbiAgICBsZXQgbWFrZV9pbnB1dF9ub2RlIH5tYWtlX2tleV9zdGFsZSA9XG4gICAgICB1cGRhdGVfb25lIH5zZWxlY3RlZCB+aW5wdXQgfm1ha2Vfc3RhbGU6KGZ1biAoa2V5LCBfKSAtPiBtYWtlX2tleV9zdGFsZSBrZXkpXG4gICAgaW5cbiAgICBzZXR1cF9nZW5lcmF0b3IgSC5oYXNoYWJsZSB+Y29tcHV0ZV9vdXRwdXQgfm1ha2VfaW5wdXRfbm9kZVxuXG4gIGxldCBzZWxlY3Rfb25lX3ZhbHVlIGggfmRlZmF1bHQgaW5wdXQgPVxuICAgIHNlbGVjdF9vbmVfdmFsdWUnIGggfmRlZmF1bHQgKEluY3IubWFwIH5mOk9wdGlvbi5zb21lIGlucHV0KVxuXG4gIGxldCBzZWxlY3RfbWFueV92YWx1ZXNcbiAgICAgICAgKHR5cGUgYSlcbiAgICAgICAgKG1vZHVsZSBIIDogSGFzaGFibGUuQ29tbW9uIHdpdGggdHlwZSB0ID0gYSlcbiAgICAgICAgfmRlZmF1bHRcbiAgICAgICAgaW5wdXRcbiAgICA9XG4gICAgbGV0IGhhc2hhYmxlID0gSC5oYXNoYWJsZSBpblxuICAgIGxldCBzZWxlY3RlZCA9IEhhc2h0YmwuVXNpbmdfaGFzaGFibGUuY3JlYXRlIH5zaXplOmhhc2h0Ymxfc2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgICBsZXQgY29tcHV0ZV9vdXRwdXQga2V5ID1cbiAgICAgIEhhc2h0YmwuZmluZCBzZWxlY3RlZCBrZXkgfD4gT3B0aW9uLnZhbHVlIH5kZWZhdWx0XG4gICAgaW5cbiAgICBsZXQgbWFrZV9pbnB1dF9ub2RlIH5tYWtlX2tleV9zdGFsZSA9XG4gICAgICBJbmNyLm1hcCBpbnB1dCB+ZjooZnVuIGlucCAtPlxuICAgICAgICBIYXNodGJsLml0ZXJfa2V5cyBzZWxlY3RlZCB+ZjptYWtlX2tleV9zdGFsZTtcbiAgICAgICAgSGFzaHRibC5jbGVhciBzZWxlY3RlZDtcbiAgICAgICAgTGlzdC5pdGVyIGlucCB+ZjooZnVuIChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgbWFrZV9rZXlfc3RhbGUga2V5O1xuICAgICAgICAgIEhhc2h0Ymwuc2V0IHNlbGVjdGVkIH5rZXkgfmRhdGFcbiAgICAgICAgKSlcbiAgICBpblxuICAgIHNldHVwX2dlbmVyYXRvciBoYXNoYWJsZSB+Y29tcHV0ZV9vdXRwdXQgfm1ha2VfaW5wdXRfbm9kZVxuXG4gIGxldCBzZWxlY3RfbWFueVxuICAgICAgICAodHlwZSBhKVxuICAgICAgICAobW9kdWxlIEggOiBIYXNoYWJsZS5Db21tb24gd2l0aCB0eXBlIHQgPSBhKVxuICAgICAgICBpbnB1dFxuICAgID1cbiAgICBsZXQgaGFzaGFibGUgPSBILmhhc2hhYmxlIGluXG4gICAgbGV0IHNlbGVjdGVkID0gSGFzaF9zZXQuVXNpbmdfaGFzaGFibGUuY3JlYXRlIH5zaXplOmhhc2h0Ymxfc2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgICBsZXQgY29tcHV0ZV9vdXRwdXQga2V5ID0gSGFzaF9zZXQubWVtIHNlbGVjdGVkIGtleSBpblxuICAgIGxldCBtYWtlX2lucHV0X25vZGUgfm1ha2Vfa2V5X3N0YWxlID1cbiAgICAgIEluY3IubWFwIGlucHV0IH5mOihmdW4gaW5wIC0+XG4gICAgICAgIGxldCBvbGRfc2V0ID0gSGFzaF9zZXQuY29weSBzZWxlY3RlZCBpblxuICAgICAgICBIYXNoX3NldC5jbGVhciBzZWxlY3RlZDtcblxuICAgICAgICBMaXN0Lml0ZXIgaW5wIH5mOihmdW4ga2V5IC0+XG4gICAgICAgICAgaWYgbm90IChIYXNoX3NldC5tZW0gb2xkX3NldCBrZXkpIHRoZW5cbiAgICAgICAgICAgIG1ha2Vfa2V5X3N0YWxlIGtleTtcbiAgICAgICAgICBIYXNoX3NldC5hZGQgc2VsZWN0ZWQga2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgSGFzaF9zZXQuaXRlciBvbGRfc2V0IH5mOihmdW4ga2V5IC0+XG4gICAgICAgICAgaWYgbm90IChIYXNoX3NldC5tZW0gc2VsZWN0ZWQga2V5KSB0aGVuXG4gICAgICAgICAgICBtYWtlX2tleV9zdGFsZSBrZXk7XG4gICAgICAgICkpXG4gICAgaW5cbiAgICBzZXR1cF9nZW5lcmF0b3IgaGFzaGFibGUgfmNvbXB1dGVfb3V0cHV0IH5tYWtlX2lucHV0X25vZGVcbmVuZFxuXG4iXX0=
