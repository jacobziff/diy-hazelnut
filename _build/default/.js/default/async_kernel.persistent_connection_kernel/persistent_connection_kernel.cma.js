// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1

//# unitInfo: Provides: Persistent_connection_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Persistent_connection_kernel = [0];
   runtime.caml_register_global
    (0, Persistent_connection_kernel, "Persistent_connection_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel__Persistent_connection_kernel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern =
      "Persistent_connection_kernel__Persistent_connection_kernel_intf",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var Persistent_connection_kernel_P = [0];
   runtime.caml_register_global
    (11, Persistent_connection_kernel_P, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel
//# unitInfo: Requires: Async_kernel, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Time_source, Base__Exn, Base__Field, Base__Random, Core, Core__Error, Core__Fn, Core__Option, Core__Or_error, Core__Sexp, Core__Time_ns, Expect_test_collector, Persistent_connection_kernel__Persistent_connection_kernel_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern = "Persistent_connection_kernel",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _a_ = [0, "<Conn.t>"],
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel = global_data.Async_kernel,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Random = global_data.Base__Random,
    Core = global_data.Core,
    Core_Fn = global_data.Core__Fn,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var
    _b_ = [0, "Attempting_to_connect"],
    _c_ = [0, "Disconnected"],
    _d_ = [0, "Obtained_address"],
    _e_ = [0, "Failed_to_connect"],
    _f_ = [0, "Connected"],
    _g_ = [0, "on_event"],
    _h_ = [0, "server_name"],
    _i_ = [0, "sexp_of_address"],
    _j_ = [0, "address_equal"],
    _k_ = [0, "don't_reconnect"],
    _l_ = [0, "close_finished"],
    _m_ = [0, "close_started"],
    _n_ = [0, "event_handler"],
    _o_ = [0, "next_connect_result"],
    _p_ = [0, "Close_started"],
    _q_ = [0, "Ok"],
    _r_ = [0, "conn"],
    _s_ = [0, "retry_delay"],
    _t_ = [0, "connect"],
    _u_ = [0, "get_address"],
    _v_ = [0, -289386606, 0],
    _w_ = [0, -289386606, 0],
    _x_ = [0, -289386606, 0],
    _y_ = [0, -289386606, 0],
    _z_ = [0, 990972795, 0],
    cst_Persistent_connection_clos = "Persistent connection closed",
    Persistent_connection_kernel =
      [0,
       function(Conn){
        var close = Conn[1], is_closed = Conn[2], close_finished = Conn[3];
        function sexp_of_t(param){return _a_;}
        function sexp_of_t$0(of_address_001, param){
         if(typeof param === "number") return 0 === param ? _b_ : _c_;
         switch(param[0]){
           case 0:
            var
             arg0_002 = param[1],
             res0_003 = caml_call1(of_address_001, arg0_002);
            return [1, [0, _d_, [0, res0_003, 0]]];
           case 1:
            var
             arg0_004 = param[1],
             res0_005 = caml_call1(Core_Error[6], arg0_004);
            return [1, [0, _e_, [0, res0_005, 0]]];
           default:
            var
             arg0_006 = param[1],
             res0_007 = caml_call1(Sexplib0_Sexp_conv[23], arg0_006);
            return [1, [0, _f_, [0, res0_007, 0]]];
         }
        }
        function log_level(param){
         if(typeof param !== "number" && 1 === param[0]) return 106380200;
         return 815031438;
        }
        function handle_event(t, event){
         var on_event = t[6][2];
         return caml_call1(on_event, event);
        }
        function abort_reconnecting_with_no_act(t){
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         caml_call2(Async_kernel_Ivar[14], t[8], 0);
         return caml_call2(Async_kernel_Ivar[14], t[4], -400989606);
        }
        function current_connection(t){
         var
          _au_ = caml_call1(Async_kernel_Ivar[18], t[4]),
          match = caml_call1(Async_kernel_Deferred[5], _au_);
         if(match){
          var match$0 = match[1];
          if(typeof match$0 !== "number"){
           var conn = match$0[2];
           return [0, conn];
          }
         }
         return 0;
        }
        function close_finished$0(t){
         return caml_call1(Async_kernel_Ivar[18], t[8]);
        }
        function is_closed$0(t){
         return caml_call1(Async_kernel_Ivar[17], t[7]);
        }
        var
         _A_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_Persistent_connection_clos),
         connected_or_failed_to_connect = caml_call1(Core_Or_error[40], _A_);
        function sexp_of_t$1(param){
         var
          conn_023 = param[4],
          next_connect_result_026 = param[5],
          don_t_reconnect_034 = param[9],
          close_finished_032 = param[8],
          close_started_030 = param[7],
          event_handler_028 = param[6],
          arg_039 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_at_){return 0;}),
          bnds_016 = [0, [1, [0, _i_, [0, arg_039, 0]]], 0],
          arg_037 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_as_){return 0;}),
          bnds_016$0 = [0, [1, [0, _j_, [0, arg_037, 0]]], bnds_016],
          arg_035 =
            caml_call2(Async_kernel_Ivar[9], Core[518], don_t_reconnect_034),
          bnds_016$1 = [0, [1, [0, _k_, [0, arg_035, 0]]], bnds_016$0],
          arg_033 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_finished_032),
          bnds_016$2 = [0, [1, [0, _l_, [0, arg_033, 0]]], bnds_016$1],
          arg_031 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_started_030),
          bnds_016$3 = [0, [1, [0, _m_, [0, arg_031, 0]]], bnds_016$2],
          server_name_011 = event_handler_028[1],
          arg_014 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ar_){return 0;}),
          bnds_010 = [0, [1, [0, _g_, [0, arg_014, 0]]], 0],
          arg_012 = caml_call1(Core[471], server_name_011),
          bnds_010$0 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_010],
          arg_029 = [1, bnds_010$0],
          bnds_016$4 = [0, [1, [0, _n_, [0, arg_029, 0]]], bnds_016$3],
          _an_ = caml_call1(Core_Or_error[13], sexp_of_t),
          arg_027 =
            caml_call2(Async_kernel_Ivar[9], _an_, next_connect_result_026),
          bnds_016$5 = [0, [1, [0, _o_, [0, arg_027, 0]]], bnds_016$4],
          arg_024 =
            caml_call2
             (Async_kernel_Ivar[9],
              function(param){
               return typeof param === "number"
                       ? _p_
                       : [1, [0, _q_, [0, _a_, 0]]];
              },
              conn_023),
          bnds_016$6 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_016$5],
          arg_022 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_aq_){return 0;}),
          bnds_016$7 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_016$6],
          arg_020 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ap_){return 0;}),
          bnds_016$8 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_016$7],
          arg_018 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ao_){return 0;}),
          bnds_016$9 = [0, [1, [0, _u_, [0, arg_018, 0]]], bnds_016$8];
         return [1, bnds_016$9];
        }
        function close_when_current_connection_(t){
         return caml_call2(Async_kernel_Ivar[15], t[9], 0);
        }
        function close_finished$1(param){return close_finished$0(param);}
        function is_closed$1(param){return is_closed$0(param);}
        function close$0(t){
         if(caml_call1(Async_kernel_Ivar[17], t[7]))
          return close_finished$0(t);
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         var _ak_ = caml_call1(Async_kernel_Ivar[18], t[4]);
         return caml_call2
                 (Async_kernel[20],
                  _ak_,
                  function(conn_opt){
                   function _al_(param){
                    return caml_call2(Async_kernel_Ivar[14], t[8], 0);
                   }
                   if(typeof conn_opt === "number")
                    var _am_ = Async_kernel_Deferred[18];
                   else
                    var conn = conn_opt[2], _am_ = caml_call1(close, conn);
                   return caml_call2(Async_kernel[21], _am_, _al_);
                  });
        }
        function server_name(t){return t[6][1];}
        function current_connection$0(param){return current_connection(param);
        }
        function connected_or_failed_to_connect$0(t){
         if(is_closed$0(t))
          return caml_call1(Async_kernel[19], connected_or_failed_to_connect);
         var match = current_connection(t);
         if(match){
          var x = match[1];
          if(! caml_call1(is_closed, x))
           return caml_call1(Async_kernel[19], [0, x]);
         }
         var
          _af_ = caml_call1(Async_kernel_Ivar[18], t[5]),
          _ag_ =
            [0,
             caml_call2(Async_kernel[4], _af_, function(_aj_){return _aj_;}),
             0],
          _ah_ = caml_call1(Async_kernel_Ivar[18], t[7]),
          _ai_ =
            [0,
             caml_call2
              (Async_kernel[4],
               _ah_,
               function(param){return connected_or_failed_to_connect;}),
             _ag_];
         return caml_call1(Async_kernel_Deferred[29], _ai_);
        }
        function connected(t){
         function loop(param){
          var
           d = caml_call1(Async_kernel_Ivar[18], t[4]),
           match = caml_call1(Async_kernel_Deferred[5], d);
          if(! match)
           return caml_call2
                   (Async_kernel[20],
                    d,
                    function(param){
                     if(typeof param === "number")
                      return caml_call1(Async_kernel_Deferred[19], 0);
                     var conn = param[2];
                     return caml_call1(Async_kernel[19], conn);
                    });
          var match$0 = match[1];
          if(typeof match$0 === "number")
           return caml_call1(Async_kernel_Deferred[19], 0);
          var conn = match$0[2];
          if(! caml_call1(is_closed, conn))
           return caml_call1(Async_kernel[19], conn);
          var _ae_ = caml_call1(close_finished, conn);
          return caml_call2(Async_kernel[20], _ae_, loop);
         }
         return loop(0);
        }
        function create
        (server_name,
         on_event$0,
         retry_delay$0,
         random_state$1,
         time_source$0,
         connect,
         address,
         get_address){
         if(on_event$0)
          var sth = on_event$0[1], on_event = sth;
         else
          var on_event = function(param){return Async_kernel_Deferred[18];};
         if(random_state$1)
          var sth$0 = random_state$1[1], random_state = sth$0;
         else
          var random_state = [0, 389604849, Base_Random[18][1]];
         if(time_source$0)
          var sth$1 = time_source$0[1], time_source = sth$1;
         else
          var time_source = caml_call1(Async_kernel_Time_source[10], 0);
         var
          event_handler = [0, server_name, on_event],
          _B_ = Core[541] ? 0.1 : 10.,
          _C_ = caml_call1(Core_Time_ns[1][81], _B_),
          default_retry_delay = caml_call1(Core_Fn[1], _C_),
          non_randomized_delay =
            caml_call2(Core_Option[34], retry_delay$0, default_retry_delay);
         if(typeof random_state === "number")
          var retry_delay_span = non_randomized_delay;
         else
          var
           random_state$0 = random_state[2],
           retry_delay_span =
             function(param){
              var
               span = caml_call1(non_randomized_delay, 0),
               span$0 = caml_call1(Core_Time_ns[1][91], span),
               distance =
                 caml_call2(Base_Random[18][10], random_state$0, span$0 * 0.3),
               wait =
                 caml_call1(Base_Random[18][16], random_state$0)
                  ? span$0 + distance
                  : span$0 - distance;
              return caml_call1(Core_Time_ns[1][81], wait);
             };
         function retry_delay(param){
          var _ad_ = caml_call1(retry_delay_span, 0);
          return caml_call2(Async_kernel_Time_source[29], time_source, _ad_);
         }
         var
          _D_ = address[2],
          _E_ = address[1],
          _F_ = caml_call1(Async_kernel_Ivar[12], 0),
          _G_ = caml_call1(Async_kernel_Ivar[12], 0),
          _H_ = caml_call1(Async_kernel_Ivar[12], 0),
          _I_ = caml_call1(Async_kernel_Ivar[12], 0),
          t =
            [0,
             get_address,
             connect,
             retry_delay,
             caml_call1(Async_kernel_Ivar[12], 0),
             _I_,
             event_handler,
             _H_,
             _G_,
             _F_,
             _E_,
             _D_],
          _J_ =
            caml_call2
             (Async_kernel_Deferred[31],
              0,
              function(param){
               var _K_ = handle_event(t, 0);
               return caml_call2
                       (Async_kernel[20],
                        _K_,
                        function(param){
                         var previous_address = [0, 0], previous_error = [0, 0];
                         function loop(param){
                          if(caml_call1(Async_kernel_Ivar[17], t[7]))
                           return caml_call1(Async_kernel[19], -400989606);
                          if(caml_call1(Async_kernel_Ivar[17], t[9]))
                           return caml_call1(Async_kernel[19], -818917400);
                          var
                           ready_to_retry_connecting = caml_call1(t[3], 0),
                           _S_ = caml_call1(t[1], 0),
                           _T_ =
                             caml_call2
                              (Async_kernel[20],
                               _S_,
                               function(param){
                                if(0 !== param[0]){
                                 var e = param[1];
                                 return caml_call1(Async_kernel[19], [1, e]);
                                }
                                var addr = param[1], match = previous_address[1];
                                if(match)
                                 var
                                  previous_address$0 = match[1],
                                  same_as_previous_address =
                                    caml_call2(t[10], addr, previous_address$0);
                                else
                                 var same_as_previous_address = 0;
                                previous_address[1] = [0, addr];
                                function _ab_(param){return caml_call1(t[2], addr);}
                                var
                                 _ac_ =
                                   same_as_previous_address
                                    ? Async_kernel_Deferred[18]
                                    : handle_event(t, [0, addr]);
                                return caml_call2(Async_kernel[20], _ac_, _ab_);
                               });
                          return caml_call2
                                  (Async_kernel[22][2],
                                   _T_,
                                   function(connect_result){
                                    caml_call2(Async_kernel_Ivar[14], t[5], connect_result);
                                    t[5] = caml_call1(Async_kernel_Ivar[12], 0);
                                    if(0 === connect_result[0]){
                                     var conn = connect_result[1];
                                     return caml_call1
                                             (Async_kernel[19],
                                              [0, 17724, [0, conn, ready_to_retry_connecting]]);
                                    }
                                    var err = connect_result[1], match = previous_error[1];
                                    if(match)
                                     var
                                      previous_err = match[1],
                                      to_sexp =
                                        function(e){
                                         var
                                          _$_ = caml_call1(Core_Error[26], e),
                                          _aa_ = caml_call1(Async_kernel_Monitor[13], _$_);
                                         return caml_call1(Base_Exn[1], _aa_);
                                        },
                                      _U_ = to_sexp(previous_err),
                                      _V_ = to_sexp(err),
                                      same_as_previous_error = caml_call2(Core_Sexp[36], _V_, _U_);
                                    else
                                     var same_as_previous_error = 0;
                                    previous_error[1] = [0, err];
                                    function _W_(param){
                                     var
                                      _Y_ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
                                      _Z_ =
                                        [0,
                                         ready_to_retry_connecting,
                                         [0, caml_call1(Async_kernel_Ivar[18], t[7]), _Y_]],
                                      ___ = caml_call1(Async_kernel_Deferred[23], _Z_);
                                     return caml_call2
                                             (Async_kernel[20], ___, function(param){return loop(0);});
                                    }
                                    var
                                     _X_ =
                                       same_as_previous_error
                                        ? Async_kernel_Deferred[18]
                                        : handle_event(t, [1, err]);
                                    return caml_call2(Async_kernel[20], _X_, _W_);
                                   });
                         }
                         var _L_ = loop(0);
                         return caml_call2
                                 (Async_kernel[20],
                                  _L_,
                                  function(param){
                                   if(typeof param === "number")
                                    return -400989606 <= param
                                            ? (caml_call2
                                               (Async_kernel_Ivar[14], t[4], -400989606),
                                              caml_call1(Async_kernel[19], _v_))
                                            : (abort_reconnecting_with_no_act
                                               (t),
                                              caml_call1(Async_kernel[19], _w_));
                                   var
                                    match = param[2],
                                    ready_to_retry_connecting = match[2],
                                    conn = match[1];
                                   caml_call2(Async_kernel_Ivar[14], t[4], [0, 17724, conn]);
                                   var _M_ = handle_event(t, [2, conn]);
                                   return caml_call2
                                           (Async_kernel[20],
                                            _M_,
                                            function(param){
                                             var _N_ = caml_call1(close_finished, conn);
                                             return caml_call2
                                                     (Async_kernel[20],
                                                      _N_,
                                                      function(param){
                                                       t[4] = caml_call1(Async_kernel_Ivar[12], 0);
                                                       var _O_ = handle_event(t, 1);
                                                       return caml_call2
                                                               (Async_kernel[20],
                                                                _O_,
                                                                function(param){
                                                                 var
                                                                  _P_ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
                                                                  _Q_ =
                                                                    [0,
                                                                     ready_to_retry_connecting,
                                                                     [0, caml_call1(Async_kernel_Ivar[18], t[7]), _P_]],
                                                                  _R_ = caml_call1(Async_kernel_Deferred[23], _Q_);
                                                                 return caml_call2
                                                                         (Async_kernel[22][3],
                                                                          _R_,
                                                                          function(param){
                                                                           return caml_call1(Async_kernel_Ivar[17], t[7])
                                                                                   ? (caml_call2(Async_kernel_Ivar[14], t[4], -400989606), _x_)
                                                                                   : caml_call1
                                                                                      (Async_kernel_Ivar[17], t[9])
                                                                                     ? (abort_reconnecting_with_no_act(t), _y_)
                                                                                     : _z_;
                                                                          });
                                                                });
                                                      });
                                            });
                                  });
                        });
              });
         caml_call1(Async_kernel[6], _J_);
         return t;
        }
        return [0,
                sexp_of_t$1,
                [0, sexp_of_t$0, log_level],
                create,
                connected,
                connected_or_failed_to_connect$0,
                current_connection$0,
                server_name,
                close$0,
                is_closed$1,
                close_finished$1,
                close_when_current_connection_];
       }];
   runtime.caml_register_global
    (69, Persistent_connection_kernel, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJzZXhwX29mX3QiLCJzZXhwX29mX3QkMCIsIm9mX2FkZHJlc3NfMDAxIiwiYXJnMF8wMDIiLCJyZXMwXzAwMyIsImFyZzBfMDA0IiwicmVzMF8wMDUiLCJhcmcwXzAwNiIsInJlczBfMDA3IiwibG9nX2xldmVsIiwiaGFuZGxlX2V2ZW50IiwidCIsImV2ZW50Iiwib25fZXZlbnQiLCJhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3QiLCJjdXJyZW50X2Nvbm5lY3Rpb24iLCJjb25uIiwiY2xvc2VfZmluaXNoZWQkMCIsImlzX2Nsb3NlZCQwIiwiY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0Iiwic2V4cF9vZl90JDEiLCJwYXJhbSIsImNvbm5fMDIzIiwibmV4dF9jb25uZWN0X3Jlc3VsdF8wMjYiLCJkb25fdF9yZWNvbm5lY3RfMDM0IiwiY2xvc2VfZmluaXNoZWRfMDMyIiwiY2xvc2Vfc3RhcnRlZF8wMzAiLCJldmVudF9oYW5kbGVyXzAyOCIsImFyZ18wMzkiLCJibmRzXzAxNiIsImFyZ18wMzciLCJibmRzXzAxNiQwIiwiYXJnXzAzNSIsImJuZHNfMDE2JDEiLCJhcmdfMDMzIiwiYm5kc18wMTYkMiIsImFyZ18wMzEiLCJibmRzXzAxNiQzIiwic2VydmVyX25hbWVfMDExIiwiYXJnXzAxNCIsImJuZHNfMDEwIiwiYXJnXzAxMiIsImJuZHNfMDEwJDAiLCJhcmdfMDI5IiwiYm5kc18wMTYkNCIsImFyZ18wMjciLCJibmRzXzAxNiQ1IiwiYXJnXzAyNCIsImJuZHNfMDE2JDYiLCJhcmdfMDIyIiwiYm5kc18wMTYkNyIsImFyZ18wMjAiLCJibmRzXzAxNiQ4IiwiYXJnXzAxOCIsImJuZHNfMDE2JDkiLCJjbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl8iLCJjbG9zZV9maW5pc2hlZCQxIiwiaXNfY2xvc2VkJDEiLCJjbG9zZSQwIiwiY29ubl9vcHQiLCJzZXJ2ZXJfbmFtZSIsImN1cnJlbnRfY29ubmVjdGlvbiQwIiwiY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0JDAiLCJ4IiwiY29ubmVjdGVkIiwibG9vcCIsImQiLCJjcmVhdGUiLCJvbl9ldmVudCQwIiwicmV0cnlfZGVsYXkkMCIsInJhbmRvbV9zdGF0ZSQxIiwidGltZV9zb3VyY2UkMCIsImNvbm5lY3QiLCJhZGRyZXNzIiwiZ2V0X2FkZHJlc3MiLCJzdGgiLCJzdGgkMCIsInJhbmRvbV9zdGF0ZSIsInN0aCQxIiwidGltZV9zb3VyY2UiLCJldmVudF9oYW5kbGVyIiwiZGVmYXVsdF9yZXRyeV9kZWxheSIsIm5vbl9yYW5kb21pemVkX2RlbGF5IiwicmV0cnlfZGVsYXlfc3BhbiIsInJhbmRvbV9zdGF0ZSQwIiwic3BhbiIsInNwYW4kMCIsImRpc3RhbmNlIiwid2FpdCIsInJldHJ5X2RlbGF5IiwicHJldmlvdXNfYWRkcmVzcyIsInByZXZpb3VzX2Vycm9yIiwicmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZyIsImUiLCJhZGRyIiwicHJldmlvdXNfYWRkcmVzcyQwIiwic2FtZV9hc19wcmV2aW91c19hZGRyZXNzIiwiY29ubmVjdF9yZXN1bHQiLCJlcnIiLCJwcmV2aW91c19lcnIiLCJ0b19zZXhwIiwic2FtZV9hc19wcmV2aW91c19lcnJvciJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYWNvYnppZmYvLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC9wZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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SHpCSzttQ0FFTCxVQXpJRk4sYUFlZ0NDLE9Bd0h6Qks7bUNBR0QsT0FBQTs7Ozs2Q0FDSixVQUFBLDJCQUpLQTs2Q0FLRCxPQUFBOzs7O3VEQTdIMEJMLE9BOEhwQjt1REFDVixVQTlJRkQsYUFlZ0NDO3VEQWdJMUIsT0FBQTs7OztpRUFNQTs0RUFFRSxrQ0F4SXdCQTtrRUFzSTFCOztxRUFkT2lGO3lFQWVMLGtDQXZJd0JqRjtrRUFxSTVCLE1BQUE7Ozs7OzJFQU1GLE9BQUcsa0NBM0kyQkE7c0ZBNkk1QixrQ0E3STRCQTtxRkErSXRCOzhHQS9Jc0JBO3dGQXNEaENHLCtCQXREZ0NIOzswRUFtSmY7O3NEQUFBOzRDQUFBO2tDQUFBO3dCQUFBO2NBQUE7U0F2Q25CO1NBQUEsT0E1R2tDQTtRQStRbkI7O2dCQWpDZlM7b0JBMVNGbkIsYUFrQklRO2dCQXNTRjBEO2dCQUZBSDtnQkFEQUY7Z0JBREFEO2dCQURBRDtnQkFEQUY7Z0JBREFEO2dCQURBRDtnQkFKQUQ7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5vcGVuISBBc3luY19rZXJuZWxcbm9wZW4hIEFzeW5jX2tlcm5lbF9yZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXG5pbmNsdWRlIFBlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWxfaW50ZlxuXG5tb2R1bGUgTWFrZSAoQ29ubiA6IENsb3NhYmxlKSA9IHN0cnVjdFxuICBtb2R1bGUgQ29ubiA9IHN0cnVjdFxuICAgIGluY2x1ZGUgQ29ublxuXG4gICAgbGV0IHNleHBfb2ZfdCAoXyA6IHQpIDogU2V4cC50ID0gQXRvbSBcIjxDb25uLnQ+XCJcbiAgZW5kXG5cbiAgdHlwZSBjb25uID0gQ29ubi50XG5cbiAgbW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgIHwgQXR0ZW1wdGluZ190b19jb25uZWN0XG4gICAgICB8IE9idGFpbmVkX2FkZHJlc3Mgb2YgJ2FkZHJlc3NcbiAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3Qgb2YgRXJyb3IudFxuICAgICAgfCBDb25uZWN0ZWQgb2YgKGNvbm5bQHNleHAub3BhcXVlXSlcbiAgICAgIHwgRGlzY29ubmVjdGVkXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHR5cGUgJ2FkZHJlc3MgZXZlbnQgPSAnYWRkcmVzcyB0XG5cbiAgICBtb2R1bGUgSGFuZGxlciA9IHN0cnVjdFxuICAgICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgICAgeyBzZXJ2ZXJfbmFtZSA6IHN0cmluZ1xuICAgICAgICA7IG9uX2V2ZW50IDogJ2FkZHJlc3MgZXZlbnQgLT4gdW5pdCBEZWZlcnJlZC50XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICBsZXQgbG9nX2xldmVsID0gZnVuY3Rpb25cbiAgICAgIHwgQXR0ZW1wdGluZ190b19jb25uZWN0IHwgQ29ubmVjdGVkIF8gfCBEaXNjb25uZWN0ZWQgfCBPYnRhaW5lZF9hZGRyZXNzIF8gLT4gYEluZm9cbiAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3QgXyAtPiBgRXJyb3JcbiAgICA7O1xuXG4gICAgbGV0IGhhbmRsZSB0IHsgSGFuZGxlci5zZXJ2ZXJfbmFtZSA9IF87IG9uX2V2ZW50IH0gPSBvbl9ldmVudCB0XG4gIGVuZFxuXG4gICgqIEEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRoYXQgaXMgcG9seW1vcnBoaWMgaW4gdGhlIGFkZHJlc3MgdHlwZS4gIFdlIGhpZGUgYXdheSB0aGlzXG4gICAgIHR5cGUgbGF0ZXIgc2luY2UgaXQgb25seSBhcHBlYXJzIGluIHRoZSB0eXBlIG9mIFtjcmVhdGVdLiAqKVxuICBtb2R1bGUgUG9seSA9IHN0cnVjdFxuICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICB7IGdldF9hZGRyZXNzIDogdW5pdCAtPiAnYWRkcmVzcyBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICAgIDsgY29ubmVjdCA6ICdhZGRyZXNzIC0+IENvbm4udCBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICAgIDsgcmV0cnlfZGVsYXkgOiB1bml0IC0+IHVuaXQgRGVmZXJyZWQudFxuICAgICAgOyBtdXRhYmxlIGNvbm4gOiBbIGBPayBvZiBDb25uLnQgfCBgQ2xvc2Vfc3RhcnRlZCBdIEl2YXIudFxuICAgICAgOyBtdXRhYmxlIG5leHRfY29ubmVjdF9yZXN1bHQgOiBDb25uLnQgT3JfZXJyb3IudCBJdmFyLnRcbiAgICAgIDsgZXZlbnRfaGFuZGxlciA6ICdhZGRyZXNzIEV2ZW50LkhhbmRsZXIudFxuICAgICAgOyBjbG9zZV9zdGFydGVkIDogdW5pdCBJdmFyLnRcbiAgICAgIDsgY2xvc2VfZmluaXNoZWQgOiB1bml0IEl2YXIudFxuICAgICAgOyBkb24ndF9yZWNvbm5lY3QgOiB1bml0IEl2YXIudFxuICAgICAgOyBhZGRyZXNzX2VxdWFsIDogJ2FkZHJlc3MgLT4gJ2FkZHJlc3MgLT4gYm9vbFxuICAgICAgOyBzZXhwX29mX2FkZHJlc3MgOiAnYWRkcmVzcyAtPiBTZXhwLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgc2VydmVyX25hbWUgdCA9IHQuZXZlbnRfaGFuZGxlci5zZXJ2ZXJfbmFtZVxuICAgIGxldCBoYW5kbGVfZXZlbnQgdCBldmVudCA9IEV2ZW50LmhhbmRsZSBldmVudCB0LmV2ZW50X2hhbmRsZXJcblxuICAgICgqIFRoaXMgZnVuY3Rpb24gZm9jdXNlcyBpbiBvbiB0aGUgdGhlIGVycm9yIGl0c2VsZiwgZGlzY2FyZGluZyBpbmZvcm1hdGlvbiBhYm91dCB3aGljaFxuICAgICAgIG1vbml0b3IgY2F1Z2h0IHRoZSBlcnJvciwgaWYgYW55LlxuXG4gICAgICAgSWYgd2UgZG9uJ3QgZG8gdGhpcywgd2Ugc29tZXRpbWVzIGVuZCB1cCB3aXRoIG5vaXN5IGxvZ3Mgd2hpY2ggcmVwb3J0IHRoZSBzYW1lIGVycm9yXG4gICAgICAgYWdhaW4gYW5kIGFnYWluLCBkaWZmZXJpbmcgb25seSBhcyB0byB3aGF0IG1vbml0b3IgY2F1Z2h0IHRoZW0uICopXG4gICAgbGV0IHNhbWVfZXJyb3IgZTEgZTIgPVxuICAgICAgbGV0IHRvX3NleHAgZSA9IEV4bi5zZXhwX29mX3QgKE1vbml0b3IuZXh0cmFjdF9leG4gKEVycm9yLnRvX2V4biBlKSkgaW5cbiAgICAgIFNleHAuZXF1YWwgKHRvX3NleHAgZTEpICh0b19zZXhwIGUyKVxuICAgIDs7XG5cbiAgICAoKiBDb250aW51ZSB0cnlpbmcgdG8gY29ubmVjdCB1bnRpbCB3ZSBhcmUgYWJsZSB0byBkbyBzbywgaW4gd2hpY2ggY2FzZSB3ZSByZXR1cm4gYm90aFxuICAgICAgIHRoZSBuZXcgY29ubmVjdGlvbiBhbmQgYSBkZWZlcnJlZCB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgb25jZSB3ZSBhcmUgcmVhZHkgZm9yXG4gICAgICAgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQuICopXG4gICAgbGV0IHRyeV9jb25uZWN0aW5nX3VudGlsX3N1Y2Nlc3NmdWwgdCA9XG4gICAgICAoKiBXZSB0YWtlIGNhcmUgbm90IHRvIHNwYW0gbG9ncyB3aXRoIHRoZSBzYW1lIG1lc3NhZ2Ugb3ZlciBhbmQgb3ZlciBieSBjb21wYXJpbmdcbiAgICAgICAgIGVhY2ggbG9nIG1lc3NhZ2UgdGhlIHRoZSBwcmV2aW91cyBvbmUgb2YgdGhlIHNhbWUgdHlwZS4gKilcbiAgICAgIGxldCBwcmV2aW91c19hZGRyZXNzID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCBwcmV2aW91c19lcnJvciA9IHJlZiBOb25lIGluXG4gICAgICBsZXQgY29ubmVjdCAoKSA9XG4gICAgICAgIHQuZ2V0X2FkZHJlc3MgKClcbiAgICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgRXJyb3IgZSAtPiByZXR1cm4gKEVycm9yIGUpXG4gICAgICAgIHwgT2sgYWRkciAtPlxuICAgICAgICAgIGxldCBzYW1lX2FzX3ByZXZpb3VzX2FkZHJlc3MgPVxuICAgICAgICAgICAgbWF0Y2ggIXByZXZpb3VzX2FkZHJlc3Mgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgICAgICB8IFNvbWUgcHJldmlvdXNfYWRkcmVzcyAtPiB0LmFkZHJlc3NfZXF1YWwgYWRkciBwcmV2aW91c19hZGRyZXNzXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmV2aW91c19hZGRyZXNzIDo9IFNvbWUgYWRkcjtcbiAgICAgICAgICAoaWYgc2FtZV9hc19wcmV2aW91c19hZGRyZXNzXG4gICAgICAgICAgIHRoZW4gRGVmZXJyZWQudW5pdFxuICAgICAgICAgICBlbHNlIGhhbmRsZV9ldmVudCB0IChPYnRhaW5lZF9hZGRyZXNzIGFkZHIpKVxuICAgICAgICAgID4+PSBmdW4gKCkgLT4gdC5jb25uZWN0IGFkZHJcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgIHRoZW4gcmV0dXJuIGBDbG9zZV9zdGFydGVkXG4gICAgICAgIGVsc2UgaWYgSXZhci5pc19mdWxsIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgIHRoZW4gcmV0dXJuIGBEb24ndF9yZWNvbm5lY3RcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmcgPSB0LnJldHJ5X2RlbGF5ICgpIGluXG4gICAgICAgICAgbGV0JWJpbmQgY29ubmVjdF9yZXN1bHQgPSBjb25uZWN0ICgpIGluXG4gICAgICAgICAgSXZhci5maWxsIHQubmV4dF9jb25uZWN0X3Jlc3VsdCBjb25uZWN0X3Jlc3VsdDtcbiAgICAgICAgICB0Lm5leHRfY29ubmVjdF9yZXN1bHQgPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgICAgICAgbWF0Y2ggY29ubmVjdF9yZXN1bHQgd2l0aFxuICAgICAgICAgIHwgT2sgY29ubiAtPiByZXR1cm4gKGBPayAoY29ubiwgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZykpXG4gICAgICAgICAgfCBFcnJvciBlcnIgLT5cbiAgICAgICAgICAgIGxldCBzYW1lX2FzX3ByZXZpb3VzX2Vycm9yID1cbiAgICAgICAgICAgICAgbWF0Y2ggIXByZXZpb3VzX2Vycm9yIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgICAgICAgIHwgU29tZSBwcmV2aW91c19lcnIgLT4gc2FtZV9lcnJvciBlcnIgcHJldmlvdXNfZXJyXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgcHJldmlvdXNfZXJyb3IgOj0gU29tZSBlcnI7XG4gICAgICAgICAgICAoaWYgc2FtZV9hc19wcmV2aW91c19lcnJvclxuICAgICAgICAgICAgIHRoZW4gRGVmZXJyZWQudW5pdFxuICAgICAgICAgICAgIGVsc2UgaGFuZGxlX2V2ZW50IHQgKEZhaWxlZF90b19jb25uZWN0IGVycikpXG4gICAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgICBEZWZlcnJlZC5hbnlcbiAgICAgICAgICAgICAgWyByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA+Pj0gZnVuICgpIC0+IGxvb3AgKCkpXG4gICAgICBpblxuICAgICAgbG9vcCAoKVxuICAgIDs7XG5cbiAgICBsZXQgYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0aXZlX2Nvbm5lY3Rpb24gdCA9XG4gICAgICBJdmFyLmZpbGwgdC5jbG9zZV9zdGFydGVkICgpO1xuICAgICAgSXZhci5maWxsIHQuY2xvc2VfZmluaXNoZWQgKCk7XG4gICAgICBJdmFyLmZpbGwgdC5jb25uIGBDbG9zZV9zdGFydGVkXG4gICAgOztcblxuICAgIGxldCBjcmVhdGVcbiAgICAgICAgICAodHlwZSBhZGRyZXNzKVxuICAgICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICAgID8ob25fZXZlbnQgPSBmdW4gXyAtPiBEZWZlcnJlZC51bml0KVxuICAgICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICAgID8ocmFuZG9tX3N0YXRlID0gYFN0YXRlIFJhbmRvbS5TdGF0ZS5kZWZhdWx0KVxuICAgICAgICAgID8odGltZV9zb3VyY2UgPSBUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpKVxuICAgICAgICAgIH5jb25uZWN0XG4gICAgICAgICAgfmFkZHJlc3M6KG1vZHVsZSBBZGRyZXNzIDogQWRkcmVzcyB3aXRoIHR5cGUgdCA9IGFkZHJlc3MpXG4gICAgICAgICAgZ2V0X2FkZHJlc3NcbiAgICAgID1cbiAgICAgIGxldCBldmVudF9oYW5kbGVyID0geyBFdmVudC5IYW5kbGVyLnNlcnZlcl9uYW1lOyBvbl9ldmVudCB9IGluXG4gICAgICBsZXQgZGVmYXVsdF9yZXRyeV9kZWxheSA9XG4gICAgICAgIEZuLmNvbnN0IChUaW1lX25zLlNwYW4ub2Zfc2VjIChpZiBhbV9ydW5uaW5nX3Rlc3QgdGhlbiAwLjEgZWxzZSAxMC4pKVxuICAgICAgaW5cbiAgICAgIGxldCBub25fcmFuZG9taXplZF9kZWxheSA9IE9wdGlvbi52YWx1ZSByZXRyeV9kZWxheSB+ZGVmYXVsdDpkZWZhdWx0X3JldHJ5X2RlbGF5IGluXG4gICAgICBsZXQgcmV0cnlfZGVsYXlfc3BhbiA9XG4gICAgICAgIG1hdGNoIHJhbmRvbV9zdGF0ZSB3aXRoXG4gICAgICAgIHwgYE5vbl9yYW5kb20gLT4gbm9uX3JhbmRvbWl6ZWRfZGVsYXlcbiAgICAgICAgfCBgU3RhdGUgcmFuZG9tX3N0YXRlIC0+XG4gICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG5vbl9yYW5kb21pemVkX2RlbGF5ICgpIGluXG4gICAgICAgICAgICBsZXQgc3BhbiA9IFRpbWVfbnMuU3Bhbi50b19zZWMgc3BhbiBpblxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gUmFuZG9tLlN0YXRlLmZsb2F0IHJhbmRvbV9zdGF0ZSAoc3BhbiAqLiAwLjMpIGluXG4gICAgICAgICAgICBsZXQgd2FpdCA9XG4gICAgICAgICAgICAgIGlmIFJhbmRvbS5TdGF0ZS5ib29sIHJhbmRvbV9zdGF0ZVxuICAgICAgICAgICAgICB0aGVuIHNwYW4gKy4gZGlzdGFuY2VcbiAgICAgICAgICAgICAgZWxzZSBzcGFuIC0uIGRpc3RhbmNlXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgVGltZV9ucy5TcGFuLm9mX3NlYyB3YWl0XG4gICAgICBpblxuICAgICAgbGV0IHJldHJ5X2RlbGF5ICgpID0gVGltZV9zb3VyY2UuYWZ0ZXIgdGltZV9zb3VyY2UgKHJldHJ5X2RlbGF5X3NwYW4gKCkpIGluXG4gICAgICBsZXQgdCA9XG4gICAgICAgIHsgZXZlbnRfaGFuZGxlclxuICAgICAgICA7IGdldF9hZGRyZXNzXG4gICAgICAgIDsgY29ubmVjdFxuICAgICAgICA7IG5leHRfY29ubmVjdF9yZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IHJldHJ5X2RlbGF5XG4gICAgICAgIDsgY29ubiA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgY2xvc2Vfc3RhcnRlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgY2xvc2VfZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGRvbid0X3JlY29ubmVjdCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgYWRkcmVzc19lcXVhbCA9IEFkZHJlc3MuZXF1YWxcbiAgICAgICAgOyBzZXhwX29mX2FkZHJlc3MgPSBBZGRyZXNzLnNleHBfb2ZfdFxuICAgICAgICB9XG4gICAgICBpblxuICAgICAgKCogdGhpcyBsb29wIGZpbmlzaGVzIG9uY2UgW2Nsb3NlIHRdIGhhcyBiZWVuIGNhbGxlZCwgaW4gd2hpY2ggY2FzZSBpdCBtYWtlcyBzdXJlIHRvXG4gICAgICAgICBsZWF2ZSBbdC5jb25uXSBmaWxsZWQgd2l0aCBbYENsb3NlX3N0YXJ0ZWRdLiAqKVxuICAgICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgIEBAIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAoKSAoZnVuICgpIC0+XG4gICAgICAgIGhhbmRsZV9ldmVudCB0IEF0dGVtcHRpbmdfdG9fY29ubmVjdFxuICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgIHRyeV9jb25uZWN0aW5nX3VudGlsX3N1Y2Nlc3NmdWwgdFxuICAgICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPlxuICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWQ7XG4gICAgICAgICAgcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYERvbid0X3JlY29ubmVjdCAtPlxuICAgICAgICAgIGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQ7XG4gICAgICAgICAgcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYE9rIChjb25uLCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nKSAtPlxuICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gKGBPayBjb25uKTtcbiAgICAgICAgICBoYW5kbGVfZXZlbnQgdCAoQ29ubmVjdGVkIGNvbm4pXG4gICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgIENvbm4uY2xvc2VfZmluaXNoZWQgY29ublxuICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICB0LmNvbm4gPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgICAgICAgaGFuZGxlX2V2ZW50IHQgRGlzY29ubmVjdGVkXG4gICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICgqIHdhaXRzIHVudGlsIFtyZXRyeV9kZWxheSAoKV0gdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSB0aW1lIGp1c3QgYmVmb3JlIHdlIGxhc3RcbiAgICAgICAgICAgICB0cmllZCB0byBjb25uZWN0IHJhdGhlciB0aGFuIHRoZSB0aW1lIHdlIG5vdGljZWQgYmVpbmcgZGlzY29ubmVjdGVkLCBzbyB0aGF0IGlmXG4gICAgICAgICAgICAgYSBsb25nLWxpdmVkIGNvbm5lY3Rpb24gZGllcywgd2Ugd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCBpbW1lZGlhdGVseS4gKilcbiAgICAgICAgICBsZXQlbWFwICgpID1cbiAgICAgICAgICAgIERlZmVycmVkLmFueVxuICAgICAgICAgICAgICBbIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWQ7XG4gICAgICAgICAgICBgRmluaXNoZWQgKCkpXG4gICAgICAgICAgZWxzZSBpZiBJdmFyLmlzX2Z1bGwgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQ7XG4gICAgICAgICAgICBgRmluaXNoZWQgKCkpXG4gICAgICAgICAgZWxzZSBgUmVwZWF0ICgpKTtcbiAgICAgIHRcbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZCB0ID1cbiAgICAgICgqIFRha2UgY2FyZSBub3QgdG8gcmV0dXJuIGEgY29ubmVjdGlvbiB0aGF0IGlzIGtub3duIHRvIGJlIGNsb3NlZCBhdCB0aGUgdGltZVxuICAgICAgICAgW2Nvbm5lY3RlZF0gd2FzIGNhbGxlZC4gIFRoaXMgY291bGQgaGFwcGVuIGluIGNsaWVudCBjb2RlIHRoYXQgYmVoYXZlcyBsaWtlXG4gICAgICAgICB7W1xuICAgICAgICAgICBQZXJzaXN0ZW50X2Nvbm5lY3Rpb24uUnBjLmNvbm5lY3RlZCB0XG4gICAgICAgICAgID4+PSBmdW4gYzEgLT5cbiAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgUnBjLkNvbm5lY3Rpb24uY2xvc2VfZmluaXNoZWQgYzFcbiAgICAgICAgICAgKCogYXQgdGhpcyBwb2ludCB3ZSBhcmUgaW4gYSByYWNlIHdpdGggdGhlIHNhbWUgY2FsbCBpbnNpZGVcbiAgICAgICAgICAgICAgcGVyc2lzdGVudF9jbGllbnQubWwgKilcbiAgICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICBQZXJzaXN0ZW50X2Nvbm5lY3Rpb24uUnBjLmNvbm5lY3RlZCB0XG4gICAgICAgICAgICgqIGRlcGVuZGluZyBvbiBob3cgdGhlIHJhY2UgdHVybnMgb3V0LCB3ZSBkb24ndCB3YW50IHRvIGdldCBhIGNsb3NlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgIGhlcmUgKilcbiAgICAgICAgICAgPj49IGZ1biBjMiAtPlxuICAgICAgICAgICAuLi5cbiAgICAgICAgIF19XG4gICAgICAgICBUaGlzIGRvZXNuJ3QgcmVtb3ZlIHRoZSByYWNlIGNvbmRpdGlvbiwgYnV0IGl0IG1ha2VzIGl0IGxlc3MgbGlrZWx5IHRvIGhhcHBlbi5cbiAgICAgICopXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBsZXQgZCA9IEl2YXIucmVhZCB0LmNvbm4gaW5cbiAgICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayBkIHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgZFxuICAgICAgICAgID4+PSAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgYENsb3NlX3N0YXJ0ZWQgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICAgICAgICAgIHwgYE9rIGNvbm4gLT4gcmV0dXJuIGNvbm4pXG4gICAgICAgIHwgU29tZSBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICB8IFNvbWUgKGBPayBjb25uKSAtPlxuICAgICAgICAgIGlmIENvbm4uaXNfY2xvc2VkIGNvbm5cbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoKiBnaXZlIHRoZSByZWNvbm5lY3Rpb24gbG9vcCBhIGNoYW5jZSB0byBvdmVyd3JpdGUgdGhlIGl2YXIgKilcbiAgICAgICAgICAgIENvbm4uY2xvc2VfZmluaXNoZWQgY29ubiA+Pj0gbG9vcFxuICAgICAgICAgIGVsc2UgcmV0dXJuIGNvbm5cbiAgICAgIGluXG4gICAgICBsb29wICgpXG4gICAgOztcblxuICAgIGxldCBjdXJyZW50X2Nvbm5lY3Rpb24gdCA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgdC5jb25uKSB3aXRoXG4gICAgICB8IE5vbmUgfCBTb21lIGBDbG9zZV9zdGFydGVkIC0+IE5vbmVcbiAgICAgIHwgU29tZSAoYE9rIGNvbm4pIC0+IFNvbWUgY29ublxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VfZmluaXNoZWQgdCA9IEl2YXIucmVhZCB0LmNsb3NlX2ZpbmlzaGVkXG4gICAgbGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuXG4gICAgbGV0IGNsb3NlIHQgPVxuICAgICAgaWYgSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgdGhlblxuICAgICAgICAoKiBBbm90aGVyIGNhbGwgdG8gY2xvc2UgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4gIFdhaXQgZm9yIGl0IHRvIGZpbmlzaC4gKilcbiAgICAgICAgY2xvc2VfZmluaXNoZWQgdFxuICAgICAgZWxzZSAoXG4gICAgICAgIEl2YXIuZmlsbCB0LmNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICAgIEl2YXIucmVhZCB0LmNvbm5cbiAgICAgICAgPj49IGZ1biBjb25uX29wdCAtPlxuICAgICAgICAobWF0Y2ggY29ubl9vcHQgd2l0aFxuICAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC51bml0XG4gICAgICAgICB8IGBPayBjb25uIC0+IENvbm4uY2xvc2UgY29ubilcbiAgICAgICAgPj58IGZ1biAoKSAtPiBJdmFyLmZpbGwgdC5jbG9zZV9maW5pc2hlZCAoKSlcbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZCA9XG4gICAgICBPcl9lcnJvci5lcnJvcl9zIFslbWVzc2FnZSBcIlBlcnNpc3RlbnQgY29ubmVjdGlvbiBjbG9zZWRcIl1cbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCB0ID1cbiAgICAgIGlmIGlzX2Nsb3NlZCB0XG4gICAgICB0aGVuIHJldHVybiBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3RfY29ubmVjdGlvbl9jbG9zZWRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBjdXJyZW50X2Nvbm5lY3Rpb24gdCB3aXRoXG4gICAgICAgIHwgU29tZSB4IHdoZW4gbm90IChDb25uLmlzX2Nsb3NlZCB4KSAtPiByZXR1cm4gKE9rIHgpXG4gICAgICAgIHwgU29tZSAoXyA6IENvbm4udCkgfCBOb25lIC0+XG4gICAgICAgICAgRGVmZXJyZWQuY2hvb3NlXG4gICAgICAgICAgICBbIGNob2ljZSAoSXZhci5yZWFkIHQuY2xvc2Vfc3RhcnRlZCkgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZClcbiAgICAgICAgICAgIDsgY2hvaWNlIChJdmFyLnJlYWQgdC5uZXh0X2Nvbm5lY3RfcmVzdWx0KSBGbi5pZFxuICAgICAgICAgICAgXSlcbiAgICA7O1xuXG4gICAgbGV0IGNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCB0ID1cbiAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSB0LmRvbid0X3JlY29ubmVjdCAoKVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgdCA9IFQgOiAnYWRkcmVzcyBQb2x5LnQgLT4gdCBbQEB1bmJveGVkXVxuXG4gIGxldCBzZXhwX29mX3QgKFQgdCkgPSBQb2x5LnNleHBfb2ZfdCB0LnNleHBfb2ZfYWRkcmVzcyB0XG5cbiAgbGV0IGNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCAoVCB0KSA9XG4gICAgUG9seS5jbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl9pc19jbG9zZWQgdFxuICA7O1xuXG4gIGxldCBjbG9zZV9maW5pc2hlZCAoVCB0KSA9IFBvbHkuY2xvc2VfZmluaXNoZWQgdFxuICBsZXQgaXNfY2xvc2VkIChUIHQpID0gUG9seS5pc19jbG9zZWQgdFxuICBsZXQgY2xvc2UgKFQgdCkgPSBQb2x5LmNsb3NlIHRcbiAgbGV0IHNlcnZlcl9uYW1lIChUIHQpID0gUG9seS5zZXJ2ZXJfbmFtZSB0XG4gIGxldCBjdXJyZW50X2Nvbm5lY3Rpb24gKFQgdCkgPSBQb2x5LmN1cnJlbnRfY29ubmVjdGlvbiB0XG4gIGxldCBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QgKFQgdCkgPSBQb2x5LmNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCB0XG4gIGxldCBjb25uZWN0ZWQgKFQgdCkgPSBQb2x5LmNvbm5lY3RlZCB0XG5cbiAgbGV0IGNyZWF0ZVxuICAgICAgICB+c2VydmVyX25hbWVcbiAgICAgICAgP29uX2V2ZW50XG4gICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICA/cmFuZG9tX3N0YXRlXG4gICAgICAgID90aW1lX3NvdXJjZVxuICAgICAgICB+Y29ubmVjdFxuICAgICAgICB+YWRkcmVzc1xuICAgICAgICBnZXRfYWRkcmVzc1xuICAgID1cbiAgICBUXG4gICAgICAoUG9seS5jcmVhdGVcbiAgICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICAgP29uX2V2ZW50XG4gICAgICAgICA/cmV0cnlfZGVsYXlcbiAgICAgICAgID9yYW5kb21fc3RhdGVcbiAgICAgICAgID90aW1lX3NvdXJjZVxuICAgICAgICAgfmNvbm5lY3RcbiAgICAgICAgIH5hZGRyZXNzXG4gICAgICAgICBnZXRfYWRkcmVzcylcbiAgOztcbmVuZFxuIl19
